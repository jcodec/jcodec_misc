/**
 *  Interface for muxer track that many muxers implement.
 *  
 *  @author Stanislav Vitvitskiy
 */
var MuxerTrack = function() {};
MuxerTrack = stjs.extend(MuxerTrack, null, [], function(constructor, prototype) {
    prototype.addFrame = function(outPacket) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEGHeader = function() {};
MPEGHeader = stjs.extend(MPEGHeader, null, [], function(constructor, prototype) {
    prototype.write = function(bb) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Edit = function(duration, mediaTime, rate) {
    this.duration = duration;
    this.mediaTime = mediaTime;
    this.rate = rate;
};
Edit = stjs.extend(Edit, null, [], function(constructor, prototype) {
    constructor.createEdit = function(edit) {
        return new Edit(edit.duration, edit.mediaTime, edit.rate);
    };
    prototype.duration = 0;
    prototype.mediaTime = 0;
    prototype.rate = 0.0;
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getMediaTime = function() {
        return this.mediaTime;
    };
    prototype.getRate = function() {
        return this.rate;
    };
    prototype.shift = function(shift) {
        this.mediaTime += shift;
    };
    prototype.setMediaTime = function(l) {
        this.mediaTime = l;
    };
    prototype.setDuration = function(duration) {
        this.duration = duration;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Rect = function(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
};
Rect = stjs.extend(Rect, null, [], function(constructor, prototype) {
    prototype.x = 0;
    prototype.y = 0;
    prototype.width = 0;
    prototype.height = 0;
    prototype.getX = function() {
        return this.x;
    };
    prototype.getY = function() {
        return this.y;
    };
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.hashCode = function() {
        var prime = 31;
        var result = 1;
        result = prime * result + this.height;
        result = prime * result + this.width;
        result = prime * result + this.x;
        result = prime * result + this.y;
        return result;
    };
    prototype.equals = function(obj) {
        if (this == obj) 
            return true;
        if (obj == null) 
            return false;
        if (this.getClass() != obj.getClass()) 
            return false;
        var other = obj;
        if (this.height != other.height) 
            return false;
        if (this.width != other.width) 
            return false;
        if (this.x != other.x) 
            return false;
        if (this.y != other.y) 
            return false;
        return true;
    };
    prototype.toString = function() {
        return "Rect [x=" + this.x + ", y=" + this.y + ", width=" + this.width + ", height=" + this.height + "]";
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SliceType = function(name, ordinal) {
    this._name = name;
    this._ordinal = ordinal;
    SliceType._values[ordinal] = this;
};
SliceType = stjs.extend(SliceType, null, [], function(constructor, prototype) {
    constructor._values = Array(5);
    constructor.P = new SliceType("P", 0);
    constructor.B = new SliceType("B", 1);
    constructor.I = new SliceType("I", 2);
    constructor.SP = new SliceType("SP", 3);
    constructor.SI = new SliceType("SI", 4);
    prototype._name = null;
    prototype._ordinal = 0;
    prototype.isIntra = function() {
        return this == SliceType.I || this == SliceType.SI;
    };
    prototype.isInter = function() {
        return this != SliceType.I && this != SliceType.SI;
    };
    constructor.values = function() {
        return SliceType._values;
    };
    prototype.ordinal = function() {
        return this._ordinal;
    };
    prototype.toString = function() {
        return this._name;
    };
    prototype.name = function() {
        return this._name;
    };
    constructor.fromValue = function(j) {
        return SliceType.values()[j];
    };
}, {_values: "Array", P: "SliceType", B: "SliceType", I: "SliceType", SP: "SliceType", SI: "SliceType"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AudioFormat = function(sampleRate, sampleSizeInBits, channelCount, signed, bigEndian) {
    this.sampleRate = sampleRate;
    this.sampleSizeInBits = sampleSizeInBits;
    this.channelCount = channelCount;
    this.signed = signed;
    this.bigEndian = bigEndian;
};
AudioFormat = stjs.extend(AudioFormat, null, [], function(constructor, prototype) {
    prototype.sampleRate = 0;
    prototype.sampleSizeInBits = 0;
    prototype.channelCount = 0;
    prototype.signed = false;
    prototype.bigEndian = false;
    constructor.STEREO_48K_S16_BE = new AudioFormat(48000, 16, 2, true, true);
    constructor.STEREO_48K_S16_LE = new AudioFormat(48000, 16, 2, true, false);
    constructor.STEREO_48K_S24_BE = new AudioFormat(48000, 24, 2, true, true);
    constructor.STEREO_48K_S24_LE = new AudioFormat(48000, 24, 2, true, false);
    constructor.MONO_48K_S16_BE = new AudioFormat(48000, 16, 1, true, true);
    constructor.MONO_48K_S16_LE = new AudioFormat(48000, 16, 1, true, false);
    constructor.MONO_48K_S24_BE = new AudioFormat(48000, 24, 1, true, true);
    constructor.MONO_48K_S24_LE = new AudioFormat(48000, 24, 1, true, false);
    constructor.STEREO_44K_S16_BE = new AudioFormat(44100, 16, 2, true, true);
    constructor.STEREO_44K_S16_LE = new AudioFormat(44100, 16, 2, true, false);
    constructor.STEREO_44K_S24_BE = new AudioFormat(44100, 24, 2, true, true);
    constructor.STEREO_44K_S24_LE = new AudioFormat(44100, 24, 2, true, false);
    constructor.MONO_44K_S16_BE = new AudioFormat(44100, 16, 1, true, true);
    constructor.MONO_44K_S16_LE = new AudioFormat(44100, 16, 1, true, false);
    constructor.MONO_44K_S24_BE = new AudioFormat(44100, 24, 1, true, true);
    constructor.MONO_44K_S24_LE = new AudioFormat(44100, 24, 1, true, false);
    constructor.STEREO_S16_BE = function(rate) {
        return new AudioFormat(rate, 16, 2, true, true);
    };
    constructor.STEREO_S16_LE = function(rate) {
        return new AudioFormat(rate, 16, 2, true, false);
    };
    constructor.STEREO_S24_BE = function(rate) {
        return new AudioFormat(rate, 24, 2, true, true);
    };
    constructor.STEREO_S24_LE = function(rate) {
        return new AudioFormat(rate, 24, 2, true, false);
    };
    constructor.MONO_S16_BE = function(rate) {
        return new AudioFormat(rate, 16, 1, true, true);
    };
    constructor.MONO_S16_LE = function(rate) {
        return new AudioFormat(rate, 16, 1, true, false);
    };
    constructor.MONO_S24_BE = function(rate) {
        return new AudioFormat(rate, 24, 1, true, true);
    };
    constructor.MONO_S24_LE = function(rate) {
        return new AudioFormat(rate, 24, 1, true, false);
    };
    constructor.NCH_48K_S16_BE = function(n) {
        return new AudioFormat(48000, 16, n, true, true);
    };
    constructor.NCH_48K_S16_LE = function(n) {
        return new AudioFormat(48000, 16, n, true, false);
    };
    constructor.NCH_48K_S24_BE = function(n) {
        return new AudioFormat(48000, 24, n, true, true);
    };
    constructor.NCH_48K_S24_LE = function(n) {
        return new AudioFormat(48000, 24, n, true, false);
    };
    constructor.NCH_44K_S16_BE = function(n) {
        return new AudioFormat(44100, 16, n, true, true);
    };
    constructor.NCH_44K_S16_LE = function(n) {
        return new AudioFormat(44100, 16, n, true, false);
    };
    constructor.NCH_44K_S24_BE = function(n) {
        return new AudioFormat(44100, 24, n, true, true);
    };
    constructor.NCH_44K_S24_LE = function(n) {
        return new AudioFormat(44100, 24, n, true, false);
    };
    constructor.createAudioFormat = function(format) {
        return new AudioFormat(format.sampleRate, format.sampleSizeInBits, format.channelCount, format.signed, format.bigEndian);
    };
    constructor.createAudioFormat2 = function(format, newSampleRate) {
        var af = new AudioFormat(format.sampleRate, format.sampleSizeInBits, format.channelCount, format.signed, format.bigEndian);
        af.sampleRate = newSampleRate;
        return af;
    };
    prototype.getChannels = function() {
        return this.channelCount;
    };
    prototype.getSampleSizeInBits = function() {
        return this.sampleSizeInBits;
    };
    prototype.getSampleRate = function() {
        return this.sampleRate;
    };
    prototype.getFrameSize = function() {
        return ((((this.sampleSizeInBits >> 3) * this.channelCount)) << 16 >> 16);
    };
    prototype.getFrameRate = function() {
        return this.sampleRate;
    };
    prototype.isBigEndian = function() {
        return this.bigEndian;
    };
    prototype.isSigned = function() {
        return this.signed;
    };
    prototype.bytesToFrames = function(bytes) {
        return stjs.trunc(bytes / (this.channelCount * this.sampleSizeInBits >> 3));
    };
    prototype.framesToBytes = function(samples) {
        return samples * (this.channelCount * this.sampleSizeInBits >> 3);
    };
    prototype.bytesToSamples = function(bytes) {
        return stjs.trunc(bytes / (this.sampleSizeInBits >> 3));
    };
    prototype.samplesToBytes = function(samples) {
        return samples * (this.sampleSizeInBits >> 3);
    };
}, {STEREO_48K_S16_BE: "AudioFormat", STEREO_48K_S16_LE: "AudioFormat", STEREO_48K_S24_BE: "AudioFormat", STEREO_48K_S24_LE: "AudioFormat", MONO_48K_S16_BE: "AudioFormat", MONO_48K_S16_LE: "AudioFormat", MONO_48K_S24_BE: "AudioFormat", MONO_48K_S24_LE: "AudioFormat", STEREO_44K_S16_BE: "AudioFormat", STEREO_44K_S16_LE: "AudioFormat", STEREO_44K_S24_BE: "AudioFormat", STEREO_44K_S24_LE: "AudioFormat", MONO_44K_S16_BE: "AudioFormat", MONO_44K_S16_LE: "AudioFormat", MONO_44K_S24_BE: "AudioFormat", MONO_44K_S24_LE: "AudioFormat"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Decoded audio samples
 *  
 *  @author The JCodec project
 *  
 */
var AudioBuffer = function(data, format, nFrames) {
    this.data = data;
    this.format = format;
    this.nFrames = nFrames;
};
AudioBuffer = stjs.extend(AudioBuffer, null, [], function(constructor, prototype) {
    prototype.data = null;
    prototype.format = null;
    prototype.nFrames = 0;
    prototype.getData = function() {
        return this.data;
    };
    prototype.getFormat = function() {
        return this.format;
    };
    prototype.getNFrames = function() {
        return this.nFrames;
    };
}, {data: "ByteBuffer", format: "AudioFormat"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var CodecMeta = function(fourcc, codecPrivate) {
    this.fourcc = fourcc;
    this.codecPrivate = codecPrivate;
};
CodecMeta = stjs.extend(CodecMeta, null, [], function(constructor, prototype) {
    prototype.fourcc = null;
    prototype.codecPrivate = null;
    prototype.getFourcc = function() {
        return this.fourcc;
    };
    prototype.getCodecPrivate = function() {
        return this.codecPrivate;
    };
}, {codecPrivate: "ByteBuffer"}, {});
var FormatException = function(msg) {
    RuntimeException.call(this, msg);
};
FormatException = stjs.extend(FormatException, RuntimeException, [], null, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Size = function(width, height) {
    this.width = width;
    this.height = height;
};
Size = stjs.extend(Size, null, [], function(constructor, prototype) {
    prototype.width = 0;
    prototype.height = 0;
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.hashCode = function() {
        var prime = 31;
        var result = 1;
        result = prime * result + this.height;
        result = prime * result + this.width;
        return result;
    };
    prototype.equals = function(obj) {
        if (this == obj) 
            return true;
        if (obj == null) 
            return false;
        if (this.getClass() != obj.getClass()) 
            return false;
        var other = obj;
        if (this.height != other.height) 
            return false;
        if (this.width != other.width) 
            return false;
        return true;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Tape timecode
 *  
 *  @author The JCodec project
 *  
 */
var TapeTimecode = function(hour, minute, second, frame, dropFrame, tapeFps) {
    this.hour = hour;
    this.minute = minute;
    this.second = second;
    this.frame = frame;
    this.dropFrame = dropFrame;
    this.tapeFps = tapeFps;
};
TapeTimecode = stjs.extend(TapeTimecode, null, [], function(constructor, prototype) {
    constructor.ZERO_TAPE_TIMECODE = new TapeTimecode(((0) << 16 >> 16), (0 << 24 >> 24), (0 << 24 >> 24), (0 << 24 >> 24), false, 0);
    prototype.hour = 0;
    prototype.minute = 0;
    prototype.second = 0;
    prototype.frame = 0;
    prototype.dropFrame = false;
    prototype.tapeFps = 0;
    prototype.getHour = function() {
        return this.hour;
    };
    prototype.getMinute = function() {
        return this.minute;
    };
    prototype.getSecond = function() {
        return this.second;
    };
    prototype.getFrame = function() {
        return this.frame;
    };
    prototype.isDropFrame = function() {
        return this.dropFrame;
    };
    prototype.getTapeFps = function() {
        return this.tapeFps;
    };
    prototype.toString = function() {
        var tcfmt = this.dropFrame ? "%02d:%02d:%02d;%02d" : "%02d:%02d:%02d:%02d";
        return String.format(tcfmt, this.hour, this.minute, this.second, this.frame);
    };
    constructor.tapeTimecode = function(frame, dropFrame, tapeFps) {
        if (dropFrame) {
            var D = stjs.trunc(frame / 17982);
            var M = frame % 17982;
            frame += 18 * D + 2 * (stjs.trunc((M - 2) / 1798));
        }
        var sec = stjs.trunc(frame / tapeFps);
        return new TapeTimecode((((stjs.trunc(sec / 3600))) << 16 >> 16), (((stjs.trunc(sec / 60)) % 60) << 24 >> 24), ((sec % 60) << 24 >> 24), ((frame % tapeFps) << 24 >> 24), dropFrame, tapeFps);
    };
}, {ZERO_TAPE_TIMECODE: "TapeTimecode"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Meta information about this media track.
 *  
 *  @author The JCodec project
 *  
 */
var DemuxerTrackMeta = function(type, codec, totalDuration, seekFrames, totalFrames, codecPrivate, videoCodecMeta, audioCodecMeta) {
    this.type = type;
    this.codec = codec;
    this.totalDuration = totalDuration;
    this.seekFrames = seekFrames;
    this.totalFrames = totalFrames;
    this.codecPrivate = codecPrivate;
    this.videoCodecMeta = videoCodecMeta;
    this.audioCodecMeta = audioCodecMeta;
    this.orientation = DemuxerTrackMeta.Orientation.D_0;
};
DemuxerTrackMeta = stjs.extend(DemuxerTrackMeta, null, [], function(constructor, prototype) {
    prototype.type = null;
    prototype.codec = null;
    prototype.totalDuration = 0.0;
    prototype.seekFrames = null;
    prototype.totalFrames = 0;
    prototype.codecPrivate = null;
    prototype.videoCodecMeta = null;
    prototype.audioCodecMeta = null;
    prototype.index = 0;
    prototype.orientation = null;
    constructor.Orientation = stjs.enumeration("D_0", "D_90", "D_180", "D_270");
    prototype.getType = function() {
        return this.type;
    };
    prototype.getCodec = function() {
        return this.codec;
    };
    /**
     *  @return Total duration in seconds of the media track
     */
    prototype.getTotalDuration = function() {
        return this.totalDuration;
    };
    /**
     *  @return Array of frame indexes that can be used to seek to, i.e. which
     *          don't require any previous frames to be decoded. Is null when
     *          every frame is a seek frame.
     */
    prototype.getSeekFrames = function() {
        return this.seekFrames;
    };
    /**
     *  @return Total number of frames in this media track.
     */
    prototype.getTotalFrames = function() {
        return this.totalFrames;
    };
    prototype.getIndex = function() {
        return this.index;
    };
    prototype.getCodecPrivate = function() {
        return this.codecPrivate;
    };
    prototype.getVideoCodecMeta = function() {
        return this.videoCodecMeta;
    };
    prototype.getAudioCodecMeta = function() {
        return this.audioCodecMeta;
    };
    prototype.setOrientation = function(orientation) {
        this.orientation = orientation;
    };
    prototype.getOrientation = function() {
        return this.orientation;
    };
}, {type: {name: "Enum", arguments: ["TrackType"]}, codec: "Codec", seekFrames: "Int32Array", codecPrivate: "ByteBuffer", videoCodecMeta: "VideoCodecMeta", audioCodecMeta: "AudioCodecMeta", orientation: {name: "Enum", arguments: ["DemuxerTrackMeta.Orientation"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var DemuxerTrack = function() {};
DemuxerTrack = stjs.extend(DemuxerTrack, null, [], function(constructor, prototype) {
    prototype.nextFrame = function() {};
    prototype.getMeta = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var TransformHiBD = function() {};
TransformHiBD = stjs.extend(TransformHiBD, null, [], function(constructor, prototype) {
    constructor.Levels = stjs.enumeration("STUDIO", "PC");
    prototype.transform = function(src, dst) {};
}, {}, {});
var PixelStore = function() {};
PixelStore = stjs.extend(PixelStore, null, [], function(constructor, prototype) {
    constructor.LoanerPicture = function(picture, refCnt) {
        this.picture = picture;
        this.refCnt = refCnt;
    };
    constructor.LoanerPicture = stjs.extend(constructor.LoanerPicture, null, [], function(constructor, prototype) {
        prototype.picture = null;
        prototype.refCnt = 0;
        prototype.getPicture = function() {
            return this.picture;
        };
        prototype.getRefCnt = function() {
            return this.refCnt;
        };
        prototype.decRefCnt = function() {
            --this.refCnt;
        };
        prototype.unused = function() {
            return this.refCnt <= 0;
        };
        prototype.incRefCnt = function() {
            ++this.refCnt;
        };
    }, {picture: "Picture"}, {});
    prototype.getPicture = function(width, height, color) {};
    prototype.putBack = function(frame) {};
    prototype.retake = function(frame) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var SimpleIDCT10Bit = function() {};
SimpleIDCT10Bit = stjs.extend(SimpleIDCT10Bit, null, [], function(constructor, prototype) {
    constructor.ROUND_COL = 8192;
    constructor.ROUND_ROW = 32768;
    constructor.SHIFT_COL = 14;
    constructor.SHIFT_ROW = 16;
    constructor.C0 = 23170;
    constructor.C1 = 32138;
    constructor.C2 = 27246;
    constructor.C3 = 18205;
    constructor.C4 = 6393;
    constructor.C5 = 30274;
    constructor.C6 = 12540;
    constructor.W1 = 90901;
    constructor.W2 = 85627;
    constructor.W3 = 77062;
    constructor.W4 = 65535;
    constructor.W5 = 51491;
    constructor.W6 = 35468;
    constructor.W7 = 18081;
    constructor.ROW_SHIFT = 15;
    constructor.COL_SHIFT = 20;
    constructor.idct10 = function(buf, off) {
        for (var i = 0; i < 8; i++) 
            SimpleIDCT10Bit.idctRow(buf, off + (i << 3));
        for (var i = 0; i < 8; i++) 
            SimpleIDCT10Bit.idctCol(buf, off + i);
    };
    constructor.idctCol = function(buf, off) {
        var a0, a1, a2, a3, b0, b1, b2, b3;
        a0 = SimpleIDCT10Bit.W4 * (buf[off + 8 * 0] + (stjs.trunc((1 << (SimpleIDCT10Bit.COL_SHIFT - 1)) / SimpleIDCT10Bit.W4)));
        a1 = a0;
        a2 = a0;
        a3 = a0;
        a0 += SimpleIDCT10Bit.W2 * buf[off + 8 * 2];
        a1 += SimpleIDCT10Bit.W6 * buf[off + 8 * 2];
        a2 += -SimpleIDCT10Bit.W6 * buf[off + 8 * 2];
        a3 += -SimpleIDCT10Bit.W2 * buf[off + 8 * 2];
        b0 = SimpleIDCT10Bit.W1 * buf[off + 8 * 1];
        b1 = SimpleIDCT10Bit.W3 * buf[off + 8 * 1];
        b2 = SimpleIDCT10Bit.W5 * buf[off + 8 * 1];
        b3 = SimpleIDCT10Bit.W7 * buf[off + 8 * 1];
        b0 += SimpleIDCT10Bit.W3 * buf[off + 8 * 3];
        b1 += -SimpleIDCT10Bit.W7 * buf[off + 8 * 3];
        b2 += -SimpleIDCT10Bit.W1 * buf[off + 8 * 3];
        b3 += -SimpleIDCT10Bit.W5 * buf[off + 8 * 3];
        if (buf[off + 8 * 4] != 0) {
            a0 += SimpleIDCT10Bit.W4 * buf[off + 8 * 4];
            a1 += -SimpleIDCT10Bit.W4 * buf[off + 8 * 4];
            a2 += -SimpleIDCT10Bit.W4 * buf[off + 8 * 4];
            a3 += SimpleIDCT10Bit.W4 * buf[off + 8 * 4];
        }
        if (buf[off + 8 * 5] != 0) {
            b0 += SimpleIDCT10Bit.W5 * buf[off + 8 * 5];
            b1 += -SimpleIDCT10Bit.W1 * buf[off + 8 * 5];
            b2 += SimpleIDCT10Bit.W7 * buf[off + 8 * 5];
            b3 += SimpleIDCT10Bit.W3 * buf[off + 8 * 5];
        }
        if (buf[off + 8 * 6] != 0) {
            a0 += SimpleIDCT10Bit.W6 * buf[off + 8 * 6];
            a1 += -SimpleIDCT10Bit.W2 * buf[off + 8 * 6];
            a2 += SimpleIDCT10Bit.W2 * buf[off + 8 * 6];
            a3 += -SimpleIDCT10Bit.W6 * buf[off + 8 * 6];
        }
        if (buf[off + 8 * 7] != 0) {
            b0 += SimpleIDCT10Bit.W7 * buf[off + 8 * 7];
            b1 += -SimpleIDCT10Bit.W5 * buf[off + 8 * 7];
            b2 += SimpleIDCT10Bit.W3 * buf[off + 8 * 7];
            b3 += -SimpleIDCT10Bit.W1 * buf[off + 8 * 7];
        }
        buf[off] = ((a0 + b0) >> SimpleIDCT10Bit.COL_SHIFT);
        buf[off + 8] = ((a1 + b1) >> SimpleIDCT10Bit.COL_SHIFT);
        buf[off + 16] = ((a2 + b2) >> SimpleIDCT10Bit.COL_SHIFT);
        buf[off + 24] = ((a3 + b3) >> SimpleIDCT10Bit.COL_SHIFT);
        buf[off + 32] = ((a3 - b3) >> SimpleIDCT10Bit.COL_SHIFT);
        buf[off + 40] = ((a2 - b2) >> SimpleIDCT10Bit.COL_SHIFT);
        buf[off + 48] = ((a1 - b1) >> SimpleIDCT10Bit.COL_SHIFT);
        buf[off + 56] = ((a0 - b0) >> SimpleIDCT10Bit.COL_SHIFT);
    };
    constructor.idctRow = function(buf, off) {
        var a0, a1, a2, a3, b0, b1, b2, b3;
        a0 = (SimpleIDCT10Bit.W4 * buf[off]) + (1 << (SimpleIDCT10Bit.ROW_SHIFT - 1));
        a1 = a0;
        a2 = a0;
        a3 = a0;
        a0 += SimpleIDCT10Bit.W2 * buf[off + 2];
        a1 += SimpleIDCT10Bit.W6 * buf[off + 2];
        a2 -= SimpleIDCT10Bit.W6 * buf[off + 2];
        a3 -= SimpleIDCT10Bit.W2 * buf[off + 2];
        b0 = SimpleIDCT10Bit.W1 * buf[off + 1];
        b0 += SimpleIDCT10Bit.W3 * buf[off + 3];
        b1 = SimpleIDCT10Bit.W3 * buf[off + 1];
        b1 += -SimpleIDCT10Bit.W7 * buf[off + 3];
        b2 = SimpleIDCT10Bit.W5 * buf[off + 1];
        b2 += -SimpleIDCT10Bit.W1 * buf[off + 3];
        b3 = SimpleIDCT10Bit.W7 * buf[off + 1];
        b3 += -SimpleIDCT10Bit.W5 * buf[off + 3];
        if (buf[off + 4] != 0 || buf[off + 5] != 0 || buf[off + 6] != 0 || buf[off + 7] != 0) {
            a0 += SimpleIDCT10Bit.W4 * buf[off + 4] + SimpleIDCT10Bit.W6 * buf[off + 6];
            a1 += -SimpleIDCT10Bit.W4 * buf[off + 4] - SimpleIDCT10Bit.W2 * buf[off + 6];
            a2 += -SimpleIDCT10Bit.W4 * buf[off + 4] + SimpleIDCT10Bit.W2 * buf[off + 6];
            a3 += SimpleIDCT10Bit.W4 * buf[off + 4] - SimpleIDCT10Bit.W6 * buf[off + 6];
            b0 += SimpleIDCT10Bit.W5 * buf[off + 5];
            b0 += SimpleIDCT10Bit.W7 * buf[off + 7];
            b1 += -SimpleIDCT10Bit.W1 * buf[off + 5];
            b1 += -SimpleIDCT10Bit.W5 * buf[off + 7];
            b2 += SimpleIDCT10Bit.W7 * buf[off + 5];
            b2 += SimpleIDCT10Bit.W3 * buf[off + 7];
            b3 += SimpleIDCT10Bit.W3 * buf[off + 5];
            b3 += -SimpleIDCT10Bit.W1 * buf[off + 7];
        }
        buf[off + 0] = (a0 + b0) >> SimpleIDCT10Bit.ROW_SHIFT;
        buf[off + 7] = (a0 - b0) >> SimpleIDCT10Bit.ROW_SHIFT;
        buf[off + 1] = (a1 + b1) >> SimpleIDCT10Bit.ROW_SHIFT;
        buf[off + 6] = (a1 - b1) >> SimpleIDCT10Bit.ROW_SHIFT;
        buf[off + 2] = (a2 + b2) >> SimpleIDCT10Bit.ROW_SHIFT;
        buf[off + 5] = (a2 - b2) >> SimpleIDCT10Bit.ROW_SHIFT;
        buf[off + 3] = (a3 + b3) >> SimpleIDCT10Bit.ROW_SHIFT;
        buf[off + 4] = (a3 - b3) >> SimpleIDCT10Bit.ROW_SHIFT;
    };
    constructor.fdctProres10 = function(block, off) {
        for (var j = 0; j < 8; ++j) {
            SimpleIDCT10Bit.fdctCol(block, off + j);
        }
        for (var i = 0; i < 64; i += 8) {
            SimpleIDCT10Bit.fdctRow(block, off + i);
        }
    };
    constructor.fdctRow = function(block, off) {
        var z0 = block[off + 0] - block[off + 7];
        var z1 = block[off + 1] - block[off + 6];
        var z2 = block[off + 2] - block[off + 5];
        var z3 = block[off + 3] - block[off + 4];
        var z4 = block[off + 0] + block[off + 7];
        var z5 = block[off + 3] + block[off + 4];
        var z6 = block[off + 1] + block[off + 6];
        var z7 = block[off + 2] + block[off + 5];
        var u0 = z4 - z5;
        var u1 = z6 - z7;
        var c0 = (z4 + z5) * SimpleIDCT10Bit.C0;
        var c1 = (z6 + z7) * SimpleIDCT10Bit.C0;
        var c2 = u0 * SimpleIDCT10Bit.C5;
        var c3 = u1 * SimpleIDCT10Bit.C6;
        var c4 = u0 * SimpleIDCT10Bit.C6;
        var c5 = u1 * SimpleIDCT10Bit.C5;
        block[1 + off] = (z0 * SimpleIDCT10Bit.C1 + z1 * SimpleIDCT10Bit.C2 + z2 * SimpleIDCT10Bit.C3 + z3 * SimpleIDCT10Bit.C4 + SimpleIDCT10Bit.ROUND_ROW) >> SimpleIDCT10Bit.SHIFT_ROW;
        block[3 + off] = (z0 * SimpleIDCT10Bit.C2 - z1 * SimpleIDCT10Bit.C4 - z2 * SimpleIDCT10Bit.C1 - z3 * SimpleIDCT10Bit.C3 + SimpleIDCT10Bit.ROUND_ROW) >> SimpleIDCT10Bit.SHIFT_ROW;
        block[5 + off] = (z0 * SimpleIDCT10Bit.C3 - z1 * SimpleIDCT10Bit.C1 + z2 * SimpleIDCT10Bit.C4 + z3 * SimpleIDCT10Bit.C2 + SimpleIDCT10Bit.ROUND_ROW) >> SimpleIDCT10Bit.SHIFT_ROW;
        block[7 + off] = (z0 * SimpleIDCT10Bit.C4 - z1 * SimpleIDCT10Bit.C3 + z2 * SimpleIDCT10Bit.C2 - z3 * SimpleIDCT10Bit.C1 + SimpleIDCT10Bit.ROUND_ROW) >> SimpleIDCT10Bit.SHIFT_ROW;
        block[0 + off] = (c0 + c1 + SimpleIDCT10Bit.ROUND_ROW) >> SimpleIDCT10Bit.SHIFT_ROW;
        block[2 + off] = (c2 + c3 + SimpleIDCT10Bit.ROUND_ROW) >> SimpleIDCT10Bit.SHIFT_ROW;
        block[4 + off] = (c0 - c1 + SimpleIDCT10Bit.ROUND_ROW) >> SimpleIDCT10Bit.SHIFT_ROW;
        block[6 + off] = (c4 - c5 + SimpleIDCT10Bit.ROUND_ROW) >> SimpleIDCT10Bit.SHIFT_ROW;
    };
    constructor.fdctCol = function(block, off) {
        var z0 = block[off + 0] - block[off + 56];
        var z1 = block[off + 8] - block[off + 48];
        var z2 = block[off + 16] - block[off + 40];
        var z3 = block[off + 24] - block[off + 32];
        var z4 = block[off + 0] + block[off + 56];
        var z5 = block[off + 24] + block[off + 32];
        var z6 = block[off + 8] + block[off + 48];
        var z7 = block[off + 16] + block[off + 40];
        var u0 = z4 - z5;
        var u1 = z6 - z7;
        var c0 = (z4 + z5) * SimpleIDCT10Bit.C0;
        var c1 = (z6 + z7) * SimpleIDCT10Bit.C0;
        var c2 = u0 * SimpleIDCT10Bit.C5;
        var c3 = u1 * SimpleIDCT10Bit.C6;
        var c4 = u0 * SimpleIDCT10Bit.C6;
        var c5 = u1 * SimpleIDCT10Bit.C5;
        block[8 + off] = (z0 * SimpleIDCT10Bit.C1 + z1 * SimpleIDCT10Bit.C2 + z2 * SimpleIDCT10Bit.C3 + z3 * SimpleIDCT10Bit.C4 + SimpleIDCT10Bit.ROUND_COL) >> SimpleIDCT10Bit.SHIFT_COL;
        block[24 + off] = (z0 * SimpleIDCT10Bit.C2 - z1 * SimpleIDCT10Bit.C4 - z2 * SimpleIDCT10Bit.C1 - z3 * SimpleIDCT10Bit.C3 + SimpleIDCT10Bit.ROUND_COL) >> SimpleIDCT10Bit.SHIFT_COL;
        block[40 + off] = (z0 * SimpleIDCT10Bit.C3 - z1 * SimpleIDCT10Bit.C1 + z2 * SimpleIDCT10Bit.C4 + z3 * SimpleIDCT10Bit.C2 + SimpleIDCT10Bit.ROUND_COL) >> SimpleIDCT10Bit.SHIFT_COL;
        block[56 + off] = (z0 * SimpleIDCT10Bit.C4 - z1 * SimpleIDCT10Bit.C3 + z2 * SimpleIDCT10Bit.C2 - z3 * SimpleIDCT10Bit.C1 + SimpleIDCT10Bit.ROUND_COL) >> SimpleIDCT10Bit.SHIFT_COL;
        block[0 + off] = (c0 + c1 + SimpleIDCT10Bit.ROUND_COL) >> SimpleIDCT10Bit.SHIFT_COL;
        block[16 + off] = (c2 + c3 + SimpleIDCT10Bit.ROUND_COL) >> SimpleIDCT10Bit.SHIFT_COL;
        block[32 + off] = (c0 - c1 + SimpleIDCT10Bit.ROUND_COL) >> SimpleIDCT10Bit.SHIFT_COL;
        block[48 + off] = (c4 - c5 + SimpleIDCT10Bit.ROUND_COL) >> SimpleIDCT10Bit.SHIFT_COL;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MathUtil = function() {};
MathUtil = stjs.extend(MathUtil, null, [], function(constructor, prototype) {
    constructor.logTab = new Int32Array([0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]);
    constructor.reverseTab = new Int32Array([0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255]);
    constructor.log2 = function(v) {
        var n = 0;
        if ((v & -65536) != 0) {
            v >>= 16;
            n += 16;
        }
        if ((v & 65280) != 0) {
            v >>= 8;
            n += 8;
        }
        n += MathUtil.logTab[v];
        return n;
    };
    constructor.log2l = function(v) {
        var n = 0;
        if ((v & -4294967296) != 0) {
            v >>= 32;
            n += 32;
        }
        if ((v & 4294901760) != 0) {
            v >>= 16;
            n += 16;
        }
        if ((v & 65280) != 0) {
            v >>= 8;
            n += 8;
        }
        n += MathUtil.logTab[((v) | 0)];
        return n;
    };
    constructor.log2Slow = function(val) {
        var i = 0;
         while ((val & -2147483648) == 0){
            val <<= 1;
            i++;
        }
        return 31 - i;
    };
    constructor.gcd = function(a, b) {
        if (b != 0) 
            return MathUtil.gcd(b, a % b);
         else 
            return a;
    };
    constructor.gcdLong = function(a, b) {
        if (b != 0) 
            return MathUtil.gcdLong(b, a % b);
         else 
            return a;
    };
    constructor.clip = function(val, from, to) {
        return val < from ? from : (val > to ? to : val);
    };
    constructor.clipMax = function(val, max) {
        return val < max ? val : max;
    };
    constructor.cubeRoot = function(n) {
        return 0;
    };
    constructor.reverse = function(b) {
        return MathUtil.reverseTab[b & 255];
    };
    constructor.nextPowerOfTwo = function(n) {
        n = n - 1;
        n = n | (n >> 1);
        n = n | (n >> 2);
        n = n | (n >> 4);
        n = n | (n >> 8);
        n = n | (n >> 16);
        n = n + 1;
        return n;
    };
    constructor.abs = function(val) {
        var sign = (val >> 31);
        return (val ^ sign) - sign;
    };
    constructor.golomb = function(signedLevel) {
        if (signedLevel == 0) 
            return 0;
        return (MathUtil.abs(signedLevel) << 1) - (~signedLevel >>> 31);
    };
    constructor.toSigned = function(val, sign) {
        return (val ^ sign) - sign;
    };
    constructor.sign = function(val) {
        return -(val >> 31);
    };
    constructor.wrap = function(picNo, maxFrames) {
        return picNo < 0 ? picNo + maxFrames : (picNo >= maxFrames ? picNo - maxFrames : picNo);
    };
    constructor.max3 = function(a, b, c) {
        return Math.max(Math.max(a, b), c);
    };
}, {logTab: "Int32Array", reverseTab: "Int32Array"}, {});
var PESPacket = function(data, pts, streamId, length, pos, dts) {
    this.data = data;
    this.pts = pts;
    this.streamId = streamId;
    this.length = length;
    this.pos = pos;
    this.dts = dts;
};
PESPacket = stjs.extend(PESPacket, null, [], function(constructor, prototype) {
    prototype.data = null;
    prototype.pts = 0;
    prototype.streamId = 0;
    prototype.length = 0;
    prototype.pos = 0;
    prototype.dts = 0;
}, {data: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Consts = function() {};
Consts = stjs.extend(Consts, null, [], function(constructor, prototype) {
    constructor.KEY_FRAME = 0;
    constructor.INTER_FRAME = 1;
    /**
     *  Specifies how the transform size is determined. For tx_mode not equal to
     *  4, the inverse transform will use the largest transform size possible up
     *  to the limit set in tx_mode. For tx_mode equal to 4, the choice of size
     *  is specified explicitly for each block.
     */
    constructor.ONLY_4X4 = 0;
    constructor.ALLOW_8X8 = 1;
    constructor.ALLOW_16X16 = 2;
    constructor.ALLOW_32X32 = 3;
    constructor.TX_MODE_SELECT = 4;
    constructor.PARTITION_NONE = 0;
    constructor.PARTITION_HORZ = 1;
    constructor.PARTITION_VERT = 2;
    constructor.PARTITION_SPLIT = 3;
    constructor.BLOCK_INVALID = -1;
    constructor.BLOCK_4X4 = 0;
    constructor.BLOCK_4X8 = 1;
    constructor.BLOCK_8X4 = 2;
    constructor.BLOCK_8X8 = 3;
    constructor.BLOCK_8X16 = 4;
    constructor.BLOCK_16X8 = 5;
    constructor.BLOCK_16X16 = 6;
    constructor.BLOCK_16X32 = 7;
    constructor.BLOCK_32X16 = 8;
    constructor.BLOCK_32X32 = 9;
    constructor.BLOCK_32X64 = 10;
    constructor.BLOCK_64X32 = 11;
    constructor.BLOCK_64X64 = 12;
    constructor.TX_4X4 = 0;
    constructor.TX_8X8 = 1;
    constructor.TX_16X16 = 2;
    constructor.TX_32X32 = 3;
    constructor.LAST_FRAME = 0;
    constructor.ALTREF_FRAME = 1;
    constructor.GOLDEN_FRAME = 2;
    constructor.INTRA_FRAME = 3;
    constructor.DC_PRED = 0;
    constructor.TM_PRED = 1;
    constructor.V_PRED = 2;
    constructor.H_PRED = 3;
    constructor.D135_PRED = 4;
    constructor.D117_PRED = 5;
    constructor.D45_PRED = 6;
    constructor.D63_PRED = 7;
    constructor.D153_PRED = 8;
    constructor.D207_PRED = 9;
    constructor.NEARESTMV = 10;
    constructor.NEARMV = 11;
    constructor.ZEROMV = 12;
    constructor.NEWMV = 13;
    constructor.SINGLE_REF = 0;
    constructor.COMPOUND_REF = 1;
    constructor.REFERENCE_MODE_SELECT = 2;
    constructor.NORMAL = 0;
    constructor.SMOOTH = 1;
    constructor.SHARP = 2;
    constructor.SWITCHABLE = 3;
    constructor.EIGHTTAP = 0;
    constructor.EIGHTTAP_SMOOTH = 1;
    constructor.EIGHTTAP_SHARP = 2;
    constructor.BILINEAR = 3;
    constructor.MV_JOINT_ZERO = 0;
    constructor.MV_JOINT_HNZVZ = 1;
    constructor.MV_JOINT_HZVNZ = 2;
    constructor.MV_JOINT_HNZVNZ = 3;
    constructor.ZERO_TOKEN = 0;
    constructor.ONE_TOKEN = 1;
    constructor.TWO_TOKEN = 2;
    constructor.THREE_TOKEN = 3;
    constructor.FOUR_TOKEN = 4;
    constructor.DCT_VAL_CAT1 = 5;
    constructor.DCT_VAL_CAT2 = 6;
    constructor.DCT_VAL_CAT3 = 7;
    constructor.DCT_VAL_CAT4 = 8;
    constructor.DCT_VAL_CAT5 = 9;
    constructor.DCT_VAL_CAT6 = 10;
    constructor.TREE_SEGMENT_ID = new Int32Array([2, 4, 6, 8, 10, 12, 0, -1, -2, -3, -4, -5, -6, -7]);
    constructor.TREE_TX_SIZE = [null, new Int32Array([-Consts.TX_4X4, -Consts.TX_8X8]), new Int32Array([-Consts.TX_4X4, 2, -Consts.TX_8X8, -Consts.TX_16X16]), new Int32Array([-Consts.TX_4X4, 2, -Consts.TX_8X8, 4, -Consts.TX_16X16, -Consts.TX_32X32])];
    constructor.maxTxLookup = new Int32Array([0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3]);
    constructor.blW = new Int32Array([1, 1, 1, 1, 1, 2, 2, 2, 4, 4, 4, 8, 8]);
    constructor.blH = new Int32Array([1, 1, 1, 1, 2, 1, 2, 4, 2, 4, 8, 4, 8]);
    constructor.TREE_INTRA_MODE = new Int32Array([-Consts.DC_PRED, 2, -Consts.TM_PRED, 4, -Consts.V_PRED, 6, 8, 12, -Consts.H_PRED, 10, -Consts.D135_PRED, -Consts.D117_PRED, -Consts.D45_PRED, 14, -Consts.D63_PRED, 16, -Consts.D153_PRED, -Consts.D207_PRED]);
    constructor.size_group_lookup = new Int32Array([0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3]);
    constructor.TREE_INTERP_FILTER = new Int32Array([-Consts.EIGHTTAP, 2, -Consts.EIGHTTAP_SMOOTH, -Consts.EIGHTTAP_SHARP]);
    constructor.TREE_INTER_MODE = new Int32Array([-(Consts.ZEROMV - Consts.NEARESTMV), 2, -(Consts.NEARESTMV - Consts.NEARESTMV), 4, -(Consts.NEARMV - Consts.NEARESTMV), -(Consts.NEWMV - Consts.NEARESTMV)]);
    constructor.mv_ref_blocks_sm = [new Int32Array([0, 1]), new Int32Array([0, 1]), new Int32Array([0, 1]), new Int32Array([0, 1]), new Int32Array([1, 0]), new Int32Array([0, 1]), new Int32Array([0, 1]), new Int32Array([1, 0]), new Int32Array([0, 1]), new Int32Array([2, 3]), new Int32Array([1, 0]), new Int32Array([0, 1]), new Int32Array([4, 5])];
    constructor.mv_ref_blocks = [new Int32Array([0, 1, 11, 12, 13, 16, 17, 18]), new Int32Array([0, 1, 11, 12, 13, 16, 17, 18]), new Int32Array([0, 1, 11, 12, 13, 16, 17, 18]), new Int32Array([0, 1, 11, 12, 13, 16, 17, 18]), new Int32Array([1, 0, 3, 11, 13, 12, 16, 17]), new Int32Array([0, 1, 2, 11, 12, 13, 17, 16]), new Int32Array([0, 1, 2, 3, 11, 14, 15, 19]), new Int32Array([1, 0, 7, 11, 2, 15, 14, 19]), new Int32Array([0, 1, 6, 11, 3, 14, 15, 19]), new Int32Array([2, 3, 6, 7, 11, 14, 15, 19]), new Int32Array([1, 0, 9, 6, 11, 15, 14, 7]), new Int32Array([0, 1, 8, 7, 11, 14, 15, 6]), new Int32Array([4, 5, 8, 9, 11, 0, 1, 10])];
    constructor.TREE_MV_JOINT = new Int32Array([-Consts.MV_JOINT_ZERO, 2, -Consts.MV_JOINT_HNZVZ, 4, -Consts.MV_JOINT_HZVNZ, -Consts.MV_JOINT_HNZVNZ]);
    constructor.MV_CLASS_TREE = new Int32Array([-0, 2, -1, 4, 6, 8, -2, -3, 10, 12, -4, -5, -6, 14, 16, 18, -7, -8, -9, -10]);
    constructor.MV_FR_TREE = new Int32Array([-0, 2, -1, 4, -2, -3]);
    constructor.LITERAL_TO_FILTER_TYPE = new Int32Array([Consts.EIGHTTAP_SMOOTH, Consts.EIGHTTAP, Consts.EIGHTTAP_SHARP, Consts.BILINEAR]);
    constructor.PARETO_TABLE = [new Int32Array([3, 86, 128, 6, 86, 23, 88, 29]), new Int32Array([9, 86, 129, 17, 88, 61, 94, 76]), new Int32Array([15, 87, 129, 28, 89, 93, 100, 110]), new Int32Array([20, 88, 130, 38, 91, 118, 106, 136]), new Int32Array([26, 89, 131, 48, 92, 139, 111, 156]), new Int32Array([31, 90, 131, 58, 94, 156, 117, 171]), new Int32Array([37, 90, 132, 66, 95, 171, 122, 184]), new Int32Array([42, 91, 132, 75, 97, 183, 127, 194]), new Int32Array([47, 92, 133, 83, 98, 193, 132, 202]), new Int32Array([52, 93, 133, 90, 100, 201, 137, 208]), new Int32Array([57, 94, 134, 98, 101, 208, 142, 214]), new Int32Array([62, 94, 135, 105, 103, 214, 146, 218]), new Int32Array([66, 95, 135, 111, 104, 219, 151, 222]), new Int32Array([71, 96, 136, 117, 106, 224, 155, 225]), new Int32Array([76, 97, 136, 123, 107, 227, 159, 228]), new Int32Array([80, 98, 137, 129, 109, 231, 162, 231]), new Int32Array([84, 98, 138, 134, 110, 234, 166, 233]), new Int32Array([89, 99, 138, 140, 112, 236, 170, 235]), new Int32Array([93, 100, 139, 145, 113, 238, 173, 236]), new Int32Array([97, 101, 140, 149, 115, 240, 176, 238]), new Int32Array([101, 102, 140, 154, 116, 242, 179, 239]), new Int32Array([105, 103, 141, 158, 118, 243, 182, 240]), new Int32Array([109, 104, 141, 162, 119, 244, 185, 241]), new Int32Array([113, 104, 142, 166, 120, 245, 187, 242]), new Int32Array([116, 105, 143, 170, 122, 246, 190, 243]), new Int32Array([120, 106, 143, 173, 123, 247, 192, 244]), new Int32Array([123, 107, 144, 177, 125, 248, 195, 244]), new Int32Array([127, 108, 145, 180, 126, 249, 197, 245]), new Int32Array([130, 109, 145, 183, 128, 249, 199, 245]), new Int32Array([134, 110, 146, 186, 129, 250, 201, 246]), new Int32Array([137, 111, 147, 189, 131, 251, 203, 246]), new Int32Array([140, 112, 147, 192, 132, 251, 205, 247]), new Int32Array([143, 113, 148, 194, 133, 251, 207, 247]), new Int32Array([146, 114, 149, 197, 135, 252, 208, 248]), new Int32Array([149, 115, 149, 199, 136, 252, 210, 248]), new Int32Array([152, 115, 150, 201, 138, 252, 211, 248]), new Int32Array([155, 116, 151, 204, 139, 253, 213, 249]), new Int32Array([158, 117, 151, 206, 140, 253, 214, 249]), new Int32Array([161, 118, 152, 208, 142, 253, 216, 249]), new Int32Array([163, 119, 153, 210, 143, 253, 217, 249]), new Int32Array([166, 120, 153, 212, 144, 254, 218, 250]), new Int32Array([168, 121, 154, 213, 146, 254, 220, 250]), new Int32Array([171, 122, 155, 215, 147, 254, 221, 250]), new Int32Array([173, 123, 155, 217, 148, 254, 222, 250]), new Int32Array([176, 124, 156, 218, 150, 254, 223, 250]), new Int32Array([178, 125, 157, 220, 151, 254, 224, 251]), new Int32Array([180, 126, 157, 221, 152, 254, 225, 251]), new Int32Array([183, 127, 158, 222, 153, 254, 226, 251]), new Int32Array([185, 128, 159, 224, 155, 255, 227, 251]), new Int32Array([187, 129, 160, 225, 156, 255, 228, 251]), new Int32Array([189, 131, 160, 226, 157, 255, 228, 251]), new Int32Array([191, 132, 161, 227, 159, 255, 229, 251]), new Int32Array([193, 133, 162, 228, 160, 255, 230, 252]), new Int32Array([195, 134, 163, 230, 161, 255, 231, 252]), new Int32Array([197, 135, 163, 231, 162, 255, 231, 252]), new Int32Array([199, 136, 164, 232, 163, 255, 232, 252]), new Int32Array([201, 137, 165, 233, 165, 255, 233, 252]), new Int32Array([202, 138, 166, 233, 166, 255, 233, 252]), new Int32Array([204, 139, 166, 234, 167, 255, 234, 252]), new Int32Array([206, 140, 167, 235, 168, 255, 235, 252]), new Int32Array([207, 141, 168, 236, 169, 255, 235, 252]), new Int32Array([209, 142, 169, 237, 171, 255, 236, 252]), new Int32Array([210, 144, 169, 237, 172, 255, 236, 252]), new Int32Array([212, 145, 170, 238, 173, 255, 237, 252]), new Int32Array([214, 146, 171, 239, 174, 255, 237, 253]), new Int32Array([215, 147, 172, 240, 175, 255, 238, 253]), new Int32Array([216, 148, 173, 240, 176, 255, 238, 253]), new Int32Array([218, 149, 173, 241, 177, 255, 239, 253]), new Int32Array([219, 150, 174, 241, 179, 255, 239, 253]), new Int32Array([220, 152, 175, 242, 180, 255, 240, 253]), new Int32Array([222, 153, 176, 242, 181, 255, 240, 253]), new Int32Array([223, 154, 177, 243, 182, 255, 240, 253]), new Int32Array([224, 155, 178, 244, 183, 255, 241, 253]), new Int32Array([225, 156, 178, 244, 184, 255, 241, 253]), new Int32Array([226, 158, 179, 244, 185, 255, 242, 253]), new Int32Array([228, 159, 180, 245, 186, 255, 242, 253]), new Int32Array([229, 160, 181, 245, 187, 255, 242, 253]), new Int32Array([230, 161, 182, 246, 188, 255, 243, 253]), new Int32Array([231, 163, 183, 246, 189, 255, 243, 253]), new Int32Array([232, 164, 184, 247, 190, 255, 243, 253]), new Int32Array([233, 165, 185, 247, 191, 255, 244, 253]), new Int32Array([234, 166, 185, 247, 192, 255, 244, 253]), new Int32Array([235, 168, 186, 248, 193, 255, 244, 253]), new Int32Array([236, 169, 187, 248, 194, 255, 244, 253]), new Int32Array([236, 170, 188, 248, 195, 255, 245, 253]), new Int32Array([237, 171, 189, 249, 196, 255, 245, 254]), new Int32Array([238, 173, 190, 249, 197, 255, 245, 254]), new Int32Array([239, 174, 191, 249, 198, 255, 245, 254]), new Int32Array([240, 175, 192, 249, 199, 255, 246, 254]), new Int32Array([240, 177, 193, 250, 200, 255, 246, 254]), new Int32Array([241, 178, 194, 250, 201, 255, 246, 254]), new Int32Array([242, 179, 195, 250, 202, 255, 246, 254]), new Int32Array([242, 181, 196, 250, 203, 255, 247, 254]), new Int32Array([243, 182, 197, 251, 204, 255, 247, 254]), new Int32Array([244, 184, 198, 251, 205, 255, 247, 254]), new Int32Array([244, 185, 199, 251, 206, 255, 247, 254]), new Int32Array([245, 186, 200, 251, 207, 255, 247, 254]), new Int32Array([246, 188, 201, 252, 207, 255, 248, 254]), new Int32Array([246, 189, 202, 252, 208, 255, 248, 254]), new Int32Array([247, 191, 203, 252, 209, 255, 248, 254]), new Int32Array([247, 192, 204, 252, 210, 255, 248, 254]), new Int32Array([248, 194, 205, 252, 211, 255, 248, 254]), new Int32Array([248, 195, 206, 252, 212, 255, 249, 254]), new Int32Array([249, 197, 207, 253, 213, 255, 249, 254]), new Int32Array([249, 198, 208, 253, 214, 255, 249, 254]), new Int32Array([250, 200, 210, 253, 215, 255, 249, 254]), new Int32Array([250, 201, 211, 253, 215, 255, 249, 254]), new Int32Array([250, 203, 212, 253, 216, 255, 249, 254]), new Int32Array([251, 204, 213, 253, 217, 255, 250, 254]), new Int32Array([251, 206, 214, 254, 218, 255, 250, 254]), new Int32Array([252, 207, 216, 254, 219, 255, 250, 254]), new Int32Array([252, 209, 217, 254, 220, 255, 250, 254]), new Int32Array([252, 211, 218, 254, 221, 255, 250, 254]), new Int32Array([253, 213, 219, 254, 222, 255, 250, 254]), new Int32Array([253, 214, 221, 254, 223, 255, 250, 254]), new Int32Array([253, 216, 222, 254, 224, 255, 251, 254]), new Int32Array([253, 218, 224, 254, 225, 255, 251, 254]), new Int32Array([254, 220, 225, 254, 225, 255, 251, 254]), new Int32Array([254, 222, 227, 255, 226, 255, 251, 254]), new Int32Array([254, 224, 228, 255, 227, 255, 251, 254]), new Int32Array([254, 226, 230, 255, 228, 255, 251, 254]), new Int32Array([255, 228, 231, 255, 230, 255, 251, 254]), new Int32Array([255, 230, 233, 255, 231, 255, 252, 254]), new Int32Array([255, 232, 235, 255, 232, 255, 252, 254]), new Int32Array([255, 235, 237, 255, 233, 255, 252, 254]), new Int32Array([255, 238, 240, 255, 235, 255, 252, 255]), new Int32Array([255, 241, 243, 255, 236, 255, 252, 254]), new Int32Array([255, 246, 247, 255, 239, 255, 253, 255])];
    constructor.extra_bits = [new Int32Array([0, 0, 0]), new Int32Array([0, 0, 1]), new Int32Array([0, 0, 2]), new Int32Array([0, 0, 3]), new Int32Array([0, 0, 4]), new Int32Array([1, 1, 5]), new Int32Array([2, 2, 7]), new Int32Array([3, 3, 11]), new Int32Array([4, 4, 19]), new Int32Array([5, 5, 35]), new Int32Array([6, 14, 67])];
    constructor.cat_probs = [new Int32Array([0]), new Int32Array([159]), new Int32Array([165, 145]), new Int32Array([173, 148, 140]), new Int32Array([176, 155, 140, 135]), new Int32Array([180, 157, 141, 134, 130]), new Int32Array([254, 254, 254, 252, 249, 243, 230, 196, 177, 153, 140, 133, 130, 129])];
    constructor.TOKEN_TREE = new Int32Array([-Consts.ZERO_TOKEN, 2, -Consts.ONE_TOKEN, 4, 6, 10, -Consts.TWO_TOKEN, 8, -Consts.THREE_TOKEN, -Consts.FOUR_TOKEN, 12, 14, -Consts.DCT_VAL_CAT1, -Consts.DCT_VAL_CAT2, 16, 18, -Consts.DCT_VAL_CAT3, -Consts.DCT_VAL_CAT4, -Consts.DCT_VAL_CAT5, -Consts.DCT_VAL_CAT6]);
    constructor.coefband_4x4 = new Int32Array([0, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5]);
    constructor.coefband_8x8plus = new Int32Array([0, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]);
    constructor.SZ_8x8 = 0;
    constructor.SZ_16x16 = 1;
    constructor.SZ_32x32 = 2;
    constructor.SZ_64x64 = 3;
    constructor.blSizeLookup = [new Int32Array([Consts.BLOCK_4X4, Consts.BLOCK_4X8, Consts.BLOCK_8X4, Consts.BLOCK_8X8, Consts.BLOCK_8X16, Consts.BLOCK_16X8, Consts.BLOCK_16X16, Consts.BLOCK_16X32, Consts.BLOCK_32X16, Consts.BLOCK_32X32, Consts.BLOCK_32X64, Consts.BLOCK_64X32, Consts.BLOCK_64X64]), new Int32Array([-1, -1, -1, Consts.BLOCK_8X4, -1, -1, Consts.BLOCK_16X8, -1, -1, Consts.BLOCK_32X16, -1, -1, Consts.BLOCK_64X32]), new Int32Array([-1, -1, -1, Consts.BLOCK_4X8, -1, 1, Consts.BLOCK_8X16, -1, -1, Consts.BLOCK_16X32, -1, -1, Consts.BLOCK_32X64]), new Int32Array([-1, -1, -1, Consts.BLOCK_4X4, -1, -1, Consts.BLOCK_8X8, -1, -1, Consts.BLOCK_16X16, -1, -1, Consts.BLOCK_32X32])];
    constructor.TREE_PARTITION = new Int32Array([-Consts.PARTITION_NONE, 2, -Consts.PARTITION_HORZ, 4, -Consts.PARTITION_VERT, Consts.PARTITION_SPLIT]);
    constructor.TREE_PARTITION_RIGHT_E = new Int32Array([-Consts.PARTITION_NONE, -Consts.PARTITION_VERT]);
    constructor.TREE_PARTITION_BOTTOM_E = new Int32Array([-Consts.PARTITION_NONE, -Consts.PARTITION_HORZ]);
    constructor.INV_REMAP_TABLE = new Int32Array([7, 20, 33, 46, 59, 72, 85, 98, 111, 124, 137, 150, 163, 176, 189, 202, 215, 228, 241, 254, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 253]);
    constructor.REFS_PER_FRAME = 3;
    constructor.MV_FR_SIZE = 4;
    constructor.MVREF_NEIGHBOURS = 8;
    constructor.BLOCK_SIZE_GROUPS = 4;
    constructor.BLOCK_SIZES = 13;
    constructor.PARTITION_CONTEXTS = 16;
    constructor.MI_SIZE = 8;
    constructor.MIN_TILE_WIDTH_B64 = 4;
    constructor.MAX_TILE_WIDTH_B64 = 64;
    constructor.MAX_MV_REF_CANDIDATES = 2;
    constructor.NUM_REF_FRAMES = 8;
    constructor.MAX_REF_FRAMES = 4;
    constructor.IS_INTER_CONTEXTS = 4;
    constructor.COMP_MODE_CONTEXTS = 5;
    constructor.REF_CONTEXTS = 5;
    constructor.MAX_SEGMENTS = 8;
    constructor.SEG_LVL_ALT_Q = 0;
    constructor.SEG_LVL_ALT_L = 1;
    constructor.SEG_LVL_REF_FRAME = 2;
    constructor.SEG_LVL_SKIP = 3;
    constructor.SEG_LVL_MAX = 4;
    constructor.BLOCK_TYPES = 2;
    constructor.REF_TYPES = 2;
    constructor.COEF_BANDS = 6;
    constructor.PREV_COEF_CONTEXTS = 6;
    constructor.UNCONSTRAINED_NODES = 3;
    constructor.TX_SIZE_CONTEXTS = 2;
    constructor.SWITCHABLE_FILTERS = 3;
    constructor.INTERP_FILTER_CONTEXTS = 4;
    constructor.SKIP_CONTEXTS = 3;
    constructor.PARTITION_TYPES = 4;
    constructor.TX_SIZES = 4;
    constructor.TX_MODES = 5;
    constructor.DCT_DCT = 0;
    constructor.ADST_DCT = 1;
    constructor.DCT_ADST = 2;
    constructor.ADST_ADST = 3;
    constructor.MB_MODE_COUNT = 14;
    constructor.INTRA_MODES = 10;
    constructor.INTER_MODES = 4;
    constructor.INTER_MODE_CONTEXTS = 7;
    constructor.MV_JOINTS = 4;
    constructor.MV_CLASSES = 11;
    constructor.CLASS0_SIZE = 2;
    constructor.MV_OFFSET_BITS = 10;
    constructor.MAX_PROB = 255;
    constructor.MAX_MODE_LF_DELTAS = 2;
    constructor.COMPANDED_MVREF_THRESH = 8;
    constructor.MAX_LOOP_FILTER = 63;
    constructor.REF_SCALE_SHIFT = 14;
    constructor.SUBPEL_BITS = 4;
    constructor.SUBPEL_SHIFTS = 16;
    constructor.SUBPEL_MASK = 15;
    constructor.MV_BORDER = 128;
    constructor.INTERP_EXTEND = 4;
    constructor.BORDERINPIXELS = 160;
    constructor.MAX_UPDATE_FACTOR = 128;
    constructor.COUNT_SAT = 20;
    constructor.BOTH_ZERO = 0;
    constructor.ZERO_PLUS_PREDICTED = 1;
    constructor.BOTH_PREDICTED = 2;
    constructor.NEW_PLUS_NON_INTRA = 3;
    constructor.BOTH_NEW = 4;
    constructor.INTRA_PLUS_NON_INTRA = 5;
    constructor.BOTH_INTRA = 6;
    constructor.INVALID_CASE = 9;
    prototype.CS_UNKNOWN = 0;
    constructor.CS_BT_601 = 1;
    constructor.CS_BT_709 = 2;
    constructor.CS_SMPTE_170 = 3;
    constructor.CS_SMPTE_240 = 4;
    constructor.CS_BT_2020 = 5;
    constructor.CS_RESERVED = 6;
    constructor.CS_RGB = 7;
    constructor.SEGMENTATION_FEATURE_BITS = new Int32Array([8, 6, 2, 0]);
    constructor.SEGMENTATION_FEATURE_SIGNED = new Int32Array([1, 1, 0, 0]);
    constructor.tx_mode_to_biggest_tx_size = new Int32Array([Consts.TX_4X4, Consts.TX_8X8, Consts.TX_16X16, Consts.TX_32X32, Consts.TX_32X32]);
}, {TREE_SEGMENT_ID: "Int32Array", TREE_TX_SIZE: "Array", maxTxLookup: "Int32Array", blW: "Int32Array", blH: "Int32Array", TREE_INTRA_MODE: "Int32Array", size_group_lookup: "Int32Array", TREE_INTERP_FILTER: "Int32Array", TREE_INTER_MODE: "Int32Array", mv_ref_blocks_sm: "Array", mv_ref_blocks: "Array", TREE_MV_JOINT: "Int32Array", MV_CLASS_TREE: "Int32Array", MV_FR_TREE: "Int32Array", LITERAL_TO_FILTER_TYPE: "Int32Array", PARETO_TABLE: "Array", extra_bits: "Array", cat_probs: "Array", TOKEN_TREE: "Int32Array", coefband_4x4: "Int32Array", coefband_8x8plus: "Int32Array", blSizeLookup: "Array", TREE_PARTITION: "Int32Array", TREE_PARTITION_RIGHT_E: "Int32Array", TREE_PARTITION_BOTTOM_E: "Int32Array", INV_REMAP_TABLE: "Int32Array", SEGMENTATION_FEATURE_BITS: "Int32Array", SEGMENTATION_FEATURE_SIGNED: "Int32Array", tx_mode_to_biggest_tx_size: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Transform = function() {};
Transform = stjs.extend(Transform, null, [], function(constructor, prototype) {
    constructor.Levels = stjs.enumeration("STUDIO", "PC");
    prototype.transform = function(src, dst) {};
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var FFTTables = function() {};
FFTTables = stjs.extend(FFTTables, null, [], function(constructor, prototype) {
    constructor.FFT_TABLE_512 = [new Float32Array([1.0, 0.0, 0.0]), new Float32Array([0.9999247, 0.012271538, -0.012271538]), new Float32Array([0.9996989, 0.024541229, -0.024541229]), new Float32Array([0.9993224, 0.036807224, -0.036807224]), new Float32Array([0.9987955, 0.049067676, -0.049067676]), new Float32Array([0.9981182, 0.061320737, -0.061320737]), new Float32Array([0.99729055, 0.07356457, -0.07356457]), new Float32Array([0.9963127, 0.08579732, -0.08579732]), new Float32Array([0.99518484, 0.09801715, -0.09801715]), new Float32Array([0.9939071, 0.11022222, -0.11022222]), new Float32Array([0.9924797, 0.12241069, -0.12241069]), new Float32Array([0.9909028, 0.13458073, -0.13458073]), new Float32Array([0.98917663, 0.1467305, -0.1467305]), new Float32Array([0.9873016, 0.15885818, -0.15885818]), new Float32Array([0.98527783, 0.17096192, -0.17096192]), new Float32Array([0.9831057, 0.18303992, -0.18303992]), new Float32Array([0.9807855, 0.19509035, -0.19509035]), new Float32Array([0.97831756, 0.2071114, -0.2071114]), new Float32Array([0.9757023, 0.21910128, -0.21910128]), new Float32Array([0.97294015, 0.23105815, -0.23105815]), new Float32Array([0.97003144, 0.24298023, -0.24298023]), new Float32Array([0.9669767, 0.2548657, -0.2548657]), new Float32Array([0.96377635, 0.2667128, -0.2667128]), new Float32Array([0.96043086, 0.27851975, -0.27851975]), new Float32Array([0.9569407, 0.29028472, -0.29028472]), new Float32Array([0.95330644, 0.302006, -0.302006]), new Float32Array([0.9495286, 0.3136818, -0.3136818]), new Float32Array([0.9456077, 0.32531038, -0.32531038]), new Float32Array([0.9415445, 0.33688995, -0.33688995]), new Float32Array([0.9373394, 0.3484188, -0.3484188]), new Float32Array([0.93299323, 0.35989517, -0.35989517]), new Float32Array([0.92850655, 0.37131733, -0.37131733]), new Float32Array([0.92388, 0.38268358, -0.38268358]), new Float32Array([0.9191143, 0.3939922, -0.3939922]), new Float32Array([0.9142102, 0.4052415, -0.4052415]), new Float32Array([0.9091684, 0.41642973, -0.41642973]), new Float32Array([0.9039898, 0.42755526, -0.42755526]), new Float32Array([0.89867496, 0.43861642, -0.43861642]), new Float32Array([0.89322484, 0.4496115, -0.4496115]), new Float32Array([0.8876402, 0.4605389, -0.4605389]), new Float32Array([0.8819218, 0.47139695, -0.47139695]), new Float32Array([0.8760707, 0.482184, -0.482184]), new Float32Array([0.8700876, 0.49289843, -0.49289843]), new Float32Array([0.8639735, 0.50353867, -0.50353867]), new Float32Array([0.85772926, 0.51410306, -0.51410306]), new Float32Array([0.85135585, 0.52459, -0.52459]), new Float32Array([0.84485424, 0.53499794, -0.53499794]), new Float32Array([0.83822536, 0.5453253, -0.5453253]), new Float32Array([0.83147025, 0.55557054, -0.55557054]), new Float32Array([0.82458997, 0.5657321, -0.5657321]), new Float32Array([0.8175855, 0.57580847, -0.57580847]), new Float32Array([0.8104579, 0.58579814, -0.58579814]), new Float32Array([0.80320823, 0.5956996, -0.5956996]), new Float32Array([0.79583764, 0.60551137, -0.60551137]), new Float32Array([0.7883472, 0.61523193, -0.61523193]), new Float32Array([0.780738, 0.62485987, -0.62485987]), new Float32Array([0.7730112, 0.6343937, -0.6343937]), new Float32Array([0.7651681, 0.64383197, -0.64383197]), new Float32Array([0.75720966, 0.6531733, -0.6531733]), new Float32Array([0.7491372, 0.6624163, -0.6624163]), new Float32Array([0.74095196, 0.67155945, -0.67155945]), new Float32Array([0.7326551, 0.68060154, -0.68060154]), new Float32Array([0.72424793, 0.6895411, -0.6895411]), new Float32Array([0.7157317, 0.69837683, -0.69837683]), new Float32Array([0.70710766, 0.70710737, -0.70710737]), new Float32Array([0.69837713, 0.71573144, -0.71573144]), new Float32Array([0.68954146, 0.7242477, -0.7242477]), new Float32Array([0.6806019, 0.73265487, -0.73265487]), new Float32Array([0.6715598, 0.7409518, -0.7409518]), new Float32Array([0.66241664, 0.74913704, -0.74913704]), new Float32Array([0.6531737, 0.75720954, -0.75720954]), new Float32Array([0.6438324, 0.765168, -0.765168]), new Float32Array([0.6343941, 0.77301127, -0.77301127]), new Float32Array([0.62486035, 0.78073806, -0.78073806]), new Float32Array([0.61523247, 0.7883473, -0.7883473]), new Float32Array([0.6055119, 0.79583776, -0.79583776]), new Float32Array([0.59570014, 0.8032084, -0.8032084]), new Float32Array([0.58579874, 0.8104581, -0.8104581]), new Float32Array([0.57580906, 0.81758577, -0.81758577]), new Float32Array([0.5657327, 0.82459027, -0.82459027]), new Float32Array([0.5555711, 0.8314706, -0.8314706]), new Float32Array([0.5453258, 0.8382257, -0.8382257]), new Float32Array([0.5349984, 0.8448546, -0.8448546]), new Float32Array([0.52459043, 0.85135627, -0.85135627]), new Float32Array([0.5141035, 0.85772973, -0.85772973]), new Float32Array([0.50353914, 0.86397403, -0.86397403]), new Float32Array([0.49289894, 0.8700882, -0.8700882]), new Float32Array([0.48218453, 0.87607133, -0.87607133]), new Float32Array([0.4713975, 0.88192254, -0.88192254]), new Float32Array([0.46053946, 0.8876409, -0.8876409]), new Float32Array([0.44961208, 0.8932256, -0.8932256]), new Float32Array([0.43861696, 0.8986758, -0.8986758]), new Float32Array([0.4275558, 0.9039906, -0.9039906]), new Float32Array([0.41643026, 0.9091693, -0.9091693]), new Float32Array([0.405242, 0.91421115, -0.91421115]), new Float32Array([0.3939927, 0.91911525, -0.91911525]), new Float32Array([0.38268408, 0.92388093, -0.92388093]), new Float32Array([0.37131783, 0.9285075, -0.9285075]), new Float32Array([0.35989568, 0.93299425, -0.93299425]), new Float32Array([0.3484193, 0.9373405, -0.9373405]), new Float32Array([0.33689046, 0.94154555, -0.94154555]), new Float32Array([0.3253109, 0.94560885, -0.94560885]), new Float32Array([0.31368232, 0.94952977, -0.94952977]), new Float32Array([0.3020065, 0.9533077, -0.9533077]), new Float32Array([0.29028523, 0.956942, -0.956942]), new Float32Array([0.27852023, 0.96043223, -0.96043223]), new Float32Array([0.26671326, 0.9637778, -0.9637778]), new Float32Array([0.25486615, 0.96697825, -0.96697825]), new Float32Array([0.24298064, 0.97003305, -0.97003305]), new Float32Array([0.23105855, 0.97294176, -0.97294176]), new Float32Array([0.21910167, 0.97570395, -0.97570395]), new Float32Array([0.20711178, 0.9783192, -0.9783192]), new Float32Array([0.19509071, 0.98078716, -0.98078716]), new Float32Array([0.18304025, 0.9831074, -0.9831074]), new Float32Array([0.17096223, 0.98527956, -0.98527956]), new Float32Array([0.15885846, 0.9873034, -0.9873034]), new Float32Array([0.14673077, 0.9891785, -0.9891785]), new Float32Array([0.13458098, 0.9909046, -0.9909046]), new Float32Array([0.12241093, 0.9924815, -0.9924815]), new Float32Array([0.11022244, 0.99390894, -0.99390894]), new Float32Array([0.09801734, 0.99518675, -0.99518675]), new Float32Array([0.085797496, 0.99631464, -0.99631464]), new Float32Array([0.07356472, 0.9972925, -0.9972925]), new Float32Array([0.061320875, 0.9981202, -0.9981202]), new Float32Array([0.049067788, 0.99879754, -0.99879754]), new Float32Array([0.03680731, 0.9993245, -0.9993245]), new Float32Array([0.024541289, 0.99970096, -0.99970096]), new Float32Array([0.012271572, 0.99992687, -0.99992687]), new Float32Array([7.4505806E-9, 1.0000021, -1.0000021]), new Float32Array([-0.012271557, 0.99992687, -0.99992687]), new Float32Array([-0.024541274, 0.999701, -0.999701]), new Float32Array([-0.036807295, 0.99932456, -0.99932456]), new Float32Array([-0.049067773, 0.99879766, -0.99879766]), new Float32Array([-0.06132086, 0.99812037, -0.99812037]), new Float32Array([-0.073564716, 0.9972927, -0.9972927]), new Float32Array([-0.085797496, 0.9963148, -0.9963148]), new Float32Array([-0.09801735, 0.995187, -0.995187]), new Float32Array([-0.11022245, 0.99390924, -0.99390924]), new Float32Array([-0.122410946, 0.9924818, -0.9924818]), new Float32Array([-0.13458101, 0.9909049, -0.9909049]), new Float32Array([-0.14673081, 0.9891788, -0.9891788]), new Float32Array([-0.15885851, 0.98730373, -0.98730373]), new Float32Array([-0.17096227, 0.98528, -0.98528]), new Float32Array([-0.1830403, 0.98310786, -0.98310786]), new Float32Array([-0.19509077, 0.98078763, -0.98078763]), new Float32Array([-0.20711185, 0.9783197, -0.9783197]), new Float32Array([-0.21910176, 0.97570443, -0.97570443]), new Float32Array([-0.23105866, 0.9729423, -0.9729423]), new Float32Array([-0.24298076, 0.9700336, -0.9700336]), new Float32Array([-0.25486627, 0.96697885, -0.96697885]), new Float32Array([-0.2667134, 0.9637785, -0.9637785]), new Float32Array([-0.27852038, 0.96043295, -0.96043295]), new Float32Array([-0.29028538, 0.9569428, -0.9569428]), new Float32Array([-0.3020067, 0.95330846, -0.95330846]), new Float32Array([-0.31368253, 0.9495306, -0.9495306]), new Float32Array([-0.32531112, 0.94560975, -0.94560975]), new Float32Array([-0.33689073, 0.9415465, -0.9415465]), new Float32Array([-0.34841958, 0.93734145, -0.93734145]), new Float32Array([-0.35989597, 0.93299526, -0.93299526]), new Float32Array([-0.37131816, 0.9285086, -0.9285086]), new Float32Array([-0.38268444, 0.923882, -0.923882]), new Float32Array([-0.39399308, 0.9191163, -0.9191163]), new Float32Array([-0.40524238, 0.9142122, -0.9142122]), new Float32Array([-0.41643065, 0.90917045, -0.90917045]), new Float32Array([-0.42755622, 0.90399176, -0.90399176]), new Float32Array([-0.4386174, 0.89867693, -0.89867693]), new Float32Array([-0.44961253, 0.89322674, -0.89322674]), new Float32Array([-0.46053994, 0.8876421, -0.8876421]), new Float32Array([-0.471398, 0.88192374, -0.88192374]), new Float32Array([-0.48218507, 0.8760726, -0.8760726]), new Float32Array([-0.49289954, 0.87008953, -0.87008953]), new Float32Array([-0.50353974, 0.8639754, -0.8639754]), new Float32Array([-0.5141041, 0.85773116, -0.85773116]), new Float32Array([-0.52459115, 0.85135776, -0.85135776]), new Float32Array([-0.5349991, 0.84485614, -0.84485614]), new Float32Array([-0.5453265, 0.8382273, -0.8382273]), new Float32Array([-0.55557173, 0.83147216, -0.83147216]), new Float32Array([-0.5657333, 0.8245919, -0.8245919]), new Float32Array([-0.5758097, 0.81758744, -0.81758744]), new Float32Array([-0.58579946, 0.8104598, -0.8104598]), new Float32Array([-0.5957009, 0.8032101, -0.8032101]), new Float32Array([-0.60551274, 0.7958395, -0.7958395]), new Float32Array([-0.6152333, 0.78834903, -0.78834903]), new Float32Array([-0.62486124, 0.7807398, -0.7807398]), new Float32Array([-0.63439506, 0.773013, -0.773013]), new Float32Array([-0.6438334, 0.7651698, -0.7651698]), new Float32Array([-0.65317476, 0.7572114, -0.7572114]), new Float32Array([-0.6624177, 0.74913895, -0.74913895]), new Float32Array([-0.6715609, 0.7409537, -0.7409537]), new Float32Array([-0.68060297, 0.73265684, -0.73265684]), new Float32Array([-0.68954253, 0.72424966, -0.72424966]), new Float32Array([-0.69837826, 0.71573335, -0.71573335]), new Float32Array([-0.70710886, 0.7071093, -0.7071093]), new Float32Array([-0.71573293, 0.69837874, -0.69837874]), new Float32Array([-0.72424924, 0.689543, -0.689543]), new Float32Array([-0.7326565, 0.68060344, -0.68060344]), new Float32Array([-0.7409534, 0.67156136, -0.67156136]), new Float32Array([-0.7491387, 0.6624182, -0.6624182]), new Float32Array([-0.7572112, 0.65317523, -0.65317523]), new Float32Array([-0.7651697, 0.64383394, -0.64383394]), new Float32Array([-0.77301294, 0.63439566, -0.63439566]), new Float32Array([-0.7807398, 0.62486184, -0.62486184]), new Float32Array([-0.78834903, 0.61523396, -0.61523396]), new Float32Array([-0.79583955, 0.6055134, -0.6055134]), new Float32Array([-0.8032102, 0.59570163, -0.59570163]), new Float32Array([-0.8104599, 0.5858002, -0.5858002]), new Float32Array([-0.81758755, 0.5758105, -0.5758105]), new Float32Array([-0.82459205, 0.5657341, -0.5657341]), new Float32Array([-0.83147246, 0.55557245, -0.55557245]), new Float32Array([-0.8382276, 0.5453272, -0.5453272]), new Float32Array([-0.8448565, 0.5349998, -0.5349998]), new Float32Array([-0.8513582, 0.5245918, -0.5245918]), new Float32Array([-0.85773164, 0.5141048, -0.5141048]), new Float32Array([-0.86397594, 0.5035404, -0.5035404]), new Float32Array([-0.8700901, 0.49290016, -0.49290016]), new Float32Array([-0.87607324, 0.48218572, -0.48218572]), new Float32Array([-0.88192445, 0.47139865, -0.47139865]), new Float32Array([-0.88764286, 0.4605406, -0.4605406]), new Float32Array([-0.8932276, 0.44961318, -0.44961318]), new Float32Array([-0.89867777, 0.43861806, -0.43861806]), new Float32Array([-0.90399265, 0.42755687, -0.42755687]), new Float32Array([-0.90917134, 0.4164313, -0.4164313]), new Float32Array([-0.9142132, 0.40524304, -0.40524304]), new Float32Array([-0.9191173, 0.3939937, -0.3939937]), new Float32Array([-0.92388296, 0.38268507, -0.38268507]), new Float32Array([-0.92850953, 0.3713188, -0.3713188]), new Float32Array([-0.9329963, 0.3598966, -0.3598966]), new Float32Array([-0.9373425, 0.3484202, -0.3484202]), new Float32Array([-0.94154763, 0.33689135, -0.33689135]), new Float32Array([-0.94561094, 0.32531175, -0.32531175]), new Float32Array([-0.94953185, 0.31368315, -0.31368315]), new Float32Array([-0.9533098, 0.30200732, -0.30200732]), new Float32Array([-0.9569441, 0.290286, -0.290286]), new Float32Array([-0.9604343, 0.27852097, -0.27852097]), new Float32Array([-0.9637799, 0.26671398, -0.26671398]), new Float32Array([-0.9669804, 0.25486684, -0.25486684]), new Float32Array([-0.97003525, 0.24298131, -0.24298131]), new Float32Array([-0.972944, 0.2310592, -0.2310592]), new Float32Array([-0.9757062, 0.21910228, -0.21910228]), new Float32Array([-0.9783215, 0.20711237, -0.20711237]), new Float32Array([-0.9807894, 0.19509128, -0.19509128]), new Float32Array([-0.98310965, 0.18304078, -0.18304078]), new Float32Array([-0.9852818, 0.17096274, -0.17096274]), new Float32Array([-0.98730564, 0.15885894, -0.15885894]), new Float32Array([-0.98918074, 0.14673121, -0.14673121]), new Float32Array([-0.9909069, 0.1345814, -0.1345814]), new Float32Array([-0.9924838, 0.12241132, -0.12241132]), new Float32Array([-0.9939112, 0.1102228, -0.1102228]), new Float32Array([-0.995189, 0.098017685, -0.098017685]), new Float32Array([-0.9963169, 0.08579781, -0.08579781]), new Float32Array([-0.9972948, 0.073565006, -0.073565006]), new Float32Array([-0.99812245, 0.06132113, -0.06132113]), new Float32Array([-0.9987998, 0.049068015, -0.049068015]), new Float32Array([-0.99932677, 0.036807507, -0.036807507]), new Float32Array([-0.9997032, 0.02454146, -0.02454146]), new Float32Array([-0.99992913, 0.012271715, -0.012271715]), new Float32Array([-1.0000044, 1.2293458E-7, -1.2293458E-7]), new Float32Array([-0.99992913, -0.012271469, 0.012271469]), new Float32Array([-0.9997033, -0.024541214, 0.024541214]), new Float32Array([-0.9993268, -0.03680726, 0.03680726]), new Float32Array([-0.9987999, -0.049067765, 0.049067765]), new Float32Array([-0.99812263, -0.061320882, 0.061320882]), new Float32Array([-0.99729496, -0.07356477, 0.07356477]), new Float32Array([-0.9963171, -0.08579758, 0.08579758]), new Float32Array([-0.99518925, -0.09801746, 0.09801746]), new Float32Array([-0.9939115, -0.110222585, 0.110222585]), new Float32Array([-0.9924841, -0.12241111, 0.12241111]), new Float32Array([-0.9909072, -0.1345812, 0.1345812]), new Float32Array([-0.98918104, -0.14673102, 0.14673102]), new Float32Array([-0.987306, -0.15885875, 0.15885875]), new Float32Array([-0.98528224, -0.17096254, 0.17096254]), new Float32Array([-0.98311013, -0.18304059, 0.18304059]), new Float32Array([-0.9807899, -0.19509108, 0.19509108]), new Float32Array([-0.97832197, -0.2071122, 0.2071122]), new Float32Array([-0.9757067, -0.21910211, 0.21910211]), new Float32Array([-0.97294456, -0.23105904, 0.23105904]), new Float32Array([-0.97003585, -0.24298118, 0.24298118]), new Float32Array([-0.96698105, -0.25486672, 0.25486672]), new Float32Array([-0.96378064, -0.26671386, 0.26671386]), new Float32Array([-0.9604351, -0.27852085, 0.27852085]), new Float32Array([-0.95694494, -0.2902859, 0.2902859]), new Float32Array([-0.9533106, -0.30200723, 0.30200723]), new Float32Array([-0.94953275, -0.31368306, 0.31368306]), new Float32Array([-0.9456119, -0.3253117, 0.3253117]), new Float32Array([-0.94154865, -0.3368913, 0.3368913]), new Float32Array([-0.9373436, -0.34842017, 0.34842017]), new Float32Array([-0.93299735, -0.3598966, 0.3598966]), new Float32Array([-0.92851067, -0.37131882, 0.37131882]), new Float32Array([-0.9238841, -0.38268512, 0.38268512]), new Float32Array([-0.9191184, -0.3939938, 0.3939938]), new Float32Array([-0.9142143, -0.40524313, 0.40524313]), new Float32Array([-0.90917253, -0.41643143, 0.41643143]), new Float32Array([-0.90399384, -0.42755702, 0.42755702]), new Float32Array([-0.898679, -0.43861824, 0.43861824]), new Float32Array([-0.8932288, -0.4496134, 0.4496134]), new Float32Array([-0.8876442, -0.46054083, 0.46054083]), new Float32Array([-0.8819258, -0.47139892, 0.47139892]), new Float32Array([-0.8760746, -0.48218602, 0.48218602]), new Float32Array([-0.8700915, -0.4929005, 0.4929005]), new Float32Array([-0.8639774, -0.50354075, 0.50354075]), new Float32Array([-0.85773313, -0.5141052, 0.5141052]), new Float32Array([-0.8513597, -0.5245922, 0.5245922]), new Float32Array([-0.8448581, -0.5350002, 0.5350002]), new Float32Array([-0.83822924, -0.5453276, 0.5453276]), new Float32Array([-0.8314741, -0.5555729, 0.5555729]), new Float32Array([-0.8245938, -0.56573457, 0.56573457]), new Float32Array([-0.8175893, -0.57581097, 0.57581097]), new Float32Array([-0.81046164, -0.5858007, 0.5858007]), new Float32Array([-0.8032119, -0.59570223, 0.59570223]), new Float32Array([-0.7958413, -0.60551405, 0.60551405]), new Float32Array([-0.78835076, -0.6152347, 0.6152347]), new Float32Array([-0.7807415, -0.6248626, 0.6248626]), new Float32Array([-0.7730147, -0.6343965, 0.6343965]), new Float32Array([-0.7651715, -0.6438348, 0.6438348]), new Float32Array([-0.7572131, -0.6531762, 0.6531762]), new Float32Array([-0.7491407, -0.6624192, 0.6624192]), new Float32Array([-0.7409554, -0.67156243, 0.67156243]), new Float32Array([-0.7326585, -0.6806046, 0.6806046]), new Float32Array([-0.72425133, -0.68954414, 0.68954414]), new Float32Array([-0.715735, -0.6983799, 0.6983799]), new Float32Array([-0.70711094, -0.70711046, 0.70711046]), new Float32Array([-0.69838035, -0.7157346, 0.7157346]), new Float32Array([-0.6895446, -0.7242509, 0.7242509]), new Float32Array([-0.68060505, -0.73265815, 0.73265815]), new Float32Array([-0.67156297, -0.7409551, 0.7409551]), new Float32Array([-0.6624198, -0.74914044, 0.74914044]), new Float32Array([-0.6531768, -0.75721294, 0.75721294]), new Float32Array([-0.6438354, -0.7651714, 0.7651714]), new Float32Array([-0.63439715, -0.77301466, 0.77301466]), new Float32Array([-0.6248633, -0.7807415, 0.7807415]), new Float32Array([-0.6152354, -0.78835076, 0.78835076]), new Float32Array([-0.6055148, -0.7958413, 0.7958413]), new Float32Array([-0.595703, -0.803212, 0.803212]), new Float32Array([-0.58580154, -0.81046176, 0.81046176]), new Float32Array([-0.5758118, -0.8175894, 0.8175894]), new Float32Array([-0.5657354, -0.8245939, 0.8245939]), new Float32Array([-0.55557376, -0.8314743, 0.8314743]), new Float32Array([-0.54532844, -0.8382295, 0.8382295]), new Float32Array([-0.535001, -0.84485835, 0.84485835]), new Float32Array([-0.524593, -0.85136, 0.85136]), new Float32Array([-0.514106, -0.8577335, 0.8577335]), new Float32Array([-0.5035416, -0.8639778, 0.8639778]), new Float32Array([-0.49290136, -0.870092, 0.870092]), new Float32Array([-0.48218688, -0.87607515, 0.87607515]), new Float32Array([-0.47139978, -0.8819264, 0.8819264]), new Float32Array([-0.4605417, -0.8876448, 0.8876448]), new Float32Array([-0.44961426, -0.89322954, 0.89322954]), new Float32Array([-0.4386191, -0.8986798, 0.8986798]), new Float32Array([-0.42755792, -0.9039947, 0.9039947]), new Float32Array([-0.41643232, -0.9091734, 0.9091734]), new Float32Array([-0.40524402, -0.91421527, 0.91421527]), new Float32Array([-0.3939947, -0.9191194, 0.9191194]), new Float32Array([-0.38268602, -0.92388517, 0.92388517]), new Float32Array([-0.3713197, -0.92851174, 0.92851174]), new Float32Array([-0.3598975, -0.9329985, 0.9329985]), new Float32Array([-0.34842107, -0.9373448, 0.9373448]), new Float32Array([-0.3368922, -0.9415499, 0.9415499]), new Float32Array([-0.32531255, -0.9456132, 0.9456132]), new Float32Array([-0.31368393, -0.9495341, 0.9495341]), new Float32Array([-0.3020081, -0.95331204, 0.95331204]), new Float32Array([-0.29028675, -0.9569464, 0.9569464]), new Float32Array([-0.2785217, -0.9604366, 0.9604366]), new Float32Array([-0.26671466, -0.9637822, 0.9637822]), new Float32Array([-0.2548675, -0.96698266, 0.96698266]), new Float32Array([-0.24298194, -0.9700375, 0.9700375]), new Float32Array([-0.23105979, -0.9729463, 0.9729463]), new Float32Array([-0.21910286, -0.9757085, 0.9757085]), new Float32Array([-0.20711292, -0.97832376, 0.97832376]), new Float32Array([-0.1950918, -0.9807917, 0.9807917]), new Float32Array([-0.18304129, -0.9831119, 0.9831119]), new Float32Array([-0.17096321, -0.9852841, 0.9852841]), new Float32Array([-0.15885939, -0.9873079, 0.9873079]), new Float32Array([-0.14673163, -0.989183, 0.989183]), new Float32Array([-0.13458179, -0.99090916, 0.99090916]), new Float32Array([-0.122411676, -0.99248606, 0.99248606]), new Float32Array([-0.11022313, -0.9939135, 0.9939135]), new Float32Array([-0.09801798, -0.9951913, 0.9951913]), new Float32Array([-0.08579808, -0.9963192, 0.9963192]), new Float32Array([-0.073565245, -0.99729705, 0.99729705]), new Float32Array([-0.06132134, -0.9981247, 0.9981247]), new Float32Array([-0.049068198, -0.99880207, 0.99880207]), new Float32Array([-0.036807664, -0.99932903, 0.99932903]), new Float32Array([-0.024541587, -0.9997055, 0.9997055]), new Float32Array([-0.012271815, -0.9999314, 0.9999314]), new Float32Array([-1.9464642E-7, -1.0000067, 1.0000067]), new Float32Array([0.012271426, -0.9999314, 0.9999314]), new Float32Array([0.0245412, -0.99970555, 0.99970555]), new Float32Array([0.036807276, -0.9993291, 0.9993291]), new Float32Array([0.04906781, -0.9988022, 0.9988022]), new Float32Array([0.061320953, -0.9981249, 0.9981249]), new Float32Array([0.073564865, -0.9972972, 0.9972972]), new Float32Array([0.0857977, -0.99631935, 0.99631935]), new Float32Array([0.09801761, -0.9951915, 0.9951915]), new Float32Array([0.110222764, -0.99391377, 0.99391377]), new Float32Array([0.12241132, -0.99248636, 0.99248636]), new Float32Array([0.13458143, -0.99090946, 0.99090946]), new Float32Array([0.14673129, -0.9891833, 0.9891833]), new Float32Array([0.15885904, -0.98730826, 0.98730826]), new Float32Array([0.17096287, -0.9852845, 0.9852845]), new Float32Array([0.18304095, -0.9831124, 0.9831124]), new Float32Array([0.19509147, -0.98079216, 0.98079216]), new Float32Array([0.20711261, -0.97832423, 0.97832423]), new Float32Array([0.21910256, -0.97570896, 0.97570896]), new Float32Array([0.23105952, -0.9729468, 0.9729468]), new Float32Array([0.24298169, -0.9700381, 0.9700381]), new Float32Array([0.25486726, -0.9669833, 0.9669833]), new Float32Array([0.26671442, -0.9637829, 0.9637829]), new Float32Array([0.27852145, -0.96043736, 0.96043736]), new Float32Array([0.2902865, -0.95694715, 0.95694715]), new Float32Array([0.30200788, -0.9533128, 0.9533128]), new Float32Array([0.31368375, -0.94953495, 0.94953495]), new Float32Array([0.3253124, -0.9456141, 0.9456141]), new Float32Array([0.33689204, -0.94155085, 0.94155085]), new Float32Array([0.34842095, -0.9373458, 0.9373458]), new Float32Array([0.3598974, -0.93299955, 0.93299955]), new Float32Array([0.37131965, -0.9285129, 0.9285129]), new Float32Array([0.382686, -0.9238863, 0.9238863]), new Float32Array([0.3939947, -0.9191206, 0.9191206]), new Float32Array([0.40524405, -0.91421646, 0.91421646]), new Float32Array([0.41643238, -0.9091746, 0.9091746]), new Float32Array([0.427558, -0.90399593, 0.90399593]), new Float32Array([0.43861923, -0.89868104, 0.89868104]), new Float32Array([0.4496144, -0.89323086, 0.89323086]), new Float32Array([0.46054187, -0.88764614, 0.88764614]), new Float32Array([0.4714, -0.8819278, 0.8819278]), new Float32Array([0.48218712, -0.8760766, 0.8760766]), new Float32Array([0.49290162, -0.87009346, 0.87009346]), new Float32Array([0.5035419, -0.8639793, 0.8639793]), new Float32Array([0.51410633, -0.85773504, 0.85773504]), new Float32Array([0.52459335, -0.85136163, 0.85136163]), new Float32Array([0.53500134, -0.84486, 0.84486]), new Float32Array([0.5453288, -0.83823115, 0.83823115]), new Float32Array([0.5555741, -0.831476, 0.831476]), new Float32Array([0.56573576, -0.82459563, 0.82459563]), new Float32Array([0.5758122, -0.81759113, 0.81759113]), new Float32Array([0.58580196, -0.8104634, 0.8104634]), new Float32Array([0.5957035, -0.8032137, 0.8032137]), new Float32Array([0.6055153, -0.79584306, 0.79584306]), new Float32Array([0.6152359, -0.78835255, 0.78835255]), new Float32Array([0.6248639, -0.7807433, 0.7807433]), new Float32Array([0.6343978, -0.7730165, 0.7730165]), new Float32Array([0.64383614, -0.7651733, 0.7651733]), new Float32Array([0.65317756, -0.7572149, 0.7572149]), new Float32Array([0.6624206, -0.7491424, 0.7491424]), new Float32Array([0.6715638, -0.7409571, 0.7409571]), new Float32Array([0.68060595, -0.7326602, 0.7326602]), new Float32Array([0.6895456, -0.72425294, 0.72425294]), new Float32Array([0.69838136, -0.7157366, 0.7157366]), new Float32Array([0.70711195, -0.70711255, 0.70711255]), new Float32Array([0.7157361, -0.69838196, 0.69838196]), new Float32Array([0.7242524, -0.6895462, 0.6895462]), new Float32Array([0.73265964, -0.6806066, 0.6806066]), new Float32Array([0.7409566, -0.67156446, 0.67156446]), new Float32Array([0.74914193, -0.6624212, 0.6624212]), new Float32Array([0.7572145, -0.6531782, 0.6531782]), new Float32Array([0.765173, -0.64383686, 0.64383686]), new Float32Array([0.77301633, -0.6343985, 0.6343985]), new Float32Array([0.7807432, -0.6248647, 0.6248647]), new Float32Array([0.7883525, -0.61523676, 0.61523676]), new Float32Array([0.795843, -0.60551614, 0.60551614]), new Float32Array([0.8032137, -0.5957043, 0.5957043]), new Float32Array([0.8104635, -0.58580285, 0.58580285]), new Float32Array([0.81759113, -0.5758131, 0.5758131]), new Float32Array([0.8245957, -0.56573665, 0.56573665]), new Float32Array([0.8314761, -0.55557495, 0.55557495]), new Float32Array([0.83823127, -0.54532963, 0.54532963]), new Float32Array([0.8448602, -0.5350022, 0.5350022]), new Float32Array([0.8513619, -0.5245941, 0.5245941]), new Float32Array([0.8577354, -0.5141071, 0.5141071]), new Float32Array([0.86397976, -0.50354266, 0.50354266]), new Float32Array([0.87009394, -0.4929024, 0.4929024]), new Float32Array([0.8760771, -0.4821879, 0.4821879]), new Float32Array([0.8819284, -0.4714008, 0.4714008]), new Float32Array([0.8876468, -0.46054268, 0.46054268]), new Float32Array([0.8932316, -0.44961524, 0.44961524]), new Float32Array([0.8986818, -0.43862006, 0.43862006]), new Float32Array([0.9039967, -0.42755884, 0.42755884]), new Float32Array([0.90917546, -0.41643322, 0.41643322]), new Float32Array([0.9142173, -0.4052449, 0.4052449]), new Float32Array([0.91912144, -0.39399552, 0.39399552]), new Float32Array([0.9238872, -0.38268682, 0.38268682]), new Float32Array([0.92851377, -0.3713205, 0.3713205]), new Float32Array([0.9330005, -0.35989824, 0.35989824]), new Float32Array([0.9373468, -0.3484218, 0.3484218]), new Float32Array([0.9415519, -0.3368929, 0.3368929]), new Float32Array([0.94561523, -0.32531324, 0.32531324]), new Float32Array([0.94953614, -0.31368458, 0.31368458]), new Float32Array([0.95331407, -0.30200872, 0.30200872]), new Float32Array([0.9569484, -0.29028735, 0.29028735]), new Float32Array([0.9604386, -0.27852228, 0.27852228]), new Float32Array([0.9637842, -0.26671523, 0.26671523]), new Float32Array([0.9669847, -0.25486803, 0.25486803]), new Float32Array([0.97003955, -0.24298245, 0.24298245]), new Float32Array([0.9729483, -0.23106027, 0.23106027]), new Float32Array([0.9757105, -0.2191033, 0.2191033]), new Float32Array([0.9783258, -0.20711334, 0.20711334]), new Float32Array([0.9807937, -0.19509219, 0.19509219]), new Float32Array([0.98311394, -0.18304165, 0.18304165]), new Float32Array([0.9852861, -0.17096354, 0.17096354]), new Float32Array([0.98730993, -0.15885969, 0.15885969]), new Float32Array([0.98918504, -0.14673191, 0.14673191]), new Float32Array([0.9909112, -0.13458204, 0.13458204]), new Float32Array([0.9924881, -0.12241191, 0.12241191]), new Float32Array([0.9939155, -0.11022334, 0.11022334]), new Float32Array([0.9951933, -0.09801817, 0.09801817]), new Float32Array([0.9963212, -0.08579824, 0.08579824]), new Float32Array([0.9972991, -0.073565386, 0.073565386]), new Float32Array([0.99812675, -0.061321456, 0.061321456]), new Float32Array([0.9988041, -0.04906829, 0.04906829]), new Float32Array([0.99933106, -0.03680773, 0.03680773]), new Float32Array([0.9997075, -0.02454163, 0.02454163]), new Float32Array([0.9999334, -0.012271833, 0.012271833])];
    constructor.FFT_TABLE_64 = [new Float32Array([1.0, 0.0]), new Float32Array([0.9951847, 0.09801714]), new Float32Array([0.98078525, 0.19509032]), new Float32Array([0.9569403, 0.2902847]), new Float32Array([0.9238795, 0.38268346]), new Float32Array([0.88192123, 0.47139674]), new Float32Array([0.83146954, 0.55557024]), new Float32Array([0.7730104, 0.6343933]), new Float32Array([0.7071067, 0.70710677]), new Float32Array([0.6343932, 0.77301043]), new Float32Array([0.5555701, 0.8314696]), new Float32Array([0.47139663, 0.88192123]), new Float32Array([0.38268334, 0.92387944]), new Float32Array([0.29028457, 0.95694023]), new Float32Array([0.19509023, 0.9807852]), new Float32Array([0.09801706, 0.9951846]), new Float32Array([-6.7055225E-8, 0.9999999]), new Float32Array([-0.09801719, 0.9951846]), new Float32Array([-0.19509035, 0.98078513]), new Float32Array([-0.2902847, 0.9569402]), new Float32Array([-0.38268346, 0.9238794]), new Float32Array([-0.47139674, 0.8819211]), new Float32Array([-0.55557024, 0.8314694]), new Float32Array([-0.6343933, 0.77301025]), new Float32Array([-0.7071067, 0.7071066]), new Float32Array([-0.7730104, 0.6343931]), new Float32Array([-0.83146954, 0.55557]), new Float32Array([-0.8819212, 0.4713965]), new Float32Array([-0.9238794, 0.38268322]), new Float32Array([-0.9569402, 0.29028445]), new Float32Array([-0.98078513, 0.19509012]), new Float32Array([-0.99518454, 0.09801695]), new Float32Array([-0.99999976, -1.7881393E-7]), new Float32Array([-0.9951845, -0.0980173]), new Float32Array([-0.980785, -0.19509046]), new Float32Array([-0.95694005, -0.29028478]), new Float32Array([-0.92387927, -0.38268352]), new Float32Array([-0.881921, -0.47139677]), new Float32Array([-0.8314693, -0.55557024]), new Float32Array([-0.77301013, -0.6343933]), new Float32Array([-0.7071065, -0.7071067]), new Float32Array([-0.634393, -0.7730104]), new Float32Array([-0.5555699, -0.83146954]), new Float32Array([-0.4713964, -0.8819212]), new Float32Array([-0.3826831, -0.9238794]), new Float32Array([-0.29028434, -0.9569402]), new Float32Array([-0.19509, -0.9807851]), new Float32Array([-0.098016836, -0.9951845]), new Float32Array([2.8312206E-7, -0.9999997]), new Float32Array([0.098017395, -0.9951844]), new Float32Array([0.19509055, -0.98078495]), new Float32Array([0.29028487, -0.95693994]), new Float32Array([0.3826836, -0.92387915]), new Float32Array([0.47139686, -0.8819209]), new Float32Array([0.55557036, -0.8314692]), new Float32Array([0.63439333, -0.77301]), new Float32Array([0.70710677, -0.70710635]), new Float32Array([0.7730104, -0.63439286]), new Float32Array([0.8314695, -0.55556977]), new Float32Array([0.88192105, -0.47139627]), new Float32Array([0.92387927, -0.38268298]), new Float32Array([0.95694005, -0.29028425]), new Float32Array([0.98078495, -0.19508994]), new Float32Array([0.99518436, -0.09801678])];
    constructor.FFT_TABLE_480 = [new Float32Array([1.0, 0.0, 0.0]), new Float32Array([0.99991435, 0.013089596, -0.013089596]), new Float32Array([0.99965733, 0.02617695, -0.02617695]), new Float32Array([0.999229, 0.039259817, -0.039259817]), new Float32Array([0.9986295, 0.05233596, -0.05233596]), new Float32Array([0.99785894, 0.06540313, -0.06540313]), new Float32Array([0.99691737, 0.0784591, -0.0784591]), new Float32Array([0.99580497, 0.09150162, -0.09150162]), new Float32Array([0.994522, 0.10452847, -0.10452847]), new Float32Array([0.9930686, 0.11753741, -0.11753741]), new Float32Array([0.991445, 0.13052621, -0.13052621]), new Float32Array([0.98965156, 0.14349265, -0.14349265]), new Float32Array([0.98768854, 0.1564345, -0.1564345]), new Float32Array([0.9855563, 0.16934955, -0.16934955]), new Float32Array([0.9832552, 0.18223558, -0.18223558]), new Float32Array([0.9807856, 0.1950904, -0.1950904]), new Float32Array([0.978148, 0.20791179, -0.20791179]), new Float32Array([0.9753427, 0.22069755, -0.22069755]), new Float32Array([0.97237027, 0.23344548, -0.23344548]), new Float32Array([0.9692313, 0.24615341, -0.24615341]), new Float32Array([0.96592623, 0.25881916, -0.25881916]), new Float32Array([0.9624557, 0.27144057, -0.27144057]), new Float32Array([0.9588202, 0.28401548, -0.28401548]), new Float32Array([0.9550204, 0.29654172, -0.29654172]), new Float32Array([0.951057, 0.30901715, -0.30901715]), new Float32Array([0.94693065, 0.32143965, -0.32143965]), new Float32Array([0.94264203, 0.33380705, -0.33380705]), new Float32Array([0.9381919, 0.3461173, -0.3461173]), new Float32Array([0.933581, 0.3583682, -0.3583682]), new Float32Array([0.9288101, 0.3705577, -0.3705577]), new Float32Array([0.9238801, 0.3826837, -0.3826837]), new Float32Array([0.9187918, 0.39474413, -0.39474413]), new Float32Array([0.913546, 0.40673694, -0.40673694]), new Float32Array([0.90814376, 0.41866004, -0.41866004]), new Float32Array([0.90258586, 0.43051142, -0.43051142]), new Float32Array([0.89687335, 0.44228902, -0.44228902]), new Float32Array([0.8910071, 0.45399085, -0.45399085]), new Float32Array([0.88498825, 0.46561489, -0.46561489]), new Float32Array([0.87881774, 0.47715914, -0.47715914]), new Float32Array([0.87249666, 0.48862165, -0.48862165]), new Float32Array([0.86602604, 0.5000004, -0.5000004]), new Float32Array([0.85940707, 0.51129353, -0.51129353]), new Float32Array([0.8526408, 0.522499, -0.522499]), new Float32Array([0.8457285, 0.533615, -0.533615]), new Float32Array([0.83867127, 0.5446395, -0.5446395]), new Float32Array([0.8314703, 0.5555707, -0.5555707]), new Float32Array([0.8241269, 0.5664068, -0.5664068]), new Float32Array([0.8166423, 0.57714576, -0.57714576]), new Float32Array([0.8090177, 0.58778584, -0.58778584]), new Float32Array([0.8012545, 0.5983252, -0.5983252]), new Float32Array([0.7933541, 0.608762, -0.608762]), new Float32Array([0.7853177, 0.61909455, -0.61909455]), new Float32Array([0.77714676, 0.629321, -0.629321]), new Float32Array([0.76884264, 0.63943964, -0.63943964]), new Float32Array([0.7604068, 0.6494487, -0.6494487]), new Float32Array([0.75184065, 0.6593465, -0.6593465]), new Float32Array([0.7431457, 0.66913134, -0.66913134]), new Float32Array([0.7343234, 0.6788015, -0.6788015]), new Float32Array([0.72537524, 0.6883554, -0.6883554]), new Float32Array([0.7163028, 0.6977913, -0.6977913]), new Float32Array([0.70710766, 0.7071076, -0.7071076]), new Float32Array([0.69779134, 0.7163028, -0.7163028]), new Float32Array([0.68835545, 0.7253753, -0.7253753]), new Float32Array([0.67880166, 0.7343235, -0.7343235]), new Float32Array([0.6691315, 0.7431459, -0.7431459]), new Float32Array([0.6593467, 0.7518409, -0.7518409]), new Float32Array([0.64944893, 0.7604071, -0.7604071]), new Float32Array([0.6394399, 0.768843, -0.768843]), new Float32Array([0.6293213, 0.7771471, -0.7771471]), new Float32Array([0.61909485, 0.7853181, -0.7853181]), new Float32Array([0.6087623, 0.7933545, -0.7933545]), new Float32Array([0.5983255, 0.801255, -0.801255]), new Float32Array([0.58778614, 0.8090182, -0.8090182]), new Float32Array([0.57714605, 0.81664276, -0.81664276]), new Float32Array([0.56640714, 0.8241274, -0.8241274]), new Float32Array([0.55557114, 0.83147085, -0.83147085]), new Float32Array([0.54463995, 0.8386718, -0.8386718]), new Float32Array([0.5336154, 0.8457291, -0.8457291]), new Float32Array([0.52249944, 0.8526415, -0.8526415]), new Float32Array([0.51129395, 0.85940784, -0.85940784]), new Float32Array([0.50000083, 0.8660269, -0.8660269]), new Float32Array([0.48862207, 0.87249756, -0.87249756]), new Float32Array([0.4771596, 0.8788187, -0.8788187]), new Float32Array([0.46561536, 0.88498926, -0.88498926]), new Float32Array([0.45399132, 0.89100814, -0.89100814]), new Float32Array([0.4422895, 0.8968744, -0.8968744]), new Float32Array([0.4305119, 0.902587, -0.902587]), new Float32Array([0.41866052, 0.9081449, -0.9081449]), new Float32Array([0.40673742, 0.9135472, -0.9135472]), new Float32Array([0.3947446, 0.91879296, -0.91879296]), new Float32Array([0.38268417, 0.92388135, -0.92388135]), new Float32Array([0.37055814, 0.9288114, -0.9288114]), new Float32Array([0.35836864, 0.93358225, -0.93358225]), new Float32Array([0.34611773, 0.93819314, -0.93819314]), new Float32Array([0.3338075, 0.94264334, -0.94264334]), new Float32Array([0.3214401, 0.94693196, -0.94693196]), new Float32Array([0.3090176, 0.9510583, -0.9510583]), new Float32Array([0.29654217, 0.95502174, -0.95502174]), new Float32Array([0.28401592, 0.9588216, -0.9588216]), new Float32Array([0.271441, 0.9624571, -0.9624571]), new Float32Array([0.25881958, 0.9659277, -0.9659277]), new Float32Array([0.2461538, 0.96923286, -0.96923286]), new Float32Array([0.23344585, 0.9723719, -0.9723719]), new Float32Array([0.2206979, 0.9753443, -0.9753443]), new Float32Array([0.20791212, 0.9781496, -0.9781496]), new Float32Array([0.19509073, 0.9807873, -0.9807873]), new Float32Array([0.18223591, 0.98325694, -0.98325694]), new Float32Array([0.16934988, 0.9855581, -0.9855581]), new Float32Array([0.15643482, 0.9876904, -0.9876904]), new Float32Array([0.14349295, 0.98965347, -0.98965347]), new Float32Array([0.1305265, 0.991447, -0.991447]), new Float32Array([0.117537685, 0.9930706, -0.9930706]), new Float32Array([0.104528725, 0.99452406, -0.99452406]), new Float32Array([0.09150185, 0.9958071, -0.9958071]), new Float32Array([0.07845929, 0.9969195, -0.9969195]), new Float32Array([0.0654033, 0.9978611, -0.9978611]), new Float32Array([0.052336097, 0.9986317, -0.9986317]), new Float32Array([0.03925993, 0.9992312, -0.9992312]), new Float32Array([0.026177032, 0.99965954, -0.99965954]), new Float32Array([0.013089649, 0.99991655, -0.99991655]), new Float32Array([2.4214387E-8, 1.0000023, -1.0000023]), new Float32Array([-0.013089602, 0.9999166, -0.9999166]), new Float32Array([-0.026176985, 0.9996596, -0.9996596]), new Float32Array([-0.039259885, 0.9992313, -0.9992313]), new Float32Array([-0.052336056, 0.9986318, -0.9986318]), new Float32Array([-0.06540326, 0.9978612, -0.9978612]), new Float32Array([-0.078459255, 0.99691963, -0.99691963]), new Float32Array([-0.09150181, 0.99580723, -0.99580723]), new Float32Array([-0.10452869, 0.99452424, -0.99452424]), new Float32Array([-0.117537655, 0.99307084, -0.99307084]), new Float32Array([-0.13052648, 0.99144727, -0.99144727]), new Float32Array([-0.14349295, 0.98965377, -0.98965377]), new Float32Array([-0.15643483, 0.98769075, -0.98769075]), new Float32Array([-0.16934991, 0.9855585, -0.9855585]), new Float32Array([-0.18223597, 0.9832574, -0.9832574]), new Float32Array([-0.19509082, 0.9807878, -0.9807878]), new Float32Array([-0.20791222, 0.9781502, -0.9781502]), new Float32Array([-0.220698, 0.9753449, -0.9753449]), new Float32Array([-0.23344596, 0.9723725, -0.9723725]), new Float32Array([-0.24615392, 0.9692335, -0.9692335]), new Float32Array([-0.2588197, 0.96592844, -0.96592844]), new Float32Array([-0.27144113, 0.96245784, -0.96245784]), new Float32Array([-0.28401607, 0.95882237, -0.95882237]), new Float32Array([-0.29654235, 0.9550226, -0.9550226]), new Float32Array([-0.3090178, 0.95105916, -0.95105916]), new Float32Array([-0.3214403, 0.9469328, -0.9469328]), new Float32Array([-0.33380774, 0.9426441, -0.9426441]), new Float32Array([-0.34611797, 0.9381939, -0.9381939]), new Float32Array([-0.3583689, 0.933583, -0.933583]), new Float32Array([-0.37055844, 0.92881215, -0.92881215]), new Float32Array([-0.38268447, 0.9238821, -0.9238821]), new Float32Array([-0.39474493, 0.9187938, -0.9187938]), new Float32Array([-0.40673777, 0.91354805, -0.91354805]), new Float32Array([-0.4186609, 0.9081458, -0.9081458]), new Float32Array([-0.4305123, 0.9025879, -0.9025879]), new Float32Array([-0.44228995, 0.8968753, -0.8968753]), new Float32Array([-0.4539918, 0.8910091, -0.8910091]), new Float32Array([-0.46561587, 0.8849902, -0.8849902]), new Float32Array([-0.47716016, 0.8788197, -0.8788197]), new Float32Array([-0.4886227, 0.8724986, -0.8724986]), new Float32Array([-0.5000015, 0.86602795, -0.86602795]), new Float32Array([-0.5112946, 0.859409, -0.859409]), new Float32Array([-0.5225001, 0.8526427, -0.8526427]), new Float32Array([-0.53361607, 0.84573036, -0.84573036]), new Float32Array([-0.5446406, 0.8386731, -0.8386731]), new Float32Array([-0.5555718, 0.83147216, -0.83147216]), new Float32Array([-0.56640786, 0.82412875, -0.82412875]), new Float32Array([-0.5771468, 0.81664413, -0.81664413]), new Float32Array([-0.587787, 0.80901957, -0.80901957]), new Float32Array([-0.5983263, 0.80125636, -0.80125636]), new Float32Array([-0.6087632, 0.7933559, -0.7933559]), new Float32Array([-0.6190958, 0.78531945, -0.78531945]), new Float32Array([-0.6293223, 0.7771484, -0.7771484]), new Float32Array([-0.63944095, 0.76884425, -0.76884425]), new Float32Array([-0.64945006, 0.76040834, -0.76040834]), new Float32Array([-0.6593479, 0.75184214, -0.75184214]), new Float32Array([-0.66913277, 0.7431472, -0.7431472]), new Float32Array([-0.6788029, 0.7343249, -0.7343249]), new Float32Array([-0.6883568, 0.7253767, -0.7253767]), new Float32Array([-0.69779277, 0.7163043, -0.7163043]), new Float32Array([-0.7071091, 0.70710915, -0.70710915]), new Float32Array([-0.7163043, 0.6977928, -0.6977928]), new Float32Array([-0.7253768, 0.68835694, -0.68835694]), new Float32Array([-0.734325, 0.6788031, -0.6788031]), new Float32Array([-0.7431474, 0.66913295, -0.66913295]), new Float32Array([-0.7518424, 0.65934813, -0.65934813]), new Float32Array([-0.7604086, 0.64945036, -0.64945036]), new Float32Array([-0.7688445, 0.6394413, -0.6394413]), new Float32Array([-0.77714866, 0.62932265, -0.62932265]), new Float32Array([-0.7853197, 0.6190962, -0.6190962]), new Float32Array([-0.7933561, 0.60876364, -0.60876364]), new Float32Array([-0.80125666, 0.59832674, -0.59832674]), new Float32Array([-0.8090199, 0.58778733, -0.58778733]), new Float32Array([-0.8166445, 0.57714725, -0.57714725]), new Float32Array([-0.82412916, 0.5664083, -0.5664083]), new Float32Array([-0.83147264, 0.5555722, -0.5555722]), new Float32Array([-0.83867365, 0.544641, -0.544641]), new Float32Array([-0.84573096, 0.5336164, -0.5336164]), new Float32Array([-0.8526434, 0.52250046, -0.52250046]), new Float32Array([-0.8594097, 0.51129496, -0.51129496]), new Float32Array([-0.8660287, 0.50000185, -0.50000185]), new Float32Array([-0.8724994, 0.48862305, -0.48862305]), new Float32Array([-0.87882054, 0.47716054, -0.47716054]), new Float32Array([-0.8849911, 0.4656163, -0.4656163]), new Float32Array([-0.89101005, 0.45399225, -0.45399225]), new Float32Array([-0.89687634, 0.4422904, -0.4422904]), new Float32Array([-0.9025889, 0.43051276, -0.43051276]), new Float32Array([-0.90814686, 0.41866136, -0.41866136]), new Float32Array([-0.9135492, 0.40673822, -0.40673822]), new Float32Array([-0.918795, 0.39474538, -0.39474538]), new Float32Array([-0.9238834, 0.38268492, -0.38268492]), new Float32Array([-0.9288134, 0.37055886, -0.37055886]), new Float32Array([-0.9335843, 0.35836932, -0.35836932]), new Float32Array([-0.93819517, 0.3461184, -0.3461184]), new Float32Array([-0.9426454, 0.33380815, -0.33380815]), new Float32Array([-0.94693404, 0.32144073, -0.32144073]), new Float32Array([-0.9510605, 0.3090182, -0.3090182]), new Float32Array([-0.95502394, 0.29654273, -0.29654273]), new Float32Array([-0.9588238, 0.28401646, -0.28401646]), new Float32Array([-0.9624593, 0.27144152, -0.27144152]), new Float32Array([-0.9659299, 0.25882006, -0.25882006]), new Float32Array([-0.96923506, 0.24615425, -0.24615425]), new Float32Array([-0.9723741, 0.23344627, -0.23344627]), new Float32Array([-0.9753465, 0.22069828, -0.22069828]), new Float32Array([-0.9781518, 0.20791247, -0.20791247]), new Float32Array([-0.9807895, 0.19509105, -0.19509105]), new Float32Array([-0.98325914, 0.18223621, -0.18223621]), new Float32Array([-0.9855603, 0.16935015, -0.16935015]), new Float32Array([-0.9876926, 0.15643506, -0.15643506]), new Float32Array([-0.9896557, 0.14349316, -0.14349316]), new Float32Array([-0.9914492, 0.13052668, -0.13052668]), new Float32Array([-0.9930728, 0.117537834, -0.117537834]), new Float32Array([-0.99452627, 0.104528844, -0.104528844]), new Float32Array([-0.9958093, 0.091501944, -0.091501944]), new Float32Array([-0.9969217, 0.07845937, -0.07845937]), new Float32Array([-0.9978633, 0.06540334, -0.06540334]), new Float32Array([-0.9986339, 0.05233611, -0.05233611]), new Float32Array([-0.9992334, 0.039259914, -0.039259914]), new Float32Array([-0.99966174, 0.02617699, -0.02617699]), new Float32Array([-0.99991876, 0.013089578, -0.013089578]), new Float32Array([-1.0000044, -7.636845E-8, 7.636845E-8]), new Float32Array([-0.99991876, -0.01308973, 0.01308973]), new Float32Array([-0.99966174, -0.026177142, 0.026177142]), new Float32Array([-0.9992334, -0.039260067, 0.039260067]), new Float32Array([-0.9986339, -0.052336264, 0.052336264]), new Float32Array([-0.99786335, -0.0654035, 0.0654035]), new Float32Array([-0.9969218, -0.07845952, 0.07845952]), new Float32Array([-0.9958094, -0.09150211, 0.09150211]), new Float32Array([-0.9945263, -0.10452901, 0.10452901]), new Float32Array([-0.9930729, -0.117538, 0.117538]), new Float32Array([-0.99144936, -0.13052686, 0.13052686]), new Float32Array([-0.98965585, -0.14349335, 0.14349335]), new Float32Array([-0.98769283, -0.15643525, 0.15643525]), new Float32Array([-0.9855606, -0.16935036, 0.16935036]), new Float32Array([-0.98325944, -0.18223645, 0.18223645]), new Float32Array([-0.98078984, -0.19509132, 0.19509132]), new Float32Array([-0.9781522, -0.20791276, 0.20791276]), new Float32Array([-0.9753469, -0.22069857, 0.22069857]), new Float32Array([-0.9723745, -0.23344655, 0.23344655]), new Float32Array([-0.96923554, -0.24615455, 0.24615455]), new Float32Array([-0.96593046, -0.25882035, 0.25882035]), new Float32Array([-0.96245986, -0.27144182, 0.27144182]), new Float32Array([-0.95882434, -0.2840168, 0.2840168]), new Float32Array([-0.95502454, -0.2965431, 0.2965431]), new Float32Array([-0.9510611, -0.30901858, 0.30901858]), new Float32Array([-0.9469347, -0.3214411, 0.3214411]), new Float32Array([-0.942646, -0.33380857, 0.33380857]), new Float32Array([-0.9381958, -0.34611884, 0.34611884]), new Float32Array([-0.9335849, -0.3583698, 0.3583698]), new Float32Array([-0.928814, -0.37055936, 0.37055936]), new Float32Array([-0.923884, -0.38268542, 0.38268542]), new Float32Array([-0.91879565, -0.39474592, 0.39474592]), new Float32Array([-0.9135499, -0.4067388, 0.4067388]), new Float32Array([-0.9081476, -0.41866195, 0.41866195]), new Float32Array([-0.9025897, -0.43051338, 0.43051338]), new Float32Array([-0.8968771, -0.44229105, 0.44229105]), new Float32Array([-0.8910109, -0.45399293, 0.45399293]), new Float32Array([-0.884992, -0.465617, 0.465617]), new Float32Array([-0.87882143, -0.47716132, 0.47716132]), new Float32Array([-0.8725003, -0.4886239, 0.4886239]), new Float32Array([-0.8660297, -0.50000274, 0.50000274]), new Float32Array([-0.8594107, -0.5112959, 0.5112959]), new Float32Array([-0.85264444, -0.52250147, 0.52250147]), new Float32Array([-0.8457321, -0.5336175, 0.5336175]), new Float32Array([-0.83867484, -0.5446421, 0.5446421]), new Float32Array([-0.8314739, -0.55557334, 0.55557334]), new Float32Array([-0.8241304, -0.5664094, 0.5664094]), new Float32Array([-0.8166458, -0.57714844, 0.57714844]), new Float32Array([-0.8090212, -0.5877886, 0.5877886]), new Float32Array([-0.80125797, -0.598328, 0.598328]), new Float32Array([-0.7933575, -0.6087649, 0.6087649]), new Float32Array([-0.78532106, -0.6190975, 0.6190975]), new Float32Array([-0.77715003, -0.62932396, 0.62932396]), new Float32Array([-0.76884586, -0.6394427, 0.6394427]), new Float32Array([-0.76040995, -0.6494518, 0.6494518]), new Float32Array([-0.75184375, -0.6593496, 0.6593496]), new Float32Array([-0.74314874, -0.6691345, 0.6691345]), new Float32Array([-0.73432636, -0.6788047, 0.6788047]), new Float32Array([-0.7253782, -0.6883586, 0.6883586]), new Float32Array([-0.7163058, -0.69779456, 0.69779456]), new Float32Array([-0.7071106, -0.70711094, 0.70711094]), new Float32Array([-0.6977942, -0.71630615, 0.71630615]), new Float32Array([-0.68835825, -0.72537863, 0.72537863]), new Float32Array([-0.6788044, -0.73432684, 0.73432684]), new Float32Array([-0.66913426, -0.7431492, 0.7431492]), new Float32Array([-0.6593494, -0.7518443, 0.7518443]), new Float32Array([-0.6494516, -0.76041055, 0.76041055]), new Float32Array([-0.63944256, -0.76884645, 0.76884645]), new Float32Array([-0.6293239, -0.77715063, 0.77715063]), new Float32Array([-0.6190974, -0.78532165, 0.78532165]), new Float32Array([-0.6087648, -0.7933581, 0.7933581]), new Float32Array([-0.59832793, -0.8012586, 0.8012586]), new Float32Array([-0.5877885, -0.8090219, 0.8090219]), new Float32Array([-0.5771484, -0.81664646, 0.81664646]), new Float32Array([-0.5664094, -0.82413113, 0.82413113]), new Float32Array([-0.55557334, -0.8314746, 0.8314746]), new Float32Array([-0.5446421, -0.8386756, 0.8386756]), new Float32Array([-0.5336175, -0.8457329, 0.8457329]), new Float32Array([-0.52250147, -0.85264534, 0.85264534]), new Float32Array([-0.5112959, -0.85941166, 0.85941166]), new Float32Array([-0.50000274, -0.8660307, 0.8660307]), new Float32Array([-0.48862392, -0.8725014, 0.8725014]), new Float32Array([-0.47716138, -0.8788225, 0.8788225]), new Float32Array([-0.4656171, -0.8849931, 0.8849931]), new Float32Array([-0.45399302, -0.891012, 0.891012]), new Float32Array([-0.44229114, -0.8968783, 0.8968783]), new Float32Array([-0.4305135, -0.9025909, 0.9025909]), new Float32Array([-0.41866207, -0.9081488, 0.9081488]), new Float32Array([-0.4067389, -0.91355115, 0.91355115]), new Float32Array([-0.39474607, -0.91879696, 0.91879696]), new Float32Array([-0.38268557, -0.92388535, 0.92388535]), new Float32Array([-0.3705595, -0.92881536, 0.92881536]), new Float32Array([-0.35836995, -0.93358624, 0.93358624]), new Float32Array([-0.346119, -0.9381972, 0.9381972]), new Float32Array([-0.33380872, -0.9426474, 0.9426474]), new Float32Array([-0.32144126, -0.9469361, 0.9469361]), new Float32Array([-0.3090187, -0.9510625, 0.9510625]), new Float32Array([-0.2965432, -0.955026, 0.955026]), new Float32Array([-0.2840169, -0.9588258, 0.9588258]), new Float32Array([-0.27144194, -0.96246135, 0.96246135]), new Float32Array([-0.25882047, -0.965932, 0.965932]), new Float32Array([-0.24615464, -0.96923715, 0.96923715]), new Float32Array([-0.23344663, -0.97237617, 0.97237617]), new Float32Array([-0.22069862, -0.97534865, 0.97534865]), new Float32Array([-0.2079128, -0.97815394, 0.97815394]), new Float32Array([-0.19509135, -0.9807916, 0.9807916]), new Float32Array([-0.18223648, -0.9832613, 0.9832613]), new Float32Array([-0.16935039, -0.98556244, 0.98556244]), new Float32Array([-0.15643527, -0.9876948, 0.9876948]), new Float32Array([-0.14349334, -0.9896579, 0.9896579]), new Float32Array([-0.13052683, -0.9914514, 0.9914514]), new Float32Array([-0.11753795, -0.993075, 0.993075]), new Float32Array([-0.104528934, -0.9945285, 0.9945285]), new Float32Array([-0.091502, -0.9958115, 0.9958115]), new Float32Array([-0.0784594, -0.9969239, 0.9969239]), new Float32Array([-0.06540334, -0.9978655, 0.9978655]), new Float32Array([-0.05233608, -0.9986361, 0.9986361]), new Float32Array([-0.03925986, -0.99923563, 0.99923563]), new Float32Array([-0.026176903, -0.99966395, 0.99966395]), new Float32Array([-0.013089463, -0.99992096, 0.99992096]), new Float32Array([2.1979213E-7, -1.0000067, 1.0000067]), new Float32Array([0.013089904, -0.999921, 0.999921]), new Float32Array([0.026177345, -0.999664, 0.999664]), new Float32Array([0.0392603, -0.9992357, 0.9992357]), new Float32Array([0.05233653, -0.9986362, 0.9986362]), new Float32Array([0.06540379, -0.9978656, 0.9978656]), new Float32Array([0.078459844, -0.99692404, 0.99692404]), new Float32Array([0.09150246, -0.99581164, 0.99581164]), new Float32Array([0.104529396, -0.9945286, 0.9945286]), new Float32Array([0.117538415, -0.9930752, 0.9930752]), new Float32Array([0.1305273, -0.9914516, 0.9914516]), new Float32Array([0.14349383, -0.9896581, 0.9896581]), new Float32Array([0.15643576, -0.9876951, 0.9876951]), new Float32Array([0.16935089, -0.98556286, 0.98556286]), new Float32Array([0.18223701, -0.9832617, 0.9832617]), new Float32Array([0.19509192, -0.98079205, 0.98079205]), new Float32Array([0.20791338, -0.97815436, 0.97815436]), new Float32Array([0.22069922, -0.97534907, 0.97534907]), new Float32Array([0.23344724, -0.97237664, 0.97237664]), new Float32Array([0.24615526, -0.9692376, 0.9692376]), new Float32Array([0.2588211, -0.96593255, 0.96593255]), new Float32Array([0.2714426, -0.96246195, 0.96246195]), new Float32Array([0.2840176, -0.9588264, 0.9588264]), new Float32Array([0.29654393, -0.9550266, 0.9550266]), new Float32Array([0.30901945, -0.9510632, 0.9510632]), new Float32Array([0.321442, -0.9469368, 0.9469368]), new Float32Array([0.3338095, -0.9426481, 0.9426481]), new Float32Array([0.3461198, -0.9381979, 0.9381979]), new Float32Array([0.35837078, -0.933587, 0.933587]), new Float32Array([0.37056035, -0.9288161, 0.9288161]), new Float32Array([0.38268644, -0.923886, 0.923886]), new Float32Array([0.39474696, -0.9187976, 0.9187976]), new Float32Array([0.40673983, -0.91355187, 0.91355187]), new Float32Array([0.41866302, -0.90814954, 0.90814954]), new Float32Array([0.43051448, -0.90259165, 0.90259165]), new Float32Array([0.44229218, -0.8968791, 0.8968791]), new Float32Array([0.4539941, -0.89101285, 0.89101285]), new Float32Array([0.4656182, -0.884994, 0.884994]), new Float32Array([0.47716254, -0.8788234, 0.8788234]), new Float32Array([0.4886251, -0.87250227, 0.87250227]), new Float32Array([0.500004, -0.86603165, 0.86603165]), new Float32Array([0.51129717, -0.85941267, 0.85941267]), new Float32Array([0.5225027, -0.8526464, 0.8526464]), new Float32Array([0.53361875, -0.84573406, 0.84573406]), new Float32Array([0.54464334, -0.8386768, 0.8386768]), new Float32Array([0.5555746, -0.83147585, 0.83147585]), new Float32Array([0.5664107, -0.8241324, 0.8241324]), new Float32Array([0.57714975, -0.8166477, 0.8166477]), new Float32Array([0.58778995, -0.8090231, 0.8090231]), new Float32Array([0.59832937, -0.8012598, 0.8012598]), new Float32Array([0.60876626, -0.79335934, 0.79335934]), new Float32Array([0.61909884, -0.7853229, 0.7853229]), new Float32Array([0.62932533, -0.7771519, 0.7771519]), new Float32Array([0.63944405, -0.7688477, 0.7688477]), new Float32Array([0.64945316, -0.7604118, 0.7604118]), new Float32Array([0.65935105, -0.7518456, 0.7518456]), new Float32Array([0.669136, -0.7431506, 0.7431506]), new Float32Array([0.6788062, -0.7343282, 0.7343282]), new Float32Array([0.68836015, -0.72538, 0.72538]), new Float32Array([0.69779617, -0.7163075, 0.7163075]), new Float32Array([0.70711255, -0.7071123, 0.7071123]), new Float32Array([0.7163078, -0.6977959, 0.6977959]), new Float32Array([0.72538036, -0.68836, 0.68836]), new Float32Array([0.7343286, -0.67880607, 0.67880607]), new Float32Array([0.74315107, -0.66913587, 0.66913587]), new Float32Array([0.75184613, -0.659351, 0.659351]), new Float32Array([0.7604124, -0.64945316, 0.64945316]), new Float32Array([0.7688483, -0.63944405, 0.63944405]), new Float32Array([0.7771525, -0.6293254, 0.6293254]), new Float32Array([0.7853235, -0.6190989, 0.6190989]), new Float32Array([0.79335994, -0.60876626, 0.60876626]), new Float32Array([0.8012605, -0.59832937, 0.59832937]), new Float32Array([0.80902374, -0.58778995, 0.58778995]), new Float32Array([0.81664836, -0.5771498, 0.5771498]), new Float32Array([0.82413304, -0.5664108, 0.5664108]), new Float32Array([0.83147657, -0.5555747, 0.5555747]), new Float32Array([0.8386776, -0.54464346, 0.54464346]), new Float32Array([0.84573495, -0.53361887, 0.53361887]), new Float32Array([0.85264736, -0.52250284, 0.52250284]), new Float32Array([0.8594137, -0.5112973, 0.5112973]), new Float32Array([0.8660327, -0.5000041, 0.5000041]), new Float32Array([0.8725034, -0.48862526, 0.48862526]), new Float32Array([0.8788246, -0.4771627, 0.4771627]), new Float32Array([0.88499516, -0.46561837, 0.46561837]), new Float32Array([0.8910141, -0.45399427, 0.45399427]), new Float32Array([0.8968804, -0.44229236, 0.44229236]), new Float32Array([0.90259296, -0.4305147, 0.4305147]), new Float32Array([0.9081509, -0.41866326, 0.41866326]), new Float32Array([0.91355324, -0.40674007, 0.40674007]), new Float32Array([0.91879904, -0.3947472, 0.3947472]), new Float32Array([0.92388743, -0.38268667, 0.38268667]), new Float32Array([0.9288175, -0.3705606, 0.3705606]), new Float32Array([0.93358845, -0.358371, 0.358371]), new Float32Array([0.9381994, -0.34612, 0.34612]), new Float32Array([0.9426496, -0.3338097, 0.3338097]), new Float32Array([0.9469383, -0.32144222, 0.32144222]), new Float32Array([0.9510647, -0.30901963, 0.30901963]), new Float32Array([0.9550282, -0.2965441, 0.2965441]), new Float32Array([0.95882803, -0.28401777, 0.28401777]), new Float32Array([0.96246356, -0.27144277, 0.27144277]), new Float32Array([0.9659342, -0.25882128, 0.25882128]), new Float32Array([0.96923935, -0.24615541, 0.24615541]), new Float32Array([0.9723784, -0.23344737, 0.23344737]), new Float32Array([0.97535086, -0.22069934, 0.22069934]), new Float32Array([0.97815615, -0.20791349, 0.20791349]), new Float32Array([0.98079383, -0.19509201, 0.19509201]), new Float32Array([0.98326355, -0.1822371, 0.1822371]), new Float32Array([0.98556477, -0.16935098, 0.16935098]), new Float32Array([0.9876971, -0.15643583, 0.15643583]), new Float32Array([0.9896602, -0.14349388, 0.14349388]), new Float32Array([0.9914537, -0.13052733, 0.13052733]), new Float32Array([0.99307734, -0.11753843, 0.11753843]), new Float32Array([0.9945308, -0.10452938, 0.10452938]), new Float32Array([0.99581385, -0.09150242, 0.09150242]), new Float32Array([0.9969263, -0.078459784, 0.078459784]), new Float32Array([0.9978679, -0.0654037, 0.0654037]), new Float32Array([0.9986385, -0.05233641, 0.05233641]), new Float32Array([0.999238, -0.039260153, 0.039260153]), new Float32Array([0.99966633, -0.026177168, 0.026177168]), new Float32Array([0.99992335, -0.013089697, 0.013089697])];
    constructor.FFT_TABLE_60 = [new Float32Array([1.0, 0.0]), new Float32Array([0.9945219, 0.104528464]), new Float32Array([0.9781476, 0.2079117]), new Float32Array([0.95105654, 0.309017]), new Float32Array([0.9135455, 0.40673664]), new Float32Array([0.86602545, 0.5]), new Float32Array([0.80901706, 0.58778524]), new Float32Array([0.7431449, 0.66913056]), new Float32Array([0.66913074, 0.7431448]), new Float32Array([0.58778536, 0.809017]), new Float32Array([0.5000001, 0.86602545]), new Float32Array([0.40673676, 0.9135455]), new Float32Array([0.30901712, 0.9510566]), new Float32Array([0.2079118, 0.9781477]), new Float32Array([0.104528576, 0.994522]), new Float32Array([1.0430813E-7, 1.0000001]), new Float32Array([-0.104528375, 0.99452204]), new Float32Array([-0.20791161, 0.97814775]), new Float32Array([-0.30901694, 0.95105666]), new Float32Array([-0.4067366, 0.9135456]), new Float32Array([-0.5, 0.86602557]), new Float32Array([-0.5877853, 0.8090172]), new Float32Array([-0.6691307, 0.74314505]), new Float32Array([-0.7431449, 0.66913086]), new Float32Array([-0.8090172, 0.5877855]), new Float32Array([-0.8660256, 0.5000002]), new Float32Array([-0.9135457, 0.4067368]), new Float32Array([-0.95105684, 0.30901712]), new Float32Array([-0.9781479, 0.20791179]), new Float32Array([-0.9945222, 0.10452853]), new Float32Array([-1.0000004, 3.7252903E-8]), new Float32Array([-0.9945223, -0.104528464]), new Float32Array([-0.978148, -0.20791173]), new Float32Array([-0.9510569, -0.3090171]), new Float32Array([-0.91354585, -0.4067368]), new Float32Array([-0.8660258, -0.5000002]), new Float32Array([-0.80901736, -0.5877855]), new Float32Array([-0.7431452, -0.66913086]), new Float32Array([-0.66913104, -0.7431451]), new Float32Array([-0.58778566, -0.80901736]), new Float32Array([-0.50000036, -0.86602587]), new Float32Array([-0.40673697, -0.91354597]), new Float32Array([-0.30901727, -0.9510571]), new Float32Array([-0.20791191, -0.9781482]), new Float32Array([-0.10452862, -0.9945225]), new Float32Array([-9.685755E-8, -1.0000006]), new Float32Array([0.10452843, -0.9945225]), new Float32Array([0.20791173, -0.9781482]), new Float32Array([0.30901712, -0.95105714]), new Float32Array([0.40673685, -0.9135461]), new Float32Array([0.5000003, -0.86602604]), new Float32Array([0.5877856, -0.8090176]), new Float32Array([0.669131, -0.7431454]), new Float32Array([0.7431453, -0.66913116]), new Float32Array([0.80901754, -0.5877858]), new Float32Array([0.86602604, -0.5000005]), new Float32Array([0.91354614, -0.40673706]), new Float32Array([0.95105726, -0.30901736]), new Float32Array([0.9781484, -0.20791197]), new Float32Array([0.99452275, -0.104528666])];
}, {FFT_TABLE_512: "Array", FFT_TABLE_64: "Array", FFT_TABLE_480: "Array", FFT_TABLE_60: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IDCT4x4 = function() {};
IDCT4x4 = stjs.extend(IDCT4x4, null, [], function(constructor, prototype) {
    constructor.idct = function(blk, off) {
        var i;
        for (i = 0; i < 4; i++) {
            IDCT4x4.idct4row(blk, off + (i << 2));
        }
        for (i = 0; i < 4; i++) {
            IDCT4x4.idct4col_add(blk, off + i);
        }
    };
    constructor.CN_SHIFT = 12;
    constructor.C_FIX = function(x) {
        return (stjs.trunc(((x) * 1.414213562 * (1 << IDCT4x4.CN_SHIFT) + 0.5)));
    };
    constructor.C1 = IDCT4x4.C_FIX(0.6532814824);
    constructor.C2 = IDCT4x4.C_FIX(0.2705980501);
    constructor.C3 = IDCT4x4.C_FIX(0.5);
    constructor.C_SHIFT = (4 + 2 + 12);
    constructor.idct4col_add = function(blk, off) {
        var c0, c1, c2, c3, a0, a1, a2, a3;
        a0 = blk[off];
        a1 = blk[off + 4];
        a2 = blk[off + 8];
        a3 = blk[off + 12];
        c0 = (a0 + a2) * IDCT4x4.C3 + (1 << (IDCT4x4.C_SHIFT - 1));
        c2 = (a0 - a2) * IDCT4x4.C3 + (1 << (IDCT4x4.C_SHIFT - 1));
        c1 = a1 * IDCT4x4.C1 + a3 * IDCT4x4.C2;
        c3 = a1 * IDCT4x4.C2 - a3 * IDCT4x4.C1;
        blk[off] = ((c0 + c1) >> IDCT4x4.C_SHIFT);
        blk[off + 4] = ((c2 + c3) >> IDCT4x4.C_SHIFT);
        blk[off + 8] = ((c2 - c3) >> IDCT4x4.C_SHIFT);
        blk[off + 12] = ((c0 - c1) >> IDCT4x4.C_SHIFT);
    };
    constructor.RN_SHIFT = 15;
    constructor.R_FIX = function(x) {
        return (stjs.trunc(((x) * 1.414213562 * (1 << IDCT4x4.RN_SHIFT) + 0.5)));
    };
    constructor.R1 = IDCT4x4.R_FIX(0.6532814824);
    constructor.R2 = IDCT4x4.R_FIX(0.2705980501);
    constructor.R3 = IDCT4x4.R_FIX(0.5);
    constructor.R_SHIFT = 11;
    constructor.idct4row = function(blk, off) {
        var c0, c1, c2, c3, a0, a1, a2, a3;
        a0 = blk[off];
        a1 = blk[off + 1];
        a2 = blk[off + 2];
        a3 = blk[off + 3];
        c0 = (a0 + a2) * IDCT4x4.R3 + (1 << (IDCT4x4.R_SHIFT - 1));
        c2 = (a0 - a2) * IDCT4x4.R3 + (1 << (IDCT4x4.R_SHIFT - 1));
        c1 = a1 * IDCT4x4.R1 + a3 * IDCT4x4.R2;
        c3 = a1 * IDCT4x4.R2 - a3 * IDCT4x4.R1;
        blk[off] = (c0 + c1) >> IDCT4x4.R_SHIFT;
        blk[off + 1] = (c2 + c3) >> IDCT4x4.R_SHIFT;
        blk[off + 2] = (c2 - c3) >> IDCT4x4.R_SHIFT;
        blk[off + 3] = (c0 - c1) >> IDCT4x4.R_SHIFT;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MBType = function(intra, code) {
    this.intra = intra;
    this._code = code;
};
MBType = stjs.extend(MBType, null, [], function(constructor, prototype) {
    constructor.I_NxN = new MBType(true, 0);
    constructor.I_16x16 = new MBType(true, 1);
    constructor.I_PCM = new MBType(true, 25);
    constructor.P_16x16 = new MBType(false, 0);
    constructor.P_16x8 = new MBType(false, 1);
    constructor.P_8x16 = new MBType(false, 2);
    constructor.P_8x8 = new MBType(false, 3);
    constructor.P_8x8ref0 = new MBType(false, 4);
    constructor.B_Direct_16x16 = new MBType(false, 0);
    constructor.B_L0_16x16 = new MBType(false, 1);
    constructor.B_L1_16x16 = new MBType(false, 2);
    constructor.B_Bi_16x16 = new MBType(false, 3);
    constructor.B_L0_L0_16x8 = new MBType(false, 4);
    constructor.B_L0_L0_8x16 = new MBType(false, 5);
    constructor.B_L1_L1_16x8 = new MBType(false, 6);
    constructor.B_L1_L1_8x16 = new MBType(false, 7);
    constructor.B_L0_L1_16x8 = new MBType(false, 8);
    constructor.B_L0_L1_8x16 = new MBType(false, 9);
    constructor.B_L1_L0_16x8 = new MBType(false, 10);
    constructor.B_L1_L0_8x16 = new MBType(false, 11);
    constructor.B_L0_Bi_16x8 = new MBType(false, 12);
    constructor.B_L0_Bi_8x16 = new MBType(false, 13);
    constructor.B_L1_Bi_16x8 = new MBType(false, 14);
    constructor.B_L1_Bi_8x16 = new MBType(false, 15);
    constructor.B_Bi_L0_16x8 = new MBType(false, 16);
    constructor.B_Bi_L0_8x16 = new MBType(false, 17);
    constructor.B_Bi_L1_16x8 = new MBType(false, 18);
    constructor.B_Bi_L1_8x16 = new MBType(false, 19);
    constructor.B_Bi_Bi_16x8 = new MBType(false, 20);
    constructor.B_Bi_Bi_8x16 = new MBType(false, 21);
    constructor.B_8x8 = new MBType(false, 22);
    prototype.intra = false;
    prototype._code = 0;
    prototype.isIntra = function() {
        return this.intra;
    };
    prototype.code = function() {
        return this._code;
    };
}, {I_NxN: "MBType", I_16x16: "MBType", I_PCM: "MBType", P_16x16: "MBType", P_16x8: "MBType", P_8x16: "MBType", P_8x8: "MBType", P_8x8ref0: "MBType", B_Direct_16x16: "MBType", B_L0_16x16: "MBType", B_L1_16x16: "MBType", B_Bi_16x16: "MBType", B_L0_L0_16x8: "MBType", B_L0_L0_8x16: "MBType", B_L1_L1_16x8: "MBType", B_L1_L1_8x16: "MBType", B_L0_L1_16x8: "MBType", B_L0_L1_8x16: "MBType", B_L1_L0_16x8: "MBType", B_L1_L0_8x16: "MBType", B_L0_Bi_16x8: "MBType", B_L0_Bi_8x16: "MBType", B_L1_Bi_16x8: "MBType", B_L1_Bi_8x16: "MBType", B_Bi_L0_16x8: "MBType", B_Bi_L0_8x16: "MBType", B_Bi_L1_16x8: "MBType", B_Bi_L1_8x16: "MBType", B_Bi_Bi_16x8: "MBType", B_Bi_Bi_8x16: "MBType", B_8x8: "MBType"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var SyntaxConstants = function() {};
SyntaxConstants = stjs.extend(SyntaxConstants, null, [], function(constructor, prototype) {
    constructor.MAX_ELEMENTS = 16;
    constructor.BYTE_MASK = 255;
    constructor.MIN_INPUT_SIZE = 768;
    constructor.WINDOW_LEN_LONG = 1024;
    constructor.WINDOW_LEN_SHORT = stjs.trunc(SyntaxConstants.WINDOW_LEN_LONG / 8);
    constructor.WINDOW_SMALL_LEN_LONG = 960;
    constructor.WINDOW_SMALL_LEN_SHORT = stjs.trunc(SyntaxConstants.WINDOW_SMALL_LEN_LONG / 8);
    constructor.ELEMENT_SCE = 0;
    constructor.ELEMENT_CPE = 1;
    constructor.ELEMENT_CCE = 2;
    constructor.ELEMENT_LFE = 3;
    constructor.ELEMENT_DSE = 4;
    constructor.ELEMENT_PCE = 5;
    constructor.ELEMENT_FIL = 6;
    constructor.ELEMENT_END = 7;
    constructor.MAX_WINDOW_COUNT = 8;
    constructor.MAX_WINDOW_GROUP_COUNT = SyntaxConstants.MAX_WINDOW_COUNT;
    constructor.MAX_LTP_SFB = 40;
    constructor.MAX_SECTIONS = 120;
    constructor.MAX_MS_MASK = 128;
    constructor.SQRT2 = 1.4142135;
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  All possible channel configurations for AAC.
 *  
 *  @author in-somnia
 */
var ChannelConfiguration = function(chCount, descr) {
    this.chCount = chCount;
    this.descr = descr;
};
ChannelConfiguration = stjs.extend(ChannelConfiguration, null, [], function(constructor, prototype) {
    constructor.CHANNEL_CONFIG_UNSUPPORTED = new ChannelConfiguration(-1, "invalid");
    constructor.CHANNEL_CONFIG_NONE = new ChannelConfiguration(0, "No channel");
    constructor.CHANNEL_CONFIG_MONO = new ChannelConfiguration(1, "Mono");
    constructor.CHANNEL_CONFIG_STEREO = new ChannelConfiguration(2, "Stereo");
    constructor.CHANNEL_CONFIG_STEREO_PLUS_CENTER = new ChannelConfiguration(3, "Stereo+Center");
    constructor.CHANNEL_CONFIG_STEREO_PLUS_CENTER_PLUS_REAR_MONO = new ChannelConfiguration(4, "Stereo+Center+Rear");
    constructor.CHANNEL_CONFIG_FIVE = new ChannelConfiguration(5, "Five channels");
    constructor.CHANNEL_CONFIG_FIVE_PLUS_ONE = new ChannelConfiguration(6, "Five channels+LF");
    constructor.CHANNEL_CONFIG_SEVEN_PLUS_ONE = new ChannelConfiguration(8, "Seven channels+LF");
    constructor.forInt = function(i) {
        var c;
        switch (i) {
            case 0:
                c = ChannelConfiguration.CHANNEL_CONFIG_NONE;
                break;
            case 1:
                c = ChannelConfiguration.CHANNEL_CONFIG_MONO;
                break;
            case 2:
                c = ChannelConfiguration.CHANNEL_CONFIG_STEREO;
                break;
            case 3:
                c = ChannelConfiguration.CHANNEL_CONFIG_STEREO_PLUS_CENTER;
                break;
            case 4:
                c = ChannelConfiguration.CHANNEL_CONFIG_STEREO_PLUS_CENTER_PLUS_REAR_MONO;
                break;
            case 5:
                c = ChannelConfiguration.CHANNEL_CONFIG_FIVE;
                break;
            case 6:
                c = ChannelConfiguration.CHANNEL_CONFIG_FIVE_PLUS_ONE;
                break;
            case 7:
            case 8:
                c = ChannelConfiguration.CHANNEL_CONFIG_SEVEN_PLUS_ONE;
                break;
            default:
                c = ChannelConfiguration.CHANNEL_CONFIG_UNSUPPORTED;
                break;
        }
        return c;
    };
    prototype.chCount = 0;
    prototype.descr = null;
    /**
     *  Returns the number of channels in this configuration.
     */
    prototype.getChannelCount = function() {
        return this.chCount;
    };
    /**
     *  Returns a short description of this configuration.
     *  
     *  @return the channel configuration's description
     */
    prototype.getDescription = function() {
        return this.descr;
    };
    /**
     *  Returns a string representation of this channel configuration. The method
     *  is identical to <code>getDescription()</code>.
     *  
     *  @return the channel configuration's description
     */
    prototype.toString = function() {
        return this.descr;
    };
}, {CHANNEL_CONFIG_UNSUPPORTED: "ChannelConfiguration", CHANNEL_CONFIG_NONE: "ChannelConfiguration", CHANNEL_CONFIG_MONO: "ChannelConfiguration", CHANNEL_CONFIG_STEREO: "ChannelConfiguration", CHANNEL_CONFIG_STEREO_PLUS_CENTER: "ChannelConfiguration", CHANNEL_CONFIG_STEREO_PLUS_CENTER_PLUS_REAR_MONO: "ChannelConfiguration", CHANNEL_CONFIG_FIVE: "ChannelConfiguration", CHANNEL_CONFIG_FIVE_PLUS_ONE: "ChannelConfiguration", CHANNEL_CONFIG_SEVEN_PLUS_ONE: "ChannelConfiguration"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  An enumeration that represents all possible sample frequencies AAC data can
 *  have.
 *  
 *  @author in-somnia
 */
var SampleFrequency = function(index, freqency, prediction, maxTNS_SFB) {
    this.index = index;
    this.frequency = freqency;
    this.prediction = prediction;
    this.maxTNS_SFB = maxTNS_SFB;
};
SampleFrequency = stjs.extend(SampleFrequency, null, [], function(constructor, prototype) {
    constructor.SAMPLE_FREQUENCY_96000 = new SampleFrequency(0, 96000, new Int32Array([33, 512]), new Int32Array([31, 9]));
    constructor.SAMPLE_FREQUENCY_88200 = new SampleFrequency(1, 88200, new Int32Array([33, 512]), new Int32Array([31, 9]));
    constructor.SAMPLE_FREQUENCY_64000 = new SampleFrequency(2, 64000, new Int32Array([38, 664]), new Int32Array([34, 10]));
    constructor.SAMPLE_FREQUENCY_48000 = new SampleFrequency(3, 48000, new Int32Array([40, 672]), new Int32Array([40, 14]));
    constructor.SAMPLE_FREQUENCY_44100 = new SampleFrequency(4, 44100, new Int32Array([40, 672]), new Int32Array([42, 14]));
    constructor.SAMPLE_FREQUENCY_32000 = new SampleFrequency(5, 32000, new Int32Array([40, 672]), new Int32Array([51, 14]));
    constructor.SAMPLE_FREQUENCY_24000 = new SampleFrequency(6, 24000, new Int32Array([41, 652]), new Int32Array([46, 14]));
    constructor.SAMPLE_FREQUENCY_22050 = new SampleFrequency(7, 22050, new Int32Array([41, 652]), new Int32Array([46, 14]));
    constructor.SAMPLE_FREQUENCY_16000 = new SampleFrequency(8, 16000, new Int32Array([37, 664]), new Int32Array([42, 14]));
    constructor.SAMPLE_FREQUENCY_12000 = new SampleFrequency(9, 12000, new Int32Array([37, 664]), new Int32Array([42, 14]));
    constructor.SAMPLE_FREQUENCY_11025 = new SampleFrequency(10, 11025, new Int32Array([37, 664]), new Int32Array([42, 14]));
    constructor.SAMPLE_FREQUENCY_8000 = new SampleFrequency(11, 8000, new Int32Array([34, 664]), new Int32Array([39, 14]));
    constructor.SAMPLE_FREQUENCY_NONE = new SampleFrequency(-1, 0, new Int32Array([0, 0]), new Int32Array([0, 0]));
    constructor._values = [SampleFrequency.SAMPLE_FREQUENCY_96000, SampleFrequency.SAMPLE_FREQUENCY_88200, SampleFrequency.SAMPLE_FREQUENCY_64000, SampleFrequency.SAMPLE_FREQUENCY_48000, SampleFrequency.SAMPLE_FREQUENCY_44100, SampleFrequency.SAMPLE_FREQUENCY_32000, SampleFrequency.SAMPLE_FREQUENCY_24000, SampleFrequency.SAMPLE_FREQUENCY_22050, SampleFrequency.SAMPLE_FREQUENCY_16000, SampleFrequency.SAMPLE_FREQUENCY_12000, SampleFrequency.SAMPLE_FREQUENCY_11025, SampleFrequency.SAMPLE_FREQUENCY_8000, SampleFrequency.SAMPLE_FREQUENCY_NONE];
    constructor.values = function() {
        return SampleFrequency._values;
    };
    /**
     *  Returns a sample frequency instance for the given index. If the index is
     *  not between 0 and 11 inclusive, SAMPLE_FREQUENCY_NONE is returned.
     *  
     *  @return a sample frequency with the given index
     */
    constructor.forInt = function(i) {
        var freq;
        if (i >= 0 && i < 12) 
            freq = SampleFrequency.values()[i];
         else 
            freq = SampleFrequency.SAMPLE_FREQUENCY_NONE;
        return freq;
    };
    constructor.forFrequency = function(i) {
        var all = SampleFrequency.values();
        var freq = null;
        for (var j = 0; freq == null && j < 12; j++) {
            if (i == all[j].frequency) 
                freq = all[j];
        }
        if (freq == null) 
            freq = SampleFrequency.SAMPLE_FREQUENCY_NONE;
        return freq;
    };
    prototype.index = 0;
    prototype.frequency = 0;
    prototype.prediction = null;
    prototype.maxTNS_SFB = null;
    /**
     *  Returns this sample frequency's index between 0 (96000) and 11 (8000) or
     *  -1 if this is SAMPLE_FREQUENCY_NONE.
     *  
     *  @return the sample frequency's index
     */
    prototype.getIndex = function() {
        return this.index;
    };
    /**
     *  Returns the sample frequency as integer value. This may be a value
     *  between 96000 and 8000, or 0 if this is SAMPLE_FREQUENCY_NONE.
     *  
     *  @return the sample frequency
     */
    prototype.getFrequency = function() {
        return this.frequency;
    };
    /**
     *  Returns the highest scale factor band allowed for ICPrediction at this
     *  sample frequency. This method is mainly used internally.
     *  
     *  @return the highest prediction SFB
     */
    prototype.getMaximalPredictionSFB = function() {
        return this.prediction[0];
    };
    /**
     *  Returns the number of predictors allowed for ICPrediction at this sample
     *  frequency. This method is mainly used internally.
     *  
     *  @return the number of ICPredictors
     */
    prototype.getPredictorCount = function() {
        return this.prediction[1];
    };
    /**
     *  Returns the highest scale factor band allowed for TNS at this sample
     *  frequency. This method is mainly used internally.
     *  
     *  @return the highest SFB for TNS
     */
    prototype.getMaximalTNS_SFB = function(shortWindow) {
        return this.maxTNS_SFB[shortWindow ? 1 : 0];
    };
    /**
     *  Returns a string representation of this sample frequency. The method is
     *  identical to <code>getDescription()</code>.
     *  
     *  @return the sample frequency's description
     */
    prototype.toString = function() {
        return Integer.toString(this.frequency);
    };
}, {SAMPLE_FREQUENCY_96000: "SampleFrequency", SAMPLE_FREQUENCY_88200: "SampleFrequency", SAMPLE_FREQUENCY_64000: "SampleFrequency", SAMPLE_FREQUENCY_48000: "SampleFrequency", SAMPLE_FREQUENCY_44100: "SampleFrequency", SAMPLE_FREQUENCY_32000: "SampleFrequency", SAMPLE_FREQUENCY_24000: "SampleFrequency", SAMPLE_FREQUENCY_22050: "SampleFrequency", SAMPLE_FREQUENCY_16000: "SampleFrequency", SAMPLE_FREQUENCY_12000: "SampleFrequency", SAMPLE_FREQUENCY_11025: "SampleFrequency", SAMPLE_FREQUENCY_8000: "SampleFrequency", SAMPLE_FREQUENCY_NONE: "SampleFrequency", _values: "Array", prediction: "Int32Array", maxTNS_SFB: "Int32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var IBitStream = function() {};
IBitStream = stjs.extend(IBitStream, null, [], function(constructor, prototype) {
    prototype.destroy = function() {};
    prototype.setData = function(data) {};
    prototype.byteAlign = function() {};
    prototype.reset = function() {};
    prototype.getPosition = function() {};
    prototype.getBitsLeft = function() {};
    prototype.readBits = function(n) {};
    prototype.readBit = function() {};
    prototype.readBool = function() {};
    prototype.peekBits = function(n) {};
    prototype.peekBit = function() {};
    prototype.skipBits = function(n) {};
    prototype.skipBit = function() {};
    prototype.maskBits = function(n) {};
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Different AAC profiles.
 *  The function <code>Decoder.canDecode</code> specifies if the decoder can
 *  handle a given format.
 *  More precisely, the ISO standard calls these 'object types'.
 *  @author in-somnia
 */
var Profile = function(num, descr, supported) {
    this.num = num;
    this.descr = descr;
    this.supported = supported;
};
Profile = stjs.extend(Profile, null, [], function(constructor, prototype) {
    constructor.UNKNOWN = new Profile(-1, "unknown", false);
    constructor.AAC_MAIN = new Profile(1, "AAC Main Profile", true);
    constructor.AAC_LC = new Profile(2, "AAC Low Complexity", true);
    constructor.AAC_SSR = new Profile(3, "AAC Scalable Sample Rate", false);
    constructor.AAC_LTP = new Profile(4, "AAC Long Term Prediction", false);
    constructor.AAC_SBR = new Profile(5, "AAC SBR", true);
    constructor.AAC_SCALABLE = new Profile(6, "Scalable AAC", false);
    constructor.TWIN_VQ = new Profile(7, "TwinVQ", false);
    constructor.AAC_LD = new Profile(11, "AAC Low Delay", false);
    constructor.ER_AAC_LC = new Profile(17, "Error Resilient AAC Low Complexity", true);
    constructor.ER_AAC_SSR = new Profile(18, "Error Resilient AAC SSR", false);
    constructor.ER_AAC_LTP = new Profile(19, "Error Resilient AAC Long Term Prediction", false);
    constructor.ER_AAC_SCALABLE = new Profile(20, "Error Resilient Scalable AAC", false);
    constructor.ER_TWIN_VQ = new Profile(21, "Error Resilient TwinVQ", false);
    constructor.ER_BSAC = new Profile(22, "Error Resilient BSAC", false);
    constructor.ER_AAC_LD = new Profile(23, "Error Resilient AAC Low Delay", false);
    constructor.ALL = [Profile.AAC_MAIN, Profile.AAC_LC, Profile.AAC_SSR, Profile.AAC_LTP, Profile.AAC_SBR, Profile.AAC_SCALABLE, Profile.TWIN_VQ, null, null, null, Profile.AAC_LD, null, null, null, null, null, Profile.ER_AAC_LC, Profile.ER_AAC_SSR, Profile.ER_AAC_LTP, Profile.ER_AAC_SCALABLE, Profile.ER_TWIN_VQ, Profile.ER_BSAC, Profile.ER_AAC_LD];
    /**
     *  Returns a profile instance for the given index. If the index is not
     *  between 1 and 23 inclusive, UNKNOWN is returned.
     *  @return a profile with the given index
     */
    constructor.forInt = function(i) {
        var p;
        if (i <= 0 || i > Profile.ALL.length) 
            p = Profile.UNKNOWN;
         else 
            p = Profile.ALL[i - 1];
        return p;
    };
    prototype.num = 0;
    prototype.descr = null;
    prototype.supported = false;
    /**
     *  Returns this profile's index between 1 and 23 or -1 if this is the
     *  <code>UNKNOWN</code> instance.
     *  @return the profile's index
     */
    prototype.getIndex = function() {
        return this.num;
    };
    /**
     *  Returns a short description of this profile.
     *  @return the profile's description
     */
    prototype.getDescription = function() {
        return this.descr;
    };
    /**
     *  Returns a string representation of this profile. The method is
     *  identical to <code>getDescription()</code>.
     *  @return the profile's description
     */
    prototype.toString = function() {
        return this.descr;
    };
    /**
     *  Returns a boolean, indicating if this profile can be decoded by the
     *  <code>Decoder</code>.
     *  @see Decoder#canDecode(net.sourceforge.jaad.aac.Profile) 
     *  @return true if the profile is supported
     */
    prototype.isDecodingSupported = function() {
        return this.supported;
    };
    /**
     *  Returns a boolean, indicating if this profile contains error resilient
     *  tools. That is, if it's index is higher than 16, since the first error
     *  resilient profile is ER_AAC_LC (17).
     *  This method is mainly used internally.
     *  @return true if the profile uses error resilience
     */
    prototype.isErrorResilientProfile = function() {
        return this.num > 16;
    };
}, {UNKNOWN: "Profile", AAC_MAIN: "Profile", AAC_LC: "Profile", AAC_SSR: "Profile", AAC_LTP: "Profile", AAC_SBR: "Profile", AAC_SCALABLE: "Profile", TWIN_VQ: "Profile", AAC_LD: "Profile", ER_AAC_LC: "Profile", ER_AAC_SSR: "Profile", ER_AAC_LTP: "Profile", ER_AAC_SCALABLE: "Profile", ER_TWIN_VQ: "Profile", ER_BSAC: "Profile", ER_AAC_LD: "Profile", ALL: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AudioFilter = function() {};
AudioFilter = stjs.extend(AudioFilter, null, [], function(constructor, prototype) {
    prototype.filter = function(_in, inPos, out) {};
    prototype.getDelay = function() {};
    prototype.getNInputs = function() {};
    prototype.getNOutputs = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Constants shared by both MQ encoder and decoder
 *  
 *  @author The JCodec project
 *  
 */
var MQConst = function() {};
MQConst = stjs.extend(MQConst, null, [], function(constructor, prototype) {
    constructor.pLps = new Int32Array([22017, 13313, 6145, 2753, 1313, 545, 22017, 21505, 18433, 14337, 12289, 9217, 7169, 5633, 22017, 21505, 20737, 18433, 14337, 13313, 12289, 10241, 9217, 8705, 7169, 6145, 5633, 5121, 4609, 4353, 2753, 2497, 2209, 1313, 1089, 673, 545, 321, 273, 133, 73, 37, 21, 9, 5, 1, 22017]);
    constructor.mpsSwitch = new Int32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    constructor.transitLPS = new Int32Array([1, 6, 9, 12, 29, 33, 6, 14, 14, 14, 17, 18, 20, 21, 14, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 46]);
    constructor.transitMPS = new Int32Array([1, 2, 3, 4, 5, 38, 7, 8, 9, 10, 11, 12, 13, 29, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 45, 46]);
}, {pLps: "Int32Array", mpsSwitch: "Int32Array", transitLPS: "Int32Array", transitMPS: "Int32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var ScaleFactorBands = function() {};
ScaleFactorBands = stjs.extend(ScaleFactorBands, null, [], function(constructor, prototype) {
    constructor.SWB_LONG_WINDOW_COUNT = new Int32Array([41, 41, 47, 49, 49, 51, 47, 47, 43, 43, 43, 40]);
    constructor.SWB_OFFSET_1024_96 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 156, 172, 188, 212, 240, 276, 320, 384, 448, 512, 576, 640, 704, 768, 832, 896, 960, 1024, -1]);
    constructor.SWB_OFFSET_1024_64 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 64, 72, 80, 88, 100, 112, 124, 140, 156, 172, 192, 216, 240, 268, 304, 344, 384, 424, 464, 504, 544, 584, 624, 664, 704, 744, 784, 824, 864, 904, 944, 984, 1024, -1]);
    constructor.SWB_OFFSET_1024_48 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 160, 176, 196, 216, 240, 264, 292, 320, 352, 384, 416, 448, 480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 1024, -1]);
    constructor.SWB_OFFSET_1024_32 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 160, 176, 196, 216, 240, 264, 292, 320, 352, 384, 416, 448, 480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 960, 992, 1024, -1]);
    constructor.SWB_OFFSET_1024_24 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 52, 60, 68, 76, 84, 92, 100, 108, 116, 124, 136, 148, 160, 172, 188, 204, 220, 240, 260, 284, 308, 336, 364, 396, 432, 468, 508, 552, 600, 652, 704, 768, 832, 896, 960, 1024, -1]);
    constructor.SWB_OFFSET_1024_16 = new Int32Array([0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 100, 112, 124, 136, 148, 160, 172, 184, 196, 212, 228, 244, 260, 280, 300, 320, 344, 368, 396, 424, 456, 492, 532, 572, 616, 664, 716, 772, 832, 896, 960, 1024, -1]);
    constructor.SWB_OFFSET_1024_8 = new Int32Array([0, 12, 24, 36, 48, 60, 72, 84, 96, 108, 120, 132, 144, 156, 172, 188, 204, 220, 236, 252, 268, 288, 308, 328, 348, 372, 396, 420, 448, 476, 508, 544, 580, 620, 664, 712, 764, 820, 880, 944, 1024, -1]);
    constructor.SWB_OFFSET_LONG_WINDOW = [ScaleFactorBands.SWB_OFFSET_1024_96, ScaleFactorBands.SWB_OFFSET_1024_96, ScaleFactorBands.SWB_OFFSET_1024_64, ScaleFactorBands.SWB_OFFSET_1024_48, ScaleFactorBands.SWB_OFFSET_1024_48, ScaleFactorBands.SWB_OFFSET_1024_32, ScaleFactorBands.SWB_OFFSET_1024_24, ScaleFactorBands.SWB_OFFSET_1024_24, ScaleFactorBands.SWB_OFFSET_1024_16, ScaleFactorBands.SWB_OFFSET_1024_16, ScaleFactorBands.SWB_OFFSET_1024_16, ScaleFactorBands.SWB_OFFSET_1024_8];
    constructor.SWB_SHORT_WINDOW_COUNT = new Int32Array([12, 12, 12, 14, 14, 14, 15, 15, 15, 15, 15, 15]);
    constructor.SWB_OFFSET_128_96 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 32, 40, 48, 64, 92, 128, -1]);
    constructor.SWB_OFFSET_128_64 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 32, 40, 48, 64, 92, 128, -1]);
    constructor.SWB_OFFSET_128_48 = new Int32Array([0, 4, 8, 12, 16, 20, 28, 36, 44, 56, 68, 80, 96, 112, 128, -1]);
    constructor.SWB_OFFSET_128_24 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 36, 44, 52, 64, 76, 92, 108, 128, -1]);
    constructor.SWB_OFFSET_128_16 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 40, 48, 60, 72, 88, 108, 128, -1]);
    constructor.SWB_OFFSET_128_8 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 36, 44, 52, 60, 72, 88, 108, 128, -1]);
    constructor.SWB_OFFSET_SHORT_WINDOW = [ScaleFactorBands.SWB_OFFSET_128_96, ScaleFactorBands.SWB_OFFSET_128_96, ScaleFactorBands.SWB_OFFSET_128_64, ScaleFactorBands.SWB_OFFSET_128_48, ScaleFactorBands.SWB_OFFSET_128_48, ScaleFactorBands.SWB_OFFSET_128_48, ScaleFactorBands.SWB_OFFSET_128_24, ScaleFactorBands.SWB_OFFSET_128_24, ScaleFactorBands.SWB_OFFSET_128_16, ScaleFactorBands.SWB_OFFSET_128_16, ScaleFactorBands.SWB_OFFSET_128_16, ScaleFactorBands.SWB_OFFSET_128_8];
}, {SWB_LONG_WINDOW_COUNT: "Int32Array", SWB_OFFSET_1024_96: "Int32Array", SWB_OFFSET_1024_64: "Int32Array", SWB_OFFSET_1024_48: "Int32Array", SWB_OFFSET_1024_32: "Int32Array", SWB_OFFSET_1024_24: "Int32Array", SWB_OFFSET_1024_16: "Int32Array", SWB_OFFSET_1024_8: "Int32Array", SWB_OFFSET_LONG_WINDOW: "Array", SWB_SHORT_WINDOW_COUNT: "Int32Array", SWB_OFFSET_128_96: "Int32Array", SWB_OFFSET_128_64: "Int32Array", SWB_OFFSET_128_48: "Int32Array", SWB_OFFSET_128_24: "Int32Array", SWB_OFFSET_128_16: "Int32Array", SWB_OFFSET_128_8: "Int32Array", SWB_OFFSET_SHORT_WINDOW: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AACTab = function() {};
AACTab = stjs.extend(AACTab, null, [], function(constructor, prototype) {
    constructor.codes1 = new Int32Array([2040, 497, 2045, 1013, 104, 1008, 2039, 492, 2037, 1009, 114, 1012, 116, 17, 118, 491, 108, 1014, 2044, 481, 2033, 496, 97, 502, 2034, 490, 2043, 498, 105, 493, 119, 23, 111, 486, 100, 485, 103, 21, 98, 18, 0, 20, 101, 22, 109, 489, 99, 484, 107, 19, 113, 483, 112, 499, 2046, 487, 2035, 495, 96, 494, 2032, 482, 2042, 1011, 106, 488, 117, 16, 115, 500, 110, 1015, 2038, 480, 2041, 1010, 102, 501, 2047, 503, 2036]);
    constructor.bits1 = new Int32Array([11, 9, 11, 10, 7, 10, 11, 9, 11, 10, 7, 10, 7, 5, 7, 9, 7, 10, 11, 9, 11, 9, 7, 9, 11, 9, 11, 9, 7, 9, 7, 5, 7, 9, 7, 9, 7, 5, 7, 5, 1, 5, 7, 5, 7, 9, 7, 9, 7, 5, 7, 9, 7, 9, 11, 9, 11, 9, 7, 9, 11, 9, 11, 10, 7, 9, 7, 5, 7, 9, 7, 10, 11, 9, 11, 10, 7, 9, 11, 9, 11]);
    constructor.codes2 = new Int32Array([499, 111, 509, 235, 35, 234, 503, 232, 506, 242, 45, 112, 32, 6, 43, 110, 40, 233, 505, 102, 248, 231, 27, 241, 500, 107, 501, 236, 42, 108, 44, 10, 39, 103, 26, 245, 36, 8, 31, 9, 0, 7, 29, 11, 48, 239, 28, 100, 30, 12, 41, 243, 47, 240, 508, 113, 498, 244, 33, 230, 247, 104, 504, 238, 34, 101, 49, 2, 38, 237, 37, 106, 507, 114, 510, 105, 46, 246, 511, 109, 502]);
    constructor.bits2 = new Int32Array([9, 7, 9, 8, 6, 8, 9, 8, 9, 8, 6, 7, 6, 5, 6, 7, 6, 8, 9, 7, 8, 8, 6, 8, 9, 7, 9, 8, 6, 7, 6, 5, 6, 7, 6, 8, 6, 5, 6, 5, 3, 5, 6, 5, 6, 8, 6, 7, 6, 5, 6, 8, 6, 8, 9, 7, 9, 8, 6, 8, 8, 7, 9, 8, 6, 7, 6, 4, 6, 8, 6, 7, 9, 7, 9, 7, 6, 8, 9, 7, 9]);
    constructor.codes3 = new Int32Array([0, 9, 239, 11, 25, 240, 491, 486, 1010, 10, 53, 495, 52, 55, 489, 493, 487, 1011, 494, 1005, 8186, 492, 498, 2041, 2040, 1016, 4088, 8, 56, 1014, 54, 117, 1009, 1003, 1004, 4084, 24, 118, 2036, 57, 116, 1007, 499, 500, 2038, 488, 1002, 8188, 242, 497, 4091, 1013, 2035, 4092, 238, 1015, 32766, 496, 2037, 32765, 8187, 16378, 65535, 241, 1008, 16380, 490, 1006, 16379, 4086, 4090, 32764, 2034, 4085, 65534, 1012, 2039, 32763, 4087, 4089, 32762]);
    constructor.bits3 = new Int32Array([1, 4, 8, 4, 5, 8, 9, 9, 10, 4, 6, 9, 6, 6, 9, 9, 9, 10, 9, 10, 13, 9, 9, 11, 11, 10, 12, 4, 6, 10, 6, 7, 10, 10, 10, 12, 5, 7, 11, 6, 7, 10, 9, 9, 11, 9, 10, 13, 8, 9, 12, 10, 11, 12, 8, 10, 15, 9, 11, 15, 13, 14, 16, 8, 10, 14, 9, 10, 14, 12, 12, 15, 11, 12, 16, 10, 11, 15, 12, 12, 15]);
    constructor.codes4 = new Int32Array([7, 22, 246, 24, 8, 239, 495, 243, 2040, 25, 23, 237, 21, 1, 226, 240, 112, 1008, 494, 241, 2042, 238, 228, 1010, 2038, 1007, 2045, 5, 20, 242, 9, 4, 229, 244, 232, 1012, 6, 2, 231, 3, 0, 107, 227, 105, 499, 235, 230, 1014, 110, 106, 500, 1004, 496, 1017, 245, 236, 2043, 234, 111, 1015, 2041, 1011, 4095, 233, 109, 1016, 108, 104, 501, 1006, 498, 2036, 2039, 1009, 4094, 1005, 497, 2037, 2046, 1013, 2044]);
    constructor.bits4 = new Int32Array([4, 5, 8, 5, 4, 8, 9, 8, 11, 5, 5, 8, 5, 4, 8, 8, 7, 10, 9, 8, 11, 8, 8, 10, 11, 10, 11, 4, 5, 8, 4, 4, 8, 8, 8, 10, 4, 4, 8, 4, 4, 7, 8, 7, 9, 8, 8, 10, 7, 7, 9, 10, 9, 10, 8, 8, 11, 8, 7, 10, 11, 10, 12, 8, 7, 10, 7, 7, 9, 10, 9, 11, 11, 10, 12, 10, 9, 11, 11, 10, 11]);
    constructor.codes5 = new Int32Array([8191, 4087, 2036, 2024, 1009, 2030, 2041, 4088, 8189, 4093, 2033, 1000, 488, 240, 492, 1006, 2034, 4090, 4084, 1007, 498, 232, 112, 236, 496, 1002, 2035, 2027, 491, 234, 26, 8, 25, 238, 495, 2029, 1008, 242, 115, 11, 0, 10, 113, 243, 2025, 2031, 494, 239, 24, 9, 27, 235, 489, 2028, 2038, 1003, 499, 237, 114, 233, 497, 1005, 2039, 4086, 2032, 1001, 493, 241, 490, 1004, 2040, 4089, 8188, 4092, 4085, 2026, 1011, 1010, 2037, 4091, 8190]);
    constructor.bits5 = new Int32Array([13, 12, 11, 11, 10, 11, 11, 12, 13, 12, 11, 10, 9, 8, 9, 10, 11, 12, 12, 10, 9, 8, 7, 8, 9, 10, 11, 11, 9, 8, 5, 4, 5, 8, 9, 11, 10, 8, 7, 4, 1, 4, 7, 8, 11, 11, 9, 8, 5, 4, 5, 8, 9, 11, 11, 10, 9, 8, 7, 8, 9, 10, 11, 12, 11, 10, 9, 8, 9, 10, 11, 12, 13, 12, 12, 11, 10, 10, 11, 12, 13]);
    constructor.codes6 = new Int32Array([2046, 1021, 497, 491, 500, 490, 496, 1020, 2045, 1014, 485, 234, 108, 113, 104, 240, 486, 1015, 499, 239, 50, 39, 40, 38, 49, 235, 503, 488, 111, 46, 8, 4, 6, 41, 107, 494, 495, 114, 45, 2, 0, 3, 47, 115, 506, 487, 110, 43, 7, 1, 5, 44, 109, 492, 505, 238, 48, 36, 42, 37, 51, 236, 498, 1016, 484, 237, 106, 112, 105, 116, 241, 1018, 2047, 1017, 502, 493, 504, 489, 501, 1019, 2044]);
    constructor.bits6 = new Int32Array([11, 10, 9, 9, 9, 9, 9, 10, 11, 10, 9, 8, 7, 7, 7, 8, 9, 10, 9, 8, 6, 6, 6, 6, 6, 8, 9, 9, 7, 6, 4, 4, 4, 6, 7, 9, 9, 7, 6, 4, 4, 4, 6, 7, 9, 9, 7, 6, 4, 4, 4, 6, 7, 9, 9, 8, 6, 6, 6, 6, 6, 8, 9, 10, 9, 8, 7, 7, 7, 7, 8, 10, 11, 10, 9, 9, 9, 9, 9, 10, 11]);
    constructor.codes7 = new Int32Array([0, 5, 55, 116, 242, 491, 1005, 2039, 4, 12, 53, 113, 236, 238, 494, 501, 54, 52, 114, 234, 241, 489, 499, 1013, 115, 112, 235, 240, 497, 496, 1004, 1018, 243, 237, 488, 495, 1007, 1009, 1017, 2043, 493, 239, 490, 498, 1011, 1016, 2041, 2044, 1006, 492, 500, 1012, 1015, 2040, 4093, 4094, 2038, 1008, 1010, 1014, 2042, 2045, 4092, 4095]);
    constructor.bits7 = new Int32Array([1, 3, 6, 7, 8, 9, 10, 11, 3, 4, 6, 7, 8, 8, 9, 9, 6, 6, 7, 8, 8, 9, 9, 10, 7, 7, 8, 8, 9, 9, 10, 10, 8, 8, 9, 9, 10, 10, 10, 11, 9, 8, 9, 9, 10, 10, 11, 11, 10, 9, 9, 10, 10, 11, 12, 12, 11, 10, 10, 10, 11, 11, 12, 12]);
    constructor.codes8 = new Int32Array([14, 5, 16, 48, 111, 241, 506, 1022, 3, 0, 4, 18, 44, 106, 117, 248, 15, 2, 6, 20, 46, 105, 114, 245, 47, 17, 19, 42, 50, 108, 236, 250, 113, 43, 45, 49, 109, 112, 242, 505, 239, 104, 51, 107, 110, 238, 249, 1020, 504, 116, 115, 237, 240, 246, 502, 509, 1021, 243, 244, 247, 503, 507, 508, 1023]);
    constructor.bits8 = new Int32Array([5, 4, 5, 6, 7, 8, 9, 10, 4, 3, 4, 5, 6, 7, 7, 8, 5, 4, 4, 5, 6, 7, 7, 8, 6, 5, 5, 6, 6, 7, 8, 8, 7, 6, 6, 6, 7, 7, 8, 9, 8, 7, 6, 7, 7, 8, 8, 10, 9, 7, 7, 8, 8, 8, 9, 9, 10, 8, 8, 8, 9, 9, 9, 10]);
    constructor.codes9 = new Int32Array([0, 5, 55, 231, 478, 974, 985, 1992, 1997, 4040, 4061, 8164, 8172, 4, 12, 53, 114, 234, 237, 482, 977, 979, 992, 2008, 4047, 4053, 54, 52, 113, 232, 236, 481, 975, 989, 987, 2000, 4039, 4052, 4068, 230, 112, 233, 477, 483, 978, 988, 1996, 1994, 2014, 4056, 4074, 8155, 479, 235, 476, 486, 981, 990, 1995, 2013, 2012, 4045, 4066, 4071, 8161, 976, 480, 484, 982, 1989, 2001, 2011, 4050, 2016, 4057, 4075, 8163, 8169, 1988, 485, 983, 1990, 1999, 2010, 4043, 4058, 4067, 4073, 8166, 8179, 8183, 2003, 984, 993, 2004, 2009, 4051, 4062, 8157, 8153, 8162, 8170, 8177, 8182, 2002, 980, 986, 1991, 2007, 2018, 4046, 4059, 8152, 8174, 16368, 8180, 16370, 2017, 991, 1993, 2006, 4042, 4048, 4069, 4070, 8171, 8175, 16371, 16372, 16373, 4064, 1998, 2005, 4038, 4049, 4065, 8160, 8168, 8176, 16369, 16376, 16374, 32764, 4072, 2015, 4041, 4055, 4060, 8156, 8159, 8173, 8181, 16377, 16379, 32765, 32766, 8167, 4044, 4054, 4063, 8158, 8154, 8165, 8178, 16378, 16375, 16380, 16381, 32767]);
    constructor.bits9 = new Int32Array([1, 3, 6, 8, 9, 10, 10, 11, 11, 12, 12, 13, 13, 3, 4, 6, 7, 8, 8, 9, 10, 10, 10, 11, 12, 12, 6, 6, 7, 8, 8, 9, 10, 10, 10, 11, 12, 12, 12, 8, 7, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 13, 9, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 13, 10, 9, 9, 10, 11, 11, 11, 12, 11, 12, 12, 13, 13, 11, 9, 10, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 11, 10, 10, 11, 11, 12, 12, 13, 13, 13, 13, 13, 13, 11, 10, 10, 11, 11, 11, 12, 12, 13, 13, 14, 13, 14, 11, 10, 11, 11, 12, 12, 12, 12, 13, 13, 14, 14, 14, 12, 11, 11, 12, 12, 12, 13, 13, 13, 14, 14, 14, 15, 12, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 15, 15, 13, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15]);
    constructor.codes10 = new Int32Array([34, 8, 29, 38, 95, 211, 463, 976, 983, 1005, 2032, 2038, 4093, 7, 0, 1, 9, 32, 84, 96, 213, 220, 468, 973, 990, 2023, 28, 2, 6, 12, 30, 40, 91, 205, 217, 462, 476, 985, 1009, 37, 11, 10, 13, 36, 87, 97, 204, 221, 460, 478, 979, 999, 93, 33, 31, 35, 39, 89, 100, 216, 223, 466, 482, 989, 1006, 209, 85, 41, 86, 88, 98, 206, 224, 226, 474, 980, 995, 2027, 457, 94, 90, 92, 99, 202, 218, 455, 458, 480, 987, 1000, 2028, 483, 210, 203, 208, 215, 219, 454, 469, 472, 970, 986, 2026, 2033, 481, 212, 207, 214, 222, 225, 464, 470, 977, 981, 1010, 2030, 2043, 1001, 461, 456, 459, 465, 471, 479, 975, 992, 1007, 2022, 2040, 4090, 1003, 477, 467, 473, 475, 978, 972, 988, 1002, 2029, 2035, 2041, 4089, 2034, 974, 484, 971, 984, 982, 994, 997, 2024, 2036, 2037, 2039, 4091, 2042, 1004, 991, 993, 996, 998, 1008, 2025, 2031, 4088, 4094, 4092, 4095]);
    constructor.bits10 = new Int32Array([6, 5, 6, 6, 7, 8, 9, 10, 10, 10, 11, 11, 12, 5, 4, 4, 5, 6, 7, 7, 8, 8, 9, 10, 10, 11, 6, 4, 5, 5, 6, 6, 7, 8, 8, 9, 9, 10, 10, 6, 5, 5, 5, 6, 7, 7, 8, 8, 9, 9, 10, 10, 7, 6, 6, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 8, 7, 6, 7, 7, 7, 8, 8, 8, 9, 10, 10, 11, 9, 7, 7, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11, 9, 8, 8, 8, 8, 8, 9, 9, 9, 10, 10, 11, 11, 9, 8, 8, 8, 8, 8, 9, 9, 10, 10, 10, 11, 11, 10, 9, 9, 9, 9, 9, 9, 10, 10, 10, 11, 11, 12, 10, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 12, 11, 10, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 12, 11, 10, 10, 10, 10, 10, 10, 11, 11, 12, 12, 12, 12]);
    constructor.codes11 = new Int32Array([0, 6, 25, 61, 156, 198, 423, 912, 962, 991, 2022, 2035, 4091, 2028, 4090, 4094, 910, 5, 1, 8, 20, 55, 66, 146, 175, 401, 421, 437, 926, 960, 930, 973, 2006, 174, 23, 7, 9, 24, 57, 64, 142, 163, 184, 409, 428, 449, 945, 918, 958, 970, 157, 60, 21, 22, 26, 59, 68, 145, 165, 190, 406, 430, 441, 929, 913, 933, 981, 148, 154, 54, 56, 58, 65, 140, 155, 176, 195, 414, 427, 444, 927, 911, 937, 975, 147, 191, 62, 63, 67, 69, 158, 167, 185, 404, 418, 442, 451, 934, 935, 955, 980, 159, 416, 143, 141, 144, 152, 166, 182, 196, 415, 431, 447, 921, 959, 948, 969, 999, 168, 438, 171, 164, 170, 178, 194, 197, 408, 420, 440, 908, 932, 964, 966, 989, 1000, 173, 943, 402, 189, 188, 398, 407, 410, 419, 433, 909, 920, 951, 979, 977, 987, 2013, 180, 990, 425, 411, 412, 417, 426, 429, 435, 907, 946, 952, 974, 993, 992, 2002, 2021, 183, 2019, 443, 424, 422, 432, 434, 439, 923, 922, 954, 949, 982, 2007, 996, 2008, 2026, 186, 2024, 928, 445, 436, 906, 452, 914, 938, 944, 956, 983, 2004, 2012, 2011, 2005, 2032, 193, 2043, 968, 931, 917, 925, 940, 942, 965, 984, 994, 998, 2020, 2023, 2016, 2025, 2039, 400, 2034, 915, 446, 448, 916, 919, 941, 963, 961, 978, 2010, 2009, 2015, 2027, 2036, 2042, 405, 2040, 957, 924, 939, 936, 947, 953, 976, 995, 997, 2018, 2014, 2029, 2033, 2041, 2044, 403, 4093, 988, 950, 967, 972, 971, 985, 986, 2003, 2017, 2030, 2031, 2037, 2038, 4092, 4095, 413, 450, 181, 161, 150, 151, 149, 153, 160, 162, 172, 169, 177, 179, 187, 192, 399, 4]);
    constructor.bits11 = new Int32Array([4, 5, 6, 7, 8, 8, 9, 10, 10, 10, 11, 11, 12, 11, 12, 12, 10, 5, 4, 5, 6, 7, 7, 8, 8, 9, 9, 9, 10, 10, 10, 10, 11, 8, 6, 5, 5, 6, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 8, 7, 6, 6, 6, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 8, 8, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 8, 8, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 8, 9, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 8, 9, 8, 8, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 10, 8, 10, 9, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 8, 10, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 8, 11, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 10, 11, 11, 8, 11, 10, 9, 9, 10, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 8, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 9, 11, 10, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 9, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 9, 12, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 5]);
    constructor.ff_aac_scalefactor_code = new Int32Array([262120, 262118, 262119, 262117, 524277, 524273, 524269, 524278, 524270, 524271, 524272, 524284, 524285, 524287, 524286, 524279, 524280, 524283, 524281, 262116, 524282, 262115, 131055, 131056, 65525, 131054, 65522, 65523, 65524, 65521, 32758, 32759, 16377, 16373, 16375, 16371, 16374, 16370, 8183, 8181, 4089, 4087, 4086, 2041, 4084, 2040, 1017, 1015, 1013, 504, 503, 250, 248, 246, 121, 58, 56, 26, 11, 4, 0, 10, 12, 27, 57, 59, 120, 122, 247, 249, 502, 505, 1012, 1014, 1016, 2037, 2036, 2038, 2039, 4085, 4088, 8180, 8182, 8184, 16376, 16372, 65520, 32756, 65526, 32757, 262114, 524249, 524250, 524251, 524252, 524253, 524254, 524248, 524242, 524243, 524244, 524245, 524246, 524274, 524255, 524263, 524264, 524265, 524266, 524267, 524262, 524256, 524257, 524258, 524259, 524260, 524261, 524247, 524268, 524276, 524275]);
    constructor.ff_aac_scalefactor_bits = new Int32Array([18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 18, 19, 18, 17, 17, 16, 17, 16, 16, 16, 16, 15, 15, 14, 14, 14, 14, 14, 14, 13, 13, 12, 12, 12, 11, 12, 11, 10, 10, 10, 9, 9, 8, 8, 8, 7, 6, 6, 5, 4, 3, 1, 4, 4, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 16, 15, 16, 15, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19]);
    constructor.maxSfbTab = new Int32Array([33, 33, 38, 40, 40, 40, 41, 41, 37, 37, 37, 34, 34]);
    constructor.ltpCoefTab = new Float32Array([0.570829, 0.696616, 0.813004, 0.911304, 0.9849, 1.067894, 1.194601, 1.369533]);
    constructor.ff_aac_num_swb_1024 = new Int32Array([41, 41, 47, 49, 49, 51, 47, 47, 43, 43, 43, 40, 40]);
    constructor.ff_aac_num_swb_128 = new Int32Array([12, 12, 12, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15]);
    constructor.swb_offset_1024_96 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 156, 172, 188, 212, 240, 276, 320, 384, 448, 512, 576, 640, 704, 768, 832, 896, 960, 1024]);
    constructor.swb_offset_128_96 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 32, 40, 48, 64, 92, 128]);
    constructor.swb_offset_1024_64 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 64, 72, 80, 88, 100, 112, 124, 140, 156, 172, 192, 216, 240, 268, 304, 344, 384, 424, 464, 504, 544, 584, 624, 664, 704, 744, 784, 824, 864, 904, 944, 984, 1024]);
    constructor.swb_offset_1024_48 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 160, 176, 196, 216, 240, 264, 292, 320, 352, 384, 416, 448, 480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 1024]);
    constructor.swb_offset_128_48 = new Int32Array([0, 4, 8, 12, 16, 20, 28, 36, 44, 56, 68, 80, 96, 112, 128]);
    constructor.swb_offset_1024_32 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48, 56, 64, 72, 80, 88, 96, 108, 120, 132, 144, 160, 176, 196, 216, 240, 264, 292, 320, 352, 384, 416, 448, 480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 960, 992, 1024]);
    constructor.swb_offset_1024_24 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 52, 60, 68, 76, 84, 92, 100, 108, 116, 124, 136, 148, 160, 172, 188, 204, 220, 240, 260, 284, 308, 336, 364, 396, 432, 468, 508, 552, 600, 652, 704, 768, 832, 896, 960, 1024]);
    constructor.swb_offset_128_24 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 36, 44, 52, 64, 76, 92, 108, 128]);
    constructor.swb_offset_1024_16 = new Int32Array([0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 100, 112, 124, 136, 148, 160, 172, 184, 196, 212, 228, 244, 260, 280, 300, 320, 344, 368, 396, 424, 456, 492, 532, 572, 616, 664, 716, 772, 832, 896, 960, 1024]);
    constructor.swb_offset_128_16 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 32, 40, 48, 60, 72, 88, 108, 128]);
    constructor.swb_offset_1024_8 = new Int32Array([0, 12, 24, 36, 48, 60, 72, 84, 96, 108, 120, 132, 144, 156, 172, 188, 204, 220, 236, 252, 268, 288, 308, 328, 348, 372, 396, 420, 448, 476, 508, 544, 580, 620, 664, 712, 764, 820, 880, 944, 1024]);
    constructor.swb_offset_128_8 = new Int32Array([0, 4, 8, 12, 16, 20, 24, 28, 36, 44, 52, 60, 72, 88, 108, 128]);
    constructor.ff_swb_offset_1024 = [AACTab.swb_offset_1024_96, AACTab.swb_offset_1024_96, AACTab.swb_offset_1024_64, AACTab.swb_offset_1024_48, AACTab.swb_offset_1024_48, AACTab.swb_offset_1024_32, AACTab.swb_offset_1024_24, AACTab.swb_offset_1024_24, AACTab.swb_offset_1024_16, AACTab.swb_offset_1024_16, AACTab.swb_offset_1024_16, AACTab.swb_offset_1024_8, AACTab.swb_offset_1024_8];
    constructor.ff_swb_offset_128 = [AACTab.swb_offset_128_96, AACTab.swb_offset_128_96, AACTab.swb_offset_128_96, AACTab.swb_offset_128_48, AACTab.swb_offset_128_48, AACTab.swb_offset_128_48, AACTab.swb_offset_128_24, AACTab.swb_offset_128_24, AACTab.swb_offset_128_16, AACTab.swb_offset_128_16, AACTab.swb_offset_128_16, AACTab.swb_offset_128_8, AACTab.swb_offset_128_8];
    constructor.tns_tmp2_map_1_3 = new Float32Array([0.0, -0.43388373, 0.6427876, 0.34202015]);
    constructor.tns_tmp2_map_0_3 = new Float32Array([0.0, -0.43388373, -0.7818315, -0.9749279, 0.9848077, 0.8660254, 0.6427876, 0.34202015]);
    constructor.tns_tmp2_map_1_4 = new Float32Array([0.0, -0.2079117, -0.40673664, -0.58778524, 0.6736956, 0.52643216, 0.36124167, 0.18374951]);
    constructor.tns_tmp2_map_0_4 = new Float32Array([0.0, -0.2079117, -0.40673664, -0.58778524, -0.7431448, -0.8660254, -0.95105654, -0.9945219, 0.99573416, 0.9618256, 0.8951633, 0.7980172, 0.6736956, 0.52643216, 0.36124167, 0.18374951]);
    constructor.tns_tmp2_map = [AACTab.tns_tmp2_map_0_3, AACTab.tns_tmp2_map_0_4, AACTab.tns_tmp2_map_1_3, AACTab.tns_tmp2_map_1_4];
    constructor.codebook_vector0_vals = new Float32Array([-1.0, 0.0, 1.0]);
    constructor.codebook_vector02_idx = new Int32Array([0, 33088, 33152, 16656, 49744, 49808, 16672, 49760, 49824, 8452, 41540, 41604, 25108, 58196, 58260, 25124, 58212, 58276, 8456, 41544, 41608, 25112, 58200, 58264, 25128, 58216, 58280, 4353, 37441, 37505, 21009, 54097, 54161, 21025, 54113, 54177, 12805, 45893, 45957, 29461, 62549, 62613, 29477, 62565, 62629, 12809, 45897, 45961, 29465, 62553, 62617, 29481, 62569, 62633, 4354, 37442, 37506, 21010, 54098, 54162, 21026, 54114, 54178, 12806, 45894, 45958, 29462, 62550, 62614, 29478, 62566, 62630, 12810, 45898, 45962, 29466, 62554, 62618, 29482, 62570, 62634]);
    constructor.codebook_vector4_vals = new Float32Array([-6.349604, -4.326749, -2.5198421, -1.0, 0.0, 1.0, 2.5198421, 4.326749, 6.349604]);
    constructor.codebook_vector4_idx = new Int32Array([0, 16, 32, 48, 64, 80, 96, 112, 128, 1, 17, 33, 49, 65, 81, 97, 113, 129, 2, 18, 34, 50, 66, 82, 98, 114, 130, 3, 19, 35, 51, 67, 83, 99, 115, 131, 4, 20, 36, 52, 68, 84, 100, 116, 132, 5, 21, 37, 53, 69, 85, 101, 117, 133, 6, 22, 38, 54, 70, 86, 102, 118, 134, 7, 23, 39, 55, 71, 87, 103, 119, 135, 8, 24, 40, 56, 72, 88, 104, 120, 136]);
    constructor.codebook_vector6_idx = new Int32Array([0, 272, 288, 304, 320, 336, 352, 368, 4353, 529, 545, 561, 577, 593, 609, 625, 4354, 530, 546, 562, 578, 594, 610, 626, 4355, 531, 547, 563, 579, 595, 611, 627, 4356, 532, 548, 564, 580, 596, 612, 628, 4357, 533, 549, 565, 581, 597, 613, 629, 4358, 534, 550, 566, 582, 598, 614, 630, 4359, 535, 551, 567, 583, 599, 615, 631]);
    constructor.codebook_vector8_idx = new Int32Array([0, 272, 288, 304, 320, 336, 352, 368, 384, 400, 416, 432, 448, 4353, 529, 545, 561, 577, 593, 609, 625, 641, 657, 673, 689, 705, 4354, 530, 546, 562, 578, 594, 610, 626, 642, 658, 674, 690, 706, 4355, 531, 547, 563, 579, 595, 611, 627, 643, 659, 675, 691, 707, 4356, 532, 548, 564, 580, 596, 612, 628, 644, 660, 676, 692, 708, 4357, 533, 549, 565, 581, 597, 613, 629, 645, 661, 677, 693, 709, 4358, 534, 550, 566, 582, 598, 614, 630, 646, 662, 678, 694, 710, 4359, 535, 551, 567, 583, 599, 615, 631, 647, 663, 679, 695, 711, 4360, 536, 552, 568, 584, 600, 616, 632, 648, 664, 680, 696, 712, 4361, 537, 553, 569, 585, 601, 617, 633, 649, 665, 681, 697, 713, 4362, 538, 554, 570, 586, 602, 618, 634, 650, 666, 682, 698, 714, 4363, 539, 555, 571, 587, 603, 619, 635, 651, 667, 683, 699, 715, 4364, 540, 556, 572, 588, 604, 620, 636, 652, 668, 684, 700, 716]);
    constructor.codebook_vector10_vals = new Float32Array([0.0, 1.0, 2.5198421, 4.326749, 6.349604, 8.54988, 10.902723, 13.390518, 16.0, 18.720755, 21.544348, 24.463781, 27.473143, 30.56735, 33.741993, 36.99318]);
    constructor.codebook_vector10_idx = new Int32Array([0, 4112, 4128, 4144, 4160, 4176, 4192, 4208, 4224, 4240, 4256, 4272, 4288, 4304, 4320, 4336, 4608, 4097, 8209, 8225, 8241, 8257, 8273, 8289, 8305, 8321, 8337, 8353, 8369, 8385, 8401, 8417, 8433, 8705, 4098, 8210, 8226, 8242, 8258, 8274, 8290, 8306, 8322, 8338, 8354, 8370, 8386, 8402, 8418, 8434, 8706, 4099, 8211, 8227, 8243, 8259, 8275, 8291, 8307, 8323, 8339, 8355, 8371, 8387, 8403, 8419, 8435, 8707, 4100, 8212, 8228, 8244, 8260, 8276, 8292, 8308, 8324, 8340, 8356, 8372, 8388, 8404, 8420, 8436, 8708, 4101, 8213, 8229, 8245, 8261, 8277, 8293, 8309, 8325, 8341, 8357, 8373, 8389, 8405, 8421, 8437, 8709, 4102, 8214, 8230, 8246, 8262, 8278, 8294, 8310, 8326, 8342, 8358, 8374, 8390, 8406, 8422, 8438, 8710, 4103, 8215, 8231, 8247, 8263, 8279, 8295, 8311, 8327, 8343, 8359, 8375, 8391, 8407, 8423, 8439, 8711, 4104, 8216, 8232, 8248, 8264, 8280, 8296, 8312, 8328, 8344, 8360, 8376, 8392, 8408, 8424, 8440, 8712, 4105, 8217, 8233, 8249, 8265, 8281, 8297, 8313, 8329, 8345, 8361, 8377, 8393, 8409, 8425, 8441, 8713, 4106, 8218, 8234, 8250, 8266, 8282, 8298, 8314, 8330, 8346, 8362, 8378, 8394, 8410, 8426, 8442, 8714, 4107, 8219, 8235, 8251, 8267, 8283, 8299, 8315, 8331, 8347, 8363, 8379, 8395, 8411, 8427, 8443, 8715, 4108, 8220, 8236, 8252, 8268, 8284, 8300, 8316, 8332, 8348, 8364, 8380, 8396, 8412, 8428, 8444, 8716, 4109, 8221, 8237, 8253, 8269, 8285, 8301, 8317, 8333, 8349, 8365, 8381, 8397, 8413, 8429, 8445, 8717, 4110, 8222, 8238, 8254, 8270, 8286, 8302, 8318, 8334, 8350, 8366, 8382, 8398, 8414, 8430, 8446, 8718, 4111, 8223, 8239, 8255, 8271, 8287, 8303, 8319, 8335, 8351, 8367, 8383, 8399, 8415, 8431, 8447, 8719, 4352, 8464, 8480, 8496, 8512, 8528, 8544, 8560, 8576, 8592, 8608, 8624, 8640, 8656, 8672, 8688, 8960]);
}, {codes1: "Int32Array", bits1: "Int32Array", codes2: "Int32Array", bits2: "Int32Array", codes3: "Int32Array", bits3: "Int32Array", codes4: "Int32Array", bits4: "Int32Array", codes5: "Int32Array", bits5: "Int32Array", codes6: "Int32Array", bits6: "Int32Array", codes7: "Int32Array", bits7: "Int32Array", codes8: "Int32Array", bits8: "Int32Array", codes9: "Int32Array", bits9: "Int32Array", codes10: "Int32Array", bits10: "Int32Array", codes11: "Int32Array", bits11: "Int32Array", ff_aac_scalefactor_code: "Int32Array", ff_aac_scalefactor_bits: "Int32Array", maxSfbTab: "Int32Array", ltpCoefTab: "Float32Array", ff_aac_num_swb_1024: "Int32Array", ff_aac_num_swb_128: "Int32Array", swb_offset_1024_96: "Int32Array", swb_offset_128_96: "Int32Array", swb_offset_1024_64: "Int32Array", swb_offset_1024_48: "Int32Array", swb_offset_128_48: "Int32Array", swb_offset_1024_32: "Int32Array", swb_offset_1024_24: "Int32Array", swb_offset_128_24: "Int32Array", swb_offset_1024_16: "Int32Array", swb_offset_128_16: "Int32Array", swb_offset_1024_8: "Int32Array", swb_offset_128_8: "Int32Array", ff_swb_offset_1024: "Array", ff_swb_offset_128: "Array", tns_tmp2_map_1_3: "Float32Array", tns_tmp2_map_0_3: "Float32Array", tns_tmp2_map_1_4: "Float32Array", tns_tmp2_map_0_4: "Float32Array", tns_tmp2_map: "Array", codebook_vector0_vals: "Float32Array", codebook_vector02_idx: "Int32Array", codebook_vector4_vals: "Float32Array", codebook_vector4_idx: "Int32Array", codebook_vector6_idx: "Int32Array", codebook_vector8_idx: "Int32Array", codebook_vector10_vals: "Float32Array", codebook_vector10_idx: "Int32Array"}, {});
var TelevisionHeader = function() {};
TelevisionHeader = stjs.extend(TelevisionHeader, null, [], function(constructor, prototype) {
    prototype.timecode = 0;
    prototype.userBits = 0;
    prototype.interlace = 0;
    prototype.filedNumber = 0;
    prototype.videoSignalStarted = 0;
    prototype.zero = 0;
    prototype.horSamplingRateHz = 0;
    prototype.vertSampleRateHz = 0;
    prototype.frameRate = 0;
    prototype.timeOffset = 0;
    prototype.gamma = 0;
    prototype.blackLevel = 0;
    prototype.blackGain = 0;
    prototype.breakpoint = 0;
    prototype.referenceWhiteLevel = 0;
    prototype.integrationTime = 0;
}, {}, {});
var IBoxFactory = function() {};
IBoxFactory = stjs.extend(IBoxFactory, null, [], function(constructor, prototype) {
    prototype.newBox = function(header) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Mapper = function() {};
Mapper = stjs.extend(Mapper, null, [], function(constructor, prototype) {
    prototype.leftAvailable = function(index) {};
    prototype.topAvailable = function(index) {};
    prototype.getAddress = function(index) {};
    prototype.getMbX = function(mbIndex) {};
    prototype.getMbY = function(mbIndex) {};
    prototype.topRightAvailable = function(mbIndex) {};
    prototype.topLeftAvailable = function(mbIdx) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AudioDecoder = function() {};
AudioDecoder = stjs.extend(AudioDecoder, null, [], function(constructor, prototype) {
    prototype.decodeFrame = function(frame, dst) {};
    prototype.getCodecMeta = function(data) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var TrackType = stjs.enumeration("VIDEO", "AUDIO", "TEXT", "OTHER");
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Codebook for ProRes codes
 *  
 *  @author The JCodec project
 *  
 */
var Codebook = function(riceOrder, expOrder, switchBits) {
    this.riceOrder = riceOrder;
    this.expOrder = expOrder;
    this.switchBits = switchBits;
    this.golombOffset = (1 << expOrder) - ((switchBits + 1) << riceOrder);
    this.golombBits = expOrder - switchBits - 1;
    this.riceMask = (1 << riceOrder) - 1;
};
Codebook = stjs.extend(Codebook, null, [], function(constructor, prototype) {
    prototype.riceOrder = 0;
    prototype.expOrder = 0;
    prototype.switchBits = 0;
    prototype.golombOffset = 0;
    prototype.golombBits = 0;
    prototype.riceMask = 0;
}, {}, {});
var FileHeader = function() {};
FileHeader = stjs.extend(FileHeader, null, [], function(constructor, prototype) {
    prototype.magic = 0;
    prototype.imageOffset = 0;
    prototype.version = null;
    prototype.ditto = 0;
    prototype.filename = null;
    prototype.created = null;
    prototype.filesize = 0;
    prototype.creator = null;
    prototype.projectName = null;
    prototype.copyright = null;
    prototype.encKey = 0;
    prototype.genericHeaderLength = 0;
    prototype.industryHeaderLength = 0;
    prototype.userHeaderLength = 0;
}, {created: "jsutil.Date"}, {});
var DPXMetadata = function() {};
DPXMetadata = stjs.extend(DPXMetadata, null, [], function(constructor, prototype) {
    constructor.V2 = "V2.0";
    constructor.V1 = "V1.0";
    prototype.file = null;
    prototype.image = null;
    prototype.imageSource = null;
    prototype.film = null;
    prototype.television = null;
    prototype.userId = null;
    constructor.smpteTC = function(tcsmpte, prevent_dropframe) {
        var ff = DPXMetadata.bcd2uint(tcsmpte & 63);
        var ss = DPXMetadata.bcd2uint(tcsmpte >> 8 & 127);
        var mm = DPXMetadata.bcd2uint(tcsmpte >> 16 & 127);
        var hh = DPXMetadata.bcd2uint(tcsmpte >> 24 & 63);
        var drop = (tcsmpte & 1 << 30) > 0 && !prevent_dropframe;
        return String.format("%02d:%02d:%02d%c%02d", hh, mm, ss, drop ? ';'.charCodeAt(0) : ':'.charCodeAt(0), ff);
    };
    constructor.bcd2uint = function(bcd) {
        var low = bcd & 15;
        var high = bcd >> 4;
        if (low > 9 || high > 9) 
            return 0;
        return low + 10 * high;
    };
    prototype.getTimecodeString = function() {
        return DPXMetadata.smpteTC(this.television.timecode, false);
    };
}, {file: "FileHeader", image: "ImageHeader", imageSource: "ImageSourceHeader", film: "FilmHeader", television: "TelevisionHeader"}, {});
var FilmHeader = function() {};
FilmHeader = stjs.extend(FilmHeader, null, [], function(constructor, prototype) {
    prototype.idCode = null;
    prototype.type = null;
    prototype.offset = null;
    prototype.prefix = null;
    prototype.count = null;
    prototype.format = null;
}, {}, {});
var ImageHeader = function() {};
ImageHeader = stjs.extend(ImageHeader, null, [], function(constructor, prototype) {
    prototype.orientation = 0;
    prototype.numberOfImageElements = 0;
    prototype.linesPerImageElement = 0;
    prototype.pixelsPerLine = 0;
    prototype.imageElement1 = null;
}, {imageElement1: "ImageElement"}, {});
var ImageSourceHeader = function() {};
ImageSourceHeader = stjs.extend(ImageSourceHeader, null, [], function(constructor, prototype) {
    prototype.xOffset = 0;
    prototype.yOffset = 0;
    prototype.xCenter = 0.0;
    prototype.yCenter = 0.0;
    prototype.xOriginal = 0;
    prototype.yOriginal = 0;
    prototype.sourceImageFilename = null;
    prototype.sourceImageDate = null;
    prototype.deviceName = null;
    prototype.deviceSerial = null;
    prototype.borderValidity = null;
    prototype.aspectRatio = null;
}, {sourceImageDate: "jsutil.Date", borderValidity: "Int16Array", aspectRatio: "Int32Array"}, {});
var ImageElement = function() {};
ImageElement = stjs.extend(ImageElement, null, [], function(constructor, prototype) {
    prototype.dataSign = 0;
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  NAL unit type
 *  
 *  @author The JCodec project
 *  
 */
var NALUnitType = function(value, name, displayName) {
    this.value = value;
    this._name = name;
    this.displayName = displayName;
};
NALUnitType = stjs.extend(NALUnitType, null, [], function(constructor, prototype) {
    constructor.NON_IDR_SLICE = new NALUnitType(1, "NON_IDR_SLICE", "non IDR slice");
    constructor.SLICE_PART_A = new NALUnitType(2, "SLICE_PART_A", "slice part a");
    constructor.SLICE_PART_B = new NALUnitType(3, "SLICE_PART_B", "slice part b");
    constructor.SLICE_PART_C = new NALUnitType(4, "SLICE_PART_C", "slice part c");
    constructor.IDR_SLICE = new NALUnitType(5, "IDR_SLICE", "idr slice");
    constructor.SEI = new NALUnitType(6, "SEI", "sei");
    constructor.SPS = new NALUnitType(7, "SPS", "sequence parameter set");
    constructor.PPS = new NALUnitType(8, "PPS", "picture parameter set");
    constructor.ACC_UNIT_DELIM = new NALUnitType(9, "ACC_UNIT_DELIM", "access unit delimiter");
    constructor.END_OF_SEQ = new NALUnitType(10, "END_OF_SEQ", "end of sequence");
    constructor.END_OF_STREAM = new NALUnitType(11, "END_OF_STREAM", "end of stream");
    constructor.FILLER_DATA = new NALUnitType(12, "FILLER_DATA", "filler data");
    constructor.SEQ_PAR_SET_EXT = new NALUnitType(13, "SEQ_PAR_SET_EXT", "sequence parameter set extension");
    constructor.AUX_SLICE = new NALUnitType(19, "AUX_SLICE", "auxilary slice");
    constructor.lut = null;
    constructor._values = null;
    prototype.value = 0;
    prototype.displayName = null;
    prototype._name = null;
    prototype.getName = function() {
        return this.displayName;
    };
    prototype.getValue = function() {
        return this.value;
    };
    constructor.fromValue = function(value) {
        return value < NALUnitType.lut.length ? NALUnitType.lut[value] : null;
    };
    prototype.toString = function() {
        return this._name;
    };
}, {NON_IDR_SLICE: "NALUnitType", SLICE_PART_A: "NALUnitType", SLICE_PART_B: "NALUnitType", SLICE_PART_C: "NALUnitType", IDR_SLICE: "NALUnitType", SEI: "NALUnitType", SPS: "NALUnitType", PPS: "NALUnitType", ACC_UNIT_DELIM: "NALUnitType", END_OF_SEQ: "NALUnitType", END_OF_STREAM: "NALUnitType", FILLER_DATA: "NALUnitType", SEQ_PAR_SET_EXT: "NALUnitType", AUX_SLICE: "NALUnitType", lut: "Array", _values: "Array"}, {});
(function() {
    NALUnitType._values = [NALUnitType.NON_IDR_SLICE, NALUnitType.SLICE_PART_A, NALUnitType.SLICE_PART_B, NALUnitType.SLICE_PART_C, NALUnitType.IDR_SLICE, NALUnitType.SEI, NALUnitType.SPS, NALUnitType.PPS, NALUnitType.ACC_UNIT_DELIM, NALUnitType.END_OF_SEQ, NALUnitType.END_OF_STREAM, NALUnitType.FILLER_DATA, NALUnitType.SEQ_PAR_SET_EXT, NALUnitType.AUX_SLICE];
    NALUnitType.lut = Array(256);
    for (var i = 0; i < NALUnitType._values.length; i++) {
        var nalUnitType = NALUnitType._values[i];
        NALUnitType.lut[nalUnitType.value] = nalUnitType;
    }
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ObjectType = stjs.enumeration("AOT_NULL", "AOT_AAC_MAIN", "AOT_AAC_LC", "AOT_AAC_SSR", "AOT_AAC_LTP", "AOT_SBR", "AOT_AAC_SCALABLE", "AOT_TWINVQ", "AOT_CELP", "AOT_HVXC", "CRAP1", "CRAP2", "AOT_TTSI", "AOT_MAINSYNTH", "AOT_WAVESYNTH", "AOT_MIDI", "AOT_SAFX", "AOT_ER_AAC_LC", "CRAP3", "AOT_ER_AAC_LTP", "AOT_ER_AAC_SCALABLE", "AOT_ER_TWINVQ", "AOT_ER_BSAC", "AOT_ER_AAC_LD", "AOT_ER_CELP", "AOT_ER_HVXC", "AOT_ER_HILN", "AOT_ER_PARAM", "AOT_SSC", "AOT_PS", "AOT_SURROUND", "AOT_ESCAPE", "AOT_L1", "AOT_L2", "AOT_L3", "AOT_DST", "AOT_ALS", "AOT_SLS", "AOT_SLS_NON_CORE", "AOT_ER_AAC_ELD", "AOT_SMR_SIMPLE", "AOT_SMR_MAIN", "AOT_USAC_NOSBR", "AOT_SAOC", "AOT_LD_SURROUND", "AOT_USAC");
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VPXConst = function() {};
VPXConst = stjs.extend(VPXConst, null, [], function(constructor, prototype) {
    constructor.vp8Norm = new Int32Array([0, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    constructor.tokenDefaultBinProbs = [[[new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128])], [new Int32Array([253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128]), new Int32Array([189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128]), new Int32Array([106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128])], [new Int32Array([1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128]), new Int32Array([181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128]), new Int32Array([78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128])], [new Int32Array([1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128]), new Int32Array([184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128]), new Int32Array([77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128])], [new Int32Array([1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128]), new Int32Array([170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128]), new Int32Array([37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128])], [new Int32Array([1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128]), new Int32Array([207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128]), new Int32Array([102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128])], [new Int32Array([1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128]), new Int32Array([177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128]), new Int32Array([80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128])], [new Int32Array([1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128])]], [[new Int32Array([198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62]), new Int32Array([131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1]), new Int32Array([68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128])], [new Int32Array([1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128]), new Int32Array([184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128]), new Int32Array([81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128])], [new Int32Array([1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128]), new Int32Array([99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128]), new Int32Array([23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128])], [new Int32Array([1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128]), new Int32Array([109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128]), new Int32Array([44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128])], [new Int32Array([1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128]), new Int32Array([94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128]), new Int32Array([22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128])], [new Int32Array([1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128]), new Int32Array([124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128]), new Int32Array([35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128])], [new Int32Array([1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128]), new Int32Array([121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128]), new Int32Array([45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128])], [new Int32Array([1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128]), new Int32Array([203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128])]], [[new Int32Array([253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128]), new Int32Array([175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128]), new Int32Array([73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128])], [new Int32Array([1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128]), new Int32Array([239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128]), new Int32Array([155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128])], [new Int32Array([1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128]), new Int32Array([201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128]), new Int32Array([69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128])], [new Int32Array([1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128]), new Int32Array([141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128])], [new Int32Array([1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128]), new Int32Array([149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128])], [new Int32Array([1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128])], [new Int32Array([1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128])], [new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128])]], [[new Int32Array([202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255]), new Int32Array([126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128]), new Int32Array([61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128])], [new Int32Array([1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128]), new Int32Array([166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128]), new Int32Array([39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128])], [new Int32Array([1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128]), new Int32Array([124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128]), new Int32Array([24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128])], [new Int32Array([1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128]), new Int32Array([149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128]), new Int32Array([28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128])], [new Int32Array([1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128]), new Int32Array([123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128]), new Int32Array([20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128])], [new Int32Array([1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128]), new Int32Array([168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128]), new Int32Array([47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128])], [new Int32Array([1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128]), new Int32Array([141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128]), new Int32Array([42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128])], [new Int32Array([1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128])]]];
    constructor.tokenProbUpdateFlagProbs = [[[new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255]), new Int32Array([250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])]], [[new Int32Array([217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255]), new Int32Array([234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255])], [new Int32Array([255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])]], [[new Int32Array([186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255])], [new Int32Array([255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])]], [[new Int32Array([248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])]]];
    constructor.probCoeffExtCat6 = new Int32Array([254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129]);
    constructor.probCoeffExtCat5 = new Int32Array([180, 157, 141, 134, 130]);
    constructor.dc_qlookup = new Int32Array([4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157]);
    constructor.ac_qlookup = new Int32Array([4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284]);
    constructor.zigzag = new Int32Array([0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15]);
}, {vp8Norm: "Int32Array", tokenDefaultBinProbs: "Array", tokenProbUpdateFlagProbs: "Array", probCoeffExtCat6: "Int32Array", probCoeffExtCat5: "Int32Array", dc_qlookup: "Int32Array", ac_qlookup: "Int32Array", zigzag: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @see http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/de//pubs/archive/37073.pdf
 *  @see http://jpegclub.org/jidctred/
 *  @see http://www3.matapp.unimib.it/corsi-2007-2008/matematica/istituzioni-di-analisi-numerica/jpeg/papers/11-multiplications.pdf
 *  @see http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/de//pubs/archive/37073.pdf
 *  <pre>
 *  </pre>
 *  
 *  @author The JCodec project
 */
var VP8DCT = function() {};
VP8DCT = stjs.extend(VP8DCT, null, [], function(constructor, prototype) {
    constructor.cospi8sqrt2minus1 = 20091;
    constructor.sinpi8sqrt2 = 35468;
    constructor.decodeDCT = function(input) {
        var i;
        var a1, b1, c1, d1;
        var offset = 0;
        var output = new Int32Array(16);
        var temp1, temp2;
        for (i = 0; i < 4; i++) {
            a1 = input[offset + 0] + input[offset + 8];
            b1 = input[offset + 0] - input[offset + 8];
            temp1 = (input[offset + 4] * VP8DCT.sinpi8sqrt2) >> 16;
            temp2 = input[offset + 12] + ((input[offset + 12] * VP8DCT.cospi8sqrt2minus1) >> 16);
            c1 = temp1 - temp2;
            temp1 = input[offset + 4] + ((input[offset + 4] * VP8DCT.cospi8sqrt2minus1) >> 16);
            temp2 = (input[offset + 12] * VP8DCT.sinpi8sqrt2) >> 16;
            d1 = temp1 + temp2;
            output[offset + (0 * 4)] = a1 + d1;
            output[offset + (3 * 4)] = a1 - d1;
            output[offset + (1 * 4)] = b1 + c1;
            output[offset + (2 * 4)] = b1 - c1;
            offset++;
        }
        offset = 0;
        for (i = 0; i < 4; i++) {
            a1 = output[(offset * 4) + 0] + output[(offset * 4) + 2];
            b1 = output[(offset * 4) + 0] - output[(offset * 4) + 2];
            temp1 = (output[(offset * 4) + 1] * VP8DCT.sinpi8sqrt2) >> 16;
            temp2 = output[(offset * 4) + 3] + ((output[(offset * 4) + 3] * VP8DCT.cospi8sqrt2minus1) >> 16);
            c1 = temp1 - temp2;
            temp1 = output[(offset * 4) + 1] + ((output[(offset * 4) + 1] * VP8DCT.cospi8sqrt2minus1) >> 16);
            temp2 = (output[(offset * 4) + 3] * VP8DCT.sinpi8sqrt2) >> 16;
            d1 = temp1 + temp2;
            output[(offset * 4) + 0] = (a1 + d1 + 4) >> 3;
            output[(offset * 4) + 3] = (a1 - d1 + 4) >> 3;
            output[(offset * 4) + 1] = (b1 + c1 + 4) >> 3;
            output[(offset * 4) + 2] = (b1 - c1 + 4) >> 3;
            offset++;
        }
        return output;
    };
    constructor.encodeDCT = function(input) {
        var i;
        var a1, b1, c1, d1;
        var ip = 0;
        var output = new Int32Array(input.length);
        var op = 0;
        for (i = 0; i < 4; i++) {
            a1 = ((input[ip + 0] + input[ip + 3]) << 3);
            b1 = ((input[ip + 1] + input[ip + 2]) << 3);
            c1 = ((input[ip + 1] - input[ip + 2]) << 3);
            d1 = ((input[ip + 0] - input[ip + 3]) << 3);
            output[op + 0] = a1 + b1;
            output[op + 2] = a1 - b1;
            output[op + 1] = (c1 * 2217 + d1 * 5352 + 14500) >> 12;
            output[op + 3] = (d1 * 2217 - c1 * 5352 + 7500) >> 12;
            ip += 4;
            op += 4;
        }
        ip = 0;
        op = 0;
        for (i = 0; i < 4; i++) {
            a1 = output[ip + 0] + output[ip + 12];
            b1 = output[ip + 4] + output[ip + 8];
            c1 = output[ip + 4] - output[ip + 8];
            d1 = output[ip + 0] - output[ip + 12];
            output[op + 0] = (a1 + b1 + 7) >> 4;
            output[op + 8] = (a1 - b1 + 7) >> 4;
            output[op + 4] = ((c1 * 2217 + d1 * 5352 + 12000) >> 16) + (d1 != 0 ? 1 : 0);
            output[op + 12] = (d1 * 2217 - c1 * 5352 + 51000) >> 16;
            ip++;
            op++;
        }
        return output;
    };
    constructor.decodeWHT = function(input) {
        var i;
        var a1, b1, c1, d1;
        var a2, b2, c2, d2;
        var output = new Int32Array(16);
        var diff = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(4);
        });
        var offset = 0;
        for (i = 0; i < 4; i++) {
            a1 = input[offset + 0] + input[offset + 12];
            b1 = input[offset + 4] + input[offset + 8];
            c1 = input[offset + 4] - input[offset + 8];
            d1 = input[offset + 0] - input[offset + 12];
            output[offset + 0] = a1 + b1;
            output[offset + 4] = c1 + d1;
            output[offset + 8] = a1 - b1;
            output[offset + 12] = d1 - c1;
            offset++;
        }
        offset = 0;
        for (i = 0; i < 4; i++) {
            a1 = output[offset + 0] + output[offset + 3];
            b1 = output[offset + 1] + output[offset + 2];
            c1 = output[offset + 1] - output[offset + 2];
            d1 = output[offset + 0] - output[offset + 3];
            a2 = a1 + b1;
            b2 = c1 + d1;
            c2 = a1 - b1;
            d2 = d1 - c1;
            output[offset + 0] = (a2 + 3) >> 3;
            output[offset + 1] = (b2 + 3) >> 3;
            output[offset + 2] = (c2 + 3) >> 3;
            output[offset + 3] = (d2 + 3) >> 3;
            diff[0][i] = (a2 + 3) >> 3;
            diff[1][i] = (b2 + 3) >> 3;
            diff[2][i] = (c2 + 3) >> 3;
            diff[3][i] = (d2 + 3) >> 3;
            offset += 4;
        }
        return output;
    };
    constructor.encodeWHT = function(input) {
        var i;
        var a1, b1, c1, d1;
        var a2, b2, c2, d2;
        var inputOffset = 0;
        var outputOffset = 0;
        var output = new Int32Array(input.length);
        for (i = 0; i < 4; i++) {
            a1 = ((input[inputOffset + 0] + input[inputOffset + 2])) << 2;
            d1 = ((input[inputOffset + 1] + input[inputOffset + 3])) << 2;
            c1 = ((input[inputOffset + 1] - input[inputOffset + 3])) << 2;
            b1 = ((input[inputOffset + 0] - input[inputOffset + 2])) << 2;
            output[outputOffset + 0] = a1 + d1 + (a1 != 0 ? 1 : 0);
            output[outputOffset + 1] = b1 + c1;
            output[outputOffset + 2] = b1 - c1;
            output[outputOffset + 3] = a1 - d1;
            inputOffset += 4;
            outputOffset += 4;
        }
        inputOffset = 0;
        outputOffset = 0;
        for (i = 0; i < 4; i++) {
            a1 = output[inputOffset + 0] + output[inputOffset + 8];
            d1 = output[inputOffset + 4] + output[inputOffset + 12];
            c1 = output[inputOffset + 4] - output[inputOffset + 12];
            b1 = output[inputOffset + 0] - output[inputOffset + 8];
            a2 = a1 + d1;
            b2 = b1 + c1;
            c2 = b1 - c1;
            d2 = a1 - d1;
            a2 += (a2 < 0 ? 1 : 0);
            b2 += (b2 < 0 ? 1 : 0);
            c2 += (c2 < 0 ? 1 : 0);
            d2 += (d2 < 0 ? 1 : 0);
            output[outputOffset + 0] = (a2 + 3) >> 3;
            output[outputOffset + 4] = (b2 + 3) >> 3;
            output[outputOffset + 8] = (c2 + 3) >> 3;
            output[outputOffset + 12] = (d2 + 3) >> 3;
            inputOffset++;
            outputOffset++;
        }
        return output;
    };
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  The MSMask indicates, if MS is applied to a specific ICStream.
 *  
 *  @author in-somnia
 */
var MSMask = stjs.enumeration("TYPE_ALL_0", "TYPE_USED", "TYPE_ALL_1", "TYPE_RESERVED");
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Profile = stjs.enumeration("MAIN", "LC", "OTHER");
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var RateControl = function() {};
RateControl = stjs.extend(RateControl, null, [], function(constructor, prototype) {
    prototype.getSegmentQps = function() {};
    prototype.getSegment = function() {};
    prototype.report = function(bits) {};
    prototype.reset = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Vector of 4 int8 elemente packed into a single int32 word
 *  
 *  @author The JCodec project
 *  
 */
var Vector4Int = function() {};
Vector4Int = stjs.extend(Vector4Int, null, [], function(constructor, prototype) {
    constructor.el8_0 = function(packed) {
        return (packed << 24) >> 24;
    };
    constructor.el8_1 = function(packed) {
        return ((packed << 16) >> 24);
    };
    constructor.el8_2 = function(packed) {
        return (packed << 8) >> 24;
    };
    constructor.el8_3 = function(packed) {
        return (packed >> 24);
    };
    constructor.el8 = function(packed, n) {
        switch (n) {
            case 0:
                return Vector4Int.el8_0(packed);
            case 1:
                return Vector4Int.el8_1(packed);
            case 2:
                return Vector4Int.el8_2(packed);
            default:
                return Vector4Int.el8_3(packed);
        }
    };
    constructor.set8_0 = function(packed, el) {
        return (packed & ~255) | (el & 255);
    };
    constructor.set8_1 = function(packed, el) {
        return (packed & ~65280) | ((el & 255) << 8);
    };
    constructor.set8_2 = function(packed, el) {
        return (packed & ~16711680) | ((el & 255) << 16);
    };
    constructor.set8_3 = function(packed, el) {
        return (packed & ~16711680) | ((el & 255) << 24);
    };
    constructor.set8 = function(packed, el, n) {
        switch (n) {
            case 0:
                return Vector4Int.set8_0(packed, el);
            case 1:
                return Vector4Int.set8_1(packed, el);
            case 2:
                return Vector4Int.set8_2(packed, el);
            default:
                return Vector4Int.set8_3(packed, el);
        }
    };
    constructor.pack8 = function(el0, el1, el2, el3) {
        return ((el3 & 255) << 24) | ((el2 & 255) << 16) | ((el1 & 255) << 8) | (el0 & 255);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Vector of 2 int16 elemente packed into a single int32 word
 *  
 *  @author The JCodec project
 *  
 */
var Vector2Int = function() {};
Vector2Int = stjs.extend(Vector2Int, null, [], function(constructor, prototype) {
    constructor.el16_0 = function(packed) {
        return (packed << 16) >> 16;
    };
    constructor.el16_1 = function(packed) {
        return (packed >> 16);
    };
    constructor.el16 = function(packed, n) {
        switch (n) {
            case 0:
                return Vector2Int.el16_0(packed);
            default:
                return Vector2Int.el16_1(packed);
        }
    };
    constructor.set16_0 = function(packed, el) {
        return (packed & ~65535) | (el & 65535);
    };
    constructor.set16_1 = function(packed, el) {
        return (packed & ~-65536) | ((el & 65535) << 16);
    };
    constructor.set16 = function(packed, el, n) {
        switch (n) {
            case 0:
                return Vector2Int.set16_0(packed, el);
            default:
                return Vector2Int.set16_1(packed, el);
        }
    };
    constructor.pack16 = function(el0, el1) {
        return ((el1 & 65535) << 16) | (el0 & 65535);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  FLV packet
 *  
 *  @author Stan Vitvitskyy
 *  
 */
var FLVTag = function(type, position, tagHeader, pts, data, keyFrame, frameNo, streamId, prevPacketSize) {
    this.type = type;
    this.position = position;
    this.tagHeader = tagHeader;
    this.pts = pts;
    this.data = data;
    this.keyFrame = keyFrame;
    this.frameNo = frameNo;
    this.streamId = streamId;
    this.prevPacketSize = prevPacketSize;
};
FLVTag = stjs.extend(FLVTag, null, [], function(constructor, prototype) {
    prototype.type = null;
    prototype.position = 0;
    prototype.tagHeader = null;
    prototype.pts = 0;
    prototype.data = null;
    prototype.keyFrame = false;
    prototype.frameNo = 0;
    prototype.streamId = 0;
    prototype.prevPacketSize = 0;
    constructor.Type = stjs.enumeration("VIDEO", "AUDIO", "SCRIPT");
    prototype.getType = function() {
        return this.type;
    };
    prototype.getPosition = function() {
        return this.position;
    };
    prototype.getTagHeader = function() {
        return this.tagHeader;
    };
    prototype.getPts = function() {
        return this.pts;
    };
    prototype.setPts = function(pts) {
        this.pts = pts;
    };
    prototype.getStreamId = function() {
        return this.streamId;
    };
    prototype.setStreamId = function(streamId) {
        this.streamId = streamId;
    };
    prototype.getPrevPacketSize = function() {
        return this.prevPacketSize;
    };
    prototype.setPrevPacketSize = function(prevPacketSize) {
        this.prevPacketSize = prevPacketSize;
    };
    prototype.getData = function() {
        return this.data;
    };
    prototype.getPtsD = function() {
        return (this.pts) / 1000;
    };
    prototype.isKeyFrame = function() {
        return this.keyFrame;
    };
    prototype.getFrameNo = function() {
        return this.frameNo;
    };
    constructor.TagHeader = function(codec) {
        this.codec = codec;
    };
    constructor.TagHeader = stjs.extend(constructor.TagHeader, null, [], function(constructor, prototype) {
        prototype.codec = null;
        prototype.getCodec = function() {
            return this.codec;
        };
    }, {codec: "Codec"}, {});
    constructor.VideoTagHeader = function(codec, frameType) {
        FLVTag.TagHeader.call(this, codec);
        this.frameType = frameType;
    };
    constructor.VideoTagHeader = stjs.extend(constructor.VideoTagHeader, FLVTag.TagHeader, [], function(constructor, prototype) {
        prototype.frameType = 0;
        prototype.getFrameType = function() {
            return this.frameType;
        };
    }, {codec: "Codec"}, {});
    constructor.AvcVideoTagHeader = function(codec, frameType, avcPacketType, compOffset) {
        FLVTag.VideoTagHeader.call(this, codec, frameType);
        this.avcPacketType = avcPacketType;
        this.compOffset = compOffset;
    };
    constructor.AvcVideoTagHeader = stjs.extend(constructor.AvcVideoTagHeader, FLVTag.VideoTagHeader, [], function(constructor, prototype) {
        prototype.compOffset = 0;
        prototype.avcPacketType = 0;
        prototype.getCompOffset = function() {
            return this.compOffset;
        };
        prototype.getAvcPacketType = function() {
            return this.avcPacketType;
        };
    }, {codec: "Codec"}, {});
    constructor.AudioTagHeader = function(codec, audioFormat) {
        FLVTag.TagHeader.call(this, codec);
        this.audioFormat = audioFormat;
    };
    constructor.AudioTagHeader = stjs.extend(constructor.AudioTagHeader, FLVTag.TagHeader, [], function(constructor, prototype) {
        prototype.audioFormat = null;
        prototype.getAudioFormat = function() {
            return this.audioFormat;
        };
    }, {audioFormat: "AudioFormat", codec: "Codec"}, {});
    constructor.AacAudioTagHeader = function(codec, audioFormat, packetType) {
        FLVTag.AudioTagHeader.call(this, codec, audioFormat);
        this.packetType = packetType;
    };
    constructor.AacAudioTagHeader = stjs.extend(constructor.AacAudioTagHeader, FLVTag.AudioTagHeader, [], function(constructor, prototype) {
        prototype.packetType = 0;
        prototype.getPacketType = function() {
            return this.packetType;
        };
    }, {audioFormat: "AudioFormat", codec: "Codec"}, {});
}, {type: {name: "Enum", arguments: ["FLVTag.Type"]}, tagHeader: "FLVTag.TagHeader", data: "ByteBuffer"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var MDCTTables = function() {};
MDCTTables = stjs.extend(MDCTTables, null, [], function(constructor, prototype) {
    constructor.MDCT_TABLE_2048 = [new Float32Array([0.031249998, 1.1984224E-5]), new Float32Array([0.031249814, 1.0785781E-4]), new Float32Array([0.031249335, 2.0373038E-4]), new Float32Array([0.031248564, 2.9960103E-4]), new Float32Array([0.031247498, 3.9546887E-4]), new Float32Array([0.031246137, 4.9133296E-4]), new Float32Array([0.031244483, 5.871925E-4]), new Float32Array([0.031242535, 6.830464E-4]), new Float32Array([0.031240292, 7.7889394E-4]), new Float32Array([0.031237755, 8.7473413E-4]), new Float32Array([0.031234924, 9.705661E-4]), new Float32Array([0.0312318, 0.0010663889]), new Float32Array([0.03122838, 0.0011622017]), new Float32Array([0.031224668, 0.0012580036]), new Float32Array([0.031220661, 0.0013537935]), new Float32Array([0.031216362, 0.0014495709]), new Float32Array([0.031211767, 0.0015453345]), new Float32Array([0.03120688, 0.0016410836]), new Float32Array([0.031201698, 0.0017368172]), new Float32Array([0.031196224, 0.0018325346]), new Float32Array([0.031190453, 0.0019282346]), new Float32Array([0.031184392, 0.0020239165]), new Float32Array([0.031178035, 0.0021195794]), new Float32Array([0.031171385, 0.0022152222]), new Float32Array([0.031164443, 0.0023108441]), new Float32Array([0.031157207, 0.0024064444]), new Float32Array([0.031149678, 0.002502022]), new Float32Array([0.031141855, 0.0025975762]), new Float32Array([0.03113374, 0.002693106]), new Float32Array([0.03112533, 0.00278861]), new Float32Array([0.031116627, 0.002884088]), new Float32Array([0.031107632, 0.002979539]), new Float32Array([0.031098345, 0.003074962]), new Float32Array([0.031088766, 0.003170356]), new Float32Array([0.031078892, 0.0032657199]), new Float32Array([0.031068727, 0.0033610533]), new Float32Array([0.03105827, 0.0034563548]), new Float32Array([0.03104752, 0.003551624]), new Float32Array([0.031036478, 0.00364686]), new Float32Array([0.031025143, 0.0037420613]), new Float32Array([0.031013517, 0.0038372274]), new Float32Array([0.031001598, 0.0039323573]), new Float32Array([0.030989388, 0.0040274505]), new Float32Array([0.030976886, 0.004122506]), new Float32Array([0.030964091, 0.004217522]), new Float32Array([0.030951008, 0.0043124985]), new Float32Array([0.03093763, 0.0044074347]), new Float32Array([0.030923964, 0.0045023295]), new Float32Array([0.030910006, 0.0045971815]), new Float32Array([0.030895757, 0.0046919906]), new Float32Array([0.030881215, 0.004786755]), new Float32Array([0.030866385, 0.004881475]), new Float32Array([0.030851264, 0.0049761487]), new Float32Array([0.030835852, 0.0050707757]), new Float32Array([0.03082015, 0.005165355]), new Float32Array([0.030804157, 0.0052598855]), new Float32Array([0.030787876, 0.0053543663]), new Float32Array([0.030771304, 0.0054487973]), new Float32Array([0.030754441, 0.0055431766]), new Float32Array([0.03073729, 0.0056375037]), new Float32Array([0.03071985, 0.0057317778]), new Float32Array([0.030702122, 0.0058259983]), new Float32Array([0.030684102, 0.0059201634]), new Float32Array([0.030665796, 0.006014273]), new Float32Array([0.0306472, 0.006108326]), new Float32Array([0.030628316, 0.0062023215]), new Float32Array([0.030609142, 0.006296259]), new Float32Array([0.030589683, 0.0063901367]), new Float32Array([0.030569933, 0.0064839544]), new Float32Array([0.030549897, 0.006577711]), new Float32Array([0.030529574, 0.006671406]), new Float32Array([0.030508962, 0.006765038]), new Float32Array([0.030488063, 0.0068586064]), new Float32Array([0.030466879, 0.00695211]), new Float32Array([0.030445406, 0.0070455484]), new Float32Array([0.030423647, 0.0071389205]), new Float32Array([0.030401602, 0.0072322255]), new Float32Array([0.030379271, 0.007325462]), new Float32Array([0.030356653, 0.0074186297]), new Float32Array([0.030333752, 0.007511728]), new Float32Array([0.030310562, 0.007604755]), new Float32Array([0.030287089, 0.007697711]), new Float32Array([0.03026333, 0.007790594]), new Float32Array([0.030239286, 0.007883404]), new Float32Array([0.030214958, 0.00797614]), new Float32Array([0.030190345, 0.0080688]), new Float32Array([0.030165449, 0.008161386]), new Float32Array([0.030140268, 0.008253893]), new Float32Array([0.030114803, 0.008346323]), new Float32Array([0.030089056, 0.008438675]), new Float32Array([0.030063024, 0.008530947]), new Float32Array([0.03003671, 0.008623139]), new Float32Array([0.030010113, 0.00871525]), new Float32Array([0.029983234, 0.008807278]), new Float32Array([0.029956073, 0.008899224]), new Float32Array([0.02992863, 0.008991086]), new Float32Array([0.029900905, 0.009082864]), new Float32Array([0.029872898, 0.009174556]), new Float32Array([0.02984461, 0.009266161]), new Float32Array([0.02981604, 0.00935768]), new Float32Array([0.029787192, 0.009449109]), new Float32Array([0.029758062, 0.009540451]), new Float32Array([0.029728653, 0.009631703]), new Float32Array([0.029698964, 0.009722863]), new Float32Array([0.029668994, 0.009813933]), new Float32Array([0.029638747, 0.00990491]), new Float32Array([0.029608218, 0.009995794]), new Float32Array([0.029577412, 0.010086584]), new Float32Array([0.029546328, 0.010177278]), new Float32Array([0.029514967, 0.010267877]), new Float32Array([0.029483326, 0.010358379]), new Float32Array([0.029451407, 0.010448785]), new Float32Array([0.029419212, 0.010539091]), new Float32Array([0.02938674, 0.010629298]), new Float32Array([0.029353991, 0.0107194055]), new Float32Array([0.029320966, 0.010809411]), new Float32Array([0.029287666, 0.0108993165]), new Float32Array([0.02925409, 0.010989118]), new Float32Array([0.029220238, 0.011078817]), new Float32Array([0.029186111, 0.011168411]), new Float32Array([0.02915171, 0.0112579]), new Float32Array([0.029117033, 0.011347284]), new Float32Array([0.029082084, 0.01143656]), new Float32Array([0.02904686, 0.011525729]), new Float32Array([0.029011363, 0.011614789]), new Float32Array([0.028975593, 0.01170374]), new Float32Array([0.028939549, 0.011792581]), new Float32Array([0.028903235, 0.0118813105]), new Float32Array([0.028866647, 0.011969929]), new Float32Array([0.028829789, 0.012058434]), new Float32Array([0.028792657, 0.012146826]), new Float32Array([0.028755257, 0.012235103]), new Float32Array([0.028717585, 0.012323265]), new Float32Array([0.028679641, 0.012411311]), new Float32Array([0.028641429, 0.012499241]), new Float32Array([0.028602947, 0.012587053]), new Float32Array([0.028564196, 0.012674746]), new Float32Array([0.028525176, 0.01276232]), new Float32Array([0.028485889, 0.012849774]), new Float32Array([0.028446332, 0.012937107]), new Float32Array([0.028406506, 0.013024318]), new Float32Array([0.028366415, 0.013111407]), new Float32Array([0.028326057, 0.013198372]), new Float32Array([0.02828543, 0.013285213]), new Float32Array([0.02824454, 0.0133719295]), new Float32Array([0.028203381, 0.013458519]), new Float32Array([0.02816196, 0.013544983]), new Float32Array([0.028120272, 0.013631319]), new Float32Array([0.028078318, 0.013717527]), new Float32Array([0.0280361, 0.013803605]), new Float32Array([0.027993621, 0.013889553]), new Float32Array([0.027950877, 0.013975372]), new Float32Array([0.027907869, 0.014061058]), new Float32Array([0.0278646, 0.014146612]), new Float32Array([0.027821066, 0.014232032]), new Float32Array([0.027777273, 0.014317319]), new Float32Array([0.027733216, 0.0144024715]), new Float32Array([0.0276889, 0.014487488]), new Float32Array([0.027644323, 0.014572368]), new Float32Array([0.027599486, 0.014657111]), new Float32Array([0.02755439, 0.014741716]), new Float32Array([0.027509032, 0.014826182]), new Float32Array([0.027463416, 0.014910509]), new Float32Array([0.027417542, 0.014994696]), new Float32Array([0.02737141, 0.015078741]), new Float32Array([0.02732502, 0.015162644]), new Float32Array([0.027278373, 0.015246404]), new Float32Array([0.02723147, 0.015330022]), new Float32Array([0.02718431, 0.015413495]), new Float32Array([0.027136894, 0.015496822]), new Float32Array([0.027089221, 0.015580004]), new Float32Array([0.027041296, 0.015663039]), new Float32Array([0.026993115, 0.015745927]), new Float32Array([0.02694468, 0.015828667]), new Float32Array([0.026895992, 0.015911257]), new Float32Array([0.02684705, 0.015993698]), new Float32Array([0.026797855, 0.01607599]), new Float32Array([0.02674841, 0.016158128]), new Float32Array([0.02669871, 0.016240114]), new Float32Array([0.026648762, 0.01632195]), new Float32Array([0.026598562, 0.016403629]), new Float32Array([0.02654811, 0.016485155]), new Float32Array([0.026497409, 0.016566526]), new Float32Array([0.02644646, 0.016647741]), new Float32Array([0.026395261, 0.0167288]), new Float32Array([0.026343813, 0.0168097]), new Float32Array([0.026292117, 0.016890442]), new Float32Array([0.026240176, 0.016971026]), new Float32Array([0.026187984, 0.01705145]), new Float32Array([0.026135549, 0.017131714]), new Float32Array([0.026082866, 0.017211815]), new Float32Array([0.026029939, 0.017291756]), new Float32Array([0.025976766, 0.017371533]), new Float32Array([0.025923347, 0.017451147]), new Float32Array([0.025869686, 0.017530596]), new Float32Array([0.025815781, 0.017609881]), new Float32Array([0.025761634, 0.017688999]), new Float32Array([0.025707243, 0.017767953]), new Float32Array([0.025652612, 0.017846737]), new Float32Array([0.025597738, 0.017925354]), new Float32Array([0.025542622, 0.018003803]), new Float32Array([0.025487268, 0.018082082]), new Float32Array([0.025431672, 0.01816019]), new Float32Array([0.02537584, 0.01823813]), new Float32Array([0.025319764, 0.018315895]), new Float32Array([0.025263453, 0.018393489]), new Float32Array([0.025206905, 0.01847091]), new Float32Array([0.025150118, 0.018548155]), new Float32Array([0.025093095, 0.018625228]), new Float32Array([0.025035836, 0.018702125]), new Float32Array([0.02497834, 0.018778846]), new Float32Array([0.024920609, 0.01885539]), new Float32Array([0.024862645, 0.018931756]), new Float32Array([0.024804447, 0.019007945]), new Float32Array([0.024746014, 0.019083954]), new Float32Array([0.024687348, 0.019159785]), new Float32Array([0.024628451, 0.019235434]), new Float32Array([0.024569321, 0.019310903]), new Float32Array([0.02450996, 0.019386189]), new Float32Array([0.02445037, 0.019461293]), new Float32Array([0.024390548, 0.019536214]), new Float32Array([0.024330497, 0.01961095]), new Float32Array([0.024270218, 0.019685503]), new Float32Array([0.024209708, 0.019759871]), new Float32Array([0.024148973, 0.019834053]), new Float32Array([0.024088008, 0.019908046]), new Float32Array([0.024026819, 0.019981854]), new Float32Array([0.023965402, 0.020055473]), new Float32Array([0.02390376, 0.020128904]), new Float32Array([0.023841891, 0.020202145]), new Float32Array([0.0237798, 0.020275196]), new Float32Array([0.023717485, 0.020348055]), new Float32Array([0.023654947, 0.020420725]), new Float32Array([0.023592185, 0.0204932]), new Float32Array([0.023529202, 0.020565484]), new Float32Array([0.023465998, 0.020637574]), new Float32Array([0.023402572, 0.02070947]), new Float32Array([0.023338927, 0.02078117]), new Float32Array([0.02327506, 0.020852676]), new Float32Array([0.023210976, 0.020923983]), new Float32Array([0.023146672, 0.020995095]), new Float32Array([0.023082152, 0.02106601]), new Float32Array([0.023017414, 0.021136725]), new Float32Array([0.022952458, 0.021207243]), new Float32Array([0.022887288, 0.02127756]), new Float32Array([0.022821901, 0.021347677]), new Float32Array([0.0227563, 0.021417594]), new Float32Array([0.022690484, 0.021487307]), new Float32Array([0.022624455, 0.02155682]), new Float32Array([0.022558214, 0.02162613]), new Float32Array([0.02249176, 0.021695236]), new Float32Array([0.022425095, 0.021764137]), new Float32Array([0.022358216, 0.021832833]), new Float32Array([0.02229113, 0.021901324]), new Float32Array([0.022223832, 0.02196961]), new Float32Array([0.022156326, 0.022037689]), new Float32Array([0.022088611, 0.02210556]), new Float32Array([0.022020688, 0.022173222]), new Float32Array([0.021952558, 0.022240676]), new Float32Array([0.021884222, 0.022307921]), new Float32Array([0.021815678, 0.022374956]), new Float32Array([0.02174693, 0.02244178]), new Float32Array([0.021677978, 0.022508394]), new Float32Array([0.02160882, 0.022574795]), new Float32Array([0.02153946, 0.022640983]), new Float32Array([0.021469899, 0.02270696]), new Float32Array([0.021400133, 0.02277272]), new Float32Array([0.021330167, 0.022838268]), new Float32Array([0.021259999, 0.0229036]), new Float32Array([0.021189632, 0.022968717]), new Float32Array([0.021119066, 0.023033619]), new Float32Array([0.0210483, 0.023098303]), new Float32Array([0.020977337, 0.02316277]), new Float32Array([0.020906175, 0.023227017]), new Float32Array([0.020834817, 0.023291048]), new Float32Array([0.020763263, 0.023354858]), new Float32Array([0.020691514, 0.023418449]), new Float32Array([0.02061957, 0.02348182]), new Float32Array([0.020547431, 0.023544969]), new Float32Array([0.020475099, 0.023607897]), new Float32Array([0.020402575, 0.023670603]), new Float32Array([0.02032986, 0.023733085]), new Float32Array([0.020256951, 0.023795344]), new Float32Array([0.020183852, 0.02385738]), new Float32Array([0.020110564, 0.023919191]), new Float32Array([0.020037087, 0.023980778]), new Float32Array([0.01996342, 0.024042137]), new Float32Array([0.019889567, 0.02410327]), new Float32Array([0.019815525, 0.024164177]), new Float32Array([0.019741297, 0.024224857]), new Float32Array([0.019666882, 0.024285309]), new Float32Array([0.019592285, 0.024345532]), new Float32Array([0.019517502, 0.024405524]), new Float32Array([0.019442534, 0.024465289]), new Float32Array([0.019367384, 0.024524823]), new Float32Array([0.019292051, 0.024584126]), new Float32Array([0.019216537, 0.024643198]), new Float32Array([0.019140843, 0.024702037]), new Float32Array([0.019064968, 0.024760643]), new Float32Array([0.018988915, 0.024819018]), new Float32Array([0.01891268, 0.024877159]), new Float32Array([0.018836271, 0.024935065]), new Float32Array([0.01875968, 0.024992736]), new Float32Array([0.018682918, 0.025050173]), new Float32Array([0.018605975, 0.025107373]), new Float32Array([0.01852886, 0.025164336]), new Float32Array([0.01845157, 0.025221065]), new Float32Array([0.018374106, 0.025277553]), new Float32Array([0.018296469, 0.025333805]), new Float32Array([0.01821866, 0.02538982]), new Float32Array([0.01814068, 0.025445594]), new Float32Array([0.018062528, 0.025501128]), new Float32Array([0.017984206, 0.025556425]), new Float32Array([0.017905716, 0.025611479]), new Float32Array([0.017827056, 0.025666293]), new Float32Array([0.01774823, 0.025720865]), new Float32Array([0.017669236, 0.025775194]), new Float32Array([0.017590076, 0.025829282]), new Float32Array([0.01751075, 0.025883125]), new Float32Array([0.01743126, 0.025936725]), new Float32Array([0.017351603, 0.025990082]), new Float32Array([0.017271785, 0.026043193]), new Float32Array([0.017191805, 0.026096059]), new Float32Array([0.017111663, 0.02614868]), new Float32Array([0.017031359, 0.026201056]), new Float32Array([0.016950896, 0.026253184]), new Float32Array([0.016870271, 0.026305065]), new Float32Array([0.01678949, 0.026356699]), new Float32Array([0.01670855, 0.026408084]), new Float32Array([0.016627451, 0.02645922]), new Float32Array([0.016546197, 0.026510108]), new Float32Array([0.016464788, 0.026560746]), new Float32Array([0.016383223, 0.026611134]), new Float32Array([0.016301505, 0.026661273]), new Float32Array([0.016219633, 0.026711158]), new Float32Array([0.016137607, 0.026760794]), new Float32Array([0.016055431, 0.026810179]), new Float32Array([0.015973102, 0.02685931]), new Float32Array([0.015890624, 0.026908187]), new Float32Array([0.015807996, 0.026956813]), new Float32Array([0.01572522, 0.027005184]), new Float32Array([0.015642295, 0.027053302]), new Float32Array([0.015559223, 0.027101165]), new Float32Array([0.015476004, 0.027148772]), new Float32Array([0.01539264, 0.027196124]), new Float32Array([0.015309131, 0.02724322]), new Float32Array([0.015225478, 0.02729006]), new Float32Array([0.015141682, 0.027336642]), new Float32Array([0.015057743, 0.027382966]), new Float32Array([0.014973662, 0.027429035]), new Float32Array([0.0148894405, 0.027474845]), new Float32Array([0.0148050785, 0.027520396]), new Float32Array([0.014720578, 0.027565686]), new Float32Array([0.014635938, 0.02761072]), new Float32Array([0.014551161, 0.027655492]), new Float32Array([0.014466247, 0.027700003]), new Float32Array([0.014381196, 0.027744256]), new Float32Array([0.01429601, 0.027788246]), new Float32Array([0.01421069, 0.027831974]), new Float32Array([0.014125235, 0.027875442]), new Float32Array([0.014039649, 0.027918646]), new Float32Array([0.013953929, 0.027961588]), new Float32Array([0.013868079, 0.028004266]), new Float32Array([0.013782097, 0.02804668]), new Float32Array([0.013695987, 0.028088832]), new Float32Array([0.0136097465, 0.028130718]), new Float32Array([0.013523379, 0.02817234]), new Float32Array([0.013436884, 0.028213697]), new Float32Array([0.013350262, 0.028254787]), new Float32Array([0.013263515, 0.028295612]), new Float32Array([0.013176642, 0.028336171]), new Float32Array([0.013089647, 0.028376464]), new Float32Array([0.013002527, 0.028416488]), new Float32Array([0.012915285, 0.028456245]), new Float32Array([0.012827922, 0.028495735]), new Float32Array([0.012740438, 0.028534956]), new Float32Array([0.012652834, 0.02857391]), new Float32Array([0.012565111, 0.028612593]), new Float32Array([0.012477269, 0.028651008]), new Float32Array([0.012389311, 0.028689153]), new Float32Array([0.012301235, 0.028727027]), new Float32Array([0.012213044, 0.028764632]), new Float32Array([0.012124738, 0.028801966]), new Float32Array([0.012036318, 0.028839028]), new Float32Array([0.011947785, 0.02887582]), new Float32Array([0.0118591385, 0.02891234]), new Float32Array([0.011770381, 0.028948586]), new Float32Array([0.011681512, 0.028984562]), new Float32Array([0.011592534, 0.029020263]), new Float32Array([0.011503447, 0.029055692]), new Float32Array([0.01141425, 0.029090848]), new Float32Array([0.011324948, 0.029125728]), new Float32Array([0.011235538, 0.029160336]), new Float32Array([0.011146022, 0.029194668]), new Float32Array([0.011056402, 0.029228726]), new Float32Array([0.010966677, 0.02926251]), new Float32Array([0.010876849, 0.029296018]), new Float32Array([0.01078692, 0.02932925]), new Float32Array([0.010696888, 0.029362205]), new Float32Array([0.0106067555, 0.029394884]), new Float32Array([0.010516523, 0.029427288]), new Float32Array([0.010426193, 0.029459413]), new Float32Array([0.010335763, 0.02949126]), new Float32Array([0.010245237, 0.029522832]), new Float32Array([0.010154613, 0.029554125]), new Float32Array([0.010063895, 0.02958514]), new Float32Array([0.009973082, 0.029615877]), new Float32Array([0.009882174, 0.029646333]), new Float32Array([0.009791174, 0.029676512]), new Float32Array([0.009700082, 0.029706411]), new Float32Array([0.009608898, 0.02973603]), new Float32Array([0.009517624, 0.029765371]), new Float32Array([0.00942626, 0.02979443]), new Float32Array([0.009334808, 0.02982321]), new Float32Array([0.009243268, 0.029851709]), new Float32Array([0.00915164, 0.029879926]), new Float32Array([0.009059927, 0.029907862]), new Float32Array([0.008968129, 0.029935516]), new Float32Array([0.0088762455, 0.02996289]), new Float32Array([0.008784279, 0.02998998]), new Float32Array([0.00869223, 0.03001679]), new Float32Array([0.008600098, 0.030043315]), new Float32Array([0.008507887, 0.030069558]), new Float32Array([0.008415595, 0.03009552]), new Float32Array([0.008323223, 0.030121196]), new Float32Array([0.008230773, 0.03014659]), new Float32Array([0.008138246, 0.0301717]), new Float32Array([0.008045643, 0.030196525]), new Float32Array([0.007952963, 0.030221067]), new Float32Array([0.007860209, 0.030245325]), new Float32Array([0.00776738, 0.030269297]), new Float32Array([0.0076744785, 0.030292984]), new Float32Array([0.007581505, 0.030316386]), new Float32Array([0.00748846, 0.030339504]), new Float32Array([0.0073953443, 0.030362334]), new Float32Array([0.0073021594, 0.030384881]), new Float32Array([0.0072089056, 0.03040714]), new Float32Array([0.007115584, 0.030429114]), new Float32Array([0.007022195, 0.0304508]), new Float32Array([0.00692874, 0.030472202]), new Float32Array([0.0068352204, 0.030493315]), new Float32Array([0.006741636, 0.030514142]), new Float32Array([0.006647988, 0.030534681]), new Float32Array([0.0065542776, 0.030554933]), new Float32Array([0.0064605055, 0.030574897]), new Float32Array([0.006366673, 0.030594574]), new Float32Array([0.00627278, 0.030613963]), new Float32Array([0.006178828, 0.030633064]), new Float32Array([0.0060848184, 0.030651875]), new Float32Array([0.005990751, 0.030670399]), new Float32Array([0.0058966274, 0.030688634]), new Float32Array([0.005802448, 0.03070658]), new Float32Array([0.0057082144, 0.030724239]), new Float32Array([0.005613927, 0.030741606]), new Float32Array([0.0055195866, 0.030758685]), new Float32Array([0.0054251943, 0.030775474]), new Float32Array([0.0053307507, 0.030791974]), new Float32Array([0.0052362573, 0.030808182]), new Float32Array([0.0051417146, 0.030824102]), new Float32Array([0.0050471234, 0.030839732]), new Float32Array([0.0049524847, 0.03085507]), new Float32Array([0.004857799, 0.03087012]), new Float32Array([0.004763068, 0.030884879]), new Float32Array([0.004668292, 0.030899346]), new Float32Array([0.0045734723, 0.030913522]), new Float32Array([0.0044786097, 0.030927408]), new Float32Array([0.0043837046, 0.030941002]), new Float32Array([0.004288758, 0.030954305]), new Float32Array([0.0041937716, 0.030967318]), new Float32Array([0.0040987455, 0.03098004]), new Float32Array([0.004003681, 0.030992467]), new Float32Array([0.0039085783, 0.031004604]), new Float32Array([0.0038134393, 0.03101645]), new Float32Array([0.0037182642, 0.031028004]), new Float32Array([0.0036230541, 0.031039266]), new Float32Array([0.0035278099, 0.031050235]), new Float32Array([0.0034325325, 0.031060912]), new Float32Array([0.0033372228, 0.031071296]), new Float32Array([0.0032418817, 0.031081388]), new Float32Array([0.00314651, 0.031091187]), new Float32Array([0.003051109, 0.031100696]), new Float32Array([0.0029556789, 0.031109909]), new Float32Array([0.002860221, 0.03111883]), new Float32Array([0.0027647365, 0.03112746]), new Float32Array([0.0026692257, 0.031135796]), new Float32Array([0.00257369, 0.031143837]), new Float32Array([0.00247813, 0.031151587]), new Float32Array([0.0023825464, 0.031159043]), new Float32Array([0.0022869406, 0.031166205]), new Float32Array([0.0021913133, 0.031173076]), new Float32Array([0.0020956653, 0.031179652]), new Float32Array([0.0019999978, 0.031185934]), new Float32Array([0.0019043112, 0.031191923]), new Float32Array([0.0018086068, 0.031197619]), new Float32Array([0.0017128853, 0.03120302]), new Float32Array([0.0016171477, 0.03120813]), new Float32Array([0.0015213949, 0.031212945]), new Float32Array([0.0014256279, 0.031217465]), new Float32Array([0.0013298473, 0.031221692]), new Float32Array([0.0012340542, 0.031225624]), new Float32Array([0.0011382495, 0.031229263]), new Float32Array([0.0010424341, 0.031232608]), new Float32Array([9.4660895E-4, 0.03123566]), new Float32Array([8.507748E-4, 0.031238416]), new Float32Array([7.549327E-4, 0.03124088]), new Float32Array([6.590835E-4, 0.031243049]), new Float32Array([5.632281E-4, 0.031244924]), new Float32Array([4.6736735E-4, 0.031246506]), new Float32Array([3.7150222E-4, 0.03124779]), new Float32Array([2.756336E-4, 0.031248784]), new Float32Array([1.7976238E-4, 0.031249482]), new Float32Array([8.388947E-5, 0.031249888])];
    constructor.MDCT_TABLE_128 = [new Float32Array([0.08838793, 2.7117162E-4]), new Float32Array([0.088354655, 0.0024402384]), new Float32Array([0.08826816, 0.0046078353]), new Float32Array([0.08812849, 0.0067726565]), new Float32Array([0.08793574, 0.008933398]), new Float32Array([0.08769002, 0.011088759]), new Float32Array([0.08739147, 0.01323744]), new Float32Array([0.08704029, 0.015378147]), new Float32Array([0.08663668, 0.01750959]), new Float32Array([0.08618088, 0.019630488]), new Float32Array([0.08567317, 0.021739561]), new Float32Array([0.085113846, 0.023835538]), new Float32Array([0.08450326, 0.025917158]), new Float32Array([0.08384177, 0.027983164]), new Float32Array([0.08312978, 0.030032318]), new Float32Array([0.08236771, 0.03206338]), new Float32Array([0.08155603, 0.034075126]), new Float32Array([0.08069522, 0.03606635]), new Float32Array([0.0797858, 0.038035847]), new Float32Array([0.07882833, 0.039982434]), new Float32Array([0.07782337, 0.041904934]), new Float32Array([0.07677153, 0.043802194]), new Float32Array([0.075673446, 0.04567307]), new Float32Array([0.07452978, 0.04751643]), new Float32Array([0.07334123, 0.049331173]), new Float32Array([0.072108485, 0.051116202]), new Float32Array([0.07083231, 0.052870438]), new Float32Array([0.06951348, 0.054592825]), new Float32Array([0.06815276, 0.05628233]), new Float32Array([0.066751, 0.05793793]), new Float32Array([0.06530903, 0.059558634]), new Float32Array([0.063827716, 0.061143458]), new Float32Array([0.062307958, 0.06269145]), new Float32Array([0.060750667, 0.06420168]), new Float32Array([0.059156783, 0.06567325]), new Float32Array([0.057527263, 0.06710525]), new Float32Array([0.055863094, 0.06849682]), new Float32Array([0.05416527, 0.069847144]), new Float32Array([0.05243482, 0.07115539]), new Float32Array([0.05067279, 0.072420776]), new Float32Array([0.048880234, 0.07364254]), new Float32Array([0.047058232, 0.07481994]), new Float32Array([0.045207888, 0.07595227]), new Float32Array([0.043330308, 0.07703885]), new Float32Array([0.04142663, 0.07807902]), new Float32Array([0.039497998, 0.07907217]), new Float32Array([0.037545573, 0.080017686]), new Float32Array([0.035570532, 0.080915]), new Float32Array([0.033574067, 0.08176357]), new Float32Array([0.031557377, 0.08256289]), new Float32Array([0.029521678, 0.08331249]), new Float32Array([0.027468195, 0.08401189]), new Float32Array([0.025398167, 0.084660694]), new Float32Array([0.02331284, 0.0852585]), new Float32Array([0.02121347, 0.08580495]), new Float32Array([0.019101324, 0.08629971]), new Float32Array([0.01697767, 0.08674248]), new Float32Array([0.014843788, 0.08713301]), new Float32Array([0.012700967, 0.08747105]), new Float32Array([0.010550494, 0.08775641]), new Float32Array([0.008393667, 0.0879889]), new Float32Array([0.006231783, 0.08816839]), new Float32Array([0.004066145, 0.08829477]), new Float32Array([0.0018980585, 0.08836797])];
    constructor.MDCT_TABLE_1920 = [new Float32Array([0.032274857, 1.3202404E-5]), new Float32Array([0.03227464, 1.1882137E-4]), new Float32Array([0.032274082, 2.2443906E-4]), new Float32Array([0.032273173, 3.3005435E-4]), new Float32Array([0.03227192, 4.3566612E-4]), new Float32Array([0.032270323, 5.412732E-4]), new Float32Array([0.03226838, 6.468745E-4]), new Float32Array([0.032266088, 7.524689E-4]), new Float32Array([0.032263454, 8.580552E-4]), new Float32Array([0.032260474, 9.636323E-4]), new Float32Array([0.032257147, 0.0010691991]), new Float32Array([0.032253474, 0.0011747545]), new Float32Array([0.032249458, 0.0012802972]), new Float32Array([0.032245096, 0.0013858263]), new Float32Array([0.032240387, 0.0014913405]), new Float32Array([0.032235336, 0.0015968387]), new Float32Array([0.032229938, 0.00170232]), new Float32Array([0.032224193, 0.0018077828]), new Float32Array([0.032218102, 0.0019132263]), new Float32Array([0.03221167, 0.0020186494]), new Float32Array([0.032204892, 0.0021240509]), new Float32Array([0.03219777, 0.0022294295]), new Float32Array([0.0321903, 0.0023347845]), new Float32Array([0.03218249, 0.0024401143]), new Float32Array([0.03217433, 0.002545418]), new Float32Array([0.03216583, 0.0026506945]), new Float32Array([0.03215698, 0.0027559423]), new Float32Array([0.03214779, 0.002861161]), new Float32Array([0.032138254, 0.0029663488]), new Float32Array([0.032128375, 0.0030715049]), new Float32Array([0.032118153, 0.0031766281]), new Float32Array([0.032107584, 0.0032817174]), new Float32Array([0.032096673, 0.0033867715]), new Float32Array([0.03208542, 0.0034917893]), new Float32Array([0.03207382, 0.0035967696]), new Float32Array([0.03206188, 0.0037017115]), new Float32Array([0.032049593, 0.0038066139]), new Float32Array([0.032036964, 0.003911475]), new Float32Array([0.032023992, 0.0040162946]), new Float32Array([0.03201068, 0.004121071]), new Float32Array([0.031997018, 0.004225804]), new Float32Array([0.031983018, 0.004330491]), new Float32Array([0.031968676, 0.004435132]), new Float32Array([0.03195399, 0.0045397254]), new Float32Array([0.031938963, 0.00464427]), new Float32Array([0.031923596, 0.004748765]), new Float32Array([0.031907883, 0.004853209]), new Float32Array([0.03189183, 0.004957601]), new Float32Array([0.031875435, 0.0050619403]), new Float32Array([0.0318587, 0.005166225]), new Float32Array([0.031841625, 0.0052704546]), new Float32Array([0.031824205, 0.0053746277]), new Float32Array([0.031806447, 0.005478743]), new Float32Array([0.031788345, 0.0055827997]), new Float32Array([0.03176991, 0.0056867967]), new Float32Array([0.031751126, 0.005790733]), new Float32Array([0.031732008, 0.005894607]), new Float32Array([0.031712547, 0.005998418]), new Float32Array([0.031692747, 0.0061021647]), new Float32Array([0.031672608, 0.006205846]), new Float32Array([0.03165213, 0.0063094613]), new Float32Array([0.031631313, 0.0064130086]), new Float32Array([0.031610157, 0.0065164873]), new Float32Array([0.031588662, 0.0066198963]), new Float32Array([0.031566832, 0.0067232344]), new Float32Array([0.03154466, 0.0068265004]), new Float32Array([0.03152215, 0.0069296933]), new Float32Array([0.031499304, 0.007032812]), new Float32Array([0.03147612, 0.0071358555]), new Float32Array([0.0314526, 0.0072388225]), new Float32Array([0.031428743, 0.007341712]), new Float32Array([0.03140455, 0.007444523]), new Float32Array([0.03138002, 0.0075472537]), new Float32Array([0.031355154, 0.007649904]), new Float32Array([0.031329952, 0.0077524725]), new Float32Array([0.031304415, 0.007854958]), new Float32Array([0.03127854, 0.007957359]), new Float32Array([0.031252332, 0.008059675]), new Float32Array([0.031225791, 0.008161904]), new Float32Array([0.031198913, 0.008264047]), new Float32Array([0.031171702, 0.0083661005]), new Float32Array([0.031144157, 0.0084680645]), new Float32Array([0.031116279, 0.008569938]), new Float32Array([0.031088067, 0.00867172]), new Float32Array([0.031059522, 0.008773409]), new Float32Array([0.031030646, 0.008875004]), new Float32Array([0.031001436, 0.008976503]), new Float32Array([0.030971894, 0.009077908]), new Float32Array([0.030942021, 0.009179214]), new Float32Array([0.030911816, 0.009280422]), new Float32Array([0.030881282, 0.009381531]), new Float32Array([0.030850416, 0.009482539]), new Float32Array([0.030819219, 0.009583446]), new Float32Array([0.030787691, 0.00968425]), new Float32Array([0.030755835, 0.009784951]), new Float32Array([0.03072365, 0.009885546]), new Float32Array([0.030691134, 0.009986036]), new Float32Array([0.030658292, 0.010086419]), new Float32Array([0.03062512, 0.010186694]), new Float32Array([0.03059162, 0.010286859]), new Float32Array([0.030557793, 0.010386915]), new Float32Array([0.030523637, 0.01048686]), new Float32Array([0.030489156, 0.010586691]), new Float32Array([0.030454349, 0.01068641]), new Float32Array([0.030419214, 0.010786015]), new Float32Array([0.030383755, 0.010885503]), new Float32Array([0.030347968, 0.010984875]), new Float32Array([0.030311858, 0.01108413]), new Float32Array([0.030275423, 0.011183266]), new Float32Array([0.030238664, 0.011282281]), new Float32Array([0.03020158, 0.011381176]), new Float32Array([0.030164175, 0.01147995]), new Float32Array([0.030126445, 0.0115786]), new Float32Array([0.030088393, 0.011677126]), new Float32Array([0.030050019, 0.011775528]), new Float32Array([0.030011322, 0.011873803]), new Float32Array([0.029972306, 0.011971951]), new Float32Array([0.029932966, 0.012069971]), new Float32Array([0.029893307, 0.012167862]), new Float32Array([0.029853327, 0.012265622]), new Float32Array([0.029813029, 0.012363251]), new Float32Array([0.02977241, 0.012460748]), new Float32Array([0.029731473, 0.012558111]), new Float32Array([0.029690217, 0.012655339]), new Float32Array([0.029648645, 0.012752432]), new Float32Array([0.029606754, 0.012849389]), new Float32Array([0.029564546, 0.012946208]), new Float32Array([0.02952202, 0.013042888]), new Float32Array([0.029479181, 0.013139429]), new Float32Array([0.029436024, 0.013235829]), new Float32Array([0.029392552, 0.013332087]), new Float32Array([0.029348766, 0.013428202]), new Float32Array([0.029304665, 0.013524174]), new Float32Array([0.02926025, 0.01362]), new Float32Array([0.029215522, 0.013715681]), new Float32Array([0.029170481, 0.013811215]), new Float32Array([0.029125128, 0.013906601]), new Float32Array([0.029079463, 0.014001838]), new Float32Array([0.029033488, 0.014096925]), new Float32Array([0.028987199, 0.014191861]), new Float32Array([0.028940601, 0.014286646]), new Float32Array([0.028893694, 0.014381277]), new Float32Array([0.028846476, 0.014475754]), new Float32Array([0.02879895, 0.014570076]), new Float32Array([0.028751116, 0.014664243]), new Float32Array([0.028702972, 0.014758252]), new Float32Array([0.028654523, 0.014852103]), new Float32Array([0.028605767, 0.014945795]), new Float32Array([0.028556703, 0.015039327]), new Float32Array([0.028507335, 0.015132697]), new Float32Array([0.02845766, 0.015225907]), new Float32Array([0.028407682, 0.0153189525]), new Float32Array([0.028357398, 0.015411834]), new Float32Array([0.028306812, 0.015504551]), new Float32Array([0.02825592, 0.015597101]), new Float32Array([0.02820473, 0.015689485]), new Float32Array([0.028153235, 0.0157817]), new Float32Array([0.028101439, 0.015873747]), new Float32Array([0.02804934, 0.015965624]), new Float32Array([0.027996944, 0.01605733]), new Float32Array([0.027944246, 0.016148863]), new Float32Array([0.02789125, 0.016240224]), new Float32Array([0.027837954, 0.01633141]), new Float32Array([0.02778436, 0.016422423]), new Float32Array([0.02773047, 0.016513258]), new Float32Array([0.027676282, 0.016603917]), new Float32Array([0.027621798, 0.016694399]), new Float32Array([0.027567018, 0.016784701]), new Float32Array([0.027511943, 0.016874824]), new Float32Array([0.027456572, 0.016964767]), new Float32Array([0.027400909, 0.017054526]), new Float32Array([0.027344951, 0.017144104]), new Float32Array([0.027288701, 0.017233498]), new Float32Array([0.027232159, 0.017322708]), new Float32Array([0.027175324, 0.017411733]), new Float32Array([0.027118199, 0.01750057]), new Float32Array([0.027060783, 0.01758922]), new Float32Array([0.027003078, 0.017677682]), new Float32Array([0.026945084, 0.017765954]), new Float32Array([0.0268868, 0.017854037]), new Float32Array([0.02682823, 0.017941928]), new Float32Array([0.026769372, 0.018029626]), new Float32Array([0.026710225, 0.018117134]), new Float32Array([0.026650794, 0.018204445]), new Float32Array([0.026591077, 0.018291561]), new Float32Array([0.026531076, 0.018378483]), new Float32Array([0.026470792, 0.018465206]), new Float32Array([0.026410222, 0.018551733]), new Float32Array([0.026349371, 0.018638061]), new Float32Array([0.026288237, 0.01872419]), new Float32Array([0.026226822, 0.018810118]), new Float32Array([0.026165126, 0.018895842]), new Float32Array([0.026103148, 0.018981367]), new Float32Array([0.026040893, 0.019066688]), new Float32Array([0.025978358, 0.019151803]), new Float32Array([0.025915544, 0.019236716]), new Float32Array([0.025852455, 0.019321421]), new Float32Array([0.025789086, 0.019405918]), new Float32Array([0.025725443, 0.019490208]), new Float32Array([0.025661524, 0.01957429]), new Float32Array([0.02559733, 0.019658163]), new Float32Array([0.025532862, 0.019741824]), new Float32Array([0.02546812, 0.019825274]), new Float32Array([0.025403107, 0.019908514]), new Float32Array([0.025337819, 0.019991538]), new Float32Array([0.025272261, 0.020074349]), new Float32Array([0.025206434, 0.020156944]), new Float32Array([0.025140336, 0.020239323]), new Float32Array([0.025073968, 0.020321487]), new Float32Array([0.025007332, 0.020403432]), new Float32Array([0.024940427, 0.020485159]), new Float32Array([0.024873257, 0.020566666]), new Float32Array([0.02480582, 0.020647954]), new Float32Array([0.024738116, 0.02072902]), new Float32Array([0.024670148, 0.020809865]), new Float32Array([0.024601916, 0.020890485]), new Float32Array([0.02453342, 0.020970883]), new Float32Array([0.024464663, 0.021051057]), new Float32Array([0.024395643, 0.021131003]), new Float32Array([0.02432636, 0.021210724]), new Float32Array([0.024256818, 0.021290218]), new Float32Array([0.024187017, 0.021369485]), new Float32Array([0.024116956, 0.021448523]), new Float32Array([0.024046637, 0.02152733]), new Float32Array([0.02397606, 0.021605907]), new Float32Array([0.023905227, 0.021684252]), new Float32Array([0.023834137, 0.021762365]), new Float32Array([0.023762792, 0.021840246]), new Float32Array([0.023691194, 0.021917893]), new Float32Array([0.02361934, 0.021995304]), new Float32Array([0.023547234, 0.022072481]), new Float32Array([0.023474876, 0.022149421]), new Float32Array([0.023402268, 0.022226123]), new Float32Array([0.023329407, 0.022302588]), new Float32Array([0.023256298, 0.022378813]), new Float32Array([0.023182938, 0.0224548]), new Float32Array([0.023109332, 0.022530545]), new Float32Array([0.023035476, 0.022606049]), new Float32Array([0.022961376, 0.022681313]), new Float32Array([0.022887029, 0.02275633]), new Float32Array([0.022812435, 0.022831107]), new Float32Array([0.0227376, 0.022905638]), new Float32Array([0.022662519, 0.022979924]), new Float32Array([0.022587197, 0.023053963]), new Float32Array([0.022511631, 0.023127757]), new Float32Array([0.022435825, 0.023201302]), new Float32Array([0.02235978, 0.023274599]), new Float32Array([0.022283494, 0.023347646]), new Float32Array([0.02220697, 0.023420444]), new Float32Array([0.022130208, 0.02349299]), new Float32Array([0.022053208, 0.023565285]), new Float32Array([0.021975974, 0.023637328]), new Float32Array([0.021898502, 0.023709117]), new Float32Array([0.021820799, 0.023780653]), new Float32Array([0.02174286, 0.023851933]), new Float32Array([0.021664688, 0.02392296]), new Float32Array([0.021586284, 0.023993729]), new Float32Array([0.021507649, 0.024064241]), new Float32Array([0.021428784, 0.024134494]), new Float32Array([0.02134969, 0.02420449]), new Float32Array([0.021270366, 0.024274228]), new Float32Array([0.021190817, 0.024343705]), new Float32Array([0.021111038, 0.024412923]), new Float32Array([0.021031033, 0.024481876]), new Float32Array([0.020950805, 0.024550568]), new Float32Array([0.02087035, 0.024618998]), new Float32Array([0.020789674, 0.024687165]), new Float32Array([0.020708775, 0.024755066]), new Float32Array([0.020627653, 0.024822703]), new Float32Array([0.02054631, 0.024890075]), new Float32Array([0.020464748, 0.024957178]), new Float32Array([0.020382967, 0.025024015]), new Float32Array([0.020300966, 0.025090585]), new Float32Array([0.020218749, 0.025156885]), new Float32Array([0.020136315, 0.025222916]), new Float32Array([0.020053666, 0.025288677]), new Float32Array([0.0199708, 0.025354166]), new Float32Array([0.019887723, 0.025419384]), new Float32Array([0.019804433, 0.025484331]), new Float32Array([0.019720929, 0.025549004]), new Float32Array([0.019637214, 0.025613405]), new Float32Array([0.01955329, 0.02567753]), new Float32Array([0.019469157, 0.02574138]), new Float32Array([0.019384814, 0.025804954]), new Float32Array([0.019300263, 0.025868252]), new Float32Array([0.019215506, 0.025931275]), new Float32Array([0.019130545, 0.025994018]), new Float32Array([0.019045377, 0.026056483]), new Float32Array([0.018960005, 0.02611867]), new Float32Array([0.018874431, 0.026180577]), new Float32Array([0.018788654, 0.026242202]), new Float32Array([0.018702677, 0.026303547]), new Float32Array([0.018616498, 0.02636461]), new Float32Array([0.018530121, 0.026425391]), new Float32Array([0.018443543, 0.02648589]), new Float32Array([0.01835677, 0.026546104]), new Float32Array([0.018269802, 0.026606034]), new Float32Array([0.018182635, 0.02666568]), new Float32Array([0.018095275, 0.026725039]), new Float32Array([0.01800772, 0.026784113]), new Float32Array([0.017919973, 0.0268429]), new Float32Array([0.017832035, 0.026901398]), new Float32Array([0.017743904, 0.02695961]), new Float32Array([0.017655585, 0.027017532]), new Float32Array([0.017567076, 0.027075164]), new Float32Array([0.017478378, 0.027132507]), new Float32Array([0.017389493, 0.02718956]), new Float32Array([0.017300423, 0.02724632]), new Float32Array([0.017211167, 0.02730279]), new Float32Array([0.017121727, 0.027358968]), new Float32Array([0.017032104, 0.027414853]), new Float32Array([0.016942298, 0.027470443]), new Float32Array([0.01685231, 0.02752574]), new Float32Array([0.016762143, 0.02758074]), new Float32Array([0.016671795, 0.027635446]), new Float32Array([0.016581269, 0.027689857]), new Float32Array([0.016490566, 0.027743971]), new Float32Array([0.016399685, 0.027797787]), new Float32Array([0.01630863, 0.027851306]), new Float32Array([0.0162174, 0.027904527]), new Float32Array([0.016125996, 0.027957449]), new Float32Array([0.016034419, 0.02801007]), new Float32Array([0.01594267, 0.028062394]), new Float32Array([0.01585075, 0.028114416]), new Float32Array([0.015758662, 0.028166136]), new Float32Array([0.015666405, 0.028217556]), new Float32Array([0.015573979, 0.028268673]), new Float32Array([0.015481387, 0.028319487]), new Float32Array([0.015388629, 0.028369997]), new Float32Array([0.015295706, 0.028420204]), new Float32Array([0.015202619, 0.028470108]), new Float32Array([0.01510937, 0.028519705]), new Float32Array([0.015015959, 0.028568998]), new Float32Array([0.014922387, 0.028617984]), new Float32Array([0.014828655, 0.028666664]), new Float32Array([0.014734765, 0.028715037]), new Float32Array([0.014640716, 0.028763102]), new Float32Array([0.014546511, 0.02881086]), new Float32Array([0.014452149, 0.02885831]), new Float32Array([0.014357634, 0.02890545]), new Float32Array([0.014262964, 0.02895228]), new Float32Array([0.014168141, 0.0289988]), new Float32Array([0.014073168, 0.02904501]), new Float32Array([0.013978043, 0.02909091]), new Float32Array([0.013882768, 0.029136496]), new Float32Array([0.013787345, 0.029181771]), new Float32Array([0.013691775, 0.029226733]), new Float32Array([0.013596057, 0.029271383]), new Float32Array([0.013500194, 0.02931572]), new Float32Array([0.013404187, 0.029359741]), new Float32Array([0.013308035, 0.02940345]), new Float32Array([0.013211742, 0.029446842]), new Float32Array([0.013115306, 0.02948992]), new Float32Array([0.013018731, 0.029532682]), new Float32Array([0.012922016, 0.029575128]), new Float32Array([0.012825162, 0.029617256]), new Float32Array([0.012728171, 0.029659068]), new Float32Array([0.012631045, 0.029700562]), new Float32Array([0.012533782, 0.029741738]), new Float32Array([0.012436386, 0.029782595]), new Float32Array([0.012338856, 0.029823134]), new Float32Array([0.012241194, 0.029863352]), new Float32Array([0.012143401, 0.029903252]), new Float32Array([0.012045478, 0.029942831]), new Float32Array([0.011947426, 0.02998209]), new Float32Array([0.011849246, 0.030021027]), new Float32Array([0.011750939, 0.030059641]), new Float32Array([0.011652507, 0.030097935]), new Float32Array([0.01155395, 0.030135907]), new Float32Array([0.011455269, 0.030173557]), new Float32Array([0.011356465, 0.030210882]), new Float32Array([0.011257539, 0.030247884]), new Float32Array([0.011158492, 0.030284563]), new Float32Array([0.011059327, 0.030320916]), new Float32Array([0.010960043, 0.030356945]), new Float32Array([0.0108606415, 0.030392649]), new Float32Array([0.010761124, 0.030428028]), new Float32Array([0.010661491, 0.03046308]), new Float32Array([0.010561744, 0.030497806]), new Float32Array([0.010461884, 0.030532207]), new Float32Array([0.010361912, 0.030566279]), new Float32Array([0.010261828, 0.030600024]), new Float32Array([0.0101616355, 0.030633444]), new Float32Array([0.010061333, 0.030666532]), new Float32Array([0.009960923, 0.030699294]), new Float32Array([0.009860408, 0.030731726]), new Float32Array([0.009759786, 0.030763831]), new Float32Array([0.009659058, 0.030795604]), new Float32Array([0.009558229, 0.03082705]), new Float32Array([0.009457297, 0.030858163]), new Float32Array([0.009356263, 0.030888947]), new Float32Array([0.009255129, 0.0309194]), new Float32Array([0.009153896, 0.030949522]), new Float32Array([0.009052565, 0.030979311]), new Float32Array([0.008951138, 0.03100877]), new Float32Array([0.008849614, 0.031037897]), new Float32Array([0.008747996, 0.03106669]), new Float32Array([0.008646283, 0.03109515]), new Float32Array([0.008544479, 0.03112328]), new Float32Array([0.008442583, 0.031151075]), new Float32Array([0.008340595, 0.031178536]), new Float32Array([0.00823852, 0.031205663]), new Float32Array([0.008136355, 0.031232458]), new Float32Array([0.008034104, 0.031258915]), new Float32Array([0.007931766, 0.03128504]), new Float32Array([0.007829344, 0.03131083]), new Float32Array([0.007726838, 0.03133628]), new Float32Array([0.007624249, 0.0313614]), new Float32Array([0.0075215786, 0.031386185]), new Float32Array([0.007418827, 0.03141063]), new Float32Array([0.0073159966, 0.03143474]), new Float32Array([0.0072130878, 0.031458512]), new Float32Array([0.0071101016, 0.031481948]), new Float32Array([0.007007039, 0.03150505]), new Float32Array([0.006903902, 0.03152781]), new Float32Array([0.0068006907, 0.031550232]), new Float32Array([0.0066974065, 0.03157232]), new Float32Array([0.0065940507, 0.031594068]), new Float32Array([0.006490624, 0.031615477]), new Float32Array([0.006387128, 0.03163655]), new Float32Array([0.006283564, 0.031657282]), new Float32Array([0.006179932, 0.031677675]), new Float32Array([0.0060762344, 0.031697728]), new Float32Array([0.0059724716, 0.031717446]), new Float32Array([0.0058686445, 0.031736817]), new Float32Array([0.005764755, 0.031755853]), new Float32Array([0.005660803, 0.03177455]), new Float32Array([0.005556791, 0.031792905]), new Float32Array([0.0054527195, 0.031810917]), new Float32Array([0.0053485897, 0.031828593]), new Float32Array([0.005244402, 0.031845924]), new Float32Array([0.005140159, 0.031862915]), new Float32Array([0.0050358605, 0.031879567]), new Float32Array([0.004931508, 0.031895876]), new Float32Array([0.0048271026, 0.031911843]), new Float32Array([0.004722646, 0.03192747]), new Float32Array([0.004618138, 0.03194275]), new Float32Array([0.0045135813, 0.031957693]), new Float32Array([0.004408976, 0.031972293]), new Float32Array([0.0043043233, 0.03198655]), new Float32Array([0.004199625, 0.032000467]), new Float32Array([0.0040948815, 0.03201404]), new Float32Array([0.0039900937, 0.032027267]), new Float32Array([0.0038852638, 0.032040153]), new Float32Array([0.003780392, 0.032052696]), new Float32Array([0.0036754797, 0.032064896]), new Float32Array([0.003570528, 0.03207675]), new Float32Array([0.0034655381, 0.032088265]), new Float32Array([0.0033605113, 0.032099433]), new Float32Array([0.0032554483, 0.03211026]), new Float32Array([0.0031503504, 0.032120742]), new Float32Array([0.003045219, 0.03213088]), new Float32Array([0.0029400548, 0.032140672]), new Float32Array([0.002834859, 0.03215012]), new Float32Array([0.0027296331, 0.032159224]), new Float32Array([0.0026243778, 0.032167986]), new Float32Array([0.0025190946, 0.0321764]), new Float32Array([0.0024137842, 0.032184474]), new Float32Array([0.002308448, 0.0321922]), new Float32Array([0.002203087, 0.03219958]), new Float32Array([0.0020977026, 0.032206617]), new Float32Array([0.0019922957, 0.03221331]), new Float32Array([0.0018868673, 0.03221966]), new Float32Array([0.0017814188, 0.03222566]), new Float32Array([0.0016759513, 0.03223132]), new Float32Array([0.0015704657, 0.03223663]), new Float32Array([0.0014649634, 0.032241598]), new Float32Array([0.0013594454, 0.032246217]), new Float32Array([0.0012539128, 0.032250494]), new Float32Array([0.0011483667, 0.032254424]), new Float32Array([0.0010428084, 0.03225801]), new Float32Array([9.372389E-4, 0.03226125]), new Float32Array([8.316594E-4, 0.032264143]), new Float32Array([7.26071E-4, 0.03226669]), new Float32Array([6.204748E-4, 0.032268897]), new Float32Array([5.1487196E-4, 0.032270756]), new Float32Array([4.0926356E-4, 0.032272268]), new Float32Array([3.0365083E-4, 0.032273434]), new Float32Array([1.9803483E-4, 0.032274254]), new Float32Array([9.24167E-5, 0.03227473])];
    constructor.MDCT_TABLE_240 = [new Float32Array([0.09128661, 2.9873577E-4]), new Float32Array([0.0912475, 0.0026882382]), new Float32Array([0.091145866, 0.005075898]), new Float32Array([0.09098176, 0.007460079]), new Float32Array([0.0907553, 0.009839147]), new Float32Array([0.09046664, 0.012211473]), new Float32Array([0.09011598, 0.014575429]), new Float32Array([0.08970356, 0.016929395]), new Float32Array([0.089229666, 0.01927176]), new Float32Array([0.08869461, 0.021600917]), new Float32Array([0.08809877, 0.023915268]), new Float32Array([0.087442555, 0.02621323]), new Float32Array([0.086726405, 0.028493227]), new Float32Array([0.08595082, 0.030753694]), new Float32Array([0.08511633, 0.032993086]), new Float32Array([0.0842235, 0.035209868]), new Float32Array([0.08327296, 0.037402514]), new Float32Array([0.08226534, 0.03956953]), new Float32Array([0.08120134, 0.041709427]), new Float32Array([0.08008169, 0.04382074]), new Float32Array([0.07890715, 0.045902014]), new Float32Array([0.07767854, 0.047951832]), new Float32Array([0.07639668, 0.04996879]), new Float32Array([0.075062476, 0.051951498]), new Float32Array([0.073676825, 0.053898603]), new Float32Array([0.07224067, 0.055808768]), new Float32Array([0.07075501, 0.05768068]), new Float32Array([0.06922086, 0.059513066]), new Float32Array([0.06763928, 0.061304666]), new Float32Array([0.066011325, 0.06305425]), new Float32Array([0.06433814, 0.06476062]), new Float32Array([0.062620856, 0.0664226]), new Float32Array([0.060860656, 0.06803906]), new Float32Array([0.05905875, 0.06960889]), new Float32Array([0.05721636, 0.07113101]), new Float32Array([0.05533476, 0.07260439]), new Float32Array([0.05341524, 0.07402801]), new Float32Array([0.051459108, 0.07540089]), new Float32Array([0.04946771, 0.07672209]), new Float32Array([0.047442406, 0.07799071]), new Float32Array([0.04538459, 0.079205886]), new Float32Array([0.04329567, 0.080366775]), new Float32Array([0.041177075, 0.08147258]), new Float32Array([0.03903026, 0.082522556]), new Float32Array([0.0368567, 0.08351597]), new Float32Array([0.034657877, 0.084452145]), new Float32Array([0.032435298, 0.08533044]), new Float32Array([0.030190494, 0.08615026]), new Float32Array([0.027924998, 0.08691104]), new Float32Array([0.025640363, 0.08761224]), new Float32Array([0.023338156, 0.08825341]), new Float32Array([0.021019952, 0.088834085]), new Float32Array([0.018687345, 0.08935388]), new Float32Array([0.016341928, 0.08981244]), new Float32Array([0.0139853135, 0.09020945]), new Float32Array([0.011619112, 0.090544626]), new Float32Array([0.00924495, 0.09081775]), new Float32Array([0.0068644495, 0.09102864]), new Float32Array([0.0044792453, 0.091177136]), new Float32Array([0.0020909712, 0.091263145])];
}, {MDCT_TABLE_2048: "Array", MDCT_TABLE_128: "Array", MDCT_TABLE_1920: "Array", MDCT_TABLE_240: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var MediaInfo = function(dim) {
    this.dim = dim;
};
MediaInfo = stjs.extend(MediaInfo, null, [], function(constructor, prototype) {
    prototype.dim = null;
    prototype.getDim = function() {
        return this.dim;
    };
    prototype.setDim = function(dim) {
        this.dim = dim;
    };
}, {dim: "Size"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var HuffmanTables = function() {};
HuffmanTables = stjs.extend(HuffmanTables, null, [], function(constructor, prototype) {
    constructor.T_HUFFMAN_ENV_1_5DB = [new Int32Array([1, 2]), new Int32Array([-64, -65]), new Int32Array([3, 4]), new Int32Array([-63, -66]), new Int32Array([5, 6]), new Int32Array([-62, -67]), new Int32Array([7, 8]), new Int32Array([-61, -68]), new Int32Array([9, 10]), new Int32Array([-60, -69]), new Int32Array([11, 12]), new Int32Array([-59, -70]), new Int32Array([13, 14]), new Int32Array([-58, -71]), new Int32Array([15, 16]), new Int32Array([-57, -72]), new Int32Array([17, 18]), new Int32Array([-73, -56]), new Int32Array([19, 21]), new Int32Array([-74, 20]), new Int32Array([-55, -75]), new Int32Array([22, 26]), new Int32Array([23, 24]), new Int32Array([-54, -76]), new Int32Array([-77, 25]), new Int32Array([-53, -78]), new Int32Array([27, 34]), new Int32Array([28, 29]), new Int32Array([-52, -79]), new Int32Array([30, 31]), new Int32Array([-80, -51]), new Int32Array([32, 33]), new Int32Array([-83, -82]), new Int32Array([-81, -50]), new Int32Array([35, 57]), new Int32Array([36, 40]), new Int32Array([37, 38]), new Int32Array([-88, -84]), new Int32Array([-48, 39]), new Int32Array([-90, -85]), new Int32Array([41, 46]), new Int32Array([42, 43]), new Int32Array([-49, -87]), new Int32Array([44, 45]), new Int32Array([-89, -86]), new Int32Array([-124, -123]), new Int32Array([47, 50]), new Int32Array([48, 49]), new Int32Array([-122, -121]), new Int32Array([-120, -119]), new Int32Array([51, 54]), new Int32Array([52, 53]), new Int32Array([-118, -117]), new Int32Array([-116, -115]), new Int32Array([55, 56]), new Int32Array([-114, -113]), new Int32Array([-112, -111]), new Int32Array([58, 89]), new Int32Array([59, 74]), new Int32Array([60, 67]), new Int32Array([61, 64]), new Int32Array([62, 63]), new Int32Array([-110, -109]), new Int32Array([-108, -107]), new Int32Array([65, 66]), new Int32Array([-106, -105]), new Int32Array([-104, -103]), new Int32Array([68, 71]), new Int32Array([69, 70]), new Int32Array([-102, -101]), new Int32Array([-100, -99]), new Int32Array([72, 73]), new Int32Array([-98, -97]), new Int32Array([-96, -95]), new Int32Array([75, 82]), new Int32Array([76, 79]), new Int32Array([77, 78]), new Int32Array([-94, -93]), new Int32Array([-92, -91]), new Int32Array([80, 81]), new Int32Array([-47, -46]), new Int32Array([-45, -44]), new Int32Array([83, 86]), new Int32Array([84, 85]), new Int32Array([-43, -42]), new Int32Array([-41, -40]), new Int32Array([87, 88]), new Int32Array([-39, -38]), new Int32Array([-37, -36]), new Int32Array([90, 105]), new Int32Array([91, 98]), new Int32Array([92, 95]), new Int32Array([93, 94]), new Int32Array([-35, -34]), new Int32Array([-33, -32]), new Int32Array([96, 97]), new Int32Array([-31, -30]), new Int32Array([-29, -28]), new Int32Array([99, 102]), new Int32Array([100, 101]), new Int32Array([-27, -26]), new Int32Array([-25, -24]), new Int32Array([103, 104]), new Int32Array([-23, -22]), new Int32Array([-21, -20]), new Int32Array([106, 113]), new Int32Array([107, 110]), new Int32Array([108, 109]), new Int32Array([-19, -18]), new Int32Array([-17, -16]), new Int32Array([111, 112]), new Int32Array([-15, -14]), new Int32Array([-13, -12]), new Int32Array([114, 117]), new Int32Array([115, 116]), new Int32Array([-11, -10]), new Int32Array([-9, -8]), new Int32Array([118, 119]), new Int32Array([-7, -6]), new Int32Array([-5, -4])];
    constructor.F_HUFFMAN_ENV_1_5DB = [new Int32Array([1, 2]), new Int32Array([-64, -65]), new Int32Array([3, 4]), new Int32Array([-63, -66]), new Int32Array([5, 6]), new Int32Array([-67, -62]), new Int32Array([7, 8]), new Int32Array([-68, -61]), new Int32Array([9, 10]), new Int32Array([-69, -60]), new Int32Array([11, 13]), new Int32Array([-70, 12]), new Int32Array([-59, -71]), new Int32Array([14, 16]), new Int32Array([-58, 15]), new Int32Array([-72, -57]), new Int32Array([17, 19]), new Int32Array([-73, 18]), new Int32Array([-56, -74]), new Int32Array([20, 23]), new Int32Array([21, 22]), new Int32Array([-55, -75]), new Int32Array([-54, -53]), new Int32Array([24, 27]), new Int32Array([25, 26]), new Int32Array([-76, -52]), new Int32Array([-77, -51]), new Int32Array([28, 31]), new Int32Array([29, 30]), new Int32Array([-50, -78]), new Int32Array([-79, -49]), new Int32Array([32, 36]), new Int32Array([33, 34]), new Int32Array([-48, -47]), new Int32Array([-80, 35]), new Int32Array([-81, -82]), new Int32Array([37, 47]), new Int32Array([38, 41]), new Int32Array([39, 40]), new Int32Array([-83, -46]), new Int32Array([-45, -84]), new Int32Array([42, 44]), new Int32Array([-85, 43]), new Int32Array([-44, -43]), new Int32Array([45, 46]), new Int32Array([-88, -87]), new Int32Array([-86, -90]), new Int32Array([48, 66]), new Int32Array([49, 56]), new Int32Array([50, 53]), new Int32Array([51, 52]), new Int32Array([-92, -42]), new Int32Array([-41, -39]), new Int32Array([54, 55]), new Int32Array([-105, -89]), new Int32Array([-38, -37]), new Int32Array([57, 60]), new Int32Array([58, 59]), new Int32Array([-94, -91]), new Int32Array([-40, -36]), new Int32Array([61, 63]), new Int32Array([-20, 62]), new Int32Array([-115, -110]), new Int32Array([64, 65]), new Int32Array([-108, -107]), new Int32Array([-101, -97]), new Int32Array([67, 89]), new Int32Array([68, 75]), new Int32Array([69, 72]), new Int32Array([70, 71]), new Int32Array([-95, -93]), new Int32Array([-34, -27]), new Int32Array([73, 74]), new Int32Array([-22, -17]), new Int32Array([-16, -124]), new Int32Array([76, 82]), new Int32Array([77, 79]), new Int32Array([-123, 78]), new Int32Array([-122, -121]), new Int32Array([80, 81]), new Int32Array([-120, -119]), new Int32Array([-118, -117]), new Int32Array([83, 86]), new Int32Array([84, 85]), new Int32Array([-116, -114]), new Int32Array([-113, -112]), new Int32Array([87, 88]), new Int32Array([-111, -109]), new Int32Array([-106, -104]), new Int32Array([90, 105]), new Int32Array([91, 98]), new Int32Array([92, 95]), new Int32Array([93, 94]), new Int32Array([-103, -102]), new Int32Array([-100, -99]), new Int32Array([96, 97]), new Int32Array([-98, -96]), new Int32Array([-35, -33]), new Int32Array([99, 102]), new Int32Array([100, 101]), new Int32Array([-32, -31]), new Int32Array([-30, -29]), new Int32Array([103, 104]), new Int32Array([-28, -26]), new Int32Array([-25, -24]), new Int32Array([106, 113]), new Int32Array([107, 110]), new Int32Array([108, 109]), new Int32Array([-23, -21]), new Int32Array([-19, -18]), new Int32Array([111, 112]), new Int32Array([-15, -14]), new Int32Array([-13, -12]), new Int32Array([114, 117]), new Int32Array([115, 116]), new Int32Array([-11, -10]), new Int32Array([-9, -8]), new Int32Array([118, 119]), new Int32Array([-7, -6]), new Int32Array([-5, -4])];
    constructor.T_HUFFMAN_ENV_BAL_1_5DB = [new Int32Array([-64, 1]), new Int32Array([-63, 2]), new Int32Array([-65, 3]), new Int32Array([-62, 4]), new Int32Array([-66, 5]), new Int32Array([-61, 6]), new Int32Array([-67, 7]), new Int32Array([-60, 8]), new Int32Array([-68, 9]), new Int32Array([10, 11]), new Int32Array([-69, -59]), new Int32Array([12, 13]), new Int32Array([-70, -58]), new Int32Array([14, 28]), new Int32Array([15, 21]), new Int32Array([16, 18]), new Int32Array([-57, 17]), new Int32Array([-71, -56]), new Int32Array([19, 20]), new Int32Array([-88, -87]), new Int32Array([-86, -85]), new Int32Array([22, 25]), new Int32Array([23, 24]), new Int32Array([-84, -83]), new Int32Array([-82, -81]), new Int32Array([26, 27]), new Int32Array([-80, -79]), new Int32Array([-78, -77]), new Int32Array([29, 36]), new Int32Array([30, 33]), new Int32Array([31, 32]), new Int32Array([-76, -75]), new Int32Array([-74, -73]), new Int32Array([34, 35]), new Int32Array([-72, -55]), new Int32Array([-54, -53]), new Int32Array([37, 41]), new Int32Array([38, 39]), new Int32Array([-52, -51]), new Int32Array([-50, 40]), new Int32Array([-49, -48]), new Int32Array([42, 45]), new Int32Array([43, 44]), new Int32Array([-47, -46]), new Int32Array([-45, -44]), new Int32Array([46, 47]), new Int32Array([-43, -42]), new Int32Array([-41, -40])];
    constructor.F_HUFFMAN_ENV_BAL_1_5DB = [new Int32Array([-64, 1]), new Int32Array([-65, 2]), new Int32Array([-63, 3]), new Int32Array([-66, 4]), new Int32Array([-62, 5]), new Int32Array([-61, 6]), new Int32Array([-67, 7]), new Int32Array([-68, 8]), new Int32Array([-60, 9]), new Int32Array([10, 11]), new Int32Array([-69, -59]), new Int32Array([-70, 12]), new Int32Array([-58, 13]), new Int32Array([14, 17]), new Int32Array([-71, 15]), new Int32Array([-57, 16]), new Int32Array([-56, -73]), new Int32Array([18, 32]), new Int32Array([19, 25]), new Int32Array([20, 22]), new Int32Array([-72, 21]), new Int32Array([-88, -87]), new Int32Array([23, 24]), new Int32Array([-86, -85]), new Int32Array([-84, -83]), new Int32Array([26, 29]), new Int32Array([27, 28]), new Int32Array([-82, -81]), new Int32Array([-80, -79]), new Int32Array([30, 31]), new Int32Array([-78, -77]), new Int32Array([-76, -75]), new Int32Array([33, 40]), new Int32Array([34, 37]), new Int32Array([35, 36]), new Int32Array([-74, -55]), new Int32Array([-54, -53]), new Int32Array([38, 39]), new Int32Array([-52, -51]), new Int32Array([-50, -49]), new Int32Array([41, 44]), new Int32Array([42, 43]), new Int32Array([-48, -47]), new Int32Array([-46, -45]), new Int32Array([45, 46]), new Int32Array([-44, -43]), new Int32Array([-42, 47]), new Int32Array([-41, -40])];
    constructor.T_HUFFMAN_ENV_3_0DB = [new Int32Array([-64, 1]), new Int32Array([-65, 2]), new Int32Array([-63, 3]), new Int32Array([-66, 4]), new Int32Array([-62, 5]), new Int32Array([-67, 6]), new Int32Array([-61, 7]), new Int32Array([-68, 8]), new Int32Array([-60, 9]), new Int32Array([10, 11]), new Int32Array([-69, -59]), new Int32Array([12, 14]), new Int32Array([-70, 13]), new Int32Array([-71, -58]), new Int32Array([15, 18]), new Int32Array([16, 17]), new Int32Array([-72, -57]), new Int32Array([-73, -74]), new Int32Array([19, 22]), new Int32Array([-56, 20]), new Int32Array([-55, 21]), new Int32Array([-54, -77]), new Int32Array([23, 31]), new Int32Array([24, 25]), new Int32Array([-75, -76]), new Int32Array([26, 27]), new Int32Array([-78, -53]), new Int32Array([28, 29]), new Int32Array([-52, -95]), new Int32Array([-94, 30]), new Int32Array([-93, -92]), new Int32Array([32, 47]), new Int32Array([33, 40]), new Int32Array([34, 37]), new Int32Array([35, 36]), new Int32Array([-91, -90]), new Int32Array([-89, -88]), new Int32Array([38, 39]), new Int32Array([-87, -86]), new Int32Array([-85, -84]), new Int32Array([41, 44]), new Int32Array([42, 43]), new Int32Array([-83, -82]), new Int32Array([-81, -80]), new Int32Array([45, 46]), new Int32Array([-79, -51]), new Int32Array([-50, -49]), new Int32Array([48, 55]), new Int32Array([49, 52]), new Int32Array([50, 51]), new Int32Array([-48, -47]), new Int32Array([-46, -45]), new Int32Array([53, 54]), new Int32Array([-44, -43]), new Int32Array([-42, -41]), new Int32Array([56, 59]), new Int32Array([57, 58]), new Int32Array([-40, -39]), new Int32Array([-38, -37]), new Int32Array([60, 61]), new Int32Array([-36, -35]), new Int32Array([-34, -33])];
    constructor.F_HUFFMAN_ENV_3_0DB = [new Int32Array([-64, 1]), new Int32Array([-65, 2]), new Int32Array([-63, 3]), new Int32Array([-66, 4]), new Int32Array([-62, 5]), new Int32Array([-67, 6]), new Int32Array([7, 8]), new Int32Array([-61, -68]), new Int32Array([9, 10]), new Int32Array([-60, -69]), new Int32Array([11, 12]), new Int32Array([-59, -70]), new Int32Array([13, 14]), new Int32Array([-58, -71]), new Int32Array([15, 16]), new Int32Array([-57, -72]), new Int32Array([17, 19]), new Int32Array([-56, 18]), new Int32Array([-55, -73]), new Int32Array([20, 24]), new Int32Array([21, 22]), new Int32Array([-74, -54]), new Int32Array([-53, 23]), new Int32Array([-75, -76]), new Int32Array([25, 30]), new Int32Array([26, 27]), new Int32Array([-52, -51]), new Int32Array([28, 29]), new Int32Array([-77, -79]), new Int32Array([-50, -49]), new Int32Array([31, 39]), new Int32Array([32, 35]), new Int32Array([33, 34]), new Int32Array([-78, -46]), new Int32Array([-82, -88]), new Int32Array([36, 37]), new Int32Array([-83, -48]), new Int32Array([-47, 38]), new Int32Array([-86, -85]), new Int32Array([40, 47]), new Int32Array([41, 44]), new Int32Array([42, 43]), new Int32Array([-80, -44]), new Int32Array([-43, -42]), new Int32Array([45, 46]), new Int32Array([-39, -87]), new Int32Array([-84, -40]), new Int32Array([48, 55]), new Int32Array([49, 52]), new Int32Array([50, 51]), new Int32Array([-95, -94]), new Int32Array([-93, -92]), new Int32Array([53, 54]), new Int32Array([-91, -90]), new Int32Array([-89, -81]), new Int32Array([56, 59]), new Int32Array([57, 58]), new Int32Array([-45, -41]), new Int32Array([-38, -37]), new Int32Array([60, 61]), new Int32Array([-36, -35]), new Int32Array([-34, -33])];
    constructor.T_HUFFMAN_ENV_BAL_3_0DB = [new Int32Array([-64, 1]), new Int32Array([-63, 2]), new Int32Array([-65, 3]), new Int32Array([-66, 4]), new Int32Array([-62, 5]), new Int32Array([-61, 6]), new Int32Array([-67, 7]), new Int32Array([-68, 8]), new Int32Array([-60, 9]), new Int32Array([10, 16]), new Int32Array([11, 13]), new Int32Array([-69, 12]), new Int32Array([-76, -75]), new Int32Array([14, 15]), new Int32Array([-74, -73]), new Int32Array([-72, -71]), new Int32Array([17, 20]), new Int32Array([18, 19]), new Int32Array([-70, -59]), new Int32Array([-58, -57]), new Int32Array([21, 22]), new Int32Array([-56, -55]), new Int32Array([-54, 23]), new Int32Array([-53, -52])];
    constructor.F_HUFFMAN_ENV_BAL_3_0DB = [new Int32Array([-64, 1]), new Int32Array([-65, 2]), new Int32Array([-63, 3]), new Int32Array([-66, 4]), new Int32Array([-62, 5]), new Int32Array([-61, 6]), new Int32Array([-67, 7]), new Int32Array([-68, 8]), new Int32Array([-60, 9]), new Int32Array([10, 13]), new Int32Array([-69, 11]), new Int32Array([-59, 12]), new Int32Array([-58, -76]), new Int32Array([14, 17]), new Int32Array([15, 16]), new Int32Array([-75, -74]), new Int32Array([-73, -72]), new Int32Array([18, 21]), new Int32Array([19, 20]), new Int32Array([-71, -70]), new Int32Array([-57, -56]), new Int32Array([22, 23]), new Int32Array([-55, -54]), new Int32Array([-53, -52])];
    constructor.T_HUFFMAN_NOISE_3_0DB = [new Int32Array([-64, 1]), new Int32Array([-63, 2]), new Int32Array([-65, 3]), new Int32Array([-66, 4]), new Int32Array([-62, 5]), new Int32Array([-67, 6]), new Int32Array([7, 8]), new Int32Array([-61, -68]), new Int32Array([9, 30]), new Int32Array([10, 15]), new Int32Array([-60, 11]), new Int32Array([-69, 12]), new Int32Array([13, 14]), new Int32Array([-59, -53]), new Int32Array([-95, -94]), new Int32Array([16, 23]), new Int32Array([17, 20]), new Int32Array([18, 19]), new Int32Array([-93, -92]), new Int32Array([-91, -90]), new Int32Array([21, 22]), new Int32Array([-89, -88]), new Int32Array([-87, -86]), new Int32Array([24, 27]), new Int32Array([25, 26]), new Int32Array([-85, -84]), new Int32Array([-83, -82]), new Int32Array([28, 29]), new Int32Array([-81, -80]), new Int32Array([-79, -78]), new Int32Array([31, 46]), new Int32Array([32, 39]), new Int32Array([33, 36]), new Int32Array([34, 35]), new Int32Array([-77, -76]), new Int32Array([-75, -74]), new Int32Array([37, 38]), new Int32Array([-73, -72]), new Int32Array([-71, -70]), new Int32Array([40, 43]), new Int32Array([41, 42]), new Int32Array([-58, -57]), new Int32Array([-56, -55]), new Int32Array([44, 45]), new Int32Array([-54, -52]), new Int32Array([-51, -50]), new Int32Array([47, 54]), new Int32Array([48, 51]), new Int32Array([49, 50]), new Int32Array([-49, -48]), new Int32Array([-47, -46]), new Int32Array([52, 53]), new Int32Array([-45, -44]), new Int32Array([-43, -42]), new Int32Array([55, 58]), new Int32Array([56, 57]), new Int32Array([-41, -40]), new Int32Array([-39, -38]), new Int32Array([59, 60]), new Int32Array([-37, -36]), new Int32Array([-35, 61]), new Int32Array([-34, -33])];
    constructor.T_HUFFMAN_NOISE_BAL_3_0DB = [new Int32Array([-64, 1]), new Int32Array([-65, 2]), new Int32Array([-63, 3]), new Int32Array([4, 9]), new Int32Array([-66, 5]), new Int32Array([-62, 6]), new Int32Array([7, 8]), new Int32Array([-76, -75]), new Int32Array([-74, -73]), new Int32Array([10, 17]), new Int32Array([11, 14]), new Int32Array([12, 13]), new Int32Array([-72, -71]), new Int32Array([-70, -69]), new Int32Array([15, 16]), new Int32Array([-68, -67]), new Int32Array([-61, -60]), new Int32Array([18, 21]), new Int32Array([19, 20]), new Int32Array([-59, -58]), new Int32Array([-57, -56]), new Int32Array([22, 23]), new Int32Array([-55, -54]), new Int32Array([-53, -52])];
}, {T_HUFFMAN_ENV_1_5DB: "Array", F_HUFFMAN_ENV_1_5DB: "Array", T_HUFFMAN_ENV_BAL_1_5DB: "Array", F_HUFFMAN_ENV_BAL_1_5DB: "Array", T_HUFFMAN_ENV_3_0DB: "Array", F_HUFFMAN_ENV_3_0DB: "Array", T_HUFFMAN_ENV_BAL_3_0DB: "Array", F_HUFFMAN_ENV_BAL_3_0DB: "Array", T_HUFFMAN_NOISE_3_0DB: "Array", T_HUFFMAN_NOISE_BAL_3_0DB: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PredictionWeightTable = function() {
    this.lumaWeight = Array(2);
    this.chromaWeight = Array(2);
    this.lumaOffset = Array(2);
    this.chromaOffset = Array(2);
};
PredictionWeightTable = stjs.extend(PredictionWeightTable, null, [], function(constructor, prototype) {
    prototype.lumaLog2WeightDenom = 0;
    prototype.chromaLog2WeightDenom = 0;
    prototype.lumaWeight = null;
    prototype.chromaWeight = null;
    prototype.lumaOffset = null;
    prototype.chromaOffset = null;
}, {lumaWeight: "Array", chromaWeight: "Array", lumaOffset: "Array", chromaOffset: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A generic interface for the video encoder.
 *  
 *  @author The JCodec project
 *  
 */
var VideoEncoder = function() {};
VideoEncoder = stjs.extend(VideoEncoder, null, [], function(constructor, prototype) {
    /**
     *  The bytes of this video frame with associated metadata.
     *  
     *  @author The JCodec project
     */
    constructor.EncodedFrame = function(data, keyFrame) {
        this.data = data;
        this.keyFrame = keyFrame;
    };
    constructor.EncodedFrame = stjs.extend(constructor.EncodedFrame, null, [], function(constructor, prototype) {
        prototype.data = null;
        prototype.keyFrame = false;
        prototype.getData = function() {
            return this.data;
        };
        prototype.isKeyFrame = function() {
            return this.keyFrame;
        };
    }, {data: "ByteBuffer"}, {});
    /**
     *  Encode one video frame.
     *  
     *  @param pic
     *             The video frame to be encoded. Must be in one of the encoder's
     *             native color spaces.
     *  @param buffer
     *             The buffer to store the encoded frame into. Note, only the
     *             storage of this buffer is used, the position and limit are
     *             kept untouched. Instead the returned value contains a
     *             duplicate of this buffer with the position and limit set
     *             correctly to the boundaries of the encoded frame. This buffer
     *             must be large enough to hold the encoded frame. It is
     *             undefined what will happen if the buffer is not large enough.
     *             Most commonly some exception will be thrown.
     *  @return The bytes of an encoded frame with additional metadata. The bytes
     *          are located in the storage supplied by the buffer argument, no
     *          allocation happens.
     */
    prototype.encodeFrame = function(pic, buffer) {};
    /**
     *  Native color spaces of this video encoder, i.e. the color space the video
     *  encoder uses internally to represent color. For example the native color
     *  space of an h.264 encoder is most commonly yuv420. This information is
     *  used to find the correct color transform. The encoder may return null
     *  which means that ANY color space will be taken. This is useful in some
     *  cases for instance for the raw video encoder.
     *  
     *  @return The array of this encoder's native color spaces.
     */
    prototype.getSupportedColorSpaces = function() {};
    /**
     *  Estimate the output buffer size that will likely be needed for the
     *  current instance of encoder to encode a given frame. Note: expect a very
     *  coarse estimate that reflects the settings the encoder has been created
     *  with as well as the input frame size.
     *  
     *  @param frame
     *             A frame in question.
     *  @return The number of bytes the encoded frame will likely take.
     */
    prototype.estimateBufferSize = function(frame) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 4 AVC ( H.264 ) Encoder pluggable rate control mechanism
 *  
 *  @author The JCodec project
 *  
 */
var RateControl = function() {};
RateControl = stjs.extend(RateControl, null, [], function(constructor, prototype) {
    prototype.startPicture = function(sz, maxSize, sliceType) {};
    prototype.initialQpDelta = function() {};
    prototype.accept = function(bits) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VPXBooleanDecoder = function(input, offset) {
    this.input = input;
    this.offset = offset;
    this.initBoolDecoder();
};
VPXBooleanDecoder = stjs.extend(VPXBooleanDecoder, null, [], function(constructor, prototype) {
    prototype.bit_count = 0;
    prototype.input = null;
    prototype.offset = 0;
    prototype.range = 0;
    prototype.value = 0;
    prototype.callCounter = 0;
    prototype.debugName = null;
    prototype.initBoolDecoder = function() {
        this.value = 0;
        this.value = (this.input.get() & 255) << 8;
        this.offset++;
        this.range = 255;
        this.bit_count = 0;
    };
    prototype.readBitEq = function() {
        return this.readBit(128);
    };
    prototype.readBit = function(probability) {
        var bit = 0;
        var range = this.range;
        var value = this.value;
        var split = 1 + (((range - 1) * probability) >> 8);
        var bigsplit = (split << 8);
        this.callCounter++;
        range = split;
        if (value >= bigsplit) {
            range = this.range - range;
            value = value - bigsplit;
            bit = 1;
        }
        var count = this.bit_count;
        var shift = VPXBooleanDecoder.leadingZeroCountInByte((range << 24 >> 24));
        range <<= shift;
        value <<= shift;
        count -= shift;
        if (count <= 0) {
            value |= (this.input.get() & 255) << (-count);
            this.offset++;
            count += 8;
        }
        this.bit_count = count;
        this.value = value;
        this.range = range;
        return bit;
    };
    prototype.decodeInt = function(sizeInBits) {
        var v = 0;
         while (sizeInBits-- > 0)
            v = (v << 1) | this.readBit(128);
        return v;
    };
    /**
     *   
     *  General formula in VP8 trees.
     *  <ul>
     *   <li> if tree element is a positive number it is treated as index of the child elements <pre>tree[i] > 0</pre>
     *        <ul>
     *        <li> left child is assumed to have index <pre>i</pre> and value <pre>tree[i]</pre> </li>
     *        <li> right child is assumed to have index <pre>i+1</pre> and value <pre>tree[i+1]</pre></li>
     *        </ul>
     *   </li>
     *   <li> a negative tree value means a leaf node was reached and it's negated value should be returned <pre>-tree[i]</pre></li>
     *  </ul>
     *  
     *  Here's a real example of a tree coded according to this formula in VP8 spec.
     *  <pre>
     *  const tree_index mb_segment_tree [2 * (4-1)] =
     *  // +-------+---+
     *  // |       |   |
     *   { 2,  4, -0, -1, -2, -3 };
     *  //     |           |   |
     *  //     +-----------+---+
     *  </pre>
     *  
     *  If presented in hierarchical form this tree would look like:
     *  <pre>
     *  +---------------+
     *  |      root     |
     *  |     /    \    |
     *  |    2      4   |
     *  |   / \    / \  |
     *  | -0  -1 -2  -3 |
     *  +---------------+
     *  <pre>
     *  
     *  On the other hand probabilities are coded only for non-leaf nodes. 
     *  Thus tree array has twice as many nodes as probabilities array
     *  Consider (3>>1) == 1 == (2>>1), and (0>>1) == 0 == (1>>1)
     *  Thus single probability element refers to single parent element in tree.
     *  if (using that probability) a '0' is coded, algorithm goes to the left 
     *  branch, correspondingly if '1' is coded, algorithm goes to
     *  the right branch (see tree structure above).
     *  
     *  The process is repeated until a negative tree element is found.
     *   
     */
    prototype.readTree = function(tree, probability) {
        var i = 0;
         while ((i = tree[i + this.readBit(probability[i >> 1])]) > 0){}
        return -i;
    };
    prototype.readTree3 = function(tree, prob0, prob1) {
        var i = 0;
        if ((i = tree[i + this.readBit(prob0)]) > 0) {
             while ((i = tree[i + this.readBit(prob1)]) > 0)
                ;
        }
        return -i;
    };
    prototype.readTreeSkip = function(t, p, skip_branches) {
        var i = skip_branches * 2;
         while ((i = t[i + this.readBit(p[i >> 1])]) > 0){}
        return -i;
    };
    prototype.seek = function() {
        this.input.setPosition(this.offset);
    };
    prototype.toString = function() {
        return "bc: " + this.value;
    };
    constructor.getBitInBytes = function(bs, i) {
        var byteIndex = i >> 3;
        var bitIndex = i & 7;
        return (bs[byteIndex] >> (7 - bitIndex)) & 1;
    };
    constructor.getBitsInBytes = function(bytes, idx, len) {
        var val = 0;
        for (var i = 0; i < len; i++) {
            val = (val << 1) | VPXBooleanDecoder.getBitInBytes(bytes, idx + i);
        }
        return val;
    };
    constructor.leadingZeroCountInByte = function(b) {
        var i = b & 255;
        if (i >= 128 || i == 0) 
            return 0;
        return Integer.numberOfLeadingZeros(b) - 24;
    };
}, {input: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  This header specifies which component(s) are contained in the scan, specifies
 *  the destinations from which the entropy tables to be used with each component
 *  are retrieved, and (for the progressive DCT) which part of the DCT quantized
 *  coefficient data is contained in the scan. For lossless processes the scan
 *  parameters specify the predictor and the point transform.
 *  
 *  @author The JCodec project
 */
var ScanHeader = function() {};
ScanHeader = stjs.extend(ScanHeader, null, [], function(constructor, prototype) {
    /**
     *  Scan header length. Specifies the length of the scan header shown in
     *  Figure B.4 (see B.1.1.4).
     */
    prototype.ls = 0;
    /**
     *  Number of image components in scan. Specifies the number of source image
     *  components in the scan. The value of Ns shall be equal to the number of
     *  sets of scan component specification parameters (Csj, Tdj, and Taj)
     *  present in the scan header.
     */
    prototype.ns = 0;
    prototype.isInterleaved = function() {
        return this.ns > 1;
    };
    constructor.Component = function() {};
    constructor.Component = stjs.extend(constructor.Component, null, [], function(constructor, prototype) {
        /**
         *  Scan component selector. Selects which of the Nf image components
         *  specified in the frame parameters shall be the jth component in the
         *  scan. Each Csj shall match one of the Ci values specified in the
         *  frame header, and the ordering in the scan header shall follow the
         *  ordering in the frame header. If Ns > 1, the order of interleaved
         *  components in the MCU is Cs1 first, Cs2 second, etc. If Ns > 1, the
         *  following restriction shall be placed on the image components
         *  contained in the scan:
         *  
         *  <pre>
         *  [j=1..Ns](Hj x Vj) &lt;= 10
         *  </pre>
         *  
         *  where Hj and Vj are the horizontal and vertical sampling factors for
         *  scan component j. These sampling factors are specified in the frame
         *  header for component i, where i is the frame component specification
         *  index for which frame component identifier Ci matches scan component
         *  selector Csj. As an example, consider an image having 3 components
         *  with maximum dimensions of 512 lines and 512 samples per line, and
         *  with the following sampling factors: Component Component 1 Component
         *  2 2 0 4 1 1 2 2 2 0 0 1 1 2 H V H V H V = = = = = = , , Then the
         *  summation of Hj Vj is (4 1) + (1 2) + (2 2) = 10. The value of Csj
         *  shall be different from the values of Cs1 to Csj 1.
         */
        prototype.cs = 0;
        /**
         *  DC entropy coding table destination selector. Specifies one of four
         *  possible DC entropy coding table destinations from which the entropy
         *  table needed for decoding of the DC coefficients of component Csj is
         *  retrieved. The DC entropy table shall have been installed in this
         *  destination (see B.2.4.2 and B.2.4.3) by the time the decoder is
         *  ready to decode the current scan. This parameter specifies the
         *  entropy coding table destination for the lossless processes.
         */
        prototype.td = 0;
        /**
         *  AC entropy coding table destination selector. Specifies one of four
         *  possible AC entropy coding table destinations from which the entropy
         *  table needed for decoding of the AC coefficients of component Csj is
         *  retrieved. The AC entropy table selected shall have been installed in
         *  this destination (see B.2.4.2 and B.2.4.3) by the time the decoder is
         *  ready to decode the current scan. This parameter is zero for the
         *  lossless processes.
         */
        prototype.ta = 0;
    }, {}, {});
    prototype.components = null;
    /**
     *  Start of spectral or predictor selection. In the DCT modes of operation,
     *  this parameter specifies the first DCT coefficient in each block in
     *  zig-zag order which shall be coded in the scan. This parameter shall be
     *  set to zero for the sequential DCT processes. In the lossless mode of
     *  operations this parameter is used to select the predictor.
     */
    prototype.ss = 0;
    /**
     *  End of spectral selection. Specifies the last DCT coefficient in each
     *  block in zig-zag order which shall be coded in the scan. This parameter
     *  shall be set to 63 for the sequential DCT processes. In the lossless mode
     *  of operations this parameter has no meaning. It shall be set to zero.
     */
    prototype.se = 0;
    /**
     *  Successive approximation bit position high. This parameter specifies the
     *  point transform used in the preceding scan (i.e. successive approximation
     *  bit position low in the preceding scan) for the band of coefficients
     *  specified by Ss and Se. This parameter shall be set to zero for the first
     *  scan of each band of coefficients. In the lossless mode of operations
     *  this parameter has no meaning. It shall be set to zero.
     */
    prototype.ah = 0;
    /**
     *  Successive approximation bit position low or point transform. In the DCT
     *  modes of operation this parameter specifies the point transform, i.e. bit
     *  position low, used before coding the band of coefficients specified by Ss
     *  and Se. This parameter shall be set to zero for the sequential DCT
     *  processes. In the lossless mode of operations, this parameter specifies
     *  the point transform, Pt.
     */
    prototype.al = 0;
    constructor.read = function(bb) {
        var scan = new ScanHeader();
        scan.ls = bb.getShort() & 65535;
        scan.ns = bb.get() & 255;
        scan.components = Array(scan.ns);
        for (var i = 0; i < scan.components.length; i++) {
            var c = scan.components[i] = new ScanHeader.Component();
            c.cs = bb.get() & 255;
            var tdta = bb.get() & 255;
            c.td = (tdta & 240) >>> 4;
            c.ta = (tdta & 15);
        }
        scan.ss = bb.get() & 255;
        scan.se = bb.get() & 255;
        var ahal = bb.get() & 255;
        scan.ah = (ahal & 240) >>> 4;
        scan.al = (ahal & 15);
        return scan;
    };
}, {components: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  This code is borrowed from ffmpeg/libavcodec/h264_cabac.c
 *  
 *  @author The JCodec project
 *  
 */
var CABACContst = function() {};
CABACContst = stjs.extend(CABACContst, null, [], function(constructor, prototype) {
    constructor.cabac_context_init_I_A = new Int32Array([20, 2, 3, 20, 2, 3, -28, -23, -6, -1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -9, 4, 0, -7, 13, 3, 0, 1, 0, -17, -13, 0, -7, -21, -27, -31, -24, -18, -27, -21, -30, -17, -12, -16, -11, -12, -2, -15, -13, -3, -8, -10, -30, -1, -6, -7, -20, -4, -5, -7, -22, -7, -11, -3, -5, -4, -4, -12, -7, -7, 8, 5, -2, 1, 0, -2, 1, 7, 10, 0, 11, 1, 0, 5, 31, 1, 7, 28, 16, 14, -13, -15, -13, -13, -12, -10, -16, -10, -7, -13, -19, 1, 0, -5, 18, -8, -15, 0, -4, 2, -11, -3, 15, -13, 0, 0, 21, -15, 9, 16, 0, 12, 24, 15, 8, 13, 15, 13, 10, 12, 6, 20, 15, 4, 1, 0, 7, 12, 11, 15, 11, 13, 16, 12, 10, 30, 18, 10, 17, 17, 0, 26, 22, 26, 30, 28, 33, 37, 33, 40, 38, 33, 40, 41, 38, 41, 30, 27, 26, 37, 35, 38, 38, 37, 38, 42, 35, 39, 14, 27, 21, 12, 2, -3, -6, -5, -3, -2, 0, 1, -2, -1, -9, -5, -5, -3, -2, 0, -16, -8, -10, -6, -10, -12, -15, -10, -6, -4, -12, -8, -7, -9, -17, -11, -20, -11, -6, -4, -13, -13, -11, -19, -8, -5, -4, -2, -3, -13, -10, -12, -13, -14, 0, -6, -6, -8, 0, -1, 0, -2, -2, -5, -3, -4, -9, -1, 0, 3, 10, -7, 15, 14, 16, 12, 1, 20, 18, 5, 1, 10, 17, 9, -12, -11, -16, -7, -8, -7, -9, -13, 4, -3, -3, -6, 10, -1, -1, -7, -14, 2, 0, -5, 0, -11, 1, 0, -14, 3, 4, -1, -13, 11, 5, 12, 15, 6, 7, 12, 18, 13, 13, 15, 12, 13, 15, 14, 14, 17, 17, 24, 21, 25, 31, 22, 19, 14, 10, 7, -2, -4, -3, 9, -12, 36, 36, 32, 37, 44, 34, 34, 40, 33, 35, 33, 38, 33, 23, 13, 29, 26, 22, 31, 35, 34, 34, 36, 34, 32, 35, 34, 39, 30, 34, 29, 19, 31, 31, 25, -17, -20, -18, -11, -15, -14, -26, -15, -14, 0, -14, -24, -23, -24, -11, 23, 26, 40, 49, 44, 45, 44, 33, 19, -3, -1, 1, 1, 0, -2, 0, 1, 0, -9, -14, -13, -15, -12, -18, -10, -9, -14, -10, -10, -10, -5, -9, -5, 2, 21, 24, 28, 28, 29, 29, 35, 29, 14, -17, -12, -16, -11, -12, -2, -15, -13, -3, -8, -10, -30, -17, -12, -16, -11, -12, -2, -15, -13, -3, -8, -10, -30, -7, -11, -3, -5, -4, -4, -12, -7, -7, 8, 5, -2, 1, 0, -2, 1, 7, 10, 0, 11, 1, 0, 5, 31, 1, 7, 28, 16, 14, -13, -15, -13, -13, -12, -10, -16, -10, -7, -13, -19, 1, 0, -5, 18, -7, -11, -3, -5, -4, -4, -12, -7, -7, 8, 5, -2, 1, 0, -2, 1, 7, 10, 0, 11, 1, 0, 5, 31, 1, 7, 28, 16, 14, -13, -15, -13, -13, -12, -10, -16, -10, -7, -13, -19, 1, 0, -5, 18, 24, 15, 8, 13, 15, 13, 10, 12, 6, 20, 15, 4, 1, 0, 7, 12, 11, 15, 11, 13, 16, 12, 10, 30, 18, 10, 17, 17, 0, 26, 22, 26, 30, 28, 33, 37, 33, 40, 38, 33, 40, 41, 38, 41, 24, 15, 8, 13, 15, 13, 10, 12, 6, 20, 15, 4, 1, 0, 7, 12, 11, 15, 11, 13, 16, 12, 10, 30, 18, 10, 17, 17, 0, 26, 22, 26, 30, 28, 33, 37, 33, 40, 38, 33, 40, 41, 38, 41, -17, -20, -18, -11, -15, -14, -26, -15, -14, 0, -14, -24, -23, -24, -11, -14, -13, -15, -12, -18, -10, -9, -14, -10, -10, -10, -5, -9, -5, 2, 23, 26, 40, 49, 44, 45, 44, 33, 19, 21, 24, 28, 28, 29, 29, 35, 29, 14, -3, -1, 1, 1, 0, -2, 0, 1, 0, -9, -17, -20, -18, -11, -15, -14, -26, -15, -14, 0, -14, -24, -23, -24, -11, -14, -13, -15, -12, -18, -10, -9, -14, -10, -10, -10, -5, -9, -5, 2, 23, 26, 40, 49, 44, 45, 44, 33, 19, 21, 24, 28, 28, 29, 29, 35, 29, 14, -3, -1, 1, 1, 0, -2, 0, 1, 0, -9, -6, -6, -8, 0, -1, 0, -2, -2, -5, -3, -4, -9, -1, 0, 3, 10, -7, 15, 14, 16, 12, 1, 20, 18, 5, 1, 10, 17, 9, -12, -11, -16, -7, -8, -7, -9, -13, 4, -3, -3, -6, 10, -1, -1, -6, -6, -8, 0, -1, 0, -2, -2, -5, -3, -4, -9, -1, 0, 3, 10, -7, 15, 14, 16, 12, 1, 20, 18, 5, 1, 10, 17, 9, -12, -11, -16, -7, -8, -7, -9, -13, 4, -3, -3, -6, 10, -1, -1, 15, 6, 7, 12, 18, 13, 13, 15, 12, 13, 15, 14, 14, 17, 17, 24, 21, 25, 31, 22, 19, 14, 10, 7, -2, -4, -3, 9, -12, 36, 36, 32, 37, 44, 34, 34, 40, 33, 35, 33, 38, 33, 23, 13, 15, 6, 7, 12, 18, 13, 13, 15, 12, 13, 15, 14, 14, 17, 17, 24, 21, 25, 31, 22, 19, 14, 10, 7, -2, -4, -3, 9, -12, 36, 36, 32, 37, 44, 34, 34, 40, 33, 35, 33, 38, 33, 23, 13, -3, -6, -5, -3, -2, 0, 1, -2, -1, -9, -5, -5, -3, -2, 0, -16, -8, -10, -6, -10, -12, -15, -10, -6, -4, -12, -8, -7, -9, -17, -3, -6, -5, -3, -2, 0, 1, -2, -1, -9, -5, -5, -3, -2, 0, -16, -8, -10, -6, -10, -12, -15, -10, -6, -4, -12, -8, -7, -9, -17, -3, -8, -10, -30, -3, -8, -10, -30, -3, -8, -10, -30]);
    constructor.cabac_context_init_I_B = new Int32Array([-15, 54, 74, -15, 54, 74, 127, 104, 53, 54, 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 63, 63, 63, 83, 86, 97, 72, 41, 62, 11, 55, 69, 127, 102, 82, 74, 107, 127, 127, 127, 95, 127, 114, 127, 123, 115, 122, 115, 63, 68, 84, 104, 70, 93, 90, 127, 74, 97, 91, 127, 56, 82, 76, 125, 93, 87, 77, 71, 63, 68, 84, 62, 65, 61, 56, 66, 64, 61, 78, 50, 52, 35, 44, 38, 45, 46, 44, 17, 51, 50, 19, 33, 62, 108, 100, 101, 91, 94, 88, 84, 86, 83, 87, 94, 70, 72, 74, 59, 102, 100, 95, 75, 72, 75, 71, 46, 69, 62, 65, 37, 72, 57, 54, 62, 72, 0, 9, 25, 18, 9, 19, 37, 18, 29, 33, 30, 45, 58, 62, 61, 38, 45, 39, 42, 44, 45, 41, 49, 34, 42, 55, 51, 46, 89, -19, -17, -17, -25, -20, -23, -27, -23, -28, -17, -11, -15, -6, 1, 17, -6, 3, 22, -16, -4, -8, -3, 3, 5, 0, 16, 22, 48, 37, 60, 68, 97, 71, 42, 50, 54, 62, 58, 63, 72, 74, 91, 67, 27, 39, 44, 46, 64, 68, 78, 77, 86, 92, 55, 60, 62, 65, 73, 76, 80, 88, 110, 97, 84, 79, 73, 74, 86, 96, 97, 117, 78, 33, 48, 53, 62, 71, 79, 86, 90, 97, 0, 93, 84, 79, 66, 71, 62, 60, 59, 75, 62, 58, 66, 79, 71, 68, 44, 62, 36, 40, 27, 29, 44, 36, 32, 42, 48, 62, 46, 64, 104, 97, 96, 88, 85, 85, 85, 88, 66, 77, 76, 76, 58, 76, 83, 99, 95, 95, 76, 74, 70, 75, 68, 65, 73, 62, 62, 68, 75, 55, 64, 70, 6, 19, 16, 14, 13, 11, 15, 16, 23, 23, 20, 26, 44, 40, 47, 17, 21, 22, 27, 29, 35, 50, 57, 63, 77, 82, 94, 69, 109, -35, -34, -26, -30, -32, -18, -15, -15, -7, -5, 0, 2, 13, 35, 58, -3, 0, 30, -7, -15, -3, 3, -1, 5, 11, 5, 12, 11, 29, 26, 39, 66, 21, 31, 50, 120, 112, 114, 85, 92, 89, 71, 81, 80, 68, 70, 56, 68, 50, 74, -13, -13, -15, -14, 3, 6, 34, 54, 82, 75, 23, 34, 43, 54, 55, 61, 64, 68, 92, 106, 97, 90, 90, 88, 73, 79, 86, 73, 70, 69, 66, 64, 58, 59, -10, -11, -8, -1, 3, 9, 20, 36, 67, 123, 115, 122, 115, 63, 68, 84, 104, 70, 93, 90, 127, 123, 115, 122, 115, 63, 68, 84, 104, 70, 93, 90, 127, 93, 87, 77, 71, 63, 68, 84, 62, 65, 61, 56, 66, 64, 61, 78, 50, 52, 35, 44, 38, 45, 46, 44, 17, 51, 50, 19, 33, 62, 108, 100, 101, 91, 94, 88, 84, 86, 83, 87, 94, 70, 72, 74, 59, 93, 87, 77, 71, 63, 68, 84, 62, 65, 61, 56, 66, 64, 61, 78, 50, 52, 35, 44, 38, 45, 46, 44, 17, 51, 50, 19, 33, 62, 108, 100, 101, 91, 94, 88, 84, 86, 83, 87, 94, 70, 72, 74, 59, 0, 9, 25, 18, 9, 19, 37, 18, 29, 33, 30, 45, 58, 62, 61, 38, 45, 39, 42, 44, 45, 41, 49, 34, 42, 55, 51, 46, 89, -19, -17, -17, -25, -20, -23, -27, -23, -28, -17, -11, -15, -6, 1, 17, 0, 9, 25, 18, 9, 19, 37, 18, 29, 33, 30, 45, 58, 62, 61, 38, 45, 39, 42, 44, 45, 41, 49, 34, 42, 55, 51, 46, 89, -19, -17, -17, -25, -20, -23, -27, -23, -28, -17, -11, -15, -6, 1, 17, 120, 112, 114, 85, 92, 89, 71, 81, 80, 68, 70, 56, 68, 50, 74, 106, 97, 90, 90, 88, 73, 79, 86, 73, 70, 69, 66, 64, 58, 59, -13, -13, -15, -14, 3, 6, 34, 54, 82, -10, -11, -8, -1, 3, 9, 20, 36, 67, 75, 23, 34, 43, 54, 55, 61, 64, 68, 92, 120, 112, 114, 85, 92, 89, 71, 81, 80, 68, 70, 56, 68, 50, 74, 106, 97, 90, 90, 88, 73, 79, 86, 73, 70, 69, 66, 64, 58, 59, -13, -13, -15, -14, 3, 6, 34, 54, 82, -10, -11, -8, -1, 3, 9, 20, 36, 67, 75, 23, 34, 43, 54, 55, 61, 64, 68, 92, 93, 84, 79, 66, 71, 62, 60, 59, 75, 62, 58, 66, 79, 71, 68, 44, 62, 36, 40, 27, 29, 44, 36, 32, 42, 48, 62, 46, 64, 104, 97, 96, 88, 85, 85, 85, 88, 66, 77, 76, 76, 58, 76, 83, 93, 84, 79, 66, 71, 62, 60, 59, 75, 62, 58, 66, 79, 71, 68, 44, 62, 36, 40, 27, 29, 44, 36, 32, 42, 48, 62, 46, 64, 104, 97, 96, 88, 85, 85, 85, 88, 66, 77, 76, 76, 58, 76, 83, 6, 19, 16, 14, 13, 11, 15, 16, 23, 23, 20, 26, 44, 40, 47, 17, 21, 22, 27, 29, 35, 50, 57, 63, 77, 82, 94, 69, 109, -35, -34, -26, -30, -32, -18, -15, -15, -7, -5, 0, 2, 13, 35, 58, 6, 19, 16, 14, 13, 11, 15, 16, 23, 23, 20, 26, 44, 40, 47, 17, 21, 22, 27, 29, 35, 50, 57, 63, 77, 82, 94, 69, 109, -35, -34, -26, -30, -32, -18, -15, -15, -7, -5, 0, 2, 13, 35, 58, 71, 42, 50, 54, 62, 58, 63, 72, 74, 91, 67, 27, 39, 44, 46, 64, 68, 78, 77, 86, 92, 55, 60, 62, 65, 73, 76, 80, 88, 110, 71, 42, 50, 54, 62, 58, 63, 72, 74, 91, 67, 27, 39, 44, 46, 64, 68, 78, 77, 86, 92, 55, 60, 62, 65, 73, 76, 80, 88, 110, 70, 93, 90, 127, 70, 93, 90, 127, 70, 93, 90, 127]);
    constructor.cabac_context_init_PB_A = [new Int32Array([20, 2, 3, 20, 2, 3, -28, -23, -6, -1, 7, 23, 23, 21, 1, 0, -37, 5, -13, -11, 1, 12, -4, 17, 18, 9, 29, 26, 16, 9, -46, -20, 1, -13, -11, 1, -6, -17, -6, 9, -3, -6, -11, 6, 7, -5, 2, 0, -3, -10, 5, 4, -3, 0, -7, -5, -4, -5, -7, 1, 0, 0, 0, 0, -9, 4, 0, -7, 13, 3, 0, -4, -3, -27, -28, -25, -23, -28, -20, -16, -22, -21, -18, -13, -29, -7, -5, -7, -13, -3, -1, -1, -9, -3, -9, -8, -23, 5, 6, 6, 6, -1, 0, -4, -8, -2, -6, -1, -7, 2, 5, -3, 1, 6, -4, 1, -4, 0, 2, -2, 11, 4, 1, 11, 18, 12, 13, 13, -10, -7, -2, 13, 9, -7, 9, 2, 5, -2, 0, 0, -13, -5, -1, 4, -6, 4, 14, 4, 13, 3, 1, 9, 7, 16, 5, 4, 11, -5, -1, 0, 22, 5, 14, -1, 0, 9, 11, 2, 3, 0, 0, 2, 2, 0, 4, 2, 6, 0, 3, 2, 4, 6, 6, 7, 6, 6, 11, 14, 8, -1, 7, -3, 15, 22, -1, 25, 30, 28, 28, 32, 34, 30, 30, 32, 31, 26, 26, 37, 28, 17, 1, 5, 9, 16, 18, 18, 22, 24, 23, 18, 20, 11, 9, 9, -1, -2, -9, -6, -2, 0, 0, -3, -2, -4, -4, -8, -17, -9, 3, 0, 0, 0, -6, -7, -12, -11, -30, 1, -3, -1, 1, 2, -6, 0, 0, -3, -10, 0, -4, 5, 7, 1, -2, -3, -3, -11, 0, 8, 10, 14, 13, 2, 0, -3, -6, -8, 0, -13, -16, -10, -21, -18, -14, -22, -21, -18, -21, -23, -26, -10, -12, -5, -9, -22, -5, 9, -4, -10, -1, 7, 9, 5, 12, 15, 18, 17, 10, 7, -1, 7, 8, 9, 6, 2, 13, 10, 6, 5, 13, 4, 6, -2, -2, 6, 10, 9, 12, 3, 14, 10, -3, 13, 17, 7, 7, 13, 10, 26, 14, 11, 9, 18, 21, 23, 32, 32, 34, 39, 42, 41, 46, 38, 21, 45, 53, 48, 65, 43, 39, 30, 18, 20, 0, -14, -5, -19, -35, 27, 28, 31, 27, 34, 30, 24, 33, 22, 26, 21, 26, 23, 16, 14, 8, 6, 17, 21, 23, 26, 27, 28, 28, 23, 24, 28, 23, 19, 22, 22, 11, 12, 11, 14, -4, -7, -5, -9, -8, -10, -19, -12, -16, -15, -20, -19, -16, -22, -20, 9, 26, 33, 39, 41, 45, 49, 45, 36, -6, -7, -7, -8, -5, -12, -6, -5, -8, -8, -5, -6, -10, -7, -17, -18, -4, -10, -9, -9, -1, -8, -14, 0, 2, 21, 33, 39, 46, 51, 60, 61, 55, 42, -7, -5, -7, -13, -3, -1, -1, -9, -3, -9, -8, -23, -7, -5, -7, -13, -3, -1, -1, -9, -3, -9, -8, -23, -2, -6, -1, -7, 2, 5, -3, 1, 6, -4, 1, -4, 0, 2, -2, 11, 4, 1, 11, 18, 12, 13, 13, -10, -7, -2, 13, 9, -7, 9, 2, 5, -2, 0, 0, -13, -5, -1, 4, -6, 4, 14, 4, 13, -2, -6, -1, -7, 2, 5, -3, 1, 6, -4, 1, -4, 0, 2, -2, 11, 4, 1, 11, 18, 12, 13, 13, -10, -7, -2, 13, 9, -7, 9, 2, 5, -2, 0, 0, -13, -5, -1, 4, -6, 4, 14, 4, 13, 11, 2, 3, 0, 0, 2, 2, 0, 4, 2, 6, 0, 3, 2, 4, 6, 6, 7, 6, 6, 11, 14, 8, -1, 7, -3, 15, 22, -1, 25, 30, 28, 28, 32, 34, 30, 30, 32, 31, 26, 26, 37, 28, 17, 11, 2, 3, 0, 0, 2, 2, 0, 4, 2, 6, 0, 3, 2, 4, 6, 6, 7, 6, 6, 11, 14, 8, -1, 7, -3, 15, 22, -1, 25, 30, 28, 28, 32, 34, 30, 30, 32, 31, 26, 26, 37, 28, 17, -4, -7, -5, -9, -8, -10, -19, -12, -16, -15, -20, -19, -16, -22, -20, -5, -6, -10, -7, -17, -18, -4, -10, -9, -9, -1, -8, -14, 0, 2, 9, 26, 33, 39, 41, 45, 49, 45, 36, 21, 33, 39, 46, 51, 60, 61, 55, 42, -6, -7, -7, -8, -5, -12, -6, -5, -8, -8, -4, -7, -5, -9, -8, -10, -19, -12, -16, -15, -20, -19, -16, -22, -20, -5, -6, -10, -7, -17, -18, -4, -10, -9, -9, -1, -8, -14, 0, 2, 9, 26, 33, 39, 41, 45, 49, 45, 36, 21, 33, 39, 46, 51, 60, 61, 55, 42, -6, -7, -7, -8, -5, -12, -6, -5, -8, -8, -13, -16, -10, -21, -18, -14, -22, -21, -18, -21, -23, -26, -10, -12, -5, -9, -22, -5, 9, -4, -10, -1, 7, 9, 5, 12, 15, 18, 17, 10, 7, -1, 7, 8, 9, 6, 2, 13, 10, 6, 5, 13, 4, 6, -13, -16, -10, -21, -18, -14, -22, -21, -18, -21, -23, -26, -10, -12, -5, -9, -22, -5, 9, -4, -10, -1, 7, 9, 5, 12, 15, 18, 17, 10, 7, -1, 7, 8, 9, 6, 2, 13, 10, 6, 5, 13, 4, 6, 14, 11, 9, 18, 21, 23, 32, 32, 34, 39, 42, 41, 46, 38, 21, 45, 53, 48, 65, 43, 39, 30, 18, 20, 0, -14, -5, -19, -35, 27, 28, 31, 27, 34, 30, 24, 33, 22, 26, 21, 26, 23, 16, 14, 14, 11, 9, 18, 21, 23, 32, 32, 34, 39, 42, 41, 46, 38, 21, 45, 53, 48, 65, 43, 39, 30, 18, 20, 0, -14, -5, -19, -35, 27, 28, 31, 27, 34, 30, 24, 33, 22, 26, 21, 26, 23, 16, 14, -6, -2, 0, 0, -3, -2, -4, -4, -8, -17, -9, 3, 0, 0, 0, -6, -7, -12, -11, -30, 1, -3, -1, 1, 2, -6, 0, 0, -3, -10, -6, -2, 0, 0, -3, -2, -4, -4, -8, -17, -9, 3, 0, 0, 0, -6, -7, -12, -11, -30, 1, -3, -1, 1, 2, -6, 0, 0, -3, -10, -3, -9, -8, -23, -3, -9, -8, -23, -3, -9, -8, -23]), new Int32Array([20, 2, 3, 20, 2, 3, -28, -23, -6, -1, 7, 22, 34, 16, -2, 4, -29, 2, -6, -13, 5, 9, -3, 10, 26, 19, 40, 57, 41, 26, -45, -15, -4, -6, -13, 5, 6, -13, 0, 8, -2, -5, -10, 2, 2, -3, -3, 1, -3, -6, 0, -3, -7, -5, -1, -1, 1, -2, -5, 0, 0, 0, 0, 0, -9, 4, 0, -7, 13, 3, 13, 7, 2, -39, -18, -17, -26, -35, -24, -23, -27, -24, -21, -18, -36, 0, -5, -7, -4, 0, 0, -15, -35, -2, -12, -9, -31, 3, 7, 7, 8, -3, 0, -7, -9, -13, -13, -9, -14, -8, -12, -23, -24, -10, -20, -17, -78, -70, -50, -46, -4, -5, -4, -8, 2, -1, -7, -6, -8, -34, -3, 32, 30, -44, 0, -5, 0, -1, -3, -8, -25, -14, -5, 5, 2, 0, -9, -11, 18, -4, 0, 7, 9, 18, 9, 5, 9, 0, 0, 2, 19, -4, 15, 12, 9, 0, 4, 10, 10, 33, 52, 18, 28, 35, 38, 34, 39, 32, 102, 0, 56, 33, 29, 37, 51, 39, 52, 69, 67, 44, 32, 55, 32, 0, 27, 33, 34, 36, 38, 38, 34, 35, 34, 32, 37, 35, 30, 28, 26, 29, 0, 2, 8, 14, 18, 17, 21, 17, 20, 18, 27, 16, 7, 16, 11, 10, -10, -23, -15, -7, 0, -5, -11, -9, -9, -10, -34, -21, -3, -5, -7, -11, -15, -17, -25, -25, -28, -11, -10, -10, -10, -9, -16, -7, -4, -5, -9, 2, -9, 1, 11, 5, -2, -2, 0, -8, 3, 7, 10, 17, 16, 3, -1, -5, -1, -4, 0, -21, -23, -20, -26, -25, -17, -27, -27, -17, -26, -27, -33, -10, -14, -8, -17, -28, -6, -2, -4, -9, -8, -1, 5, 1, 9, 0, 1, 7, -7, -6, -16, -2, 2, -6, -3, 2, -3, -3, 0, 9, -1, -2, -2, -1, -9, 14, 16, 0, 18, 11, 12, 10, 2, 12, 13, 0, 3, 19, 3, 18, 19, 18, 14, 26, 31, 33, 33, 37, 39, 42, 47, 45, 49, 41, 32, 69, 63, 66, 77, 54, 52, 41, 36, 40, 30, 28, 23, 12, 11, 37, 39, 40, 38, 46, 42, 40, 49, 38, 40, 38, 46, 31, 29, 25, 12, 11, 26, 22, 23, 27, 33, 26, 30, 27, 18, 25, 18, 12, 21, 14, 11, 25, 21, 21, -5, -6, -10, -7, -17, -18, -4, -10, -9, -9, -1, -8, -14, 0, 2, 17, 32, 42, 49, 53, 64, 68, 66, 47, -5, 0, -1, -2, -2, -9, -6, -4, -4, -7, -3, -3, -7, -6, -12, -14, -3, -6, -5, -5, 0, -4, -9, 1, 2, 17, 32, 42, 49, 53, 64, 68, 66, 47, 0, -5, -7, -4, 0, 0, -15, -35, -2, -12, -9, -31, 0, -5, -7, -4, 0, 0, -15, -35, -2, -12, -9, -31, -13, -13, -9, -14, -8, -12, -23, -24, -10, -20, -17, -78, -70, -50, -46, -4, -5, -4, -8, 2, -1, -7, -6, -8, -34, -3, 32, 30, -44, 0, -5, 0, -1, -3, -8, -25, -14, -5, 5, 2, 0, -9, -11, 18, -13, -13, -9, -14, -8, -12, -23, -24, -10, -20, -17, -78, -70, -50, -46, -4, -5, -4, -8, 2, -1, -7, -6, -8, -34, -3, 32, 30, -44, 0, -5, 0, -1, -3, -8, -25, -14, -5, 5, 2, 0, -9, -11, 18, 4, 10, 10, 33, 52, 18, 28, 35, 38, 34, 39, 32, 102, 0, 56, 33, 29, 37, 51, 39, 52, 69, 67, 44, 32, 55, 32, 0, 27, 33, 34, 36, 38, 38, 34, 35, 34, 32, 37, 35, 30, 28, 26, 29, 4, 10, 10, 33, 52, 18, 28, 35, 38, 34, 39, 32, 102, 0, 56, 33, 29, 37, 51, 39, 52, 69, 67, 44, 32, 55, 32, 0, 27, 33, 34, 36, 38, 38, 34, 35, 34, 32, 37, 35, 30, 28, 26, 29, -5, -6, -10, -7, -17, -18, -4, -10, -9, -9, -1, -8, -14, 0, 2, -3, -3, -7, -6, -12, -14, -3, -6, -5, -5, 0, -4, -9, 1, 2, 17, 32, 42, 49, 53, 64, 68, 66, 47, 17, 32, 42, 49, 53, 64, 68, 66, 47, -5, 0, -1, -2, -2, -9, -6, -4, -4, -7, -5, -6, -10, -7, -17, -18, -4, -10, -9, -9, -1, -8, -14, 0, 2, -3, -3, -7, -6, -12, -14, -3, -6, -5, -5, 0, -4, -9, 1, 2, 17, 32, 42, 49, 53, 64, 68, 66, 47, 17, 32, 42, 49, 53, 64, 68, 66, 47, -5, 0, -1, -2, -2, -9, -6, -4, -4, -7, -21, -23, -20, -26, -25, -17, -27, -27, -17, -26, -27, -33, -10, -14, -8, -17, -28, -6, -2, -4, -9, -8, -1, 5, 1, 9, 0, 1, 7, -7, -6, -16, -2, 2, -6, -3, 2, -3, -3, 0, 9, -1, -2, -2, -21, -23, -20, -26, -25, -17, -27, -27, -17, -26, -27, -33, -10, -14, -8, -17, -28, -6, -2, -4, -9, -8, -1, 5, 1, 9, 0, 1, 7, -7, -6, -16, -2, 2, -6, -3, 2, -3, -3, 0, 9, -1, -2, -2, 19, 18, 14, 26, 31, 33, 33, 37, 39, 42, 47, 45, 49, 41, 32, 69, 63, 66, 77, 54, 52, 41, 36, 40, 30, 28, 23, 12, 11, 37, 39, 40, 38, 46, 42, 40, 49, 38, 40, 38, 46, 31, 29, 25, 19, 18, 14, 26, 31, 33, 33, 37, 39, 42, 47, 45, 49, 41, 32, 69, 63, 66, 77, 54, 52, 41, 36, 40, 30, 28, 23, 12, 11, 37, 39, 40, 38, 46, 42, 40, 49, 38, 40, 38, 46, 31, 29, 25, -23, -15, -7, 0, -5, -11, -9, -9, -10, -34, -21, -3, -5, -7, -11, -15, -17, -25, -25, -28, -11, -10, -10, -10, -9, -16, -7, -4, -5, -9, -23, -15, -7, 0, -5, -11, -9, -9, -10, -34, -21, -3, -5, -7, -11, -15, -17, -25, -25, -28, -11, -10, -10, -10, -9, -16, -7, -4, -5, -9, -2, -12, -9, -31, -2, -12, -9, -31, -2, -12, -9, -31]), new Int32Array([20, 2, 3, 20, 2, 3, -28, -23, -6, -1, 7, 29, 25, 14, -10, -3, -27, 26, -4, -24, 5, 6, -17, 14, 20, 20, 29, 54, 37, 12, -32, -22, -2, -4, -24, 5, -6, -14, -6, 4, -11, -15, -21, 19, 20, 4, 6, 1, -5, -13, 5, 6, -3, -1, 3, -4, -2, -12, -7, 1, 0, 0, 0, 0, -9, 4, 0, -7, 13, 3, 7, -9, -20, -36, -17, -14, -25, -25, -12, -17, -31, -14, -18, -13, -37, 11, 5, 2, 5, -6, 4, -14, -37, -5, -11, -11, -30, 0, -2, 0, -4, -6, 3, -8, -13, -4, -12, -5, -3, -4, -8, -16, -9, -1, 5, 4, -4, -2, 2, -1, -4, -1, 0, -7, -4, -6, -3, -6, 8, -9, -11, 9, 0, -5, 1, -15, -5, -8, -21, -21, -13, -25, -29, 9, 17, -8, -5, -2, 13, 3, -7, 8, -10, 3, -3, -20, 0, 1, -3, -21, 16, -23, 17, 44, 50, -22, 4, 0, 7, 11, 8, 6, 7, 3, 8, 13, 13, 4, 3, 2, 6, 8, 11, 14, 7, 4, 4, 13, 9, 19, 10, 12, 0, 20, 8, 35, 33, 28, 24, 27, 34, 52, 39, 19, 31, 36, 24, 34, 30, 22, 20, 19, 27, 19, 15, 15, 21, 25, 30, 31, 27, 24, 0, 14, 15, 26, -24, -24, -22, -9, 0, 0, -14, -13, -13, -11, -29, -21, -14, -12, -11, -10, -21, -16, -23, -15, -37, -10, -8, -8, -8, -7, -14, -10, -9, -12, -18, -4, -22, -16, -2, 1, -13, -9, -4, -13, -13, -6, -13, -6, -2, -16, -10, -13, -9, -10, 0, -22, -25, -25, -27, -19, -23, -25, -26, -24, -28, -31, -37, -10, -15, -10, -13, -50, -5, 17, -5, -13, -12, -2, 0, -1, 4, -7, 5, 15, 1, 0, -10, 1, 0, 2, 0, -5, 7, 5, 2, 14, 15, 5, 2, -2, -18, 12, 5, -12, 11, 5, 0, 2, -6, 5, 7, -6, -11, -2, -2, 25, 17, 16, 17, 27, 37, 41, 42, 48, 39, 46, 52, 46, 52, 43, 32, 61, 56, 62, 81, 45, 35, 28, 34, 39, 30, 20, 18, 15, 0, 36, 37, 37, 32, 34, 29, 24, 34, 31, 35, 31, 33, 36, 27, 21, 18, 19, 36, 24, 27, 24, 31, 22, 22, 16, 15, 14, 3, -16, 21, 22, 25, 21, 19, 17, -3, -8, -9, -10, -18, -12, -11, -5, -17, -14, -16, -8, -14, -9, -11, 9, 30, 31, 33, 33, 31, 37, 31, 20, -9, -7, -8, -11, -10, -12, -8, -9, -6, -10, -3, -8, -9, -10, -18, -12, -11, -5, -17, -14, -16, -8, -14, -9, -11, 9, 30, 31, 33, 33, 31, 37, 31, 20, 11, 5, 2, 5, -6, 4, -14, -37, -5, -11, -11, -30, 11, 5, 2, 5, -6, 4, -14, -37, -5, -11, -11, -30, -4, -12, -5, -3, -4, -8, -16, -9, -1, 5, 4, -4, -2, 2, -1, -4, -1, 0, -7, -4, -6, -3, -6, 8, -9, -11, 9, 0, -5, 1, -15, -5, -8, -21, -21, -13, -25, -29, 9, 17, -8, -5, -2, 13, -4, -12, -5, -3, -4, -8, -16, -9, -1, 5, 4, -4, -2, 2, -1, -4, -1, 0, -7, -4, -6, -3, -6, 8, -9, -11, 9, 0, -5, 1, -15, -5, -8, -21, -21, -13, -25, -29, 9, 17, -8, -5, -2, 13, 4, 0, 7, 11, 8, 6, 7, 3, 8, 13, 13, 4, 3, 2, 6, 8, 11, 14, 7, 4, 4, 13, 9, 19, 10, 12, 0, 20, 8, 35, 33, 28, 24, 27, 34, 52, 39, 19, 31, 36, 24, 34, 30, 22, 4, 0, 7, 11, 8, 6, 7, 3, 8, 13, 13, 4, 3, 2, 6, 8, 11, 14, 7, 4, 4, 13, 9, 19, 10, 12, 0, 20, 8, 35, 33, 28, 24, 27, 34, 52, 39, 19, 31, 36, 24, 34, 30, 22, -3, -8, -9, -10, -18, -12, -11, -5, -17, -14, -16, -8, -14, -9, -11, -3, -8, -9, -10, -18, -12, -11, -5, -17, -14, -16, -8, -14, -9, -11, 9, 30, 31, 33, 33, 31, 37, 31, 20, 9, 30, 31, 33, 33, 31, 37, 31, 20, -9, -7, -8, -11, -10, -12, -8, -9, -6, -10, -3, -8, -9, -10, -18, -12, -11, -5, -17, -14, -16, -8, -14, -9, -11, -3, -8, -9, -10, -18, -12, -11, -5, -17, -14, -16, -8, -14, -9, -11, 9, 30, 31, 33, 33, 31, 37, 31, 20, 9, 30, 31, 33, 33, 31, 37, 31, 20, -9, -7, -8, -11, -10, -12, -8, -9, -6, -10, -22, -25, -25, -27, -19, -23, -25, -26, -24, -28, -31, -37, -10, -15, -10, -13, -50, -5, 17, -5, -13, -12, -2, 0, -1, 4, -7, 5, 15, 1, 0, -10, 1, 0, 2, 0, -5, 7, 5, 2, 14, 15, 5, 2, -22, -25, -25, -27, -19, -23, -25, -26, -24, -28, -31, -37, -10, -15, -10, -13, -50, -5, 17, -5, -13, -12, -2, 0, -1, 4, -7, 5, 15, 1, 0, -10, 1, 0, 2, 0, -5, 7, 5, 2, 14, 15, 5, 2, 17, 16, 17, 27, 37, 41, 42, 48, 39, 46, 52, 46, 52, 43, 32, 61, 56, 62, 81, 45, 35, 28, 34, 39, 30, 20, 18, 15, 0, 36, 37, 37, 32, 34, 29, 24, 34, 31, 35, 31, 33, 36, 27, 21, 17, 16, 17, 27, 37, 41, 42, 48, 39, 46, 52, 46, 52, 43, 32, 61, 56, 62, 81, 45, 35, 28, 34, 39, 30, 20, 18, 15, 0, 36, 37, 37, 32, 34, 29, 24, 34, 31, 35, 31, 33, 36, 27, 21, -24, -22, -9, 0, 0, -14, -13, -13, -11, -29, -21, -14, -12, -11, -10, -21, -16, -23, -15, -37, -10, -8, -8, -8, -7, -14, -10, -9, -12, -18, -24, -22, -9, 0, 0, -14, -13, -13, -11, -29, -21, -14, -12, -11, -10, -21, -16, -23, -15, -37, -10, -8, -8, -8, -7, -14, -10, -9, -12, -18, -5, -11, -11, -30, -5, -11, -11, -30, -5, -11, -11, -30])];
    constructor.cabac_context_init_PB_B = [new Int32Array([-15, 54, 74, -15, 54, 74, 127, 104, 53, 54, 51, 33, 2, 0, 9, 49, 118, 57, 78, 65, 62, 49, 73, 50, 64, 43, 0, 67, 90, 104, 127, 104, 67, 78, 65, 62, 86, 95, 61, 45, 69, 81, 96, 55, 67, 86, 88, 58, 76, 94, 54, 69, 81, 88, 67, 74, 74, 80, 72, 58, 41, 63, 63, 63, 83, 86, 97, 72, 41, 62, 45, 78, 96, 126, 98, 101, 67, 82, 94, 83, 110, 91, 102, 93, 127, 92, 89, 96, 108, 46, 65, 57, 93, 74, 92, 87, 126, 54, 60, 59, 69, 48, 68, 69, 88, 85, 78, 75, 77, 54, 50, 68, 50, 42, 81, 63, 70, 67, 57, 76, 35, 64, 61, 35, 25, 24, 29, 36, 93, 73, 73, 46, 49, 100, 53, 53, 53, 61, 56, 56, 63, 60, 62, 57, 69, 57, 39, 51, 68, 64, 61, 63, 50, 39, 44, 52, 48, 60, 59, 59, 33, 44, 43, 78, 60, 69, 28, 40, 44, 49, 46, 44, 51, 47, 39, 62, 46, 54, 54, 58, 63, 51, 57, 53, 52, 55, 45, 36, 53, 82, 55, 78, 46, 31, 84, 7, -7, 3, 4, 0, -1, 6, 6, 9, 19, 27, 30, 20, 34, 70, 67, 59, 67, 30, 32, 35, 29, 31, 38, 43, 41, 63, 59, 64, 94, 89, 108, 76, 44, 45, 52, 64, 59, 70, 75, 82, 102, 77, 24, 42, 48, 55, 59, 71, 83, 87, 119, 58, 29, 36, 38, 43, 55, 58, 64, 74, 90, 70, 29, 31, 42, 59, 58, 72, 81, 97, 58, 5, 14, 18, 27, 40, 58, 70, 79, 85, 0, 106, 106, 87, 114, 110, 98, 110, 106, 103, 107, 108, 112, 96, 95, 91, 93, 94, 86, 67, 80, 85, 70, 60, 58, 61, 50, 50, 49, 54, 41, 46, 51, 49, 52, 41, 47, 55, 41, 44, 50, 53, 49, 63, 64, 69, 59, 70, 44, 31, 43, 53, 34, 38, 52, 40, 32, 44, 38, 50, 57, 43, 11, 14, 11, 11, 9, -2, -15, -15, -21, -23, -33, -31, -28, -12, 29, -24, -45, -26, -43, -19, -10, 9, 26, 27, 57, 82, 75, 97, 125, 0, 0, -4, 6, 8, 10, 22, 19, 32, 31, 41, 44, 47, 65, 71, 60, 63, 65, 24, 20, 23, 32, 23, 24, 40, 32, 29, 42, 57, 53, 61, 86, 40, 51, 59, 79, 71, 69, 70, 66, 68, 73, 69, 70, 67, 62, 70, 66, 65, 63, -2, -9, -9, -7, -2, 3, 9, 27, 59, 66, 35, 42, 45, 48, 56, 60, 62, 66, 76, 85, 81, 77, 81, 80, 73, 74, 83, 71, 67, 61, 66, 66, 59, 59, -13, -14, -7, -2, 2, 6, 17, 34, 62, 92, 89, 96, 108, 46, 65, 57, 93, 74, 92, 87, 126, 92, 89, 96, 108, 46, 65, 57, 93, 74, 92, 87, 126, 85, 78, 75, 77, 54, 50, 68, 50, 42, 81, 63, 70, 67, 57, 76, 35, 64, 61, 35, 25, 24, 29, 36, 93, 73, 73, 46, 49, 100, 53, 53, 53, 61, 56, 56, 63, 60, 62, 57, 69, 57, 39, 51, 68, 85, 78, 75, 77, 54, 50, 68, 50, 42, 81, 63, 70, 67, 57, 76, 35, 64, 61, 35, 25, 24, 29, 36, 93, 73, 73, 46, 49, 100, 53, 53, 53, 61, 56, 56, 63, 60, 62, 57, 69, 57, 39, 51, 68, 28, 40, 44, 49, 46, 44, 51, 47, 39, 62, 46, 54, 54, 58, 63, 51, 57, 53, 52, 55, 45, 36, 53, 82, 55, 78, 46, 31, 84, 7, -7, 3, 4, 0, -1, 6, 6, 9, 19, 27, 30, 20, 34, 70, 28, 40, 44, 49, 46, 44, 51, 47, 39, 62, 46, 54, 54, 58, 63, 51, 57, 53, 52, 55, 45, 36, 53, 82, 55, 78, 46, 31, 84, 7, -7, 3, 4, 0, -1, 6, 6, 9, 19, 27, 30, 20, 34, 70, 79, 71, 69, 70, 66, 68, 73, 69, 70, 67, 62, 70, 66, 65, 63, 85, 81, 77, 81, 80, 73, 74, 83, 71, 67, 61, 66, 66, 59, 59, -2, -9, -9, -7, -2, 3, 9, 27, 59, -13, -14, -7, -2, 2, 6, 17, 34, 62, 66, 35, 42, 45, 48, 56, 60, 62, 66, 76, 79, 71, 69, 70, 66, 68, 73, 69, 70, 67, 62, 70, 66, 65, 63, 85, 81, 77, 81, 80, 73, 74, 83, 71, 67, 61, 66, 66, 59, 59, -2, -9, -9, -7, -2, 3, 9, 27, 59, -13, -14, -7, -2, 2, 6, 17, 34, 62, 66, 35, 42, 45, 48, 56, 60, 62, 66, 76, 106, 106, 87, 114, 110, 98, 110, 106, 103, 107, 108, 112, 96, 95, 91, 93, 94, 86, 67, 80, 85, 70, 60, 58, 61, 50, 50, 49, 54, 41, 46, 51, 49, 52, 41, 47, 55, 41, 44, 50, 53, 49, 63, 64, 106, 106, 87, 114, 110, 98, 110, 106, 103, 107, 108, 112, 96, 95, 91, 93, 94, 86, 67, 80, 85, 70, 60, 58, 61, 50, 50, 49, 54, 41, 46, 51, 49, 52, 41, 47, 55, 41, 44, 50, 53, 49, 63, 64, 11, 14, 11, 11, 9, -2, -15, -15, -21, -23, -33, -31, -28, -12, 29, -24, -45, -26, -43, -19, -10, 9, 26, 27, 57, 82, 75, 97, 125, 0, 0, -4, 6, 8, 10, 22, 19, 32, 31, 41, 44, 47, 65, 71, 11, 14, 11, 11, 9, -2, -15, -15, -21, -23, -33, -31, -28, -12, 29, -24, -45, -26, -43, -19, -10, 9, 26, 27, 57, 82, 75, 97, 125, 0, 0, -4, 6, 8, 10, 22, 19, 32, 31, 41, 44, 47, 65, 71, 76, 44, 45, 52, 64, 59, 70, 75, 82, 102, 77, 24, 42, 48, 55, 59, 71, 83, 87, 119, 58, 29, 36, 38, 43, 55, 58, 64, 74, 90, 76, 44, 45, 52, 64, 59, 70, 75, 82, 102, 77, 24, 42, 48, 55, 59, 71, 83, 87, 119, 58, 29, 36, 38, 43, 55, 58, 64, 74, 90, 74, 92, 87, 126, 74, 92, 87, 126, 74, 92, 87, 126]), new Int32Array([-15, 54, 74, -15, 54, 74, 127, 104, 53, 54, 51, 25, 0, 0, 9, 41, 118, 65, 71, 79, 52, 50, 70, 54, 34, 22, 0, 2, 36, 69, 127, 101, 76, 71, 79, 52, 69, 90, 52, 43, 69, 82, 96, 59, 75, 87, 100, 56, 74, 85, 59, 81, 86, 95, 66, 77, 70, 86, 72, 61, 41, 63, 63, 63, 83, 86, 97, 72, 41, 62, 15, 51, 80, 127, 91, 96, 81, 98, 102, 97, 119, 99, 110, 102, 127, 80, 89, 94, 92, 39, 65, 84, 127, 73, 104, 91, 127, 55, 56, 55, 61, 53, 68, 74, 88, 103, 91, 89, 92, 76, 87, 110, 105, 78, 112, 99, 127, 127, 127, 127, 66, 78, 71, 72, 59, 55, 70, 75, 89, 119, 75, 20, 22, 127, 54, 61, 58, 60, 61, 67, 84, 74, 65, 52, 57, 61, 69, 70, 55, 71, 58, 61, 41, 25, 32, 43, 47, 44, 51, 46, 38, 66, 38, 42, 34, 89, 45, 28, 31, -11, -43, 15, 0, -22, -25, 0, -18, -12, -94, 0, -15, -4, 10, -5, -29, -9, -34, -58, -63, -5, 7, -29, 1, 0, 36, -25, -30, -28, -28, -27, -18, -16, -14, -8, -6, 0, 10, 18, 25, 41, 75, 72, 77, 35, 31, 35, 30, 45, 42, 45, 26, 54, 66, 56, 73, 67, 116, 112, 71, 61, 53, 66, 77, 80, 84, 87, 127, 101, 39, 53, 61, 75, 77, 91, 107, 111, 122, 76, 44, 52, 57, 58, 72, 69, 69, 74, 86, 66, 34, 32, 31, 52, 55, 67, 73, 89, 52, 4, 8, 8, 19, 37, 61, 73, 70, 78, 0, 126, 124, 110, 126, 124, 105, 121, 117, 102, 117, 116, 122, 95, 100, 95, 111, 114, 89, 80, 82, 85, 81, 72, 64, 67, 56, 69, 69, 69, 69, 67, 77, 64, 61, 67, 64, 57, 65, 66, 62, 51, 66, 71, 75, 70, 72, 60, 37, 47, 35, 37, 41, 41, 48, 41, 41, 59, 50, 40, 66, 50, -6, -6, 0, -12, -16, -25, -22, -28, -30, -30, -42, -36, -34, -17, 9, -71, -63, -64, -74, -39, -35, -10, 0, -1, 14, 26, 37, 55, 65, -33, -36, -37, -30, -33, -30, -24, -29, -12, -10, -3, -5, 20, 30, 44, 48, 49, 45, 22, 22, 21, 20, 28, 24, 34, 42, 39, 50, 70, 54, 71, 83, 32, 49, 54, 85, 81, 77, 81, 80, 73, 74, 83, 71, 67, 61, 66, 66, 59, 59, -10, -13, -9, -5, 0, 3, 10, 27, 57, 71, 24, 36, 42, 52, 57, 63, 65, 67, 82, 81, 76, 72, 78, 72, 68, 70, 76, 66, 62, 57, 61, 60, 54, 58, -10, -13, -9, -5, 0, 3, 10, 27, 57, 80, 89, 94, 92, 39, 65, 84, 127, 73, 104, 91, 127, 80, 89, 94, 92, 39, 65, 84, 127, 73, 104, 91, 127, 103, 91, 89, 92, 76, 87, 110, 105, 78, 112, 99, 127, 127, 127, 127, 66, 78, 71, 72, 59, 55, 70, 75, 89, 119, 75, 20, 22, 127, 54, 61, 58, 60, 61, 67, 84, 74, 65, 52, 57, 61, 69, 70, 55, 103, 91, 89, 92, 76, 87, 110, 105, 78, 112, 99, 127, 127, 127, 127, 66, 78, 71, 72, 59, 55, 70, 75, 89, 119, 75, 20, 22, 127, 54, 61, 58, 60, 61, 67, 84, 74, 65, 52, 57, 61, 69, 70, 55, 45, 28, 31, -11, -43, 15, 0, -22, -25, 0, -18, -12, -94, 0, -15, -4, 10, -5, -29, -9, -34, -58, -63, -5, 7, -29, 1, 0, 36, -25, -30, -28, -28, -27, -18, -16, -14, -8, -6, 0, 10, 18, 25, 41, 45, 28, 31, -11, -43, 15, 0, -22, -25, 0, -18, -12, -94, 0, -15, -4, 10, -5, -29, -9, -34, -58, -63, -5, 7, -29, 1, 0, 36, -25, -30, -28, -28, -27, -18, -16, -14, -8, -6, 0, 10, 18, 25, 41, 85, 81, 77, 81, 80, 73, 74, 83, 71, 67, 61, 66, 66, 59, 59, 81, 76, 72, 78, 72, 68, 70, 76, 66, 62, 57, 61, 60, 54, 58, -10, -13, -9, -5, 0, 3, 10, 27, 57, -10, -13, -9, -5, 0, 3, 10, 27, 57, 71, 24, 36, 42, 52, 57, 63, 65, 67, 82, 85, 81, 77, 81, 80, 73, 74, 83, 71, 67, 61, 66, 66, 59, 59, 81, 76, 72, 78, 72, 68, 70, 76, 66, 62, 57, 61, 60, 54, 58, -10, -13, -9, -5, 0, 3, 10, 27, 57, -10, -13, -9, -5, 0, 3, 10, 27, 57, 71, 24, 36, 42, 52, 57, 63, 65, 67, 82, 126, 124, 110, 126, 124, 105, 121, 117, 102, 117, 116, 122, 95, 100, 95, 111, 114, 89, 80, 82, 85, 81, 72, 64, 67, 56, 69, 69, 69, 69, 67, 77, 64, 61, 67, 64, 57, 65, 66, 62, 51, 66, 71, 75, 126, 124, 110, 126, 124, 105, 121, 117, 102, 117, 116, 122, 95, 100, 95, 111, 114, 89, 80, 82, 85, 81, 72, 64, 67, 56, 69, 69, 69, 69, 67, 77, 64, 61, 67, 64, 57, 65, 66, 62, 51, 66, 71, 75, -6, -6, 0, -12, -16, -25, -22, -28, -30, -30, -42, -36, -34, -17, 9, -71, -63, -64, -74, -39, -35, -10, 0, -1, 14, 26, 37, 55, 65, -33, -36, -37, -30, -33, -30, -24, -29, -12, -10, -3, -5, 20, 30, 44, -6, -6, 0, -12, -16, -25, -22, -28, -30, -30, -42, -36, -34, -17, 9, -71, -63, -64, -74, -39, -35, -10, 0, -1, 14, 26, 37, 55, 65, -33, -36, -37, -30, -33, -30, -24, -29, -12, -10, -3, -5, 20, 30, 44, 112, 71, 61, 53, 66, 77, 80, 84, 87, 127, 101, 39, 53, 61, 75, 77, 91, 107, 111, 122, 76, 44, 52, 57, 58, 72, 69, 69, 74, 86, 112, 71, 61, 53, 66, 77, 80, 84, 87, 127, 101, 39, 53, 61, 75, 77, 91, 107, 111, 122, 76, 44, 52, 57, 58, 72, 69, 69, 74, 86, 73, 104, 91, 127, 73, 104, 91, 127, 73, 104, 91, 127]), new Int32Array([-15, 54, 74, -15, 54, 74, 127, 104, 53, 54, 51, 16, 0, 0, 51, 62, 99, 16, 85, 102, 57, 57, 73, 57, 40, 10, 0, 0, 42, 97, 127, 117, 74, 85, 102, 57, 93, 88, 44, 55, 89, 103, 116, 57, 58, 84, 96, 63, 85, 106, 63, 75, 90, 101, 55, 79, 75, 97, 50, 60, 41, 63, 63, 63, 83, 86, 97, 72, 41, 62, 34, 88, 127, 127, 91, 95, 84, 86, 89, 91, 127, 76, 103, 90, 127, 80, 76, 84, 78, 55, 61, 83, 127, 79, 104, 91, 127, 65, 79, 72, 92, 56, 68, 71, 98, 86, 88, 82, 72, 67, 72, 89, 69, 59, 66, 57, 71, 71, 58, 74, 44, 69, 62, 51, 47, 42, 41, 53, 76, 78, 83, 52, 67, 90, 67, 72, 75, 80, 83, 64, 31, 64, 94, 75, 63, 74, 35, 27, 91, 65, 69, 77, 66, 62, 68, 81, 30, 7, 23, 74, 66, 124, 37, -18, -34, 127, 39, 42, 34, 29, 31, 37, 42, 40, 33, 43, 36, 47, 55, 58, 60, 44, 44, 42, 48, 56, 52, 37, 49, 58, 48, 45, 69, 33, 63, -18, -25, -3, 10, 0, -14, -44, -24, 17, 25, 29, 33, 15, 20, 73, 34, 31, 44, 16, 36, 36, 28, 21, 20, 12, 16, 42, 93, 56, 57, 38, 127, 115, 82, 62, 53, 59, 85, 89, 94, 92, 127, 100, 57, 67, 71, 77, 85, 88, 104, 98, 127, 82, 48, 61, 66, 70, 75, 79, 83, 92, 108, 79, 69, 75, 58, 58, 78, 83, 81, 99, 81, 38, 62, 58, 59, 73, 76, 86, 83, 87, 0, 127, 127, 120, 127, 114, 117, 118, 117, 113, 118, 120, 124, 94, 102, 99, 106, 127, 92, 57, 86, 94, 91, 77, 71, 73, 64, 81, 64, 57, 67, 68, 67, 68, 77, 64, 68, 78, 55, 59, 65, 54, 44, 60, 70, 76, 86, 70, 64, 70, 55, 56, 69, 65, 74, 54, 54, 76, 82, 77, 77, 42, -13, -9, -12, -21, -30, -40, -41, -47, -32, -40, -51, -41, -39, -19, 11, -55, -46, -50, -67, -20, -2, 15, 1, 1, 17, 38, 45, 54, 79, -16, -14, -17, 1, 15, 15, 25, 22, 16, 18, 28, 41, 28, 47, 62, 31, 26, 24, 23, 16, 30, 29, 41, 42, 60, 52, 60, 78, 123, 53, 56, 61, 33, 50, 61, 78, 74, 72, 72, 75, 71, 63, 70, 75, 72, 67, 53, 59, 52, 68, -2, -10, -4, -1, 7, 12, 23, 38, 64, 71, 37, 44, 49, 56, 59, 63, 67, 68, 79, 78, 74, 72, 72, 75, 71, 63, 70, 75, 72, 67, 53, 59, 52, 68, -2, -10, -4, -1, 7, 12, 23, 38, 64, 80, 76, 84, 78, 55, 61, 83, 127, 79, 104, 91, 127, 80, 76, 84, 78, 55, 61, 83, 127, 79, 104, 91, 127, 86, 88, 82, 72, 67, 72, 89, 69, 59, 66, 57, 71, 71, 58, 74, 44, 69, 62, 51, 47, 42, 41, 53, 76, 78, 83, 52, 67, 90, 67, 72, 75, 80, 83, 64, 31, 64, 94, 75, 63, 74, 35, 27, 91, 86, 88, 82, 72, 67, 72, 89, 69, 59, 66, 57, 71, 71, 58, 74, 44, 69, 62, 51, 47, 42, 41, 53, 76, 78, 83, 52, 67, 90, 67, 72, 75, 80, 83, 64, 31, 64, 94, 75, 63, 74, 35, 27, 91, 39, 42, 34, 29, 31, 37, 42, 40, 33, 43, 36, 47, 55, 58, 60, 44, 44, 42, 48, 56, 52, 37, 49, 58, 48, 45, 69, 33, 63, -18, -25, -3, 10, 0, -14, -44, -24, 17, 25, 29, 33, 15, 20, 73, 39, 42, 34, 29, 31, 37, 42, 40, 33, 43, 36, 47, 55, 58, 60, 44, 44, 42, 48, 56, 52, 37, 49, 58, 48, 45, 69, 33, 63, -18, -25, -3, 10, 0, -14, -44, -24, 17, 25, 29, 33, 15, 20, 73, 78, 74, 72, 72, 75, 71, 63, 70, 75, 72, 67, 53, 59, 52, 68, 78, 74, 72, 72, 75, 71, 63, 70, 75, 72, 67, 53, 59, 52, 68, -2, -10, -4, -1, 7, 12, 23, 38, 64, -2, -10, -4, -1, 7, 12, 23, 38, 64, 71, 37, 44, 49, 56, 59, 63, 67, 68, 79, 78, 74, 72, 72, 75, 71, 63, 70, 75, 72, 67, 53, 59, 52, 68, 78, 74, 72, 72, 75, 71, 63, 70, 75, 72, 67, 53, 59, 52, 68, -2, -10, -4, -1, 7, 12, 23, 38, 64, -2, -10, -4, -1, 7, 12, 23, 38, 64, 71, 37, 44, 49, 56, 59, 63, 67, 68, 79, 127, 127, 120, 127, 114, 117, 118, 117, 113, 118, 120, 124, 94, 102, 99, 106, 127, 92, 57, 86, 94, 91, 77, 71, 73, 64, 81, 64, 57, 67, 68, 67, 68, 77, 64, 68, 78, 55, 59, 65, 54, 44, 60, 70, 127, 127, 120, 127, 114, 117, 118, 117, 113, 118, 120, 124, 94, 102, 99, 106, 127, 92, 57, 86, 94, 91, 77, 71, 73, 64, 81, 64, 57, 67, 68, 67, 68, 77, 64, 68, 78, 55, 59, 65, 54, 44, 60, 70, -13, -9, -12, -21, -30, -40, -41, -47, -32, -40, -51, -41, -39, -19, 11, -55, -46, -50, -67, -20, -2, 15, 1, 1, 17, 38, 45, 54, 79, -16, -14, -17, 1, 15, 15, 25, 22, 16, 18, 28, 41, 28, 47, 62, -13, -9, -12, -21, -30, -40, -41, -47, -32, -40, -51, -41, -39, -19, 11, -55, -46, -50, -67, -20, -2, 15, 1, 1, 17, 38, 45, 54, 79, -16, -14, -17, 1, 15, 15, 25, 22, 16, 18, 28, 41, 28, 47, 62, 115, 82, 62, 53, 59, 85, 89, 94, 92, 127, 100, 57, 67, 71, 77, 85, 88, 104, 98, 127, 82, 48, 61, 66, 70, 75, 79, 83, 92, 108, 115, 82, 62, 53, 59, 85, 89, 94, 92, 127, 100, 57, 67, 71, 77, 85, 88, 104, 98, 127, 82, 48, 61, 66, 70, 75, 79, 83, 92, 108, 79, 104, 91, 127, 79, 104, 91, 127, 79, 104, 91, 127])];
}, {cabac_context_init_I_A: "Int32Array", cabac_context_init_I_B: "Int32Array", cabac_context_init_PB_A: "Array", cabac_context_init_PB_B: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ChannelLabel = stjs.enumeration("MONO", "STEREO_LEFT", "STEREO_RIGHT", "LEFT_TOTAL", "RIGHT_TOTAL", "FRONT_LEFT", "FRONT_RIGHT", "CENTER", "LFE", "REAR_LEFT", "REAR_RIGHT", "FRONT_CENTER_LEFT", "FRONT_CENTER_RIGHT", "REAR_CENTER", "SIDE_LEFT", "SIDE_RIGHT");
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Aspect ratio
 *  
 *  dynamic enum
 *  
 *  @author The JCodec project
 *  
 */
var AspectRatio = function(value) {
    this.value = value;
};
AspectRatio = stjs.extend(AspectRatio, null, [], function(constructor, prototype) {
    constructor.Extended_SAR = new AspectRatio(255);
    prototype.value = 0;
    constructor.fromValue = function(value) {
        if (value == AspectRatio.Extended_SAR.value) {
            return AspectRatio.Extended_SAR;
        }
        return new AspectRatio(value);
    };
    prototype.getValue = function() {
        return this.value;
    };
}, {Extended_SAR: "AspectRatio"}, {});
var NotImplementedException = function(string) {
    RuntimeException.call(this, string);
};
NotImplementedException = stjs.extend(NotImplementedException, RuntimeException, [], null, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Macroblock = function() {
    this.mvs = Array(4);
    this.pmvs = Array(4);
    this.qmvs = Array(4);
    this.bmvs = Array(4);
    this.bqmvs = Array(4);
    for (var i = 0; i < 4; i++) {
        this.mvs[i] = Macroblock.vec();
        this.pmvs[i] = Macroblock.vec();
        this.qmvs[i] = Macroblock.vec();
        this.bmvs[i] = Macroblock.vec();
        this.bqmvs[i] = Macroblock.vec();
    }
    this.pred = [new Int8Array(256), new Int8Array(64), new Int8Array(64), new Int8Array(256), new Int8Array(64), new Int8Array(64)];
    this.predValues = Array.apply(null, Array(6)).map(function() {
        return new Int16Array(Macroblock.MBPRED_SIZE);
    });
    this.acpredDirections = new Int32Array(6);
    this.amv = Macroblock.vec();
    this.predictors = new Int16Array(8);
    this.block = Array.apply(null, Array(6)).map(function() {
        return new Int16Array(64);
    });
};
Macroblock = stjs.extend(Macroblock, null, [], function(constructor, prototype) {
    constructor.MBPRED_SIZE = 15;
    constructor.vec = function() {
        return new Macroblock.Vector(0, 0);
    };
    constructor.Vector = function(x, y) {
        this.x = x;
        this.y = y;
    };
    constructor.Vector = stjs.extend(constructor.Vector, null, [], function(constructor, prototype) {
        prototype.x = 0;
        prototype.y = 0;
    }, {}, {});
    prototype.mvs = null;
    prototype.predValues = null;
    prototype.acpredDirections = null;
    prototype.mode = 0;
    prototype.quant = 0;
    prototype.fieldDCT = false;
    prototype.fieldPred = false;
    prototype.fieldForTop = false;
    prototype.fieldForBottom = false;
    prototype.pmvs = null;
    prototype.qmvs = null;
    prototype.cbp = 0;
    prototype.bmvs = null;
    prototype.bqmvs = null;
    prototype.amv = null;
    prototype.mvsAvg = null;
    prototype.x = 0;
    prototype.y = 0;
    prototype.bound = 0;
    prototype.acpredFlag = false;
    prototype.predictors = null;
    prototype.block = null;
    prototype.coded = false;
    prototype.mcsel = false;
    prototype.pred = null;
    prototype.reset = function(x2, y2, bound2) {
        this.x = x2;
        this.y = y2;
        this.bound = bound2;
    };
}, {mvs: "Array", predValues: "Array", acpredDirections: "Int32Array", pmvs: "Array", qmvs: "Array", bmvs: "Array", bqmvs: "Array", amv: "Macroblock.Vector", mvsAvg: "Macroblock.Vector", predictors: "Int16Array", block: "Array", pred: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  AAC block types
 *  
 *  @author The JCodec project
 *  
 */
var BlockType = stjs.enumeration("TYPE_SCE", "TYPE_CPE", "TYPE_CCE", "TYPE_LFE", "TYPE_DSE", "TYPE_PCE", "TYPE_FIL", "TYPE_END");
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  AAC bitstream block
 *  
 *  @author The JCodec project
 *  
 */
var Block = function() {};
Block = stjs.extend(Block, null, [], function(constructor, prototype) {
    prototype.type = null;
    prototype.getType = function() {
        return this.type;
    };
    prototype.parse = function(_in) {};
}, {type: {name: "Enum", arguments: ["BlockType"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Shared constants for H264 CABAC M encoder/decoder
 *  
 *  @author The JCodec project
 *  
 */
var MConst = function() {};
MConst = stjs.extend(MConst, null, [], function(constructor, prototype) {
    constructor.rangeLPS = [new Int32Array([128, 128, 128, 123, 116, 111, 105, 100, 95, 90, 85, 81, 77, 73, 69, 66, 62, 59, 56, 53, 51, 48, 46, 43, 41, 39, 37, 35, 33, 32, 30, 29, 27, 26, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 14, 13, 12, 12, 11, 11, 10, 10, 9, 9, 8, 8, 7, 7, 7, 6, 6, 6, 2]), new Int32Array([176, 167, 158, 150, 142, 135, 128, 122, 116, 110, 104, 99, 94, 89, 85, 80, 76, 72, 69, 65, 62, 59, 56, 53, 50, 48, 45, 43, 41, 39, 37, 35, 33, 31, 30, 28, 27, 26, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 14, 13, 12, 12, 11, 11, 10, 9, 9, 9, 8, 8, 7, 7, 2]), new Int32Array([208, 197, 187, 178, 169, 160, 152, 144, 137, 130, 123, 117, 111, 105, 100, 95, 90, 86, 81, 77, 73, 69, 66, 63, 59, 56, 54, 51, 48, 46, 43, 41, 39, 37, 35, 33, 32, 30, 29, 27, 26, 25, 23, 22, 21, 20, 19, 18, 17, 16, 15, 15, 14, 13, 12, 12, 11, 11, 10, 10, 9, 9, 8, 2]), new Int32Array([240, 227, 216, 205, 195, 185, 175, 166, 158, 150, 142, 135, 128, 122, 116, 110, 104, 99, 94, 89, 85, 80, 76, 72, 69, 65, 62, 59, 56, 53, 50, 48, 45, 43, 41, 39, 37, 35, 33, 31, 30, 28, 27, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 14, 13, 12, 12, 11, 11, 10, 9, 2])];
    constructor.transitLPS = new Int32Array([0, 0, 1, 2, 2, 4, 4, 5, 6, 7, 8, 9, 9, 11, 11, 12, 13, 13, 15, 15, 16, 16, 18, 18, 19, 19, 21, 21, 22, 22, 23, 24, 24, 25, 26, 26, 27, 27, 28, 29, 29, 30, 30, 30, 31, 32, 32, 33, 33, 33, 34, 34, 35, 35, 35, 36, 36, 36, 37, 37, 37, 38, 38, 63]);
}, {rangeLPS: "Array", transitLPS: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Contains a mapping of macroblocks to slice groups. Groups is an array of
 *  group slice group indices having a dimension picWidthInMbs x picHeightInMbs
 *  
 *  @author The JCodec project
 *  
 */
var MBToSliceGroupMap = function(groups, indices, inverse) {
    this.groups = groups;
    this.indices = indices;
    this.inverse = inverse;
};
MBToSliceGroupMap = stjs.extend(MBToSliceGroupMap, null, [], function(constructor, prototype) {
    prototype.groups = null;
    prototype.indices = null;
    prototype.inverse = null;
    prototype.getGroups = function() {
        return this.groups;
    };
    prototype.getIndices = function() {
        return this.indices;
    };
    prototype.getInverse = function() {
        return this.inverse;
    };
}, {groups: "Int32Array", indices: "Int32Array", inverse: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ContainerAdaptor = function() {};
ContainerAdaptor = stjs.extend(ContainerAdaptor, null, [], function(constructor, prototype) {
    prototype.decodeFrame = function(packet, data) {};
    prototype.canSeek = function(data) {};
    prototype.allocatePicture = function() {};
    prototype.getMediaInfo = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var JCodecException = function(arg0) {
    Exception.call(this, arg0);
};
JCodecException = stjs.extend(JCodecException, Exception, [], null, {}, {});
var LogLevel = stjs.enumeration("DEBUG", "INFO", "WARN", "ERROR");
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var DCT = function() {};
DCT = stjs.extend(DCT, null, [], function(constructor, prototype) {
    constructor.n = 32;
    constructor.w_array_real = new Float32Array([1.0, 0.98078525, 0.9238795, 0.8314696, 0.70710677, 0.5555702, 0.3826834, 0.19509028, 0.0, -0.19509037, -0.3826835, -0.5555703, -0.7071068, -0.83146966, -0.92387956, -0.9807853]);
    constructor.w_array_imag = new Float32Array([0.0, -0.19509032, -0.38268346, -0.55557024, -0.70710677, -0.83146966, -0.92387956, -0.9807853, -1.0, -0.98078525, -0.9238795, -0.8314696, -0.7071067, -0.5555702, -0.38268337, -0.19509023]);
    constructor.dct4_64_tab = new Float32Array([0.9999247, 0.9981181, 0.993907, 0.9873014, 0.9783174, 0.96697646, 0.953306, 0.937339, 0.9191139, 0.8986745, 0.8760701, 0.8513552, 0.82458925, 0.7958369, 0.76516724, 0.7326543, 0.69837624, 0.66241574, 0.62485945, 0.58579785, 0.545325, 0.5035384, 0.46053872, 0.41642955, 0.37131715, 0.32531023, 0.2785196, 0.23105814, 0.18303989, 0.13458069, 0.08579727, 0.036807165, -1.0121963, -1.0594388, -1.1041292, -1.1461595, -1.1854287, -1.2218422, -1.255312, -1.2857577, -1.313106, -1.3372908, -1.3582538, -1.3759449, -1.390321, -1.4013479, -1.4089987, -1.4132552, -1.4141071, -1.4115522, -1.4055967, -1.396255, -1.3835497, -1.3675113, -1.3481784, -1.3255975, -1.2998233, -1.2709177, -1.2389501, -1.2039981, -1.1661453, -1.1254834, -1.0821099, -1.0361296, -0.9876532, -0.9367974, -0.88368475, -0.8284433, -0.771206, -0.71211076, -0.6513001, -0.58892035, -0.5251218, -0.46005824, -0.39388633, -0.32676548, -0.25885743, -0.19032592, -0.121335685, -0.052053273, 0.017354608, 0.086720645, 0.15587783, 0.22465932, 0.29289973, 0.3604344, 0.42710093, 0.49273846, 0.5571889, 0.62029713, 0.681911, 0.74188185, 0.8000656, 0.856322, 0.91051537, 0.96251523, 1.0, 0.99879545, 0.9951847, 0.9891765, 0.98078525, 0.97003126, 0.95694035, 0.94154406, 0.9238795, 0.9039893, 0.88192123, 0.8577286, 0.8314696, 0.8032075, 0.77301043, 0.7409511, 0.70710677, 0.6715589, 0.6343933, 0.5956993, 0.5555702, 0.5141027, 0.47139665, 0.4275551, 0.38268343, 0.33688983, 0.29028463, 0.24298012, 0.19509023, 0.1467305, 0.098017134, 0.04906765, -1.0, -1.0478631, -1.0932019, -1.1359069, -1.1758755, -1.2130115, -1.247225, -1.2784339, -1.3065629, -1.3315444, -1.353318, -1.3718314, -1.3870399, -1.3989068, -1.4074037, -1.4125102, 0.0, -1.4125102, -1.4074037, -1.3989068, -1.3870399, -1.3718314, -1.353318, -1.3315444, -1.3065629, -1.2784339, -1.247225, -1.2130114, -1.1758755, -1.135907, -1.0932019, -1.0478631, -1.0, -0.9497278, -0.89716756, -0.842446, -0.78569496, -0.7270511, -0.66665566, -0.6046542, -0.54119605, -0.47643423, -0.4105245, -0.34362584, -0.27589935, -0.2075082, -0.1386171, -0.069392145, 0.0, 0.069392264, 0.13861716, 0.2075082, 0.27589947, 0.34362596, 0.41052464, 0.4764342, 0.5411961, 0.6046542, 0.6666557, 0.72705114, 0.7856951, 0.842446, 0.89716756, 0.9497278]);
    constructor.bit_rev_tab = new Int32Array([0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30, 1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23, 15, 31]);
    constructor.fft_dif = function(Real, Imag) {
        var w_real, w_imag;
        var point1_real, point1_imag, point2_real, point2_imag;
        var j, i, i2, w_index;
        for (i = 0; i < 16; i++) {
            point1_real = Real[i];
            point1_imag = Imag[i];
            i2 = i + 16;
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            w_real = DCT.w_array_real[i];
            w_imag = DCT.w_array_imag[i];
            point1_real -= point2_real;
            point1_imag -= point2_imag;
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = ((point1_real * w_real) - (point1_imag * w_imag));
            Imag[i2] = ((point1_real * w_imag) + (point1_imag * w_real));
        }
        for (j = 0 , w_index = 0; j < 8; j++ , w_index += 2) {
            w_real = DCT.w_array_real[w_index];
            w_imag = DCT.w_array_imag[w_index];
            i = j;
            point1_real = Real[i];
            point1_imag = Imag[i];
            i2 = i + 8;
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            point1_real -= point2_real;
            point1_imag -= point2_imag;
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = ((point1_real * w_real) - (point1_imag * w_imag));
            Imag[i2] = ((point1_real * w_imag) + (point1_imag * w_real));
            i = j + 16;
            point1_real = Real[i];
            point1_imag = Imag[i];
            i2 = i + 8;
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            point1_real -= point2_real;
            point1_imag -= point2_imag;
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = ((point1_real * w_real) - (point1_imag * w_imag));
            Imag[i2] = ((point1_real * w_imag) + (point1_imag * w_real));
        }
        for (i = 0; i < DCT.n; i += 8) {
            i2 = i + 4;
            point1_real = Real[i];
            point1_imag = Imag[i];
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = point1_real - point2_real;
            Imag[i2] = point1_imag - point2_imag;
        }
        w_real = DCT.w_array_real[4];
        for (i = 1; i < DCT.n; i += 8) {
            i2 = i + 4;
            point1_real = Real[i];
            point1_imag = Imag[i];
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            point1_real -= point2_real;
            point1_imag -= point2_imag;
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = (point1_real + point1_imag) * w_real;
            Imag[i2] = (point1_imag - point1_real) * w_real;
        }
        for (i = 2; i < DCT.n; i += 8) {
            i2 = i + 4;
            point1_real = Real[i];
            point1_imag = Imag[i];
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = point1_imag - point2_imag;
            Imag[i2] = point2_real - point1_real;
        }
        w_real = DCT.w_array_real[12];
        for (i = 3; i < DCT.n; i += 8) {
            i2 = i + 4;
            point1_real = Real[i];
            point1_imag = Imag[i];
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            point1_real -= point2_real;
            point1_imag -= point2_imag;
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = (point1_real - point1_imag) * w_real;
            Imag[i2] = (point1_real + point1_imag) * w_real;
        }
        for (i = 0; i < DCT.n; i += 4) {
            i2 = i + 2;
            point1_real = Real[i];
            point1_imag = Imag[i];
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = point1_real - point2_real;
            Imag[i2] = point1_imag - point2_imag;
        }
        for (i = 1; i < DCT.n; i += 4) {
            i2 = i + 2;
            point1_real = Real[i];
            point1_imag = Imag[i];
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = point1_imag - point2_imag;
            Imag[i2] = point2_real - point1_real;
        }
        for (i = 0; i < DCT.n; i += 2) {
            i2 = i + 1;
            point1_real = Real[i];
            point1_imag = Imag[i];
            point2_real = Real[i2];
            point2_imag = Imag[i2];
            Real[i] += point2_real;
            Imag[i] += point2_imag;
            Real[i2] = point1_real - point2_real;
            Imag[i2] = point1_imag - point2_imag;
        }
    };
    constructor.dct4_kernel = function(in_real, in_imag, out_real, out_imag) {
        var i, i_rev;
        for (i = 0; i < 32; i++) {
            var x_re, x_im, tmp;
            x_re = in_real[i];
            x_im = in_imag[i];
            tmp = (x_re + x_im) * DCT.dct4_64_tab[i];
            in_real[i] = (x_im * DCT.dct4_64_tab[i + 64]) + tmp;
            in_imag[i] = (x_re * DCT.dct4_64_tab[i + 32]) + tmp;
        }
        DCT.fft_dif(in_real, in_imag);
        for (i = 0; i < 16; i++) {
            var x_re, x_im, tmp;
            i_rev = DCT.bit_rev_tab[i];
            x_re = in_real[i_rev];
            x_im = in_imag[i_rev];
            tmp = (x_re + x_im) * DCT.dct4_64_tab[i + 3 * 32];
            out_real[i] = (x_im * DCT.dct4_64_tab[i + 5 * 32]) + tmp;
            out_imag[i] = (x_re * DCT.dct4_64_tab[i + 4 * 32]) + tmp;
        }
        out_imag[16] = (in_imag[1] - in_real[1]) * DCT.dct4_64_tab[16 + 3 * 32];
        out_real[16] = (in_real[1] + in_imag[1]) * DCT.dct4_64_tab[16 + 3 * 32];
        for (i = 17; i < 32; i++) {
            var x_re, x_im, tmp;
            i_rev = DCT.bit_rev_tab[i];
            x_re = in_real[i_rev];
            x_im = in_imag[i_rev];
            tmp = (x_re + x_im) * DCT.dct4_64_tab[i + 3 * 32];
            out_real[i] = (x_im * DCT.dct4_64_tab[i + 5 * 32]) + tmp;
            out_imag[i] = (x_re * DCT.dct4_64_tab[i + 4 * 32]) + tmp;
        }
    };
}, {w_array_real: "Float32Array", w_array_imag: "Float32Array", dct4_64_tab: "Float32Array", bit_rev_tab: "Int32Array"}, {});
/**
 *  A reader for H.264 macroblocks
 *  
 *  @author The JCodec project
 */
var MBlockReader = function() {};
MBlockReader = stjs.extend(MBlockReader, null, [], null, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Plane = function(data, size) {
    this.data = data;
    this.size = size;
};
Plane = stjs.extend(Plane, null, [], function(constructor, prototype) {
    prototype.data = null;
    prototype.size = null;
    prototype.getData = function() {
        return this.data;
    };
    prototype.getSize = function() {
        return this.size;
    };
}, {data: "Int32Array", size: "Size"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Inverse quantization lookup table for all possible values
 *  from 0<sup>4/3</sup> to 8191<sup>4/3</sup>.
 *  @author in-somnia
 */
var IQTable = function() {};
IQTable = stjs.extend(IQTable, null, [], function(constructor, prototype) {
    constructor.IQ_TABLE = new Float32Array([0.0, 1.0, 2.5198421, 4.326749, 6.349604, 8.54988, 10.902723, 13.390518, 16.0, 18.720755, 21.544348, 24.463781, 27.473143, 30.56735, 33.741993, 36.99318, 40.317474, 43.71179, 47.173344, 50.69963, 54.288353, 57.93741, 61.644867, 65.40894, 69.22798, 73.10044, 77.024895, 81.0, 85.02449, 89.09719, 93.21697, 97.3828, 101.593666, 105.84863, 110.146805, 114.48732, 118.869385, 123.292206, 127.755066, 132.25725, 136.79808, 141.3769, 145.99312, 150.64612, 155.33533, 160.0602, 164.8202, 169.61482, 174.44357, 179.30598, 184.20157, 189.12991, 194.09058, 199.08315, 204.10721, 209.16238, 214.24829, 219.36456, 224.51085, 229.68678, 234.89206, 240.12633, 245.38928, 250.6806, 256.0, 261.34717, 266.72183, 272.12372, 277.55255, 283.00806, 288.48996, 293.99805, 299.53207, 305.09177, 310.6769, 316.28726, 321.9226, 327.5827, 333.26736, 338.97638, 344.70956, 350.46664, 356.24747, 362.05188, 367.8796, 373.73053, 379.60443, 385.50113, 391.4205, 397.3623, 403.32642, 409.31268, 415.3209, 421.3509, 427.4026, 433.47574, 439.57028, 445.68597, 451.82275, 457.98044, 464.15887, 470.35797, 476.57755, 482.81747, 489.0776, 495.35788, 501.65808, 507.97815, 514.31793, 520.6773, 527.0562, 533.4544, 539.8719, 546.3085, 552.76404, 559.2386, 565.7319, 572.2439, 578.7744, 585.3235, 591.89087, 598.47656, 605.08044, 611.70233, 618.3422, 625.0, 631.67554, 638.3688, 645.0796, 651.80786, 658.5536, 665.31665, 672.0969, 678.89435, 685.7088, 692.5403, 699.3886, 706.2537, 713.1356, 720.0341, 726.94916, 733.88074, 740.8287, 747.79297, 754.7735, 761.77026, 768.7831, 775.8119, 782.85675, 789.9174, 796.9939, 804.0862, 811.1941, 818.3176, 825.45667, 832.6112, 839.7812, 846.96643, 854.167, 861.38275, 868.61365, 875.8596, 883.1206, 890.39655, 897.6874, 904.9931, 912.31354, 919.6487, 926.99854, 934.3629, 941.7419, 949.1354, 956.5432, 963.96545, 971.40204, 978.85284, 986.3179, 993.797, 1001.2903, 1008.7976, 1016.3189, 1023.8542, 1031.4033, 1038.9663, 1046.5431, 1054.1335, 1061.7378, 1069.3556, 1076.987, 1084.632, 1092.2904, 1099.9624, 1107.6477, 1115.3463, 1123.0583, 1130.7836, 1138.522, 1146.2737, 1154.0383, 1161.8162, 1169.607, 1177.411, 1185.2278, 1193.0575, 1200.9001, 1208.7555, 1216.6238, 1224.5048, 1232.3983, 1240.3047, 1248.2236, 1256.1552, 1264.0991, 1272.0558, 1280.0248, 1288.0062, 1296.0, 1304.0062, 1312.0247, 1320.0554, 1328.0984, 1336.1536, 1344.2208, 1352.3003, 1360.3918, 1368.4955, 1376.6111, 1384.7386, 1392.8782, 1401.0295, 1409.1929, 1417.368, 1425.555, 1433.7538, 1441.9642, 1450.1864, 1458.4202, 1466.6656, 1474.9227, 1483.1914, 1491.4716, 1499.7633, 1508.0665, 1516.3811, 1524.7072, 1533.0446, 1541.3933, 1549.7534, 1558.1248, 1566.5074, 1574.9014, 1583.3064, 1591.7227, 1600.15, 1608.5885, 1617.0381, 1625.4987, 1633.9703, 1642.453, 1650.9465, 1659.4512, 1667.9666, 1676.4929, 1685.0302, 1693.5781, 1702.137, 1710.7065, 1719.2869, 1727.8779, 1736.4797, 1745.092, 1753.7152, 1762.3489, 1770.993, 1779.648, 1788.3132, 1796.9891, 1805.6754, 1814.3722, 1823.0795, 1831.7971, 1840.5251, 1849.2635, 1858.0123, 1866.7714, 1875.5406, 1884.3202, 1893.1101, 1901.9102, 1910.7203, 1919.5408, 1928.3712, 1937.2119, 1946.0627, 1954.9236, 1963.7944, 1972.6753, 1981.5663, 1990.4672, 1999.378, 2008.2988, 2017.2296, 2026.1702, 2035.1207, 2044.081, 2053.0513, 2062.0312, 2071.021, 2080.0205, 2089.0298, 2098.0488, 2107.0776, 2116.116, 2125.164, 2134.2217, 2143.289, 2152.366, 2161.4524, 2170.5486, 2179.654, 2188.7693, 2197.8938, 2207.0278, 2216.1714, 2225.3245, 2234.4868, 2243.6587, 2252.8398, 2262.0305, 2271.2305, 2280.4397, 2289.6582, 2298.886, 2308.123, 2317.3696, 2326.625, 2335.89, 2345.1638, 2354.447, 2363.7395, 2373.041, 2382.3516, 2391.6711, 2401.0, 2410.338, 2419.6848, 2429.0408, 2438.4058, 2447.7798, 2457.1626, 2466.5544, 2475.9553, 2485.3652, 2494.784, 2504.2117, 2513.648, 2523.0935, 2532.5476, 2542.0107, 2551.4824, 2560.9631, 2570.4526, 2579.951, 2589.4578, 2598.9734, 2608.4978, 2618.031, 2627.5728, 2637.1233, 2646.6824, 2656.25, 2665.8264, 2675.4114, 2685.0051, 2694.6072, 2704.218, 2713.8372, 2723.465, 2733.1013, 2742.746, 2752.3994, 2762.0613, 2771.7314, 2781.4102, 2791.0972, 2800.7927, 2810.4966, 2820.209, 2829.9297, 2839.6587, 2849.396, 2859.1416, 2868.8958, 2878.658, 2888.4285, 2898.2075, 2907.9944, 2917.7898, 2927.5935, 2937.4053, 2947.225, 2957.0535, 2966.8896, 2976.7341, 2986.587, 2996.4478, 3006.3167, 3016.1936, 3026.0786, 3035.972, 3045.873, 3055.7825, 3065.6997, 3075.6252, 3085.5586, 3095.5, 3105.4492, 3115.4067, 3125.3718, 3135.3452, 3145.3264, 3155.3154, 3165.3125, 3175.3174, 3185.3303, 3195.351, 3205.3796, 3215.416, 3225.4602, 3235.5122, 3245.5723, 3255.64, 3265.7153, 3275.7986, 3285.8896, 3295.9885, 3306.095, 3316.2092, 3326.331, 3336.4607, 3346.5981, 3356.7432, 3366.896, 3377.0564, 3387.2244, 3397.4, 3407.5833, 3417.7742, 3427.9727, 3438.1787, 3448.3923, 3458.6138, 3468.8425, 3479.0789, 3489.3228, 3499.5742, 3509.833, 3520.0994, 3530.3733, 3540.6548, 3550.9436, 3561.24, 3571.5437, 3581.855, 3592.1736, 3602.4995, 3612.833, 3623.1738, 3633.522, 3643.8777, 3654.2407, 3664.6108, 3674.9885, 3685.3735, 3695.7659, 3706.1655, 3716.5725, 3726.9866, 3737.4082, 3747.837, 3758.273, 3768.7163, 3779.1667, 3789.6245, 3800.0894, 3810.5615, 3821.041, 3831.5276, 3842.0212, 3852.5222, 3863.0303, 3873.5454, 3884.0679, 3894.5974, 3905.134, 3915.6777, 3926.2285, 3936.7864, 3947.3513, 3957.9236, 3968.5027, 3979.0889, 3989.6821, 4000.2825, 4010.8896, 4021.504, 4032.1252, 4042.7537, 4053.389, 4064.0312, 4074.6807, 4085.337, 4096.0, 4106.67, 4117.347, 4128.0312, 4138.722, 4149.42, 4160.1245, 4170.8364, 4181.5547, 4192.2803, 4203.012, 4213.7515, 4224.4976, 4235.25, 4246.01, 4256.7764, 4267.5493, 4278.3296, 4289.116, 4299.91, 4310.7104, 4321.5176, 4332.3315, 4343.1523, 4353.9795, 4364.814, 4375.655, 4386.5024, 4397.3564, 4408.218, 4419.0854, 4429.9595, 4440.841, 4451.7285, 4462.623, 4473.524, 4484.4316, 4495.346, 4506.267, 4517.195, 4528.129, 4539.07, 4550.017, 4560.971, 4571.9316, 4582.899, 4593.8726, 4604.8525, 4615.8394, 4626.833, 4637.833, 4648.8394, 4659.852, 4670.8716, 4681.8975, 4692.93, 4703.9688, 4715.014, 4726.0664, 4737.1245, 4748.1895, 4759.2607, 4770.3384, 4781.4224, 4792.513, 4803.6104, 4814.7134, 4825.823, 4836.9395, 4848.062, 4859.191, 4870.3267, 4881.4683, 4892.616, 4903.7705, 4914.9316, 4926.0986, 4937.272, 4948.4517, 4959.638, 4970.8306, 4982.0293, 4993.234, 5004.4453, 5015.663, 5026.8867, 5038.117, 5049.3535, 5060.596, 5071.8447, 5083.1, 5094.3613, 5105.629, 5116.903, 5128.1826, 5139.469, 5150.7617, 5162.06, 5173.3647, 5184.676, 5195.993, 5207.3164, 5218.646, 5229.9814, 5241.323, 5252.6714, 5264.0254, 5275.3853, 5286.752, 5298.124, 5309.503, 5320.887, 5332.278, 5343.675, 5355.0776, 5366.487, 5377.902, 5389.3228, 5400.75, 5412.183, 5423.622, 5435.0674, 5446.519, 5457.976, 5469.4395, 5480.9087, 5492.3843, 5503.8657, 5515.353, 5526.846, 5538.345, 5549.8506, 5561.362, 5572.879, 5584.4023, 5595.931, 5607.4663, 5619.0073, 5630.554, 5642.107, 5653.6655, 5665.2305, 5676.801, 5688.3774, 5699.9595, 5711.548, 5723.142, 5734.742, 5746.3477, 5757.9595, 5769.577, 5781.2007, 5792.83, 5804.465, 5816.106, 5827.7524, 5839.4053, 5851.0635, 5862.728, 5874.398, 5886.0737, 5897.7554, 5909.443, 5921.1357, 5932.835, 5944.5396, 5956.25, 5967.9663, 5979.6885, 5991.416, 6003.1494, 6014.8887, 6026.634, 6038.3843, 6050.141, 6061.903, 6073.671, 6085.4443, 6097.2236, 6109.0083, 6120.7993, 6132.595, 6144.3975, 6156.205, 6168.018, 6179.8374, 6191.6616, 6203.492, 6215.328, 6227.1694, 6239.0166, 6250.8696, 6262.728, 6274.592, 6286.4614, 6298.337, 6310.218, 6322.104, 6333.996, 6345.894, 6357.797, 6369.7056, 6381.62, 6393.54, 6405.4653, 6417.3965, 6429.333, 6441.2754, 6453.2227, 6465.176, 6477.135, 6489.099, 6501.069, 6513.044, 6525.025, 6537.0107, 6549.003, 6561.0, 6573.003, 6585.0107, 6597.025, 6609.044, 6621.0684, 6633.0986, 6645.1343, 6657.1753, 6669.2217, 6681.2734, 6693.331, 6705.3936, 6717.462, 6729.5356, 6741.6143, 6753.6987, 6765.7886, 6777.8843, 6789.985, 6802.091, 6814.202, 6826.319, 6838.4414, 6850.569, 6862.7017, 6874.8403, 6886.984, 6899.133, 6911.287, 6923.447, 6935.612, 6947.782, 6959.958, 6972.139, 6984.3257, 6996.517, 7008.7144, 7020.9165, 7033.1245, 7045.3374, 7057.5557, 7069.779, 7082.008, 7094.2417, 7106.4814, 7118.726, 7130.9756, 7143.231, 7155.491, 7167.757, 7180.028, 7192.304, 7204.5854, 7216.872, 7229.164, 7241.4614, 7253.7637, 7266.0713, 7278.384, 7290.7017, 7303.025, 7315.3535, 7327.687, 7340.026, 7352.3696, 7364.7188, 7377.073, 7389.4326, 7401.7974, 7414.167, 7426.542, 7438.9224, 7451.3076, 7463.698, 7476.0938, 7488.494, 7500.9004, 7513.311, 7525.7275, 7538.1484, 7550.575, 7563.0063, 7575.443, 7587.885, 7600.3315, 7612.7837, 7625.2407, 7637.7026, 7650.17, 7662.642, 7675.119, 7687.6016, 7700.0894, 7712.5815, 7725.0796, 7737.582, 7750.09, 7762.6025, 7775.12, 7787.643, 7800.171, 7812.704, 7825.2417, 7837.7847, 7850.333, 7862.8857, 7875.444, 7888.007, 7900.5747, 7913.148, 7925.726, 7938.309, 7950.897, 7963.4897, 7976.088, 7988.691, 8001.299, 8013.9116, 8026.5293, 8039.1523, 8051.78, 8064.4126, 8077.0503, 8089.693, 8102.3403, 8114.993, 8127.6504, 8140.313, 8152.98, 8165.6523, 8178.3296, 8191.0117, 8203.698, 8216.391, 8229.087, 8241.789, 8254.495, 8267.207, 8279.923, 8292.645, 8305.37, 8318.102, 8330.837, 8343.578, 8356.323, 8369.074, 8381.829, 8394.59, 8407.3545, 8420.124, 8432.899, 8445.679, 8458.463, 8471.252, 8484.046, 8496.845, 8509.648, 8522.457, 8535.2705, 8548.089, 8560.911, 8573.739, 8586.572, 8599.409, 8612.251, 8625.099, 8637.95, 8650.807, 8663.668, 8676.533, 8689.404, 8702.28, 8715.16, 8728.046, 8740.936, 8753.83, 8766.7295, 8779.634, 8792.542, 8805.456, 8818.374, 8831.297, 8844.225, 8857.157, 8870.095, 8883.037, 8895.983, 8908.935, 8921.891, 8934.852, 8947.817, 8960.787, 8973.763, 8986.742, 8999.727, 9012.715, 9025.709, 9038.707, 9051.71, 9064.718, 9077.73, 9090.747, 9103.769, 9116.795, 9129.826, 9142.861, 9155.902, 9168.947, 9181.996, 9195.051, 9208.109, 9221.173, 9234.241, 9247.313, 9260.391, 9273.473, 9286.56, 9299.65, 9312.746, 9325.847, 9338.952, 9352.062, 9365.176, 9378.295, 9391.418, 9404.546, 9417.679, 9430.815, 9443.957, 9457.104, 9470.254, 9483.41, 9496.569, 9509.734, 9522.903, 9536.077, 9549.255, 9562.438, 9575.625, 9588.817, 9602.014, 9615.215, 9628.42, 9641.63, 9654.845, 9668.063, 9681.287, 9694.515, 9707.747, 9720.984, 9734.227, 9747.473, 9760.723, 9773.978, 9787.237, 9800.502, 9813.7705, 9827.043, 9840.321, 9853.603, 9866.89, 9880.181, 9893.476, 9906.775, 9920.08, 9933.389, 9946.702, 9960.02, 9973.342, 9986.669, 10000.0, 10013.336, 10026.676, 10040.02, 10053.369, 10066.722, 10080.08, 10093.442, 10106.809, 10120.18, 10133.555, 10146.935, 10160.319, 10173.708, 10187.101, 10200.498, 10213.9, 10227.307, 10240.717, 10254.132, 10267.552, 10280.976, 10294.403, 10307.836, 10321.273, 10334.715, 10348.16, 10361.61, 10375.064, 10388.523, 10401.987, 10415.454, 10428.926, 10442.402, 10455.883, 10469.368, 10482.857, 10496.351, 10509.849, 10523.352, 10536.857, 10550.369, 10563.884, 10577.403, 10590.928, 10604.456, 10617.988, 10631.525, 10645.066, 10658.612, 10672.162, 10685.716, 10699.274, 10712.837, 10726.404, 10739.976, 10753.551, 10767.131, 10780.715, 10794.303, 10807.8955, 10821.493, 10835.094, 10848.699, 10862.31, 10875.924, 10889.542, 10903.164, 10916.791, 10930.422, 10944.058, 10957.697, 10971.341, 10984.989, 10998.642, 11012.298, 11025.959, 11039.624, 11053.293, 11066.967, 11080.645, 11094.326, 11108.012, 11121.702, 11135.397, 11149.096, 11162.799, 11176.506, 11190.218, 11203.933, 11217.653, 11231.377, 11245.105, 11258.838, 11272.574, 11286.314, 11300.06, 11313.809, 11327.5625, 11341.319, 11355.081, 11368.847, 11382.617, 11396.392, 11410.17, 11423.952, 11437.738, 11451.529, 11465.324, 11479.123, 11492.927, 11506.734, 11520.546, 11534.361, 11548.181, 11562.005, 11575.833, 11589.665, 11603.502, 11617.342, 11631.187, 11645.035, 11658.889, 11672.745, 11686.606, 11700.472, 11714.341, 11728.214, 11742.092, 11755.974, 11769.859, 11783.749, 11797.643, 11811.541, 11825.442, 11839.349, 11853.259, 11867.174, 11881.092, 11895.015, 11908.94, 11922.871, 11936.806, 11950.745, 11964.6875, 11978.635, 11992.586, 12006.54, 12020.5, 12034.463, 12048.43, 12062.401, 12076.376, 12090.355, 12104.339, 12118.326, 12132.317, 12146.313, 12160.3125, 12174.316, 12188.324, 12202.335, 12216.351, 12230.371, 12244.395, 12258.422, 12272.454, 12286.489, 12300.529, 12314.572, 12328.62, 12342.672, 12356.728, 12370.787, 12384.852, 12398.919, 12412.99, 12427.066, 12441.146, 12455.2295, 12469.317, 12483.409, 12497.505, 12511.6045, 12525.708, 12539.815, 12553.927, 12568.042, 12582.161, 12596.285, 12610.412, 12624.544, 12638.679, 12652.818, 12666.961, 12681.108, 12695.259, 12709.414, 12723.573, 12737.736, 12751.902, 12766.073, 12780.248, 12794.427, 12808.609, 12822.796, 12836.986, 12851.181, 12865.379, 12879.581, 12893.787, 12907.997, 12922.211, 12936.429, 12950.65, 12964.876, 12979.105, 12993.339, 13007.576, 13021.817, 13036.0625, 13050.312, 13064.564, 13078.821, 13093.082, 13107.347, 13121.615, 13135.888, 13150.164, 13164.443, 13178.728, 13193.016, 13207.307, 13221.603, 13235.902, 13250.205, 13264.513, 13278.823, 13293.139, 13307.457, 13321.779, 13336.106, 13350.437, 13364.7705, 13379.108, 13393.45, 13407.796, 13422.1455, 13436.499, 13450.855, 13465.217, 13479.582, 13493.95, 13508.322, 13522.699, 13537.079, 13551.463, 13565.851, 13580.242, 13594.638, 13609.037, 13623.44, 13637.847, 13652.258, 13666.672, 13681.09, 13695.512, 13709.9375, 13724.367, 13738.801, 13753.238, 13767.679, 13782.124, 13796.572, 13811.024, 13825.48, 13839.94, 13854.404, 13868.872, 13883.343, 13897.818, 13912.297, 13926.779, 13941.266, 13955.756, 13970.25, 13984.747, 13999.249, 14013.754, 14028.263, 14042.775, 14057.292, 14071.812, 14086.336, 14100.863, 14115.395, 14129.93, 14144.469, 14159.011, 14173.558, 14188.107, 14202.661, 14217.219, 14231.78, 14246.345, 14260.914, 14275.486, 14290.0625, 14304.642, 14319.226, 14333.8125, 14348.403, 14362.998, 14377.597, 14392.199, 14406.805, 14421.414, 14436.027, 14450.645, 14465.265, 14479.89, 14494.518, 14509.149, 14523.784, 14538.424, 14553.066, 14567.713, 14582.362, 14597.017, 14611.674, 14626.335, 14641.0, 14655.669, 14670.341, 14685.017, 14699.696, 14714.379, 14729.066, 14743.757, 14758.451, 14773.148, 14787.85, 14802.555, 14817.264, 14831.977, 14846.692, 14861.412, 14876.136, 14890.862, 14905.594, 14920.327, 14935.065, 14949.807, 14964.553, 14979.301, 14994.054, 15008.81, 15023.569, 15038.333, 15053.1, 15067.87, 15082.645, 15097.423, 15112.204, 15126.989, 15141.777, 15156.57, 15171.366, 15186.166, 15200.969, 15215.775, 15230.586, 15245.399, 15260.217, 15275.038, 15289.863, 15304.691, 15319.523, 15334.359, 15349.198, 15364.041, 15378.887, 15393.737, 15408.59, 15423.447, 15438.308, 15453.172, 15468.04, 15482.911, 15497.786, 15512.664, 15527.547, 15542.433, 15557.321, 15572.214, 15587.11, 15602.01, 15616.914, 15631.82, 15646.731, 15661.6455, 15676.5625, 15691.484, 15706.409, 15721.337, 15736.269, 15751.204, 15766.144, 15781.086, 15796.031, 15810.981, 15825.934, 15840.891, 15855.851, 15870.814, 15885.781, 15900.752, 15915.727, 15930.704, 15945.686, 15960.67, 15975.658, 15990.65, 16005.6455, 16020.645, 16035.646, 16050.652, 16065.662, 16080.675, 16095.691, 16110.711, 16125.734, 16140.762, 16155.792, 16170.826, 16185.863, 16200.904, 16215.948, 16230.996, 16246.048, 16261.103, 16276.161, 16291.223, 16306.288, 16321.356, 16336.429, 16351.505, 16366.584, 16381.667, 16396.752, 16411.842, 16426.936, 16442.031, 16457.133, 16472.236, 16487.342, 16502.453, 16517.566, 16532.684, 16547.805, 16562.93, 16578.057, 16593.188, 16608.322, 16623.46, 16638.602, 16653.746, 16668.895, 16684.047, 16699.203, 16714.361, 16729.523, 16744.69, 16759.857, 16775.03, 16790.207, 16805.385, 16820.568, 16835.754, 16850.943, 16866.137, 16881.334, 16896.533, 16911.736, 16926.943, 16942.152, 16957.367, 16972.584, 16987.805, 17003.027, 17018.256, 17033.486, 17048.719, 17063.957, 17079.197, 17094.441, 17109.69, 17124.94, 17140.195, 17155.453, 17170.713, 17185.979, 17201.246, 17216.518, 17231.793, 17247.07, 17262.352, 17277.637, 17292.926, 17308.217, 17323.512, 17338.81, 17354.111, 17369.416, 17384.725, 17400.037, 17415.352, 17430.672, 17445.992, 17461.318, 17476.646, 17491.979, 17507.314, 17522.654, 17537.996, 17553.342, 17568.69, 17584.043, 17599.398, 17614.756, 17630.12, 17645.484, 17660.854, 17676.227, 17691.602, 17706.98, 17722.363, 17737.748, 17753.137, 17768.53, 17783.926, 17799.324, 17814.727, 17830.133, 17845.541, 17860.953, 17876.37, 17891.79, 17907.21, 17922.637, 17938.064, 17953.498, 17968.934, 17984.371, 17999.814, 18015.26, 18030.709, 18046.16, 18061.615, 18077.074, 18092.537, 18108.002, 18123.47, 18138.943, 18154.418, 18169.896, 18185.379, 18200.863, 18216.352, 18231.844, 18247.338, 18262.838, 18278.338, 18293.844, 18309.352, 18324.863, 18340.379, 18355.896, 18371.418, 18386.941, 18402.47, 18418.002, 18433.535, 18449.072, 18464.613, 18480.158, 18495.705, 18511.256, 18526.81, 18542.367, 18557.928, 18573.492, 18589.059, 18604.629, 18620.203, 18635.781, 18651.361, 18666.943, 18682.531, 18698.121, 18713.713, 18729.31, 18744.91, 18760.512, 18776.12, 18791.729, 18807.34, 18822.957, 18838.576, 18854.197, 18869.824, 18885.453, 18901.084, 18916.719, 18932.357, 18948.0, 18963.645, 18979.293, 18994.943, 19010.6, 19026.256, 19041.918, 19057.582, 19073.25, 19088.92, 19104.594, 19120.271, 19135.951, 19151.635, 19167.322, 19183.012, 19198.705, 19214.402, 19230.102, 19245.805, 19261.51, 19277.22, 19292.932, 19308.648, 19324.367, 19340.088, 19355.814, 19371.543, 19387.273, 19403.01, 19418.746, 19434.488, 19450.232, 19465.98, 19481.73, 19497.484, 19513.242, 19529.002, 19544.766, 19560.533, 19576.303, 19592.076, 19607.852, 19623.63, 19639.414, 19655.2, 19670.988, 19686.78, 19702.576, 19718.373, 19734.176, 19749.98, 19765.787, 19781.6, 19797.414, 19813.23, 19829.05, 19844.875, 19860.701, 19876.531, 19892.365, 19908.201, 19924.041, 19939.883, 19955.729, 19971.578, 19987.43, 20003.285, 20019.143, 20035.004, 20050.87, 20066.736, 20082.607, 20098.482, 20114.36, 20130.24, 20146.123, 20162.01, 20177.898, 20193.791, 20209.688, 20225.586, 20241.488, 20257.395, 20273.303, 20289.215, 20305.129, 20321.047, 20336.967, 20352.893, 20368.818, 20384.75, 20400.682, 20416.62, 20432.559, 20448.502, 20464.447, 20480.396, 20496.348, 20512.303, 20528.262, 20544.223, 20560.188, 20576.154, 20592.125, 20608.1, 20624.076, 20640.055, 20656.04, 20672.025, 20688.014, 20704.006, 20720.002, 20736.0, 20752.002, 20768.006, 20784.014, 20800.025, 20816.04, 20832.055, 20848.076, 20864.1, 20880.125, 20896.154, 20912.186, 20928.223, 20944.26, 20960.303, 20976.346, 20992.395, 21008.445, 21024.498, 21040.557, 21056.615, 21072.68, 21088.744, 21104.814, 21120.887, 21136.96, 21153.04, 21169.121, 21185.205, 21201.293, 21217.383, 21233.477, 21249.574, 21265.674, 21281.775, 21297.883, 21313.99, 21330.104, 21346.217, 21362.336, 21378.457, 21394.58, 21410.707, 21426.838, 21442.97, 21459.107, 21475.246, 21491.389, 21507.533, 21523.682, 21539.834, 21555.988, 21572.145, 21588.307, 21604.469, 21620.635, 21636.805, 21652.979, 21669.152, 21685.332, 21701.514, 21717.697, 21733.885, 21750.076, 21766.27, 21782.467, 21798.666, 21814.87, 21831.074, 21847.283, 21863.494, 21879.709, 21895.928, 21912.148, 21928.371, 21944.598, 21960.828, 21977.06, 21993.297, 22009.535, 22025.777, 22042.021, 22058.27, 22074.52, 22090.773, 22107.03, 22123.29, 22139.553, 22155.818, 22172.086, 22188.357, 22204.633, 22220.91, 22237.191, 22253.475, 22269.762, 22286.05, 22302.344, 22318.639, 22334.938, 22351.238, 22367.543, 22383.85, 22400.16, 22416.473, 22432.79, 22449.11, 22465.432, 22481.756, 22498.084, 22514.416, 22530.75, 22547.086, 22563.426, 22579.77, 22596.115, 22612.465, 22628.816, 22645.17, 22661.527, 22677.889, 22694.252, 22710.62, 22726.988, 22743.361, 22759.736, 22776.115, 22792.496, 22808.88, 22825.268, 22841.658, 22858.05, 22874.447, 22890.846, 22907.248, 22923.652, 22940.06, 22956.47, 22972.885, 22989.3, 23005.72, 23022.143, 23038.568, 23054.996, 23071.428, 23087.861, 23104.299, 23120.738, 23137.182, 23153.627, 23170.076, 23186.527, 23202.982, 23219.44, 23235.9, 23252.363, 23268.83, 23285.299, 23301.77, 23318.246, 23334.723, 23351.203, 23367.688, 23384.174, 23400.664, 23417.156, 23433.652, 23450.15, 23466.65, 23483.154, 23499.662, 23516.172, 23532.684, 23549.2, 23565.719, 23582.24, 23598.764, 23615.291, 23631.822, 23648.354, 23664.89, 23681.43, 23697.97, 23714.516, 23731.062, 23747.613, 23764.166, 23780.723, 23797.281, 23813.844, 23830.408, 23846.975, 23863.545, 23880.12, 23896.695, 23913.273, 23929.855, 23946.441, 23963.03, 23979.62, 23996.213, 24012.809, 24029.408, 24046.01, 24062.615, 24079.223, 24095.834, 24112.447, 24129.064, 24145.684, 24162.305, 24178.93, 24195.559, 24212.19, 24228.822, 24245.459, 24262.098, 24278.74, 24295.385, 24312.033, 24328.684, 24345.336, 24361.992, 24378.652, 24395.314, 24411.979, 24428.646, 24445.318, 24461.99, 24478.668, 24495.346, 24512.027, 24528.713, 24545.4, 24562.092, 24578.785, 24595.48, 24612.18, 24628.88, 24645.586, 24662.293, 24679.004, 24695.717, 24712.434, 24729.152, 24745.873, 24762.598, 24779.324, 24796.055, 24812.787, 24829.523, 24846.262, 24863.004, 24879.748, 24896.494, 24913.244, 24929.996, 24946.752, 24963.51, 24980.271, 24997.035, 25013.803, 25030.572, 25047.344, 25064.12, 25080.896, 25097.678, 25114.46, 25131.248, 25148.037, 25164.828, 25181.623, 25198.422, 25215.22, 25232.025, 25248.83, 25265.639, 25282.451, 25299.266, 25316.082, 25332.902, 25349.725, 25366.55, 25383.379, 25400.209, 25417.043, 25433.88, 25450.719, 25467.562, 25484.406, 25501.254, 25518.105, 25534.959, 25551.814, 25568.674, 25585.535, 25602.4, 25619.268, 25636.137, 25653.01, 25669.885, 25686.764, 25703.645, 25720.53, 25737.416, 25754.305, 25771.197, 25788.092, 25804.99, 25821.89, 25838.795, 25855.7, 25872.61, 25889.52, 25906.436, 25923.352, 25940.271, 25957.195, 25974.12, 25991.049, 26007.979, 26024.912, 26041.85, 26058.787, 26075.73, 26092.674, 26109.623, 26126.572, 26143.525, 26160.48, 26177.44, 26194.4, 26211.365, 26228.33, 26245.3, 26262.273, 26279.248, 26296.225, 26313.205, 26330.19, 26347.174, 26364.162, 26381.154, 26398.148, 26415.145, 26432.145, 26449.146, 26466.152, 26483.16, 26500.17, 26517.184, 26534.2, 26551.219, 26568.24, 26585.264, 26602.291, 26619.32, 26636.352, 26653.387, 26670.424, 26687.465, 26704.508, 26721.555, 26738.604, 26755.654, 26772.709, 26789.766, 26806.824, 26823.887, 26840.951, 26858.02, 26875.09, 26892.162, 26909.238, 26926.316, 26943.398, 26960.482, 26977.568, 26994.658, 27011.75, 27028.844, 27045.941, 27063.041, 27080.145, 27097.25, 27114.357, 27131.469, 27148.582, 27165.7, 27182.818, 27199.94, 27217.064, 27234.191, 27251.32, 27268.453, 27285.588, 27302.727, 27319.867, 27337.01, 27354.156, 27371.305, 27388.455, 27405.61, 27422.766, 27439.926, 27457.088, 27474.252, 27491.42, 27508.59, 27525.764, 27542.938, 27560.117, 27577.297, 27594.48, 27611.666, 27628.855, 27646.047, 27663.24, 27680.438, 27697.637, 27714.84, 27732.045, 27749.252, 27766.463, 27783.676, 27800.89, 27818.11, 27835.33, 27852.553, 27869.78, 27887.008, 27904.24, 27921.473, 27938.71, 27955.95, 27973.191, 27990.438, 28007.684, 28024.934, 28042.188, 28059.443, 28076.701, 28093.96, 28111.225, 28128.49, 28145.76, 28163.031, 28180.305, 28197.582, 28214.861, 28232.143, 28249.428, 28266.715, 28284.004, 28301.297, 28318.592, 28335.889, 28353.19, 28370.492, 28387.799, 28405.107, 28422.418, 28439.73, 28457.047, 28474.367, 28491.688, 28509.012, 28526.338, 28543.668, 28561.0, 28578.334, 28595.672, 28613.012, 28630.354, 28647.7, 28665.047, 28682.398, 28699.75, 28717.105, 28734.465, 28751.826, 28769.19, 28786.555, 28803.924, 28821.295, 28838.67, 28856.047, 28873.426, 28890.807, 28908.191, 28925.578, 28942.969, 28960.361, 28977.756, 28995.152, 29012.553, 29029.955, 29047.361, 29064.77, 29082.18, 29099.594, 29117.01, 29134.428, 29151.848, 29169.271, 29186.697, 29204.127, 29221.559, 29238.992, 29256.43, 29273.867, 29291.31, 29308.754, 29326.201, 29343.65, 29361.104, 29378.559, 29396.016, 29413.475, 29430.938, 29448.402, 29465.871, 29483.34, 29500.814, 29518.29, 29535.768, 29553.248, 29570.73, 29588.217, 29605.705, 29623.197, 29640.69, 29658.186, 29675.686, 29693.186, 29710.69, 29728.197, 29745.705, 29763.217, 29780.73, 29798.248, 29815.768, 29833.29, 29850.814, 29868.342, 29885.871, 29903.402, 29920.938, 29938.475, 29956.016, 29973.557, 29991.104, 30008.65, 30026.201, 30043.754, 30061.309, 30078.867, 30096.428, 30113.99, 30131.555, 30149.123, 30166.695, 30184.268, 30201.844, 30219.422, 30237.002, 30254.586, 30272.172, 30289.762, 30307.352, 30324.945, 30342.543, 30360.14, 30377.742, 30395.346, 30412.953, 30430.562, 30448.174, 30465.787, 30483.404, 30501.023, 30518.645, 30536.27, 30553.896, 30571.525, 30589.156, 30606.791, 30624.428, 30642.068, 30659.71, 30677.355, 30695.002, 30712.652, 30730.305, 30747.959, 30765.615, 30783.275, 30800.938, 30818.604, 30836.27, 30853.94, 30871.613, 30889.287, 30906.965, 30924.645, 30942.328, 30960.014, 30977.701, 30995.39, 31013.084, 31030.78, 31048.477, 31066.178, 31083.879, 31101.584, 31119.293, 31137.004, 31154.717, 31172.432, 31190.148, 31207.87, 31225.592, 31243.318, 31261.047, 31278.777, 31296.51, 31314.244, 31331.982, 31349.723, 31367.467, 31385.213, 31402.96, 31420.71, 31438.463, 31456.219, 31473.977, 31491.738, 31509.502, 31527.268, 31545.035, 31562.805, 31580.578, 31598.354, 31616.133, 31633.912, 31651.695, 31669.482, 31687.27, 31705.06, 31722.854, 31740.648, 31758.447, 31776.248, 31794.05, 31811.855, 31829.664, 31847.475, 31865.287, 31883.104, 31900.922, 31918.742, 31936.564, 31954.39, 31972.219, 31990.049, 32007.88, 32025.717, 32043.555, 32061.395, 32079.238, 32097.084, 32114.932, 32132.781, 32150.635, 32168.49, 32186.348, 32204.207, 32222.07, 32239.936, 32257.803, 32275.674, 32293.545, 32311.422, 32329.299, 32347.178, 32365.06, 32382.945, 32400.834, 32418.723, 32436.615, 32454.51, 32472.408, 32490.307, 32508.209, 32526.115, 32544.021, 32561.932, 32579.844, 32597.758, 32615.676, 32633.594, 32651.516, 32669.441, 32687.367, 32705.297, 32723.229, 32741.162, 32759.1, 32777.04, 32794.98, 32812.926, 32830.87, 32848.82, 32866.77, 32884.727, 32902.68, 32920.64, 32938.6, 32956.566, 32974.53, 32992.5, 33010.47, 33028.445, 33046.418, 33064.4, 33082.38, 33100.363, 33118.348, 33136.336, 33154.33, 33172.32, 33190.316, 33208.312, 33226.312, 33244.316, 33262.32, 33280.33, 33298.34, 33316.35, 33334.367, 33352.383, 33370.402, 33388.426, 33406.45, 33424.477, 33442.508, 33460.54, 33478.574, 33496.61, 33514.65, 33532.69, 33550.734, 33568.78, 33586.832, 33604.883, 33622.934, 33640.992, 33659.05, 33677.11, 33695.176, 33713.242, 33731.31, 33749.38, 33767.453, 33785.527, 33803.605, 33821.688, 33839.77, 33857.855, 33875.94, 33894.03, 33912.125, 33930.22, 33948.316, 33966.418, 33984.52, 34002.625, 34020.73, 34038.84, 34056.953, 34075.066, 34093.184, 34111.3, 34129.42, 34147.547, 34165.67, 34183.8, 34201.934, 34220.066, 34238.203, 34256.34, 34274.48, 34292.625, 34310.77, 34328.918, 34347.066, 34365.22, 34383.375, 34401.53, 34419.69, 34437.855, 34456.02, 34474.188, 34492.355, 34510.527, 34528.703, 34546.88, 34565.06, 34583.24, 34601.42, 34619.61, 34637.797, 34655.99, 34674.184, 34692.38, 34710.574, 34728.777, 34746.98, 34765.184, 34783.39, 34801.6, 34819.812, 34838.027, 34856.246, 34874.465, 34892.688, 34910.91, 34929.137, 34947.367, 34965.598, 34983.832, 35002.07, 35020.31, 35038.547, 35056.793, 35075.04, 35093.285, 35111.535, 35129.79, 35148.043, 35166.3, 35184.562, 35202.824, 35221.09, 35239.355, 35257.625, 35275.895, 35294.17, 35312.445, 35330.727, 35349.008, 35367.29, 35385.58, 35403.863, 35422.156, 35440.45, 35458.742, 35477.043, 35495.34, 35513.645, 35531.95, 35550.258, 35568.566, 35586.88, 35605.19, 35623.508, 35641.83, 35660.15, 35678.473, 35696.797, 35715.125, 35733.457, 35751.79, 35770.125, 35788.465, 35806.805, 35825.145, 35843.492, 35861.84, 35880.188, 35898.54, 35916.895, 35935.25, 35953.61, 35971.97, 35990.336, 36008.7, 36027.07, 36045.438, 36063.812, 36082.188, 36100.566, 36118.945, 36137.33, 36155.71, 36174.098, 36192.49, 36210.88, 36229.273, 36247.67, 36266.07, 36284.47, 36302.875, 36321.277, 36339.688, 36358.098, 36376.51, 36394.926, 36413.344, 36431.76, 36450.184, 36468.61, 36487.035, 36505.465, 36523.895, 36542.33, 36560.766, 36579.203, 36597.645, 36616.086, 36634.53, 36652.98, 36671.43, 36689.883, 36708.336, 36726.793, 36745.25, 36763.715, 36782.176, 36800.645, 36819.113, 36837.582, 36856.055, 36874.53, 36893.008, 36911.49, 36929.97, 36948.457, 36966.94, 36985.43, 37003.92, 37022.418, 37040.914, 37059.41, 37077.914, 37096.414, 37114.92, 37133.43, 37151.938, 37170.45, 37188.965, 37207.48, 37226.0, 37244.523, 37263.047, 37281.574, 37300.1, 37318.633, 37337.164, 37355.7, 37374.24, 37392.777, 37411.32, 37429.867, 37448.41, 37466.96, 37485.51, 37504.066, 37522.62, 37541.18, 37559.742, 37578.305, 37596.87, 37615.438, 37634.008, 37652.58, 37671.152, 37689.73, 37708.31, 37726.89, 37745.473, 37764.06, 37782.65, 37801.24, 37819.832, 37838.426, 37857.023, 37875.62, 37894.223, 37912.83, 37931.434, 37950.043, 37968.656, 37987.266, 38005.883, 38024.5, 38043.12, 38061.742, 38080.367, 38098.996, 38117.625, 38136.254, 38154.89, 38173.523, 38192.164, 38210.805, 38229.445, 38248.094, 38266.74, 38285.39, 38304.04, 38322.695, 38341.35, 38360.01, 38378.67, 38397.336, 38416.0, 38434.668, 38453.336, 38472.01, 38490.684, 38509.363, 38528.04, 38546.723, 38565.406, 38584.09, 38602.78, 38621.47, 38640.164, 38658.86, 38677.555, 38696.254, 38714.957, 38733.66, 38752.367, 38771.074, 38789.785, 38808.5, 38827.215, 38845.934, 38864.652, 38883.375, 38902.098, 38920.824, 38939.555, 38958.285, 38977.02, 38995.754, 39014.492, 39033.23, 39051.973, 39070.72, 39089.465, 39108.215, 39126.965, 39145.72, 39164.477, 39183.234, 39201.992, 39220.754, 39239.52, 39258.29, 39277.06, 39295.83, 39314.6, 39333.38, 39352.156, 39370.938, 39389.72, 39408.504, 39427.293, 39446.082, 39464.87, 39483.668, 39502.465, 39521.26, 39540.062, 39558.863, 39577.67, 39596.477, 39615.285, 39634.098, 39652.914, 39671.73, 39690.547, 39709.367, 39728.19, 39747.016, 39765.844, 39784.67, 39803.504, 39822.34, 39841.176, 39860.016, 39878.855, 39897.7, 39916.543, 39935.39, 39954.242, 39973.094, 39991.945, 40010.8, 40029.66, 40048.523, 40067.387, 40086.25, 40105.117, 40123.99, 40142.86, 40161.734, 40180.61, 40199.49, 40218.367, 40237.25, 40256.137, 40275.023, 40293.914, 40312.805, 40331.7, 40350.598, 40369.496, 40388.395, 40407.297, 40426.203, 40445.11, 40464.02, 40482.934, 40501.848, 40520.76, 40539.68, 40558.6, 40577.523, 40596.45, 40615.375, 40634.305, 40653.24, 40672.17, 40691.105, 40710.043, 40728.984, 40747.93, 40766.87, 40785.82, 40804.77, 40823.72, 40842.676, 40861.63, 40880.586, 40899.547, 40918.51, 40937.477, 40956.44, 40975.41, 40994.383, 41013.355, 41032.332, 41051.31, 41070.29, 41089.27, 41108.254, 41127.242, 41146.23, 41165.223, 41184.215, 41203.21, 41222.207, 41241.207, 41260.21, 41279.215, 41298.22, 41317.227, 41336.24, 41355.25, 41374.266, 41393.285, 41412.305, 41431.324, 41450.348, 41469.375, 41488.402, 41507.434, 41526.465, 41545.5, 41564.535, 41583.574, 41602.617, 41621.66, 41640.707, 41659.754, 41678.805, 41697.855, 41716.91, 41735.965, 41755.023, 41774.086, 41793.15, 41812.215, 41831.28, 41850.35, 41869.42, 41888.496, 41907.57, 41926.65, 41945.73, 41964.812, 41983.9, 42002.984, 42022.074, 42041.164, 42060.258, 42079.35, 42098.45, 42117.55, 42136.652, 42155.758, 42174.863, 42193.973, 42213.082, 42232.195, 42251.31, 42270.426, 42289.547, 42308.668, 42327.793, 42346.918, 42366.047, 42385.176, 42404.31, 42423.44, 42442.58, 42461.72, 42480.86, 42500.0, 42519.15, 42538.293, 42557.445, 42576.594, 42595.75, 42614.906, 42634.062, 42653.223, 42672.387, 42691.55, 42710.72, 42729.887, 42749.06, 42768.23, 42787.406, 42806.582, 42825.76, 42844.945, 42864.13, 42883.316, 42902.504, 42921.695, 42940.887, 42960.082, 42979.277, 42998.477, 43017.68, 43036.883, 43056.086, 43075.293, 43094.504, 43113.715, 43132.93, 43152.145, 43171.363, 43190.586, 43209.81, 43229.03, 43248.258, 43267.49, 43286.72, 43305.953, 43325.188, 43344.426, 43363.664, 43382.906, 43402.15, 43421.395, 43440.645, 43459.895, 43479.145, 43498.402, 43517.656, 43536.918, 43556.176, 43575.44, 43594.707, 43613.973, 43633.242, 43652.516, 43671.79, 43691.062, 43710.34, 43729.62, 43748.902, 43768.188, 43787.473, 43806.76, 43826.055, 43845.348, 43864.64, 43883.938, 43903.24, 43922.54, 43941.844, 43961.15, 43980.457, 43999.766, 44019.08, 44038.39, 44057.707, 44077.027, 44096.348, 44115.668, 44134.992, 44154.32, 44173.65, 44192.98, 44212.312, 44231.65, 44250.984, 44270.324, 44289.668, 44309.008, 44328.355, 44347.703, 44367.055, 44386.406, 44405.758, 44425.117, 44444.473, 44463.836, 44483.2, 44502.562, 44521.93, 44541.297, 44560.668, 44580.043, 44599.418, 44618.793, 44638.176, 44657.555, 44676.938, 44696.324, 44715.715, 44735.1, 44754.496, 44773.89, 44793.285, 44812.684, 44832.086, 44851.49, 44870.89, 44890.297, 44909.707, 44929.117, 44948.53, 44967.945, 44987.363, 45006.78, 45026.203, 45045.63, 45065.055, 45084.48, 45103.91, 45123.344, 45142.777, 45162.215, 45181.652, 45201.094, 45220.535, 45239.98, 45259.426, 45278.875, 45298.324, 45317.777, 45337.23, 45356.688, 45376.15, 45395.61, 45415.074, 45434.54, 45454.004, 45473.477, 45492.945, 45512.42, 45531.895, 45551.375, 45570.855, 45590.336, 45609.82, 45629.305, 45648.793, 45668.285, 45687.777, 45707.273, 45726.77, 45746.266, 45765.77, 45785.27, 45804.773, 45824.28, 45843.793, 45863.3, 45882.816, 45902.332, 45921.848, 45941.367, 45960.89, 45980.414, 45999.938, 46019.465, 46038.996, 46058.527, 46078.062, 46097.598, 46117.137, 46136.676, 46156.22, 46175.76, 46195.31, 46214.855, 46234.406, 46253.96, 46273.516, 46293.07, 46312.63, 46332.19, 46351.754, 46371.32, 46390.887, 46410.453, 46430.027, 46449.598, 46469.176, 46488.75, 46508.332, 46527.91, 46547.496, 46567.082, 46586.668, 46606.258, 46625.85, 46645.445, 46665.04, 46684.637, 46704.24, 46723.84, 46743.445, 46763.05, 46782.656, 46802.27, 46821.88, 46841.496, 46861.11, 46880.73, 46900.35, 46919.973, 46939.598, 46959.223, 46978.85, 46998.484, 47018.117, 47037.75, 47057.387, 47077.027, 47096.668, 47116.312, 47135.957, 47155.6, 47175.254, 47194.902, 47214.56, 47234.21, 47253.87, 47273.527, 47293.19, 47312.855, 47332.52, 47352.188, 47371.855, 47391.527, 47411.203, 47430.88, 47450.555, 47470.234, 47489.918, 47509.6, 47529.29, 47548.977, 47568.664, 47588.355, 47608.05, 47627.746, 47647.445, 47667.145, 47686.848, 47706.55, 47726.258, 47745.97, 47765.676, 47785.39, 47805.105, 47824.82, 47844.54, 47864.26, 47883.984, 47903.707, 47923.434, 47943.164, 47962.895, 47982.625, 48002.36, 48022.098, 48041.836, 48061.58, 48081.32, 48101.066, 48120.812, 48140.562, 48160.312, 48180.066, 48199.82, 48219.58, 48239.336, 48259.098, 48278.86, 48298.625, 48318.395, 48338.16, 48357.934, 48377.707, 48397.48, 48417.258, 48437.04, 48456.82, 48476.6, 48496.387, 48516.176, 48535.965, 48555.758, 48575.55, 48595.344, 48615.145, 48634.94, 48654.742, 48674.547, 48694.35, 48714.16, 48733.97, 48753.78, 48773.594, 48793.41, 48813.227, 48833.047, 48852.87, 48872.69, 48892.52, 48912.348, 48932.176, 48952.008, 48971.84, 48991.676, 49011.516, 49031.355, 49051.195, 49071.04, 49090.887, 49110.734, 49130.582, 49150.434, 49170.29, 49190.145, 49210.004, 49229.863, 49249.723, 49269.586, 49289.453, 49309.32, 49329.19, 49349.062, 49368.938, 49388.812, 49408.69, 49428.57, 49448.453, 49468.336, 49488.223, 49508.11, 49528.0, 49547.89, 49567.785, 49587.68, 49607.58, 49627.477, 49647.38, 49667.28, 49687.188, 49707.098, 49727.008, 49746.918, 49766.832, 49786.746, 49806.664, 49826.586, 49846.508, 49866.43, 49886.355, 49906.28, 49926.21, 49946.145, 49966.08, 49986.01, 50005.95, 50025.89, 50045.832, 50065.777, 50085.723, 50105.668, 50125.617, 50145.57, 50165.523, 50185.48, 50205.438, 50225.395, 50245.355, 50265.32, 50285.285, 50305.254, 50325.223, 50345.195, 50365.168, 50385.14, 50405.12, 50425.098, 50445.08, 50465.062, 50485.047, 50505.035, 50525.023, 50545.016, 50565.008, 50585.004, 50605.0, 50625.0, 50645.0, 50665.004, 50685.008, 50705.016, 50725.023, 50745.035, 50765.047, 50785.062, 50805.08, 50825.098, 50845.12, 50865.14, 50885.168, 50905.195, 50925.223, 50945.254, 50965.285, 50985.32, 51005.355, 51025.395, 51045.434, 51065.477, 51085.523, 51105.566, 51125.617, 51145.668, 51165.72, 51185.773, 51205.83, 51225.887, 51245.945, 51266.008, 51286.074, 51306.14, 51326.207, 51346.277, 51366.348, 51386.42, 51406.5, 51426.574, 51446.656, 51466.74, 51486.82, 51506.906, 51526.992, 51547.082, 51567.176, 51587.27, 51607.363, 51627.46, 51647.56, 51667.66, 51687.766, 51707.87, 51727.977, 51748.086, 51768.195, 51788.31, 51808.426, 51828.543, 51848.66, 51868.78, 51888.902, 51909.027, 51929.156, 51949.285, 51969.414, 51989.547, 52009.68, 52029.816, 52049.957, 52070.098, 52090.24, 52110.383, 52130.527, 52150.676, 52170.83, 52190.977, 52211.133, 52231.29, 52251.445, 52271.605, 52291.766, 52311.93, 52332.098, 52352.266, 52372.434, 52392.605, 52412.777, 52432.953, 52453.13, 52473.31, 52493.492, 52513.67, 52533.86, 52554.047, 52574.234, 52594.426, 52614.617, 52634.812, 52655.008, 52675.207, 52695.406, 52715.61, 52735.816, 52756.02, 52776.23, 52796.438, 52816.652, 52836.863, 52857.082, 52877.3, 52897.52, 52917.742, 52937.965, 52958.19, 52978.418, 52998.65, 53018.88, 53039.113, 53059.348, 53079.582, 53099.824, 53120.062, 53140.31, 53160.55, 53180.797, 53201.047, 53221.297, 53241.55, 53261.805, 53282.062, 53302.32, 53322.582, 53342.844, 53363.105, 53383.37, 53403.64, 53423.91, 53444.184, 53464.457, 53484.73, 53505.008, 53525.29, 53545.57, 53565.855, 53586.14, 53606.426, 53626.715, 53647.008, 53667.3, 53687.594, 53707.89, 53728.19, 53748.492, 53768.793, 53789.098, 53809.402, 53829.71, 53850.023, 53870.336, 53890.65, 53910.965, 53931.28, 53951.6, 53971.926, 53992.246, 54012.574, 54032.902, 54053.23, 54073.562, 54093.895, 54114.23, 54134.566, 54154.906, 54175.246, 54195.59, 54215.934, 54236.28, 54256.63, 54276.98, 54297.332, 54317.688, 54338.043, 54358.4, 54378.758, 54399.12, 54419.484, 54439.85, 54460.22, 54480.586, 54500.96, 54521.332, 54541.707, 54562.086, 54582.465, 54602.844, 54623.227, 54643.613, 54664.0, 54684.387, 54704.777, 54725.168, 54745.562, 54765.96, 54786.36, 54806.758, 54827.16, 54847.562, 54867.97, 54888.375, 54908.785, 54929.195, 54949.61, 54970.023, 54990.44, 55010.86, 55031.28, 55051.703, 55072.13, 55092.555, 55112.984, 55133.414, 55153.844, 55174.277, 55194.715, 55215.152, 55235.594, 55256.035, 55276.477, 55296.92, 55317.37, 55337.82, 55358.27, 55378.723, 55399.176, 55419.633, 55440.094, 55460.555, 55481.016, 55501.48, 55521.945, 55542.414, 55562.883, 55583.355, 55603.83, 55624.305, 55644.78, 55665.26, 55685.742, 55706.227, 55726.71, 55747.2, 55767.688, 55788.176, 55808.668, 55829.164, 55849.66, 55870.156, 55890.656, 55911.16, 55931.664, 55952.168, 55972.676, 55993.188, 56013.695, 56034.21, 56054.727, 56075.242, 56095.76, 56116.28, 56136.805, 56157.33, 56177.855, 56198.383, 56218.914, 56239.445, 56259.98, 56280.516, 56301.05, 56321.59, 56342.133, 56362.676, 56383.22, 56403.766, 56424.316, 56444.867, 56465.418, 56485.973, 56506.53, 56527.09, 56547.65, 56568.21, 56588.773, 56609.34, 56629.906, 56650.477, 56671.047, 56691.62, 56712.195, 56732.773, 56753.35, 56773.93, 56794.51, 56815.098, 56835.684, 56856.273, 56876.863, 56897.453, 56918.047, 56938.64, 56959.24, 56979.84, 57000.44, 57021.043, 57041.65, 57062.254, 57082.863, 57103.473, 57124.086, 57144.7, 57165.316, 57185.934, 57206.55, 57227.176, 57247.797, 57268.42, 57289.05, 57309.68, 57330.31, 57350.94, 57371.574, 57392.21, 57412.85, 57433.492, 57454.133, 57474.777, 57495.42, 57516.07, 57536.72, 57557.37, 57578.023, 57598.68, 57619.336, 57639.992, 57660.652, 57681.316, 57701.98, 57722.645, 57743.312, 57763.984, 57784.656, 57805.33, 57826.004, 57846.68, 57867.36, 57888.04, 57908.723, 57929.406, 57950.094, 57970.78, 57991.473, 58012.164, 58032.855, 58053.555, 58074.25, 58094.95, 58115.652, 58136.35, 58157.06, 58177.766, 58198.473, 58219.184, 58239.895, 58260.61, 58281.324, 58302.043, 58322.76, 58343.484, 58364.207, 58384.934, 58405.66, 58426.387, 58447.117, 58467.85, 58488.586, 58509.32, 58530.06, 58550.797, 58571.54, 58592.28, 58613.027, 58633.773, 58654.523, 58675.273, 58696.027, 58716.78, 58737.54, 58758.297, 58779.055, 58799.816, 58820.582, 58841.348, 58862.113, 58882.883, 58903.652, 58924.426, 58945.203, 58965.977, 58986.758, 59007.535, 59028.316, 59049.1, 59069.887, 59090.676, 59111.465, 59132.254, 59153.047, 59173.844, 59194.637, 59215.438, 59236.24, 59257.04, 59277.844, 59298.65, 59319.457, 59340.266, 59361.08, 59381.89, 59402.703, 59423.52, 59444.34, 59465.16, 59485.98, 59506.805, 59527.63, 59548.457, 59569.29, 59590.117, 59610.953, 59631.785, 59652.625, 59673.46, 59694.3, 59715.145, 59735.99, 59756.832, 59777.68, 59798.53, 59819.383, 59840.234, 59861.09, 59881.945, 59902.805, 59923.664, 59944.527, 59965.39, 59986.258, 60007.125, 60027.992, 60048.863, 60069.74, 60090.613, 60111.49, 60132.367, 60153.246, 60174.13, 60195.01, 60215.9, 60236.785, 60257.676, 60278.566, 60299.46, 60320.355, 60341.25, 60362.15, 60383.05, 60403.95, 60424.855, 60445.76, 60466.668, 60487.58, 60508.49, 60529.4, 60550.316, 60571.23, 60592.15, 60613.07, 60633.992, 60654.914, 60675.84, 60696.766, 60717.695, 60738.63, 60759.56, 60780.496, 60801.43, 60822.367, 60843.31, 60864.25, 60885.195, 60906.14, 60927.086, 60948.035, 60968.984, 60989.938, 61010.89, 61031.848, 61052.805, 61073.766, 61094.727, 61115.69, 61136.656, 61157.62, 61178.59, 61199.562, 61220.535, 61241.508, 61262.484, 61283.46, 61304.44, 61325.42, 61346.406, 61367.39, 61388.375, 61409.363, 61430.355, 61451.348, 61472.34, 61493.336, 61514.332, 61535.332, 61556.332, 61577.336, 61598.34, 61619.348, 61640.355, 61661.363, 61682.375, 61703.39, 61724.406, 61745.42, 61766.44, 61787.46, 61808.484, 61829.508, 61850.535, 61871.562, 61892.59, 61913.62, 61934.656, 61955.69, 61976.727, 61997.766, 62018.805, 62039.848, 62060.89, 62081.938, 62102.984, 62124.035, 62145.086, 62166.137, 62187.19, 62208.25, 62229.31, 62250.367, 62271.43, 62292.492, 62313.56, 62334.625, 62355.69, 62376.76, 62397.836, 62418.91, 62439.984, 62461.062, 62482.145, 62503.223, 62524.31, 62545.39, 62566.477, 62587.566, 62608.656, 62629.75, 62650.844, 62671.938, 62693.035, 62714.133, 62735.234, 62756.336, 62777.44, 62798.547, 62819.656, 62840.766, 62861.875, 62882.99, 62904.105, 62925.223, 62946.34, 62967.46, 62988.582, 63009.707, 63030.832, 63051.96, 63073.09, 63094.22, 63115.35, 63136.484, 63157.62, 63178.76, 63199.9, 63221.043, 63242.184, 63263.33, 63284.477, 63305.625, 63326.777, 63347.93, 63369.082, 63390.24, 63411.395, 63432.555, 63453.715, 63474.88, 63496.043, 63517.207, 63538.375, 63559.547, 63580.72, 63601.89, 63623.066, 63644.242, 63665.42, 63686.6, 63707.785, 63728.97, 63750.152, 63771.34, 63792.53, 63813.72, 63834.914, 63856.11, 63877.305, 63898.5, 63919.703, 63940.902, 63962.105, 63983.312, 64004.52, 64025.727, 64046.938, 64068.15, 64089.363, 64110.58, 64131.793, 64153.016, 64174.234, 64195.457, 64216.68, 64237.906, 64259.137, 64280.363, 64301.598, 64322.83, 64344.062, 64365.3, 64386.54, 64407.777, 64429.02, 64450.266, 64471.508, 64492.758, 64514.004, 64535.254, 64556.508, 64577.76, 64599.02, 64620.277, 64641.535, 64662.797, 64684.06, 64705.324, 64726.59, 64747.86, 64769.13, 64790.4, 64811.67, 64832.945, 64854.223, 64875.504, 64896.78, 64918.066, 64939.348, 64960.633, 64981.92, 65003.21, 65024.5, 65045.793, 65067.086, 65088.383, 65109.68, 65130.98, 65152.28, 65173.586, 65194.89, 65216.195, 65237.504, 65258.812, 65280.125, 65301.438, 65322.754, 65344.07, 65365.39, 65386.71, 65408.03, 65429.355, 65450.68, 65472.008, 65493.336, 65514.668, 65536.0, 65557.336, 65578.67, 65600.01, 65621.34, 65642.69, 65664.03, 65685.375, 65706.72, 65728.07, 65749.42, 65770.77, 65792.125, 65813.48, 65834.836, 65856.195, 65877.555, 65898.914, 65920.28, 65941.65, 65963.016, 65984.38, 66005.75, 66027.125, 66048.5, 66069.875, 66091.25, 66112.63, 66134.016, 66155.4, 66176.78, 66198.164, 66219.555, 66240.945, 66262.336, 66283.73, 66305.125, 66326.516, 66347.914, 66369.32, 66390.72, 66412.125, 66433.53, 66454.94, 66476.34, 66497.75, 66519.164, 66540.58, 66561.99, 66583.414, 66604.83, 66626.25, 66647.67, 66669.1, 66690.52, 66711.95, 66733.38, 66754.81, 66776.24, 66797.68, 66819.12, 66840.555, 66861.99, 66883.44, 66904.875, 66926.32, 66947.766, 66969.22, 66990.664, 67012.12, 67033.57, 67055.02, 67076.484, 67097.94, 67119.4, 67140.86, 67162.33, 67183.79, 67205.26, 67226.73, 67248.195, 67269.67, 67291.14, 67312.62, 67334.09, 67355.58, 67377.055, 67398.54, 67420.02, 67441.51, 67463.0, 67484.484, 67505.98, 67527.47, 67548.96, 67570.46, 67591.96, 67613.46, 67634.96, 67656.46, 67677.97, 67699.48, 67720.984, 67742.49, 67764.0, 67785.516, 67807.03, 67828.55, 67850.06, 67871.586, 67893.11, 67914.63, 67936.16, 67957.69, 67979.21, 68000.74, 68022.27, 68043.805, 68065.34, 68086.88, 68108.42, 68129.96, 68151.5, 68173.05, 68194.59, 68216.14, 68237.69, 68259.24, 68280.79, 68302.34, 68323.9, 68345.46, 68367.016, 68388.58, 68410.14, 68431.7, 68453.27, 68474.836, 68496.41, 68517.98, 68539.555, 68561.125, 68582.7, 68604.28, 68625.86, 68647.445, 68669.02, 68690.61, 68712.195, 68733.78, 68755.375, 68776.97, 68798.56, 68820.16, 68841.75, 68863.35, 68884.945, 68906.55, 68928.16, 68949.76, 68971.37, 68992.98, 69014.586, 69036.195, 69057.81, 69079.42, 69101.04, 69122.664, 69144.28, 69165.91, 69187.52, 69209.15, 69230.78, 69252.41, 69274.04, 69295.67, 69317.305, 69338.94, 69360.58, 69382.21, 69403.85, 69425.5, 69447.14, 69468.79, 69490.44, 69512.086, 69533.734, 69555.38, 69577.04, 69598.695, 69620.35, 69642.016, 69663.67, 69685.336, 69707.0, 69728.664, 69750.336, 69772.0, 69793.67, 69815.34, 69837.02, 69858.695, 69880.375, 69902.055, 69923.734, 69945.414, 69967.1, 69988.79, 70010.48, 70032.164, 70053.85, 70075.55, 70097.24, 70118.94, 70140.63, 70162.336, 70184.04, 70205.74, 70227.445, 70249.15, 70270.86, 70292.56, 70314.27, 70335.99, 70357.7, 70379.42, 70401.14, 70422.86, 70444.58, 70466.305, 70488.02, 70509.75, 70531.484, 70553.21, 70574.945, 70596.67, 70618.41, 70640.15, 70661.88, 70683.625, 70705.37, 70727.11, 70748.85, 70770.6, 70792.34, 70814.09, 70835.84, 70857.6, 70879.35, 70901.11, 70922.87, 70944.625, 70966.39, 70988.16, 71009.914, 71031.69, 71053.45, 71075.22, 71096.99, 71118.766, 71140.54, 71162.32, 71184.09, 71205.875, 71227.66, 71249.44, 71271.23, 71293.01, 71314.8, 71336.586, 71358.375, 71380.17, 71401.97, 71423.766, 71445.56, 71467.36, 71489.164, 71510.96, 71532.766, 71554.58, 71576.38, 71598.195, 71620.01, 71641.82, 71663.63, 71685.445, 71707.266, 71729.086, 71750.91, 71772.73, 71794.555, 71816.38, 71838.21, 71860.04, 71881.87, 71903.7, 71925.54, 71947.375, 71969.21, 71991.05, 72012.89, 72034.734, 72056.58, 72078.42, 72100.27, 72122.125, 72143.97, 72165.83, 72187.68, 72209.54, 72231.39, 72253.25, 72275.12, 72296.98, 72318.84, 72340.7, 72362.57, 72384.445, 72406.31, 72428.19, 72450.06, 72471.94, 72493.81, 72515.695, 72537.57, 72559.45, 72581.34, 72603.23, 72625.12, 72647.0, 72668.89, 72690.79, 72712.68, 72734.58, 72756.47, 72778.375, 72800.27, 72822.17, 72844.08, 72865.984, 72887.89, 72909.8, 72931.71, 72953.625, 72975.54, 72997.45, 73019.37, 73041.29, 73063.21, 73085.13, 73107.055, 73128.98, 73150.91, 73172.836, 73194.766, 73216.695, 73238.63, 73260.56, 73282.5, 73304.44, 73326.38, 73348.32, 73370.266, 73392.21, 73414.16, 73436.1, 73458.055, 73480.01, 73501.96, 73523.914, 73545.87, 73567.83, 73589.79, 73611.75, 73633.71, 73655.68, 73677.64, 73699.61, 73721.58, 73743.555, 73765.52, 73787.5, 73809.48, 73831.45, 73853.43, 73875.414, 73897.4, 73919.38, 73941.37, 73963.35, 73985.34, 74007.336, 74029.33, 74051.32, 74073.31, 74095.31, 74117.31, 74139.31, 74161.31, 74183.32, 74205.33, 74227.33, 74249.34, 74271.35, 74293.36, 74315.375, 74337.39, 74359.41, 74381.43, 74403.445, 74425.47, 74447.49, 74469.516, 74491.55, 74513.57, 74535.6, 74557.63, 74579.664, 74601.7, 74623.74, 74645.77, 74667.82, 74689.86, 74711.9, 74733.945, 74755.99, 74778.04, 74800.086, 74822.14, 74844.195, 74866.25, 74888.305, 74910.36, 74932.42, 74954.484, 74976.55, 74998.61, 75020.67, 75042.74, 75064.81, 75086.88, 75108.95, 75131.02, 75153.1, 75175.18, 75197.26, 75219.336, 75241.42, 75263.5, 75285.586, 75307.67, 75329.766, 75351.85, 75373.945, 75396.04, 75418.13, 75440.23, 75462.33, 75484.43, 75506.53, 75528.63, 75550.734, 75572.84, 75594.95, 75617.06, 75639.17, 75661.28, 75683.4, 75705.516, 75727.63, 75749.75, 75771.875, 75793.99, 75816.12, 75838.24, 75860.37, 75882.5, 75904.63, 75926.766, 75948.9, 75971.03, 75993.17, 76015.305, 76037.445, 76059.586, 76081.734, 76103.875, 76126.02, 76148.17, 76170.32, 76192.47, 76214.625, 76236.78, 76258.94, 76281.09, 76303.25, 76325.414, 76347.58, 76369.74, 76391.91, 76414.08, 76436.24, 76458.414, 76480.586, 76502.76, 76524.94, 76547.12, 76569.29, 76591.47, 76613.66, 76635.836, 76658.02, 76680.21, 76702.4, 76724.586, 76746.78, 76768.98, 76791.164, 76813.37, 76835.56, 76857.766, 76879.96, 76902.164, 76924.37, 76946.58, 76968.78, 76990.99, 77013.2, 77035.414, 77057.63, 77079.84, 77102.06, 77124.28, 77146.5, 77168.73, 77190.945, 77213.17, 77235.4, 77257.625, 77279.86, 77302.09, 77324.32, 77346.555, 77368.8, 77391.03, 77413.27, 77435.516, 77457.76, 77480.0, 77502.25, 77524.49, 77546.74, 77568.99, 77591.25, 77613.5, 77635.76, 77658.016, 77680.27, 77702.53, 77724.8, 77747.055, 77769.32, 77791.586, 77813.86, 77836.125, 77858.4, 77880.67, 77902.945, 77925.23, 77947.5, 77969.78, 77992.06, 78014.34, 78036.625, 78058.914, 78081.2, 78103.49, 78125.78, 78148.07, 78170.37, 78192.664, 78214.96, 78237.26, 78259.555, 78281.86, 78304.164, 78326.47, 78348.77, 78371.086, 78393.39, 78415.7, 78438.016, 78460.33, 78482.65, 78504.97, 78527.28, 78549.6, 78571.93, 78594.25, 78616.58, 78638.91, 78661.234, 78683.56, 78705.9, 78728.23, 78750.56, 78772.9, 78795.234, 78817.58, 78839.92, 78862.266, 78884.61, 78906.95, 78929.3, 78951.65, 78974.0, 78996.35, 79018.71, 79041.06, 79063.42, 79085.78, 79108.14, 79130.5, 79152.87, 79175.23, 79197.59, 79219.96, 79242.336, 79264.7, 79287.08, 79309.45, 79331.83, 79354.21, 79376.586, 79398.97, 79421.35, 79443.734, 79466.12, 79488.51, 79510.9, 79533.29, 79555.68, 79578.07, 79600.47, 79622.86, 79645.26, 79667.664, 79690.06, 79712.47, 79734.87, 79757.27, 79779.68, 79802.09, 79824.5, 79846.914, 79869.33, 79891.74, 79914.164, 79936.58, 79959.0, 79981.42, 80003.84, 80026.27, 80048.695, 80071.125, 80093.555, 80115.984, 80138.42, 80160.85, 80183.29, 80205.73, 80228.164, 80250.61, 80273.05, 80295.49, 80317.94, 80340.38, 80362.836, 80385.28, 80407.734, 80430.19, 80452.64, 80475.1, 80497.555, 80520.016, 80542.48, 80564.945, 80587.41, 80609.875, 80632.336, 80654.805, 80677.28, 80699.75, 80722.23, 80744.695, 80767.17, 80789.66, 80812.13, 80834.62, 80857.1, 80879.586, 80902.07, 80924.555, 80947.05, 80969.54, 80992.03, 81014.52, 81037.016, 81059.516, 81082.016, 81104.516, 81127.016, 81149.516, 81172.02, 81194.53, 81217.04, 81239.55, 81262.055, 81284.57, 81307.086, 81329.6, 81352.12, 81374.63, 81397.16, 81419.68, 81442.2, 81464.73, 81487.26, 81509.78, 81532.31, 81554.84, 81577.375, 81599.914, 81622.445, 81644.984, 81667.52, 81690.06, 81712.61, 81735.15, 81757.695, 81780.24, 81802.79, 81825.34, 81847.89, 81870.445, 81893.0, 81915.555, 81938.11, 81960.67, 81983.234, 82005.8, 82028.36, 82050.92, 82073.49, 82096.06, 82118.63, 82141.2, 82163.77, 82186.35, 82208.93, 82231.51, 82254.086, 82276.664, 82299.25, 82321.83, 82344.414, 82367.01, 82389.59, 82412.19, 82434.77, 82457.37, 82479.96, 82502.56, 82525.16, 82547.76, 82570.36, 82592.96, 82615.56, 82638.17, 82660.78, 82683.39, 82706.0, 82728.61, 82751.23, 82773.836, 82796.45, 82819.07, 82841.695, 82864.31, 82886.94, 82909.56, 82932.19, 82954.81, 82977.445, 83000.07, 83022.7, 83045.336, 83067.98, 83090.61, 83113.25, 83135.89, 83158.53, 83181.17, 83203.82, 83226.46, 83249.11, 83271.76, 83294.414, 83317.06, 83339.72, 83362.37, 83385.03, 83407.69, 83430.34, 83453.01, 83475.67, 83498.336, 83521.0, 83543.664, 83566.336, 83589.01, 83611.68, 83634.35, 83657.03, 83679.7, 83702.38, 83725.06, 83747.74, 83770.43, 83793.11, 83815.8, 83838.484, 83861.17, 83883.87, 83906.555, 83929.25, 83951.945, 83974.64, 83997.336, 84020.04, 84042.74, 84065.445, 84088.15, 84110.85, 84133.56, 84156.266, 84178.98, 84201.69, 84224.41, 84247.12, 84269.836, 84292.555, 84315.27, 84337.99, 84360.72, 84383.445, 84406.164, 84428.9, 84451.625, 84474.35, 84497.086, 84519.82, 84542.555, 84565.29, 84588.03, 84610.766, 84633.51, 84656.25, 84678.99, 84701.74, 84724.484, 84747.234, 84769.984, 84792.74, 84815.49, 84838.25, 84861.0, 84883.76, 84906.52, 84929.28, 84952.05, 84974.805, 84997.57, 85020.336, 85043.11, 85065.875, 85088.65, 85111.42, 85134.195, 85156.98, 85179.75, 85202.53, 85225.31, 85248.09, 85270.875, 85293.664, 85316.445, 85339.234, 85362.02, 85384.82, 85407.61, 85430.41, 85453.2, 85476.0, 85498.8, 85521.6, 85544.4, 85567.2, 85590.01, 85612.81, 85635.625, 85658.43, 85681.24, 85704.055, 85726.87, 85749.69, 85772.5, 85795.32, 85818.14, 85840.96, 85863.79, 85886.61, 85909.44, 85932.266, 85955.09, 85977.92, 86000.76, 86023.59, 86046.43, 86069.266, 86092.1, 86114.945, 86137.78, 86160.625, 86183.47, 86206.32, 86229.164, 86252.016, 86274.87, 86297.72, 86320.57, 86343.42, 86366.28, 86389.14, 86412.0, 86434.86, 86457.72, 86480.586, 86503.45, 86526.32, 86549.19, 86572.055, 86594.93, 86617.805, 86640.68, 86663.555, 86686.43, 86709.31, 86732.19, 86755.07, 86777.95, 86800.84, 86823.73, 86846.62, 86869.51, 86892.4, 86915.29, 86938.19, 86961.08, 86983.98, 87006.875, 87029.77, 87052.68, 87075.586, 87098.484, 87121.39, 87144.305, 87167.21, 87190.125, 87213.03, 87235.945, 87258.87, 87281.78, 87304.695, 87327.62, 87350.54, 87373.46, 87396.39, 87419.31, 87442.24, 87465.17, 87488.1, 87511.03, 87533.97, 87556.9, 87579.836, 87602.77, 87625.71, 87648.66, 87671.59, 87694.54, 87717.484, 87740.43, 87763.38, 87786.33, 87809.28, 87832.234, 87855.19, 87878.15, 87901.1, 87924.06, 87947.02, 87969.984, 87992.945, 88015.914, 88038.88, 88061.85, 88084.82, 88107.79, 88130.76, 88153.734, 88176.71, 88199.69, 88222.664, 88245.65, 88268.625, 88291.61, 88314.59, 88337.58, 88360.57, 88383.555, 88406.55, 88429.54, 88452.53, 88475.52, 88498.52, 88521.52, 88544.52, 88567.52, 88590.52, 88613.52, 88636.53, 88659.54, 88682.55, 88705.555, 88728.57, 88751.58, 88774.59, 88797.61, 88820.625, 88843.65, 88866.664, 88889.69, 88912.71, 88935.734, 88958.766, 88981.79, 89004.82, 89027.85, 89050.88, 89073.914, 89096.95, 89119.984, 89143.02, 89166.06, 89189.11, 89212.15, 89235.195, 89258.24, 89281.29, 89304.336, 89327.38, 89350.44, 89373.49, 89396.54, 89419.6, 89442.66, 89465.72, 89488.77, 89511.836, 89534.9, 89557.97, 89581.03, 89604.1, 89627.17, 89650.24, 89673.31, 89696.38, 89719.46, 89742.54, 89765.62, 89788.695, 89811.77, 89834.86, 89857.945, 89881.03, 89904.12, 89927.2, 89950.3, 89973.39, 89996.48, 90019.58, 90042.67, 90065.766, 90088.87, 90111.97, 90135.07, 90158.17, 90181.28, 90204.38, 90227.49, 90250.6, 90273.71, 90296.83, 90319.94, 90343.055, 90366.17, 90389.29, 90412.41, 90435.53, 90458.65, 90481.77, 90504.9, 90528.03, 90551.16, 90574.29, 90597.42, 90620.555, 90643.69, 90666.82, 90689.96, 90713.1, 90736.24, 90759.38, 90782.52, 90805.67, 90828.81, 90851.96, 90875.11, 90898.266, 90921.414, 90944.57, 90967.73, 90990.88, 91014.04, 91037.195, 91060.36, 91083.52, 91106.69, 91129.85, 91153.016, 91176.19, 91199.35, 91222.52, 91245.7, 91268.875, 91292.05, 91315.23, 91338.41, 91361.586, 91384.766, 91407.95, 91431.13, 91454.32, 91477.51, 91500.695, 91523.89, 91547.08, 91570.27, 91593.47, 91616.664, 91639.86, 91663.06, 91686.26, 91709.46, 91732.664, 91755.875, 91779.08, 91802.29, 91825.5, 91848.71, 91871.92, 91895.13, 91918.35, 91941.56, 91964.78, 91988.01, 92011.23, 92034.445, 92057.67, 92080.9, 92104.125, 92127.35, 92150.586, 92173.81, 92197.05, 92220.28, 92243.516, 92266.76, 92289.99, 92313.234, 92336.48, 92359.72, 92382.96, 92406.21, 92429.46, 92452.7, 92475.96, 92499.21, 92522.46, 92545.72, 92568.98, 92592.234, 92615.49, 92638.75, 92662.016, 92685.28, 92708.54, 92731.81, 92755.08, 92778.34, 92801.62, 92824.89, 92848.164, 92871.44, 92894.72, 92917.99, 92941.27, 92964.555, 92987.836, 93011.125, 93034.41, 93057.695, 93080.984, 93104.27, 93127.56, 93150.86, 93174.15, 93197.445, 93220.74, 93244.04, 93267.34, 93290.64, 93313.945, 93337.25, 93360.555, 93383.87, 93407.17, 93430.484, 93453.8, 93477.11, 93500.42, 93523.74, 93547.055, 93570.375, 93593.695, 93617.016, 93640.34, 93663.664, 93686.99, 93710.32, 93733.65, 93756.984, 93780.31, 93803.65, 93826.984, 93850.32, 93873.66, 93896.99, 93920.336, 93943.68, 93967.02, 93990.37, 94013.71, 94037.06, 94060.414, 94083.76, 94107.12, 94130.47, 94153.82, 94177.18, 94200.54, 94223.9, 94247.26, 94270.62, 94293.984, 94317.35, 94340.72, 94364.086, 94387.45, 94410.83, 94434.195, 94457.57, 94480.945, 94504.33, 94527.7, 94551.086, 94574.47, 94597.85, 94621.234, 94644.62, 94668.01, 94691.39, 94714.78, 94738.17, 94761.57, 94784.96, 94808.36, 94831.76, 94855.16, 94878.555, 94901.95, 94925.36, 94948.766, 94972.17, 94995.58, 95018.984, 95042.39, 95065.805, 95089.22, 95112.63, 95136.05, 95159.47, 95182.88, 95206.305, 95229.73, 95253.15, 95276.58, 95300.0, 95323.43, 95346.86, 95370.29, 95393.72, 95417.16, 95440.586, 95464.02, 95487.46, 95510.9, 95534.34, 95557.78, 95581.23, 95604.67, 95628.12, 95651.56, 95675.016, 95698.46, 95721.914, 95745.37, 95768.82, 95792.28, 95815.734, 95839.195, 95862.66, 95886.12, 95909.586, 95933.05, 95956.516, 95979.984, 96003.45, 96026.92, 96050.39, 96073.87, 96097.34, 96120.82, 96144.3, 96167.77, 96191.26, 96214.734, 96238.22, 96261.7, 96285.195, 96308.68, 96332.17, 96355.66, 96379.15, 96402.65, 96426.14, 96449.64, 96473.13, 96496.63, 96520.13, 96543.64, 96567.14, 96590.65, 96614.15, 96637.66, 96661.17, 96684.68, 96708.195, 96731.7, 96755.22, 96778.734, 96802.26, 96825.77, 96849.3, 96872.81, 96896.336, 96919.87, 96943.39, 96966.92, 96990.445, 97013.98, 97037.51, 97061.05, 97084.58, 97108.12, 97131.66, 97155.195, 97178.734, 97202.27, 97225.82, 97249.37, 97272.91, 97296.46, 97320.01, 97343.555, 97367.11, 97390.664, 97414.22, 97437.77, 97461.336, 97484.89, 97508.45, 97532.016, 97555.58, 97579.14, 97602.71, 97626.27, 97649.84, 97673.414, 97696.984, 97720.56, 97744.13, 97767.71, 97791.29, 97814.87, 97838.45, 97862.03, 97885.62, 97909.2, 97932.79, 97956.375, 97979.96, 98003.555, 98027.15, 98050.734, 98074.336, 98097.93, 98121.52, 98145.125, 98168.73, 98192.33, 98215.93, 98239.54, 98263.14, 98286.75, 98310.36, 98333.97, 98357.58, 98381.195, 98404.805, 98428.42, 98452.04, 98475.66, 98499.28, 98522.9, 98546.52, 98570.15, 98593.77, 98617.4, 98641.03, 98664.664, 98688.29, 98711.92, 98735.56, 98759.195, 98782.836, 98806.47, 98830.11, 98853.75, 98877.4, 98901.04, 98924.69, 98948.336, 98971.984, 98995.63, 99019.28, 99042.94, 99066.586, 99090.24, 99113.9, 99137.56, 99161.22, 99184.88, 99208.55, 99232.21, 99255.875, 99279.54, 99303.21, 99326.875, 99350.55, 99374.22, 99397.9, 99421.57, 99445.25, 99468.93, 99492.61, 99516.29, 99539.97, 99563.66, 99587.336, 99611.02, 99634.71, 99658.4, 99682.09, 99705.79, 99729.48, 99753.17, 99776.87, 99800.57, 99824.266, 99847.97, 99871.67, 99895.375, 99919.08, 99942.78, 99966.49, 99990.2, 100013.914, 100037.625, 100061.336, 100085.055, 100108.766, 100132.484, 100156.2, 100179.92, 100203.65, 100227.37, 100251.09, 100274.82, 100298.55, 100322.27, 100346.01, 100369.74, 100393.47, 100417.2, 100440.945, 100464.68, 100488.414, 100512.16, 100535.9, 100559.64, 100583.38, 100607.13, 100630.875, 100654.625, 100678.375, 100702.125, 100725.88, 100749.63, 100773.39, 100797.15, 100820.91, 100844.664, 100868.42, 100892.19, 100915.95, 100939.72, 100963.484, 100987.25, 101011.02, 101034.79, 101058.56, 101082.336, 101106.11, 101129.89, 101153.664, 101177.445, 101201.23, 101225.01, 101248.79, 101272.58, 101296.36, 101320.15, 101343.94, 101367.73, 101391.52, 101415.31, 101439.11, 101462.91, 101486.7, 101510.5, 101534.305, 101558.1, 101581.91, 101605.71, 101629.516, 101653.32, 101677.13, 101700.94, 101724.75, 101748.56, 101772.38, 101796.195, 101820.01, 101843.83, 101867.65, 101891.47, 101915.29, 101939.12, 101962.945, 101986.766, 102010.59, 102034.42, 102058.26, 102082.086, 102105.92, 102129.76, 102153.59, 102177.43, 102201.27, 102225.11, 102248.95, 102272.8, 102296.64, 102320.484, 102344.336, 102368.18, 102392.03, 102415.88, 102439.734, 102463.59, 102487.445, 102511.305, 102535.164, 102559.02, 102582.88, 102606.75, 102630.61, 102654.48, 102678.34, 102702.21, 102726.086, 102749.95, 102773.83, 102797.7, 102821.58, 102845.45, 102869.33, 102893.21, 102917.086, 102940.97, 102964.85, 102988.74, 103012.625, 103036.516, 103060.41, 103084.3, 103108.19, 103132.08, 103155.98, 103179.87, 103203.766, 103227.664, 103251.56, 103275.47, 103299.37, 103323.27, 103347.18, 103371.086, 103394.99, 103418.91, 103442.81, 103466.73, 103490.64, 103514.555, 103538.48, 103562.39, 103586.31, 103610.234, 103634.16, 103658.08, 103682.01, 103705.93, 103729.86, 103753.79, 103777.72, 103801.65, 103825.586, 103849.516, 103873.45, 103897.39, 103921.33, 103945.27, 103969.21, 103993.16, 104017.1, 104041.05, 104064.99, 104088.94, 104112.89, 104136.84, 104160.8, 104184.75, 104208.7, 104232.66, 104256.62, 104280.58, 104304.54, 104328.5, 104352.46, 104376.43, 104400.4, 104424.36, 104448.336, 104472.305, 104496.27, 104520.25, 104544.22, 104568.195, 104592.17, 104616.16, 104640.13, 104664.12, 104688.1, 104712.086, 104736.07, 104760.055, 104784.05, 104808.03, 104832.02, 104856.016, 104880.01, 104904.01, 104928.0, 104952.0, 104976.0, 105000.0, 105024.0, 105048.01, 105072.01, 105096.016, 105120.02, 105144.03, 105168.05, 105192.055, 105216.07, 105240.086, 105264.1, 105288.12, 105312.13, 105336.16, 105360.17, 105384.195, 105408.22, 105432.25, 105456.27, 105480.305, 105504.33, 105528.36, 105552.4, 105576.43, 105600.46, 105624.5, 105648.54, 105672.58, 105696.62, 105720.66, 105744.7, 105768.74, 105792.79, 105816.836, 105840.89, 105864.94, 105888.99, 105913.04, 105937.09, 105961.15, 105985.21, 106009.266, 106033.33, 106057.38, 106081.445, 106105.516, 106129.58, 106153.64, 106177.71, 106201.78, 106225.85, 106249.92, 106273.99, 106298.07, 106322.15, 106346.23, 106370.305, 106394.38, 106418.46, 106442.55, 106466.63, 106490.72, 106514.805, 106538.89, 106562.98, 106587.07, 106611.164, 106635.26, 106659.35, 106683.445, 106707.55, 106731.65, 106755.74, 106779.84, 106803.95, 106828.055, 106852.164, 106876.266, 106900.375, 106924.484, 106948.59, 106972.71, 106996.82, 107020.94, 107045.055, 107069.17, 107093.3, 107117.414, 107141.54, 107165.66, 107189.78, 107213.914, 107238.04, 107262.164, 107286.3, 107310.43, 107334.56, 107358.695, 107382.836, 107406.97, 107431.11, 107455.25, 107479.39, 107503.53, 107527.67, 107551.82, 107575.97, 107600.12, 107624.266, 107648.414, 107672.57, 107696.72, 107720.875, 107745.03, 107769.19, 107793.34, 107817.51, 107841.67, 107865.83, 107889.99, 107914.164, 107938.33, 107962.5, 107986.664, 108010.836, 108035.01, 108059.18, 108083.36, 108107.53, 108131.71, 108155.89, 108180.07, 108204.25, 108228.44, 108252.62, 108276.805, 108300.99, 108325.18, 108349.375, 108373.56, 108397.76, 108421.95, 108446.15, 108470.34, 108494.54, 108518.74, 108542.94, 108567.14, 108591.34, 108615.55, 108639.76, 108663.96, 108688.17, 108712.38, 108736.59, 108760.805, 108785.02, 108809.234, 108833.45, 108857.67, 108881.89, 108906.11, 108930.336, 108954.555, 108978.78, 109003.01, 109027.234, 109051.46, 109075.695, 109099.93, 109124.16, 109148.39, 109172.63, 109196.87, 109221.1, 109245.34, 109269.586, 109293.83, 109318.07, 109342.32, 109366.56, 109390.81, 109415.06, 109439.31, 109463.56, 109487.81, 109512.07, 109536.33, 109560.586, 109584.84, 109609.1, 109633.36, 109657.625, 109681.89, 109706.16, 109730.42, 109754.69, 109778.96, 109803.23, 109827.5, 109851.77, 109876.05, 109900.33, 109924.6, 109948.88, 109973.164, 109997.445, 110021.73, 110046.01, 110070.3, 110094.58, 110118.87, 110143.16, 110167.445, 110191.74, 110216.03, 110240.33, 110264.625, 110288.92, 110313.22, 110337.52, 110361.82, 110386.125, 110410.43, 110434.734, 110459.04, 110483.35, 110507.66, 110531.97, 110556.28, 110580.59, 110604.91, 110629.23, 110653.55, 110677.86, 110702.18, 110726.51, 110750.83, 110775.15, 110799.48, 110823.805, 110848.13, 110872.46, 110896.79, 110921.125, 110945.46, 110969.79, 110994.125, 111018.47, 111042.805, 111067.15, 111091.484, 111115.83, 111140.17, 111164.516, 111188.87, 111213.21, 111237.56, 111261.914, 111286.266, 111310.62, 111334.98, 111359.33, 111383.69, 111408.05, 111432.41, 111456.766, 111481.13, 111505.49, 111529.86, 111554.23, 111578.59, 111602.97, 111627.336, 111651.71, 111676.08, 111700.45, 111724.836, 111749.21, 111773.586, 111797.97, 111822.35, 111846.734, 111871.12, 111895.5, 111919.89, 111944.27, 111968.664, 111993.055, 112017.45, 112041.84, 112066.234, 112090.63, 112115.03, 112139.43, 112163.83, 112188.234, 112212.63, 112237.04, 112261.445, 112285.85, 112310.26, 112334.664, 112359.08, 112383.49, 112407.91, 112432.32, 112456.734, 112481.15, 112505.57, 112529.99, 112554.41, 112578.836, 112603.26, 112627.68, 112652.11, 112676.54, 112700.97, 112725.4, 112749.83, 112774.26, 112798.695, 112823.13, 112847.57, 112872.01, 112896.445, 112920.89, 112945.33, 112969.77, 112994.22, 113018.664, 113043.11, 113067.56, 113092.016, 113116.46, 113140.914, 113165.375, 113189.83, 113214.28, 113238.74, 113263.2, 113287.664, 113312.125, 113336.586, 113361.055, 113385.516, 113409.984, 113434.45, 113458.93, 113483.4, 113507.87, 113532.34, 113556.82, 113581.3, 113605.77, 113630.25, 113654.734, 113679.22, 113703.7, 113728.19, 113752.67, 113777.16, 113801.65, 113826.13, 113850.625, 113875.12, 113899.62, 113924.11, 113948.61, 113973.1, 113997.6, 114022.1, 114046.6, 114071.11, 114095.61, 114120.12, 114144.625, 114169.13, 114193.64, 114218.16, 114242.664, 114267.18, 114291.695, 114316.21, 114340.73, 114365.25, 114389.766, 114414.29, 114438.81, 114463.336, 114487.86, 114512.39, 114536.914, 114561.445, 114585.98, 114610.51, 114635.04, 114659.58, 114684.11, 114708.65, 114733.19, 114757.73, 114782.27, 114806.81, 114831.36, 114855.9, 114880.445, 114904.99, 114929.55, 114954.09, 114978.65, 115003.2, 115027.76, 115052.31, 115076.87, 115101.42, 115125.984, 115150.55, 115175.11, 115199.67, 115224.234, 115248.805, 115273.37, 115297.94, 115322.51, 115347.08, 115371.65, 115396.23, 115420.805, 115445.375, 115469.95, 115494.53, 115519.12, 115543.695, 115568.28, 115592.87, 115617.45, 115642.04, 115666.625, 115691.22, 115715.805, 115740.4, 115764.99, 115789.586, 115814.18, 115838.78, 115863.38, 115887.98, 115912.58, 115937.19, 115961.79, 115986.39, 116011.0, 116035.61, 116060.22, 116084.83, 116109.44, 116134.055, 116158.664, 116183.28, 116207.9, 116232.516, 116257.14, 116281.76, 116306.38, 116331.01, 116355.63, 116380.26, 116404.88, 116429.516, 116454.14, 116478.77, 116503.41, 116528.04, 116552.67, 116577.31, 116601.95, 116626.586, 116651.23, 116675.875, 116700.516, 116725.16, 116749.805, 116774.45, 116799.1, 116823.75, 116848.4, 116873.055, 116897.7, 116922.36, 116947.016, 116971.67, 116996.336, 117020.99, 117045.66, 117070.32, 117094.984, 117119.65, 117144.31, 117168.98, 117193.65, 117218.32, 117242.99, 117267.664, 117292.336, 117317.016, 117341.69, 117366.37, 117391.05, 117415.73, 117440.414, 117465.09, 117489.78, 117514.47, 117539.16, 117563.84, 117588.53, 117613.23, 117637.914, 117662.61, 117687.305, 117712.0, 117736.695, 117761.4, 117786.09, 117810.8, 117835.5, 117860.2, 117884.914, 117909.62, 117934.33, 117959.03, 117983.74, 118008.46, 118033.17, 118057.88, 118082.6, 118107.32, 118132.04, 118156.76, 118181.48, 118206.195, 118230.92, 118255.65, 118280.375, 118305.1, 118329.83, 118354.56, 118379.29, 118404.02, 118428.76, 118453.49, 118478.23, 118502.97, 118527.7, 118552.445, 118577.19, 118601.93, 118626.67, 118651.42, 118676.164, 118700.914, 118725.664, 118750.414, 118775.164, 118799.92, 118824.67, 118849.43, 118874.19, 118898.945, 118923.7, 118948.47, 118973.23, 118997.99, 119022.76, 119047.52, 119072.29, 119097.06, 119121.83, 119146.6, 119171.375, 119196.15, 119220.92, 119245.695, 119270.48, 119295.26, 119320.03, 119344.81, 119369.6, 119394.38, 119419.17, 119443.95, 119468.74, 119493.53, 119518.32, 119543.12, 119567.91, 119592.7, 119617.5, 119642.3, 119667.09, 119691.89, 119716.695, 119741.49, 119766.3, 119791.1, 119815.91, 119840.72, 119865.52, 119890.336, 119915.15, 119939.96, 119964.77, 119989.586, 120014.41, 120039.22, 120064.04, 120088.86, 120113.68, 120138.51, 120163.33, 120188.16, 120212.98, 120237.805, 120262.63, 120287.47, 120312.3, 120337.13, 120361.97, 120386.805, 120411.64, 120436.48, 120461.31, 120486.16, 120511.0, 120535.84, 120560.69, 120585.53, 120610.375, 120635.23, 120660.08, 120684.93, 120709.78, 120734.63, 120759.484, 120784.34, 120809.2, 120834.055, 120858.92, 120883.78, 120908.64, 120933.51, 120958.37, 120983.234, 121008.1, 121032.97, 121057.84, 121082.71, 121107.586, 121132.46, 121157.336, 121182.21, 121207.086, 121231.97, 121256.85, 121281.73, 121306.61, 121331.5, 121356.38, 121381.266, 121406.16, 121431.05, 121455.94, 121480.83, 121505.72, 121530.62, 121555.51, 121580.41, 121605.305, 121630.2, 121655.1, 121680.01, 121704.914, 121729.81, 121754.72, 121779.625, 121804.54, 121829.445, 121854.36, 121879.266, 121904.18, 121929.09, 121954.016, 121978.93, 122003.85, 122028.766, 122053.69, 122078.61, 122103.53, 122128.46, 122153.38, 122178.31, 122203.24, 122228.17, 122253.1, 122278.03, 122302.97, 122327.91, 122352.836, 122377.77, 122402.72, 122427.66, 122452.59, 122477.54, 122502.484, 122527.43, 122552.375, 122577.32, 122602.27, 122627.22, 122652.17, 122677.125, 122702.08, 122727.04, 122751.99, 122776.95, 122801.91, 122826.87, 122851.83, 122876.8, 122901.76, 122926.73, 122951.69, 122976.66, 123001.625, 123026.6, 123051.57, 123076.55, 123101.516, 123126.49, 123151.47, 123176.445, 123201.43, 123226.41, 123251.39, 123276.375, 123301.36, 123326.34, 123351.33, 123376.32, 123401.305, 123426.3, 123451.29, 123476.28, 123501.28, 123526.27, 123551.27, 123576.27, 123601.27, 123626.27, 123651.27, 123676.27, 123701.28, 123726.29, 123751.3, 123776.305, 123801.31, 123826.32, 123851.336, 123876.35, 123901.37, 123926.38, 123951.4, 123976.414, 124001.44, 124026.45, 124051.48, 124076.5, 124101.53, 124126.555, 124151.58, 124176.61, 124201.64, 124226.67, 124251.7, 124276.734, 124301.77, 124326.805, 124351.84, 124376.88, 124401.92, 124426.97, 124452.01, 124477.055, 124502.09, 124527.14, 124552.19, 124577.24, 124602.29, 124627.34, 124652.39, 124677.445, 124702.5, 124727.56, 124752.62, 124777.67, 124802.734, 124827.8, 124852.86, 124877.92, 124902.99, 124928.055, 124953.125, 124978.195, 125003.266, 125028.336, 125053.41, 125078.484, 125103.555, 125128.63, 125153.71, 125178.79, 125203.87, 125228.95, 125254.03, 125279.12, 125304.2, 125329.29, 125354.375, 125379.47, 125404.555, 125429.65, 125454.74, 125479.836, 125504.93, 125530.02, 125555.125, 125580.23, 125605.33, 125630.43, 125655.53, 125680.63, 125705.74, 125730.84, 125755.95, 125781.06, 125806.17, 125831.28, 125856.4, 125881.51, 125906.625, 125931.74, 125956.86, 125981.98, 126007.1, 126032.22, 126057.34, 126082.47, 126107.59, 126132.72, 126157.85, 126182.98, 126208.11, 126233.24, 126258.375, 126283.51, 126308.64, 126333.78, 126358.914, 126384.055, 126409.195, 126434.336, 126459.484, 126484.625, 126509.77, 126534.92, 126560.06, 126585.22, 126610.37, 126635.516, 126660.67, 126685.83, 126710.98, 126736.13, 126761.3, 126786.45, 126811.62, 126836.77, 126861.94, 126887.1, 126912.266, 126937.44, 126962.6, 126987.77, 127012.945, 127038.12, 127063.29, 127088.46, 127113.63, 127138.81, 127163.99, 127189.17, 127214.35, 127239.53, 127264.72, 127289.9, 127315.086, 127340.27, 127365.46, 127390.65, 127415.836, 127441.03, 127466.22, 127491.414, 127516.61, 127541.805, 127567.01, 127592.2, 127617.41, 127642.61, 127667.81, 127693.016, 127718.22, 127743.42, 127768.63, 127793.84, 127819.055, 127844.266, 127869.48, 127894.69, 127919.91, 127945.125, 127970.34, 127995.56, 128020.78, 128046.0, 128071.23, 128096.445, 128121.67, 128146.9, 128172.125, 128197.35, 128222.586, 128247.82, 128273.05, 128298.28, 128323.516, 128348.76, 128373.99, 128399.234, 128424.47, 128449.71, 128474.95, 128500.195, 128525.445, 128550.69, 128575.94, 128601.19, 128626.44, 128651.69, 128676.94, 128702.195, 128727.445, 128752.7, 128777.96, 128803.22, 128828.48, 128853.74, 128879.0, 128904.266, 128929.53, 128954.8, 128980.06, 129005.336, 129030.6, 129055.875, 129081.15, 129106.42, 129131.695, 129156.97, 129182.25, 129207.52, 129232.805, 129258.086, 129283.37, 129308.66, 129333.94, 129359.23, 129384.51, 129409.8, 129435.086, 129460.38, 129485.67, 129510.96, 129536.26, 129561.555, 129586.85, 129612.15, 129637.445, 129662.75, 129688.055, 129713.35, 129738.66, 129763.96, 129789.27, 129814.58, 129839.89, 129865.2, 129890.51, 129915.83, 129941.14, 129966.45, 129991.77, 130017.086, 130042.41, 130067.73, 130093.05, 130118.375, 130143.695, 130169.02, 130194.35, 130219.68, 130245.01, 130270.336, 130295.664, 130321.0, 130346.336, 130371.67, 130397.01, 130422.34, 130447.68, 130473.02, 130498.37, 130523.7, 130549.05, 130574.4, 130599.74, 130625.086, 130650.44, 130675.79, 130701.14, 130726.49, 130751.84, 130777.2, 130802.555, 130827.914, 130853.27, 130878.63, 130903.99, 130929.35, 130954.72, 130980.086, 131005.445, 131030.81, 131056.19, 131081.55, 131106.92, 131132.3, 131157.67, 131183.05, 131208.42, 131233.8, 131259.17, 131284.55, 131309.94, 131335.31, 131360.7, 131386.08, 131411.47, 131436.86, 131462.25, 131487.64, 131513.03, 131538.42, 131563.81, 131589.2, 131614.6, 131640.0, 131665.39, 131690.8, 131716.19, 131741.6, 131767.0, 131792.4, 131817.81, 131843.22, 131868.62, 131894.03, 131919.44, 131944.84, 131970.27, 131995.67, 132021.1, 132046.5, 132071.92, 132097.34, 132122.77, 132148.19, 132173.61, 132199.03, 132224.45, 132249.88, 132275.31, 132300.73, 132326.17, 132351.6, 132377.03, 132402.47, 132427.89, 132453.33, 132478.77, 132504.2, 132529.64, 132555.1, 132580.53, 132605.97, 132631.42, 132656.86, 132682.31, 132707.75, 132733.2, 132758.66, 132784.11, 132809.56, 132835.02, 132860.47, 132885.92, 132911.39, 132936.84, 132962.3, 132987.77, 133013.22, 133038.69, 133064.16, 133089.62, 133115.1, 133140.56, 133166.03, 133191.5, 133216.97, 133242.44, 133267.92, 133293.39, 133318.88, 133344.34, 133369.83, 133395.31, 133420.8, 133446.28, 133471.77, 133497.25, 133522.73, 133548.22, 133573.7, 133599.2, 133624.69, 133650.19, 133675.69, 133701.17, 133726.67, 133752.17, 133777.67, 133803.17, 133828.67, 133854.17, 133879.67, 133905.19, 133930.69, 133956.2, 133981.7, 134007.22, 134032.73, 134058.23, 134083.75, 134109.27, 134134.78, 134160.3, 134185.81, 134211.34, 134236.86, 134262.38, 134287.9, 134313.44, 134338.95, 134364.48, 134390.02, 134415.55, 134441.08, 134466.61, 134492.14, 134517.67, 134543.2, 134568.75, 134594.28, 134619.81, 134645.36, 134670.9, 134696.44, 134721.98, 134747.53, 134773.08, 134798.62, 134824.17, 134849.72, 134875.28, 134900.83, 134926.39, 134951.94, 134977.5, 135003.05, 135028.61, 135054.17, 135079.73, 135105.3, 135130.86, 135156.42, 135181.98, 135207.55, 135233.12, 135258.69, 135284.27, 135309.83, 135335.4, 135360.98, 135386.56, 135412.12, 135437.7, 135463.28, 135488.88, 135514.45, 135540.03, 135565.61, 135591.2, 135616.78, 135642.38, 135667.97, 135693.55, 135719.14, 135744.73, 135770.33, 135795.92, 135821.52, 135847.12, 135872.72, 135898.31, 135923.92, 135949.52, 135975.12, 136000.73, 136026.33, 136051.94, 136077.55, 136103.16, 136128.77, 136154.38, 136179.98, 136205.61, 136231.22, 136256.84, 136282.45, 136308.08, 136333.69, 136359.31, 136384.94, 136410.56, 136436.19, 136461.81, 136487.44, 136513.06, 136538.7, 136564.33, 136589.95, 136615.6, 136641.23, 136666.86, 136692.5, 136718.14, 136743.78, 136769.42, 136795.06, 136820.7, 136846.34, 136871.98, 136897.64, 136923.28, 136948.94, 136974.58, 137000.23, 137025.89, 137051.55, 137077.2, 137102.86, 137128.52, 137154.17, 137179.83, 137205.48, 137231.16, 137256.81, 137282.48, 137308.14, 137333.81, 137359.48, 137385.16, 137410.81, 137436.48, 137462.16, 137487.84, 137513.52, 137539.19, 137564.88, 137590.55, 137616.22, 137641.9, 137667.6, 137693.28, 137718.95, 137744.64, 137770.33, 137796.02, 137821.7, 137847.4, 137873.1, 137898.78, 137924.48, 137950.17, 137975.88, 138001.58, 138027.27, 138052.97, 138078.67, 138104.38, 138130.08, 138155.78, 138181.48, 138207.2, 138232.9, 138258.61, 138284.33, 138310.05, 138335.75, 138361.47, 138387.19, 138412.9, 138438.62, 138464.34, 138490.06, 138515.78, 138541.5, 138567.23, 138592.95, 138618.69, 138644.4, 138670.14, 138695.88, 138721.6, 138747.33, 138773.06, 138798.8, 138824.53, 138850.28, 138876.02, 138901.75, 138927.5, 138953.23, 138978.98, 139004.72, 139030.47, 139056.22, 139081.97, 139107.72, 139133.47, 139159.22, 139184.97, 139210.72, 139236.48, 139262.23, 139288.0, 139313.75, 139339.52, 139365.28, 139391.03, 139416.8, 139442.56, 139468.33, 139494.1, 139519.88, 139545.64, 139571.4, 139597.19, 139622.95, 139648.73, 139674.5, 139700.28, 139726.06, 139751.84, 139777.62, 139803.4, 139829.19, 139854.97, 139880.75, 139906.53, 139932.33, 139958.11, 139983.9, 140009.69, 140035.48, 140061.28, 140087.08, 140112.88, 140138.67, 140164.47, 140190.27, 140216.06, 140241.86, 140267.67, 140293.47, 140319.28, 140345.08, 140370.89, 140396.7, 140422.52, 140448.33, 140474.14, 140499.95, 140525.77, 140551.58, 140577.39, 140603.22, 140629.03, 140654.86, 140680.67, 140706.5, 140732.33, 140758.16, 140783.97, 140809.8, 140835.62, 140861.47, 140887.3, 140913.12, 140938.95, 140964.8, 140990.62, 141016.47, 141042.31, 141068.14, 141093.98, 141119.83, 141145.67, 141171.52, 141197.36, 141223.2, 141249.06, 141274.9, 141300.75, 141326.61, 141352.45, 141378.31, 141404.17, 141430.03, 141455.88, 141481.73, 141507.6, 141533.47, 141559.33, 141585.19, 141611.05, 141636.92, 141662.78, 141688.66, 141714.52, 141740.39, 141766.27, 141792.14, 141818.02, 141843.89, 141869.77, 141895.64, 141921.52, 141947.39, 141973.28, 141999.16, 142025.05, 142050.92, 142076.81, 142102.7, 142128.6, 142154.48, 142180.38, 142206.27, 142232.16, 142258.05, 142283.94, 142309.84, 142335.73, 142361.64, 142387.53, 142413.44, 142439.34, 142465.23, 142491.14, 142517.05, 142542.95, 142568.86, 142594.78, 142620.69, 142646.6, 142672.52, 142698.42, 142724.34, 142750.25, 142776.17, 142802.1, 142828.02, 142853.94, 142879.86, 142905.78, 142931.7, 142957.62, 142983.55, 143009.48, 143035.4, 143061.34, 143087.27, 143113.2, 143139.14, 143165.08, 143191.02, 143216.95, 143242.89, 143268.83, 143294.77, 143320.7, 143346.66, 143372.6, 143398.55, 143424.48, 143450.44, 143476.39, 143502.34, 143528.3, 143554.25, 143580.2, 143606.16, 143632.11, 143658.06, 143684.03, 143709.98, 143735.94, 143761.9, 143787.88, 143813.83, 143839.8, 143865.77, 143891.73, 143917.7, 143943.67, 143969.64, 143995.62, 144021.6, 144047.56, 144073.55, 144099.52, 144125.5, 144151.48, 144177.45, 144203.44, 144229.42, 144255.4, 144281.39, 144307.38, 144333.38, 144359.36, 144385.34, 144411.34, 144437.33, 144463.33, 144489.33, 144515.31, 144541.31, 144567.31, 144593.31, 144619.31, 144645.31, 144671.31, 144697.33, 144723.33, 144749.33, 144775.34, 144801.34, 144827.36, 144853.38, 144879.39, 144905.39, 144931.4, 144957.42, 144983.45, 145009.47, 145035.48, 145061.5, 145087.53, 145113.55, 145139.58, 145165.6, 145191.62, 145217.66, 145243.69, 145269.72, 145295.73, 145321.78, 145347.81, 145373.84, 145399.88, 145425.92, 145451.95, 145478.0, 145504.03, 145530.08, 145556.11, 145582.16, 145608.2, 145634.25, 145660.3, 145686.34, 145712.39, 145738.45, 145764.5, 145790.55, 145816.61, 145842.66, 145868.72, 145894.78, 145920.84, 145946.89, 145972.95, 145999.02, 146025.08, 146051.16, 146077.22, 146103.28, 146129.36, 146155.42, 146181.48, 146207.56, 146233.64, 146259.72, 146285.78, 146311.86, 146337.94, 146364.02, 146390.1, 146416.19, 146442.27, 146468.34, 146494.44, 146520.52, 146546.61, 146572.69, 146598.78, 146624.88, 146650.97, 146677.06, 146703.16, 146729.25, 146755.34, 146781.44, 146807.53, 146833.64, 146859.73, 146885.84, 146911.94, 146938.05, 146964.16, 146990.27, 147016.36, 147042.47, 147068.58, 147094.7, 147120.81, 147146.92, 147173.03, 147199.16, 147225.27, 147251.39, 147277.52, 147303.62, 147329.75, 147355.88, 147382.0, 147408.12, 147434.25, 147460.38, 147486.5, 147512.64, 147538.77, 147564.89, 147591.03, 147617.17, 147643.3, 147669.44, 147695.58, 147721.72, 147747.86, 147774.0, 147800.14, 147826.28, 147852.42, 147878.58, 147904.72, 147930.88, 147957.02, 147983.17, 148009.33, 148035.47, 148061.62, 148087.78, 148113.94, 148140.1, 148166.25, 148192.42, 148218.58, 148244.73, 148270.9, 148297.06, 148323.23, 148349.4, 148375.56, 148401.73, 148427.9, 148454.08, 148480.25, 148506.42, 148532.6, 148558.78, 148584.95, 148611.12, 148637.31, 148663.48, 148689.67, 148715.86, 148742.05, 148768.22, 148794.4, 148820.6, 148846.78, 148872.98, 148899.17, 148925.36, 148951.55, 148977.75, 149003.94, 149030.14, 149056.34, 149082.53, 149108.73, 149134.94, 149161.14, 149187.34, 149213.55, 149239.75, 149265.97, 149292.17, 149318.38, 149344.6, 149370.8, 149397.02, 149423.23, 149449.45, 149475.66, 149501.88, 149528.1, 149554.31, 149580.55, 149606.77, 149632.98, 149659.2, 149685.44, 149711.66, 149737.89, 149764.12, 149790.34, 149816.58, 149842.81, 149869.05, 149895.28, 149921.52, 149947.75, 149973.98, 150000.23, 150026.47, 150052.72, 150078.95, 150105.2, 150131.44, 150157.69, 150183.94, 150210.19, 150236.44, 150262.69, 150288.94, 150315.19, 150341.45, 150367.7, 150393.95, 150420.22, 150446.47, 150472.73, 150499.0, 150525.25, 150551.52, 150577.78, 150604.05, 150630.31, 150656.58, 150682.86, 150709.12, 150735.39, 150761.67, 150787.94, 150814.22, 150840.5, 150866.77, 150893.05, 150919.33, 150945.61, 150971.89, 150998.17, 151024.45, 151050.75, 151077.03, 151103.31, 151129.61, 151155.89, 151182.19, 151208.48, 151234.77, 151261.06, 151287.36, 151313.66, 151339.95, 151366.25, 151392.55, 151418.86, 151445.16, 151471.45, 151497.77, 151524.06, 151550.38, 151576.69, 151603.0, 151629.3, 151655.61, 151681.92, 151708.23, 151734.56, 151760.88, 151787.19, 151813.5, 151839.83, 151866.14, 151892.47, 151918.8, 151945.11, 151971.44, 151997.77, 152024.1, 152050.42, 152076.75, 152103.08, 152129.42, 152155.75, 152182.08, 152208.42, 152234.75, 152261.1, 152287.44, 152313.77, 152340.11, 152366.45, 152392.8, 152419.14, 152445.48, 152471.83, 152498.19, 152524.53, 152550.88, 152577.23, 152603.58, 152629.94, 152656.3, 152682.66, 152709.0, 152735.36, 152761.72, 152788.08, 152814.45, 152840.81, 152867.17, 152893.53, 152919.9, 152946.27, 152972.64, 152999.02, 153025.38, 153051.75, 153078.12, 153104.5, 153130.88, 153157.25, 153183.62, 153210.0, 153236.39, 153262.77, 153289.14, 153315.53, 153341.92, 153368.3, 153394.69, 153421.08, 153447.47, 153473.86, 153500.25, 153526.64, 153553.03, 153579.42, 153605.81, 153632.22, 153658.61, 153685.02, 153711.4, 153737.81, 153764.22, 153790.62, 153817.03, 153843.44, 153869.84, 153896.25, 153922.66, 153949.06, 153975.48, 154001.89, 154028.3, 154054.72, 154081.14, 154107.55, 154133.97, 154160.39, 154186.81, 154213.23, 154239.66, 154266.08, 154292.5, 154318.92, 154345.36, 154371.78, 154398.22, 154424.64, 154451.08, 154477.52, 154503.94, 154530.38, 154556.81, 154583.25, 154609.69, 154636.12, 154662.58, 154689.02, 154715.45, 154741.9, 154768.34, 154794.8, 154821.23, 154847.69, 154874.14, 154900.6, 154927.05, 154953.5, 154979.95, 155006.4, 155032.86, 155059.31, 155085.78, 155112.23, 155138.7, 155165.16, 155191.62, 155218.1, 155244.56, 155271.02, 155297.48, 155323.95, 155350.44, 155376.9, 155403.38, 155429.84, 155456.33, 155482.8, 155509.28, 155535.75, 155562.23, 155588.72, 155615.19, 155641.67, 155668.16, 155694.64, 155721.12, 155747.62, 155774.11, 155800.6, 155827.1, 155853.58, 155880.08, 155906.56, 155933.06, 155959.56, 155986.05, 156012.55, 156039.05, 156065.55, 156092.05, 156118.56, 156145.06, 156171.56, 156198.08, 156224.58, 156251.1, 156277.6, 156304.11, 156330.62, 156357.14, 156383.64, 156410.16, 156436.67, 156463.2, 156489.72, 156516.23, 156542.75, 156569.28, 156595.8, 156622.33, 156648.84, 156675.38, 156701.9, 156728.44, 156754.97, 156781.5, 156808.03, 156834.56, 156861.1, 156887.62, 156914.17, 156940.7, 156967.25, 156993.78, 157020.33, 157046.86, 157073.4, 157099.95, 157126.5, 157153.05, 157179.6, 157206.14, 157232.69, 157259.25, 157285.8, 157312.34, 157338.9, 157365.45, 157392.02, 157418.58, 157445.14, 157471.69, 157498.25, 157524.81, 157551.38, 157577.95, 157604.52, 157631.08, 157657.64, 157684.22, 157710.78, 157737.36, 157763.92, 157790.5, 157817.08, 157843.66, 157870.23, 157896.81, 157923.39, 157949.97, 157976.55, 158003.12, 158029.72, 158056.3, 158082.89, 158109.47, 158136.06, 158162.66, 158189.23, 158215.83, 158242.42, 158269.02, 158295.61, 158322.2, 158348.81, 158375.4, 158402.0, 158428.61, 158455.2, 158481.81, 158508.4, 158535.02, 158561.62, 158588.23, 158614.84, 158641.45, 158668.06, 158694.67, 158721.28, 158747.89, 158774.52, 158801.12, 158827.75, 158854.36, 158880.98, 158907.61, 158934.22, 158960.84, 158987.47, 159014.1, 159040.72, 159067.34, 159093.97, 159120.61, 159147.23, 159173.88, 159200.5, 159227.14, 159253.77, 159280.4, 159307.05, 159333.69, 159360.31, 159386.95, 159413.61, 159440.25, 159466.89, 159493.53, 159520.19, 159546.83, 159573.47, 159600.12, 159626.78, 159653.42, 159680.08, 159706.73, 159733.39, 159760.05, 159786.7, 159813.36, 159840.02, 159866.69, 159893.34, 159920.0, 159946.67, 159973.33, 160000.0, 160026.67, 160053.33, 160080.0, 160106.67, 160133.34, 160160.02, 160186.69, 160213.38, 160240.05, 160266.72, 160293.4, 160320.08, 160346.77, 160373.44, 160400.12, 160426.81, 160453.5, 160480.19, 160506.86, 160533.56, 160560.25, 160586.94, 160613.62, 160640.31, 160667.02, 160693.7, 160720.4, 160747.11, 160773.8, 160800.5, 160827.2, 160853.9, 160880.61, 160907.31, 160934.02, 160960.72, 160987.42, 161014.14, 161040.84, 161067.55, 161094.27, 161120.98, 161147.69, 161174.4, 161201.12, 161227.84, 161254.56, 161281.28, 161308.0, 161334.72, 161361.44, 161388.17, 161414.89, 161441.62, 161468.34, 161495.08, 161521.8, 161548.53, 161575.27, 161602.0, 161628.73, 161655.47, 161682.2, 161708.94, 161735.67, 161762.42, 161789.16, 161815.89, 161842.64, 161869.39, 161896.12, 161922.88, 161949.62, 161976.38, 162003.12, 162029.88, 162056.62, 162083.38, 162110.12, 162136.88, 162163.64, 162190.39, 162217.16, 162243.9, 162270.67, 162297.44, 162324.19, 162350.95, 162377.72, 162404.48, 162431.25, 162458.03, 162484.8, 162511.56, 162538.33, 162565.11, 162591.88, 162618.66, 162645.44, 162672.2, 162698.98, 162725.77, 162752.55, 162779.33, 162806.11, 162832.89, 162859.67, 162886.45, 162913.25, 162940.03, 162966.83, 162993.61, 163020.4, 163047.2, 163073.98, 163100.78, 163127.58, 163154.38, 163181.17, 163207.97, 163234.77, 163261.58, 163288.38, 163315.17, 163341.98, 163368.8, 163395.6, 163422.4, 163449.22, 163476.02, 163502.83, 163529.64, 163556.45, 163583.27, 163610.1, 163636.9, 163663.72, 163690.55, 163717.36, 163744.19, 163771.0, 163797.83, 163824.66, 163851.47, 163878.3, 163905.12, 163931.95, 163958.78, 163985.61, 164012.45, 164039.28, 164066.11, 164092.95, 164119.78, 164146.62, 164173.47, 164200.3, 164227.14, 164253.98, 164280.83, 164307.67, 164334.52, 164361.36, 164388.2, 164415.06, 164441.9, 164468.75, 164495.61, 164522.45, 164549.31, 164576.17, 164603.03, 164629.88, 164656.73, 164683.6, 164710.45, 164737.31, 164764.19, 164791.05, 164817.9, 164844.78, 164871.64, 164898.52, 164925.38, 164952.25, 164979.12, 165006.0, 165032.88, 165059.73, 165086.62]);
}, {IQ_TABLE: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Represents a section of PSI payload ( Program Stream Information ) MPEG
 *  Transport stream
 *  
 *  @author The JCodec project
 *  
 */
var PSISection = function(tableId, specificId, versionNumber, currentNextIndicator, sectionNumber, lastSectionNumber) {
    this.tableId = tableId;
    this.specificId = specificId;
    this.versionNumber = versionNumber;
    this.currentNextIndicator = currentNextIndicator;
    this.sectionNumber = sectionNumber;
    this.lastSectionNumber = lastSectionNumber;
};
PSISection = stjs.extend(PSISection, null, [], function(constructor, prototype) {
    prototype.tableId = 0;
    prototype.specificId = 0;
    prototype.versionNumber = 0;
    prototype.currentNextIndicator = 0;
    prototype.sectionNumber = 0;
    prototype.lastSectionNumber = 0;
    constructor.parsePSI = function(data) {
        var tableId = data.get() & 255;
        var w0 = data.getShort() & 65535;
        if ((w0 & 49152) != 32768) 
             throw new RuntimeException("Invalid section data");
        var sectionLength = w0 & 4095;
        data.setLimit(data.position() + sectionLength);
        var specificId = data.getShort() & 65535;
        var b0 = data.get() & 255;
        var versionNumber = (b0 >> 1) & 31;
        var currentNextIndicator = b0 & 1;
        var sectionNumber = data.get() & 255;
        var lastSectionNumber = data.get() & 255;
        return new PSISection(tableId, specificId, versionNumber, currentNextIndicator, sectionNumber, lastSectionNumber);
    };
    prototype.getTableId = function() {
        return this.tableId;
    };
    prototype.getSpecificId = function() {
        return this.specificId;
    };
    prototype.getVersionNumber = function() {
        return this.versionNumber;
    };
    prototype.getCurrentNextIndicator = function() {
        return this.currentNextIndicator;
    };
    prototype.getSectionNumber = function() {
        return this.sectionNumber;
    };
    prototype.getLastSectionNumber = function() {
        return this.lastSectionNumber;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var HRDParameters = function() {};
HRDParameters = stjs.extend(HRDParameters, null, [], function(constructor, prototype) {
    prototype.cpbCntMinus1 = 0;
    prototype.bitRateScale = 0;
    prototype.cpbSizeScale = 0;
    prototype.bitRateValueMinus1 = null;
    prototype.cpbSizeValueMinus1 = null;
    prototype.cbrFlag = null;
    prototype.initialCpbRemovalDelayLengthMinus1 = 0;
    prototype.cpbRemovalDelayLengthMinus1 = 0;
    prototype.dpbOutputDelayLengthMinus1 = 0;
    prototype.timeOffsetLength = 0;
}, {bitRateValueMinus1: "Int32Array", cpbSizeValueMinus1: "Int32Array", cbrFlag: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var VUIParameters = function() {};
VUIParameters = stjs.extend(VUIParameters, null, [], function(constructor, prototype) {
    constructor.BitstreamRestriction = function() {};
    constructor.BitstreamRestriction = stjs.extend(constructor.BitstreamRestriction, null, [], function(constructor, prototype) {
        prototype.motionVectorsOverPicBoundariesFlag = false;
        prototype.maxBytesPerPicDenom = 0;
        prototype.maxBitsPerMbDenom = 0;
        prototype.log2MaxMvLengthHorizontal = 0;
        prototype.log2MaxMvLengthVertical = 0;
        prototype.numReorderFrames = 0;
        prototype.maxDecFrameBuffering = 0;
    }, {}, {});
    prototype.aspectRatioInfoPresentFlag = false;
    prototype.sarWidth = 0;
    prototype.sarHeight = 0;
    prototype.overscanInfoPresentFlag = false;
    prototype.overscanAppropriateFlag = false;
    prototype.videoSignalTypePresentFlag = false;
    prototype.videoFormat = 0;
    prototype.videoFullRangeFlag = false;
    prototype.colourDescriptionPresentFlag = false;
    prototype.colourPrimaries = 0;
    prototype.transferCharacteristics = 0;
    prototype.matrixCoefficients = 0;
    prototype.chromaLocInfoPresentFlag = false;
    prototype.chromaSampleLocTypeTopField = 0;
    prototype.chromaSampleLocTypeBottomField = 0;
    prototype.timingInfoPresentFlag = false;
    prototype.numUnitsInTick = 0;
    prototype.timeScale = 0;
    prototype.fixedFrameRateFlag = false;
    prototype.lowDelayHrdFlag = false;
    prototype.picStructPresentFlag = false;
    prototype.nalHRDParams = null;
    prototype.vclHRDParams = null;
    prototype.bitstreamRestriction = null;
    prototype.aspectRatio = null;
}, {nalHRDParams: "HRDParameters", vclHRDParams: "HRDParameters", bitstreamRestriction: "VUIParameters.BitstreamRestriction", aspectRatio: "AspectRatio"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Creates MP4 file out of a set of samples
 *  
 *  @author The JCodec project
 *  
 */
var MP4TrackType = function(handler) {
    this.handler = handler;
};
MP4TrackType = stjs.extend(MP4TrackType, null, [], function(constructor, prototype) {
    constructor.VIDEO = new MP4TrackType("vide");
    constructor.SOUND = new MP4TrackType("soun");
    constructor.TIMECODE = new MP4TrackType("tmcd");
    constructor.HINT = new MP4TrackType("hint");
    constructor.TEXT = new MP4TrackType("text");
    constructor.HYPER_TEXT = new MP4TrackType("wtxt");
    constructor.CC = new MP4TrackType("clcp");
    constructor.SUB = new MP4TrackType("sbtl");
    constructor.MUSIC = new MP4TrackType("musi");
    constructor.MPEG1 = new MP4TrackType("MPEG");
    constructor.SPRITE = new MP4TrackType("sprt");
    constructor.TWEEN = new MP4TrackType("twen");
    constructor.CHAPTERS = new MP4TrackType("chap");
    constructor.THREE_D = new MP4TrackType("qd3d");
    constructor.STREAMING = new MP4TrackType("strm");
    constructor.OBJECTS = new MP4TrackType("obje");
    constructor.DATA = new MP4TrackType("url ");
    constructor._values = [MP4TrackType.VIDEO, MP4TrackType.SOUND, MP4TrackType.TIMECODE, MP4TrackType.HINT, MP4TrackType.TEXT, MP4TrackType.HYPER_TEXT, MP4TrackType.CC, MP4TrackType.SUB, MP4TrackType.MUSIC, MP4TrackType.MPEG1, MP4TrackType.SPRITE, MP4TrackType.TWEEN, MP4TrackType.CHAPTERS, MP4TrackType.THREE_D, MP4TrackType.STREAMING, MP4TrackType.OBJECTS, MP4TrackType.DATA];
    prototype.handler = null;
    prototype.getHandler = function() {
        return this.handler;
    };
    constructor.fromHandler = function(handler) {
        for (var i = 0; i < MP4TrackType._values.length; i++) {
            var val = MP4TrackType._values[i];
            if (val.getHandler().equals(handler)) 
                return val;
        }
        return null;
    };
}, {VIDEO: "MP4TrackType", SOUND: "MP4TrackType", TIMECODE: "MP4TrackType", HINT: "MP4TrackType", TEXT: "MP4TrackType", HYPER_TEXT: "MP4TrackType", CC: "MP4TrackType", SUB: "MP4TrackType", MUSIC: "MP4TrackType", MPEG1: "MP4TrackType", SPRITE: "MP4TrackType", TWEEN: "MP4TrackType", CHAPTERS: "MP4TrackType", THREE_D: "MP4TrackType", STREAMING: "MP4TrackType", OBJECTS: "MP4TrackType", DATA: "MP4TrackType", _values: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Unit = stjs.enumeration("FRAME", "SEC");
var UnhandledStateException = function(string) {
    RuntimeException.call(this, string);
};
UnhandledStateException = stjs.extend(UnhandledStateException, RuntimeException, [], null, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var FFT = function() {};
FFT = stjs.extend(FFT, null, [], function(constructor, prototype) {
    constructor.FFT_TABLE_128 = [new Float32Array([1.0, -0.0]), new Float32Array([0.99879545, -0.049067676]), new Float32Array([0.9951847, -0.09801714]), new Float32Array([0.9891765, -0.14673047]), new Float32Array([0.98078525, -0.19509032]), new Float32Array([0.97003126, -0.24298018]), new Float32Array([0.95694035, -0.29028466]), new Float32Array([0.94154406, -0.33688986]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([0.9039893, -0.42755508]), new Float32Array([0.8819213, -0.47139674]), new Float32Array([0.8577286, -0.51410276]), new Float32Array([0.8314696, -0.55557024]), new Float32Array([0.8032075, -0.5956993]), new Float32Array([0.77301043, -0.6343933]), new Float32Array([0.7409511, -0.671559]), new Float32Array([0.70710677, -0.70710677]), new Float32Array([0.671559, -0.7409511]), new Float32Array([0.6343933, -0.77301043]), new Float32Array([0.5956993, -0.8032075]), new Float32Array([0.55557024, -0.8314696]), new Float32Array([0.51410276, -0.8577286]), new Float32Array([0.47139674, -0.8819213]), new Float32Array([0.42755508, -0.9039893]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([0.33688986, -0.94154406]), new Float32Array([0.29028466, -0.95694035]), new Float32Array([0.24298018, -0.97003126]), new Float32Array([0.19509032, -0.98078525]), new Float32Array([0.14673047, -0.9891765]), new Float32Array([0.09801714, -0.9951847]), new Float32Array([0.049067676, -0.99879545]), new Float32Array([6.123234E-17, -1.0]), new Float32Array([-0.049067676, -0.99879545]), new Float32Array([-0.09801714, -0.9951847]), new Float32Array([-0.14673047, -0.9891765]), new Float32Array([-0.19509032, -0.98078525]), new Float32Array([-0.24298018, -0.97003126]), new Float32Array([-0.29028466, -0.95694035]), new Float32Array([-0.33688986, -0.94154406]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([-0.42755508, -0.9039893]), new Float32Array([-0.47139674, -0.8819213]), new Float32Array([-0.51410276, -0.8577286]), new Float32Array([-0.55557024, -0.8314696]), new Float32Array([-0.5956993, -0.8032075]), new Float32Array([-0.6343933, -0.77301043]), new Float32Array([-0.671559, -0.7409511]), new Float32Array([-0.70710677, -0.70710677]), new Float32Array([-0.7409511, -0.671559]), new Float32Array([-0.77301043, -0.6343933]), new Float32Array([-0.8032075, -0.5956993]), new Float32Array([-0.8314696, -0.55557024]), new Float32Array([-0.8577286, -0.51410276]), new Float32Array([-0.8819213, -0.47139674]), new Float32Array([-0.9039893, -0.42755508]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([-0.94154406, -0.33688986]), new Float32Array([-0.95694035, -0.29028466]), new Float32Array([-0.97003126, -0.24298018]), new Float32Array([-0.98078525, -0.19509032]), new Float32Array([-0.9891765, -0.14673047]), new Float32Array([-0.9951847, -0.09801714]), new Float32Array([-0.99879545, -0.049067676])];
    constructor.FFT_TABLE_16 = [new Float32Array([1.0, -0.0]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([0.70710677, -0.70710677]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([6.123234E-17, -1.0]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([-0.70710677, -0.70710677]), new Float32Array([-0.9238795, -0.38268343])];
    constructor.process = function(_in, n) {
        var ln = ((Math.round(Math.log(n) / Math.log(2))) | 0);
        var table = (n == 128) ? FFT.FFT_TABLE_128 : FFT.FFT_TABLE_16;
        var rev = Array.apply(null, Array(n)).map(function() {
            return new Float32Array(2);
        });
        var i, ii = 0;
        for (i = 0; i < n; i++) {
            rev[i][0] = _in[ii][0];
            rev[i][1] = _in[ii][1];
            var k = n >> 1;
             while (ii >= k && k > 0){
                ii -= k;
                k >>= 1;
            }
            ii += k;
        }
        for (i = 0; i < n; i++) {
            _in[i][0] = rev[i][0];
            _in[i][1] = rev[i][1];
        }
        var blocks = stjs.trunc(n / 2);
        var size = 2;
        var j, k, l, k0, k1, size2;
        var a = new Float32Array(2);
        for (i = 0; i < ln; i++) {
            size2 = stjs.trunc(size / 2);
            k0 = 0;
            k1 = size2;
            for (j = 0; j < blocks; ++j) {
                l = 0;
                for (k = 0; k < size2; ++k) {
                    a[0] = _in[k1][0] * table[l][0] - _in[k1][1] * table[l][1];
                    a[1] = _in[k1][0] * table[l][1] + _in[k1][1] * table[l][0];
                    _in[k1][0] = _in[k0][0] - a[0];
                    _in[k1][1] = _in[k0][1] - a[1];
                    _in[k0][0] += a[0];
                    _in[k0][1] += a[1];
                    l += blocks;
                    k0++;
                    k1++;
                }
                k0 += size2;
                k1 += size2;
            }
            blocks = stjs.trunc(blocks / 2);
            size = size * 2;
        }
    };
}, {FFT_TABLE_128: "Array", FFT_TABLE_16: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var GCConstants = function() {};
GCConstants = stjs.extend(GCConstants, null, [], function(constructor, prototype) {
    constructor.BANDS = 4;
    constructor.MAX_CHANNELS = 5;
    constructor.NPQFTAPS = 96;
    constructor.NPEPARTS = 64;
    constructor.ID_GAIN = 16;
    constructor.LN_GAIN = new Int32Array([-4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);
}, {LN_GAIN: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VP8Util = function() {};
VP8Util = stjs.extend(VP8Util, null, [], function(constructor, prototype) {
    constructor.BLOCK_TYPES = 4;
    constructor.COEF_BANDS = 8;
    constructor.PREV_COEF_CONTEXTS = 3;
    constructor.MAX_ENTROPY_TOKENS = 12;
    constructor.MAX_MODE_LF_DELTAS = 4;
    constructor.MAX_REF_LF_DELTAS = 4;
    constructor.MB_FEATURE_TREE_PROBS = 3;
    /**
     *  delta() is the process to read 5 bits from the bitstream to determine a signed delta value:
     *  
     *  +-------+--------------------------------------------------+
     *  | Index | Description                                      |
     *  +-------+--------------------------------------------------+
     *  | L(4)  | Magnitude of delta                               |
     *  | L(1)  | Sign of delta, 0 for positive and 1 for negative |
     *  +-------+--------------------------------------------------+
     *  
     *  @param bc
     *  @return
     *  @throws IOException
     */
    constructor.delta = function(bc) {
        var magnitude = bc.decodeInt(4);
        if (bc.readBitEq() > 0) 
            magnitude = -magnitude;
        return magnitude;
    };
    constructor.SubblockConstants = function() {};
    constructor.SubblockConstants = stjs.extend(constructor.SubblockConstants, null, [], function(constructor, prototype) {
        /**
         *  predict DC using row above and column to the left
         */
        constructor.B_DC_PRED = 0;
        /**
         *  propagate second differences a la "true motion"
         */
        constructor.B_TM_PRED = 1;
        /**
         * 
         *  predict rows using row above 
         */
        constructor.B_VE_PRED = 2;
        /**
         *  predict columns using column to the left
         */
        constructor.B_HE_PRED = 3;
        /**
         *  southwest (left and down) 45 degree diagonal prediction
         */
        constructor.B_LD_PRED = 4;
        /**
         * 
         *  southeast (right and down) "" 
         */
        constructor.B_RD_PRED = 5;
        /**
         *  SSE (vertical right) diagonal prediction
         */
        constructor.B_VR_PRED = 6;
        /**
         * 
         *  SSW (vertical left) "" 
         */
        constructor.B_VL_PRED = 7;
        /**
         *   ESE (horizontal down) "" 
         */
        constructor.B_HD_PRED = 8;
        /**
         * 
         *  ENE (horizontal up) "" 
         */
        constructor.B_HU_PRED = 9;
        /**
         *  predict DC using row above and column to the left
         */
        constructor.DC_PRED = 0;
        /**
         * 
         *  predict rows using row above 
         */
        constructor.V_PRED = 1;
        /**
         *  predict columns using column to the left
         */
        constructor.H_PRED = 2;
        /**
         *  propagate second differences a la "true motion"
         */
        constructor.TM_PRED = 3;
        /**
         *  each Y subblock is independently predicted
         */
        constructor.B_PRED = 4;
        /**
         * exact value: 0 
         */
        constructor.DCT_0 = 0;
        /**
         * exact value: 1 
         */
        constructor.DCT_1 = 1;
        /**
         * exact value: 2 
         */
        constructor.DCT_2 = 2;
        /**
         * exact value: 3 
         */
        constructor.DCT_3 = 3;
        /**
         * exact value: 4 
         */
        constructor.DCT_4 = 4;
        /**
         * value range: [5,6] 
         */
        constructor.cat_5_6 = 5;
        /**
         * value range: [7, 8, 9, 10] size == 4 
         */
        constructor.cat_7_10 = 6;
        /**
         * value range: [11, 12, 13, 14, 15, 16, 17, 18] size == 8 
         */
        constructor.cat_11_18 = 7;
        /**
         * value range: [19 - 34] size == 16 
         */
        constructor.cat_19_34 = 8;
        /**
         * value range: [35 - 66] size == 32 
         */
        constructor.cat_35_66 = 9;
        /**
         * value range: [67 - 2048] size == 1982 
         */
        constructor.cat_67_2048 = 10;
        /**
         * end of block 
         */
        constructor.dct_eob = 11;
        /**
         *  <pre>
         *     <root> 
         *     /    \
         *  dct_eob  2
         *          /  \
         *       DCO_0  4
         *             /  \ 
         *           DCT_1 \ 
         *                  6-------+
         *                 /         \
         *                /           \ 
         *               8             \
         *              / \             \    
         *         DCT_2  10             \
         *               /  \            12-----+
         *           DCT_3  DCY_4       /        \
         *                            14          16
         *                           /  \        /  \
         *                       cat1   cat2    /    \
         *                                     18     20----+ 
         *                                    /  \     |     \
         *                                 cat3  cat4  cat5  cat6
         *  </pre>
         */
        constructor.vp8CoefTree = new Int32Array([-VP8Util.SubblockConstants.dct_eob, 2, -VP8Util.SubblockConstants.DCT_0, 4, -VP8Util.SubblockConstants.DCT_1, 6, 8, 12, -VP8Util.SubblockConstants.DCT_2, 10, -VP8Util.SubblockConstants.DCT_3, -VP8Util.SubblockConstants.DCT_4, 14, 16, -VP8Util.SubblockConstants.cat_5_6, -VP8Util.SubblockConstants.cat_7_10, 18, 20, -VP8Util.SubblockConstants.cat_11_18, -VP8Util.SubblockConstants.cat_19_34, -VP8Util.SubblockConstants.cat_35_66, -VP8Util.SubblockConstants.cat_67_2048]);
        constructor.vp8CoefBands = new Int32Array([0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7]);
        /**
         *  <pre>
         *   0---1   2---3
         *     /   /   /   
         *   4   5   6   7
         *   | /   /   / | 
         *   8   9   10  11
         *     /   /   /   
         *   12--13  14--15
         *   </pre>
         */
        constructor.vp8defaultZigZag1d = new Int32Array([0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15]);
        /**
         * 
         *  <pre>
         *       <root>
         *      /      \
         *  B_DC_PRED   2
         *            /  \
         *   B_TM_PRED    4
         *              /   \
         *      B_VE_PRED    6---------------------+
         *                 /                        \        
         *                8                         12
         *              /  \                      /   \
         *      B_HE_PRED  10             B_LD_PRED    14
         *                /  \                       /   \
         *       B_RD_PRED  B_VR_PRED        B_VL_PRED    16
         *                                              /   \
         *                                      B_HD_PRED  B_HU_PRED
         *  </pre>
         */
        constructor.subblockModeTree = new Int32Array([-VP8Util.SubblockConstants.B_DC_PRED, 2, -VP8Util.SubblockConstants.B_TM_PRED, 4, -VP8Util.SubblockConstants.B_VE_PRED, 6, 8, 12, -VP8Util.SubblockConstants.B_HE_PRED, 10, -VP8Util.SubblockConstants.B_RD_PRED, -VP8Util.SubblockConstants.B_VR_PRED, -VP8Util.SubblockConstants.B_LD_PRED, 14, -VP8Util.SubblockConstants.B_VL_PRED, 16, -VP8Util.SubblockConstants.B_HD_PRED, -VP8Util.SubblockConstants.B_HU_PRED]);
        constructor.Pcat1 = new Int32Array([159, 0]);
        constructor.Pcat2 = new Int32Array([165, 145, 0]);
        constructor.Pcat3 = new Int32Array([173, 148, 140, 0]);
        constructor.Pcat4 = new Int32Array([176, 155, 140, 135, 0]);
        constructor.Pcat5 = new Int32Array([180, 157, 141, 134, 130, 0]);
        constructor.Pcat6 = new Int32Array([254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]);
        constructor.keyFrameSubblockModeProb = [[new Int32Array([231, 120, 48, 89, 115, 113, 120, 152, 112]), new Int32Array([152, 179, 64, 126, 170, 118, 46, 70, 95]), new Int32Array([175, 69, 143, 80, 85, 82, 72, 155, 103]), new Int32Array([56, 58, 10, 171, 218, 189, 17, 13, 152]), new Int32Array([144, 71, 10, 38, 171, 213, 144, 34, 26]), new Int32Array([114, 26, 17, 163, 44, 195, 21, 10, 173]), new Int32Array([121, 24, 80, 195, 26, 62, 44, 64, 85]), new Int32Array([170, 46, 55, 19, 136, 160, 33, 206, 71]), new Int32Array([63, 20, 8, 114, 114, 208, 12, 9, 226]), new Int32Array([81, 40, 11, 96, 182, 84, 29, 16, 36])], [new Int32Array([134, 183, 89, 137, 98, 101, 106, 165, 148]), new Int32Array([72, 187, 100, 130, 157, 111, 32, 75, 80]), new Int32Array([66, 102, 167, 99, 74, 62, 40, 234, 128]), new Int32Array([41, 53, 9, 178, 241, 141, 26, 8, 107]), new Int32Array([104, 79, 12, 27, 217, 255, 87, 17, 7]), new Int32Array([74, 43, 26, 146, 73, 166, 49, 23, 157]), new Int32Array([65, 38, 105, 160, 51, 52, 31, 115, 128]), new Int32Array([87, 68, 71, 44, 114, 51, 15, 186, 23]), new Int32Array([47, 41, 14, 110, 182, 183, 21, 17, 194]), new Int32Array([66, 45, 25, 102, 197, 189, 23, 18, 22])], [new Int32Array([88, 88, 147, 150, 42, 46, 45, 196, 205]), new Int32Array([43, 97, 183, 117, 85, 38, 35, 179, 61]), new Int32Array([39, 53, 200, 87, 26, 21, 43, 232, 171]), new Int32Array([56, 34, 51, 104, 114, 102, 29, 93, 77]), new Int32Array([107, 54, 32, 26, 51, 1, 81, 43, 31]), new Int32Array([39, 28, 85, 171, 58, 165, 90, 98, 64]), new Int32Array([34, 22, 116, 206, 23, 34, 43, 166, 73]), new Int32Array([68, 25, 106, 22, 64, 171, 36, 225, 114]), new Int32Array([34, 19, 21, 102, 132, 188, 16, 76, 124]), new Int32Array([62, 18, 78, 95, 85, 57, 50, 48, 51])], [new Int32Array([193, 101, 35, 159, 215, 111, 89, 46, 111]), new Int32Array([60, 148, 31, 172, 219, 228, 21, 18, 111]), new Int32Array([112, 113, 77, 85, 179, 255, 38, 120, 114]), new Int32Array([40, 42, 1, 196, 245, 209, 10, 25, 109]), new Int32Array([100, 80, 8, 43, 154, 1, 51, 26, 71]), new Int32Array([88, 43, 29, 140, 166, 213, 37, 43, 154]), new Int32Array([61, 63, 30, 155, 67, 45, 68, 1, 209]), new Int32Array([142, 78, 78, 16, 255, 128, 34, 197, 171]), new Int32Array([41, 40, 5, 102, 211, 183, 4, 1, 221]), new Int32Array([51, 50, 17, 168, 209, 192, 23, 25, 82])], [new Int32Array([125, 98, 42, 88, 104, 85, 117, 175, 82]), new Int32Array([95, 84, 53, 89, 128, 100, 113, 101, 45]), new Int32Array([75, 79, 123, 47, 51, 128, 81, 171, 1]), new Int32Array([57, 17, 5, 71, 102, 57, 53, 41, 49]), new Int32Array([115, 21, 2, 10, 102, 255, 166, 23, 6]), new Int32Array([38, 33, 13, 121, 57, 73, 26, 1, 85]), new Int32Array([41, 10, 67, 138, 77, 110, 90, 47, 114]), new Int32Array([101, 29, 16, 10, 85, 128, 101, 196, 26]), new Int32Array([57, 18, 10, 102, 102, 213, 34, 20, 43]), new Int32Array([117, 20, 15, 36, 163, 128, 68, 1, 26])], [new Int32Array([138, 31, 36, 171, 27, 166, 38, 44, 229]), new Int32Array([67, 87, 58, 169, 82, 115, 26, 59, 179]), new Int32Array([63, 59, 90, 180, 59, 166, 93, 73, 154]), new Int32Array([40, 40, 21, 116, 143, 209, 34, 39, 175]), new Int32Array([57, 46, 22, 24, 128, 1, 54, 17, 37]), new Int32Array([47, 15, 16, 183, 34, 223, 49, 45, 183]), new Int32Array([46, 17, 33, 183, 6, 98, 15, 32, 183]), new Int32Array([65, 32, 73, 115, 28, 128, 23, 128, 205]), new Int32Array([40, 3, 9, 115, 51, 192, 18, 6, 223]), new Int32Array([87, 37, 9, 115, 59, 77, 64, 21, 47])], [new Int32Array([104, 55, 44, 218, 9, 54, 53, 130, 226]), new Int32Array([64, 90, 70, 205, 40, 41, 23, 26, 57]), new Int32Array([54, 57, 112, 184, 5, 41, 38, 166, 213]), new Int32Array([30, 34, 26, 133, 152, 116, 10, 32, 134]), new Int32Array([75, 32, 12, 51, 192, 255, 160, 43, 51]), new Int32Array([39, 19, 53, 221, 26, 114, 32, 73, 255]), new Int32Array([31, 9, 65, 234, 2, 15, 1, 118, 73]), new Int32Array([88, 31, 35, 67, 102, 85, 55, 186, 85]), new Int32Array([56, 21, 23, 111, 59, 205, 45, 37, 192]), new Int32Array([55, 38, 70, 124, 73, 102, 1, 34, 98])], [new Int32Array([102, 61, 71, 37, 34, 53, 31, 243, 192]), new Int32Array([69, 60, 71, 38, 73, 119, 28, 222, 37]), new Int32Array([68, 45, 128, 34, 1, 47, 11, 245, 171]), new Int32Array([62, 17, 19, 70, 146, 85, 55, 62, 70]), new Int32Array([75, 15, 9, 9, 64, 255, 184, 119, 16]), new Int32Array([37, 43, 37, 154, 100, 163, 85, 160, 1]), new Int32Array([63, 9, 92, 136, 28, 64, 32, 201, 85]), new Int32Array([86, 6, 28, 5, 64, 255, 25, 248, 1]), new Int32Array([56, 8, 17, 132, 137, 255, 55, 116, 128]), new Int32Array([58, 15, 20, 82, 135, 57, 26, 121, 40])], [new Int32Array([164, 50, 31, 137, 154, 133, 25, 35, 218]), new Int32Array([51, 103, 44, 131, 131, 123, 31, 6, 158]), new Int32Array([86, 40, 64, 135, 148, 224, 45, 183, 128]), new Int32Array([22, 26, 17, 131, 240, 154, 14, 1, 209]), new Int32Array([83, 12, 13, 54, 192, 255, 68, 47, 28]), new Int32Array([45, 16, 21, 91, 64, 222, 7, 1, 197]), new Int32Array([56, 21, 39, 155, 60, 138, 23, 102, 213]), new Int32Array([85, 26, 85, 85, 128, 128, 32, 146, 171]), new Int32Array([18, 11, 7, 63, 144, 171, 4, 4, 246]), new Int32Array([35, 27, 10, 146, 174, 171, 12, 26, 128])], [new Int32Array([190, 80, 35, 99, 180, 80, 126, 54, 45]), new Int32Array([85, 126, 47, 87, 176, 51, 41, 20, 32]), new Int32Array([101, 75, 128, 139, 118, 146, 116, 128, 85]), new Int32Array([56, 41, 15, 176, 236, 85, 37, 9, 62]), new Int32Array([146, 36, 19, 30, 171, 255, 97, 27, 20]), new Int32Array([71, 30, 17, 119, 118, 255, 17, 18, 138]), new Int32Array([101, 38, 60, 138, 55, 70, 43, 26, 142]), new Int32Array([138, 45, 61, 62, 219, 1, 81, 188, 64]), new Int32Array([32, 41, 20, 117, 151, 142, 20, 21, 163]), new Int32Array([112, 19, 12, 61, 195, 128, 48, 4, 24])]];
    }, {vp8CoefTree: "Int32Array", vp8CoefBands: "Int32Array", vp8defaultZigZag1d: "Int32Array", subblockModeTree: "Int32Array", Pcat1: "Int32Array", Pcat2: "Int32Array", Pcat3: "Int32Array", Pcat4: "Int32Array", Pcat5: "Int32Array", Pcat6: "Int32Array", keyFrameSubblockModeProb: "Array"}, {});
    constructor.getDefaultCoefProbs = function() {
        var r = Array.apply(null, Array(VP8Util.vp8DefaultCoefProbs.length)).map(function() {
            return Array.apply(null, Array(VP8Util.vp8DefaultCoefProbs[0].length)).map(function() {
                return Array.apply(null, Array(VP8Util.vp8DefaultCoefProbs[0][0].length)).map(function() {
                    return new Int32Array(VP8Util.vp8DefaultCoefProbs[0][0][0].length);
                });
            });
        });
        for (var i = 0; i < VP8Util.vp8DefaultCoefProbs.length; i++) 
            for (var j = 0; j < VP8Util.vp8DefaultCoefProbs[0].length; j++) 
                for (var k = 0; k < VP8Util.vp8DefaultCoefProbs[0][0].length; k++) 
                    for (var l = 0; l < VP8Util.vp8DefaultCoefProbs[0][0][0].length; l++) 
                        r[i][j][k][l] = VP8Util.vp8DefaultCoefProbs[i][j][k][l];
        return r;
    };
    constructor.vp8KeyFrameUVModeProb = new Int32Array([142, 114, 183]);
    /**
     * 
     *  <pre>
     *  +-----------------------------+
     *  |         root                |
     *  |        /    \               |
     *  |   -DC_PRED    2             |
     *  |             /   \           |
     *  |       -V_PRED    4          |
     *  |                 /  \        |
     *  |          -H_PRED  -TM_PRED  |
     *  +-----------------------------+
     *  </pre>
     *  
     */
    constructor.vp8UVModeTree = new Int32Array([-VP8Util.SubblockConstants.DC_PRED, 2, -VP8Util.SubblockConstants.V_PRED, 4, -VP8Util.SubblockConstants.H_PRED, -VP8Util.SubblockConstants.TM_PRED]);
    constructor.keyFrameYModeProb = new Int32Array([145, 156, 163, 128]);
    /**
     *  Left branch is picked if 0 is decoded, right branch is picked
     *  if 1 is decoded. Positive value of the node tells the index
     *  of the left-most child. Negative value implies leaf node (no
     *  children), with corresponding absolute value.
     *  
     *  0 implies B_PRED is returned.
     *  100 implies DC_PRED is returned.
     *  101 implies V_PRED is returned
     *  110 - H_PRED
     *  111 - TM_PRED
     *  <pre>
     *  +------------------------------------------+
     *  |         root                             |
     *  |        /    \                            |
     *  |   -B_PRED    2------------               |
     *  |             /             \              |
     *  |            4               6----         |
     *  |          /  \             /     \        |
     *  |   -DC_PRED  -V_PRED   -H_PRED  -TM_PRED  |
     *  +------------------------------------------+
     *  </pre>
     *  
     */
    constructor.keyFrameYModeTree = new Int32Array([-VP8Util.SubblockConstants.B_PRED, 2, 4, 6, -VP8Util.SubblockConstants.DC_PRED, -VP8Util.SubblockConstants.V_PRED, -VP8Util.SubblockConstants.H_PRED, -VP8Util.SubblockConstants.TM_PRED]);
    constructor.segmentTree = new Int32Array([2, 4, -0, -1, -2, -3]);
    constructor.getBitInBytes = function(bs, i) {
        var byteIndex = i >> 3;
        var bitIndex = i & 7;
        return (bs[byteIndex] >> bitIndex) & 1;
    };
    constructor.getBitsInBytes = function(bytes, idx, len) {
        var val = 0;
        for (var i = 0; i < len; i++) 
            val |= VP8Util.getBitInBytes(bytes, idx + i) << i;
        return val;
    };
    constructor.getMacroblockCount = function(dimention) {
        if ((dimention & 15) != 0) 
            dimention += 16 - (dimention & 15);
        return dimention >> 4;
    };
    constructor.PRED_BLOCK_127 = new Int32Array([127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127]);
    constructor.PRED_BLOCK_129 = new Int32Array([129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129]);
    constructor.pickDefaultPrediction = function(intra_bmode) {
        if (intra_bmode == VP8Util.SubblockConstants.B_TM_PRED || intra_bmode == VP8Util.SubblockConstants.B_DC_PRED || intra_bmode == VP8Util.SubblockConstants.B_VE_PRED || intra_bmode == VP8Util.SubblockConstants.B_HE_PRED || intra_bmode == VP8Util.SubblockConstants.B_VR_PRED || intra_bmode == VP8Util.SubblockConstants.B_RD_PRED || intra_bmode == VP8Util.SubblockConstants.B_HD_PRED) 
            return VP8Util.PRED_BLOCK_129;
        return VP8Util.PRED_BLOCK_127;
    };
    constructor.QuantizationParams = function(baseIndex, ydcIndexDelta, y2dcIndexDelta, y2acIndexDelta, chromaDCIndexDelta, chromaACIndexDelta) {
        this.yAC = VP8Util.QuantizationParams.acQLookup[VP8Util.QuantizationParams.clip(baseIndex, 127)];
        this.yDC = VP8Util.QuantizationParams.dcQLookup[VP8Util.QuantizationParams.clip(baseIndex + ydcIndexDelta, 127)];
        this.y2DC = VP8Util.QuantizationParams.dcQLookup[VP8Util.QuantizationParams.clip(baseIndex + y2dcIndexDelta, 127)] * 2;
        this.y2AC = stjs.trunc(VP8Util.QuantizationParams.acQLookup[VP8Util.QuantizationParams.clip(baseIndex + y2acIndexDelta, 127)] * 155 / 100);
        if (this.y2AC < 8) 
            this.y2AC = 8;
        this.chromaDC = VP8Util.QuantizationParams.dcQLookup[VP8Util.QuantizationParams.clip(baseIndex + chromaDCIndexDelta, 127)];
        this.chromaAC = VP8Util.QuantizationParams.acQLookup[VP8Util.QuantizationParams.clip(baseIndex + chromaACIndexDelta, 127)];
    };
    constructor.QuantizationParams = stjs.extend(constructor.QuantizationParams, null, [], function(constructor, prototype) {
        prototype.yAC = 0;
        prototype.yDC = 0;
        prototype.y2DC = 0;
        prototype.y2AC = 0;
        prototype.chromaDC = 0;
        prototype.chromaAC = 0;
        constructor.dcQLookup = new Int32Array([4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157]);
        constructor.acQLookup = new Int32Array([4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284]);
        constructor.clip = function(val, max) {
            if (val > max) 
                return max;
            if (val < 0) 
                return 0;
            return val;
        };
        constructor.clip255 = function(val) {
            if (val > 255) 
                return 255;
            if (val < 0) 
                return 0;
            return val;
        };
    }, {dcQLookup: "Int32Array", acQLookup: "Int32Array"}, {});
    constructor.PLANE = stjs.enumeration("U", "V", "Y1", "Y2");
    constructor.vp8DefaultCoefProbs = [[[new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128])], [new Int32Array([253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128]), new Int32Array([189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128]), new Int32Array([106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128])], [new Int32Array([1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128]), new Int32Array([181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128]), new Int32Array([78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128])], [new Int32Array([1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128]), new Int32Array([184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128]), new Int32Array([77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128])], [new Int32Array([1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128]), new Int32Array([170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128]), new Int32Array([37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128])], [new Int32Array([1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128]), new Int32Array([207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128]), new Int32Array([102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128])], [new Int32Array([1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128]), new Int32Array([177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128]), new Int32Array([80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128])], [new Int32Array([1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128])]], [[new Int32Array([198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62]), new Int32Array([131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1]), new Int32Array([68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128])], [new Int32Array([1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128]), new Int32Array([184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128]), new Int32Array([81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128])], [new Int32Array([1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128]), new Int32Array([99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128]), new Int32Array([23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128])], [new Int32Array([1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128]), new Int32Array([109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128]), new Int32Array([44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128])], [new Int32Array([1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128]), new Int32Array([94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128]), new Int32Array([22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128])], [new Int32Array([1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128]), new Int32Array([124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128]), new Int32Array([35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128])], [new Int32Array([1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128]), new Int32Array([121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128]), new Int32Array([45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128])], [new Int32Array([1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128]), new Int32Array([203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128])]], [[new Int32Array([253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128]), new Int32Array([175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128]), new Int32Array([73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128])], [new Int32Array([1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128]), new Int32Array([239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128]), new Int32Array([155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128])], [new Int32Array([1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128]), new Int32Array([201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128]), new Int32Array([69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128])], [new Int32Array([1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128]), new Int32Array([141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128])], [new Int32Array([1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128]), new Int32Array([149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128])], [new Int32Array([1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128])], [new Int32Array([1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128]), new Int32Array([55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128])], [new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128])]], [[new Int32Array([202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255]), new Int32Array([126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128]), new Int32Array([61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128])], [new Int32Array([1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128]), new Int32Array([166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128]), new Int32Array([39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128])], [new Int32Array([1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128]), new Int32Array([124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128]), new Int32Array([24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128])], [new Int32Array([1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128]), new Int32Array([149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128]), new Int32Array([28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128])], [new Int32Array([1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128]), new Int32Array([123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128]), new Int32Array([20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128])], [new Int32Array([1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128]), new Int32Array([168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128]), new Int32Array([47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128])], [new Int32Array([1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128]), new Int32Array([141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128]), new Int32Array([42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128])], [new Int32Array([1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]), new Int32Array([238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128])]]];
    constructor.vp8CoefUpdateProbs = [[[new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255]), new Int32Array([250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])]], [[new Int32Array([217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255]), new Int32Array([234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255])], [new Int32Array([255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])]], [[new Int32Array([186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255])], [new Int32Array([255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])]], [[new Int32Array([248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])], [new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]), new Int32Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])]]];
    constructor.predictHU = function(left) {
        var p = new Int32Array(16);
        p[0 * 4 + 0] = VP8Util.avg2(left[0], left[1]);
        p[0 * 4 + 1] = VP8Util.avg3(left[0], left[1], left[2]);
        p[0 * 4 + 2] = p[1 * 4 + 0] = VP8Util.avg2(left[1], left[2]);
        p[0 * 4 + 3] = p[1 * 4 + 1] = VP8Util.avg3(left[1], left[2], left[3]);
        p[1 * 4 + 2] = p[2 * 4 + 0] = VP8Util.avg2(left[2], left[3]);
        p[1 * 4 + 3] = p[2 * 4 + 1] = VP8Util.avg3(left[2], left[3], left[3]);
        p[2 * 4 + 2] = p[2 * 4 + 3] = p[3 * 4 + 0] = p[3 * 4 + 1] = p[3 * 4 + 2] = p[3 * 4 + 3] = left[3];
        return p;
    };
    constructor.predictHD = function(above, left, aboveLeft) {
        var p = new Int32Array(16);
        var edge = new Int32Array(9);
        edge[0] = left[3];
        edge[1] = left[2];
        edge[2] = left[1];
        edge[3] = left[0];
        edge[4] = aboveLeft;
        edge[5] = above[0];
        edge[6] = above[1];
        edge[7] = above[2];
        edge[8] = above[3];
        p[3 * 4 + 0] = VP8Util.avg2(edge[0], edge[1]);
        p[3 * 4 + 1] = VP8Util.avg3(edge[0], edge[1], edge[2]);
        p[2 * 4 + 0] = p[3 * 4 + 2] = VP8Util.avg2(edge[1], edge[2]);
        p[2 * 4 + 1] = p[3 * 4 + 3] = VP8Util.avg3(edge[1], edge[2], edge[3]);
        p[2 * 4 + 2] = p[1 * 4 + 0] = VP8Util.avg2(edge[2], edge[3]);
        p[2 * 4 + 3] = p[1 * 4 + 1] = VP8Util.avg3(edge[2], edge[3], edge[4]);
        p[1 * 4 + 2] = p[0 * 4 + 0] = VP8Util.avg2(edge[3], edge[4]);
        p[1 * 4 + 3] = p[0 * 4 + 1] = VP8Util.avg3(edge[3], edge[4], edge[5]);
        p[0 * 4 + 2] = VP8Util.avg3(edge[4], edge[5], edge[6]);
        p[0 * 4 + 3] = VP8Util.avg3(edge[5], edge[6], edge[7]);
        return p;
    };
    constructor.predictVL = function(above, aboveRight) {
        var p = new Int32Array(16);
        p[0 * 4 + 0] = VP8Util.avg2(above[0], above[1]);
        p[1 * 4 + 0] = VP8Util.avg3(above[0], above[1], above[2]);
        p[2 * 4 + 0] = p[0 * 4 + 1] = VP8Util.avg2(above[1], above[2]);
        p[1 * 4 + 1] = p[3 * 4 + 0] = VP8Util.avg3(above[1], above[2], above[3]);
        p[2 * 4 + 1] = p[0 * 4 + 2] = VP8Util.avg2(above[2], above[3]);
        p[3 * 4 + 1] = p[1 * 4 + 2] = VP8Util.avg3(above[2], above[3], aboveRight[0]);
        p[2 * 4 + 2] = p[0 * 4 + 3] = VP8Util.avg2(above[3], aboveRight[0]);
        p[3 * 4 + 2] = p[1 * 4 + 3] = VP8Util.avg3(above[3], aboveRight[0], aboveRight[1]);
        p[2 * 4 + 3] = VP8Util.avg3(aboveRight[0], aboveRight[1], aboveRight[2]);
        p[3 * 4 + 3] = VP8Util.avg3(aboveRight[1], aboveRight[2], aboveRight[3]);
        return p;
    };
    constructor.predictVR = function(above, left, aboveLeft) {
        var p = new Int32Array(16);
        var edge = new Int32Array(9);
        edge[0] = left[3];
        edge[1] = left[2];
        edge[2] = left[1];
        edge[3] = left[0];
        edge[4] = aboveLeft;
        edge[5] = above[0];
        edge[6] = above[1];
        edge[7] = above[2];
        edge[8] = above[3];
        p[3 * 4 + 0] = VP8Util.avg3(edge[1], edge[2], edge[3]);
        p[2 * 4 + 0] = VP8Util.avg3(edge[2], edge[3], edge[4]);
        p[3 * 4 + 1] = p[1 * 4 + 0] = VP8Util.avg3(edge[3], edge[4], edge[5]);
        p[2 * 4 + 1] = p[0 * 4 + 0] = VP8Util.avg2(edge[4], edge[5]);
        p[3 * 4 + 2] = p[1 * 4 + 1] = VP8Util.avg3(edge[4], edge[5], edge[6]);
        p[2 * 4 + 2] = p[0 * 4 + 1] = VP8Util.avg2(edge[5], edge[6]);
        p[3 * 4 + 3] = p[1 * 4 + 2] = VP8Util.avg3(edge[5], edge[6], edge[7]);
        p[2 * 4 + 3] = p[0 * 4 + 2] = VP8Util.avg2(edge[6], edge[7]);
        p[1 * 4 + 3] = VP8Util.avg3(edge[6], edge[7], edge[8]);
        p[0 * 4 + 3] = VP8Util.avg2(edge[7], edge[8]);
        return p;
    };
    /**
     *  <pre>
     *   E4|E5|E6|E7|E8|
     *   __|__|__|__|__|
     *   E3|
     *   __|
     *   E2|
     *   __|
     *   E1|
     *   __|
     *   E0|
     *   __|
     *  </pre>
     *  
     *  @param above
     *  @param left
     *  @param aboveLeft
     *  @return
     */
    constructor.predictRD = function(above, left, aboveLeft) {
        var p = new Int32Array(16);
        var edge = new Int32Array(9);
        edge[0] = left[3];
        edge[1] = left[2];
        edge[2] = left[1];
        edge[3] = left[0];
        edge[4] = aboveLeft;
        edge[5] = above[0];
        edge[6] = above[1];
        edge[7] = above[2];
        edge[8] = above[3];
        p[3 * 4 + 0] = VP8Util.avg3(edge[0], edge[1], edge[2]);
        p[3 * 4 + 1] = p[2 * 4 + 0] = VP8Util.avg3(edge[1], edge[2], edge[3]);
        p[3 * 4 + 2] = p[2 * 4 + 1] = p[1 * 4 + 0] = VP8Util.avg3(edge[2], edge[3], edge[4]);
        p[3 * 4 + 3] = p[2 * 4 + 2] = p[1 * 4 + 1] = p[0 * 4 + 0] = VP8Util.avg3(edge[3], edge[4], edge[5]);
        p[2 * 4 + 3] = p[1 * 4 + 2] = p[0 * 4 + 1] = VP8Util.avg3(edge[4], edge[5], edge[6]);
        p[1 * 4 + 3] = p[0 * 4 + 2] = VP8Util.avg3(edge[5], edge[6], edge[7]);
        p[0 * 4 + 3] = VP8Util.avg3(edge[6], edge[7], edge[8]);
        return p;
    };
    constructor.predictLD = function(above, aboveRight) {
        var p = new Int32Array(16);
        p[0 * 4 + 0] = VP8Util.avg3(above[0], above[1], above[2]);
        p[0 * 4 + 1] = p[1 * 4 + 0] = VP8Util.avg3(above[1], above[2], above[3]);
        p[0 * 4 + 2] = p[1 * 4 + 1] = p[2 * 4 + 0] = VP8Util.avg3(above[2], above[3], aboveRight[0]);
        p[0 * 4 + 3] = p[1 * 4 + 2] = p[2 * 4 + 1] = p[3 * 4 + 0] = VP8Util.avg3(above[3], aboveRight[0], aboveRight[1]);
        p[1 * 4 + 3] = p[2 * 4 + 2] = p[3 * 4 + 1] = VP8Util.avg3(aboveRight[0], aboveRight[1], aboveRight[2]);
        p[2 * 4 + 3] = p[3 * 4 + 2] = VP8Util.avg3(aboveRight[1], aboveRight[2], aboveRight[3]);
        p[3 * 4 + 3] = VP8Util.avg3(aboveRight[2], aboveRight[3], aboveRight[3]);
        return p;
    };
    constructor.predictHE = function(left, aboveLeft) {
        var p = new Int32Array(16);
        var v = VP8Util.avg3(left[2], left[3], left[3]);
        p[3 * 4 + 0] = p[3 * 4 + 1] = p[3 * 4 + 2] = p[3 * 4 + 3] = VP8Util.avg3(left[2], left[3], left[3]);
        p[2 * 4 + 0] = p[2 * 4 + 1] = p[2 * 4 + 2] = p[2 * 4 + 3] = VP8Util.avg3(left[1], left[2], left[3]);
        p[1 * 4 + 0] = p[1 * 4 + 1] = p[1 * 4 + 2] = p[1 * 4 + 3] = VP8Util.avg3(left[0], left[1], left[2]);
        p[0 * 4 + 0] = p[0 * 4 + 1] = p[0 * 4 + 2] = p[0 * 4 + 3] = VP8Util.avg3(aboveLeft, left[0], left[1]);
        return p;
    };
    /**
     *  avg3(Pixel x, Pixel y, Pixel z) { avg2(Pixel x, Pixel y) { return (x + y + 1) >> 1;}
     *  
     *  @param above
     *  @param aboveLeft
     *  @param aboveRight
     *  @return
     */
    constructor.predictVE = function(above, aboveLeft, aboveRight) {
        var p = new Int32Array(16);
        p[0 * 4 + 0] = p[1 * 4 + 0] = p[2 * 4 + 0] = p[3 * 4 + 0] = VP8Util.avg3(aboveLeft, above[0], above[1]);
        p[0 * 4 + 1] = p[1 * 4 + 1] = p[2 * 4 + 1] = p[3 * 4 + 1] = VP8Util.avg3(above[0], above[1], above[2]);
        p[0 * 4 + 2] = p[1 * 4 + 2] = p[2 * 4 + 2] = p[3 * 4 + 2] = VP8Util.avg3(above[1], above[2], above[3]);
        p[0 * 4 + 3] = p[1 * 4 + 3] = p[2 * 4 + 3] = p[3 * 4 + 3] = VP8Util.avg3(above[2], above[3], aboveRight[0]);
        return p;
    };
    constructor.avg2 = function(x, y) {
        return (x + y + 1) >> 1;
    };
    constructor.avg3 = function(x, y, z) {
        return (x + y + y + z + 2) >> 2;
    };
    constructor.predictTM = function(above, left, aboveLeft) {
        var p = new Int32Array(16);
        for (var aRow = 0; aRow < 4; aRow++) 
            for (var aCol = 0; aCol < 4; aCol++) 
                p[aRow * 4 + aCol] = VP8Util.QuantizationParams.clip255(left[aRow] + above[aCol] - aboveLeft);
        return p;
    };
    constructor.predictDC = function(above, left) {
        var p = new Int32Array(16);
        var v = 4;
        var i = 0;
        do {
            v += above[i] + left[i];
        } while (++i < 4);
        v >>= 3;
        for (var aRow = 0; aRow < 4; aRow++) 
            for (var aCol = 0; aCol < 4; aCol++) 
                p[aRow * 4 + aCol] = v;
        return p;
    };
    constructor.planeToType = function(plane, withY2) {
        switch (plane) {
            case VP8Util.PLANE.Y2:
                return 1;
            case VP8Util.PLANE.Y1:
                if (withY2) 
                    return 0;
                 else 
                    return 3;
            case VP8Util.PLANE.U:
                return 2;
            case VP8Util.PLANE.V:
                return 2;
        }
        return -1;
    };
}, {vp8KeyFrameUVModeProb: "Int32Array", vp8UVModeTree: "Int32Array", keyFrameYModeProb: "Int32Array", keyFrameYModeTree: "Int32Array", segmentTree: "Int32Array", PRED_BLOCK_127: "Int32Array", PRED_BLOCK_129: "Int32Array", vp8DefaultCoefProbs: "Array", vp8CoefUpdateProbs: "Array"}, {});
var LogSink = function() {};
LogSink = stjs.extend(LogSink, null, [], function(constructor, prototype) {
    prototype.postMessage = function(msg) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Context model for table-based binary arithmetic encoders/decoders
 *  
 *  Stores probability state table index and current MPS symbol value
 *  
 *  @author The JCodec project
 *  
 */
var Context = function(state, mps) {
    this.stateIdx = state;
    this.mps = mps;
};
Context = stjs.extend(Context, null, [], function(constructor, prototype) {
    prototype.stateIdx = 0;
    prototype.mps = 0;
    prototype.getState = function() {
        return this.stateIdx;
    };
    prototype.getMps = function() {
        return this.mps;
    };
    prototype.setMps = function(mps) {
        this.mps = mps;
    };
    prototype.setState = function(state) {
        this.stateIdx = state;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var AutoResource = function() {};
AutoResource = stjs.extend(AutoResource, null, [], function(constructor, prototype) {
    prototype.setCurTime = function(curTime) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A generic muxer interface.
 *  
 *  @author The JCodec project
 *  
 */
var Muxer = function() {};
Muxer = stjs.extend(Muxer, null, [], function(constructor, prototype) {
    /**
     *  Adds a video track and stores the provided metadata fields inside the
     *  container. Note: some containers don't store all or any metadata fields
     *  in which case some or all provided metadata will be ignored.
     *  
     *  @param codec
     *             Codec type stored in this track.
     *  @param meta
     *             Video metadata including the codec type.
     *  @return A track used further to store media samples.
     */
    prototype.addVideoTrack = function(codec, meta) {};
    /**
     *  Adds an audio track and stores the provided metadata fields inside the
     *  container. Note: some containers don't store all or any metadata fields
     *  in which case some or all provided metadata will be ignored.
     *  
     *  @param codec
     *             Codec type stored in this track.
     *  @param meta
     *             Audio metadata including the codec type.
     *  @return A track used further to store media samples.
     */
    prototype.addAudioTrack = function(codec, meta) {};
    /**
     *  Finalize writing this file. This function needs to be called at the end
     *  of the muxing session since some muxers use global headers and those can
     *  only be known at the end of the coding session. After calling this method
     *  no further muxing is possible with this muxer though this check might not
     *  be enforced by individual muxers. Calling any muxer methods after this
     *  function returns yields an undefined behavior.
     *  
     *  @throws IOException
     */
    prototype.finish = function() {};
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var HCB = function() {};
HCB = stjs.extend(HCB, null, [], function(constructor, prototype) {
    constructor.ZERO_HCB = 0;
    constructor.ESCAPE_HCB = 11;
    constructor.NOISE_HCB = 13;
    constructor.INTENSITY_HCB2 = 14;
    constructor.INTENSITY_HCB = 15;
    constructor.FIRST_PAIR_HCB = 5;
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Source = function() {};
Source = stjs.extend(Source, null, [], function(constructor, prototype) {
    /**
     *  Starts reading media data from the source.
     *  
     *  @param pixelStore
     *             The pixel store where the buffers for the returned pictures
     *             will be borrowed from.
     *  
     *  @throws IOException
     */
    prototype.init = function(pixelStore) {};
    /**
     *  Skips some number of frames in this source
     *  
     *  @param skipFrames
     *             The number of frames to skip
     *  @throws IOException
     */
    prototype.seekFrames = function(seekFrames) {};
    /**
     *  Gets the next video frame from this source
     *  
     *  @return A picture holding the decoded frame, when the picture is not used
     *          it must be returned to the appropriate pixel store for the
     *          maximum efficiency.
     *  @throws IOException
     */
    prototype.getNextVideoFrame = function() {};
    /**
     *  Gets the next decoded audio frame from this source
     *  
     *  @return The audio buffer containing PCM samples of the decoded audio and
     *          the audio format.
     */
    prototype.getNextAudioFrame = function() {};
    /**
     *  Closes the input and flushes all the buffers related to this source.
     */
    prototype.finish = function() {};
    prototype.haveAudio = function() {};
    prototype.setOption = function(option, value) {};
    /**
     *  Gets the metadata about video
     *  @return
     */
    prototype.getVideoCodecMeta = function() {};
    /**
     *  Gets the metadata about audio
     *  @return
     */
    prototype.getAudioCodecMeta = function() {};
    prototype.isVideo = function() {};
    prototype.isAudio = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VPXDCT = function() {};
VPXDCT = stjs.extend(VPXDCT, null, [], function(constructor, prototype) {
    constructor.fdct4x4 = function(coef) {
        for (var i = 0; i < 16; i += 4) {
            var a1 = ((coef[i] + coef[i + 3]) << 3);
            var b1 = ((coef[i + 1] + coef[i + 2]) << 3);
            var c1 = ((coef[i + 1] - coef[i + 2]) << 3);
            var d1 = ((coef[i] - coef[i + 3]) << 3);
            coef[i] = a1 + b1;
            coef[i + 2] = a1 - b1;
            coef[i + 1] = (c1 * 2217 + d1 * 5352 + 14500) >> 12;
            coef[i + 3] = (d1 * 2217 - c1 * 5352 + 7500) >> 12;
        }
        for (var i = 0; i < 4; i++) {
            var a1 = coef[i] + coef[i + 12];
            var b1 = coef[i + 4] + coef[i + 8];
            var c1 = coef[i + 4] - coef[i + 8];
            var d1 = coef[i] - coef[i + 12];
            coef[i] = (a1 + b1 + 7) >> 4;
            coef[i + 8] = (a1 - b1 + 7) >> 4;
            coef[i + 4] = ((c1 * 2217 + d1 * 5352 + 12000) >> 16) + (d1 != 0 ? 1 : 0);
            coef[i + 12] = (d1 * 2217 - c1 * 5352 + 51000) >> 16;
        }
    };
    constructor.walsh4x4 = function(coef) {
        for (var i = 0; i < 16; i += 4) {
            var a1 = ((coef[i] + coef[i + 2]) << 2);
            var d1 = ((coef[i + 1] + coef[i + 3]) << 2);
            var c1 = ((coef[i + 1] - coef[i + 3]) << 2);
            var b1 = ((coef[i] - coef[i + 2]) << 2);
            coef[i] = a1 + d1 + (a1 != 0 ? 1 : 0);
            coef[i + 1] = b1 + c1;
            coef[i + 2] = b1 - c1;
            coef[i + 3] = a1 - d1;
        }
        for (var i = 0; i < 4; i++) {
            var a1 = coef[i] + coef[i + 8];
            var d1 = coef[i + 4] + coef[i + 12];
            var c1 = coef[i + 4] - coef[i + 12];
            var b1 = coef[i] - coef[i + 8];
            var a2 = a1 + d1;
            var b2 = b1 + c1;
            var c2 = b1 - c1;
            var d2 = a1 - d1;
            a2 += a2 < 0 ? 1 : 0;
            b2 += b2 < 0 ? 1 : 0;
            c2 += c2 < 0 ? 1 : 0;
            d2 += d2 < 0 ? 1 : 0;
            coef[i] = (a2 + 3) >> 3;
            coef[i + 4] = (b2 + 3) >> 3;
            coef[i + 8] = (c2 + 3) >> 3;
            coef[i + 12] = (d2 + 3) >> 3;
        }
    };
    constructor.cospi8sqrt2minus1 = 20091;
    constructor.sinpi8sqrt2 = 35468;
    constructor.idct4x4 = function(coef) {
        for (var i = 0; i < 4; i++) {
            var a1 = coef[i] + coef[i + 8];
            var b1 = coef[i] - coef[i + 8];
            var temp1 = (coef[i + 4] * VPXDCT.sinpi8sqrt2) >> 16;
            var temp2 = coef[i + 12] + ((coef[i + 12] * VPXDCT.cospi8sqrt2minus1) >> 16);
            var c1 = temp1 - temp2;
            temp1 = coef[i + 4] + ((coef[i + 4] * VPXDCT.cospi8sqrt2minus1) >> 16);
            temp2 = (coef[i + 12] * VPXDCT.sinpi8sqrt2) >> 16;
            var d1 = temp1 + temp2;
            coef[i] = a1 + d1;
            coef[i + 12] = a1 - d1;
            coef[i + 4] = b1 + c1;
            coef[i + 8] = b1 - c1;
        }
        for (var i = 0; i < 16; i += 4) {
            var a1 = coef[i] + coef[i + 2];
            var b1 = coef[i] - coef[i + 2];
            var temp1 = (coef[i + 1] * VPXDCT.sinpi8sqrt2) >> 16;
            var temp2 = coef[i + 3] + ((coef[i + 3] * VPXDCT.cospi8sqrt2minus1) >> 16);
            var c1 = temp1 - temp2;
            temp1 = coef[i + 1] + ((coef[i + 1] * VPXDCT.cospi8sqrt2minus1) >> 16);
            temp2 = (coef[i + 3] * VPXDCT.sinpi8sqrt2) >> 16;
            var d1 = temp1 + temp2;
            coef[i] = (a1 + d1 + 4) >> 3;
            coef[i + 3] = (a1 - d1 + 4) >> 3;
            coef[i + 1] = (b1 + c1 + 4) >> 3;
            coef[i + 2] = (b1 - c1 + 4) >> 3;
        }
    };
    constructor.iwalsh4x4 = function(coef) {
        for (var i = 0; i < 4; i++) {
            var a1 = coef[i] + coef[i + 12];
            var b1 = coef[i + 4] + coef[i + 8];
            var c1 = coef[i + 4] - coef[i + 8];
            var d1 = coef[i] - coef[i + 12];
            coef[i] = a1 + b1;
            coef[i + 4] = c1 + d1;
            coef[i + 8] = a1 - b1;
            coef[i + 12] = d1 - c1;
        }
        for (var i = 0; i < 16; i += 4) {
            var a1 = coef[i] + coef[i + 3];
            var b1 = coef[i + 1] + coef[i + 2];
            var c1 = coef[i + 1] - coef[i + 2];
            var d1 = coef[i] - coef[i + 3];
            var a2 = a1 + b1;
            var b2 = c1 + d1;
            var c2 = a1 - b1;
            var d2 = d1 - c1;
            coef[i] = (a2 + 3) >> 3;
            coef[i + 1] = (b2 + 3) >> 3;
            coef[i + 2] = (c2 + 3) >> 3;
            coef[i + 3] = (d2 + 3) >> 3;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IDCT2x2 = function() {};
IDCT2x2 = stjs.extend(IDCT2x2, null, [], function(constructor, prototype) {
    constructor.idct = function(blk, off) {
        var x0 = blk[off], x1 = blk[off + 1], x2 = blk[off + 2], x3 = blk[off + 3];
        var t0 = x0 + x2;
        var t2 = x0 - x2;
        var t1 = x1 + x3;
        var t3 = x1 - x3;
        blk[off] = (t0 + t1) >> 3;
        blk[off + 1] = (t0 - t1) >> 3;
        blk[off + 2] = (t2 + t3) >> 3;
        blk[off + 3] = (t2 - t3) >> 3;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var ImageConvert = function() {};
ImageConvert = stjs.extend(ImageConvert, null, [], function(constructor, prototype) {
    constructor.SCALEBITS = 10;
    constructor.ONE_HALF = (1 << (ImageConvert.SCALEBITS - 1));
    constructor.FIX = function(x) {
        return (stjs.trunc(((x) * (1 << ImageConvert.SCALEBITS) + 0.5)));
    };
    constructor.FIX_0_71414 = ImageConvert.FIX(0.71414);
    constructor.FIX_1_772 = ImageConvert.FIX(1.772);
    constructor._FIX_0_34414 = -ImageConvert.FIX(0.34414);
    constructor.FIX_1_402 = ImageConvert.FIX(1.402);
    constructor.ycbcr_to_rgb24 = function(y, cb, cr) {
        y = y << ImageConvert.SCALEBITS;
        cb = cb - 128;
        cr = cr - 128;
        var add_r = ImageConvert.FIX_1_402 * cr + ImageConvert.ONE_HALF;
        var add_g = ImageConvert._FIX_0_34414 * cb - ImageConvert.FIX_0_71414 * cr + ImageConvert.ONE_HALF;
        var add_b = ImageConvert.FIX_1_772 * cb + ImageConvert.ONE_HALF;
        var r = (y + add_r) >> ImageConvert.SCALEBITS;
        var g = (y + add_g) >> ImageConvert.SCALEBITS;
        var b = (y + add_b) >> ImageConvert.SCALEBITS;
        r = ImageConvert.crop(r);
        g = ImageConvert.crop(g);
        b = ImageConvert.crop(b);
        return ((r & 255) << 16) | ((g & 255) << 8) | (b & 255);
    };
    constructor.CROP = 1024;
    constructor.Y_JPEG_TO_CCIR = function(y) {
        return (((y) * ImageConvert.FIX(219.0 / 255.0) + (ImageConvert.ONE_HALF + (16 << ImageConvert.SCALEBITS))) >> ImageConvert.SCALEBITS);
    };
    constructor.Y_CCIR_TO_JPEG = function(y) {
        return ((y) * ImageConvert.FIX(255.0 / 219.0) + (ImageConvert.ONE_HALF - 16 * ImageConvert.FIX(255.0 / 219.0))) >> ImageConvert.SCALEBITS;
    };
    constructor.cropTable = new Int8Array(ImageConvert.CROP + 256 + ImageConvert.CROP);
    constructor.intCropTable = new Int32Array(ImageConvert.CROP + 256 + ImageConvert.CROP);
    constructor._y_ccir_to_jpeg = new Int8Array(256);
    constructor._y_jpeg_to_ccir = new Int8Array(256);
    constructor.icrop = function(i) {
        return ImageConvert.intCropTable[i + ImageConvert.CROP];
    };
    constructor.crop = function(i) {
        return ImageConvert.cropTable[i + ImageConvert.CROP];
    };
    constructor.y_ccir_to_jpeg = function(y) {
        return ImageConvert._y_ccir_to_jpeg[(y & 255)];
    };
    constructor.y_jpeg_to_ccir = function(y) {
        return ImageConvert._y_jpeg_to_ccir[(y & 255)];
    };
    constructor.YUV444toRGB888 = function(y, u, v, rgb) {
        var c = y - 16;
        var d = u - 128;
        var e = v - 128;
        var r = (298 * c + 409 * e + 128) >> 8;
        var g = (298 * c - 100 * d - 208 * e + 128) >> 8;
        var b = (298 * c + 516 * d + 128) >> 8;
        rgb.put(ImageConvert.crop(r));
        rgb.put(ImageConvert.crop(g));
        rgb.put(ImageConvert.crop(b));
    };
    constructor.RGB888toYUV444 = function(rgb, Y, U, V) {
        var r = rgb.get() & 255;
        var g = rgb.get() & 255;
        var b = rgb.get() & 255;
        var y = 66 * r + 129 * g + 25 * b;
        var u = -38 * r - 74 * g + 112 * b;
        var v = 112 * r - 94 * g - 18 * b;
        y = (y + 128) >> 8;
        u = (u + 128) >> 8;
        v = (v + 128) >> 8;
        Y.put(ImageConvert.crop(y + 16));
        U.put(ImageConvert.crop(u + 128));
        V.put(ImageConvert.crop(v + 128));
    };
    constructor.RGB888toY4 = function(r, g, b) {
        var y = 66 * r + 129 * g + 25 * b;
        y = (y + 128) >> 8;
        return ImageConvert.crop(y + 16);
    };
    constructor.RGB888toU4 = function(r, g, b) {
        var u = -38 * r - 74 * g + 112 * b;
        u = (u + 128) >> 8;
        return ImageConvert.crop(u + 128);
    };
    constructor.RGB888toV4 = function(r, g, b) {
        var v = 112 * r - 94 * g - 18 * b;
        v = (v + 128) >> 8;
        return ImageConvert.crop(v + 128);
    };
}, {cropTable: "Int8Array", intCropTable: "Int32Array", _y_ccir_to_jpeg: "Int8Array", _y_jpeg_to_ccir: "Int8Array"}, {});
(function() {
    for (var i = -ImageConvert.CROP; i < 0; i++) {
        ImageConvert.cropTable[i + ImageConvert.CROP] = 0;
        ImageConvert.intCropTable[i + ImageConvert.CROP] = 0;
    }
    for (var i = 0; i < 256; i++) {
        ImageConvert.cropTable[i + ImageConvert.CROP] = (i << 24 >> 24);
        ImageConvert.intCropTable[i + ImageConvert.CROP] = i;
    }
    for (var i = 256; i < ImageConvert.CROP; i++) {
        ImageConvert.cropTable[i + ImageConvert.CROP] = (255 << 24 >> 24);
        ImageConvert.intCropTable[i + ImageConvert.CROP] = 255;
    }
    for (var i = 0; i < 256; i++) {
        ImageConvert._y_ccir_to_jpeg[i] = ImageConvert.crop(ImageConvert.Y_CCIR_TO_JPEG(i));
        ImageConvert._y_jpeg_to_ccir[i] = ImageConvert.crop(ImageConvert.Y_JPEG_TO_CCIR(i));
    }
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  H.264 encoder. Save/restore interface. Encoding process usually updates the
 *  context of decoding inplace so that the next coding unit has the context
 *  ready. However rate control algorithm may require that the current macroblock
 *  is redone with different choice of encoding parameters, in this case all the
 *  contexts need to be reset to their previous states.
 *  
 *  This interface is implemented by the components that support the function of
 *  clean restoring to the state at the time 'save' is called.
 *  
 *  @author Jay Codec
 *  
 */
var SaveRestore = function() {};
SaveRestore = stjs.extend(SaveRestore, null, [], function(constructor, prototype) {
    prototype.save = function() {};
    prototype.restore = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Sink = function() {};
Sink = stjs.extend(Sink, null, [], function(constructor, prototype) {
    /**
     *  Initializes output to this sink.
     *  
     *  @throws IOException
     */
    prototype.init = function() {};
    /**
     *  Outputs video frame to the sink
     *  
     *  @param decodedFrame
     *  @throws IOException
     */
    prototype.outputVideoFrame = function(videoFrame) {};
    /**
     *  Outputs an audio frame to the sink
     *  
     *  @param audioFrame
     *  @throws IOException
     */
    prototype.outputAudioFrame = function(audioFrame) {};
    /**
     *  Finilizes encoding process, flushes the buffers and closes off the
     *  output file (or any other resources for that matter).
     *  
     *  @throws IOException
     */
    prototype.finish = function() {};
    /**
     *  Gets the color space that the sink expects
     *  @return
     */
    prototype.getInputColor = function() {};
    prototype.setOption = function(profile, value) {};
    prototype.isVideo = function() {};
    prototype.isAudio = function() {};
}, {}, {});
var H264Utils2 = function() {};
H264Utils2 = stjs.extend(H264Utils2, null, [], function(constructor, prototype) {
    constructor.golomb2Signed = function(val) {
        var sign = ((val & 1) << 1) - 1;
        val = ((val >> 1) + (val & 1)) * sign;
        return val;
    };
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Tables of coefficients used for TNS.
 *  The suffix indicates the values of coefCompress and coefRes.
 *  @author in-somnia
 */
var TNSTables = function() {};
TNSTables = stjs.extend(TNSTables, null, [], function(constructor, prototype) {
    constructor.TNS_COEF_1_3 = new Float32Array([0.0, -0.43388373, 0.6427876, 0.34202015]);
    constructor.TNS_COEF_0_3 = new Float32Array([0.0, -0.43388373, -0.7818315, -0.9749279, 0.9848077, 0.8660254, 0.6427876, 0.34202015]);
    constructor.TNS_COEF_1_4 = new Float32Array([0.0, -0.2079117, -0.40673664, -0.58778524, 0.6736956, 0.52643216, 0.36124167, 0.18374951]);
    constructor.TNS_COEF_0_4 = new Float32Array([0.0, -0.2079117, -0.40673664, -0.58778524, -0.7431448, -0.8660254, -0.95105654, -0.9945219, 0.99573416, 0.9618256, 0.8951633, 0.7980172, 0.6736956, 0.52643216, 0.36124167, 0.18374951]);
    constructor.TNS_TABLES = [TNSTables.TNS_COEF_0_3, TNSTables.TNS_COEF_0_4, TNSTables.TNS_COEF_1_3, TNSTables.TNS_COEF_1_4];
}, {TNS_COEF_1_3: "Float32Array", TNS_COEF_0_3: "Float32Array", TNS_COEF_1_4: "Float32Array", TNS_COEF_0_4: "Float32Array", TNS_TABLES: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var PSConstants = function() {};
PSConstants = stjs.extend(PSConstants, null, [], function(constructor, prototype) {
    constructor.MAX_PS_ENVELOPES = 5;
    constructor.NO_ALLPASS_LINKS = 3;
    constructor.NEGATE_IPD_MASK = 4096;
    constructor.DECAY_SLOPE = 0.05;
    constructor.COEF_SQRT2 = 1.4142135;
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var PSHuffmanTables = function() {};
PSHuffmanTables = stjs.extend(PSHuffmanTables, null, [], function(constructor, prototype) {
    constructor.f_huff_iid_def = [new Int32Array([-31, 1]), new Int32Array([2, 3]), new Int32Array([-30, -32]), new Int32Array([4, 5]), new Int32Array([-29, -33]), new Int32Array([6, 7]), new Int32Array([-28, -34]), new Int32Array([8, 9]), new Int32Array([-35, -27]), new Int32Array([-26, 10]), new Int32Array([-36, 11]), new Int32Array([-25, 12]), new Int32Array([-37, 13]), new Int32Array([-38, 14]), new Int32Array([-24, 15]), new Int32Array([16, 17]), new Int32Array([-23, -39]), new Int32Array([18, 19]), new Int32Array([-22, -21]), new Int32Array([20, 21]), new Int32Array([-40, -20]), new Int32Array([22, 23]), new Int32Array([-41, 24]), new Int32Array([25, 26]), new Int32Array([-42, -45]), new Int32Array([-44, -43]), new Int32Array([-19, 27]), new Int32Array([-18, -17])];
    constructor.t_huff_iid_def = [new Int32Array([-31, 1]), new Int32Array([-32, 2]), new Int32Array([-30, 3]), new Int32Array([-33, 4]), new Int32Array([-29, 5]), new Int32Array([-34, 6]), new Int32Array([-28, 7]), new Int32Array([-35, 8]), new Int32Array([-27, 9]), new Int32Array([-36, 10]), new Int32Array([-26, 11]), new Int32Array([-37, 12]), new Int32Array([-25, 13]), new Int32Array([-24, 14]), new Int32Array([-38, 15]), new Int32Array([16, 17]), new Int32Array([-23, -39]), new Int32Array([18, 19]), new Int32Array([20, 21]), new Int32Array([22, 23]), new Int32Array([-22, -45]), new Int32Array([-44, -43]), new Int32Array([24, 25]), new Int32Array([26, 27]), new Int32Array([-42, -41]), new Int32Array([-40, -21]), new Int32Array([-20, -19]), new Int32Array([-18, -17])];
    constructor.f_huff_iid_fine = [new Int32Array([1, -31]), new Int32Array([2, 3]), new Int32Array([4, -32]), new Int32Array([-30, 5]), new Int32Array([-33, -29]), new Int32Array([6, 7]), new Int32Array([-34, -28]), new Int32Array([8, 9]), new Int32Array([-35, -27]), new Int32Array([10, 11]), new Int32Array([-36, -26]), new Int32Array([12, 13]), new Int32Array([-37, -25]), new Int32Array([14, 15]), new Int32Array([-24, 16]), new Int32Array([17, 18]), new Int32Array([19, -39]), new Int32Array([-23, 20]), new Int32Array([21, -38]), new Int32Array([-21, 22]), new Int32Array([23, -40]), new Int32Array([-22, 24]), new Int32Array([-42, -20]), new Int32Array([25, 26]), new Int32Array([27, -41]), new Int32Array([28, -43]), new Int32Array([-19, 29]), new Int32Array([30, 31]), new Int32Array([32, -45]), new Int32Array([-17, 33]), new Int32Array([34, -44]), new Int32Array([-18, 35]), new Int32Array([36, 37]), new Int32Array([38, -46]), new Int32Array([-16, 39]), new Int32Array([40, 41]), new Int32Array([42, 43]), new Int32Array([-48, -14]), new Int32Array([44, 45]), new Int32Array([46, 47]), new Int32Array([48, 49]), new Int32Array([-47, -15]), new Int32Array([-52, -10]), new Int32Array([-50, -12]), new Int32Array([-49, -13]), new Int32Array([50, 51]), new Int32Array([52, 53]), new Int32Array([54, 55]), new Int32Array([56, 57]), new Int32Array([58, 59]), new Int32Array([-57, -56]), new Int32Array([-59, -58]), new Int32Array([-53, -9]), new Int32Array([-55, -54]), new Int32Array([-6, -5]), new Int32Array([-8, -7]), new Int32Array([-2, -1]), new Int32Array([-4, -3]), new Int32Array([-61, -60]), new Int32Array([-51, -11])];
    constructor.t_huff_iid_fine = [new Int32Array([1, -31]), new Int32Array([-30, 2]), new Int32Array([3, -32]), new Int32Array([4, 5]), new Int32Array([6, 7]), new Int32Array([-33, -29]), new Int32Array([8, -34]), new Int32Array([-28, 9]), new Int32Array([-35, -27]), new Int32Array([10, 11]), new Int32Array([-26, 12]), new Int32Array([13, 14]), new Int32Array([-37, -25]), new Int32Array([15, 16]), new Int32Array([17, -36]), new Int32Array([18, -38]), new Int32Array([-24, 19]), new Int32Array([20, 21]), new Int32Array([-22, 22]), new Int32Array([23, 24]), new Int32Array([-39, -23]), new Int32Array([25, 26]), new Int32Array([-20, 27]), new Int32Array([28, 29]), new Int32Array([-41, -21]), new Int32Array([30, 31]), new Int32Array([32, -40]), new Int32Array([33, -44]), new Int32Array([-18, 34]), new Int32Array([35, 36]), new Int32Array([37, -43]), new Int32Array([-19, 38]), new Int32Array([39, -42]), new Int32Array([40, 41]), new Int32Array([42, 43]), new Int32Array([44, 45]), new Int32Array([46, -46]), new Int32Array([-16, 47]), new Int32Array([-45, -17]), new Int32Array([48, 49]), new Int32Array([-52, -51]), new Int32Array([-13, -12]), new Int32Array([-50, -49]), new Int32Array([50, 51]), new Int32Array([52, 53]), new Int32Array([54, 55]), new Int32Array([56, -48]), new Int32Array([-14, 57]), new Int32Array([58, -47]), new Int32Array([-15, 59]), new Int32Array([-57, -5]), new Int32Array([-59, -58]), new Int32Array([-2, -1]), new Int32Array([-4, -3]), new Int32Array([-61, -60]), new Int32Array([-56, -6]), new Int32Array([-55, -7]), new Int32Array([-54, -8]), new Int32Array([-53, -9]), new Int32Array([-11, -10])];
    constructor.f_huff_icc = [new Int32Array([-31, 1]), new Int32Array([-30, 2]), new Int32Array([-32, 3]), new Int32Array([-29, 4]), new Int32Array([-33, 5]), new Int32Array([-28, 6]), new Int32Array([-34, 7]), new Int32Array([-27, 8]), new Int32Array([-26, 9]), new Int32Array([-35, 10]), new Int32Array([-25, 11]), new Int32Array([-36, 12]), new Int32Array([-24, 13]), new Int32Array([-37, -38])];
    constructor.t_huff_icc = [new Int32Array([-31, 1]), new Int32Array([-30, 2]), new Int32Array([-32, 3]), new Int32Array([-29, 4]), new Int32Array([-33, 5]), new Int32Array([-28, 6]), new Int32Array([-34, 7]), new Int32Array([-27, 8]), new Int32Array([-35, 9]), new Int32Array([-26, 10]), new Int32Array([-36, 11]), new Int32Array([-25, 12]), new Int32Array([-37, 13]), new Int32Array([-38, -24])];
    constructor.f_huff_ipd = [new Int32Array([1, -31]), new Int32Array([2, 3]), new Int32Array([-30, 4]), new Int32Array([5, 6]), new Int32Array([-27, -26]), new Int32Array([-28, -25]), new Int32Array([-29, -24])];
    constructor.t_huff_ipd = [new Int32Array([1, -31]), new Int32Array([2, 3]), new Int32Array([4, 5]), new Int32Array([-30, -24]), new Int32Array([-26, 6]), new Int32Array([-29, -25]), new Int32Array([-27, -28])];
    constructor.f_huff_opd = [new Int32Array([1, -31]), new Int32Array([2, 3]), new Int32Array([-24, -30]), new Int32Array([4, 5]), new Int32Array([-28, -25]), new Int32Array([-29, 6]), new Int32Array([-26, -27])];
    constructor.t_huff_opd = [new Int32Array([1, -31]), new Int32Array([2, 3]), new Int32Array([4, 5]), new Int32Array([-30, -24]), new Int32Array([-26, -29]), new Int32Array([-25, 6]), new Int32Array([-27, -28])];
}, {f_huff_iid_def: "Array", t_huff_iid_def: "Array", f_huff_iid_fine: "Array", t_huff_iid_fine: "Array", f_huff_icc: "Array", t_huff_icc: "Array", f_huff_ipd: "Array", t_huff_ipd: "Array", f_huff_opd: "Array", t_huff_opd: "Array"}, {});
var AssertionException = function(string) {
    RuntimeException.call(this, string);
};
AssertionException = stjs.extend(AssertionException, RuntimeException, [], null, {}, {});
var NotSupportedException = function(_arguments) {
    RuntimeException.call(this, "" + arguments);
};
NotSupportedException = stjs.extend(NotSupportedException, RuntimeException, [], null, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MP4Edit = function() {};
MP4Edit = stjs.extend(MP4Edit, null, [], function(constructor, prototype) {
    /**
     *  Operation performed on a movie header and fragments
     *  
     *  @param mov
     */
    prototype.applyToFragment = function(mov, fragmentBox) {};
    /**
     *  Operation performed on a movie header
     *  
     *  @param mov
     */
    prototype.apply = function(mov) {};
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var FilterbankTable = function() {};
FilterbankTable = stjs.extend(FilterbankTable, null, [], function(constructor, prototype) {
    constructor.qmf_c = new Float32Array([0.0, -5.5252865E-4, -5.6176924E-4, -4.947518E-4, -4.875228E-4, -4.893791E-4, -5.040714E-4, -5.226564E-4, -5.4665655E-4, -5.677803E-4, -5.8709306E-4, -6.1327475E-4, -6.3124934E-4, -6.540333E-4, -6.777691E-4, -6.9416146E-4, -7.1577367E-4, -7.255043E-4, -7.440942E-4, -7.490598E-4, -7.6813716E-4, -7.7248487E-4, -7.834332E-4, -7.7798695E-4, -7.803665E-4, -7.8014494E-4, -7.7579776E-4, -7.630794E-4, -7.5300015E-4, -7.319357E-4, -7.215392E-4, -6.9179374E-4, -6.650415E-4, -6.341595E-4, -5.946119E-4, -5.564576E-4, -5.1455724E-4, -4.6063255E-4, -4.0951214E-4, -3.501176E-4, -2.8969813E-4, -2.0983373E-4, -1.4463809E-4, -6.173344E-5, 1.3494974E-5, 1.0943831E-4, 2.043017E-4, 2.9495312E-4, 4.0265403E-4, 5.107389E-4, 6.2393764E-4, 7.458026E-4, 8.6084433E-4, 9.885988E-4, 0.0011250156, 0.0012577885, 0.0013902495, 0.001544322, 0.0016868083, 0.0018348265, 0.001984114, 0.0021461584, 0.0023017256, 0.0024625617, 0.002620176, 0.0027870464, 0.0029469447, 0.003112542, 0.0032739614, 0.0034418874, 0.0036008267, 0.0037603923, 0.0039207432, 0.004081975, 0.004226427, 0.004373072, 0.0045209853, 0.004660646, 0.004793256, 0.0049137603, 0.005039302, 0.0051407353, 0.005246117, 0.005347168, 0.0054196776, 0.005487604, 0.0055475715, 0.0055938023, 0.005622064, 0.0056455196, 0.00563892, 0.0056266114, 0.005591713, 0.0055404366, 0.005475378, 0.0053838976, 0.005271576, 0.0051382277, 0.0049839686, 0.004810947, 0.004603953, 0.004380186, 0.0041251644, 0.003845641, 0.0035401247, 0.0032091886, 0.0028446757, 0.002450854, 0.0020274175, 0.0015784682, 0.0010902329, 5.8322644E-4, 2.760452E-5, -5.464281E-4, -0.0011568136, -0.0018039473, -0.0024826725, -0.0031933777, -0.0039401124, -0.0047222595, -0.0055337213, -0.0063792295, -0.0072615817, -0.008179823, -0.009132533, -0.010115022, -0.011131555, -0.012185, 0.013271822, 0.014390467, 0.015540555, 0.016732471, 0.017943338, 0.019187244, 0.02045318, 0.021746755, 0.023068016, 0.024416098, 0.025787584, 0.027185943, 0.028607218, 0.030050267, 0.031501763, 0.03297541, 0.034462094, 0.035969757, 0.037481286, 0.03900537, 0.040534917, 0.04206491, 0.043609753, 0.045148842, 0.046684302, 0.04821657, 0.049738575, 0.051255617, 0.052763075, 0.05424528, 0.055717364, 0.057161644, 0.058591567, 0.05998375, 0.061345518, 0.06268578, 0.06397159, 0.06522471, 0.06643675, 0.0676076, 0.06870438, 0.06976303, 0.07076287, 0.07170027, 0.07256826, 0.07336202, 0.07410037, 0.07474525, 0.07531373, 0.075800836, 0.07619925, 0.076499216, 0.07670935, 0.0768174, 0.076823, 0.07672049, 0.07650507, 0.07617483, 0.07573058, 0.07515763, 0.07446644, 0.0736406, 0.07267746, 0.07158264, 0.07035331, 0.0689664, 0.067452505, 0.06576907, 0.06394448, 0.061960276, 0.05981666, 0.05751527, 0.055046003, 0.05240938, 0.049597867, 0.04663033, 0.04347688, 0.04014583, 0.03664181, 0.032958392, 0.0290824, 0.025030756, 0.020799708, 0.016370125, 0.011762383, 0.006963686, 0.00197656, -0.0032086896, -0.008571175, -0.014128882, -0.019883413, -0.025822729, -0.031953126, -0.038277656, -0.044780683, -0.051480416, -0.058370534, -0.06544098, -0.07269433, -0.08013729, -0.087754756, -0.09555334, -0.103532955, -0.11168269, -0.1200078, -0.12850028, -0.13715518, -0.14597665, -0.1549607, -0.16409588, -0.17338082, -0.18281725, -0.19239667, -0.20212501, -0.2119736, -0.22196527, -0.23206909, -0.24230169, -0.25264803, -0.26310533, -0.2736634, -0.28432143, -0.29507166, -0.30590987, -0.3168279, -0.32781136, -0.33887228, -0.3499914, 0.361159, 0.37237954, 0.383635, 0.39492118, 0.40623176, 0.4175697, 0.42891198, 0.44025537, 0.45159966, 0.4629308, 0.4742453, 0.4855253, 0.49677083, 0.5079818, 0.5191235, 0.5302241, 0.54125535, 0.55220515, 0.56307894, 0.5738524, 0.5845403, 0.5951123, 0.60557836, 0.615911, 0.62612426, 0.636198, 0.646127, 0.6559016, 0.665514, 0.67496634, 0.68423533, 0.69332826, 0.70223886, 0.710941, 0.71944624, 0.7277449, 0.7358212, 0.7436828, 0.75131375, 0.75870806, 0.7658675, 0.7727781, 0.7794288, 0.7858353, 0.7919736, 0.7978466, 0.80344856, 0.8087695, 0.8138191, 0.8185776, 0.823042, 0.82722753, 0.83110386, 0.83469373, 0.83797175, 0.8409541, 0.8436238, 0.84598184, 0.8480316, 0.8497805, 0.8511971, 0.8523047, 0.8531021, 0.8535721, 0.85373855, 0.8535721, 0.8531021, 0.8523047, 0.8511971, 0.8497805, 0.8480316, 0.84598184, 0.8436238, 0.8409541, 0.83797175, 0.83469373, 0.83110386, 0.82722753, 0.823042, 0.8185776, 0.8138191, 0.8087695, 0.80344856, 0.7978466, 0.7919736, 0.7858353, 0.7794288, 0.7727781, 0.7658675, 0.75870806, 0.75131375, 0.7436828, 0.7358212, 0.7277449, 0.71944624, 0.710941, 0.70223886, 0.69332826, 0.68423533, 0.67496634, 0.665514, 0.6559016, 0.646127, 0.636198, 0.62612426, 0.615911, 0.60557836, 0.5951123, 0.5845403, 0.5738524, 0.56307894, 0.55220515, 0.54125535, 0.5302241, 0.5191235, 0.5079818, 0.49677083, 0.4855253, 0.4742453, 0.4629308, 0.45159966, 0.44025537, 0.42891198, 0.4175697, 0.40623176, 0.39492118, 0.383635, 0.37237954, -0.361159, -0.3499914, -0.33887228, -0.32781136, -0.3168279, -0.30590987, -0.29507166, -0.28432143, -0.2736634, -0.26310533, -0.25264803, -0.24230169, -0.23206909, -0.22196527, -0.2119736, -0.20212501, -0.19239667, -0.18281725, -0.17338082, -0.16409588, -0.1549607, -0.14597665, -0.13715518, -0.12850028, -0.1200078, -0.11168269, -0.103532955, -0.09555334, -0.087754756, -0.08013729, -0.07269433, -0.06544098, -0.058370534, -0.051480416, -0.044780683, -0.038277656, -0.031953126, -0.025822729, -0.019883413, -0.014128882, -0.008571175, -0.0032086896, 0.00197656, 0.006963686, 0.011762383, 0.016370125, 0.020799708, 0.025030756, 0.0290824, 0.032958392, 0.03664181, 0.04014583, 0.04347688, 0.04663033, 0.049597867, 0.05240938, 0.055046003, 0.05751527, 0.05981666, 0.061960276, 0.06394448, 0.06576907, 0.067452505, 0.0689664, 0.07035331, 0.07158264, 0.07267746, 0.0736406, 0.07446644, 0.07515763, 0.07573058, 0.07617483, 0.07650507, 0.07672049, 0.076823, 0.0768174, 0.07670935, 0.076499216, 0.07619925, 0.075800836, 0.07531373, 0.07474525, 0.07410037, 0.07336202, 0.07256826, 0.07170027, 0.07076287, 0.06976303, 0.06870438, 0.0676076, 0.06643675, 0.06522471, 0.06397159, 0.06268578, 0.061345518, 0.05998375, 0.058591567, 0.057161644, 0.055717364, 0.05424528, 0.052763075, 0.051255617, 0.049738575, 0.04821657, 0.046684302, 0.045148842, 0.043609753, 0.04206491, 0.040534917, 0.03900537, 0.037481286, 0.035969757, 0.034462094, 0.03297541, 0.031501763, 0.030050267, 0.028607218, 0.027185943, 0.025787584, 0.024416098, 0.023068016, 0.021746755, 0.02045318, 0.019187244, 0.017943338, 0.016732471, 0.015540555, 0.014390467, -0.013271822, -0.012185, -0.011131555, -0.010115022, -0.009132533, -0.008179823, -0.0072615817, -0.0063792295, -0.0055337213, -0.0047222595, -0.0039401124, -0.0031933777, -0.0024826725, -0.0018039473, -0.0011568136, -5.464281E-4, 2.760452E-5, 5.8322644E-4, 0.0010902329, 0.0015784682, 0.0020274175, 0.002450854, 0.0028446757, 0.0032091886, 0.0035401247, 0.003845641, 0.0041251644, 0.004380186, 0.004603953, 0.004810947, 0.0049839686, 0.0051382277, 0.005271576, 0.0053838976, 0.005475378, 0.0055404366, 0.005591713, 0.0056266114, 0.00563892, 0.0056455196, 0.005622064, 0.0055938023, 0.0055475715, 0.005487604, 0.0054196776, 0.005347168, 0.005246117, 0.0051407353, 0.005039302, 0.0049137603, 0.004793256, 0.004660646, 0.0045209853, 0.004373072, 0.004226427, 0.004081975, 0.0039207432, 0.0037603923, 0.0036008267, 0.0034418874, 0.0032739614, 0.003112542, 0.0029469447, 0.0027870464, 0.002620176, 0.0024625617, 0.0023017256, 0.0021461584, 0.001984114, 0.0018348265, 0.0016868083, 0.001544322, 0.0013902495, 0.0012577885, 0.0011250156, 9.885988E-4, 8.6084433E-4, 7.458026E-4, 6.2393764E-4, 5.107389E-4, 4.0265403E-4, 2.9495312E-4, 2.043017E-4, 1.0943831E-4, 1.3494974E-5, -6.173344E-5, -1.4463809E-4, -2.0983373E-4, -2.8969813E-4, -3.501176E-4, -4.0951214E-4, -4.6063255E-4, -5.1455724E-4, -5.564576E-4, -5.946119E-4, -6.341595E-4, -6.650415E-4, -6.9179374E-4, -7.215392E-4, -7.319357E-4, -7.5300015E-4, -7.630794E-4, -7.7579776E-4, -7.8014494E-4, -7.803665E-4, -7.7798695E-4, -7.834332E-4, -7.7248487E-4, -7.6813716E-4, -7.490598E-4, -7.440942E-4, -7.255043E-4, -7.1577367E-4, -6.9416146E-4, -6.777691E-4, -6.540333E-4, -6.3124934E-4, -6.1327475E-4, -5.8709306E-4, -5.677803E-4, -5.4665655E-4, -5.226564E-4, -5.040714E-4, -4.893791E-4, -4.875228E-4, -4.947518E-4, -5.6176924E-4, -5.5252865E-4]);
}, {qmf_c: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Packed4BitList = function() {};
Packed4BitList = stjs.extend(Packed4BitList, null, [], function(constructor, prototype) {
    constructor.CLEAR_MASK = new Int32Array([~(15 | (15 << 28)), ~(15 | (240 << 28)), ~(15 | (3840 << 28)), ~(15 | (61440 << 28)), ~(15 | (983040 << 28)), ~(15 | (15728640 << 28)), ~(15 | (251658240 << 28))]);
    /**
     *  Creates packed 4bit list with 7 values in it
     *  
     *  @return
     */
    constructor._7 = function(val0, val1, val2, val3, val4, val5, val6) {
        return (7 << 28) | ((val0 & 15) << 24) | ((val1 & 15) << 20) | ((val2 & 15) << 16) | ((val3 & 15) << 12) | ((val4 & 15) << 8) | ((val5 & 15) << 4) | ((val6 & 15));
    };
    constructor._3 = function(val0, val1, val2) {
        return Packed4BitList._7(val0, val1, val2, 0, 0, 0, 0);
    };
    /**
     *  Sets a 4 bit value into the list
     *  
     *  @param list
     *  @param val
     *  @param n
     *  @return
     */
    constructor.set = function(list, val, n) {
        var cnt = (list >> 28) & 15;
        var newc = n + 1;
        cnt = newc > cnt ? newc : cnt;
        return (list & Packed4BitList.CLEAR_MASK[n]) | ((val & 255) << (n << 2)) | (cnt << 28);
    };
    constructor.get = function(list, n) {
        if (n > 6) 
            return 0;
        return (list >> (n << 2)) & 255;
    };
}, {CLEAR_MASK: "Int32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 *  
 *  @author in-somnia
 */
var SBRConstants = function() {};
SBRConstants = stjs.extend(SBRConstants, null, [], function(constructor, prototype) {
    constructor.startMinTable = new Int32Array([7, 7, 10, 11, 12, 16, 16, 17, 24, 32, 35, 48]);
    constructor.offsetIndexTable = new Int32Array([5, 5, 4, 4, 4, 3, 2, 1, 0, 6, 6, 6]);
    constructor.OFFSET = [new Int32Array([-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7]), new Int32Array([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13]), new Int32Array([-5, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 16]), new Int32Array([-6, -4, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 16]), new Int32Array([-4, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 16, 20]), new Int32Array([-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 16, 20, 24]), new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 13, 16, 20, 24, 28, 33])];
    constructor.EXTENSION_ID_PS = 2;
    constructor.MAX_NTSRHFG = 40;
    constructor.MAX_NTSR = 32;
    constructor.MAX_M = 49;
    constructor.MAX_L_E = 5;
    constructor.EXT_SBR_DATA = 13;
    constructor.EXT_SBR_DATA_CRC = 14;
    constructor.FIXFIX = 0;
    constructor.FIXVAR = 1;
    constructor.VARFIX = 2;
    constructor.VARVAR = 3;
    constructor.LO_RES = 0;
    constructor.HI_RES = 1;
    constructor.NO_TIME_SLOTS_960 = 15;
    constructor.NO_TIME_SLOTS = 16;
    constructor.RATE = 2;
    constructor.NOISE_FLOOR_OFFSET = 6;
    constructor.T_HFGEN = 8;
    constructor.T_HFADJ = 2;
}, {startMinTable: "Int32Array", offsetIndexTable: "Int32Array", OFFSET: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AACConts = function() {};
AACConts = stjs.extend(AACConts, null, [], function(constructor, prototype) {
    constructor.AAC_CHANNEL_COUNT = new Int16Array([0, 1, 2, 3, 4, 5, 6, 8]);
    constructor.AAC_SAMPLE_RATES = new Int32Array([96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350]);
}, {AAC_CHANNEL_COUNT: "Int16Array", AAC_SAMPLE_RATES: "Int32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var KBDWindows = function() {};
KBDWindows = stjs.extend(KBDWindows, null, [], function(constructor, prototype) {
    constructor.KBD_1024 = new Float32Array([2.9256154E-4, 4.2998567E-4, 5.467407E-4, 6.5482303E-4, 7.5870194E-4, 8.6059334E-4, 9.617754E-4, 0.001063061, 0.0011650036, 0.0012680013, 0.0013723518, 0.0014782865, 0.0015859902, 0.0016956148, 0.0018072877, 0.0019211179, 0.0020372008, 0.0021556206, 0.0022764534, 0.0023997684, 0.002525629, 0.002654095, 0.0027852214, 0.0029190616, 0.0030556656, 0.0031950814, 0.0033373553, 0.0034825325, 0.0036306567, 0.0037817704, 0.003935915, 0.004093132, 0.004253461, 0.004416942, 0.004583614, 0.004753516, 0.0049266857, 0.0051031616, 0.0052829813, 0.005466182, 0.0056528007, 0.005842875, 0.0060364413, 0.006233536, 0.0064341966, 0.006638458, 0.0068463576, 0.0070579313, 0.0072732153, 0.007492245, 0.007715057, 0.0079416875, 0.008172171, 0.008406544, 0.008644843, 0.008887102, 0.009133358, 0.009383645, 0.009638, 0.009896458, 0.010159055, 0.010425826, 0.010696805, 0.010972029, 0.0112515325, 0.011535351, 0.011823521, 0.012116075, 0.01241305, 0.01271448, 0.013020401, 0.013330848, 0.013645855, 0.013965457, 0.014289689, 0.014618587, 0.014952184, 0.015290515, 0.015633615, 0.015981518, 0.01633426, 0.016691875, 0.017054394, 0.017421857, 0.017794292, 0.018171739, 0.018554227, 0.018941795, 0.019334473, 0.019732295, 0.020135297, 0.02054351, 0.020956969, 0.021375706, 0.021799758, 0.022229154, 0.02266393, 0.023104116, 0.023549749, 0.024000859, 0.024457477, 0.02491964, 0.025387377, 0.025860721, 0.026339704, 0.02682436, 0.027314719, 0.027810814, 0.028312674, 0.028820332, 0.02933382, 0.02985317, 0.03037841, 0.030909576, 0.03144669, 0.03198979, 0.032538906, 0.033094067, 0.0336553, 0.034222636, 0.03479611, 0.035375744, 0.035961572, 0.03655362, 0.03715192, 0.037756503, 0.03836739, 0.038984615, 0.039608207, 0.04023819, 0.040874593, 0.04151744, 0.042166766, 0.042822596, 0.043484952, 0.044153865, 0.044829357, 0.04551146, 0.0462002, 0.046895597, 0.04759768, 0.048306476, 0.049022008, 0.049744297, 0.050473373, 0.05120926, 0.05195198, 0.052701555, 0.05345801, 0.05422137, 0.05499166, 0.055768896, 0.056553107, 0.05734431, 0.058142528, 0.058947787, 0.0597601, 0.060579497, 0.061405994, 0.062239613, 0.06308037, 0.06392829, 0.064783394, 0.065645695, 0.066515215, 0.06739197, 0.06827598, 0.06916727, 0.07006585, 0.070971735, 0.071884945, 0.0728055, 0.07373342, 0.074668705, 0.07561139, 0.07656147, 0.077518985, 0.07848393, 0.07945632, 0.080436185, 0.08142353, 0.08241835, 0.083420694, 0.084430546, 0.08544793, 0.086472854, 0.08750533, 0.088545375, 0.08959299, 0.0906482, 0.091711, 0.0927814, 0.09385943, 0.09494507, 0.09603836, 0.09713928, 0.09824785, 0.09936407, 0.10048797, 0.101619534, 0.10275877, 0.10390569, 0.10506031, 0.106222615, 0.10739262, 0.10857033, 0.10975575, 0.110948876, 0.112149715, 0.113358274, 0.11457455, 0.115798555, 0.11703028, 0.11826973, 0.119516894, 0.120771796, 0.12203442, 0.12330477, 0.12458284, 0.12586865, 0.12716216, 0.1284634, 0.12977235, 0.13108903, 0.1324134, 0.13374549, 0.13508528, 0.13643277, 0.13778795, 0.13915081, 0.14052136, 0.14189959, 0.14328548, 0.14467904, 0.14608026, 0.1474891, 0.14890559, 0.15032972, 0.15176146, 0.1532008, 0.15464775, 0.15610228, 0.1575644, 0.15903409, 0.16051131, 0.1619961, 0.1634884, 0.16498822, 0.16649553, 0.16801035, 0.16953263, 0.17106237, 0.17259955, 0.17414416, 0.17569618, 0.1772556, 0.17882238, 0.18039654, 0.18197803, 0.18356684, 0.18516295, 0.18676636, 0.18837702, 0.18999492, 0.19162005, 0.19325238, 0.1948919, 0.19653857, 0.19819237, 0.1998533, 0.2015213, 0.20319638, 0.2048785, 0.20656763, 0.20826375, 0.20996685, 0.21167688, 0.21339384, 0.21511766, 0.21684836, 0.2185859, 0.22033022, 0.22208133, 0.2238392, 0.22560377, 0.22737503, 0.22915295, 0.2309375, 0.23272865, 0.23452635, 0.2363306, 0.23814134, 0.23995855, 0.2417822, 0.24361224, 0.24544866, 0.24729142, 0.24914046, 0.25099578, 0.2528573, 0.25472504, 0.25659892, 0.25847894, 0.26036504, 0.26225716, 0.2641553, 0.2660594, 0.26796943, 0.26988536, 0.27180713, 0.27373472, 0.27566808, 0.27760717, 0.27955195, 0.28150237, 0.2834584, 0.28542, 0.28738713, 0.28935972, 0.29133776, 0.29332116, 0.29530993, 0.297304, 0.29930335, 0.3013079, 0.3033176, 0.30533245, 0.30735236, 0.3093773, 0.31140724, 0.3134421, 0.31548184, 0.31752646, 0.31957585, 0.32162997, 0.3236888, 0.3257523, 0.32782036, 0.32989296, 0.3319701, 0.33405167, 0.33613762, 0.33822796, 0.34032255, 0.3424214, 0.34452447, 0.34663165, 0.34874293, 0.35085824, 0.3529775, 0.35510075, 0.35722783, 0.35935876, 0.36149344, 0.36363184, 0.3657739, 0.36791956, 0.3700688, 0.37222147, 0.37437764, 0.37653714, 0.37870002, 0.38086614, 0.38303548, 0.38520798, 0.38738358, 0.38956222, 0.39174384, 0.39392838, 0.3961158, 0.39830604, 0.40049905, 0.40269473, 0.40489307, 0.40709397, 0.40929738, 0.4115033, 0.41371155, 0.4159222, 0.4181351, 0.42035022, 0.42256752, 0.42478693, 0.42700836, 0.42923176, 0.4314571, 0.43368432, 0.43591332, 0.43814406, 0.44037646, 0.4426105, 0.44484606, 0.44708315, 0.44932166, 0.45156154, 0.4538027, 0.45604512, 0.45828876, 0.46053347, 0.46277925, 0.46502605, 0.46727377, 0.46952236, 0.47177178, 0.4740219, 0.47627273, 0.4785242, 0.4807762, 0.4830287, 0.48528165, 0.48753494, 0.48978856, 0.49204242, 0.49429646, 0.49655062, 0.49880484, 0.501059, 0.5033131, 0.50556713, 0.50782096, 0.5100745, 0.5123277, 0.5145805, 0.5168329, 0.51908475, 0.521336, 0.52358663, 0.5258366, 0.52808577, 0.5303341, 0.53258157, 0.53482807, 0.5370735, 0.5393179, 0.5415612, 0.5438032, 0.546044, 0.54828346, 0.55052155, 0.55275816, 0.5549932, 0.5572267, 0.5594586, 0.5616888, 0.5639172, 0.56614375, 0.5683685, 0.5705912, 0.57281196, 0.5750306, 0.57724714, 0.57946146, 0.58167356, 0.58388335, 0.58609074, 0.5882957, 0.59049815, 0.59269804, 0.59489536, 0.59708995, 0.59928185, 0.60147095, 0.6036572, 0.6058405, 0.60802084, 0.6101982, 0.6123724, 0.6145435, 0.6167114, 0.61887604, 0.62103736, 0.6231953, 0.6253498, 0.62750083, 0.62964827, 0.6317921, 0.63393235, 0.6360689, 0.6382016, 0.6403305, 0.6424555, 0.6445766, 0.6466937, 0.64880675, 0.65091574, 0.6530205, 0.65512115, 0.65721744, 0.6593095, 0.66139716, 0.6634804, 0.66555923, 0.6676335, 0.6697032, 0.67176825, 0.67382866, 0.6758843, 0.67793524, 0.6799813, 0.6820225, 0.6840588, 0.6860901, 0.6881164, 0.6901376, 0.69215375, 0.6941647, 0.69617045, 0.6981709, 0.7001661, 0.7021559, 0.70414037, 0.70611936, 0.70809287, 0.71006083, 0.7120232, 0.71398, 0.7159311, 0.71787655, 0.7198162, 0.7217501, 0.7236782, 0.7256003, 0.7275166, 0.72942686, 0.73133117, 0.73322946, 0.73512167, 0.73700774, 0.73888767, 0.7407614, 0.7426289, 0.74449015, 0.74634504, 0.7481936, 0.7500359, 0.75187165, 0.75370103, 0.75552386, 0.7573402, 0.75915, 0.7609532, 0.7627498, 0.7645397, 0.766323, 0.7680995, 0.76986927, 0.7716323, 0.7733885, 0.77513784, 0.7768803, 0.7786159, 0.78034455, 0.7820663, 0.783781, 0.78548867, 0.7871893, 0.7888829, 0.7905694, 0.79224885, 0.79392105, 0.7955861, 0.797244, 0.7988947, 0.8005381, 0.80217427, 0.80380315, 0.80542475, 0.807039, 0.8086459, 0.81024545, 0.8118376, 0.8134223, 0.81499964, 0.8165695, 0.8181319, 0.81968683, 0.8212342, 0.8227741, 0.8243065, 0.82583135, 0.8273486, 0.82885826, 0.83036035, 0.8318549, 0.8333417, 0.834821, 0.83629256, 0.8377565, 0.8392128, 0.84066135, 0.8421022, 0.8435354, 0.8449609, 0.8463787, 0.84778875, 0.84919107, 0.85058564, 0.85197246, 0.8533515, 0.8547228, 0.8560863, 0.8574421, 0.85879004, 0.86013025, 0.86146265, 0.86278725, 0.8641041, 0.8654131, 0.86671436, 0.8680078, 0.8692934, 0.8705712, 0.87184125, 0.87310344, 0.8743579, 0.8756045, 0.87684333, 0.87807435, 0.8792976, 0.8805131, 0.8817207, 0.88292056, 0.88411266, 0.885297, 0.88647354, 0.8876423, 0.88880336, 0.88995665, 0.8911022, 0.89224, 0.89337003, 0.8944924, 0.89560705, 0.896714, 0.8978132, 0.8989048, 0.89998865, 0.9010649, 0.90213346, 0.90319437, 0.9042477, 0.90529335, 0.9063314, 0.9073619, 0.90838486, 0.9094002, 0.910408, 0.9114083, 0.912401, 0.9133863, 0.91436404, 0.91533434, 0.9162972, 0.9172526, 0.91820055, 0.9191411, 0.92007434, 0.9210002, 0.92191863, 0.9228298, 0.92373365, 0.92463017, 0.92551947, 0.9264015, 0.9272763, 0.9281439, 0.9290044, 0.9298576, 0.93070376, 0.93154275, 0.93237466, 0.93319947, 0.9340173, 0.93482804, 0.9356318, 0.9364286, 0.9372184, 0.93800133, 0.9387773, 0.93954647, 0.94030875, 0.94106424, 0.9418129, 0.9425548, 0.94328994, 0.94401836, 0.94474006, 0.94545513, 0.9461636, 0.94686544, 0.9475607, 0.9482494, 0.94893163, 0.9496073, 0.95027655, 0.95093936, 0.9515958, 0.95224583, 0.9528895, 0.9535269, 0.954158, 0.95478284, 0.9554015, 0.956014, 0.9566203, 0.95722044, 0.9578145, 0.9584025, 0.95898455, 0.9595605, 0.9601306, 0.9606947, 0.96125287, 0.9618052, 0.96235174, 0.9628925, 0.9634274, 0.96395665, 0.96448016, 0.964998, 0.96551025, 0.9660169, 0.966518, 0.96701354, 0.9675036, 0.9679882, 0.96846735, 0.96894115, 0.9694096, 0.9698727, 0.97033054, 0.9707831, 0.9712305, 0.9716727, 0.97210974, 0.9725417, 0.9729686, 0.9733904, 0.9738073, 0.97421914, 0.97462606, 0.97502816, 0.97542536, 0.97581774, 0.9762053, 0.97658813, 0.97696626, 0.9773397, 0.9777085, 0.9780727, 0.9784323, 0.9787874, 0.979138, 0.97948414, 0.97982585, 0.98016316, 0.9804961, 0.9808247, 0.9811491, 0.98146915, 0.98178506, 0.9820968, 0.98240435, 0.98270786, 0.98300725, 0.9833026, 0.98359394, 0.98388135, 0.98416483, 0.98444444, 0.9847202, 0.9849921, 0.9852602, 0.9855246, 0.98578525, 0.9860422, 0.9862955, 0.98654526, 0.9867914, 0.987034, 0.9872731, 0.9875087, 0.9877409, 0.9879697, 0.98819506, 0.98841715, 0.9886359, 0.9888514, 0.9890637, 0.9892727, 0.98947865, 0.9896814, 0.98988104, 0.9900777, 0.9902712, 0.99046177, 0.99064934, 0.990834, 0.99101573, 0.9911946, 0.9913706, 0.9915438, 0.99171424, 0.99188197, 0.9920469, 0.9922092, 0.9923689, 0.9925259, 0.9926803, 0.9928322, 0.9929815, 0.99312836, 0.9932727, 0.99341464, 0.9935542, 0.9936913, 0.9938261, 0.9939586, 0.99408877, 0.9942167, 0.9943424, 0.9944658, 0.9945872, 0.99470633, 0.99482334, 0.99493825, 0.99505115, 0.99516195, 0.9952708, 0.99537766, 0.9954825, 0.99558544, 0.99568653, 0.99578565, 0.995883, 0.9959785, 0.9960722, 0.996164, 0.9962542, 0.99634266, 0.9964294, 0.99651444, 0.9965978, 0.9966796, 0.9967598, 0.99683833, 0.9969154, 0.99699086, 0.9970649, 0.99713737, 0.9972084, 0.997278, 0.99734616, 0.9974129, 0.9974783, 0.9975424, 0.9976051, 0.9976665, 0.99772656, 0.9977854, 0.99784297, 0.99789935, 0.9979545, 0.99800843, 0.99806124, 0.99811286, 0.9981634, 0.99821275, 0.9982611, 0.9983083, 0.99835443, 0.9983996, 0.9984437, 0.9984868, 0.99852896, 0.9985701, 0.9986103, 0.9986496, 0.9986879, 0.9987254, 0.998762, 0.9987977, 0.9988326, 0.9988666, 0.9988998, 0.9989322, 0.99896383, 0.99899465, 0.99902475, 0.9990541, 0.9990827, 0.9991106, 0.99913776, 0.9991643, 0.9991901, 0.9992153, 0.9992398, 0.9992637, 0.99928695, 0.9993096, 0.9993317, 0.9993532, 0.9993741, 0.9993944, 0.9994142, 0.9994335, 0.99945223, 0.9994705, 0.9994882, 0.99950546, 0.9995222, 0.9995385, 0.9995543, 0.99956965, 0.9995846, 0.9995991, 0.9996132, 0.9996269, 0.99964017, 0.99965304, 0.99966556, 0.9996777, 0.99968946, 0.99970084, 0.99971193, 0.99972266, 0.9997331, 0.99974316, 0.9997529, 0.99976236, 0.99977154, 0.99978036, 0.99978894, 0.9997973, 0.9998053, 0.9998131, 0.9998206, 0.99982786, 0.9998349, 0.9998417, 0.99984825, 0.99985456, 0.9998607, 0.9998666, 0.99987227, 0.9998778, 0.9998831, 0.9998882, 0.9998931, 0.9998979, 0.9999025, 0.9999069, 0.9999111, 0.99991524, 0.9999192, 0.99992293, 0.9999266, 0.9999301, 0.9999335, 0.9999367, 0.9999398, 0.9999428, 0.99994564, 0.9999484, 0.999951, 0.99995357, 0.99995595, 0.9999583, 0.9999605, 0.9999626, 0.99996465, 0.9999666, 0.99996847, 0.99997026, 0.9999719, 0.99997354, 0.9999751, 0.9999766, 0.99997795, 0.9999793, 0.99998057, 0.99998176, 0.99998295, 0.999984, 0.99998504, 0.99998605, 0.999987, 0.99998784, 0.9999887, 0.9999895, 0.9999902, 0.99999094, 0.9999916, 0.99999225, 0.99999285, 0.9999934, 0.9999939, 0.99999446, 0.9999949, 0.99999535, 0.99999577, 0.9999961, 0.9999965, 0.9999968, 0.99999714, 0.99999744, 0.9999977, 0.9999979, 0.99999815, 0.9999984, 0.99999857, 0.99999875, 0.9999989, 0.99999905, 0.9999992, 0.99999934, 0.99999946, 0.9999995, 0.99999964, 0.9999997, 0.99999976, 0.9999998, 0.9999999, 0.99999994]);
    constructor.KBD_128 = new Float32Array([4.3795702E-5, 1.18673845E-4, 2.3071657E-4, 3.894728E-4, 6.058127E-4, 8.9199696E-4, 0.0012617254, 0.0017301724, 0.0023140071, 0.0030313989, 0.003902005, 0.00494694, 0.006188728, 0.007651231, 0.00935956, 0.011339966, 0.013619707, 0.016226895, 0.019190324, 0.022539284, 0.02630334, 0.030512117, 0.03519505, 0.04038113, 0.046098642, 0.05237489, 0.059235904, 0.06670617, 0.074808344, 0.083562955, 0.09298815, 0.10309941, 0.11390932, 0.1254273, 0.13765942, 0.15060817, 0.1642723, 0.17864668, 0.19372223, 0.20948577, 0.22591996, 0.2430034, 0.26071054, 0.27901176, 0.29787362, 0.31725872, 0.33712614, 0.35743153, 0.3781274, 0.39916334, 0.4204864, 0.4420414, 0.46377128, 0.48561758, 0.5075207, 0.52942044, 0.5512564, 0.5729685, 0.5944971, 0.6157838, 0.6367718, 0.65740615, 0.67763436, 0.6974065, 0.7166758, 0.735399, 0.7535364, 0.7710523, 0.78791517, 0.8040978, 0.8195774, 0.83433586, 0.8483596, 0.86163956, 0.8741714, 0.885955, 0.89699465, 0.90729886, 0.91687983, 0.9257536, 0.93393934, 0.9414595, 0.94833905, 0.95460534, 0.9602877, 0.965417, 0.9700254, 0.9741459, 0.9778117, 0.9810564, 0.9839133, 0.986415, 0.9885935, 0.99047965, 0.9921028, 0.9934912, 0.99467105, 0.9956672, 0.9965025, 0.9971979, 0.99777263, 0.998244, 0.9986275, 0.9989369, 0.99918437, 0.99938047, 0.99953437, 0.999654, 0.99974597, 0.9998158, 0.99986833, 0.99990726, 0.9999357, 0.9999562, 0.99997073, 0.99998087, 0.9999878, 0.9999924, 0.9999954, 0.9999973, 0.9999985, 0.9999992, 0.9999996, 0.9999998, 0.99999994, 1.0, 1.0, 1.0]);
    constructor.KBD_960 = new Float32Array([3.0215626E-4, 4.452267E-4, 5.674948E-4, 6.812466E-4, 7.910497E-4, 8.991655E-4, 0.0010068978, 0.0011150759, 0.0012242653, 0.0013348736, 0.0014472068, 0.001561504, 0.0016779569, 0.0017967242, 0.0019179397, 0.0020417196, 0.0021681653, 0.002297368, 0.0024294101, 0.0025643678, 0.002702311, 0.0028433062, 0.0029874153, 0.0031346984, 0.0032852124, 0.0034390124, 0.0035961515, 0.0037566822, 0.0039206543, 0.0040881187, 0.004259123, 0.0044337157, 0.0046119443, 0.004793856, 0.0049794964, 0.0051689115, 0.0053621475, 0.005559249, 0.0057602613, 0.005965229, 0.006174197, 0.006387209, 0.0066043097, 0.006825543, 0.0070509524, 0.007280582, 0.007514476, 0.0077526774, 0.007995229, 0.008242176, 0.00849356, 0.008749426, 0.009009816, 0.009274773, 0.009544341, 0.009818562, 0.01009748, 0.010381138, 0.010669579, 0.010962844, 0.011260978, 0.011564023, 0.0118720215, 0.012185017, 0.01250305, 0.012826165, 0.013154404, 0.01348781, 0.013826424, 0.01417029, 0.014519448, 0.014873942, 0.015233814, 0.015599105, 0.015969856, 0.016346112, 0.016727913, 0.017115299, 0.017508315, 0.017907, 0.018311396, 0.018721545, 0.019137487, 0.019559264, 0.019986916, 0.020420484, 0.02086001, 0.021305535, 0.021757096, 0.022214737, 0.022678494, 0.023148412, 0.023624528, 0.024106883, 0.024595516, 0.025090465, 0.025591772, 0.026099475, 0.026613612, 0.027134223, 0.027661344, 0.028195018, 0.02873528, 0.02928217, 0.029835723, 0.030395979, 0.030962974, 0.031536747, 0.032117333, 0.03270477, 0.033299096, 0.033900343, 0.034508552, 0.035123758, 0.035745993, 0.0363753, 0.0370117, 0.037655246, 0.03830596, 0.03896388, 0.039629042, 0.04030148, 0.040981222, 0.041668307, 0.04236277, 0.043064635, 0.04377394, 0.04449072, 0.045215003, 0.04594682, 0.046686206, 0.04743319, 0.048187803, 0.048950076, 0.049720038, 0.05049772, 0.051283147, 0.052076355, 0.052877367, 0.053686213, 0.054502927, 0.055327527, 0.056160048, 0.057000514, 0.05784895, 0.058705386, 0.059569843, 0.060442355, 0.06132294, 0.062211625, 0.06310843, 0.06401339, 0.06492652, 0.065847844, 0.066777386, 0.067715175, 0.06866122, 0.06961555, 0.070578195, 0.071549155, 0.072528474, 0.07351615, 0.07451222, 0.07551669, 0.07652959, 0.07755093, 0.07858074, 0.07961902, 0.0806658, 0.08172109, 0.082784906, 0.08385727, 0.08493819, 0.08602769, 0.08712578, 0.088232465, 0.089347765, 0.0904717, 0.09160427, 0.0927455, 0.09389539, 0.095053956, 0.09622121, 0.097397156, 0.098581806, 0.09977517, 0.100977264, 0.10218809, 0.103407644, 0.10463595, 0.105873, 0.10711882, 0.1083734, 0.10963675, 0.110908866, 0.11218977, 0.11347944, 0.11477791, 0.11608516, 0.11740119, 0.118726015, 0.120059624, 0.12140203, 0.122753225, 0.12411321, 0.12548198, 0.12685953, 0.12824588, 0.129641, 0.1310449, 0.13245757, 0.133879, 0.13530922, 0.13674818, 0.13819589, 0.13965234, 0.14111754, 0.14259146, 0.14407411, 0.14556547, 0.14706554, 0.14857428, 0.15009172, 0.15161783, 0.15315259, 0.154696, 0.15624805, 0.1578087, 0.15937798, 0.16095585, 0.16254228, 0.16413727, 0.16574082, 0.1673529, 0.16897348, 0.17060255, 0.1722401, 0.17388609, 0.17554054, 0.17720339, 0.17887463, 0.18055424, 0.1822422, 0.18393849, 0.18564309, 0.18735597, 0.18907711, 0.19080646, 0.19254404, 0.19428979, 0.1960437, 0.19780573, 0.19957587, 0.20135407, 0.20314032, 0.20493457, 0.20673682, 0.20854701, 0.21036512, 0.21219113, 0.21402499, 0.21586668, 0.21771616, 0.2195734, 0.22143836, 0.223311, 0.22519132, 0.22707924, 0.22897474, 0.23087779, 0.23278835, 0.23470637, 0.23663183, 0.23856467, 0.24050486, 0.24245237, 0.24440713, 0.24636914, 0.24833833, 0.25031465, 0.2522981, 0.25428858, 0.25628608, 0.25829056, 0.26030195, 0.26232022, 0.26434532, 0.2663772, 0.26841584, 0.27046117, 0.27251315, 0.27457172, 0.2766368, 0.2787084, 0.28078645, 0.28287092, 0.2849617, 0.28705877, 0.2891621, 0.29127163, 0.29338726, 0.295509, 0.29763678, 0.2997705, 0.30191016, 0.3040557, 0.30620703, 0.3083641, 0.31052688, 0.3126953, 0.3148693, 0.31704885, 0.31923383, 0.32142425, 0.32362, 0.32582104, 0.3280273, 0.33023876, 0.3324553, 0.3346769, 0.33690348, 0.339135, 0.34137136, 0.34361252, 0.34585842, 0.348109, 0.3503642, 0.35262394, 0.35488814, 0.35715678, 0.35942975, 0.36170703, 0.36398852, 0.36627415, 0.36856386, 0.3708576, 0.3731553, 0.37545687, 0.3777623, 0.38007143, 0.38238424, 0.3847007, 0.38702068, 0.38934413, 0.39167097, 0.3940012, 0.39633462, 0.39867127, 0.40101105, 0.40335387, 0.40569967, 0.4080484, 0.41039994, 0.41275427, 0.41511127, 0.4174709, 0.4198331, 0.42219776, 0.4245648, 0.4269342, 0.42930585, 0.43167967, 0.43405563, 0.43643358, 0.43881354, 0.44119534, 0.443579, 0.44596437, 0.44835138, 0.45074, 0.45313016, 0.45552173, 0.45791465, 0.46030888, 0.46270433, 0.46510088, 0.46749854, 0.46989715, 0.47229666, 0.47469702, 0.47709814, 0.47949994, 0.48190233, 0.48430526, 0.48670864, 0.4891124, 0.49151644, 0.4939207, 0.49632514, 0.49872962, 0.5011341, 0.5035385, 0.50594276, 0.50834674, 0.5107504, 0.51315373, 0.5155565, 0.5179588, 0.52036047, 0.52276146, 0.5251616, 0.52756095, 0.5299594, 0.5323568, 0.53475314, 0.5371483, 0.53954226, 0.5419349, 0.5443261, 0.546716, 0.5491042, 0.55149084, 0.55387586, 0.55625904, 0.5586404, 0.5610199, 0.56339735, 0.5657728, 0.56814605, 0.5705171, 0.5728859, 0.5752523, 0.57761633, 0.5799778, 0.5823367, 0.58469296, 0.58704644, 0.5893972, 0.591745, 0.5940899, 0.59643185, 0.5987706, 0.6011062, 0.6034386, 0.6057677, 0.60809344, 0.6104157, 0.61273444, 0.6150496, 0.6173611, 0.6196689, 0.62197286, 0.62427294, 0.6265691, 0.62886125, 0.63114935, 0.6334333, 0.63571304, 0.63798845, 0.64025956, 0.64252627, 0.6447885, 0.64704615, 0.6492992, 0.65154755, 0.6537912, 0.65603006, 0.65826404, 0.660493, 0.66271704, 0.664936, 0.6671499, 0.66935855, 0.67156196, 0.67376006, 0.67595273, 0.67814004, 0.6803218, 0.6824981, 0.6846687, 0.6868337, 0.68899286, 0.6911463, 0.6932939, 0.6954356, 0.69757134, 0.699701, 0.70182467, 0.7039421, 0.70605344, 0.70815855, 0.7102573, 0.7123498, 0.71443576, 0.71651536, 0.7185884, 0.72065496, 0.72271484, 0.7247681, 0.7268146, 0.7288544, 0.7308874, 0.7329135, 0.7349327, 0.736945, 0.7389502, 0.74094844, 0.74293953, 0.74492353, 0.7469003, 0.7488699, 0.75083214, 0.7527872, 0.75473475, 0.756675, 0.75860775, 0.7605331, 0.7624508, 0.7643611, 0.76626366, 0.7681586, 0.77004594, 0.7719255, 0.7737973, 0.77566135, 0.7775175, 0.77936584, 0.7812063, 0.7830388, 0.78486335, 0.78667986, 0.7884884, 0.79028887, 0.79208124, 0.79386544, 0.79564154, 0.7974094, 0.7991691, 0.80092055, 0.80266374, 0.8043986, 0.80612516, 0.8078434, 0.80955327, 0.8112547, 0.8129477, 0.8146323, 0.8163084, 0.817976, 0.81963515, 0.8212857, 0.8229278, 0.8245612, 0.82618606, 0.8278023, 0.82940996, 0.831009, 0.8325993, 0.83418095, 0.8357539, 0.8373181, 0.8388737, 0.8404205, 0.8419585, 0.8434878, 0.8450083, 0.84652007, 0.848023, 0.84951717, 0.8510025, 0.85247904, 0.8539467, 0.85540557, 0.8568556, 0.85829675, 0.85972905, 0.86115247, 0.86256707, 0.8639728, 0.8653696, 0.86675763, 0.8681367, 0.86950696, 0.87086827, 0.87222075, 0.87356436, 0.8748991, 0.87622494, 0.8775419, 0.87885004, 0.88014925, 0.8814396, 0.8827212, 0.88399386, 0.88525766, 0.8865127, 0.88775885, 0.8889962, 0.8902247, 0.8914444, 0.89265525, 0.89385736, 0.8950507, 0.8962353, 0.8974111, 0.89857817, 0.89973646, 0.90088606, 0.90202695, 0.9031592, 0.9042827, 0.90539753, 0.90650374, 0.90760136, 0.9086903, 0.90977067, 0.9108424, 0.91190565, 0.9129603, 0.9140064, 0.91504407, 0.9160732, 0.9170939, 0.91810614, 0.91910994, 0.92010534, 0.9210924, 0.92207104, 0.9230414, 0.9240034, 0.92495716, 0.9259026, 0.9268399, 0.9277689, 0.9286897, 0.92960244, 0.930507, 0.93140346, 0.9322918, 0.93317217, 0.9340444, 0.93490875, 0.93576515, 0.93661356, 0.93745404, 0.9382867, 0.93911153, 0.93992853, 0.9407377, 0.94153917, 0.9423329, 0.943119, 0.9438974, 0.94466823, 0.9454315, 0.94618714, 0.9469353, 0.947676, 0.9484092, 0.94913507, 0.9498535, 0.9505646, 0.95126843, 0.951965, 0.95265424, 0.95333636, 0.9540113, 0.9546792, 0.95533997, 0.95599365, 0.9566404, 0.95728016, 0.957913, 0.9585389, 0.959158, 0.95977026, 0.9603758, 0.9609746, 0.9615666, 0.96215206, 0.9627309, 0.96330315, 0.96386886, 0.96442807, 0.9649809, 0.96552724, 0.96606725, 0.96660095, 0.9671284, 0.9676496, 0.96816456, 0.96867335, 0.96917605, 0.9696727, 0.9701633, 0.97064793, 0.9711266, 0.9715994, 0.97206634, 0.97252744, 0.97298276, 0.97343236, 0.9738763, 0.9743146, 0.97474724, 0.97517437, 0.975596, 0.9760121, 0.97642285, 0.97682816, 0.97722816, 0.97762287, 0.9780123, 0.9783966, 0.9787757, 0.97914964, 0.97951853, 0.97988236, 0.98024124, 0.9805952, 0.98094416, 0.9812883, 0.9816277, 0.98196226, 0.98229206, 0.98261726, 0.98293775, 0.98325366, 0.98356503, 0.9838719, 0.98417425, 0.9844722, 0.98476577, 0.98505497, 0.98533994, 0.9856206, 0.98589706, 0.98616934, 0.9864375, 0.9867016, 0.9869616, 0.98721766, 0.9874697, 0.98771787, 0.9879621, 0.9882026, 0.9884392, 0.9886721, 0.98890126, 0.98912674, 0.98934865, 0.9895669, 0.9897816, 0.98999286, 0.9902006, 0.9904049, 0.99060583, 0.9908034, 0.9909977, 0.9911887, 0.99137646, 0.991561, 0.99174243, 0.9919207, 0.9920959, 0.9922681, 0.99243724, 0.9926034, 0.9927667, 0.9929271, 0.99308455, 0.9932393, 0.99339116, 0.99354035, 0.9936868, 0.99383056, 0.9939717, 0.9941103, 0.99424624, 0.99437964, 0.9945106, 0.99463904, 0.9947651, 0.9948887, 0.99501, 0.9951289, 0.9952456, 0.99535996, 0.99547213, 0.99558204, 0.99568987, 0.9957955, 0.995899, 0.99600047, 0.9960999, 0.99619734, 0.99629277, 0.99638623, 0.9964778, 0.9965674, 0.9966552, 0.9967412, 0.99682534, 0.9969078, 0.9969884, 0.99706733, 0.9971445, 0.9972201, 0.997294, 0.99736637, 0.99743706, 0.99750626, 0.9975739, 0.99764, 0.9977047, 0.9977679, 0.9978297, 0.99789006, 0.99794906, 0.9980067, 0.99806297, 0.998118, 0.9981717, 0.99822414, 0.99827534, 0.99832535, 0.99837416, 0.9984218, 0.9984683, 0.99851364, 0.99855787, 0.998601, 0.9986431, 0.99868417, 0.99872416, 0.9987632, 0.99880123, 0.9988383, 0.9988744, 0.9989096, 0.99894387, 0.9989773, 0.9990098, 0.99904144, 0.9990723, 0.9991023, 0.9991315, 0.99915993, 0.9991876, 0.9992145, 0.99924064, 0.999266, 0.99929076, 0.99931484, 0.9993382, 0.9993609, 0.999383, 0.99940443, 0.99942523, 0.99944544, 0.99946505, 0.9994841, 0.9995026, 0.99952054, 0.99953794, 0.9995548, 0.9995712, 0.99958706, 0.99960244, 0.99961734, 0.9996318, 0.99964577, 0.99965936, 0.9996725, 0.99968517, 0.9996975, 0.99970937, 0.99972093, 0.999732, 0.9997428, 0.99975324, 0.9997633, 0.999773, 0.9997824, 0.9997915, 0.99980026, 0.9998087, 0.99981683, 0.99982476, 0.99983233, 0.99983966, 0.9998467, 0.99985355, 0.9998601, 0.99986637, 0.99987245, 0.99987835, 0.99988395, 0.9998894, 0.99989456, 0.9998996, 0.9999044, 0.99990904, 0.99991345, 0.99991775, 0.99992186, 0.99992573, 0.99992955, 0.9999331, 0.9999366, 0.9999399, 0.9999431, 0.9999461, 0.99994904, 0.9999518, 0.99995446, 0.99995697, 0.9999594, 0.99996173, 0.99996394, 0.999966, 0.99996805, 0.99996996, 0.99997175, 0.9999735, 0.99997514, 0.9999767, 0.9999782, 0.9999796, 0.9999809, 0.9999822, 0.99998343, 0.99998456, 0.99998564, 0.99998665, 0.9999876, 0.9999885, 0.9999894, 0.99999017, 0.99999094, 0.99999166, 0.9999923, 0.99999297, 0.99999356, 0.9999941, 0.9999946, 0.9999951, 0.9999955, 0.99999595, 0.99999636, 0.9999967, 0.999997, 0.9999974, 0.9999977, 0.9999979, 0.99999815, 0.9999984, 0.99999857, 0.9999988, 0.9999989, 0.9999991, 0.9999992, 0.9999994, 0.99999946, 0.9999996, 0.9999997, 0.99999976, 0.9999998, 0.9999999, 0.99999994]);
    constructor.KBD_120 = new Float32Array([4.523201E-5, 1.2745647E-4, 2.5293985E-4, 4.3351404E-4, 6.827101E-4, 0.0010158708, 0.0014502163, 0.0020048865, 0.002700962, 0.003561459, 0.0046113017, 0.005877263, 0.0073878774, 0.009173328, 0.0112652965, 0.013696786, 0.016501913, 0.019715669, 0.023373658, 0.0275118, 0.03216601, 0.037371866, 0.043164253, 0.04957698, 0.05664239, 0.06439101, 0.072851084, 0.082048275, 0.09200519, 0.102741085, 0.114271455, 0.12660775, 0.13975702, 0.15372172, 0.1684994, 0.18408258, 0.20045857, 0.21760936, 0.23551162, 0.25413665, 0.27345052, 0.29341415, 0.3139834, 0.3351095, 0.35673913, 0.37881488, 0.40127558, 0.42405677, 0.44709122, 0.47030926, 0.4936395, 0.5170094, 0.54034567, 0.5635751, 0.586625, 0.60942394, 0.6319022, 0.65399253, 0.6756304, 0.696755, 0.71730924, 0.7372405, 0.756501, 0.77504814, 0.79284453, 0.8098587, 0.8260648, 0.8414431, 0.85597974, 0.86966664, 0.88250166, 0.8944884, 0.9056356, 0.9159574, 0.9254725, 0.93420404, 0.9421792, 0.94942844, 0.9559854, 0.96188605, 0.96716833, 0.97187155, 0.97603595, 0.9797022, 0.98291075, 0.98570174, 0.9881142, 0.99018586, 0.99195284, 0.99344957, 0.9947081, 0.99575853, 0.99662834, 0.9973428, 0.99792475, 0.99839455, 0.9987703, 0.99906796, 0.99930143, 0.9994825, 0.99962145, 0.9997268, 0.9998056, 0.99986386, 0.9999062, 0.9999365, 0.9999579, 0.9999727, 0.9999827, 0.9999894, 0.9999937, 0.99999636, 0.999998, 0.9999989, 0.99999946, 0.99999976, 0.9999999, 0.99999994, 1.0, 1.0]);
}, {KBD_1024: "Float32Array", KBD_128: "Float32Array", KBD_960: "Float32Array", KBD_120: "Float32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var Codebooks = function() {};
Codebooks = stjs.extend(Codebooks, null, [], function(constructor, prototype) {
    constructor.HCB1 = [new Int32Array([1, 0, 0, 0, 0, 0]), new Int32Array([5, 16, 1, 0, 0, 0]), new Int32Array([5, 17, -1, 0, 0, 0]), new Int32Array([5, 18, 0, 0, 0, -1]), new Int32Array([5, 19, 0, 1, 0, 0]), new Int32Array([5, 20, 0, 0, 0, 1]), new Int32Array([5, 21, 0, 0, -1, 0]), new Int32Array([5, 22, 0, 0, 1, 0]), new Int32Array([5, 23, 0, -1, 0, 0]), new Int32Array([7, 96, 1, -1, 0, 0]), new Int32Array([7, 97, -1, 1, 0, 0]), new Int32Array([7, 98, 0, 0, -1, 1]), new Int32Array([7, 99, 0, 1, -1, 0]), new Int32Array([7, 100, 0, -1, 1, 0]), new Int32Array([7, 101, 0, 0, 1, -1]), new Int32Array([7, 102, 1, 1, 0, 0]), new Int32Array([7, 103, 0, 0, -1, -1]), new Int32Array([7, 104, -1, -1, 0, 0]), new Int32Array([7, 105, 0, -1, -1, 0]), new Int32Array([7, 106, 1, 0, -1, 0]), new Int32Array([7, 107, 0, 1, 0, -1]), new Int32Array([7, 108, -1, 0, 1, 0]), new Int32Array([7, 109, 0, 0, 1, 1]), new Int32Array([7, 110, 1, 0, 1, 0]), new Int32Array([7, 111, 0, -1, 0, 1]), new Int32Array([7, 112, 0, 1, 1, 0]), new Int32Array([7, 113, 0, 1, 0, 1]), new Int32Array([7, 114, -1, 0, -1, 0]), new Int32Array([7, 115, 1, 0, 0, 1]), new Int32Array([7, 116, -1, 0, 0, -1]), new Int32Array([7, 117, 1, 0, 0, -1]), new Int32Array([7, 118, -1, 0, 0, 1]), new Int32Array([7, 119, 0, -1, 0, -1]), new Int32Array([9, 480, 1, 1, -1, 0]), new Int32Array([9, 481, -1, 1, -1, 0]), new Int32Array([9, 482, 1, -1, 1, 0]), new Int32Array([9, 483, 0, 1, 1, -1]), new Int32Array([9, 484, 0, 1, -1, 1]), new Int32Array([9, 485, 0, -1, 1, 1]), new Int32Array([9, 486, 0, -1, 1, -1]), new Int32Array([9, 487, 1, -1, -1, 0]), new Int32Array([9, 488, 1, 0, -1, 1]), new Int32Array([9, 489, 0, 1, -1, -1]), new Int32Array([9, 490, -1, 1, 1, 0]), new Int32Array([9, 491, -1, 0, 1, -1]), new Int32Array([9, 492, -1, -1, 1, 0]), new Int32Array([9, 493, 0, -1, -1, 1]), new Int32Array([9, 494, 1, -1, 0, 1]), new Int32Array([9, 495, 1, -1, 0, -1]), new Int32Array([9, 496, -1, 1, 0, -1]), new Int32Array([9, 497, -1, -1, -1, 0]), new Int32Array([9, 498, 0, -1, -1, -1]), new Int32Array([9, 499, 0, 1, 1, 1]), new Int32Array([9, 500, 1, 0, 1, -1]), new Int32Array([9, 501, 1, 1, 0, 1]), new Int32Array([9, 502, -1, 1, 0, 1]), new Int32Array([9, 503, 1, 1, 1, 0]), new Int32Array([10, 1008, -1, -1, 0, 1]), new Int32Array([10, 1009, -1, 0, -1, -1]), new Int32Array([10, 1010, 1, 1, 0, -1]), new Int32Array([10, 1011, 1, 0, -1, -1]), new Int32Array([10, 1012, -1, 0, -1, 1]), new Int32Array([10, 1013, -1, -1, 0, -1]), new Int32Array([10, 1014, -1, 0, 1, 1]), new Int32Array([10, 1015, 1, 0, 1, 1]), new Int32Array([11, 2032, 1, -1, 1, -1]), new Int32Array([11, 2033, -1, 1, -1, 1]), new Int32Array([11, 2034, -1, 1, 1, -1]), new Int32Array([11, 2035, 1, -1, -1, 1]), new Int32Array([11, 2036, 1, 1, 1, 1]), new Int32Array([11, 2037, -1, -1, 1, 1]), new Int32Array([11, 2038, 1, 1, -1, -1]), new Int32Array([11, 2039, -1, -1, 1, -1]), new Int32Array([11, 2040, -1, -1, -1, -1]), new Int32Array([11, 2041, 1, 1, -1, 1]), new Int32Array([11, 2042, 1, -1, 1, 1]), new Int32Array([11, 2043, -1, 1, 1, 1]), new Int32Array([11, 2044, -1, 1, -1, -1]), new Int32Array([11, 2045, -1, -1, -1, 1]), new Int32Array([11, 2046, 1, -1, -1, -1]), new Int32Array([11, 2047, 1, 1, 1, -1])];
    constructor.HCB2 = [new Int32Array([3, 0, 0, 0, 0, 0]), new Int32Array([4, 2, 1, 0, 0, 0]), new Int32Array([5, 6, -1, 0, 0, 0]), new Int32Array([5, 7, 0, 0, 0, 1]), new Int32Array([5, 8, 0, 0, -1, 0]), new Int32Array([5, 9, 0, 0, 0, -1]), new Int32Array([5, 10, 0, -1, 0, 0]), new Int32Array([5, 11, 0, 0, 1, 0]), new Int32Array([5, 12, 0, 1, 0, 0]), new Int32Array([6, 26, 0, -1, 1, 0]), new Int32Array([6, 27, -1, 1, 0, 0]), new Int32Array([6, 28, 0, 1, -1, 0]), new Int32Array([6, 29, 0, 0, 1, -1]), new Int32Array([6, 30, 0, 1, 0, -1]), new Int32Array([6, 31, 0, 0, -1, 1]), new Int32Array([6, 32, -1, 0, 0, -1]), new Int32Array([6, 33, 1, -1, 0, 0]), new Int32Array([6, 34, 1, 0, -1, 0]), new Int32Array([6, 35, -1, -1, 0, 0]), new Int32Array([6, 36, 0, 0, -1, -1]), new Int32Array([6, 37, 1, 0, 1, 0]), new Int32Array([6, 38, 1, 0, 0, 1]), new Int32Array([6, 39, 0, -1, 0, 1]), new Int32Array([6, 40, -1, 0, 1, 0]), new Int32Array([6, 41, 0, 1, 0, 1]), new Int32Array([6, 42, 0, -1, -1, 0]), new Int32Array([6, 43, -1, 0, 0, 1]), new Int32Array([6, 44, 0, -1, 0, -1]), new Int32Array([6, 45, -1, 0, -1, 0]), new Int32Array([6, 46, 1, 1, 0, 0]), new Int32Array([6, 47, 0, 1, 1, 0]), new Int32Array([6, 48, 0, 0, 1, 1]), new Int32Array([6, 49, 1, 0, 0, -1]), new Int32Array([7, 100, 0, 1, -1, 1]), new Int32Array([7, 101, 1, 0, -1, 1]), new Int32Array([7, 102, -1, 1, -1, 0]), new Int32Array([7, 103, 0, -1, 1, -1]), new Int32Array([7, 104, 1, -1, 1, 0]), new Int32Array([7, 105, 1, 1, 0, -1]), new Int32Array([7, 106, 1, 0, 1, 1]), new Int32Array([7, 107, -1, 1, 1, 0]), new Int32Array([7, 108, 0, -1, -1, 1]), new Int32Array([7, 109, 1, 1, 1, 0]), new Int32Array([7, 110, -1, 0, 1, -1]), new Int32Array([7, 111, -1, -1, -1, 0]), new Int32Array([7, 112, -1, 0, -1, 1]), new Int32Array([7, 113, 1, -1, -1, 0]), new Int32Array([7, 114, 1, 1, -1, 0]), new Int32Array([8, 230, 1, -1, 0, 1]), new Int32Array([8, 231, -1, 1, 0, -1]), new Int32Array([8, 232, -1, -1, 1, 0]), new Int32Array([8, 233, -1, 0, 1, 1]), new Int32Array([8, 234, -1, -1, 0, 1]), new Int32Array([8, 235, -1, -1, 0, -1]), new Int32Array([8, 236, 0, -1, -1, -1]), new Int32Array([8, 237, 1, 0, 1, -1]), new Int32Array([8, 238, 1, 0, -1, -1]), new Int32Array([8, 239, 0, 1, -1, -1]), new Int32Array([8, 240, 0, 1, 1, 1]), new Int32Array([8, 241, -1, 1, 0, 1]), new Int32Array([8, 242, -1, 0, -1, -1]), new Int32Array([8, 243, 0, 1, 1, -1]), new Int32Array([8, 244, 1, -1, 0, -1]), new Int32Array([8, 245, 0, -1, 1, 1]), new Int32Array([8, 246, 1, 1, 0, 1]), new Int32Array([8, 247, 1, -1, 1, -1]), new Int32Array([8, 248, -1, 1, -1, 1]), new Int32Array([9, 498, 1, -1, -1, 1]), new Int32Array([9, 499, -1, -1, -1, -1]), new Int32Array([9, 500, -1, 1, 1, -1]), new Int32Array([9, 501, -1, 1, 1, 1]), new Int32Array([9, 502, 1, 1, 1, 1]), new Int32Array([9, 503, -1, -1, 1, -1]), new Int32Array([9, 504, 1, -1, 1, 1]), new Int32Array([9, 505, -1, 1, -1, -1]), new Int32Array([9, 506, -1, -1, 1, 1]), new Int32Array([9, 507, 1, 1, -1, -1]), new Int32Array([9, 508, 1, -1, -1, -1]), new Int32Array([9, 509, -1, -1, -1, 1]), new Int32Array([9, 510, 1, 1, -1, 1]), new Int32Array([9, 511, 1, 1, 1, -1])];
    constructor.HCB3 = [new Int32Array([1, 0, 0, 0, 0, 0]), new Int32Array([4, 8, 1, 0, 0, 0]), new Int32Array([4, 9, 0, 0, 0, 1]), new Int32Array([4, 10, 0, 1, 0, 0]), new Int32Array([4, 11, 0, 0, 1, 0]), new Int32Array([5, 24, 1, 1, 0, 0]), new Int32Array([5, 25, 0, 0, 1, 1]), new Int32Array([6, 52, 0, 1, 1, 0]), new Int32Array([6, 53, 0, 1, 0, 1]), new Int32Array([6, 54, 1, 0, 1, 0]), new Int32Array([6, 55, 0, 1, 1, 1]), new Int32Array([6, 56, 1, 0, 0, 1]), new Int32Array([6, 57, 1, 1, 1, 0]), new Int32Array([7, 116, 1, 1, 1, 1]), new Int32Array([7, 117, 1, 0, 1, 1]), new Int32Array([7, 118, 1, 1, 0, 1]), new Int32Array([8, 238, 2, 0, 0, 0]), new Int32Array([8, 239, 0, 0, 0, 2]), new Int32Array([8, 240, 0, 0, 1, 2]), new Int32Array([8, 241, 2, 1, 0, 0]), new Int32Array([8, 242, 1, 2, 1, 0]), new Int32Array([9, 486, 0, 0, 2, 1]), new Int32Array([9, 487, 0, 1, 2, 1]), new Int32Array([9, 488, 1, 2, 0, 0]), new Int32Array([9, 489, 0, 1, 1, 2]), new Int32Array([9, 490, 2, 1, 1, 0]), new Int32Array([9, 491, 0, 0, 2, 0]), new Int32Array([9, 492, 0, 2, 1, 0]), new Int32Array([9, 493, 0, 1, 2, 0]), new Int32Array([9, 494, 0, 2, 0, 0]), new Int32Array([9, 495, 0, 1, 0, 2]), new Int32Array([9, 496, 2, 0, 1, 0]), new Int32Array([9, 497, 1, 2, 1, 1]), new Int32Array([9, 498, 0, 2, 1, 1]), new Int32Array([9, 499, 1, 1, 2, 0]), new Int32Array([9, 500, 1, 1, 2, 1]), new Int32Array([10, 1002, 1, 2, 0, 1]), new Int32Array([10, 1003, 1, 0, 2, 0]), new Int32Array([10, 1004, 1, 0, 2, 1]), new Int32Array([10, 1005, 0, 2, 0, 1]), new Int32Array([10, 1006, 2, 1, 1, 1]), new Int32Array([10, 1007, 1, 1, 1, 2]), new Int32Array([10, 1008, 2, 1, 0, 1]), new Int32Array([10, 1009, 1, 0, 1, 2]), new Int32Array([10, 1010, 0, 0, 2, 2]), new Int32Array([10, 1011, 0, 1, 2, 2]), new Int32Array([10, 1012, 2, 2, 1, 0]), new Int32Array([10, 1013, 1, 2, 2, 0]), new Int32Array([10, 1014, 1, 0, 0, 2]), new Int32Array([10, 1015, 2, 0, 0, 1]), new Int32Array([10, 1016, 0, 2, 2, 1]), new Int32Array([11, 2034, 2, 2, 0, 0]), new Int32Array([11, 2035, 1, 2, 2, 1]), new Int32Array([11, 2036, 1, 1, 0, 2]), new Int32Array([11, 2037, 2, 0, 1, 1]), new Int32Array([11, 2038, 1, 1, 2, 2]), new Int32Array([11, 2039, 2, 2, 1, 1]), new Int32Array([11, 2040, 0, 2, 2, 0]), new Int32Array([11, 2041, 0, 2, 1, 2]), new Int32Array([12, 4084, 1, 0, 2, 2]), new Int32Array([12, 4085, 2, 2, 0, 1]), new Int32Array([12, 4086, 2, 1, 2, 0]), new Int32Array([12, 4087, 2, 2, 2, 0]), new Int32Array([12, 4088, 0, 2, 2, 2]), new Int32Array([12, 4089, 2, 2, 2, 1]), new Int32Array([12, 4090, 2, 1, 2, 1]), new Int32Array([12, 4091, 1, 2, 1, 2]), new Int32Array([12, 4092, 1, 2, 2, 2]), new Int32Array([13, 8186, 0, 2, 0, 2]), new Int32Array([13, 8187, 2, 0, 2, 0]), new Int32Array([13, 8188, 1, 2, 0, 2]), new Int32Array([14, 16378, 2, 0, 2, 1]), new Int32Array([14, 16379, 2, 1, 1, 2]), new Int32Array([14, 16380, 2, 1, 0, 2]), new Int32Array([15, 32762, 2, 2, 2, 2]), new Int32Array([15, 32763, 2, 2, 1, 2]), new Int32Array([15, 32764, 2, 1, 2, 2]), new Int32Array([15, 32765, 2, 0, 1, 2]), new Int32Array([15, 32766, 2, 0, 0, 2]), new Int32Array([16, 65534, 2, 2, 0, 2]), new Int32Array([16, 65535, 2, 0, 2, 2])];
    constructor.HCB4 = [new Int32Array([4, 0, 1, 1, 1, 1]), new Int32Array([4, 1, 0, 1, 1, 1]), new Int32Array([4, 2, 1, 1, 0, 1]), new Int32Array([4, 3, 1, 1, 1, 0]), new Int32Array([4, 4, 1, 0, 1, 1]), new Int32Array([4, 5, 1, 0, 0, 0]), new Int32Array([4, 6, 1, 1, 0, 0]), new Int32Array([4, 7, 0, 0, 0, 0]), new Int32Array([4, 8, 0, 0, 1, 1]), new Int32Array([4, 9, 1, 0, 1, 0]), new Int32Array([5, 20, 1, 0, 0, 1]), new Int32Array([5, 21, 0, 1, 1, 0]), new Int32Array([5, 22, 0, 0, 0, 1]), new Int32Array([5, 23, 0, 1, 0, 1]), new Int32Array([5, 24, 0, 0, 1, 0]), new Int32Array([5, 25, 0, 1, 0, 0]), new Int32Array([7, 104, 2, 1, 1, 1]), new Int32Array([7, 105, 1, 1, 2, 1]), new Int32Array([7, 106, 1, 2, 1, 1]), new Int32Array([7, 107, 1, 1, 1, 2]), new Int32Array([7, 108, 2, 1, 1, 0]), new Int32Array([7, 109, 2, 1, 0, 1]), new Int32Array([7, 110, 1, 2, 1, 0]), new Int32Array([7, 111, 2, 0, 1, 1]), new Int32Array([7, 112, 0, 1, 2, 1]), new Int32Array([8, 226, 0, 1, 1, 2]), new Int32Array([8, 227, 1, 1, 2, 0]), new Int32Array([8, 228, 0, 2, 1, 1]), new Int32Array([8, 229, 1, 0, 1, 2]), new Int32Array([8, 230, 1, 2, 0, 1]), new Int32Array([8, 231, 1, 1, 0, 2]), new Int32Array([8, 232, 1, 0, 2, 1]), new Int32Array([8, 233, 2, 1, 0, 0]), new Int32Array([8, 234, 2, 0, 1, 0]), new Int32Array([8, 235, 1, 2, 0, 0]), new Int32Array([8, 236, 2, 0, 0, 1]), new Int32Array([8, 237, 0, 1, 0, 2]), new Int32Array([8, 238, 0, 2, 1, 0]), new Int32Array([8, 239, 0, 0, 1, 2]), new Int32Array([8, 240, 0, 1, 2, 0]), new Int32Array([8, 241, 0, 2, 0, 1]), new Int32Array([8, 242, 1, 0, 0, 2]), new Int32Array([8, 243, 0, 0, 2, 1]), new Int32Array([8, 244, 1, 0, 2, 0]), new Int32Array([8, 245, 2, 0, 0, 0]), new Int32Array([8, 246, 0, 0, 0, 2]), new Int32Array([9, 494, 0, 2, 0, 0]), new Int32Array([9, 495, 0, 0, 2, 0]), new Int32Array([9, 496, 1, 2, 2, 1]), new Int32Array([9, 497, 2, 2, 1, 1]), new Int32Array([9, 498, 2, 1, 2, 1]), new Int32Array([9, 499, 1, 1, 2, 2]), new Int32Array([9, 500, 1, 2, 1, 2]), new Int32Array([9, 501, 2, 1, 1, 2]), new Int32Array([10, 1004, 1, 2, 2, 0]), new Int32Array([10, 1005, 2, 2, 1, 0]), new Int32Array([10, 1006, 2, 1, 2, 0]), new Int32Array([10, 1007, 0, 2, 2, 1]), new Int32Array([10, 1008, 0, 1, 2, 2]), new Int32Array([10, 1009, 2, 2, 0, 1]), new Int32Array([10, 1010, 0, 2, 1, 2]), new Int32Array([10, 1011, 2, 0, 2, 1]), new Int32Array([10, 1012, 1, 0, 2, 2]), new Int32Array([10, 1013, 2, 2, 2, 1]), new Int32Array([10, 1014, 1, 2, 0, 2]), new Int32Array([10, 1015, 2, 0, 1, 2]), new Int32Array([10, 1016, 2, 1, 0, 2]), new Int32Array([10, 1017, 1, 2, 2, 2]), new Int32Array([11, 2036, 2, 1, 2, 2]), new Int32Array([11, 2037, 2, 2, 1, 2]), new Int32Array([11, 2038, 0, 2, 2, 0]), new Int32Array([11, 2039, 2, 2, 0, 0]), new Int32Array([11, 2040, 0, 0, 2, 2]), new Int32Array([11, 2041, 2, 0, 2, 0]), new Int32Array([11, 2042, 0, 2, 0, 2]), new Int32Array([11, 2043, 2, 0, 0, 2]), new Int32Array([11, 2044, 2, 2, 2, 2]), new Int32Array([11, 2045, 0, 2, 2, 2]), new Int32Array([11, 2046, 2, 2, 2, 0]), new Int32Array([12, 4094, 2, 2, 0, 2]), new Int32Array([12, 4095, 2, 0, 2, 2])];
    constructor.HCB5 = [new Int32Array([1, 0, 0, 0]), new Int32Array([4, 8, -1, 0]), new Int32Array([4, 9, 1, 0]), new Int32Array([4, 10, 0, 1]), new Int32Array([4, 11, 0, -1]), new Int32Array([5, 24, 1, -1]), new Int32Array([5, 25, -1, 1]), new Int32Array([5, 26, -1, -1]), new Int32Array([5, 27, 1, 1]), new Int32Array([7, 112, -2, 0]), new Int32Array([7, 113, 0, 2]), new Int32Array([7, 114, 2, 0]), new Int32Array([7, 115, 0, -2]), new Int32Array([8, 232, -2, -1]), new Int32Array([8, 233, 2, 1]), new Int32Array([8, 234, -1, -2]), new Int32Array([8, 235, 1, 2]), new Int32Array([8, 236, -2, 1]), new Int32Array([8, 237, 2, -1]), new Int32Array([8, 238, -1, 2]), new Int32Array([8, 239, 1, -2]), new Int32Array([8, 240, -3, 0]), new Int32Array([8, 241, 3, 0]), new Int32Array([8, 242, 0, -3]), new Int32Array([8, 243, 0, 3]), new Int32Array([9, 488, -3, -1]), new Int32Array([9, 489, 1, 3]), new Int32Array([9, 490, 3, 1]), new Int32Array([9, 491, -1, -3]), new Int32Array([9, 492, -3, 1]), new Int32Array([9, 493, 3, -1]), new Int32Array([9, 494, 1, -3]), new Int32Array([9, 495, -1, 3]), new Int32Array([9, 496, -2, 2]), new Int32Array([9, 497, 2, 2]), new Int32Array([9, 498, -2, -2]), new Int32Array([9, 499, 2, -2]), new Int32Array([10, 1000, -3, -2]), new Int32Array([10, 1001, 3, -2]), new Int32Array([10, 1002, -2, 3]), new Int32Array([10, 1003, 2, -3]), new Int32Array([10, 1004, 3, 2]), new Int32Array([10, 1005, 2, 3]), new Int32Array([10, 1006, -3, 2]), new Int32Array([10, 1007, -2, -3]), new Int32Array([10, 1008, 0, -4]), new Int32Array([10, 1009, -4, 0]), new Int32Array([10, 1010, 4, 1]), new Int32Array([10, 1011, 4, 0]), new Int32Array([11, 2024, -4, -1]), new Int32Array([11, 2025, 0, 4]), new Int32Array([11, 2026, 4, -1]), new Int32Array([11, 2027, -1, -4]), new Int32Array([11, 2028, 1, 4]), new Int32Array([11, 2029, -1, 4]), new Int32Array([11, 2030, -4, 1]), new Int32Array([11, 2031, 1, -4]), new Int32Array([11, 2032, 3, -3]), new Int32Array([11, 2033, -3, -3]), new Int32Array([11, 2034, -3, 3]), new Int32Array([11, 2035, -2, 4]), new Int32Array([11, 2036, -4, -2]), new Int32Array([11, 2037, 4, 2]), new Int32Array([11, 2038, 2, -4]), new Int32Array([11, 2039, 2, 4]), new Int32Array([11, 2040, 3, 3]), new Int32Array([11, 2041, -4, 2]), new Int32Array([12, 4084, -2, -4]), new Int32Array([12, 4085, 4, -2]), new Int32Array([12, 4086, 3, -4]), new Int32Array([12, 4087, -4, -3]), new Int32Array([12, 4088, -4, 3]), new Int32Array([12, 4089, 3, 4]), new Int32Array([12, 4090, -3, 4]), new Int32Array([12, 4091, 4, 3]), new Int32Array([12, 4092, 4, -3]), new Int32Array([12, 4093, -3, -4]), new Int32Array([13, 8188, 4, -4]), new Int32Array([13, 8189, -4, 4]), new Int32Array([13, 8190, 4, 4]), new Int32Array([13, 8191, -4, -4])];
    constructor.HCB6 = [new Int32Array([4, 0, 0, 0]), new Int32Array([4, 1, 1, 0]), new Int32Array([4, 2, 0, -1]), new Int32Array([4, 3, 0, 1]), new Int32Array([4, 4, -1, 0]), new Int32Array([4, 5, 1, 1]), new Int32Array([4, 6, -1, 1]), new Int32Array([4, 7, 1, -1]), new Int32Array([4, 8, -1, -1]), new Int32Array([6, 36, 2, -1]), new Int32Array([6, 37, 2, 1]), new Int32Array([6, 38, -2, 1]), new Int32Array([6, 39, -2, -1]), new Int32Array([6, 40, -2, 0]), new Int32Array([6, 41, -1, 2]), new Int32Array([6, 42, 2, 0]), new Int32Array([6, 43, 1, -2]), new Int32Array([6, 44, 1, 2]), new Int32Array([6, 45, 0, -2]), new Int32Array([6, 46, -1, -2]), new Int32Array([6, 47, 0, 2]), new Int32Array([6, 48, 2, -2]), new Int32Array([6, 49, -2, 2]), new Int32Array([6, 50, -2, -2]), new Int32Array([6, 51, 2, 2]), new Int32Array([7, 104, -3, 1]), new Int32Array([7, 105, 3, 1]), new Int32Array([7, 106, 3, -1]), new Int32Array([7, 107, -1, 3]), new Int32Array([7, 108, -3, -1]), new Int32Array([7, 109, 1, 3]), new Int32Array([7, 110, 1, -3]), new Int32Array([7, 111, -1, -3]), new Int32Array([7, 112, 3, 0]), new Int32Array([7, 113, -3, 0]), new Int32Array([7, 114, 0, -3]), new Int32Array([7, 115, 0, 3]), new Int32Array([7, 116, 3, 2]), new Int32Array([8, 234, -3, -2]), new Int32Array([8, 235, -2, 3]), new Int32Array([8, 236, 2, 3]), new Int32Array([8, 237, 3, -2]), new Int32Array([8, 238, 2, -3]), new Int32Array([8, 239, -2, -3]), new Int32Array([8, 240, -3, 2]), new Int32Array([8, 241, 3, 3]), new Int32Array([9, 484, 3, -3]), new Int32Array([9, 485, -3, -3]), new Int32Array([9, 486, -3, 3]), new Int32Array([9, 487, 1, -4]), new Int32Array([9, 488, -1, -4]), new Int32Array([9, 489, 4, 1]), new Int32Array([9, 490, -4, 1]), new Int32Array([9, 491, -4, -1]), new Int32Array([9, 492, 1, 4]), new Int32Array([9, 493, 4, -1]), new Int32Array([9, 494, -1, 4]), new Int32Array([9, 495, 0, -4]), new Int32Array([9, 496, -4, 2]), new Int32Array([9, 497, -4, -2]), new Int32Array([9, 498, 2, 4]), new Int32Array([9, 499, -2, -4]), new Int32Array([9, 500, -4, 0]), new Int32Array([9, 501, 4, 2]), new Int32Array([9, 502, 4, -2]), new Int32Array([9, 503, -2, 4]), new Int32Array([9, 504, 4, 0]), new Int32Array([9, 505, 2, -4]), new Int32Array([9, 506, 0, 4]), new Int32Array([10, 1014, -3, -4]), new Int32Array([10, 1015, -3, 4]), new Int32Array([10, 1016, 3, -4]), new Int32Array([10, 1017, 4, -3]), new Int32Array([10, 1018, 3, 4]), new Int32Array([10, 1019, 4, 3]), new Int32Array([10, 1020, -4, 3]), new Int32Array([10, 1021, -4, -3]), new Int32Array([11, 2044, 4, 4]), new Int32Array([11, 2045, -4, 4]), new Int32Array([11, 2046, -4, -4]), new Int32Array([11, 2047, 4, -4])];
    constructor.HCB7 = [new Int32Array([1, 0, 0, 0]), new Int32Array([3, 4, 1, 0]), new Int32Array([3, 5, 0, 1]), new Int32Array([4, 12, 1, 1]), new Int32Array([6, 52, 2, 1]), new Int32Array([6, 53, 1, 2]), new Int32Array([6, 54, 2, 0]), new Int32Array([6, 55, 0, 2]), new Int32Array([7, 112, 3, 1]), new Int32Array([7, 113, 1, 3]), new Int32Array([7, 114, 2, 2]), new Int32Array([7, 115, 3, 0]), new Int32Array([7, 116, 0, 3]), new Int32Array([8, 234, 2, 3]), new Int32Array([8, 235, 3, 2]), new Int32Array([8, 236, 1, 4]), new Int32Array([8, 237, 4, 1]), new Int32Array([8, 238, 1, 5]), new Int32Array([8, 239, 5, 1]), new Int32Array([8, 240, 3, 3]), new Int32Array([8, 241, 2, 4]), new Int32Array([8, 242, 0, 4]), new Int32Array([8, 243, 4, 0]), new Int32Array([9, 488, 4, 2]), new Int32Array([9, 489, 2, 5]), new Int32Array([9, 490, 5, 2]), new Int32Array([9, 491, 0, 5]), new Int32Array([9, 492, 6, 1]), new Int32Array([9, 493, 5, 0]), new Int32Array([9, 494, 1, 6]), new Int32Array([9, 495, 4, 3]), new Int32Array([9, 496, 3, 5]), new Int32Array([9, 497, 3, 4]), new Int32Array([9, 498, 5, 3]), new Int32Array([9, 499, 2, 6]), new Int32Array([9, 500, 6, 2]), new Int32Array([9, 501, 1, 7]), new Int32Array([10, 1004, 3, 6]), new Int32Array([10, 1005, 0, 6]), new Int32Array([10, 1006, 6, 0]), new Int32Array([10, 1007, 4, 4]), new Int32Array([10, 1008, 7, 1]), new Int32Array([10, 1009, 4, 5]), new Int32Array([10, 1010, 7, 2]), new Int32Array([10, 1011, 5, 4]), new Int32Array([10, 1012, 6, 3]), new Int32Array([10, 1013, 2, 7]), new Int32Array([10, 1014, 7, 3]), new Int32Array([10, 1015, 6, 4]), new Int32Array([10, 1016, 5, 5]), new Int32Array([10, 1017, 4, 6]), new Int32Array([10, 1018, 3, 7]), new Int32Array([11, 2038, 7, 0]), new Int32Array([11, 2039, 0, 7]), new Int32Array([11, 2040, 6, 5]), new Int32Array([11, 2041, 5, 6]), new Int32Array([11, 2042, 7, 4]), new Int32Array([11, 2043, 4, 7]), new Int32Array([11, 2044, 5, 7]), new Int32Array([11, 2045, 7, 5]), new Int32Array([12, 4092, 7, 6]), new Int32Array([12, 4093, 6, 6]), new Int32Array([12, 4094, 6, 7]), new Int32Array([12, 4095, 7, 7])];
    constructor.HCB8 = [new Int32Array([3, 0, 1, 1]), new Int32Array([4, 2, 2, 1]), new Int32Array([4, 3, 1, 0]), new Int32Array([4, 4, 1, 2]), new Int32Array([4, 5, 0, 1]), new Int32Array([4, 6, 2, 2]), new Int32Array([5, 14, 0, 0]), new Int32Array([5, 15, 2, 0]), new Int32Array([5, 16, 0, 2]), new Int32Array([5, 17, 3, 1]), new Int32Array([5, 18, 1, 3]), new Int32Array([5, 19, 3, 2]), new Int32Array([5, 20, 2, 3]), new Int32Array([6, 42, 3, 3]), new Int32Array([6, 43, 4, 1]), new Int32Array([6, 44, 1, 4]), new Int32Array([6, 45, 4, 2]), new Int32Array([6, 46, 2, 4]), new Int32Array([6, 47, 3, 0]), new Int32Array([6, 48, 0, 3]), new Int32Array([6, 49, 4, 3]), new Int32Array([6, 50, 3, 4]), new Int32Array([6, 51, 5, 2]), new Int32Array([7, 104, 5, 1]), new Int32Array([7, 105, 2, 5]), new Int32Array([7, 106, 1, 5]), new Int32Array([7, 107, 5, 3]), new Int32Array([7, 108, 3, 5]), new Int32Array([7, 109, 4, 4]), new Int32Array([7, 110, 5, 4]), new Int32Array([7, 111, 0, 4]), new Int32Array([7, 112, 4, 5]), new Int32Array([7, 113, 4, 0]), new Int32Array([7, 114, 2, 6]), new Int32Array([7, 115, 6, 2]), new Int32Array([7, 116, 6, 1]), new Int32Array([7, 117, 1, 6]), new Int32Array([8, 236, 3, 6]), new Int32Array([8, 237, 6, 3]), new Int32Array([8, 238, 5, 5]), new Int32Array([8, 239, 5, 0]), new Int32Array([8, 240, 6, 4]), new Int32Array([8, 241, 0, 5]), new Int32Array([8, 242, 4, 6]), new Int32Array([8, 243, 7, 1]), new Int32Array([8, 244, 7, 2]), new Int32Array([8, 245, 2, 7]), new Int32Array([8, 246, 6, 5]), new Int32Array([8, 247, 7, 3]), new Int32Array([8, 248, 1, 7]), new Int32Array([8, 249, 5, 6]), new Int32Array([8, 250, 3, 7]), new Int32Array([9, 502, 6, 6]), new Int32Array([9, 503, 7, 4]), new Int32Array([9, 504, 6, 0]), new Int32Array([9, 505, 4, 7]), new Int32Array([9, 506, 0, 6]), new Int32Array([9, 507, 7, 5]), new Int32Array([9, 508, 7, 6]), new Int32Array([9, 509, 6, 7]), new Int32Array([10, 1020, 5, 7]), new Int32Array([10, 1021, 7, 0]), new Int32Array([10, 1022, 0, 7]), new Int32Array([10, 1023, 7, 7])];
    constructor.HCB9 = [new Int32Array([1, 0, 0, 0]), new Int32Array([3, 4, 1, 0]), new Int32Array([3, 5, 0, 1]), new Int32Array([4, 12, 1, 1]), new Int32Array([6, 52, 2, 1]), new Int32Array([6, 53, 1, 2]), new Int32Array([6, 54, 2, 0]), new Int32Array([6, 55, 0, 2]), new Int32Array([7, 112, 3, 1]), new Int32Array([7, 113, 2, 2]), new Int32Array([7, 114, 1, 3]), new Int32Array([8, 230, 3, 0]), new Int32Array([8, 231, 0, 3]), new Int32Array([8, 232, 2, 3]), new Int32Array([8, 233, 3, 2]), new Int32Array([8, 234, 1, 4]), new Int32Array([8, 235, 4, 1]), new Int32Array([8, 236, 2, 4]), new Int32Array([8, 237, 1, 5]), new Int32Array([9, 476, 4, 2]), new Int32Array([9, 477, 3, 3]), new Int32Array([9, 478, 0, 4]), new Int32Array([9, 479, 4, 0]), new Int32Array([9, 480, 5, 1]), new Int32Array([9, 481, 2, 5]), new Int32Array([9, 482, 1, 6]), new Int32Array([9, 483, 3, 4]), new Int32Array([9, 484, 5, 2]), new Int32Array([9, 485, 6, 1]), new Int32Array([9, 486, 4, 3]), new Int32Array([10, 974, 0, 5]), new Int32Array([10, 975, 2, 6]), new Int32Array([10, 976, 5, 0]), new Int32Array([10, 977, 1, 7]), new Int32Array([10, 978, 3, 5]), new Int32Array([10, 979, 1, 8]), new Int32Array([10, 980, 8, 1]), new Int32Array([10, 981, 4, 4]), new Int32Array([10, 982, 5, 3]), new Int32Array([10, 983, 6, 2]), new Int32Array([10, 984, 7, 1]), new Int32Array([10, 985, 0, 6]), new Int32Array([10, 986, 8, 2]), new Int32Array([10, 987, 2, 8]), new Int32Array([10, 988, 3, 6]), new Int32Array([10, 989, 2, 7]), new Int32Array([10, 990, 4, 5]), new Int32Array([10, 991, 9, 1]), new Int32Array([10, 992, 1, 9]), new Int32Array([10, 993, 7, 2]), new Int32Array([11, 1988, 6, 0]), new Int32Array([11, 1989, 5, 4]), new Int32Array([11, 1990, 6, 3]), new Int32Array([11, 1991, 8, 3]), new Int32Array([11, 1992, 0, 7]), new Int32Array([11, 1993, 9, 2]), new Int32Array([11, 1994, 3, 8]), new Int32Array([11, 1995, 4, 6]), new Int32Array([11, 1996, 3, 7]), new Int32Array([11, 1997, 0, 8]), new Int32Array([11, 1998, 10, 1]), new Int32Array([11, 1999, 6, 4]), new Int32Array([11, 2000, 2, 9]), new Int32Array([11, 2001, 5, 5]), new Int32Array([11, 2002, 8, 0]), new Int32Array([11, 2003, 7, 0]), new Int32Array([11, 2004, 7, 3]), new Int32Array([11, 2005, 10, 2]), new Int32Array([11, 2006, 9, 3]), new Int32Array([11, 2007, 8, 4]), new Int32Array([11, 2008, 1, 10]), new Int32Array([11, 2009, 7, 4]), new Int32Array([11, 2010, 6, 5]), new Int32Array([11, 2011, 5, 6]), new Int32Array([11, 2012, 4, 8]), new Int32Array([11, 2013, 4, 7]), new Int32Array([11, 2014, 3, 9]), new Int32Array([11, 2015, 11, 1]), new Int32Array([11, 2016, 5, 8]), new Int32Array([11, 2017, 9, 0]), new Int32Array([11, 2018, 8, 5]), new Int32Array([12, 4038, 10, 3]), new Int32Array([12, 4039, 2, 10]), new Int32Array([12, 4040, 0, 9]), new Int32Array([12, 4041, 11, 2]), new Int32Array([12, 4042, 9, 4]), new Int32Array([12, 4043, 6, 6]), new Int32Array([12, 4044, 12, 1]), new Int32Array([12, 4045, 4, 9]), new Int32Array([12, 4046, 8, 6]), new Int32Array([12, 4047, 1, 11]), new Int32Array([12, 4048, 9, 5]), new Int32Array([12, 4049, 10, 4]), new Int32Array([12, 4050, 5, 7]), new Int32Array([12, 4051, 7, 5]), new Int32Array([12, 4052, 2, 11]), new Int32Array([12, 4053, 1, 12]), new Int32Array([12, 4054, 12, 2]), new Int32Array([12, 4055, 11, 3]), new Int32Array([12, 4056, 3, 10]), new Int32Array([12, 4057, 5, 9]), new Int32Array([12, 4058, 6, 7]), new Int32Array([12, 4059, 8, 7]), new Int32Array([12, 4060, 11, 4]), new Int32Array([12, 4061, 0, 10]), new Int32Array([12, 4062, 7, 6]), new Int32Array([12, 4063, 12, 3]), new Int32Array([12, 4064, 10, 0]), new Int32Array([12, 4065, 10, 5]), new Int32Array([12, 4066, 4, 10]), new Int32Array([12, 4067, 6, 8]), new Int32Array([12, 4068, 2, 12]), new Int32Array([12, 4069, 9, 6]), new Int32Array([12, 4070, 9, 7]), new Int32Array([12, 4071, 4, 11]), new Int32Array([12, 4072, 11, 0]), new Int32Array([12, 4073, 6, 9]), new Int32Array([12, 4074, 3, 11]), new Int32Array([12, 4075, 5, 10]), new Int32Array([13, 8152, 8, 8]), new Int32Array([13, 8153, 7, 8]), new Int32Array([13, 8154, 12, 5]), new Int32Array([13, 8155, 3, 12]), new Int32Array([13, 8156, 11, 5]), new Int32Array([13, 8157, 7, 7]), new Int32Array([13, 8158, 12, 4]), new Int32Array([13, 8159, 11, 6]), new Int32Array([13, 8160, 10, 6]), new Int32Array([13, 8161, 4, 12]), new Int32Array([13, 8162, 7, 9]), new Int32Array([13, 8163, 5, 11]), new Int32Array([13, 8164, 0, 11]), new Int32Array([13, 8165, 12, 6]), new Int32Array([13, 8166, 6, 10]), new Int32Array([13, 8167, 12, 0]), new Int32Array([13, 8168, 10, 7]), new Int32Array([13, 8169, 5, 12]), new Int32Array([13, 8170, 7, 10]), new Int32Array([13, 8171, 9, 8]), new Int32Array([13, 8172, 0, 12]), new Int32Array([13, 8173, 11, 7]), new Int32Array([13, 8174, 8, 9]), new Int32Array([13, 8175, 9, 9]), new Int32Array([13, 8176, 10, 8]), new Int32Array([13, 8177, 7, 11]), new Int32Array([13, 8178, 12, 7]), new Int32Array([13, 8179, 6, 11]), new Int32Array([13, 8180, 8, 11]), new Int32Array([13, 8181, 11, 8]), new Int32Array([13, 8182, 7, 12]), new Int32Array([13, 8183, 6, 12]), new Int32Array([14, 16368, 8, 10]), new Int32Array([14, 16369, 10, 9]), new Int32Array([14, 16370, 8, 12]), new Int32Array([14, 16371, 9, 10]), new Int32Array([14, 16372, 9, 11]), new Int32Array([14, 16373, 9, 12]), new Int32Array([14, 16374, 10, 11]), new Int32Array([14, 16375, 12, 9]), new Int32Array([14, 16376, 10, 10]), new Int32Array([14, 16377, 11, 9]), new Int32Array([14, 16378, 12, 8]), new Int32Array([14, 16379, 11, 10]), new Int32Array([14, 16380, 12, 10]), new Int32Array([14, 16381, 12, 11]), new Int32Array([15, 32764, 10, 12]), new Int32Array([15, 32765, 11, 11]), new Int32Array([15, 32766, 11, 12]), new Int32Array([15, 32767, 12, 12])];
    constructor.HCB10 = [new Int32Array([4, 0, 1, 1]), new Int32Array([4, 1, 1, 2]), new Int32Array([4, 2, 2, 1]), new Int32Array([5, 6, 2, 2]), new Int32Array([5, 7, 1, 0]), new Int32Array([5, 8, 0, 1]), new Int32Array([5, 9, 1, 3]), new Int32Array([5, 10, 3, 2]), new Int32Array([5, 11, 3, 1]), new Int32Array([5, 12, 2, 3]), new Int32Array([5, 13, 3, 3]), new Int32Array([6, 28, 2, 0]), new Int32Array([6, 29, 0, 2]), new Int32Array([6, 30, 2, 4]), new Int32Array([6, 31, 4, 2]), new Int32Array([6, 32, 1, 4]), new Int32Array([6, 33, 4, 1]), new Int32Array([6, 34, 0, 0]), new Int32Array([6, 35, 4, 3]), new Int32Array([6, 36, 3, 4]), new Int32Array([6, 37, 3, 0]), new Int32Array([6, 38, 0, 3]), new Int32Array([6, 39, 4, 4]), new Int32Array([6, 40, 2, 5]), new Int32Array([6, 41, 5, 2]), new Int32Array([7, 84, 1, 5]), new Int32Array([7, 85, 5, 1]), new Int32Array([7, 86, 5, 3]), new Int32Array([7, 87, 3, 5]), new Int32Array([7, 88, 5, 4]), new Int32Array([7, 89, 4, 5]), new Int32Array([7, 90, 6, 2]), new Int32Array([7, 91, 2, 6]), new Int32Array([7, 92, 6, 3]), new Int32Array([7, 93, 4, 0]), new Int32Array([7, 94, 6, 1]), new Int32Array([7, 95, 0, 4]), new Int32Array([7, 96, 1, 6]), new Int32Array([7, 97, 3, 6]), new Int32Array([7, 98, 5, 5]), new Int32Array([7, 99, 6, 4]), new Int32Array([7, 100, 4, 6]), new Int32Array([8, 202, 6, 5]), new Int32Array([8, 203, 7, 2]), new Int32Array([8, 204, 3, 7]), new Int32Array([8, 205, 2, 7]), new Int32Array([8, 206, 5, 6]), new Int32Array([8, 207, 8, 2]), new Int32Array([8, 208, 7, 3]), new Int32Array([8, 209, 5, 0]), new Int32Array([8, 210, 7, 1]), new Int32Array([8, 211, 0, 5]), new Int32Array([8, 212, 8, 1]), new Int32Array([8, 213, 1, 7]), new Int32Array([8, 214, 8, 3]), new Int32Array([8, 215, 7, 4]), new Int32Array([8, 216, 4, 7]), new Int32Array([8, 217, 2, 8]), new Int32Array([8, 218, 6, 6]), new Int32Array([8, 219, 7, 5]), new Int32Array([8, 220, 1, 8]), new Int32Array([8, 221, 3, 8]), new Int32Array([8, 222, 8, 4]), new Int32Array([8, 223, 4, 8]), new Int32Array([8, 224, 5, 7]), new Int32Array([8, 225, 8, 5]), new Int32Array([8, 226, 5, 8]), new Int32Array([9, 454, 7, 6]), new Int32Array([9, 455, 6, 7]), new Int32Array([9, 456, 9, 2]), new Int32Array([9, 457, 6, 0]), new Int32Array([9, 458, 6, 8]), new Int32Array([9, 459, 9, 3]), new Int32Array([9, 460, 3, 9]), new Int32Array([9, 461, 9, 1]), new Int32Array([9, 462, 2, 9]), new Int32Array([9, 463, 0, 6]), new Int32Array([9, 464, 8, 6]), new Int32Array([9, 465, 9, 4]), new Int32Array([9, 466, 4, 9]), new Int32Array([9, 467, 10, 2]), new Int32Array([9, 468, 1, 9]), new Int32Array([9, 469, 7, 7]), new Int32Array([9, 470, 8, 7]), new Int32Array([9, 471, 9, 5]), new Int32Array([9, 472, 7, 8]), new Int32Array([9, 473, 10, 3]), new Int32Array([9, 474, 5, 9]), new Int32Array([9, 475, 10, 4]), new Int32Array([9, 476, 2, 10]), new Int32Array([9, 477, 10, 1]), new Int32Array([9, 478, 3, 10]), new Int32Array([9, 479, 9, 6]), new Int32Array([9, 480, 6, 9]), new Int32Array([9, 481, 8, 0]), new Int32Array([9, 482, 4, 10]), new Int32Array([9, 483, 7, 0]), new Int32Array([9, 484, 11, 2]), new Int32Array([10, 970, 7, 9]), new Int32Array([10, 971, 11, 3]), new Int32Array([10, 972, 10, 6]), new Int32Array([10, 973, 1, 10]), new Int32Array([10, 974, 11, 1]), new Int32Array([10, 975, 9, 7]), new Int32Array([10, 976, 0, 7]), new Int32Array([10, 977, 8, 8]), new Int32Array([10, 978, 10, 5]), new Int32Array([10, 979, 3, 11]), new Int32Array([10, 980, 5, 10]), new Int32Array([10, 981, 8, 9]), new Int32Array([10, 982, 11, 5]), new Int32Array([10, 983, 0, 8]), new Int32Array([10, 984, 11, 4]), new Int32Array([10, 985, 2, 11]), new Int32Array([10, 986, 7, 10]), new Int32Array([10, 987, 6, 10]), new Int32Array([10, 988, 10, 7]), new Int32Array([10, 989, 4, 11]), new Int32Array([10, 990, 1, 11]), new Int32Array([10, 991, 12, 2]), new Int32Array([10, 992, 9, 8]), new Int32Array([10, 993, 12, 3]), new Int32Array([10, 994, 11, 6]), new Int32Array([10, 995, 5, 11]), new Int32Array([10, 996, 12, 4]), new Int32Array([10, 997, 11, 7]), new Int32Array([10, 998, 12, 5]), new Int32Array([10, 999, 3, 12]), new Int32Array([10, 1000, 6, 11]), new Int32Array([10, 1001, 9, 0]), new Int32Array([10, 1002, 10, 8]), new Int32Array([10, 1003, 10, 0]), new Int32Array([10, 1004, 12, 1]), new Int32Array([10, 1005, 0, 9]), new Int32Array([10, 1006, 4, 12]), new Int32Array([10, 1007, 9, 9]), new Int32Array([10, 1008, 12, 6]), new Int32Array([10, 1009, 2, 12]), new Int32Array([10, 1010, 8, 10]), new Int32Array([11, 2022, 9, 10]), new Int32Array([11, 2023, 1, 12]), new Int32Array([11, 2024, 11, 8]), new Int32Array([11, 2025, 12, 7]), new Int32Array([11, 2026, 7, 11]), new Int32Array([11, 2027, 5, 12]), new Int32Array([11, 2028, 6, 12]), new Int32Array([11, 2029, 10, 9]), new Int32Array([11, 2030, 8, 11]), new Int32Array([11, 2031, 12, 8]), new Int32Array([11, 2032, 0, 10]), new Int32Array([11, 2033, 7, 12]), new Int32Array([11, 2034, 11, 0]), new Int32Array([11, 2035, 10, 10]), new Int32Array([11, 2036, 11, 9]), new Int32Array([11, 2037, 11, 10]), new Int32Array([11, 2038, 0, 11]), new Int32Array([11, 2039, 11, 11]), new Int32Array([11, 2040, 9, 11]), new Int32Array([11, 2041, 10, 11]), new Int32Array([11, 2042, 12, 0]), new Int32Array([11, 2043, 8, 12]), new Int32Array([12, 4088, 12, 9]), new Int32Array([12, 4089, 10, 12]), new Int32Array([12, 4090, 9, 12]), new Int32Array([12, 4091, 11, 12]), new Int32Array([12, 4092, 12, 11]), new Int32Array([12, 4093, 0, 12]), new Int32Array([12, 4094, 12, 10]), new Int32Array([12, 4095, 12, 12])];
    constructor.HCB11 = [new Int32Array([4, 0, 0, 0]), new Int32Array([4, 1, 1, 1]), new Int32Array([5, 4, 16, 16]), new Int32Array([5, 5, 1, 0]), new Int32Array([5, 6, 0, 1]), new Int32Array([5, 7, 2, 1]), new Int32Array([5, 8, 1, 2]), new Int32Array([5, 9, 2, 2]), new Int32Array([6, 20, 1, 3]), new Int32Array([6, 21, 3, 1]), new Int32Array([6, 22, 3, 2]), new Int32Array([6, 23, 2, 0]), new Int32Array([6, 24, 2, 3]), new Int32Array([6, 25, 0, 2]), new Int32Array([6, 26, 3, 3]), new Int32Array([7, 54, 4, 1]), new Int32Array([7, 55, 1, 4]), new Int32Array([7, 56, 4, 2]), new Int32Array([7, 57, 2, 4]), new Int32Array([7, 58, 4, 3]), new Int32Array([7, 59, 3, 4]), new Int32Array([7, 60, 3, 0]), new Int32Array([7, 61, 0, 3]), new Int32Array([7, 62, 5, 1]), new Int32Array([7, 63, 5, 2]), new Int32Array([7, 64, 2, 5]), new Int32Array([7, 65, 4, 4]), new Int32Array([7, 66, 1, 5]), new Int32Array([7, 67, 5, 3]), new Int32Array([7, 68, 3, 5]), new Int32Array([7, 69, 5, 4]), new Int32Array([8, 140, 4, 5]), new Int32Array([8, 141, 6, 2]), new Int32Array([8, 142, 2, 6]), new Int32Array([8, 143, 6, 1]), new Int32Array([8, 144, 6, 3]), new Int32Array([8, 145, 3, 6]), new Int32Array([8, 146, 1, 6]), new Int32Array([8, 147, 4, 16]), new Int32Array([8, 148, 3, 16]), new Int32Array([8, 149, 16, 5]), new Int32Array([8, 150, 16, 3]), new Int32Array([8, 151, 16, 4]), new Int32Array([8, 152, 6, 4]), new Int32Array([8, 153, 16, 6]), new Int32Array([8, 154, 4, 0]), new Int32Array([8, 155, 4, 6]), new Int32Array([8, 156, 0, 4]), new Int32Array([8, 157, 2, 16]), new Int32Array([8, 158, 5, 5]), new Int32Array([8, 159, 5, 16]), new Int32Array([8, 160, 16, 7]), new Int32Array([8, 161, 16, 2]), new Int32Array([8, 162, 16, 8]), new Int32Array([8, 163, 2, 7]), new Int32Array([8, 164, 7, 2]), new Int32Array([8, 165, 3, 7]), new Int32Array([8, 166, 6, 5]), new Int32Array([8, 167, 5, 6]), new Int32Array([8, 168, 6, 16]), new Int32Array([8, 169, 16, 10]), new Int32Array([8, 170, 7, 3]), new Int32Array([8, 171, 7, 1]), new Int32Array([8, 172, 16, 9]), new Int32Array([8, 173, 7, 16]), new Int32Array([8, 174, 1, 16]), new Int32Array([8, 175, 1, 7]), new Int32Array([8, 176, 4, 7]), new Int32Array([8, 177, 16, 11]), new Int32Array([8, 178, 7, 4]), new Int32Array([8, 179, 16, 12]), new Int32Array([8, 180, 8, 16]), new Int32Array([8, 181, 16, 1]), new Int32Array([8, 182, 6, 6]), new Int32Array([8, 183, 9, 16]), new Int32Array([8, 184, 2, 8]), new Int32Array([8, 185, 5, 7]), new Int32Array([8, 186, 10, 16]), new Int32Array([8, 187, 16, 13]), new Int32Array([8, 188, 8, 3]), new Int32Array([8, 189, 8, 2]), new Int32Array([8, 190, 3, 8]), new Int32Array([8, 191, 5, 0]), new Int32Array([8, 192, 16, 14]), new Int32Array([8, 193, 11, 16]), new Int32Array([8, 194, 7, 5]), new Int32Array([8, 195, 4, 8]), new Int32Array([8, 196, 6, 7]), new Int32Array([8, 197, 7, 6]), new Int32Array([8, 198, 0, 5]), new Int32Array([9, 398, 8, 4]), new Int32Array([9, 399, 16, 15]), new Int32Array([9, 400, 12, 16]), new Int32Array([9, 401, 1, 8]), new Int32Array([9, 402, 8, 1]), new Int32Array([9, 403, 14, 16]), new Int32Array([9, 404, 5, 8]), new Int32Array([9, 405, 13, 16]), new Int32Array([9, 406, 3, 9]), new Int32Array([9, 407, 8, 5]), new Int32Array([9, 408, 7, 7]), new Int32Array([9, 409, 2, 9]), new Int32Array([9, 410, 8, 6]), new Int32Array([9, 411, 9, 2]), new Int32Array([9, 412, 9, 3]), new Int32Array([9, 413, 15, 16]), new Int32Array([9, 414, 4, 9]), new Int32Array([9, 415, 6, 8]), new Int32Array([9, 416, 6, 0]), new Int32Array([9, 417, 9, 4]), new Int32Array([9, 418, 5, 9]), new Int32Array([9, 419, 8, 7]), new Int32Array([9, 420, 7, 8]), new Int32Array([9, 421, 1, 9]), new Int32Array([9, 422, 10, 3]), new Int32Array([9, 423, 0, 6]), new Int32Array([9, 424, 10, 2]), new Int32Array([9, 425, 9, 1]), new Int32Array([9, 426, 9, 5]), new Int32Array([9, 427, 4, 10]), new Int32Array([9, 428, 2, 10]), new Int32Array([9, 429, 9, 6]), new Int32Array([9, 430, 3, 10]), new Int32Array([9, 431, 6, 9]), new Int32Array([9, 432, 10, 4]), new Int32Array([9, 433, 8, 8]), new Int32Array([9, 434, 10, 5]), new Int32Array([9, 435, 9, 7]), new Int32Array([9, 436, 11, 3]), new Int32Array([9, 437, 1, 10]), new Int32Array([9, 438, 7, 0]), new Int32Array([9, 439, 10, 6]), new Int32Array([9, 440, 7, 9]), new Int32Array([9, 441, 3, 11]), new Int32Array([9, 442, 5, 10]), new Int32Array([9, 443, 10, 1]), new Int32Array([9, 444, 4, 11]), new Int32Array([9, 445, 11, 2]), new Int32Array([9, 446, 13, 2]), new Int32Array([9, 447, 6, 10]), new Int32Array([9, 448, 13, 3]), new Int32Array([9, 449, 2, 11]), new Int32Array([9, 450, 16, 0]), new Int32Array([9, 451, 5, 11]), new Int32Array([9, 452, 11, 5]), new Int32Array([10, 906, 11, 4]), new Int32Array([10, 907, 9, 8]), new Int32Array([10, 908, 7, 10]), new Int32Array([10, 909, 8, 9]), new Int32Array([10, 910, 0, 16]), new Int32Array([10, 911, 4, 13]), new Int32Array([10, 912, 0, 7]), new Int32Array([10, 913, 3, 13]), new Int32Array([10, 914, 11, 6]), new Int32Array([10, 915, 13, 1]), new Int32Array([10, 916, 13, 4]), new Int32Array([10, 917, 12, 3]), new Int32Array([10, 918, 2, 13]), new Int32Array([10, 919, 13, 5]), new Int32Array([10, 920, 8, 10]), new Int32Array([10, 921, 6, 11]), new Int32Array([10, 922, 10, 8]), new Int32Array([10, 923, 10, 7]), new Int32Array([10, 924, 14, 2]), new Int32Array([10, 925, 12, 4]), new Int32Array([10, 926, 1, 11]), new Int32Array([10, 927, 4, 12]), new Int32Array([10, 928, 11, 1]), new Int32Array([10, 929, 3, 12]), new Int32Array([10, 930, 1, 13]), new Int32Array([10, 931, 12, 2]), new Int32Array([10, 932, 7, 11]), new Int32Array([10, 933, 3, 14]), new Int32Array([10, 934, 5, 12]), new Int32Array([10, 935, 5, 13]), new Int32Array([10, 936, 14, 4]), new Int32Array([10, 937, 4, 14]), new Int32Array([10, 938, 11, 7]), new Int32Array([10, 939, 14, 3]), new Int32Array([10, 940, 12, 5]), new Int32Array([10, 941, 13, 6]), new Int32Array([10, 942, 12, 6]), new Int32Array([10, 943, 8, 0]), new Int32Array([10, 944, 11, 8]), new Int32Array([10, 945, 2, 12]), new Int32Array([10, 946, 9, 9]), new Int32Array([10, 947, 14, 5]), new Int32Array([10, 948, 6, 13]), new Int32Array([10, 949, 10, 10]), new Int32Array([10, 950, 15, 2]), new Int32Array([10, 951, 8, 11]), new Int32Array([10, 952, 9, 10]), new Int32Array([10, 953, 14, 6]), new Int32Array([10, 954, 10, 9]), new Int32Array([10, 955, 5, 14]), new Int32Array([10, 956, 11, 9]), new Int32Array([10, 957, 14, 1]), new Int32Array([10, 958, 2, 14]), new Int32Array([10, 959, 6, 12]), new Int32Array([10, 960, 1, 12]), new Int32Array([10, 961, 13, 8]), new Int32Array([10, 962, 0, 8]), new Int32Array([10, 963, 13, 7]), new Int32Array([10, 964, 7, 12]), new Int32Array([10, 965, 12, 7]), new Int32Array([10, 966, 7, 13]), new Int32Array([10, 967, 15, 3]), new Int32Array([10, 968, 12, 1]), new Int32Array([10, 969, 6, 14]), new Int32Array([10, 970, 2, 15]), new Int32Array([10, 971, 15, 5]), new Int32Array([10, 972, 15, 4]), new Int32Array([10, 973, 1, 14]), new Int32Array([10, 974, 9, 11]), new Int32Array([10, 975, 4, 15]), new Int32Array([10, 976, 14, 7]), new Int32Array([10, 977, 8, 13]), new Int32Array([10, 978, 13, 9]), new Int32Array([10, 979, 8, 12]), new Int32Array([10, 980, 5, 15]), new Int32Array([10, 981, 3, 15]), new Int32Array([10, 982, 10, 11]), new Int32Array([10, 983, 11, 10]), new Int32Array([10, 984, 12, 8]), new Int32Array([10, 985, 15, 6]), new Int32Array([10, 986, 15, 7]), new Int32Array([10, 987, 8, 14]), new Int32Array([10, 988, 15, 1]), new Int32Array([10, 989, 7, 14]), new Int32Array([10, 990, 9, 0]), new Int32Array([10, 991, 0, 9]), new Int32Array([10, 992, 9, 13]), new Int32Array([10, 993, 9, 12]), new Int32Array([10, 994, 12, 9]), new Int32Array([10, 995, 14, 8]), new Int32Array([10, 996, 10, 13]), new Int32Array([10, 997, 14, 9]), new Int32Array([10, 998, 12, 10]), new Int32Array([10, 999, 6, 15]), new Int32Array([10, 1000, 7, 15]), new Int32Array([11, 2002, 9, 14]), new Int32Array([11, 2003, 15, 8]), new Int32Array([11, 2004, 11, 11]), new Int32Array([11, 2005, 11, 14]), new Int32Array([11, 2006, 1, 15]), new Int32Array([11, 2007, 10, 12]), new Int32Array([11, 2008, 10, 14]), new Int32Array([11, 2009, 13, 11]), new Int32Array([11, 2010, 13, 10]), new Int32Array([11, 2011, 11, 13]), new Int32Array([11, 2012, 11, 12]), new Int32Array([11, 2013, 8, 15]), new Int32Array([11, 2014, 14, 11]), new Int32Array([11, 2015, 13, 12]), new Int32Array([11, 2016, 12, 13]), new Int32Array([11, 2017, 15, 9]), new Int32Array([11, 2018, 14, 10]), new Int32Array([11, 2019, 10, 0]), new Int32Array([11, 2020, 12, 11]), new Int32Array([11, 2021, 9, 15]), new Int32Array([11, 2022, 0, 10]), new Int32Array([11, 2023, 12, 12]), new Int32Array([11, 2024, 11, 0]), new Int32Array([11, 2025, 12, 14]), new Int32Array([11, 2026, 10, 15]), new Int32Array([11, 2027, 13, 13]), new Int32Array([11, 2028, 0, 13]), new Int32Array([11, 2029, 14, 12]), new Int32Array([11, 2030, 15, 10]), new Int32Array([11, 2031, 15, 11]), new Int32Array([11, 2032, 11, 15]), new Int32Array([11, 2033, 14, 13]), new Int32Array([11, 2034, 13, 0]), new Int32Array([11, 2035, 0, 11]), new Int32Array([11, 2036, 13, 14]), new Int32Array([11, 2037, 15, 12]), new Int32Array([11, 2038, 15, 13]), new Int32Array([11, 2039, 12, 15]), new Int32Array([11, 2040, 14, 0]), new Int32Array([11, 2041, 14, 14]), new Int32Array([11, 2042, 13, 15]), new Int32Array([11, 2043, 12, 0]), new Int32Array([11, 2044, 14, 15]), new Int32Array([12, 4090, 0, 14]), new Int32Array([12, 4091, 0, 12]), new Int32Array([12, 4092, 15, 14]), new Int32Array([12, 4093, 15, 0]), new Int32Array([12, 4094, 0, 15]), new Int32Array([12, 4095, 15, 15])];
    constructor.HCB_SF = [new Int32Array([1, 0, 60]), new Int32Array([3, 4, 59]), new Int32Array([4, 10, 61]), new Int32Array([4, 11, 58]), new Int32Array([4, 12, 62]), new Int32Array([5, 26, 57]), new Int32Array([5, 27, 63]), new Int32Array([6, 56, 56]), new Int32Array([6, 57, 64]), new Int32Array([6, 58, 55]), new Int32Array([6, 59, 65]), new Int32Array([7, 120, 66]), new Int32Array([7, 121, 54]), new Int32Array([7, 122, 67]), new Int32Array([8, 246, 53]), new Int32Array([8, 247, 68]), new Int32Array([8, 248, 52]), new Int32Array([8, 249, 69]), new Int32Array([8, 250, 51]), new Int32Array([9, 502, 70]), new Int32Array([9, 503, 50]), new Int32Array([9, 504, 49]), new Int32Array([9, 505, 71]), new Int32Array([10, 1012, 72]), new Int32Array([10, 1013, 48]), new Int32Array([10, 1014, 73]), new Int32Array([10, 1015, 47]), new Int32Array([10, 1016, 74]), new Int32Array([10, 1017, 46]), new Int32Array([11, 2036, 76]), new Int32Array([11, 2037, 75]), new Int32Array([11, 2038, 77]), new Int32Array([11, 2039, 78]), new Int32Array([11, 2040, 45]), new Int32Array([11, 2041, 43]), new Int32Array([12, 4084, 44]), new Int32Array([12, 4085, 79]), new Int32Array([12, 4086, 42]), new Int32Array([12, 4087, 41]), new Int32Array([12, 4088, 80]), new Int32Array([12, 4089, 40]), new Int32Array([13, 8180, 81]), new Int32Array([13, 8181, 39]), new Int32Array([13, 8182, 82]), new Int32Array([13, 8183, 38]), new Int32Array([13, 8184, 83]), new Int32Array([14, 16370, 37]), new Int32Array([14, 16371, 35]), new Int32Array([14, 16372, 85]), new Int32Array([14, 16373, 33]), new Int32Array([14, 16374, 36]), new Int32Array([14, 16375, 34]), new Int32Array([14, 16376, 84]), new Int32Array([14, 16377, 32]), new Int32Array([15, 32756, 87]), new Int32Array([15, 32757, 89]), new Int32Array([15, 32758, 30]), new Int32Array([15, 32759, 31]), new Int32Array([16, 65520, 86]), new Int32Array([16, 65521, 29]), new Int32Array([16, 65522, 26]), new Int32Array([16, 65523, 27]), new Int32Array([16, 65524, 28]), new Int32Array([16, 65525, 24]), new Int32Array([16, 65526, 88]), new Int32Array([17, 131054, 25]), new Int32Array([17, 131055, 22]), new Int32Array([17, 131056, 23]), new Int32Array([18, 262114, 90]), new Int32Array([18, 262115, 21]), new Int32Array([18, 262116, 19]), new Int32Array([18, 262117, 3]), new Int32Array([18, 262118, 1]), new Int32Array([18, 262119, 2]), new Int32Array([18, 262120, 0]), new Int32Array([19, 524242, 98]), new Int32Array([19, 524243, 99]), new Int32Array([19, 524244, 100]), new Int32Array([19, 524245, 101]), new Int32Array([19, 524246, 102]), new Int32Array([19, 524247, 117]), new Int32Array([19, 524248, 97]), new Int32Array([19, 524249, 91]), new Int32Array([19, 524250, 92]), new Int32Array([19, 524251, 93]), new Int32Array([19, 524252, 94]), new Int32Array([19, 524253, 95]), new Int32Array([19, 524254, 96]), new Int32Array([19, 524255, 104]), new Int32Array([19, 524256, 111]), new Int32Array([19, 524257, 112]), new Int32Array([19, 524258, 113]), new Int32Array([19, 524259, 114]), new Int32Array([19, 524260, 115]), new Int32Array([19, 524261, 116]), new Int32Array([19, 524262, 110]), new Int32Array([19, 524263, 105]), new Int32Array([19, 524264, 106]), new Int32Array([19, 524265, 107]), new Int32Array([19, 524266, 108]), new Int32Array([19, 524267, 109]), new Int32Array([19, 524268, 118]), new Int32Array([19, 524269, 6]), new Int32Array([19, 524270, 8]), new Int32Array([19, 524271, 9]), new Int32Array([19, 524272, 10]), new Int32Array([19, 524273, 5]), new Int32Array([19, 524274, 103]), new Int32Array([19, 524275, 120]), new Int32Array([19, 524276, 119]), new Int32Array([19, 524277, 4]), new Int32Array([19, 524278, 7]), new Int32Array([19, 524279, 15]), new Int32Array([19, 524280, 16]), new Int32Array([19, 524281, 18]), new Int32Array([19, 524282, 20]), new Int32Array([19, 524283, 17]), new Int32Array([19, 524284, 11]), new Int32Array([19, 524285, 12]), new Int32Array([19, 524286, 14]), new Int32Array([19, 524287, 13])];
    constructor.CODEBOOKS = [Codebooks.HCB1, Codebooks.HCB2, Codebooks.HCB3, Codebooks.HCB4, Codebooks.HCB5, Codebooks.HCB6, Codebooks.HCB7, Codebooks.HCB8, Codebooks.HCB9, Codebooks.HCB10, Codebooks.HCB11];
}, {HCB1: "Array", HCB2: "Array", HCB3: "Array", HCB4: "Array", HCB5: "Array", HCB6: "Array", HCB7: "Array", HCB8: "Array", HCB9: "Array", HCB10: "Array", HCB11: "Array", HCB_SF: "Array", CODEBOOKS: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var WriterLE = function() {};
WriterLE = stjs.extend(WriterLE, null, [], function(constructor, prototype) {
    constructor.writeShort = function(out, s) {
        out.write(s & 255);
        out.write((s >> 8) & 255);
    };
    constructor.writeInt = function(out, i) {
        out.write(i & 255);
        out.write((i >> 8) & 255);
        out.write((i >> 16) & 255);
        out.write((i >> 24) & 255);
    };
    constructor.writeLong = function(out, l) {
        out.write((((l & 255)) | 0));
        out.write(((((l >> 8) & 255)) | 0));
        out.write(((((l >> 16) & 255)) | 0));
        out.write(((((l >> 24) & 255)) | 0));
        out.write(((((l >> 32) & 255)) | 0));
        out.write(((((l >> 40) & 255)) | 0));
        out.write(((((l >> 48) & 255)) | 0));
        out.write(((((l >> 56) & 255)) | 0));
    };
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Intensity stereo lookup table for all possible values for
 *  0.5<sup>0.25*scaleFactor</sup>.
 *  @author in-somnia
 */
var ISScaleTable = function() {};
ISScaleTable = stjs.extend(ISScaleTable, null, [], function(constructor, prototype) {
    constructor.SCALE_TABLE = new Float32Array([1.0, 0.8408964, 0.70710677, 0.59460354, 0.5, 0.4204482, 0.35355338, 0.29730177, 0.25, 0.2102241, 0.17677669, 0.14865088, 0.125, 0.10511205, 0.088388346, 0.07432544, 0.0625, 0.052556027, 0.044194173, 0.03716272, 0.03125, 0.026278013, 0.022097087, 0.01858136, 0.015625, 0.013139007, 0.011048543, 0.00929068, 0.0078125, 0.0065695033, 0.0055242716, 0.00464534, 0.00390625, 0.0032847517, 0.0027621358, 0.00232267, 0.001953125, 0.0016423758, 0.0013810679, 0.001161335, 9.765625E-4, 8.211879E-4, 6.9053395E-4, 5.806675E-4, 4.8828125E-4, 4.1059396E-4, 3.4526698E-4, 2.9033376E-4, 2.4414062E-4, 2.0529698E-4, 1.7263349E-4, 1.4516688E-4, 1.2207031E-4, 1.0264849E-4, 8.6316744E-5, 7.258344E-5, 6.1035156E-5, 5.1324245E-5, 4.3158372E-5, 3.629172E-5, 3.0517578E-5, 2.5662122E-5, 2.1579186E-5, 1.814586E-5, 1.5258789E-5, 1.2831061E-5, 1.0789593E-5, 9.07293E-6, 7.6293945E-6, 6.4155306E-6, 5.3947965E-6, 4.536465E-6, 3.8146973E-6, 3.2077653E-6, 2.6973983E-6, 2.2682325E-6, 1.9073486E-6, 1.6038827E-6, 1.3486991E-6, 1.1341162E-6, 9.536743E-7, 8.019413E-7, 6.7434956E-7, 5.670581E-7, 4.7683716E-7, 4.0097066E-7, 3.3717478E-7, 2.8352906E-7, 2.3841858E-7, 2.0048533E-7, 1.6858739E-7, 1.4176453E-7, 1.1920929E-7, 1.00242666E-7, 8.4293696E-8, 7.0882265E-8, 5.9604645E-8, 5.0121333E-8, 4.2146848E-8, 3.5441133E-8, 2.9802322E-8, 2.5060666E-8, 2.1073424E-8, 1.7720566E-8, 1.4901161E-8, 1.2530333E-8, 1.0536712E-8, 8.860283E-9, 7.4505806E-9, 6.2651666E-9, 5.268356E-9, 4.4301416E-9, 3.7252903E-9, 3.1325833E-9, 2.634178E-9, 2.2150708E-9, 1.8626451E-9, 1.5662917E-9, 1.317089E-9, 1.1075354E-9, 9.313226E-10, 7.831458E-10, 6.585445E-10, 5.537677E-10, 4.656613E-10, 3.915729E-10, 3.2927225E-10, 2.7688385E-10, 2.3283064E-10, 1.9578646E-10, 1.6463612E-10, 1.3844192E-10, 1.1641532E-10, 9.789323E-11, 8.231806E-11, 6.922096E-11, 5.820766E-11, 4.8946614E-11, 4.115903E-11, 3.461048E-11, 2.910383E-11, 2.4473307E-11, 2.0579516E-11, 1.730524E-11, 1.4551915E-11, 1.22366535E-11, 1.0289758E-11, 8.65262E-12, 7.2759576E-12, 6.1183268E-12, 5.144879E-12, 4.32631E-12, 3.6379788E-12, 3.0591634E-12, 2.5724394E-12, 2.163155E-12, 1.8189894E-12, 1.5295817E-12, 1.2862197E-12, 1.0815775E-12, 9.094947E-13, 7.6479085E-13, 6.4310986E-13, 5.4078877E-13, 4.5474735E-13, 3.8239542E-13, 3.2155493E-13, 2.7039438E-13, 2.2737368E-13, 1.9119771E-13, 1.6077747E-13, 1.3519719E-13, 1.1368684E-13, 9.5598856E-14, 8.038873E-14, 6.7598596E-14, 5.684342E-14, 4.7799428E-14, 4.0194366E-14, 3.3799298E-14, 2.842171E-14, 2.3899714E-14, 2.0097183E-14, 1.6899649E-14, 1.4210855E-14, 1.1949857E-14, 1.00485916E-14, 8.4498245E-15, 7.1054274E-15, 5.9749285E-15, 5.0242958E-15, 4.2249122E-15, 3.5527137E-15, 2.9874642E-15, 2.5121479E-15, 2.1124561E-15, 1.7763568E-15, 1.4937321E-15, 1.2560739E-15, 1.0562281E-15, 8.881784E-16, 7.4686606E-16, 6.2803697E-16, 5.2811403E-16, 4.440892E-16, 3.7343303E-16, 3.1401849E-16, 2.6405702E-16, 2.220446E-16, 1.8671652E-16, 1.5700924E-16, 1.3202851E-16, 1.110223E-16, 9.335826E-17, 7.850462E-17, 6.6014254E-17, 5.551115E-17, 4.667913E-17, 3.925231E-17, 3.3007127E-17, 2.7755576E-17, 2.3339564E-17, 1.9626155E-17, 1.6503563E-17, 1.3877788E-17, 1.1669782E-17, 9.813078E-18, 8.251782E-18, 6.938894E-18, 5.834891E-18, 4.906539E-18, 4.125891E-18, 3.469447E-18, 2.9174455E-18, 2.4532694E-18, 2.0629454E-18, 1.7347235E-18, 1.4587228E-18, 1.2266347E-18, 1.0314727E-18, 8.6736174E-19, 7.293614E-19, 6.1331736E-19, 5.1573636E-19, 4.3368087E-19, 3.646807E-19, 3.0665868E-19, 2.5786818E-19, 2.1684043E-19, 1.8234035E-19, 1.5332934E-19, 1.2893409E-19, 1.0842022E-19, 9.1170173E-20, 7.666467E-20]);
}, {SCALE_TABLE: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var AudioSource = function() {};
AudioSource = stjs.extend(AudioSource, null, [], function(constructor, prototype) {
    prototype.getFormat = function() {};
    prototype.readFloat = function(buffer) {};
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var PQFTables = function() {};
PQFTables = stjs.extend(PQFTables, null, [], function(constructor, prototype) {
    constructor.PROTO_TABLE = new Float32Array([1.2206911E-5, 1.7261988E-5, 1.2300094E-5, -1.0833943E-5, -5.77725E-5, -1.2764768E-4, -2.0965187E-4, -2.8166673E-4, -3.123486E-4, -2.673852E-4, -1.19494245E-4, 1.396514E-4, 4.886414E-4, 8.7044627E-4, 0.001194943, 0.0013519708, 0.0012346314, 7.695321E-4, -5.2242434E-5, -0.0011516092, -0.002353847, -0.0034033123, -0.004002855, -0.0038745415, -0.0028321072, -8.503889E-4, 0.0018856751, 0.004968874, 0.0078056706, 0.0097027905, 0.009996043, 0.008201936, 0.0041642073, -0.0018364454, -0.0090384865, -0.016241528, -0.021939551, -0.02453318, -0.022591664, -0.015122066, -0.0017971713, 0.016903413, 0.039672315, 0.064487524, 0.08885003, 0.11011329, 0.12585402, 0.13422394, 0.13422394, 0.12585402, 0.11011329, 0.08885003, 0.064487524, 0.039672315, 0.016903413, -0.0017971713, -0.015122066, -0.022591664, -0.02453318, -0.021939551, -0.016241528, -0.0090384865, -0.0018364454, 0.0041642073, 0.008201936, 0.009996043, 0.0097027905, 0.0078056706, 0.004968874, 0.0018856751, -8.503889E-4, -0.0028321072, -0.0038745415, -0.004002855, -0.0034033123, -0.002353847, -0.0011516092, -5.2242434E-5, 7.695321E-4, 0.0012346314, 0.0013519708, 0.001194943, 8.7044627E-4, 4.886414E-4, 1.396514E-4, -1.19494245E-4, -2.673852E-4, -3.123486E-4, -2.8166673E-4, -2.0965187E-4, -1.2764768E-4, -5.77725E-5, -1.0833943E-5, 1.2300094E-5, 1.7261988E-5, 1.2206911E-5]);
    constructor.COEFS_Q0 = [new Float32Array([1.6629392, -0.39018065, -1.9615706, -1.11114]), new Float32Array([1.9615705, 1.6629392, 1.1111404, 0.39018047]), new Float32Array([1.9615705, 1.6629392, 1.1111404, 0.39018047]), new Float32Array([1.6629392, -0.39018065, -1.9615706, -1.11114])];
    constructor.COEFS_Q1 = [new Float32Array([1.1111404, -1.9615706, 0.39018083, 1.6629387]), new Float32Array([0.39018047, -1.11114, 1.6629387, -1.9615704]), new Float32Array([-0.39018065, 1.1111408, -1.6629395, 1.9615709]), new Float32Array([-1.1111407, 1.9615705, -0.39018044, -1.6629392])];
    constructor.COEFS_T0 = [new Float32Array([4.8827646E-5, 0.0012493944, 0.0049385256, 0.011328429, 0.016656829, 0.0071886852, 0.53689575, 0.060488265, 0.032807745, 0.015498166, 0.0054078833, 0.0011266669]), new Float32Array([6.904795E-5, 0.0010695409, 0.0030781284, 0.0034015556, -0.0073457817, -0.067613654, 0.50341606, 0.090366654, 0.03998417, 0.01601142, 0.004779772, 8.386075E-4]), new Float32Array([4.9200375E-5, 4.7797698E-4, -2.0896974E-4, -0.0075427005, -0.036153946, -0.15868926, 0.44045317, 0.09813272, 0.038811162, 0.013613249, 0.003481785, 5.1059073E-4]), new Float32Array([-4.333577E-5, -5.586056E-4, -0.004606437, -0.019875497, -0.06496611, -0.2579501, 0.35540012, 0.087758206, 0.031222682, 0.009415388, 0.0019545655, 2.3109E-4])];
    constructor.COEFS_T1 = [new Float32Array([-2.3109E-4, -0.0019545655, -0.009415388, -0.031222682, -0.087758206, -0.35540012, 0.2579501, 0.06496611, 0.019875497, 0.004606437, 5.586056E-4, 4.333577E-5]), new Float32Array([-5.1059073E-4, -0.003481785, -0.013613249, -0.038811162, -0.09813272, -0.44045317, 0.15868926, 0.036153946, 0.0075427005, 2.0896974E-4, -4.7797698E-4, -4.9200375E-5]), new Float32Array([-8.386075E-4, -0.004779772, -0.01601142, -0.03998417, -0.090366654, -0.50341606, 0.067613654, 0.0073457817, -0.0034015556, -0.0030781284, -0.0010695409, -6.904795E-5]), new Float32Array([-0.0011266669, -0.0054078833, -0.015498166, -0.032807745, -0.060488265, -0.53689575, -0.0071886852, -0.016656829, -0.011328429, -0.0049385256, -0.0012493944, -4.8827646E-5])];
}, {PROTO_TABLE: "Float32Array", COEFS_Q0: "Array", COEFS_Q1: "Array", COEFS_T0: "Array", COEFS_T1: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var SineWindows = function() {};
SineWindows = stjs.extend(SineWindows, null, [], function(constructor, prototype) {
    constructor.SINE_1024 = new Float32Array([7.669903E-4, 0.002300969, 0.0038349426, 0.005368907, 0.0069028586, 0.008436794, 0.00997071, 0.011504602, 0.013038468, 0.014572302, 0.016106103, 0.017639864, 0.019173585, 0.02070726, 0.022240888, 0.023774462, 0.025307981, 0.02684144, 0.028374836, 0.029908165, 0.031441424, 0.03297461, 0.034507714, 0.036040742, 0.037573684, 0.039106537, 0.040639296, 0.042171963, 0.04370453, 0.04523699, 0.046769347, 0.048301592, 0.049833726, 0.05136574, 0.052897636, 0.05442941, 0.05596105, 0.057492558, 0.059023935, 0.06055517, 0.062086266, 0.063617215, 0.06514801, 0.06667866, 0.06820914, 0.06973947, 0.07126963, 0.07279963, 0.07432945, 0.07585911, 0.07738858, 0.07891786, 0.080446966, 0.08197588, 0.0835046, 0.085033126, 0.08656145, 0.08808957, 0.08961748, 0.09114519, 0.092672676, 0.09419994, 0.09572699, 0.097253814, 0.09878041, 0.10030677, 0.1018329, 0.10335878, 0.10488442, 0.10640982, 0.10793497, 0.109459855, 0.11098449, 0.11250886, 0.11403298, 0.115556814, 0.11708038, 0.11860368, 0.12012669, 0.121649414, 0.12317186, 0.12469402, 0.12621588, 0.12773745, 0.1292587, 0.13077967, 0.13230032, 0.13382065, 0.13534068, 0.13686039, 0.13837977, 0.13989884, 0.14141756, 0.14293596, 0.14445402, 0.14597175, 0.14748912, 0.14900614, 0.15052283, 0.15203916, 0.15355512, 0.15507074, 0.15658598, 0.15810084, 0.15961535, 0.16112947, 0.16264322, 0.16415659, 0.16566956, 0.16718215, 0.16869435, 0.17020614, 0.17171754, 0.17322853, 0.17473911, 0.1762493, 0.17775905, 0.17926839, 0.18077731, 0.1822858, 0.18379387, 0.1853015, 0.18680869, 0.18831545, 0.18982176, 0.19132763, 0.19283305, 0.19433801, 0.19584252, 0.19734657, 0.19885014, 0.20035325, 0.2018559, 0.20335807, 0.20485975, 0.20636095, 0.20786168, 0.20936191, 0.21086164, 0.21236089, 0.21385963, 0.21535787, 0.2168556, 0.21835282, 0.21984953, 0.22134572, 0.2228414, 0.22433653, 0.22583115, 0.22732525, 0.22881879, 0.23031181, 0.23180428, 0.2332962, 0.23478758, 0.2362784, 0.23776866, 0.23925838, 0.24074753, 0.24223611, 0.24372411, 0.24521154, 0.24669841, 0.24818468, 0.24967039, 0.2511555, 0.25264, 0.25412393, 0.25560725, 0.25708997, 0.25857207, 0.2600536, 0.26153448, 0.26301476, 0.26449442, 0.26597348, 0.26745188, 0.26892966, 0.2704068, 0.27188334, 0.2733592, 0.27483445, 0.27630904, 0.27778298, 0.27925625, 0.28072888, 0.28220084, 0.28367212, 0.28514278, 0.28661272, 0.28808203, 0.28955063, 0.29101855, 0.2924858, 0.29395235, 0.2954182, 0.29688337, 0.29834786, 0.29981163, 0.3012747, 0.30273703, 0.30419868, 0.3056596, 0.30711982, 0.3085793, 0.31003806, 0.31149608, 0.31295338, 0.31440994, 0.31586576, 0.31732082, 0.31877515, 0.32022873, 0.32168156, 0.32313362, 0.32458493, 0.32603547, 0.32748523, 0.32893425, 0.3303825, 0.33182994, 0.3332766, 0.3347225, 0.3361676, 0.3376119, 0.33905542, 0.34049815, 0.34194008, 0.34338117, 0.34482148, 0.34626096, 0.34769964, 0.3491375, 0.35057455, 0.35201076, 0.35344616, 0.3548807, 0.35631442, 0.3577473, 0.35917935, 0.3606105, 0.36204088, 0.36347038, 0.364899, 0.36632678, 0.36775368, 0.36917976, 0.37060493, 0.37202924, 0.37345266, 0.37487522, 0.3762969, 0.3777177, 0.3791376, 0.3805566, 0.38197473, 0.38339192, 0.38480824, 0.38622364, 0.38763815, 0.38905174, 0.3904644, 0.39187613, 0.39328697, 0.39469686, 0.39610586, 0.3975139, 0.398921, 0.40032718, 0.4017324, 0.40313667, 0.40454, 0.40594238, 0.4073438, 0.40874428, 0.4101438, 0.41154233, 0.41293988, 0.4143365, 0.41573212, 0.41712677, 0.41852042, 0.4199131, 0.4213048, 0.4226955, 0.4240852, 0.4254739, 0.4268616, 0.42824832, 0.429634, 0.4310187, 0.43240237, 0.43378502, 0.43516666, 0.43654725, 0.43792683, 0.4393054, 0.4406829, 0.44205937, 0.4434348, 0.4448092, 0.44618255, 0.44755486, 0.4489261, 0.45029628, 0.45166543, 0.45303348, 0.45440048, 0.4557664, 0.45713127, 0.45849505, 0.45985776, 0.4612194, 0.46257994, 0.46393937, 0.46529773, 0.466655, 0.46801114, 0.46936622, 0.47072017, 0.47207302, 0.47342476, 0.47477537, 0.47612488, 0.4774733, 0.47882056, 0.48016667, 0.48151168, 0.48285556, 0.4841983, 0.4855399, 0.48688036, 0.48821968, 0.48955783, 0.49089485, 0.4922307, 0.4935654, 0.49489895, 0.4962313, 0.4975625, 0.49889255, 0.5002214, 0.50154907, 0.50287557, 0.5042009, 0.50552505, 0.506848, 0.5081697, 0.50949025, 0.5108096, 0.51212776, 0.5134447, 0.51476043, 0.516075, 0.5173883, 0.5187004, 0.52001125, 0.52132094, 0.5226294, 0.52393657, 0.5252425, 0.52654725, 0.52785075, 0.529153, 0.530454, 0.5317537, 0.5330522, 0.53434944, 0.5356455, 0.53694016, 0.53823364, 0.53952587, 0.5408168, 0.54210645, 0.5433948, 0.5446819, 0.54596776, 0.5472523, 0.5485355, 0.5498175, 0.55109817, 0.5523775, 0.55365556, 0.55493236, 0.5562078, 0.55748194, 0.5587548, 0.5600263, 0.5612965, 0.5625654, 0.56383294, 0.5650992, 0.5663641, 0.56762767, 0.5688899, 0.5701508, 0.57141036, 0.57266855, 0.57392544, 0.57518095, 0.5764351, 0.5776879, 0.5789393, 0.5801894, 0.5814381, 0.5826855, 0.58393145, 0.58517605, 0.5864193, 0.58766115, 0.5889016, 0.5901407, 0.5913784, 0.59261465, 0.5938496, 0.59508306, 0.5963152, 0.59754586, 0.5987752, 0.60000306, 0.60122955, 0.6024546, 0.6036782, 0.6049005, 0.60612124, 0.60734063, 0.6085586, 0.60977507, 0.61099017, 0.6122038, 0.613416, 0.61462677, 0.6158361, 0.6170439, 0.6182503, 0.6194553, 0.62065876, 0.6218608, 0.62306136, 0.6242605, 0.6254581, 0.62665427, 0.627849, 0.6290422, 0.63023394, 0.6314242, 0.63261294, 0.6338002, 0.634986, 0.63617027, 0.63735306, 0.63853437, 0.6397142, 0.64089245, 0.6420692, 0.6432445, 0.64441824, 0.6455905, 0.6467612, 0.6479304, 0.64909804, 0.6502642, 0.6514288, 0.6525919, 0.6537534, 0.6549134, 0.6560719, 0.6572288, 0.6583842, 0.65953803, 0.6606903, 0.661841, 0.66299015, 0.6641378, 0.6652838, 0.66642827, 0.6675712, 0.6687125, 0.66985226, 0.67099047, 0.67212707, 0.67326206, 0.6743955, 0.6755274, 0.6766576, 0.6777863, 0.67891335, 0.68003887, 0.6811627, 0.682285, 0.6834057, 0.6845247, 0.6856422, 0.68675804, 0.68787223, 0.6889849, 0.69009584, 0.6912052, 0.6923129, 0.69341904, 0.6945235, 0.6956263, 0.6967275, 0.6978271, 0.698925, 0.70002127, 0.7011159, 0.7022089, 0.7033002, 0.70438987, 0.7054779, 0.70656425, 0.70764893, 0.70873195, 0.7098133, 0.710893, 0.711971, 0.7130473, 0.714122, 0.71519494, 0.7162663, 0.7173359, 0.7184038, 0.71947, 0.72053456, 0.72159743, 0.7226586, 0.723718, 0.72477573, 0.7258318, 0.7268861, 0.7279387, 0.7289896, 0.7300388, 0.7310863, 0.732132, 0.73317605, 0.73421836, 0.73525894, 0.7362978, 0.7373349, 0.7383703, 0.7394039, 0.74043584, 0.741466, 0.7424944, 0.7435211, 0.744546, 0.74556917, 0.74659055, 0.7476102, 0.7486281, 0.7496442, 0.75065863, 0.7516712, 0.75268203, 0.75369114, 0.7546984, 0.7557039, 0.75670767, 0.7577096, 0.7587098, 0.75970817, 0.76070476, 0.76169956, 0.7626926, 0.7636838, 0.76467323, 0.7656609, 0.7666467, 0.7676307, 0.7686129, 0.7695933, 0.7705719, 0.7715487, 0.77252364, 0.7734968, 0.7744681, 0.77543765, 0.77640533, 0.77737117, 0.7783352, 0.77929735, 0.78025776, 0.78121626, 0.7821729, 0.7831278, 0.7840808, 0.7850319, 0.78598124, 0.7869287, 0.78787434, 0.78881806, 0.78976, 0.7907, 0.7916382, 0.7925745, 0.79350895, 0.7944415, 0.79537225, 0.79630107, 0.79722804, 0.79815316, 0.7990764, 0.7999977, 0.80091715, 0.8018347, 0.8027504, 0.8036642, 0.8045761, 0.8054861, 0.8063942, 0.80730045, 0.8082047, 0.8091071, 0.81000763, 0.81090623, 0.811803, 0.81269777, 0.8135906, 0.81448156, 0.8153706, 0.8162577, 0.8171429, 0.8180262, 0.81890756, 0.81978697, 0.82066447, 0.82154006, 0.8224137, 0.8232854, 0.82415515, 0.825023, 0.8258889, 0.8267528, 0.8276148, 0.8284748, 0.82933295, 0.83018905, 0.83104324, 0.8318955, 0.8327458, 0.8335941, 0.8344404, 0.8352848, 0.8361273, 0.8369677, 0.8378062, 0.8386427, 0.83947724, 0.84030986, 0.84114045, 0.841969, 0.84279567, 0.8436203, 0.84444296, 0.84526366, 0.8460823, 0.84689903, 0.84771377, 0.8485265, 0.84933716, 0.8501459, 0.85095257, 0.8517573, 0.85256, 0.8533607, 0.8541594, 0.8549561, 0.85575074, 0.8565434, 0.857334, 0.85812265, 0.85890925, 0.8596939, 0.86047643, 0.86125696, 0.86203545, 0.8628119, 0.86358637, 0.8643588, 0.8651292, 0.86589754, 0.8666639, 0.8674281, 0.86819035, 0.86895055, 0.86970866, 0.8704648, 0.87121886, 0.87197083, 0.8727208, 0.8734687, 0.87421453, 0.8749583, 0.8757, 0.8764397, 0.87717724, 0.8779128, 0.87864625, 0.87937766, 0.880107, 0.8808343, 0.88155943, 0.88228256, 0.8830036, 0.88372254, 0.88443947, 0.88515425, 0.88586694, 0.8865776, 0.8872861, 0.88799256, 0.88869697, 0.88939923, 0.8900994, 0.8907975, 0.8914935, 0.8921874, 0.8928792, 0.8935689, 0.8942565, 0.894942, 0.89562535, 0.89630663, 0.89698577, 0.8976628, 0.8983378, 0.8990106, 0.8996813, 0.9003499, 0.9010164, 0.90168077, 0.902343, 0.9030031, 0.9036611, 0.90431696, 0.9049707, 0.9056223, 0.90627176, 0.9069191, 0.90756434, 0.90820736, 0.90884835, 0.9094871, 0.91012377, 0.91075826, 0.91139066, 0.91202086, 0.912649, 0.9132749, 0.91389865, 0.9145203, 0.9151398, 0.9157571, 0.9163723, 0.9169853, 0.91759616, 0.91820484, 0.9188114, 0.9194158, 0.92001796, 0.92061806, 0.9212159, 0.92181164, 0.9224052, 0.9229965, 0.9235858, 0.92417276, 0.9247576, 0.9253403, 0.9259208, 0.9264991, 0.92707527, 0.92764926, 0.928221, 0.9287906, 0.929358, 0.92992324, 0.93048626, 0.9310471, 0.93160576, 0.9321622, 0.9327165, 0.93326855, 0.93381846, 0.9343661, 0.9349116, 0.93545485, 0.93599594, 0.9365348, 0.9370715, 0.937606, 0.93813825, 0.9386683, 0.9391961, 0.93972176, 0.9402452, 0.9407664, 0.9412854, 0.9418022, 0.9423168, 0.9428291, 0.9433392, 0.9438471, 0.9443528, 0.9448563, 0.94535756, 0.9458566, 0.9463534, 0.9468479, 0.94734025, 0.9478304, 0.94831824, 0.9488039, 0.9492873, 0.9497685, 0.95024747, 0.9507241, 0.95119864, 0.9516709, 0.95214087, 0.9526086, 0.9530741, 0.9535374, 0.95399845, 0.9544572, 0.95491374, 0.95536804, 0.9558201, 0.95626986, 0.95671743, 0.9571627, 0.9576057, 0.9580465, 0.95848507, 0.9589213, 0.95935535, 0.95978713, 0.96021664, 0.9606439, 0.96106887, 0.9614916, 0.96191204, 0.9623302, 0.96274614, 0.9631598, 0.9635712, 0.9639804, 0.96438724, 0.96479183, 0.9651941, 0.9655942, 0.965992, 0.96638745, 0.9667807, 0.96717167, 0.96756035, 0.96794677, 0.96833086, 0.96871275, 0.9690923, 0.9694696, 0.9698446, 0.97021735, 0.9705878, 0.9709559, 0.9713218, 0.9716854, 0.97204673, 0.97240573, 0.97276247, 0.9731169, 0.973469, 0.9738189, 0.97416645, 0.97451174, 0.9748547, 0.9751954, 0.9755338, 0.9758699, 0.9762037, 0.9765352, 0.9768644, 0.9771913, 0.97751594, 0.9778382, 0.97815824, 0.9784759, 0.97879136, 0.97910446, 0.97941524, 0.97972375, 0.9800299, 0.9803338, 0.98063534, 0.9809346, 0.9812316, 0.98152626, 0.98181856, 0.9821086, 0.9823963, 0.9826817, 0.9829648, 0.9832456, 0.983524, 0.98380023, 0.98407406, 0.98434556, 0.9846148, 0.98488164, 0.9851462, 0.9854085, 0.9856684, 0.98592603, 0.9861813, 0.9864343, 0.9866849, 0.9869333, 0.9871793, 0.98742294, 0.98766434, 0.98790336, 0.9881401, 0.9883745, 0.9886065, 0.9888363, 0.9890637, 0.98928875, 0.9895115, 0.98973197, 0.98995006, 0.9901658, 0.9903792, 0.99059033, 0.9907991, 0.99100554, 0.9912097, 0.99141145, 0.9916109, 0.991808, 0.9920028, 0.99219525, 0.9923853, 0.99257314, 0.9927586, 0.9929417, 0.99312246, 0.99330086, 0.993477, 0.99365073, 0.99382216, 0.9939912, 0.99415797, 0.99432236, 0.9944844, 0.99464417, 0.9948015, 0.99495655, 0.99510926, 0.9952596, 0.99540764, 0.9955533, 0.9956966, 0.9958376, 0.99597627, 0.9961126, 0.9962465, 0.9963781, 0.9965074, 0.9966343, 0.9967589, 0.9968811, 0.997001, 0.99711853, 0.99723375, 0.9973466, 0.9974571, 0.9975652, 0.99767107, 0.9977745, 0.99787563, 0.9979744, 0.9980708, 0.99816483, 0.99825656, 0.9983459, 0.99843293, 0.99851763, 0.99859995, 0.99867994, 0.99875754, 0.9988328, 0.9989057, 0.9989763, 0.9990445, 0.99911034, 0.9991739, 0.99923503, 0.99929386, 0.9993503, 0.99940443, 0.99945617, 0.9995056, 0.99955267, 0.9995974, 0.9996397, 0.9996797, 0.99971735, 0.99975264, 0.9997856, 0.9998162, 0.99984443, 0.9998703, 0.99989384, 0.999915, 0.99993384, 0.9999503, 0.9999644, 0.99997616, 0.9999856, 0.99999267, 0.9999974, 0.9999997]);
    constructor.SINE_128 = new Float32Array([0.0061358847, 0.01840673, 0.030674804, 0.04293826, 0.055195246, 0.06744392, 0.07968244, 0.091908954, 0.10412163, 0.11631863, 0.1284981, 0.14065824, 0.15279719, 0.16491312, 0.17700422, 0.18906866, 0.20110464, 0.21311031, 0.22508392, 0.2370236, 0.24892761, 0.2607941, 0.27262136, 0.28440753, 0.2961509, 0.30784965, 0.31950203, 0.3311063, 0.34266073, 0.35416353, 0.36561298, 0.37700742, 0.38834503, 0.3996242, 0.41084316, 0.42200026, 0.43309382, 0.44412214, 0.45508358, 0.4659765, 0.47679922, 0.48755017, 0.49822766, 0.50883013, 0.519356, 0.52980363, 0.54017144, 0.55045795, 0.56066155, 0.57078075, 0.58081394, 0.5907597, 0.60061646, 0.6103828, 0.6200572, 0.62963825, 0.63912445, 0.6485144, 0.6578067, 0.66699994, 0.6760927, 0.6850837, 0.69397146, 0.70275474, 0.7114322, 0.72000253, 0.72846437, 0.7368166, 0.74505776, 0.7531868, 0.7612024, 0.76910335, 0.7768885, 0.78455657, 0.79210657, 0.79953724, 0.8068476, 0.8140363, 0.8211025, 0.82804507, 0.8348629, 0.841555, 0.84812033, 0.854558, 0.86086696, 0.86704624, 0.873095, 0.8790122, 0.8847971, 0.89044875, 0.89596623, 0.9013488, 0.9065957, 0.91170603, 0.9166791, 0.92151403, 0.9262102, 0.93076694, 0.9351835, 0.9394592, 0.94359344, 0.9475856, 0.951435, 0.9551412, 0.95870346, 0.9621214, 0.96539444, 0.9685221, 0.9715039, 0.97433937, 0.97702813, 0.9795698, 0.9819639, 0.9842101, 0.9863081, 0.9882576, 0.9900582, 0.99170977, 0.9932119, 0.9945646, 0.9957674, 0.9968203, 0.99772304, 0.99847555, 0.99907774, 0.9995294, 0.9998306, 0.99998116]);
    constructor.SINE_960 = new Float32Array([8.18123E-4, 0.0024543668, 0.004090604, 0.00572683, 0.0073630414, 0.008999232, 0.010635399, 0.012271538, 0.013907644, 0.015543712, 0.017179739, 0.01881572, 0.020451652, 0.022087527, 0.023723343, 0.025359096, 0.026994782, 0.028630394, 0.030265931, 0.031901386, 0.03353676, 0.035172038, 0.036807224, 0.03844231, 0.040077295, 0.041712172, 0.043346938, 0.044981588, 0.046616115, 0.04825052, 0.049884796, 0.051518936, 0.05315294, 0.0547868, 0.056420516, 0.05805408, 0.059687488, 0.061320737, 0.06295382, 0.064586736, 0.06621948, 0.06785204, 0.06948443, 0.071116626, 0.07274863, 0.07438044, 0.07601206, 0.07764347, 0.07927467, 0.08090566, 0.08253644, 0.08416699, 0.08579731, 0.08742741, 0.089057274, 0.090686895, 0.09231628, 0.093945414, 0.0955743, 0.09720293, 0.09883129, 0.1004594, 0.10208723, 0.10371479, 0.10534207, 0.10696907, 0.10859578, 0.110222206, 0.11184833, 0.11347417, 0.11509969, 0.11672491, 0.11834981, 0.1199744, 0.12159866, 0.123222604, 0.12484621, 0.1264695, 0.12809242, 0.12971503, 0.13133727, 0.13295917, 0.1345807, 0.13620189, 0.1378227, 0.13944314, 0.14106323, 0.14268291, 0.14430223, 0.14592116, 0.14753969, 0.14915784, 0.15077558, 0.15239291, 0.15400985, 0.15562636, 0.15724246, 0.15885815, 0.16047339, 0.16208823, 0.1637026, 0.16531657, 0.16693008, 0.16854315, 0.17015575, 0.1717679, 0.1733796, 0.17499083, 0.1766016, 0.1782119, 0.17982171, 0.18143104, 0.18303989, 0.18464825, 0.18625611, 0.18786347, 0.18947034, 0.19107668, 0.19268253, 0.19428785, 0.19589266, 0.19749694, 0.19910069, 0.20070392, 0.2023066, 0.20390874, 0.20551033, 0.20711137, 0.20871186, 0.2103118, 0.21191117, 0.21350996, 0.2151082, 0.21670584, 0.21830292, 0.21989942, 0.22149532, 0.22309062, 0.22468533, 0.22627944, 0.22787294, 0.22946583, 0.2310581, 0.23264977, 0.2342408, 0.23583122, 0.23742099, 0.23901014, 0.24059863, 0.24218649, 0.2437737, 0.24536026, 0.24694616, 0.2485314, 0.25011596, 0.25169986, 0.2532831, 0.25486565, 0.25644752, 0.25802872, 0.2596092, 0.261189, 0.2627681, 0.26434648, 0.2659242, 0.26750115, 0.26907742, 0.27065295, 0.27222776, 0.27380186, 0.2753752, 0.27694783, 0.2785197, 0.2800908, 0.28166118, 0.2832308, 0.2847997, 0.28636777, 0.2879351, 0.2895017, 0.29106748, 0.2926325, 0.29419672, 0.29576015, 0.2973228, 0.29888466, 0.3004457, 0.30200595, 0.30356538, 0.305124, 0.3066818, 0.3082388, 0.30979496, 0.31135032, 0.3129048, 0.31445846, 0.31601128, 0.31756327, 0.3191144, 0.32066464, 0.32221407, 0.32376263, 0.3253103, 0.3268571, 0.32840303, 0.3299481, 0.33149227, 0.33303556, 0.33457795, 0.33611944, 0.33766004, 0.33919972, 0.3407385, 0.3422764, 0.34381336, 0.34534937, 0.3468845, 0.34841868, 0.34995192, 0.35148424, 0.3530156, 0.35454604, 0.35607553, 0.35760406, 0.3591316, 0.36065823, 0.36218387, 0.36370853, 0.36523223, 0.36675495, 0.3682767, 0.36979744, 0.3713172, 0.37283596, 0.37435374, 0.3758705, 0.37738624, 0.378901, 0.38041475, 0.38192746, 0.38343915, 0.38494983, 0.38645947, 0.38796806, 0.3894756, 0.39098215, 0.39248762, 0.39399204, 0.3954954, 0.39699772, 0.39849895, 0.39999914, 0.40149826, 0.4029963, 0.40449324, 0.4059891, 0.4074839, 0.4089776, 0.4104702, 0.4119617, 0.4134521, 0.41494137, 0.41642955, 0.41791663, 0.41940257, 0.42088738, 0.4223711, 0.42385367, 0.42533508, 0.4268154, 0.42829454, 0.42977253, 0.43124938, 0.43272507, 0.4341996, 0.435673, 0.4371452, 0.43861625, 0.4400861, 0.44155478, 0.44302228, 0.4444886, 0.44595373, 0.44741768, 0.4488804, 0.45034194, 0.45180228, 0.4532614, 0.4547193, 0.45617598, 0.45763147, 0.4590857, 0.46053872, 0.4619905, 0.46344104, 0.46489033, 0.4663384, 0.4677852, 0.46923077, 0.47067505, 0.4721181, 0.4735599, 0.47500038, 0.47643963, 0.4778776, 0.47931427, 0.48074967, 0.48218378, 0.4836166, 0.48504812, 0.48647836, 0.48790726, 0.48933488, 0.4907612, 0.4921862, 0.49360988, 0.49503222, 0.49645326, 0.49787295, 0.49929133, 0.50070834, 0.502124, 0.50353837, 0.50495136, 0.50636303, 0.50777334, 0.5091823, 0.51058984, 0.51199603, 0.51340085, 0.5148043, 0.5162064, 0.5176071, 0.5190064, 0.5204043, 0.5218008, 0.523196, 0.52458966, 0.525982, 0.5273729, 0.5287624, 0.53015053, 0.5315372, 0.53292245, 0.5343062, 0.53568864, 0.5370696, 0.5384491, 0.53982717, 0.5412038, 0.542579, 0.5439527, 0.545325, 0.5466958, 0.5480651, 0.54943305, 0.5507994, 0.5521644, 0.55352783, 0.5548898, 0.5562503, 0.5576093, 0.5589668, 0.5603228, 0.56167734, 0.5630303, 0.56438184, 0.5657318, 0.56708026, 0.56842726, 0.56977266, 0.57111657, 0.572459, 0.5737998, 0.5751391, 0.5764769, 0.5778131, 0.5791478, 0.58048093, 0.5818125, 0.5831425, 0.584471, 0.58579785, 0.58712316, 0.5884469, 0.5897691, 0.5910897, 0.5924087, 0.59372616, 0.595042, 0.5963562, 0.5976689, 0.59897995, 0.60028934, 0.6015972, 0.6029034, 0.60420805, 0.60551107, 0.6068124, 0.60811216, 0.6094103, 0.61070675, 0.61200166, 0.61329484, 0.6145864, 0.6158764, 0.6171646, 0.61845124, 0.61973625, 0.62101954, 0.62230116, 0.6235812, 0.6248595, 0.6261361, 0.62741107, 0.6286844, 0.629956, 0.6312259, 0.63249415, 0.63376063, 0.6350255, 0.63628864, 0.63755006, 0.6388098, 0.6400678, 0.6413241, 0.64257866, 0.64383155, 0.6450827, 0.6463321, 0.6475798, 0.6488257, 0.65006995, 0.6513124, 0.65255314, 0.65379214, 0.65502936, 0.65626484, 0.65749854, 0.6587305, 0.6599607, 0.66118914, 0.6624158, 0.6636407, 0.66486377, 0.6660851, 0.66730464, 0.6685224, 0.66973835, 0.67095256, 0.6721649, 0.6733755, 0.67458427, 0.67579126, 0.6769964, 0.67819977, 0.6794013, 0.680601, 0.6817989, 0.68299496, 0.6841892, 0.6853816, 0.6865722, 0.6877609, 0.6889478, 0.69013286, 0.691316, 0.6924974, 0.6936769, 0.6948545, 0.6960303, 0.69720423, 0.69837624, 0.6995464, 0.7007147, 0.7018812, 0.7030457, 0.7042084, 0.7053692, 0.70652807, 0.70768505, 0.70884013, 0.70999336, 0.7111447, 0.71229404, 0.71344155, 0.71458715, 0.71573085, 0.7168726, 0.7180124, 0.71915036, 0.7202863, 0.7214204, 0.72255254, 0.7236827, 0.72481096, 0.7259373, 0.7270617, 0.7281841, 0.72930455, 0.7304231, 0.73153967, 0.7326543, 0.7337669, 0.7348776, 0.73598635, 0.7370931, 0.73819786, 0.73930067, 0.74040145, 0.7415003, 0.74259716, 0.743692, 0.7447849, 0.7458758, 0.74696463, 0.7480515, 0.7491364, 0.7502193, 0.75130016, 0.752379, 0.7534558, 0.75453067, 0.75560343, 0.75667423, 0.75774294, 0.7588097, 0.7598744, 0.76093704, 0.76199764, 0.7630562, 0.7641128, 0.76516724, 0.76621974, 0.7672701, 0.7683184, 0.7693647, 0.7704089, 0.7714511, 0.77249116, 0.77352923, 0.77456516, 0.77559906, 0.7766308, 0.77766055, 0.7786882, 0.77971375, 0.7807372, 0.7817586, 0.7827779, 0.78379506, 0.7848102, 0.78582317, 0.78683406, 0.7878428, 0.7888495, 0.78985405, 0.7908565, 0.7918568, 0.792855, 0.79385114, 0.7948451, 0.7958369, 0.7968266, 0.7978142, 0.7987996, 0.7997829, 0.800764, 0.80174303, 0.8027199, 0.8036946, 0.8046672, 0.8056376, 0.8066058, 0.8075719, 0.8085358, 0.8094976, 0.81045717, 0.8114146, 0.8123699, 0.81332296, 0.81427383, 0.81522256, 0.8161691, 0.81711346, 0.8180556, 0.8189956, 0.81993335, 0.82086897, 0.8218024, 0.8227335, 0.8236625, 0.8245893, 0.8255139, 0.8264362, 0.8273564, 0.8282743, 0.82919, 0.8301035, 0.8310148, 0.83192384, 0.83283067, 0.8337353, 0.83463764, 0.83553773, 0.8364357, 0.8373313, 0.8382247, 0.83911586, 0.8400048, 0.8408915, 0.8417759, 0.84265804, 0.8435379, 0.8444156, 0.84529096, 0.8461641, 0.84703493, 0.84790355, 0.84876984, 0.84963393, 0.8504957, 0.8513552, 0.8522124, 0.85306734, 0.85392, 0.85477036, 0.8556184, 0.8564642, 0.85730773, 0.85814893, 0.8589878, 0.8598244, 0.8606587, 0.8614907, 0.8623204, 0.8631478, 0.86397284, 0.8647956, 0.865616, 0.86643416, 0.86724997, 0.86806345, 0.8688746, 0.86968344, 0.87048995, 0.87129414, 0.87209594, 0.8728955, 0.87369263, 0.87448746, 0.87527996, 0.8760701, 0.8768579, 0.87764335, 0.87842643, 0.8792072, 0.8799856, 0.8807616, 0.8815353, 0.88230664, 0.8830756, 0.8838422, 0.8846064, 0.8853683, 0.88612777, 0.88688487, 0.88763964, 0.888392, 0.889142, 0.8898896, 0.89063483, 0.8913776, 0.8921181, 0.8928562, 0.8935918, 0.89432514, 0.895056, 0.8957845, 0.8965106, 0.89723426, 0.8979556, 0.8986745, 0.89939094, 0.900105, 0.9008167, 0.9015259, 0.90223277, 0.9029372, 0.9036392, 0.9043388, 0.905036, 0.90573066, 0.90642303, 0.9071129, 0.9078004, 0.9084854, 0.909168, 0.90984815, 0.91052586, 0.9112012, 0.911874, 0.9125444, 0.9132124, 0.9138779, 0.914541, 0.9152016, 0.9158598, 0.9165155, 0.9171688, 0.9178196, 0.91846794, 0.9191139, 0.9197573, 0.92039824, 0.9210368, 0.9216728, 0.9223064, 0.9229375, 0.92356616, 0.9241923, 0.924816, 0.9254372, 0.92605597, 0.9266722, 0.92728597, 0.9278973, 0.9285061, 0.9291124, 0.9297162, 0.9303176, 0.9309164, 0.93151283, 0.9321067, 0.9326981, 0.9332869, 0.9338733, 0.9344572, 0.93503857, 0.93561745, 0.9361938, 0.93676764, 0.937339, 0.9379079, 0.9384742, 0.939038, 0.93959934, 0.9401581, 0.94071436, 0.94126815, 0.94181937, 0.9423681, 0.94291425, 0.94345796, 0.94399905, 0.9445377, 0.9450738, 0.9456073, 0.9461383, 0.94666684, 0.9471928, 0.94771624, 0.94823706, 0.94875544, 0.94927126, 0.9497845, 0.9502952, 0.9508034, 0.951309, 0.9518121, 0.95231265, 0.9528106, 0.953306, 0.95379895, 0.95428926, 0.954777, 0.95526224, 0.95574486, 0.956225, 0.95670253, 0.9571775, 0.95764995, 0.95811975, 0.95858705, 0.9590518, 0.9595139, 0.9599735, 0.9604305, 0.960885, 0.96133685, 0.96178615, 0.9622328, 0.962677, 0.96311855, 0.96355754, 0.96399397, 0.96442777, 0.964859, 0.9652877, 0.96571374, 0.96613723, 0.96655816, 0.96697646, 0.9673922, 0.9678053, 0.9682159, 0.9686238, 0.9690292, 0.969432, 0.9698321, 0.97022974, 0.9706247, 0.97101706, 0.9714069, 0.971794, 0.9721786, 0.9725606, 0.97293997, 0.9733167, 0.97369087, 0.97406244, 0.9744314, 0.9747977, 0.97516143, 0.9755226, 0.97588104, 0.97623694, 0.9765902, 0.9769409, 0.97728896, 0.9776344, 0.97797716, 0.9783174, 0.9786549, 0.9789899, 0.97932225, 0.9796519, 0.97997904, 0.9803035, 0.98062533, 0.9809446, 0.98126113, 0.98157513, 0.98188645, 0.98219514, 0.9825012, 0.98280466, 0.9831055, 0.9834037, 0.9836992, 0.98399216, 0.98428243, 0.9845701, 0.98485506, 0.98513746, 0.9854172, 0.9856943, 0.9859687, 0.98624057, 0.98650974, 0.9867763, 0.98704016, 0.9873014, 0.98756003, 0.987816, 0.9880693, 0.98832, 0.988568, 0.9888134, 0.9890561, 0.9892962, 0.98953366, 0.98976845, 0.9900006, 0.9902301, 0.99045694, 0.9906811, 0.99090266, 0.99112153, 0.9913377, 0.99155134, 0.9917622, 0.9919705, 0.9921761, 0.99237907, 0.99257934, 0.992777, 0.99297196, 0.9931643, 0.99335396, 0.99354094, 0.9937253, 0.993907, 0.99408597, 0.99426234, 0.994436, 0.9946071, 0.9947755, 0.9949412, 0.9951042, 0.9952646, 0.9954223, 0.99557734, 0.99572974, 0.9958795, 0.9960265, 0.9961709, 0.9963126, 0.9964517, 0.99658805, 0.99672174, 0.9968528, 0.9969812, 0.9971069, 0.99722993, 0.99735034, 0.997468, 0.99758303, 0.9976954, 0.99780506, 0.9979121, 0.9980164, 0.9981181, 0.9982171, 0.9983134, 0.99840707, 0.9984981, 0.99858636, 0.998672, 0.998755, 0.99883527, 0.9989129, 0.9989878, 0.9990601, 0.99912965, 0.9991966, 0.99926084, 0.99932235, 0.99938124, 0.9994375, 0.99949104, 0.9995419, 0.99959004, 0.9996356, 0.99967843, 0.99971855, 0.99975604, 0.99979085, 0.999823, 0.9998524, 0.9998792, 0.99990326, 0.9999247, 0.99994344, 0.9999595, 0.9999729, 0.9999836, 0.99999166, 0.99999696, 0.99999964]);
    constructor.SINE_120 = new Float32Array([0.006544938, 0.019633692, 0.032719083, 0.045798868, 0.058870804, 0.07193265, 0.08498218, 0.09801714, 0.11103531, 0.12403445, 0.13701235, 0.14996676, 0.16289547, 0.17579629, 0.18866697, 0.20150532, 0.21430916, 0.22707626, 0.23980446, 0.25249156, 0.26513544, 0.27773383, 0.29028466, 0.30278578, 0.315235, 0.3276302, 0.33996925, 0.35225004, 0.3644705, 0.3766285, 0.38872197, 0.40074882, 0.41270703, 0.42459452, 0.43640924, 0.4481492, 0.45981237, 0.47139674, 0.48290035, 0.4943212, 0.5056574, 0.5169069, 0.5280678, 0.5391383, 0.5501164, 0.5610002, 0.57178795, 0.5824777, 0.59306765, 0.6035559, 0.61394083, 0.62422055, 0.6343933, 0.64445734, 0.65441096, 0.66425246, 0.6739801, 0.6835923, 0.69308734, 0.7024637, 0.71171963, 0.72085357, 0.72986406, 0.7387495, 0.74750835, 0.7561391, 0.7646403, 0.77301043, 0.78124815, 0.78935206, 0.79732066, 0.80515265, 0.81284666, 0.82040143, 0.82781565, 0.83508795, 0.8422172, 0.84920216, 0.8560416, 0.8627344, 0.8692793, 0.8756753, 0.8819213, 0.8880161, 0.8939588, 0.89974827, 0.90538365, 0.9108638, 0.91618794, 0.9213551, 0.92636436, 0.9312149, 0.93590593, 0.94043654, 0.94480604, 0.94901365, 0.95305866, 0.95694035, 0.9606581, 0.96421117, 0.9675991, 0.9708212, 0.97387695, 0.9767659, 0.9794874, 0.9820411, 0.98442656, 0.9866433, 0.98869103, 0.99056935, 0.9922779, 0.99381644, 0.9951847, 0.9963825, 0.99740946, 0.9982656, 0.99895066, 0.9994646, 0.99980724, 0.9999786]);
}, {SINE_1024: "Float32Array", SINE_128: "Float32Array", SINE_960: "Float32Array", SINE_120: "Float32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var BitsBuffer = function() {
    this.len = 0;
};
BitsBuffer = stjs.extend(BitsBuffer, null, [], function(constructor, prototype) {
    prototype.bufa = 0;
    prototype.bufb = 0;
    prototype.len = 0;
    constructor.S = new Int32Array([1, 2, 4, 8, 16]);
    constructor.B = new Int32Array([1431655765, 858993459, 252645135, 16711935, 65535]);
    prototype.getLength = function() {
        return this.len;
    };
    prototype.showBits = function(bits) {
        if (bits == 0) 
            return 0;
        if (this.len <= 32) {
            if (this.len >= bits) 
                return ((this.bufa >> (this.len - bits)) & (-1 >> (32 - bits)));
             else 
                return ((this.bufa << (bits - this.len)) & (-1 >> (32 - bits)));
        } else {
            if ((this.len - bits) < 32) 
                return ((this.bufb & (-1 >> (64 - this.len))) << (bits - this.len + 32)) | (this.bufa >> (this.len - bits));
             else 
                return ((this.bufb >> (this.len - bits - 32)) & (-1 >> (32 - bits)));
        }
    };
    prototype.flushBits = function(bits) {
        this.len -= bits;
        var b;
        if (this.len < 0) {
            this.len = 0;
            b = false;
        } else 
            b = true;
        return b;
    };
    prototype.getBits = function(n) {
        var i = this.showBits(n);
        if (!this.flushBits(n)) 
            i = -1;
        return i;
    };
    prototype.getBit = function() {
        var i = this.showBits(1);
        if (!this.flushBits(1)) 
            i = -1;
        return i;
    };
    prototype.rewindReverse = function() {
        if (this.len == 0) 
            return;
        var i = BitsBuffer.rewindReverse64(this.bufb, this.bufa, this.len);
        this.bufb = i[0];
        this.bufa = i[1];
    };
    prototype.concatBits = function(a) {
        if (a.len == 0) 
            return;
        var al = a.bufa;
        var ah = a.bufb;
        var bl, bh;
        if (this.len > 32) {
            bl = this.bufa;
            bh = this.bufb & ((1 << (this.len - 32)) - 1);
            ah = al << (this.len - 32);
            al = 0;
        } else {
            bl = this.bufa & ((1 << (this.len)) - 1);
            bh = 0;
            ah = (ah << (this.len)) | (al >> (32 - this.len));
            al = al << this.len;
        }
        this.bufa = bl | al;
        this.bufb = bh | ah;
        this.len += a.len;
    };
    prototype.readSegment = function(segwidth, _in) {
        this.len = segwidth;
        if (segwidth > 32) {
            this.bufb = _in.readBits(segwidth - 32);
            this.bufa = _in.readBits(32);
        } else {
            this.bufa = _in.readBits(segwidth);
            this.bufb = 0;
        }
    };
    constructor.rewindReverse32 = function(v, len) {
        v = ((v >> BitsBuffer.S[0]) & BitsBuffer.B[0]) | ((v << BitsBuffer.S[0]) & ~BitsBuffer.B[0]);
        v = ((v >> BitsBuffer.S[1]) & BitsBuffer.B[1]) | ((v << BitsBuffer.S[1]) & ~BitsBuffer.B[1]);
        v = ((v >> BitsBuffer.S[2]) & BitsBuffer.B[2]) | ((v << BitsBuffer.S[2]) & ~BitsBuffer.B[2]);
        v = ((v >> BitsBuffer.S[3]) & BitsBuffer.B[3]) | ((v << BitsBuffer.S[3]) & ~BitsBuffer.B[3]);
        v = ((v >> BitsBuffer.S[4]) & BitsBuffer.B[4]) | ((v << BitsBuffer.S[4]) & ~BitsBuffer.B[4]);
        v >>= (32 - len);
        return v;
    };
    constructor.rewindReverse64 = function(hi, lo, len) {
        var i = new Int32Array(2);
        if (len <= 32) {
            i[0] = 0;
            i[1] = BitsBuffer.rewindReverse32(lo, len);
        } else {
            lo = ((lo >> BitsBuffer.S[0]) & BitsBuffer.B[0]) | ((lo << BitsBuffer.S[0]) & ~BitsBuffer.B[0]);
            hi = ((hi >> BitsBuffer.S[0]) & BitsBuffer.B[0]) | ((hi << BitsBuffer.S[0]) & ~BitsBuffer.B[0]);
            lo = ((lo >> BitsBuffer.S[1]) & BitsBuffer.B[1]) | ((lo << BitsBuffer.S[1]) & ~BitsBuffer.B[1]);
            hi = ((hi >> BitsBuffer.S[1]) & BitsBuffer.B[1]) | ((hi << BitsBuffer.S[1]) & ~BitsBuffer.B[1]);
            lo = ((lo >> BitsBuffer.S[2]) & BitsBuffer.B[2]) | ((lo << BitsBuffer.S[2]) & ~BitsBuffer.B[2]);
            hi = ((hi >> BitsBuffer.S[2]) & BitsBuffer.B[2]) | ((hi << BitsBuffer.S[2]) & ~BitsBuffer.B[2]);
            lo = ((lo >> BitsBuffer.S[3]) & BitsBuffer.B[3]) | ((lo << BitsBuffer.S[3]) & ~BitsBuffer.B[3]);
            hi = ((hi >> BitsBuffer.S[3]) & BitsBuffer.B[3]) | ((hi << BitsBuffer.S[3]) & ~BitsBuffer.B[3]);
            lo = ((lo >> BitsBuffer.S[4]) & BitsBuffer.B[4]) | ((lo << BitsBuffer.S[4]) & ~BitsBuffer.B[4]);
            hi = ((hi >> BitsBuffer.S[4]) & BitsBuffer.B[4]) | ((hi << BitsBuffer.S[4]) & ~BitsBuffer.B[4]);
            i[1] = (hi >> (64 - len)) | (lo << (len - 32));
            i[1] = lo >> (64 - len);
        }
        return i;
    };
}, {S: "Int32Array", B: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A helper class that builds macroblock to slice group maps needed by ASO
 *  (Arbitrary Slice Order)
 *  
 *  @author The JCodec project
 *  
 */
var SliceGroupMapBuilder = function() {};
SliceGroupMapBuilder = stjs.extend(SliceGroupMapBuilder, null, [], function(constructor, prototype) {
    /**
     *  
     *  Interleaved slice group map. Each slice group fills a number of cells
     *  equal to the appropriate run length, then followed by the next slice
     *  group.
     *  
     *  Example:
     *  
     *  1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1,
     *  
     */
    constructor.buildInterleavedMap = function(picWidthInMbs, picHeightInMbs, runLength) {
        var numSliceGroups = runLength.length;
        var picSizeInMbs = picWidthInMbs * picHeightInMbs;
        var groups = new Int32Array(picSizeInMbs);
        var i = 0;
        do {
            for (var iGroup = 0; iGroup < numSliceGroups && i < picSizeInMbs; i += runLength[iGroup++]) {
                for (var j = 0; j < runLength[iGroup] && i + j < picSizeInMbs; j++) {
                    groups[i + j] = iGroup;
                }
            }
        } while (i < picSizeInMbs);
        return groups;
    };
    /**
     *  A dispersed map. Every odd line starts from the (N / 2)th group
     *  
     *  Example:
     *  
     *  0, 1, 2, 3, 0, 1, 2, 3 2, 3, 0, 1, 2, 3, 0, 1 0, 1, 2, 3, 0, 1, 2, 3 2,
     *  3, 0, 1, 2, 3, 0, 1 0, 1, 2, 3, 0, 1, 2, 3 2, 3, 0, 1, 2, 3, 0, 1 0, 1,
     *  2, 3, 0, 1, 2, 3 2, 3, 0, 1, 2, 3, 0, 1 0, 1, 2, 3, 0, 1, 2, 3 2, 3, 0,
     *  1, 2, 3, 0, 1
     *  
     */
    constructor.buildDispersedMap = function(picWidthInMbs, picHeightInMbs, numSliceGroups) {
        var picSizeInMbs = picWidthInMbs * picHeightInMbs;
        var groups = new Int32Array(picSizeInMbs);
        for (var i = 0; i < picSizeInMbs; i++) {
            var group = ((i % picWidthInMbs) + (stjs.trunc(((stjs.trunc(i / picWidthInMbs)) * numSliceGroups) / 2))) % numSliceGroups;
            groups[i] = group;
        }
        return groups;
    };
    /**
     *  
     *  A foreground macroblock to slice group map. Macroblocks of the last slice
     *  group are the background, all the others represent rectangles covering
     *  areas with top-left corner specified by topLeftAddr[group] and bottom
     *  right corner specified by bottomRightAddr[group].
     *  
     *  @param picWidthInMbs
     *  @param picHeightInMbs
     *  @param numSliceGroups
     *             Total number of slice groups
     *  @param topLeftAddr
     *             Addresses of macroblocks that are top-left corners of
     *             respective slice groups
     *  @param bottomRightAddr
     *             Addresses macroblocks that are bottom-right corners of
     *             respective slice groups
     *  @return
     */
    constructor.buildForegroundMap = function(picWidthInMbs, picHeightInMbs, numSliceGroups, topLeftAddr, bottomRightAddr) {
        var picSizeInMbs = picWidthInMbs * picHeightInMbs;
        var groups = new Int32Array(picSizeInMbs);
        for (var i = 0; i < picSizeInMbs; i++) 
            groups[i] = numSliceGroups - 1;
        var tot = 0;
        for (var iGroup = numSliceGroups - 2; iGroup >= 0; iGroup--) {
            var yTopLeft = stjs.trunc(topLeftAddr[iGroup] / picWidthInMbs);
            var xTopLeft = topLeftAddr[iGroup] % picWidthInMbs;
            var yBottomRight = stjs.trunc(bottomRightAddr[iGroup] / picWidthInMbs);
            var xBottomRight = bottomRightAddr[iGroup] % picWidthInMbs;
            var sz = (yBottomRight - yTopLeft + 1) * (xBottomRight - xTopLeft + 1);
            tot += sz;
            var ind = 0;
            for (var y = yTopLeft; y <= yBottomRight; y++) 
                for (var x = xTopLeft; x <= xBottomRight; x++) {
                    var mbAddr = y * picWidthInMbs + x;
                    groups[mbAddr] = iGroup;
                }
        }
        return groups;
    };
    /**
     *  A boxout macroblock to slice group mapping. Only applicable when there's
     *  exactly 2 slice groups. Slice group 1 is a background, while slice group
     *  0 is a box in the middle of the frame.
     *  
     *  @param picWidthInMbs
     *  @param picHeightInMbs
     *  @param changeDirection
     *  @param numberOfMbsInBox
     *             number of macroblocks in slice group 0
     *  @return
     */
    constructor.buildBoxOutMap = function(picWidthInMbs, picHeightInMbs, changeDirection, numberOfMbsInBox) {
        var picSizeInMbs = picWidthInMbs * picHeightInMbs;
        var groups = new Int32Array(picSizeInMbs);
        var changeDirectionInt = changeDirection ? 1 : 0;
        for (var i = 0; i < picSizeInMbs; i++) 
            groups[i] = 1;
        var x = stjs.trunc((picWidthInMbs - changeDirectionInt) / 2);
        var y = stjs.trunc((picHeightInMbs - changeDirectionInt) / 2);
        var leftBound = x;
        var topBound = y;
        var rightBound = x;
        var bottomBound = y;
        var xDir = changeDirectionInt - 1;
        var yDir = changeDirectionInt;
        var mapUnitVacant = false;
        for (var k = 0; k < numberOfMbsInBox; k += (mapUnitVacant ? 1 : 0)) {
            var mbAddr = y * picWidthInMbs + x;
            mapUnitVacant = (groups[mbAddr] == 1);
            if (mapUnitVacant) {
                groups[mbAddr] = 0;
            }
            if (xDir == -1 && x == leftBound) {
                leftBound = SliceGroupMapBuilder.Max(leftBound - 1, 0);
                x = leftBound;
                xDir = 0;
                yDir = 2 * changeDirectionInt - 1;
            } else if (xDir == 1 && x == rightBound) {
                rightBound = SliceGroupMapBuilder.Min(rightBound + 1, picWidthInMbs - 1);
                x = rightBound;
                xDir = 0;
                yDir = 1 - 2 * changeDirectionInt;
            } else if (yDir == -1 && y == topBound) {
                topBound = SliceGroupMapBuilder.Max(topBound - 1, 0);
                y = topBound;
                xDir = 1 - 2 * changeDirectionInt;
                yDir = 0;
            } else if (yDir == 1 && y == bottomBound) {
                bottomBound = SliceGroupMapBuilder.Min(bottomBound + 1, picHeightInMbs - 1);
                y = bottomBound;
                xDir = 2 * changeDirectionInt - 1;
                yDir = 0;
            } else {
                x += xDir;
                y += yDir;
            }
        }
        return groups;
    };
    constructor.Min = function(i, j) {
        return i < j ? i : j;
    };
    constructor.Max = function(i, j) {
        return i > j ? i : j;
    };
    /**
     *  
     *  A macroblock to slice group map that fills frame in raster scan.
     *  
     *  @param picWidthInMbs
     *  @param picHeightInMbs
     *  @param sizeOfUpperLeftGroup
     *  @param changeDirection
     *  @return
     */
    constructor.buildRasterScanMap = function(picWidthInMbs, picHeightInMbs, sizeOfUpperLeftGroup, changeDirection) {
        var picSizeInMbs = picWidthInMbs * picHeightInMbs;
        var groups = new Int32Array(picSizeInMbs);
        var changeDirectionInt = changeDirection ? 1 : 0;
        var i;
        for (i = 0; i < sizeOfUpperLeftGroup; i++) {
            groups[i] = changeDirectionInt;
        }
        for (; i < picSizeInMbs; i++) {
            groups[i] = 1 - changeDirectionInt;
        }
        return groups;
    };
    /**
     *  A macroblock to slice group map that fills frame column by column
     *  
     *  @param picWidthInMbs
     *  @param picHeightInMbs
     *  @param sizeOfUpperLeftGroup
     *  @param changeDirection
     *  @return
     */
    constructor.buildWipeMap = function(picWidthInMbs, picHeightInMbs, sizeOfUpperLeftGroup, changeDirection) {
        var picSizeInMbs = picWidthInMbs * picHeightInMbs;
        var groups = new Int32Array(picSizeInMbs);
        var changeDirectionInt = changeDirection ? 1 : 0;
        var k = 0;
        for (var j = 0; j < picWidthInMbs; j++) {
            for (var i = 0; i < picHeightInMbs; i++) {
                var mbAddr = i * picWidthInMbs + j;
                if (k++ < sizeOfUpperLeftGroup) {
                    groups[mbAddr] = changeDirectionInt;
                } else {
                    groups[mbAddr] = 1 - changeDirectionInt;
                }
            }
        }
        return groups;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Functions to work with long storing up to two complete 31-bit motion vectors
 *  with the number of vectors stored.
 *  
 *  @author The JCodec project
 *  
 */
var MVList = function() {};
MVList = stjs.extend(MVList, null, [], function(constructor, prototype) {
    constructor.LO_MASK = 2147483647;
    constructor.HI_MASK = MVList.LO_MASK << 31;
    constructor.HI_MASK_NEG = ~(MVList.HI_MASK | (3 << 62));
    constructor.LO_MASK_NEG = ~(MVList.LO_MASK | (3 << 62));
    constructor.create = function(mv0, mv1) {
        return (stjs.trunc(2) << 62) | (stjs.trunc(mv1) << 31) | (mv0 & MVList.LO_MASK);
    };
    constructor.addUniq = function(list, mv) {
        var cnt = (list >> 62) & 3;
        if (cnt == 2) 
            return list;
        if (cnt == 0) {
            return (stjs.trunc(1) << 62) | (list & MVList.LO_MASK_NEG) | (mv & MVList.LO_MASK);
        } else {
            var first = (((list & MVList.LO_MASK)) | 0);
            if (first != mv) 
                return (stjs.trunc(2) << 62) | (list & MVList.HI_MASK_NEG) | ((stjs.trunc(mv) << 31) & MVList.HI_MASK);
             else 
                return list;
        }
    };
    constructor.add = function(list, mv) {
        var cnt = (list >> 62) & 3;
        if (cnt == 2) 
            return list;
        if (cnt == 0) {
            return (stjs.trunc(1) << 62) | (list & MVList.LO_MASK_NEG) | (mv & MVList.LO_MASK);
        } else {
            return (stjs.trunc(2) << 62) | (list & MVList.HI_MASK_NEG) | ((stjs.trunc(mv) << 31) & MVList.HI_MASK);
        }
    };
    constructor.get = function(list, n) {
        if (n == 0) 
            return (((list & MVList.LO_MASK)) | 0);
         else 
            return ((((list >> 31) & MVList.LO_MASK)) | 0);
    };
    constructor.set = function(list, n, mv) {
        var cnt = (list >> 62) & 3;
        var newc = n + 1;
        cnt = newc > cnt ? newc : cnt;
        if (n == 0) {
            return (cnt << 62) | (list & MVList.LO_MASK_NEG) | (mv & MVList.LO_MASK);
        } else {
            return (cnt << 62) | (list & MVList.HI_MASK_NEG) | ((stjs.trunc(mv) << 31) & MVList.HI_MASK);
        }
    };
    constructor.size = function(list) {
        return ((((list >> 62) & 3)) | 0);
    };
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var RVLCTables = function() {};
RVLCTables = stjs.extend(RVLCTables, null, [], function(constructor, prototype) {
    constructor.RVLC_BOOK = [new Int32Array([0, 1, 0]), new Int32Array([-1, 3, 5]), new Int32Array([1, 3, 7]), new Int32Array([-2, 4, 9]), new Int32Array([-3, 5, 17]), new Int32Array([2, 5, 27]), new Int32Array([-4, 6, 33]), new Int32Array([99, 6, 50]), new Int32Array([3, 6, 51]), new Int32Array([99, 6, 52]), new Int32Array([-7, 7, 65]), new Int32Array([99, 7, 96]), new Int32Array([99, 7, 98]), new Int32Array([7, 7, 99]), new Int32Array([4, 7, 107]), new Int32Array([-5, 8, 129]), new Int32Array([99, 8, 194]), new Int32Array([5, 8, 195]), new Int32Array([99, 8, 212]), new Int32Array([99, 9, 256]), new Int32Array([-6, 9, 257]), new Int32Array([99, 9, 426]), new Int32Array([6, 9, 427]), new Int32Array([99, 10, 0])];
    constructor.ESCAPE_BOOK = [new Int32Array([1, 2, 0]), new Int32Array([0, 2, 2]), new Int32Array([3, 3, 2]), new Int32Array([2, 3, 6]), new Int32Array([4, 4, 14]), new Int32Array([7, 5, 13]), new Int32Array([6, 5, 15]), new Int32Array([5, 5, 31]), new Int32Array([11, 6, 24]), new Int32Array([10, 6, 25]), new Int32Array([9, 6, 29]), new Int32Array([8, 6, 61]), new Int32Array([13, 7, 56]), new Int32Array([12, 7, 120]), new Int32Array([15, 8, 114]), new Int32Array([14, 8, 242]), new Int32Array([17, 9, 230]), new Int32Array([16, 9, 486]), new Int32Array([19, 10, 463]), new Int32Array([18, 10, 974]), new Int32Array([22, 11, 925]), new Int32Array([20, 11, 1950]), new Int32Array([21, 11, 1951]), new Int32Array([23, 12, 1848]), new Int32Array([25, 13, 3698]), new Int32Array([24, 14, 7399]), new Int32Array([26, 15, 14797]), new Int32Array([49, 19, 236736]), new Int32Array([50, 19, 236737]), new Int32Array([51, 19, 236738]), new Int32Array([52, 19, 236739]), new Int32Array([53, 19, 236740]), new Int32Array([27, 20, 473482]), new Int32Array([28, 20, 473483]), new Int32Array([29, 20, 473484]), new Int32Array([30, 20, 473485]), new Int32Array([31, 20, 473486]), new Int32Array([32, 20, 473487]), new Int32Array([33, 20, 473488]), new Int32Array([34, 20, 473489]), new Int32Array([35, 20, 473490]), new Int32Array([36, 20, 473491]), new Int32Array([37, 20, 473492]), new Int32Array([38, 20, 473493]), new Int32Array([39, 20, 473494]), new Int32Array([40, 20, 473495]), new Int32Array([41, 20, 473496]), new Int32Array([42, 20, 473497]), new Int32Array([43, 20, 473498]), new Int32Array([44, 20, 473499]), new Int32Array([45, 20, 473500]), new Int32Array([46, 20, 473501]), new Int32Array([47, 20, 473502]), new Int32Array([48, 20, 473503]), new Int32Array([99, 21, 0])];
}, {RVLC_BOOK: "Array", ESCAPE_BOOK: "Array"}, {});
var Message = function(level, fileName, className, methodName, lineNumber, message, args) {
    this.level = level;
    this.fileName = fileName;
    this.className = className;
    this.methodName = methodName;
    this.message = methodName;
    this.lineNumber = lineNumber;
    this.message = message;
    this.args = args;
};
Message = stjs.extend(Message, null, [], function(constructor, prototype) {
    prototype.level = null;
    prototype.fileName = null;
    prototype.className = null;
    prototype.lineNumber = 0;
    prototype.message = null;
    prototype.methodName = null;
    prototype.args = null;
    prototype.getLevel = function() {
        return this.level;
    };
    prototype.getFileName = function() {
        return this.fileName;
    };
    prototype.getClassName = function() {
        return this.className;
    };
    prototype.getMethodName = function() {
        return this.methodName;
    };
    prototype.getLineNumber = function() {
        return this.lineNumber;
    };
    prototype.getMessage = function() {
        return this.message;
    };
    prototype.getArgs = function() {
        return this.args;
    };
}, {level: {name: "Enum", arguments: ["LogLevel"]}, args: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  The SampleBuffer holds the decoded AAC frame. It contains the raw PCM data
 *  and its format.
 *  @author in-somnia
 */
var SampleBuffer = function() {
    this.data = new Int8Array(0);
    this.sampleRate = 0;
    this.channels = 0;
    this.bitsPerSample = 0;
    this.bigEndian = true;
};
SampleBuffer = stjs.extend(SampleBuffer, null, [], function(constructor, prototype) {
    prototype.sampleRate = 0;
    prototype.channels = 0;
    prototype.bitsPerSample = 0;
    prototype.length = 0.0;
    prototype.bitrate = 0.0;
    prototype.encodedBitrate = 0.0;
    prototype.data = null;
    prototype.bigEndian = false;
    /**
     *  Returns the buffer's PCM data.
     *  @return the audio data
     */
    prototype.getData = function() {
        return this.data;
    };
    /**
     *  Returns the data's sample rate.
     *  @return the sample rate
     */
    prototype.getSampleRate = function() {
        return this.sampleRate;
    };
    /**
     *  Returns the number of channels stored in the data buffer.
     *  @return the number of channels
     */
    prototype.getChannels = function() {
        return this.channels;
    };
    /**
     *  Returns the number of bits per sample. Usually this is 16, meaning a
     *  sample is stored in two bytes.
     *  @return the number of bits per sample
     */
    prototype.getBitsPerSample = function() {
        return this.bitsPerSample;
    };
    /**
     *  Returns the length of the current frame in seconds.
     *  length = samplesPerChannel / sampleRate
     *  @return the length in seconds
     */
    prototype.getLength = function() {
        return this.length;
    };
    /**
     *  Returns the bitrate of the decoded PCM data.
     *  <code>bitrate = (samplesPerChannel * bitsPerSample) / length</code>
     *  @return the bitrate
     */
    prototype.getBitrate = function() {
        return this.bitrate;
    };
    /**
     *  Returns the AAC bitrate of the current frame.
     *  @return the AAC bitrate
     */
    prototype.getEncodedBitrate = function() {
        return this.encodedBitrate;
    };
    /**
     *  Indicates the endianness for the data.
     *  
     *  @return true if the data is in big endian, false if it is in little endian
     */
    prototype.isBigEndian = function() {
        return this.bigEndian;
    };
    /**
     *  Sets the endianness for the data.
     *  
     *  @param bigEndian if true the data will be in big endian, else in little 
     *  endian
     */
    prototype.setBigEndian = function(bigEndian) {
        if (bigEndian != this.bigEndian) {
            var tmp;
            for (var i = 0; i < this.data.length; i += 2) {
                tmp = this.data[i];
                this.data[i] = this.data[i + 1];
                this.data[i + 1] = tmp;
            }
            this.bigEndian = bigEndian;
        }
    };
    prototype.setData = function(data, sampleRate, channels, bitsPerSample, bitsRead) {
        this.data = data;
        this.sampleRate = sampleRate;
        this.channels = channels;
        this.bitsPerSample = bitsPerSample;
        if (sampleRate == 0) {
            this.length = 0;
            this.bitrate = 0;
            this.encodedBitrate = 0;
        } else {
            var bytesPerSample = stjs.trunc(bitsPerSample / 8);
            var samplesPerChannel = stjs.trunc(data.length / (bytesPerSample * channels));
            this.length = samplesPerChannel / sampleRate;
            this.bitrate = (samplesPerChannel * bitsPerSample * channels) / this.length;
            this.encodedBitrate = bitsRead / this.length;
        }
    };
}, {data: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Simple JSON serializer, introduced because jcodec can not use dependencies as
 *  they bring frastration on some platforms
 *  
 *  @author The JCodec project
 */
var ToJSON = function() {};
ToJSON = stjs.extend(ToJSON, null, [], function(constructor, prototype) {
    /**
     *  Converts an object to JSON
     *  
     *  @param obj
     *  @return
     */
    constructor.toJSON = function(obj) {
        return JSON.stringify(obj);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  This header specifies the source image characteristics (see A.1), the
 *  components in the frame, and the sampling factors for each component, and
 *  specifies the destinations from which the quantized tables to be used with
 *  each component are retrieved.
 *  
 *  @author The JCodec project
 */
var FrameHeader = function() {};
FrameHeader = stjs.extend(FrameHeader, null, [], function(constructor, prototype) {
    /**
     *  Frame header length. Specifies the length of the frame header shown in
     *  Figure B.3 (see B.1.1.4).
     */
    prototype.headerLength = 0;
    /**
     *  Sample precision. Specifies the precision in bits for the samples of the
     *  components in the frame.
     */
    prototype.bitsPerSample = 0;
    /**
     *  Number of lines. Specifies the maximum number of lines in the source
     *  image. This shall be equal to the number of lines in the component with
     *  the maximum number of vertical samples (see A.1.1). Value 0 indicates
     *  that the number of lines shall be defined by the DNL marker and
     *  parameters at the end of the first scan (see B.2.5).
     */
    prototype.height = 0;
    /**
     *  Number of samples per line. Specifies the maximum number of samples per
     *  line in the source image. This shall be equal to the number of samples
     *  per line in the component with the maximum number of horizontal samples
     *  (see A.1.1).
     */
    prototype.width = 0;
    /**
     *  Number of image components in frame Specifies the number of source image
     *  components in the frame. The value of Nf shall be equal to the number of
     *  sets of frame component specification parameters (Ci, Hi, Vi, and Tq)
     *  present in the frame header.
     */
    prototype.nComp = 0;
    constructor.Component = function() {};
    constructor.Component = stjs.extend(constructor.Component, null, [], function(constructor, prototype) {
        /**
         *  Component identifier. Assigns a unique label to the ith component in
         *  the sequence of frame component specification parameters. These
         *  values shall be used in the scan headers to identify the components
         *  in the scan. The value of Ci shall be different from the values of C1
         *  through Ci 1.
         */
        prototype.index = 0;
        /**
         *  Horizontal sampling factor. Specifies the relationship between the
         *  component horizontal dimension and maximum image dimension X (see
         *  A.1.1); also specifies the number of horizontal data units of
         *  component Ci in each MCU, when more than one component is encoded in
         *  a scan.
         */
        prototype.subH = 0;
        /**
         *  Vertical sampling factor. Specifies the relationship between the
         *  component vertical dimension and maximum image dimension Y (see
         *  A.1.1); also specifies the number of vertical data units of component
         *  Ci in each MCU, when more than one component is encoded in a scan.
         */
        prototype.subV = 0;
        /**
         *  Quantization table destination selector. Specifies one of four
         *  possible quantization table destinations from which the quantization
         *  table to use for dequantization of DCT coefficients of component Ci
         *  is retrieved. If the decoding process uses the dequantization
         *  procedure, this table shall have been installed in this destination
         *  by the time the decoder is ready to decode the scan(s) containing
         *  component Ci. The destination shall not be re- specified, or its
         *  contents changed, until all scans containing Ci have been completed.
         */
        prototype.quantTable = 0;
    }, {}, {});
    prototype.getHmax = function() {
        var max = 0;
        for (var i = 0; i < this.components.length; i++) {
            var c = this.components[i];
            max = Math.max(max, c.subH);
        }
        return max;
    };
    prototype.getVmax = function() {
        var max = 0;
        for (var i = 0; i < this.components.length; i++) {
            var c = this.components[i];
            max = Math.max(max, c.subV);
        }
        return max;
    };
    prototype.components = null;
    constructor.read = function(is) {
        var frame = new FrameHeader();
        frame.headerLength = is.getShort() & 65535;
        frame.bitsPerSample = is.get() & 255;
        frame.height = is.getShort() & 65535;
        frame.width = is.getShort() & 65535;
        frame.nComp = is.get() & 255;
        frame.components = Array(frame.nComp);
        for (var i = 0; i < frame.components.length; i++) {
            var c = frame.components[i] = new FrameHeader.Component();
            c.index = is.get() & 255;
            var hv = is.get() & 255;
            c.subH = (hv & 240) >>> 4;
            c.subV = (hv & 15);
            c.quantTable = is.get() & 255;
        }
        return frame;
    };
}, {components: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AudioEncoder = function() {};
AudioEncoder = stjs.extend(AudioEncoder, null, [], function(constructor, prototype) {
    /**
     *  Encodes audio sample data in from the provided 'audioPkt'. The encoder is
     *  expected to know the bytes per sample, channel count and endian of the
     *  provided sample data to be able to correctly decode the bytes of provided
     *  samples.
     *  
     *  @param audioPkt Raw bytes containing sample data.
     *  @param buf Buffer to use as a storage for the output audio frame.
     *  @return Encoded audio frame.
     */
    prototype.encode = function(audioPkt, buf) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ChannelPosition = stjs.enumeration("AAC_CHANNEL_FRONT", "AAC_CHANNEL_SIDE", "AAC_CHANNEL_BACK", "AAC_CHANNEL_LFE", "AAC_CHANNEL_CC");
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var AudioSink = function() {};
AudioSink = stjs.extend(AudioSink, null, [], function(constructor, prototype) {
    prototype.writeFloat = function(buffer) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Point = function(x, y) {
    this.x = x;
    this.y = y;
};
Point = stjs.extend(Point, null, [], function(constructor, prototype) {
    prototype.x = 0;
    prototype.y = 0;
    prototype.getX = function() {
        return this.x;
    };
    prototype.getY = function() {
        return this.y;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ChannelUtils = function() {};
ChannelUtils = stjs.extend(ChannelUtils, null, [], null, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var NoiseTable = function() {};
NoiseTable = stjs.extend(NoiseTable, null, [], function(constructor, prototype) {
    constructor.NOISE_TABLE = [new Float32Array([-0.99948156, -0.59483415]), new Float32Array([0.97113454, -0.67528516]), new Float32Array([0.14130051, -0.95090985]), new Float32Array([-0.47005495, -0.3734055]), new Float32Array([0.80705065, 0.29653668]), new Float32Array([-0.3898148, 0.8957261]), new Float32Array([-0.010530499, -0.6695906]), new Float32Array([-0.9126637, -0.11522938]), new Float32Array([0.5484042, 0.75221366]), new Float32Array([0.40009254, -0.989294]), new Float32Array([-0.99867976, -0.8814707]), new Float32Array([-0.95531076, 0.9090876]), new Float32Array([-0.45725933, -0.5671632]), new Float32Array([-0.72929674, -0.98008275]), new Float32Array([0.756228, 0.2095033]), new Float32Array([0.070694424, -0.782479]), new Float32Array([0.7449625, -0.91169006]), new Float32Array([-0.96440184, -0.9473992]), new Float32Array([0.3042463, -0.49438268]), new Float32Array([0.6656503, 0.6465294]), new Float32Array([0.9169701, 0.17514098]), new Float32Array([-0.7077492, 0.5254865]), new Float32Array([-0.70051414, -0.45340028]), new Float32Array([-0.99496514, -0.9007191]), new Float32Array([0.9816449, -0.77463156]), new Float32Array([-0.5467158, -0.025709284]), new Float32Array([-0.01689629, 0.0028750645]), new Float32Array([-0.8611035, 0.42548585]), new Float32Array([-0.9889298, -0.8788113]), new Float32Array([0.51756626, 0.66926783]), new Float32Array([-0.9963503, -0.5810773]), new Float32Array([-0.9996937, 0.9836999]), new Float32Array([0.5526626, 0.5944906]), new Float32Array([0.34581178, 0.9487942]), new Float32Array([0.6266421, -0.7440297]), new Float32Array([-0.771497, -0.33883658]), new Float32Array([-0.91592246, 0.036879014]), new Float32Array([-0.76285493, -0.9137187]), new Float32Array([0.7978834, -0.9318097]), new Float32Array([0.5447308, -0.119192064]), new Float32Array([-0.8563928, 0.42429855]), new Float32Array([-0.928824, 0.27871808]), new Float32Array([-0.11708371, -0.99800843]), new Float32Array([0.2135675, -0.90716296]), new Float32Array([-0.76191694, 0.9976812]), new Float32Array([0.98111045, -0.9585446]), new Float32Array([-0.8591327, 0.9576657]), new Float32Array([-0.93307245, 0.4943176]), new Float32Array([0.30485755, -0.70540035]), new Float32Array([0.8528965, 0.46766132]), new Float32Array([0.91328084, -0.998396]), new Float32Array([-0.058902, 0.70741826]), new Float32Array([0.28398687, 0.34633556]), new Float32Array([0.95258164, -0.54893416]), new Float32Array([-0.78566325, -0.7556854]), new Float32Array([-0.957895, -0.20423195]), new Float32Array([0.8241116, 0.9665462]), new Float32Array([-0.65185446, -0.8873499]), new Float32Array([-0.93643606, 0.9987079]), new Float32Array([0.9142716, -0.98290503]), new Float32Array([-0.70395684, 0.587968]), new Float32Array([0.0056377198, 0.617682]), new Float32Array([0.8906505, 0.5278335]), new Float32Array([-0.6868371, 0.80806947]), new Float32Array([0.7216534, -0.6925986]), new Float32Array([-0.6292825, 0.13627037]), new Float32Array([0.29938436, -0.4605133]), new Float32Array([-0.91781956, -0.74012715]), new Float32Array([0.99298716, 0.4081661]), new Float32Array([0.82368296, -0.7403605]), new Float32Array([-0.98512834, -0.9997233]), new Float32Array([-0.9591537, -0.992378]), new Float32Array([-0.21411127, -0.9342482]), new Float32Array([-0.6882148, -0.26892307]), new Float32Array([0.91852, 0.09358229]), new Float32Array([-0.9606277, 0.36099094]), new Float32Array([0.51646185, -0.7137333]), new Float32Array([0.6113072, 0.4695014]), new Float32Array([0.47336128, -0.2733318]), new Float32Array([0.9099831, 0.96715665]), new Float32Array([0.448448, 0.99211574]), new Float32Array([0.6661489, 0.96590173]), new Float32Array([0.7492224, -0.8987986]), new Float32Array([-0.99571586, 0.5278552]), new Float32Array([0.9740108, -0.1685587]), new Float32Array([0.72683746, -0.48060775]), new Float32Array([0.9543219, 0.68849605]), new Float32Array([-0.72962207, -0.76608443]), new Float32Array([-0.8535948, 0.88738126]), new Float32Array([-0.8141243, -0.9748077]), new Float32Array([-0.87930775, 0.7474831]), new Float32Array([-0.7157333, -0.9857061]), new Float32Array([0.835243, 0.83702534]), new Float32Array([-0.48086065, -0.98848504]), new Float32Array([0.97139126, 0.8009362]), new Float32Array([0.5199283, 0.8024763]), new Float32Array([-0.008485912, -0.7667013]), new Float32Array([-0.70294374, 0.5535991]), new Float32Array([-0.95894426, -0.43265504]), new Float32Array([0.97079253, 0.093258575]), new Float32Array([-0.92404294, 0.855077]), new Float32Array([-0.6950647, 0.98633415]), new Float32Array([0.26559204, 0.7331431]), new Float32Array([0.28038442, 0.14537914]), new Float32Array([-0.7413812, 0.9931034]), new Float32Array([-0.01752796, -0.82616633]), new Float32Array([-0.55126774, -0.9889854]), new Float32Array([0.979609, -0.94021446]), new Float32Array([-0.9919631, 0.67019016]), new Float32Array([-0.6768493, 0.12631492]), new Float32Array([0.09140039, -0.20537731]), new Float32Array([-0.7165896, -0.977882]), new Float32Array([0.8101464, 0.5372265]), new Float32Array([0.40616992, -0.26469007]), new Float32Array([-0.67680186, 0.9450205]), new Float32Array([0.8684977, -0.18333599]), new Float32Array([-0.9950038, -0.02634122]), new Float32Array([0.8432919, 0.104069576]), new Float32Array([-0.09215969, 0.6954001]), new Float32Array([0.9995617, -0.12358542]), new Float32Array([-0.7973278, -0.91582525]), new Float32Array([0.9634997, 0.96640456]), new Float32Array([-0.7994278, 0.643239]), new Float32Array([-0.1156604, 0.28587845]), new Float32Array([-0.39922956, 0.94129604]), new Float32Array([0.990892, -0.9206263]), new Float32Array([0.28631285, -0.91035044]), new Float32Array([-0.83302724, -0.6733041]), new Float32Array([0.95404446, 0.49162766]), new Float32Array([-0.06449863, 0.03250561]), new Float32Array([-0.99575055, 0.42389783]), new Float32Array([-0.6550114, 0.82546115]), new Float32Array([-0.8125444, -0.51627237]), new Float32Array([-0.9964637, 0.8449053]), new Float32Array([0.002878406, 0.6476826]), new Float32Array([0.7017699, -0.20453028]), new Float32Array([0.9636188, 0.40706968]), new Float32Array([-0.6888376, 0.91338956]), new Float32Array([-0.34875587, 0.71472293]), new Float32Array([0.9198008, 0.6650745]), new Float32Array([-0.9900905, 0.8586802]), new Float32Array([0.68865794, 0.5566032]), new Float32Array([-0.994844, -0.2005256]), new Float32Array([0.9421451, -0.9969643]), new Float32Array([-0.6741463, 0.4954822]), new Float32Array([-0.47339353, -0.8590433]), new Float32Array([0.14323652, -0.94145596]), new Float32Array([-0.29268295, 0.05759225]), new Float32Array([0.4379386, -0.7890497]), new Float32Array([-0.36345127, 0.64874434]), new Float32Array([-0.08750605, 0.97686946]), new Float32Array([-0.9649527, -0.53960305]), new Float32Array([0.5552694, 0.7889152]), new Float32Array([0.73538214, 0.96452075]), new Float32Array([-0.30889773, -0.8066439]), new Float32Array([0.035749957, -0.9732562]), new Float32Array([0.9872069, 0.48409134]), new Float32Array([-0.816893, -0.90827703]), new Float32Array([0.6786686, 0.81284505]), new Float32Array([-0.1580857, 0.85279554]), new Float32Array([0.8072339, -0.24717419]), new Float32Array([0.47788757, -0.4633315]), new Float32Array([0.96367556, 0.3848675]), new Float32Array([-0.99143875, -0.24945277]), new Float32Array([0.8308188, -0.9478085]), new Float32Array([-0.5875319, 0.012907724]), new Float32Array([0.9553811, -0.8555705]), new Float32Array([-0.9649092, -0.64020973]), new Float32Array([-0.973271, 0.12378128]), new Float32Array([0.9140037, 0.5797247]), new Float32Array([-0.9992584, 0.71084845]), new Float32Array([-0.86875904, -0.202917]), new Float32Array([-0.26240036, -0.68264556]), new Float32Array([-0.24664412, -0.8764227]), new Float32Array([0.024162758, 0.27192914]), new Float32Array([0.8206862, -0.8508779]), new Float32Array([0.8854737, -0.896368]), new Float32Array([-0.18173078, -0.26152146]), new Float32Array([0.093554765, 0.54845124]), new Float32Array([-0.54668415, 0.95980775]), new Float32Array([0.3705099, -0.5991014]), new Float32Array([-0.70373595, 0.9122767]), new Float32Array([-0.34600785, -0.99441427]), new Float32Array([-0.6877448, -0.30238837]), new Float32Array([-0.26843292, 0.8311567]), new Float32Array([0.49072334, -0.4535971]), new Float32Array([0.38975993, 0.9551536]), new Float32Array([-0.97757125, 0.053058945]), new Float32Array([-0.17325553, -0.9277067]), new Float32Array([0.99948037, 0.58285546]), new Float32Array([-0.64946246, 0.6864551]), new Float32Array([-0.12016921, -0.57147324]), new Float32Array([-0.58947456, -0.3484713]), new Float32Array([-0.4181514, 0.16276422]), new Float32Array([0.9988565, 0.11136095]), new Float32Array([-0.56649613, -0.90494865]), new Float32Array([0.9413802, 0.35281917]), new Float32Array([-0.7572508, 0.5365055]), new Float32Array([0.20541973, -0.94435143]), new Float32Array([0.9998037, 0.79835916]), new Float32Array([0.29078278, 0.35393777]), new Float32Array([-0.6285877, 0.38765693]), new Float32Array([0.43440905, -0.9854633]), new Float32Array([-0.98298585, 0.21021524]), new Float32Array([0.19513029, -0.9423983]), new Float32Array([-0.95476663, 0.98364556]), new Float32Array([0.93379635, -0.7088199]), new Float32Array([-0.8523541, -0.08342348]), new Float32Array([-0.86425096, -0.45795026]), new Float32Array([0.3887978, 0.9727443]), new Float32Array([0.9204512, -0.62433654]), new Float32Array([0.89162534, 0.5495096]), new Float32Array([-0.36834338, 0.964583]), new Float32Array([0.93891764, -0.89968354]), new Float32Array([0.99267656, -0.037570342]), new Float32Array([-0.9406347, 0.41332337]), new Float32Array([0.99740225, -0.16830495]), new Float32Array([-0.35899413, -0.46633226]), new Float32Array([0.052372374, -0.25640363]), new Float32Array([0.36703584, -0.38653266]), new Float32Array([0.9165318, -0.30587628]), new Float32Array([0.69000804, 0.9095217]), new Float32Array([-0.3865875, 0.99501574]), new Float32Array([-0.29250816, 0.37444994]), new Float32Array([-0.601822, 0.8677965]), new Float32Array([-0.9741859, 0.96468526]), new Float32Array([0.8846157, 0.57508403]), new Float32Array([0.05198933, 0.21269661]), new Float32Array([-0.5349962, 0.97241557]), new Float32Array([-0.4942956, 0.98183864]), new Float32Array([-0.98935145, -0.4024916]), new Float32Array([-0.9808138, -0.728569]), new Float32Array([-0.2733815, 0.9995092]), new Float32Array([0.06310803, -0.54539585]), new Float32Array([-0.20461677, -0.14209978]), new Float32Array([0.6622384, 0.7252858]), new Float32Array([-0.84764344, 0.023723168]), new Float32Array([-0.8903986, 0.8886658]), new Float32Array([0.9590331, 0.76744926]), new Float32Array([0.73504126, -0.037472032]), new Float32Array([-0.31744435, -0.36834112]), new Float32Array([-0.34110826, 0.40211222]), new Float32Array([0.47803885, -0.39423218]), new Float32Array([0.98299193, 0.019897914]), new Float32Array([-0.30963072, -0.18076721]), new Float32Array([0.9999259, -0.26281872]), new Float32Array([-0.93149734, -0.98313165]), new Float32Array([0.99923474, -0.8014299]), new Float32Array([-0.2602417, -0.7599976]), new Float32Array([-0.35712513, 0.19298963]), new Float32Array([-0.99899083, 0.74645156]), new Float32Array([0.86557174, 0.55593866]), new Float32Array([0.33408043, 0.86185956]), new Float32Array([0.99010736, 0.046023976]), new Float32Array([-0.6669427, -0.91643614]), new Float32Array([0.6401679, 0.1564953]), new Float32Array([0.99570537, 0.45844585]), new Float32Array([-0.63431466, 0.21079117]), new Float32Array([-0.07706847, -0.89581436]), new Float32Array([0.9859009, 0.8824172]), new Float32Array([0.8009933, -0.36851898]), new Float32Array([0.78368133, 0.45507]), new Float32Array([0.087078065, 0.80938995]), new Float32Array([-0.8681188, 0.3934731]), new Float32Array([-0.3946653, -0.66809434]), new Float32Array([0.97875327, -0.7246784]), new Float32Array([-0.95038563, 0.8956322]), new Float32Array([0.1700524, 0.54683053]), new Float32Array([-0.76910794, -0.96226615]), new Float32Array([0.9974328, 0.42697158]), new Float32Array([0.95437384, 0.9700232]), new Float32Array([0.99578905, -0.54106826]), new Float32Array([0.2805826, -0.8536142]), new Float32Array([0.8525652, -0.6456761]), new Float32Array([-0.5060854, -0.65846014]), new Float32Array([-0.97210735, -0.23095213]), new Float32Array([0.9542405, -0.9924015]), new Float32Array([-0.9692657, 0.73775655]), new Float32Array([0.30872163, 0.4151496]), new Float32Array([-0.2452384, 0.6320663]), new Float32Array([-0.33813265, -0.38661778]), new Float32Array([-0.058268283, -0.06940774]), new Float32Array([-0.22898461, 0.9705485]), new Float32Array([-0.18509915, 0.47565764]), new Float32Array([-0.10488238, -0.8776995]), new Float32Array([-0.7188659, 0.7803098]), new Float32Array([0.99793875, 0.9004131]), new Float32Array([0.57563305, -0.91034335]), new Float32Array([0.28909647, 0.96307784]), new Float32Array([0.42189, 0.4814865]), new Float32Array([0.9333505, -0.43537024]), new Float32Array([-0.9708738, 0.8663645]), new Float32Array([0.36722872, 0.65291655]), new Float32Array([-0.81093025, 0.0877837]), new Float32Array([-0.26240602, -0.92774093]), new Float32Array([0.839965, 0.5583985]), new Float32Array([-0.99909616, -0.9602461]), new Float32Array([0.74649465, 0.121448934]), new Float32Array([-0.74774593, -0.26898062]), new Float32Array([0.95781666, -0.79047924]), new Float32Array([0.95472306, -0.08588776]), new Float32Array([0.48708332, 0.9999904]), new Float32Array([0.46332037, 0.10964126]), new Float32Array([-0.76497006, 0.8921093]), new Float32Array([0.5739739, 0.35289705]), new Float32Array([0.7537432, 0.96705216]), new Float32Array([-0.591744, -0.8940537]), new Float32Array([0.75087905, -0.29612672]), new Float32Array([-0.98607856, 0.2503491]), new Float32Array([-0.40761057, -0.9004557]), new Float32Array([0.6692927, 0.9862949]), new Float32Array([-0.974637, -0.001902233]), new Float32Array([0.9014551, 0.9978139]), new Float32Array([-0.87259287, 0.99233586]), new Float32Array([-0.9152946, -0.15698707]), new Float32Array([-0.033057388, -0.37205264]), new Float32Array([0.07223051, -0.88805]), new Float32Array([0.9949801, 0.97094357]), new Float32Array([-0.74904937, 0.99985486]), new Float32Array([0.045852285, 0.99812335]), new Float32Array([-0.89054954, -0.31791914]), new Float32Array([-0.8378214, 0.97637635]), new Float32Array([0.33454806, -0.8623152]), new Float32Array([-0.9970758, 0.9323799]), new Float32Array([-0.22827528, 0.1887476]), new Float32Array([0.67248046, -0.036462113]), new Float32Array([-0.05146538, -0.925997]), new Float32Array([0.999473, 0.9362523]), new Float32Array([0.66951126, 0.98905826]), new Float32Array([-0.99602956, -0.44654715]), new Float32Array([0.82104903, 0.9954074]), new Float32Array([0.9918651, 0.72023]), new Float32Array([-0.6528459, 0.5218672]), new Float32Array([0.93885446, -0.7489531]), new Float32Array([0.9673525, 0.90891814]), new Float32Array([-0.22225969, 0.5712403]), new Float32Array([-0.44132784, -0.9268884]), new Float32Array([-0.85694975, 0.8884453]), new Float32Array([0.9178304, -0.46356893]), new Float32Array([0.7255697, -0.99899554]), new Float32Array([-0.9971158, 0.5821156]), new Float32Array([0.7763898, 0.94321835]), new Float32Array([0.07717324, 0.586384]), new Float32Array([-0.5604983, 0.825223]), new Float32Array([0.98398894, 0.3946744]), new Float32Array([0.47546947, 0.68613046]), new Float32Array([0.6567509, 0.18331636]), new Float32Array([0.032733753, -0.7493311]), new Float32Array([-0.38684145, 0.5133735]), new Float32Array([-0.9734627, -0.9654936]), new Float32Array([-0.53282154, -0.9142327]), new Float32Array([0.9981731, 0.61133575]), new Float32Array([-0.502545, -0.8882934]), new Float32Array([0.019958733, 0.85223514]), new Float32Array([0.9993038, 0.945789]), new Float32Array([0.82907766, -0.063234426]), new Float32Array([-0.5866071, 0.96840775]), new Float32Array([-0.17573737, -0.48166922]), new Float32Array([0.8343429, -0.13023451]), new Float32Array([0.059464913, 0.20511048]), new Float32Array([0.81505483, -0.9468595]), new Float32Array([-0.4497638, 0.40894574]), new Float32Array([-0.89746475, 0.9984658]), new Float32Array([0.39677256, -0.74854666]), new Float32Array([-0.07588948, 0.74096215]), new Float32Array([0.76343197, 0.41746628]), new Float32Array([-0.74490106, 0.9472591]), new Float32Array([0.6488012, 0.41336662]), new Float32Array([0.62319535, -0.9309831]), new Float32Array([0.42215818, -0.077127874]), new Float32Array([0.02704554, -0.05417518]), new Float32Array([0.8000177, 0.91542196]), new Float32Array([-0.7935183, -0.36208898]), new Float32Array([0.6387236, 0.081282526]), new Float32Array([0.5289052, 0.6004887]), new Float32Array([0.7423855, 0.04491915]), new Float32Array([0.9909613, -0.19451183]), new Float32Array([-0.8041233, -0.88513815]), new Float32Array([-0.64612615, 0.7219868]), new Float32Array([0.11657771, -0.8366283]), new Float32Array([-0.95053184, -0.96939903]), new Float32Array([-0.6222887, 0.8276726]), new Float32Array([0.030044759, -0.99738896]), new Float32Array([-0.97987217, 0.3652613]), new Float32Array([-0.9998698, -0.3602161]), new Float32Array([0.8911065, -0.9789425]), new Float32Array([0.104079604, 0.7735779]), new Float32Array([0.95964736, -0.3543582]), new Float32Array([0.5084323, 0.9610769]), new Float32Array([0.17006335, -0.76854026]), new Float32Array([0.25872675, 0.998933]), new Float32Array([-0.011159987, 0.9849602]), new Float32Array([-0.795987, 0.9713841]), new Float32Array([-0.9926471, -0.9954282]), new Float32Array([-0.9982966, 0.018771388]), new Float32Array([-0.70801014, 0.33680686]), new Float32Array([-0.70467055, 0.93272775]), new Float32Array([0.99846023, -0.9872575]), new Float32Array([-0.6336497, -0.16473594]), new Float32Array([-0.16258217, -0.95939124]), new Float32Array([-0.43645594, -0.9480503]), new Float32Array([-0.99848473, 0.9624517]), new Float32Array([-0.1679646, -0.98987514]), new Float32Array([-0.8797923, -0.71725726]), new Float32Array([0.441831, -0.93568975]), new Float32Array([0.9331018, -0.9991331]), new Float32Array([-0.9394193, -0.56409377]), new Float32Array([-0.8859, 0.476246]), new Float32Array([0.9997146, -0.83889955]), new Float32Array([-0.75376385, 0.008146434]), new Float32Array([0.93887687, -0.11284528]), new Float32Array([0.85126436, 0.5234925]), new Float32Array([0.3970142, 0.81779635]), new Float32Array([-0.37024465, -0.8707166]), new Float32Array([-0.36024827, 0.34655735]), new Float32Array([-0.93388814, -0.8447654]), new Float32Array([-0.652988, -0.18439576]), new Float32Array([0.11960319, 0.99899346]), new Float32Array([0.94292563, 0.83163905]), new Float32Array([0.75081146, -0.35533223]), new Float32Array([0.5672198, -0.24076836]), new Float32Array([0.46857765, -0.30140233]), new Float32Array([0.97312313, -0.9954819]), new Float32Array([-0.38299978, 0.9851691]), new Float32Array([0.410258, 0.02116737]), new Float32Array([0.09638062, 0.044119842]), new Float32Array([-0.8528325, 0.91475564]), new Float32Array([0.88866806, -0.99735266]), new Float32Array([-0.48202428, -0.9680561]), new Float32Array([0.2757258, 0.5863475]), new Float32Array([-0.6588913, 0.5883563]), new Float32Array([0.98838085, 0.9999435]), new Float32Array([-0.2065135, 0.54593045]), new Float32Array([-0.62126416, -0.5989368]), new Float32Array([0.20320106, -0.8687918]), new Float32Array([-0.9779055, 0.9629081]), new Float32Array([0.11112535, 0.21484764]), new Float32Array([-0.41368338, 0.2821684]), new Float32Array([0.24133039, 0.5129436]), new Float32Array([-0.6639341, -0.0824968]), new Float32Array([-0.5369783, -0.976499]), new Float32Array([-0.97224736, 0.22081333]), new Float32Array([0.8739248, -0.12796174]), new Float32Array([0.19050361, 0.016026154]), new Float32Array([-0.4635344, -0.9524904]), new Float32Array([-0.07064097, -0.94479805]), new Float32Array([-0.92444086, -0.1045759]), new Float32Array([-0.83822596, -0.016950432]), new Float32Array([0.75214684, -0.99955684]), new Float32Array([-0.42102998, 0.9972094]), new Float32Array([-0.72094786, -0.3500896]), new Float32Array([0.78843313, 0.52851397]), new Float32Array([0.97394025, -0.26695943]), new Float32Array([0.99206465, -0.5701012]), new Float32Array([0.7678961, -0.7651936]), new Float32Array([-0.8200242, -0.7353018]), new Float32Array([0.8192499, 0.99698424]), new Float32Array([-0.2671985, 0.6890337]), new Float32Array([-0.4331126, 0.85321814]), new Float32Array([0.9919498, 0.9187625]), new Float32Array([-0.80692, -0.3262754]), new Float32Array([0.43080005, -0.21919096]), new Float32Array([0.67709494, -0.95478076]), new Float32Array([0.5615177, -0.7069381]), new Float32Array([0.10831863, -0.08628837]), new Float32Array([0.91229415, -0.6598735]), new Float32Array([-0.48972893, 0.56289244]), new Float32Array([-0.8903366, -0.71656567]), new Float32Array([0.65269446, 0.6591601]), new Float32Array([0.6743948, -0.8168438]), new Float32Array([-0.4777083, -0.16789556]), new Float32Array([-0.9971598, -0.93565786]), new Float32Array([-0.9088959, 0.620344]), new Float32Array([-0.06618623, -0.23812217]), new Float32Array([0.9943027, 0.18812555]), new Float32Array([0.97686404, -0.28664535]), new Float32Array([0.9481365, -0.9750664]), new Float32Array([-0.954345, -0.7960798]), new Float32Array([-0.49104783, 0.32895213]), new Float32Array([0.9988117, 0.88993984]), new Float32Array([0.5044917, -0.8599507]), new Float32Array([0.4716289, -0.18680204]), new Float32Array([-0.6208158, 0.75000674]), new Float32Array([-0.43867016, 0.9999807]), new Float32Array([0.98630565, -0.535789]), new Float32Array([-0.6151036, -0.8951502]), new Float32Array([-0.038415175, -0.6988882]), new Float32Array([-0.30102158, -0.07667809]), new Float32Array([0.41881284, 0.02188099]), new Float32Array([-0.86135453, 0.98947483]), new Float32Array([0.6722686, -0.13494389]), new Float32Array([-0.707374, -0.7654735]), new Float32Array([0.9404495, 0.09026201]), new Float32Array([-0.8238635, 0.08924769]), new Float32Array([-0.32070667, 0.5014342]), new Float32Array([0.5759316, -0.98966426]), new Float32Array([-0.36326018, 0.07440243]), new Float32Array([0.99979043, -0.14130287]), new Float32Array([-0.9236602, -0.97979295]), new Float32Array([-0.44607177, -0.54233253]), new Float32Array([0.442268, 0.71326756]), new Float32Array([0.036719073, 0.6360639]), new Float32Array([0.52175426, -0.85396826]), new Float32Array([-0.9470114, -0.018263482]), new Float32Array([-0.9875961, 0.8228871]), new Float32Array([0.8743479, 0.8939949]), new Float32Array([-0.9341204, 0.41374052]), new Float32Array([0.9606394, 0.93116707]), new Float32Array([0.9753425, 0.8615093]), new Float32Array([0.9964247, 0.7019004]), new Float32Array([-0.94705087, -0.29580042]), new Float32Array([0.91599804, -0.98147833])];
}, {NOISE_TABLE: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var AudioFrameWithPacket = function(audio, packet) {
    this.audio = audio;
    this.packet = packet;
};
AudioFrameWithPacket = stjs.extend(AudioFrameWithPacket, null, [], function(constructor, prototype) {
    prototype.audio = null;
    prototype.packet = null;
    prototype.getAudio = function() {
        return this.audio;
    };
    prototype.getPacket = function() {
        return this.packet;
    };
}, {audio: "AudioBuffer", packet: "Packet"}, {});
/**
 *  Filters the decoded image before it gets to encoder.
 *  
 *  @author stan
 */
var Filter = function() {};
Filter = stjs.extend(Filter, null, [], function(constructor, prototype) {
    prototype.filter = function(picture, store) {};
    /**
     *  The color space that this filter supports on the input. null indicates any color space is taken.
     *  @return
     */
    prototype.getInputColor = function() {};
    prototype.getOutputColor = function() {};
}, {}, {});
/**
 *  The sink that consumes the uncompressed frames and stores them into a
 *  compressed file.
 *  
 *  @author Stanislav Vitvitskiy
 */
var PacketSink = function() {};
PacketSink = stjs.extend(PacketSink, null, [], function(constructor, prototype) {
    prototype.outputVideoPacket = function(videoPacket, videoCodecMeta) {};
    prototype.outputAudioPacket = function(audioPacket, audioCodecMeta) {};
}, {}, {});
var Options = stjs.enumeration("PROFILE", "INTERLACED", "DOWNSCALE");
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var RawDataBlockType = stjs.enumeration("TYPE_SCE", "TYPE_CPE", "TYPE_CCE", "TYPE_LFE", "TYPE_DSE", "TYPE_PCE", "TYPE_FIL", "TYPE_END");
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Scalefactor lookup table
 *  @author in-somnia
 */
var ScaleFactorTable = function() {};
ScaleFactorTable = stjs.extend(ScaleFactorTable, null, [], function(constructor, prototype) {
    constructor.SCALEFACTOR_TABLE = new Float32Array([8.881784E-16, 1.0562281E-15, 1.2560739E-15, 1.4937321E-15, 1.7763568E-15, 2.1124561E-15, 2.5121479E-15, 2.9874642E-15, 3.5527137E-15, 4.2249122E-15, 5.0242958E-15, 5.9749285E-15, 7.1054274E-15, 8.4498245E-15, 1.00485916E-14, 1.1949857E-14, 1.4210855E-14, 1.6899649E-14, 2.0097183E-14, 2.3899714E-14, 2.842171E-14, 3.3799298E-14, 4.0194366E-14, 4.7799428E-14, 5.684342E-14, 6.7598596E-14, 8.038873E-14, 9.5598856E-14, 1.1368684E-13, 1.3519719E-13, 1.6077747E-13, 1.9119771E-13, 2.2737368E-13, 2.7039438E-13, 3.2155493E-13, 3.8239542E-13, 4.5474735E-13, 5.4078877E-13, 6.4310986E-13, 7.6479085E-13, 9.094947E-13, 1.0815775E-12, 1.2862197E-12, 1.5295817E-12, 1.8189894E-12, 2.163155E-12, 2.5724394E-12, 3.0591634E-12, 3.6379788E-12, 4.32631E-12, 5.144879E-12, 6.1183268E-12, 7.2759576E-12, 8.65262E-12, 1.0289758E-11, 1.22366535E-11, 1.4551915E-11, 1.730524E-11, 2.0579516E-11, 2.4473307E-11, 2.910383E-11, 3.461048E-11, 4.115903E-11, 4.8946614E-11, 5.820766E-11, 6.922096E-11, 8.231806E-11, 9.789323E-11, 1.1641532E-10, 1.3844192E-10, 1.6463612E-10, 1.9578646E-10, 2.3283064E-10, 2.7688385E-10, 3.2927225E-10, 3.915729E-10, 4.656613E-10, 5.537677E-10, 6.585445E-10, 7.831458E-10, 9.313226E-10, 1.1075354E-9, 1.317089E-9, 1.5662917E-9, 1.8626451E-9, 2.2150708E-9, 2.634178E-9, 3.1325833E-9, 3.7252903E-9, 4.4301416E-9, 5.268356E-9, 6.2651666E-9, 7.4505806E-9, 8.860283E-9, 1.0536712E-8, 1.2530333E-8, 1.4901161E-8, 1.7720566E-8, 2.1073424E-8, 2.5060666E-8, 2.9802322E-8, 3.5441133E-8, 4.2146848E-8, 5.0121333E-8, 5.9604645E-8, 7.0882265E-8, 8.4293696E-8, 1.00242666E-7, 1.1920929E-7, 1.4176453E-7, 1.6858739E-7, 2.0048533E-7, 2.3841858E-7, 2.8352906E-7, 3.3717478E-7, 4.0097066E-7, 4.7683716E-7, 5.670581E-7, 6.7434956E-7, 8.019413E-7, 9.536743E-7, 1.1341162E-6, 1.3486991E-6, 1.6038827E-6, 1.9073486E-6, 2.2682325E-6, 2.6973983E-6, 3.2077653E-6, 3.8146973E-6, 4.536465E-6, 5.3947965E-6, 6.4155306E-6, 7.6293945E-6, 9.07293E-6, 1.0789593E-5, 1.2831061E-5, 1.5258789E-5, 1.814586E-5, 2.1579186E-5, 2.5662122E-5, 3.0517578E-5, 3.629172E-5, 4.3158372E-5, 5.1324245E-5, 6.1035156E-5, 7.258344E-5, 8.6316744E-5, 1.0264849E-4, 1.2207031E-4, 1.4516688E-4, 1.7263349E-4, 2.0529698E-4, 2.4414062E-4, 2.9033376E-4, 3.4526698E-4, 4.1059396E-4, 4.8828125E-4, 5.806675E-4, 6.9053395E-4, 8.211879E-4, 9.765625E-4, 0.001161335, 0.0013810679, 0.0016423758, 0.001953125, 0.00232267, 0.0027621358, 0.0032847517, 0.00390625, 0.00464534, 0.0055242716, 0.0065695033, 0.0078125, 0.00929068, 0.011048543, 0.013139007, 0.015625, 0.01858136, 0.022097087, 0.026278013, 0.03125, 0.03716272, 0.044194173, 0.052556027, 0.0625, 0.07432544, 0.088388346, 0.10511205, 0.125, 0.14865088, 0.17677669, 0.2102241, 0.25, 0.29730177, 0.35355338, 0.4204482, 0.5, 0.59460354, 0.70710677, 0.8408964, 1.0, 1.1892071, 1.4142135, 1.6817929, 2.0, 2.3784142, 2.828427, 3.3635857, 4.0, 4.7568283, 5.656854, 6.7271714, 8.0, 9.513657, 11.313708, 13.454343, 16.0, 19.027313, 22.627417, 26.908686, 32.0, 38.054626, 45.254833, 53.81737, 64.0, 76.10925, 90.50967, 107.63474, 128.0, 152.2185, 181.01933, 215.26949, 256.0, 304.437, 362.03867, 430.53897, 512.0, 608.874, 724.07733, 861.07794, 1024.0, 1217.748, 1448.1547, 1722.1559, 2048.0, 2435.496, 2896.3093, 3444.3118, 4096.0, 4870.992, 5792.6187, 6888.6235, 8192.0, 9741.984, 11585.237, 13777.247, 16384.0, 19483.969, 23170.475, 27554.494, 32768.0, 38967.938, 46340.95, 55108.99, 65536.0, 77935.875, 92681.9, 110217.98, 131072.0, 155871.75, 185363.8, 220435.95, 262144.0, 311743.5, 370727.6, 440871.9, 524288.0, 623487.0, 741455.2, 881743.8, 1048576.0, 1246974.0, 1482910.4, 1763487.6, 2097152.0, 2493948.0, 2965820.8, 3526975.2, 4194304.0, 4987896.0, 5931641.5, 7053950.5, 8388608.0, 9975792.0, 1.1863283E7, 1.4107901E7, 1.6777216E7, 1.9951584E7, 2.3726566E7, 2.8215802E7, 3.3554432E7, 3.9903168E7, 4.7453132E7, 5.6431604E7, 6.7108864E7, 7.9806336E7, 9.4906264E7, 1.12863208E8, 1.34217728E8, 1.59612672E8, 1.89812528E8, 2.25726416E8, 2.68435456E8, 3.19225344E8, 3.79625056E8, 4.51452832E8, 5.3687091E8, 6.3845069E8, 7.5925011E8, 9.0290566E8, 1.07374182E9, 1.27690138E9, 1.51850022E9, 1.80581133E9, 2.14748365E9, 2.55380275E9, 3.03700045E9, 3.61162266E9, 4.2949673E9, 5.1076055E9, 6.0740009E9, 7.2232453E9, 8.5899346E9, 1.0215211E10, 1.21480018E10, 1.44464906E10, 1.71798692E10, 2.0430422E10, 2.42960036E10, 2.88929812E10, 3.4359738E10, 4.0860844E10, 4.8592007E10, 5.7785962E10, 6.8719477E10, 8.1721688E10, 9.7184014E10, 1.15571925E11, 1.37438953E11, 1.63443376E11, 1.94368029E11, 2.3114385E11, 2.74877907E11, 3.26886752E11, 3.88736057E11, 4.622877E11, 5.4975581E11, 6.537735E11, 7.7747211E11, 9.245754E11, 1.09951163E12, 1.30754701E12, 1.55494423E12, 1.8491508E12, 2.19902326E12, 2.61509402E12, 3.10988846E12, 3.6983016E12, 4.3980465E12, 5.230188E12, 6.2197769E12, 7.3966032E12, 8.796093E12, 1.04603761E13, 1.24395538E13, 1.47932064E13, 1.7592186E13, 2.09207521E13, 2.48791077E13, 2.95864128E13, 3.5184372E13, 4.1841504E13, 4.9758215E13, 5.9172826E13, 7.0368744E13, 8.3683009E13, 9.9516431E13, 1.18345651E14, 1.40737488E14, 1.67366017E14, 1.99032861E14, 2.36691302E14, 2.81474977E14, 3.34732034E14, 3.98065723E14, 4.73382605E14, 5.6294995E14, 6.6946407E14, 7.9613145E14, 9.4676521E14, 1.12589991E15, 1.33892814E15, 1.59226289E15, 1.89353042E15, 2.25179981E15, 2.67785627E15, 3.18452578E15, 3.78706084E15, 4.5035996E15, 5.3557125E15, 6.3690516E15, 7.5741217E15, 9.0071993E15, 1.07114251E16, 1.27381031E16, 1.51482434E16, 1.80143985E16, 2.14228502E16, 2.54762063E16, 3.02964867E16, 3.6028797E16, 4.28457E16, 5.0952413E16, 6.0592973E16, 7.2057594E16, 8.5691401E16, 1.01904825E17, 1.21185947E17]);
}, {SCALEFACTOR_TABLE: "Float32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var Windows = function() {};
Windows = stjs.extend(Windows, null, [], function(constructor, prototype) {
    constructor.SINE_256 = new Float32Array([0.0030679568, 0.009203754, 0.015339206, 0.02147408, 0.027608145, 0.033741172, 0.039872926, 0.04600318, 0.052131705, 0.058258265, 0.06438263, 0.070504576, 0.076623864, 0.08274026, 0.08885355, 0.0949635, 0.10106986, 0.10717242, 0.11327095, 0.119365215, 0.12545498, 0.13154003, 0.13762012, 0.14369503, 0.14976454, 0.1558284, 0.1618864, 0.16793829, 0.17398387, 0.1800229, 0.18605515, 0.1920804, 0.1980984, 0.20410897, 0.21011184, 0.2161068, 0.22209363, 0.22807208, 0.23404196, 0.24000302, 0.24595505, 0.2518978, 0.2578311, 0.26375467, 0.2696683, 0.27557182, 0.28146493, 0.28734747, 0.29321915, 0.29907984, 0.30492923, 0.31076714, 0.31659338, 0.3224077, 0.32820985, 0.33399966, 0.33977687, 0.34554133, 0.35129276, 0.35703096, 0.36275572, 0.36846682, 0.37416407, 0.3798472, 0.38551605, 0.39117038, 0.39681, 0.40243465, 0.40804416, 0.41363832, 0.4192169, 0.42477968, 0.4303265, 0.4358571, 0.44137126, 0.44686884, 0.45234957, 0.4578133, 0.4632598, 0.46868882, 0.4741002, 0.47949377, 0.48486924, 0.49022648, 0.49556527, 0.50088537, 0.50618666, 0.5114688, 0.5167318, 0.5219753, 0.52719915, 0.5324031, 0.53758705, 0.5427508, 0.54789406, 0.5530167, 0.5581185, 0.56319934, 0.56825894, 0.57329714, 0.57831377, 0.58330864, 0.5882816, 0.5932323, 0.5981607, 0.6030666, 0.6079498, 0.6128101, 0.6176473, 0.62246126, 0.6272518, 0.63201874, 0.63676184, 0.64148104, 0.64617604, 0.65084666, 0.65549284, 0.66011435, 0.664711, 0.6692826, 0.673829, 0.67835003, 0.68284553, 0.68731534, 0.6917592, 0.6961771, 0.7005688, 0.70493406, 0.7092728, 0.71358484, 0.71787006, 0.7221282, 0.7263591, 0.73056275, 0.7347389, 0.7388873, 0.74300796, 0.7471006, 0.75116515, 0.7552014, 0.7592092, 0.7631884, 0.7671389, 0.7710605, 0.7749531, 0.7788165, 0.7826506, 0.7864552, 0.7902302, 0.7939755, 0.79769087, 0.80137616, 0.80503136, 0.80865616, 0.8122506, 0.81581444, 0.8193475, 0.8228498, 0.82632107, 0.8297612, 0.8331702, 0.83654773, 0.8398938, 0.84320825, 0.8464909, 0.84974176, 0.8529606, 0.85614735, 0.8593018, 0.86242396, 0.8655136, 0.8685707, 0.8715951, 0.87458664, 0.8775453, 0.8804709, 0.88336337, 0.88622254, 0.88904834, 0.8918407, 0.8945995, 0.89732456, 0.9000159, 0.9026733, 0.90529674, 0.9078861, 0.9104413, 0.9129622, 0.9154487, 0.9179008, 0.9203183, 0.9227011, 0.92504925, 0.9273625, 0.9296409, 0.9318843, 0.9340925, 0.93626565, 0.93840355, 0.94050604, 0.9425732, 0.9446048, 0.9466009, 0.9485614, 0.95048606, 0.952375, 0.9542281, 0.95604527, 0.95782644, 0.95957154, 0.96128047, 0.96295327, 0.9645898, 0.96619, 0.9677538, 0.96928126, 0.97077215, 0.9722265, 0.97364426, 0.97502536, 0.97636974, 0.97767735, 0.9789482, 0.9801821, 0.9813792, 0.9825393, 0.9836624, 0.9847485, 0.9857975, 0.9868094, 0.98778415, 0.98872167, 0.989622, 0.9904851, 0.99131083, 0.9920993, 0.9928504, 0.9935641, 0.99424046, 0.9948793, 0.9954808, 0.9960447, 0.9965711, 0.99706006, 0.99751145, 0.9979253, 0.99830157, 0.99864024, 0.9989413, 0.99920475, 0.9994306, 0.9996188, 0.9997694, 0.99988234, 0.9999576, 0.9999953]);
    constructor.SINE_32 = new Float32Array([0.024541229, 0.07356457, 0.12241068, 0.17096189, 0.21910124, 0.26671275, 0.31368175, 0.35989505, 0.4052413, 0.44961134, 0.4928982, 0.53499764, 0.57580817, 0.6152316, 0.65317285, 0.68954057, 0.7242471, 0.7572088, 0.7883464, 0.8175848, 0.8448536, 0.87008697, 0.8932243, 0.9142098, 0.9329928, 0.94952816, 0.96377605, 0.9757021, 0.98527765, 0.99247956, 0.99729043, 0.9996988]);
    constructor.KBD_256 = new Float32Array([5.85123E-4, 9.6421497E-4, 0.0013558208, 0.001777185, 0.0022352533, 0.00273423, 0.0032773002, 0.0038671999, 0.0045064446, 0.0051974338, 0.005942505, 0.00674396, 0.007604081, 0.008525138, 0.009509392, 0.010559099, 0.011676508, 0.012863862, 0.014123397, 0.015457335, 0.01686789, 0.018357255, 0.019927613, 0.02158112, 0.023319913, 0.0251461, 0.027061762, 0.029068947, 0.031169666, 0.03336589, 0.035659555, 0.038052544, 0.040546697, 0.043143805, 0.045845594, 0.048653748, 0.05156988, 0.054595537, 0.057732213, 0.060981322, 0.06434421, 0.06782214, 0.07141632, 0.07512784, 0.07895775, 0.082906984, 0.086976394, 0.09116676, 0.095478736, 0.09991292, 0.10446978, 0.10914971, 0.11395299, 0.118879795, 0.123930216, 0.12910421, 0.13440166, 0.13982232, 0.14536583, 0.15103175, 0.1568195, 0.16272838, 0.16875762, 0.17490631, 0.18117344, 0.18755788, 0.19405837, 0.20067358, 0.20740204, 0.21424216, 0.22119227, 0.22825058, 0.23541516, 0.242684, 0.25005502, 0.25752598, 0.26509452, 0.27275825, 0.28051463, 0.28836104, 0.29629478, 0.304313, 0.31241283, 0.32059127, 0.32884523, 0.33717158, 0.34556705, 0.35402837, 0.3625521, 0.37113485, 0.37977302, 0.38846308, 0.3972014, 0.40598422, 0.41480786, 0.42366847, 0.43256226, 0.4414853, 0.4504337, 0.4594035, 0.46839076, 0.47739145, 0.4864016, 0.49541712, 0.50443405, 0.5134483, 0.5224558, 0.5314526, 0.54043466, 0.5493979, 0.5583384, 0.56725216, 0.5761352, 0.58498365, 0.59379363, 0.6025613, 0.6112828, 0.6199545, 0.62857264, 0.6371336, 0.6456338, 0.6540698, 0.66243804, 0.67073524, 0.67895806, 0.68710333, 0.69516784, 0.7031487, 0.7110428, 0.71884745, 0.72655976, 0.73417705, 0.7416969, 0.7491167, 0.7564342, 0.76364714, 0.7707534, 0.77775085, 0.78463775, 0.79141223, 0.79807264, 0.8046174, 0.8110451, 0.81735444, 0.8235442, 0.8296133, 0.83556086, 0.841386, 0.84708804, 0.8526664, 0.85812056, 0.8634502, 0.8686552, 0.87373537, 0.8786907, 0.88352144, 0.8882277, 0.89280987, 0.8972685, 0.90160406, 0.90581733, 0.909909, 0.91388005, 0.91773146, 0.92146426, 0.9250797, 0.928579, 0.9319635, 0.93523467, 0.93839407, 0.9414432, 0.9443838, 0.94721764, 0.9499464, 0.9525721, 0.95509654, 0.95752174, 0.9598498, 0.9620826, 0.96422243, 0.9662714, 0.9682316, 0.9701054, 0.9718949, 0.9736024, 0.9752302, 0.9767806, 0.9782558, 0.9796582, 0.98099, 0.98225355, 0.9834512, 0.9845851, 0.9856576, 0.9866709, 0.98762727, 0.9885289, 0.989378, 0.9901766, 0.9909269, 0.99163103, 0.9922909, 0.99290866, 0.99348617, 0.99402535, 0.99452806, 0.9949962, 0.9954315, 0.99583566, 0.9962104, 0.9965573, 0.99687797, 0.9971739, 0.9974466, 0.9976974, 0.9979278, 0.9981389, 0.9983321, 0.9985086, 0.9986694, 0.9988157, 0.9989485, 0.99906886, 0.99917763, 0.99927574, 0.999364, 0.99944323, 0.9995141, 0.9995774, 0.9996338, 0.9996838, 0.9997281, 0.9997671, 0.9998014, 0.9998315, 0.9998577, 0.99988055, 0.9999003, 0.99991727, 0.9999318, 0.99994427, 0.99995476, 0.99996364, 0.9999711, 0.99997723, 0.99998236, 0.99998647, 0.99998987, 0.99999255, 0.99999464, 0.99999624, 0.9999975, 0.99999845, 0.9999991, 0.9999995, 0.9999998]);
    constructor.KBD_32 = new Float32Array([8.7591405E-5, 9.32176E-4, 0.0032114612, 0.008100989, 0.017124029, 0.032072075, 0.054830786, 0.08713618, 0.13029234, 0.18489555, 0.2506163, 0.32608742, 0.40893167, 0.4959415, 0.583394, 0.6674602, 0.7446455, 0.8121893, 0.86835593, 0.912565, 0.9453396, 0.9680865, 0.98275816, 0.99147564, 0.9961964, 0.99849564, 0.99948555, 0.9998534, 0.99996716, 0.9999948, 0.9999996, 1.0]);
}, {SINE_256: "Float32Array", SINE_32: "Float32Array", KBD_256: "Float32Array", KBD_32: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var DCTRef = function() {};
DCTRef = stjs.extend(DCTRef, null, [], function(constructor, prototype) {
    constructor.coefficients = new Float64Array(64);
    constructor.fdct = function(block, off) {
        var i, j, k;
        var out = new Float64Array(8 * 8);
        for (i = 0; i < 64; i += 8) {
            for (j = 0; j < 8; ++j) {
                var tmp = 0;
                for (k = 0; k < 8; ++k) {
                    tmp += DCTRef.coefficients[i + k] * block[k * 8 + j + off];
                }
                out[i + j] = tmp * 4;
            }
        }
        for (j = 0; j < 8; ++j) {
            for (i = 0; i < 64; i += 8) {
                var tmp = 0;
                for (k = 0; k < 8; ++k) {
                    tmp += out[i + k] * DCTRef.coefficients[j * 8 + k];
                }
                block[i + j + off] = stjs.trunc((tmp + 0.499999999999));
            }
        }
    };
    constructor.idct = function(block, off) {
        var i, j, k;
        var out = new Float64Array(8 * 8);
        for (i = 0; i < 64; i += 8) {
            for (j = 0; j < 8; ++j) {
                var tmp = 0;
                for (k = 0; k < 8; ++k) {
                    tmp += block[i + k] * DCTRef.coefficients[k * 8 + j];
                }
                out[i + j] = tmp;
            }
        }
        for (i = 0; i < 8; ++i) {
            for (j = 0; j < 8; ++j) {
                var tmp = 0;
                for (k = 0; k < 64; k += 8) {
                    tmp += DCTRef.coefficients[k + i] * out[k + j];
                }
                block[i * 8 + j] = stjs.trunc((tmp + 0.5));
            }
        }
    };
}, {coefficients: "Float64Array"}, {});
(function() {
    for (var j = 0; j < 8; ++j) {
        DCTRef.coefficients[j] = Math.sqrt(0.125);
        for (var i = 8; i < 64; i += 8) {
            DCTRef.coefficients[i + j] = 0.5 * Math.cos(i * (j + 0.5) * Math.PI / 64.0);
        }
    }
})();
var InterpFilter = stjs.enumeration("LANCZOS", "BICUBIC");
/**
 *  A source for compressed video/audio frames.
 *  
 *  @author Stanislav Vitvitskiy
 */
var PacketSource = function() {};
PacketSource = stjs.extend(PacketSource, null, [], function(constructor, prototype) {
    prototype.inputVideoPacket = function() {};
    prototype.inputAudioPacket = function() {};
}, {}, {});
/**
 *  this annotation warns not to remove methods/constructors/fields if their
 *  usages are not found via normal means
 */
var UsedViaReflection = function() {};
UsedViaReflection = stjs.extend(UsedViaReflection, null, [], null, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Chunk = function(offset, startTv, sampleCount, sampleSize, sampleSizes, sampleDur, sampleDurs, entry) {
    this.offset = offset;
    this.startTv = startTv;
    this.sampleCount = sampleCount;
    this.sampleSize = sampleSize;
    this.sampleSizes = sampleSizes;
    this.sampleDur = sampleDur;
    this.sampleDurs = sampleDurs;
    this.entry = entry;
};
Chunk = stjs.extend(Chunk, null, [], function(constructor, prototype) {
    prototype.offset = 0;
    prototype.startTv = 0;
    prototype.sampleCount = 0;
    prototype.sampleSize = 0;
    prototype.sampleSizes = null;
    prototype.sampleDur = 0;
    prototype.sampleDurs = null;
    prototype.entry = 0;
    prototype.getOffset = function() {
        return this.offset;
    };
    prototype.getStartTv = function() {
        return this.startTv;
    };
    prototype.getSampleCount = function() {
        return this.sampleCount;
    };
    prototype.getSampleSize = function() {
        return this.sampleSize;
    };
    prototype.getSampleSizes = function() {
        return this.sampleSizes;
    };
    prototype.getSampleDur = function() {
        return this.sampleDur;
    };
    prototype.getSampleDurs = function() {
        return this.sampleDurs;
    };
    prototype.getEntry = function() {
        return this.entry;
    };
    prototype.getDuration = function() {
        if (this.sampleDur > 0) 
            return this.sampleDur * this.sampleCount;
        var sum = 0;
        for (var j = 0; j < this.sampleDurs.length; j++) {
            var i = this.sampleDurs[j];
            sum += i;
        }
        return sum;
    };
    prototype.getSize = function() {
        if (this.sampleSize > 0) 
            return this.sampleSize * this.sampleCount;
        var sum = 0;
        for (var j = 0; j < this.sampleSizes.length; j++) {
            var i = this.sampleSizes[j];
            sum += i;
        }
        return sum;
    };
}, {sampleSizes: "Int32Array", sampleDurs: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SoundFilter = function() {};
SoundFilter = stjs.extend(SoundFilter, null, [], function(constructor, prototype) {
    constructor.sine = new Int32Array([0, 1, 3, 4, 6, 7, 9, 10, 12, 14, 15, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 32, 34, 36, 37, 39, 40, 42, 43, 45, 47, 48, 50, 51, 53, 54, 56, 57, 59, 61, 62, 64, 65, 67, 68, 70, 72, 73, 75, 76, 78, 79, 81, 82, 84, 85, 87, 89, 90, 92, 93, 95, 96, 98, 99, 101, 102, 104, 106, 107, 109, 110, 112, 113, 115, 116, 118, 119, 121, 122, 124, 125, 127, 128, 130, 132, 133, 135, 136, 138, 139, 141, 142, 144, 145, 147, 148, 150, 151, 153, 154, 156, 157, 159, 160, 162, 163, 165, 166, 168, 169, 171, 172, 173, 175, 176, 178, 179, 181, 182, 184, 185, 187, 188, 190, 191, 193, 194, 195, 197, 198, 200, 201, 203, 204, 206, 207, 208, 210, 211, 213, 214, 216, 217, 218, 220, 221, 223, 224, 225, 227, 228, 230, 231, 233, 234, 235, 237, 238, 239, 241, 242, 244, 245, 246, 248, 249, 250, 252, 253, 255, 256, 257, 259, 260, 261, 263, 264, 265, 267, 268, 269, 271, 272, 273, 275, 276, 277, 279, 280, 281, 283, 284, 285, 287, 288, 289, 290, 292, 293, 294, 296, 297, 298, 299, 301, 302, 303, 304, 306, 307, 308, 310, 311, 312, 313, 314, 316, 317, 318, 319, 321, 322, 323, 324, 326, 327, 328, 329, 330, 332, 333, 334, 335, 336, 337, 339, 340, 341, 342, 343, 345, 346, 347, 348, 349, 350, 351, 353, 354, 355, 356, 357, 358, 359, 360, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 423, 424, 425, 426, 427, 428, 429, 430, 430, 431, 432, 433, 434, 435, 435, 436, 437, 438, 439, 439, 440, 441, 442, 443, 443, 444, 445, 446, 447, 447, 448, 449, 450, 450, 451, 452, 453, 453, 454, 455, 455, 456, 457, 458, 458, 459, 460, 460, 461, 462, 462, 463, 464, 464, 465, 466, 466, 467, 468, 468, 469, 469, 470, 471, 471, 472, 473, 473, 474, 474, 475, 475, 476, 477, 477, 478, 478, 479, 479, 480, 481, 481, 482, 482, 483, 483, 484, 484, 485, 485, 486, 486, 487, 487, 488, 488, 489, 489, 489, 490, 490, 491, 491, 492, 492, 493, 493, 493, 494, 494, 495, 495, 495, 496, 496, 497, 497, 497, 498, 498, 498, 499, 499, 499, 500, 500, 500, 501, 501, 501, 502, 502, 502, 503, 503, 503, 503, 504, 504, 504, 504, 505, 505, 505, 505, 506, 506, 506, 506, 507, 507, 507, 507, 507, 508, 508, 508, 508, 508, 509, 509, 509, 509, 509, 509, 509, 510, 510, 510, 510, 510, 510, 510, 510, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511]);
    constructor.linear = new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]);
    constructor.in16BitSignedLE = function(b, nCh, func) {
        var to = Math.min(b.length * nCh * 2, func.length);
        var off = 0;
        for (var i = 0; i < to; i++) {
            for (var j = 0; j < nCh; j++) {
                var sample = ((((b[off] & 255) | ((b[off + 1] & 255) << 8))) << 16 >> 16);
                sample = ((((sample * func[i]) >> 9)) << 16 >> 16);
                b[off] = ((sample & 255) << 24 >> 24);
                b[off + 1] = ((sample >> 8) << 24 >> 24);
                off += 2;
            }
        }
    };
    constructor.out16BitSignedLE = function(b, nCh, func) {
        var to = Math.min(b.length * nCh * 2, func.length);
        var off = b.length - (to * nCh * 2);
        for (var i = 0; i < to; i++) {
            for (var j = 0; j < nCh; j++) {
                var sample = ((((b[off] & 255) | ((b[off + 1] & 255) << 8))) << 16 >> 16);
                sample = ((((sample * func[512 - i - 1]) >> 9)) << 16 >> 16);
                b[off] = ((sample & 255) << 24 >> 24);
                b[off + 1] = ((sample >> 8) << 24 >> 24);
                off += 2;
            }
        }
    };
    constructor._in = function(fmt, samples, func) {
        SoundFilter.in16BitSignedLE(samples, fmt.getChannels(), func);
    };
    constructor.out = function(fmt, samples, func) {
        SoundFilter.out16BitSignedLE(samples, fmt.getChannels(), func);
    };
}, {sine: "Int32Array", linear: "Int32Array"}, {});
/**
 *  Contains functions to manager a 31 bit packed mv
 */
var MV = function() {};
MV = stjs.extend(MV, null, [], function(constructor, prototype) {
    constructor.create = function(x, y, ref) {
        return (ref << 28) | ((y & 16383) << 14) | (x & 16383);
    };
    constructor.x = function(mv) {
        return (mv << 18) >> 18;
    };
    constructor.y = function(mv) {
        return (mv << 4) >> 18;
    };
    constructor.ref = function(mv) {
        return (mv >> 28) & 3;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Frame = function(pic, pts, duration, pixelAspect, frameNo, tapeTimecode, messages) {
    this.pic = pic;
    this.pts = pts;
    this.duration = duration;
    this.pixelAspect = pixelAspect;
    this.tapeTimecode = tapeTimecode;
    this.frameNo = frameNo;
    this.messages = messages;
};
Frame = stjs.extend(Frame, null, [], function(constructor, prototype) {
    prototype.pic = null;
    prototype.pts = null;
    prototype.duration = null;
    prototype.pixelAspect = null;
    prototype.tapeTimecode = null;
    prototype.frameNo = 0;
    prototype.messages = null;
    prototype.getPic = function() {
        return this.pic;
    };
    prototype.getPts = function() {
        return this.pts;
    };
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getPixelAspect = function() {
        return this.pixelAspect;
    };
    prototype.getTapeTimecode = function() {
        return this.tapeTimecode;
    };
    prototype.getFrameNo = function() {
        return this.frameNo;
    };
    prototype.getMessages = function() {
        return this.messages;
    };
    prototype.isAvailable = function() {
        return true;
    };
}, {pic: "Picture", pts: "RationalLarge", duration: "RationalLarge", pixelAspect: "Rational", tapeTimecode: "TapeTimecode", messages: {name: "List", arguments: [null]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEGEncoder = function() {};
MPEGEncoder = stjs.extend(MPEGEncoder, null, [], null, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Probabilities = function() {};
Probabilities = stjs.extend(Probabilities, null, [], function(constructor, prototype) {
    constructor.default_partition_probs = [new Int32Array([199, 122, 141]), new Int32Array([147, 63, 159]), new Int32Array([148, 133, 118]), new Int32Array([121, 104, 114]), new Int32Array([174, 73, 87]), new Int32Array([92, 41, 83]), new Int32Array([82, 99, 50]), new Int32Array([53, 39, 39]), new Int32Array([177, 58, 59]), new Int32Array([68, 26, 63]), new Int32Array([52, 79, 25]), new Int32Array([17, 14, 12]), new Int32Array([222, 34, 30]), new Int32Array([72, 16, 44]), new Int32Array([58, 32, 12]), new Int32Array([10, 7, 6])];
    constructor.default_skip_prob = new Int32Array([192, 128, 64]);
    constructor.default_tx_probs = [[new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([100, 0, 0]), new Int32Array([66, 0, 0])], [new Int32Array([20, 152, 0]), new Int32Array([15, 101, 0])], [new Int32Array([3, 136, 37]), new Int32Array([5, 52, 13])]];
    constructor.default_is_inter_probs = new Int32Array([9, 102, 187, 225]);
    constructor.kf_y_mode_probs = [[new Int32Array([137, 30, 42, 148, 151, 207, 70, 52, 91]), new Int32Array([92, 45, 102, 136, 116, 180, 74, 90, 100]), new Int32Array([73, 32, 19, 187, 222, 215, 46, 34, 100]), new Int32Array([91, 30, 32, 116, 121, 186, 93, 86, 94]), new Int32Array([72, 35, 36, 149, 68, 206, 68, 63, 105]), new Int32Array([73, 31, 28, 138, 57, 124, 55, 122, 151]), new Int32Array([67, 23, 21, 140, 126, 197, 40, 37, 171]), new Int32Array([86, 27, 28, 128, 154, 212, 45, 43, 53]), new Int32Array([74, 32, 27, 107, 86, 160, 63, 134, 102]), new Int32Array([59, 67, 44, 140, 161, 202, 78, 67, 119])], [new Int32Array([63, 36, 126, 146, 123, 158, 60, 90, 96]), new Int32Array([43, 46, 168, 134, 107, 128, 69, 142, 92]), new Int32Array([44, 29, 68, 159, 201, 177, 50, 57, 77]), new Int32Array([58, 38, 76, 114, 97, 172, 78, 133, 92]), new Int32Array([46, 41, 76, 140, 63, 184, 69, 112, 57]), new Int32Array([38, 32, 85, 140, 46, 112, 54, 151, 133]), new Int32Array([39, 27, 61, 131, 110, 175, 44, 75, 136]), new Int32Array([52, 30, 74, 113, 130, 175, 51, 64, 58]), new Int32Array([47, 35, 80, 100, 74, 143, 64, 163, 74]), new Int32Array([36, 61, 116, 114, 128, 162, 80, 125, 82])], [new Int32Array([82, 26, 26, 171, 208, 204, 44, 32, 105]), new Int32Array([55, 44, 68, 166, 179, 192, 57, 57, 108]), new Int32Array([42, 26, 11, 199, 241, 228, 23, 15, 85]), new Int32Array([68, 42, 19, 131, 160, 199, 55, 52, 83]), new Int32Array([58, 50, 25, 139, 115, 232, 39, 52, 118]), new Int32Array([50, 35, 33, 153, 104, 162, 64, 59, 131]), new Int32Array([44, 24, 16, 150, 177, 202, 33, 19, 156]), new Int32Array([55, 27, 12, 153, 203, 218, 26, 27, 49]), new Int32Array([53, 49, 21, 110, 116, 168, 59, 80, 76]), new Int32Array([38, 72, 19, 168, 203, 212, 50, 50, 107])], [new Int32Array([103, 26, 36, 129, 132, 201, 83, 80, 93]), new Int32Array([59, 38, 83, 112, 103, 162, 98, 136, 90]), new Int32Array([62, 30, 23, 158, 200, 207, 59, 57, 50]), new Int32Array([67, 30, 29, 84, 86, 191, 102, 91, 59]), new Int32Array([60, 32, 33, 112, 71, 220, 64, 89, 104]), new Int32Array([53, 26, 34, 130, 56, 149, 84, 120, 103]), new Int32Array([53, 21, 23, 133, 109, 210, 56, 77, 172]), new Int32Array([77, 19, 29, 112, 142, 228, 55, 66, 36]), new Int32Array([61, 29, 29, 93, 97, 165, 83, 175, 162]), new Int32Array([47, 47, 43, 114, 137, 181, 100, 99, 95])], [new Int32Array([69, 23, 29, 128, 83, 199, 46, 44, 101]), new Int32Array([53, 40, 55, 139, 69, 183, 61, 80, 110]), new Int32Array([40, 29, 19, 161, 180, 207, 43, 24, 91]), new Int32Array([60, 34, 19, 105, 61, 198, 53, 64, 89]), new Int32Array([52, 31, 22, 158, 40, 209, 58, 62, 89]), new Int32Array([44, 31, 29, 147, 46, 158, 56, 102, 198]), new Int32Array([35, 19, 12, 135, 87, 209, 41, 45, 167]), new Int32Array([55, 25, 21, 118, 95, 215, 38, 39, 66]), new Int32Array([51, 38, 25, 113, 58, 164, 70, 93, 97]), new Int32Array([47, 54, 34, 146, 108, 203, 72, 103, 151])], [new Int32Array([64, 19, 37, 156, 66, 138, 49, 95, 133]), new Int32Array([46, 27, 80, 150, 55, 124, 55, 121, 135]), new Int32Array([36, 23, 27, 165, 149, 166, 54, 64, 118]), new Int32Array([53, 21, 36, 131, 63, 163, 60, 109, 81]), new Int32Array([40, 26, 35, 154, 40, 185, 51, 97, 123]), new Int32Array([35, 19, 34, 179, 19, 97, 48, 129, 124]), new Int32Array([36, 20, 26, 136, 62, 164, 33, 77, 154]), new Int32Array([45, 18, 32, 130, 90, 157, 40, 79, 91]), new Int32Array([45, 26, 28, 129, 45, 129, 49, 147, 123]), new Int32Array([38, 44, 51, 136, 74, 162, 57, 97, 121])], [new Int32Array([75, 17, 22, 136, 138, 185, 32, 34, 166]), new Int32Array([56, 39, 58, 133, 117, 173, 48, 53, 187]), new Int32Array([35, 21, 12, 161, 212, 207, 20, 23, 145]), new Int32Array([56, 29, 19, 117, 109, 181, 55, 68, 112]), new Int32Array([47, 29, 17, 153, 64, 220, 59, 51, 114]), new Int32Array([46, 16, 24, 136, 76, 147, 41, 64, 172]), new Int32Array([34, 17, 11, 108, 152, 187, 13, 15, 209]), new Int32Array([51, 24, 14, 115, 133, 209, 32, 26, 104]), new Int32Array([55, 30, 18, 122, 79, 179, 44, 88, 116]), new Int32Array([37, 49, 25, 129, 168, 164, 41, 54, 148])], [new Int32Array([82, 22, 32, 127, 143, 213, 39, 41, 70]), new Int32Array([62, 44, 61, 123, 105, 189, 48, 57, 64]), new Int32Array([47, 25, 17, 175, 222, 220, 24, 30, 86]), new Int32Array([68, 36, 17, 106, 102, 206, 59, 74, 74]), new Int32Array([57, 39, 23, 151, 68, 216, 55, 63, 58]), new Int32Array([49, 30, 35, 141, 70, 168, 82, 40, 115]), new Int32Array([51, 25, 15, 136, 129, 202, 38, 35, 139]), new Int32Array([68, 26, 16, 111, 141, 215, 29, 28, 28]), new Int32Array([59, 39, 19, 114, 75, 180, 77, 104, 42]), new Int32Array([40, 61, 26, 126, 152, 206, 61, 59, 93])], [new Int32Array([78, 23, 39, 111, 117, 170, 74, 124, 94]), new Int32Array([48, 34, 86, 101, 92, 146, 78, 179, 134]), new Int32Array([47, 22, 24, 138, 187, 178, 68, 69, 59]), new Int32Array([56, 25, 33, 105, 112, 187, 95, 177, 129]), new Int32Array([48, 31, 27, 114, 63, 183, 82, 116, 56]), new Int32Array([43, 28, 37, 121, 63, 123, 61, 192, 169]), new Int32Array([42, 17, 24, 109, 97, 177, 56, 76, 122]), new Int32Array([58, 18, 28, 105, 139, 182, 70, 92, 63]), new Int32Array([46, 23, 32, 74, 86, 150, 67, 183, 88]), new Int32Array([36, 38, 48, 92, 122, 165, 88, 137, 91])], [new Int32Array([65, 70, 60, 155, 159, 199, 61, 60, 81]), new Int32Array([44, 78, 115, 132, 119, 173, 71, 112, 93]), new Int32Array([39, 38, 21, 184, 227, 206, 42, 32, 64]), new Int32Array([58, 47, 36, 124, 137, 193, 80, 82, 78]), new Int32Array([49, 50, 35, 144, 95, 205, 63, 78, 59]), new Int32Array([41, 53, 52, 148, 71, 142, 65, 128, 51]), new Int32Array([40, 36, 28, 143, 143, 202, 40, 55, 137]), new Int32Array([52, 34, 29, 129, 183, 227, 42, 35, 43]), new Int32Array([42, 44, 44, 104, 105, 164, 64, 130, 80]), new Int32Array([43, 81, 53, 140, 169, 204, 68, 84, 72])]];
    constructor.kf_uv_mode_probs = [new Int32Array([144, 11, 54, 157, 195, 130, 46, 58, 108]), new Int32Array([118, 15, 123, 148, 131, 101, 44, 93, 131]), new Int32Array([113, 12, 23, 188, 226, 142, 26, 32, 125]), new Int32Array([120, 11, 50, 123, 163, 135, 64, 77, 103]), new Int32Array([113, 9, 36, 155, 111, 157, 32, 44, 161]), new Int32Array([116, 9, 55, 176, 76, 96, 37, 61, 149]), new Int32Array([115, 9, 28, 141, 161, 167, 21, 25, 193]), new Int32Array([120, 12, 32, 145, 195, 142, 32, 38, 86]), new Int32Array([116, 12, 64, 120, 140, 125, 49, 115, 121]), new Int32Array([102, 19, 66, 162, 182, 122, 35, 59, 128])];
    constructor.default_y_mode_probs = [new Int32Array([65, 32, 18, 144, 162, 194, 41, 51, 98]), new Int32Array([132, 68, 18, 165, 217, 196, 45, 40, 78]), new Int32Array([173, 80, 19, 176, 240, 193, 64, 35, 46]), new Int32Array([221, 135, 38, 194, 248, 121, 96, 85, 29])];
    constructor.default_uv_mode_probs = [new Int32Array([120, 7, 76, 176, 208, 126, 28, 54, 103]), new Int32Array([48, 12, 154, 155, 139, 90, 34, 117, 119]), new Int32Array([67, 6, 25, 204, 243, 158, 13, 21, 96]), new Int32Array([97, 5, 44, 131, 176, 139, 48, 68, 97]), new Int32Array([83, 5, 42, 156, 111, 152, 26, 49, 152]), new Int32Array([80, 5, 58, 178, 74, 83, 33, 62, 145]), new Int32Array([86, 5, 32, 154, 192, 168, 14, 22, 163]), new Int32Array([85, 5, 32, 156, 216, 148, 19, 29, 73]), new Int32Array([77, 7, 64, 116, 132, 122, 37, 126, 120]), new Int32Array([101, 21, 107, 181, 192, 103, 19, 67, 125])];
    constructor.default_single_ref_prob = [new Int32Array([33, 16]), new Int32Array([77, 74]), new Int32Array([142, 142]), new Int32Array([172, 170]), new Int32Array([238, 247])];
    constructor.default_comp_ref_prob = new Int32Array([50, 126, 123, 221, 226]);
    constructor.default_interp_filter_probs = [new Int32Array([235, 162]), new Int32Array([36, 255]), new Int32Array([34, 3]), new Int32Array([149, 144])];
    constructor.default_inter_mode_probs = [new Int32Array([2, 173, 34]), new Int32Array([7, 145, 85]), new Int32Array([7, 166, 63]), new Int32Array([7, 94, 66]), new Int32Array([8, 64, 46]), new Int32Array([17, 81, 31]), new Int32Array([25, 29, 30])];
    constructor.default_mv_joint_probs = new Int32Array([32, 64, 96]);
    constructor.default_mv_bits_prob = [new Int32Array([136, 140, 148, 160, 176, 192, 224, 234, 234, 240]), new Int32Array([136, 140, 148, 160, 176, 192, 224, 234, 234, 240])];
    constructor.default_mv_class0_bit_prob = new Int32Array([216, 208]);
    constructor.default_mv_class0_hp_prob = new Int32Array([160, 160]);
    constructor.coef_probs = [[[[[new Int32Array([195, 29, 183]), new Int32Array([84, 49, 136]), new Int32Array([8, 42, 71]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([31, 107, 169]), new Int32Array([35, 99, 159]), new Int32Array([17, 82, 140]), new Int32Array([8, 66, 114]), new Int32Array([2, 44, 76]), new Int32Array([1, 19, 32])], [new Int32Array([40, 132, 201]), new Int32Array([29, 114, 187]), new Int32Array([13, 91, 157]), new Int32Array([7, 75, 127]), new Int32Array([3, 58, 95]), new Int32Array([1, 28, 47])], [new Int32Array([69, 142, 221]), new Int32Array([42, 122, 201]), new Int32Array([15, 91, 159]), new Int32Array([6, 67, 121]), new Int32Array([1, 42, 77]), new Int32Array([1, 17, 31])], [new Int32Array([102, 148, 228]), new Int32Array([67, 117, 204]), new Int32Array([17, 82, 154]), new Int32Array([6, 59, 114]), new Int32Array([2, 39, 75]), new Int32Array([1, 15, 29])], [new Int32Array([156, 57, 233]), new Int32Array([119, 57, 212]), new Int32Array([58, 48, 163]), new Int32Array([29, 40, 124]), new Int32Array([12, 30, 81]), new Int32Array([3, 12, 31])]], [[new Int32Array([191, 107, 226]), new Int32Array([124, 117, 204]), new Int32Array([25, 99, 155]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([29, 148, 210]), new Int32Array([37, 126, 194]), new Int32Array([8, 93, 157]), new Int32Array([2, 68, 118]), new Int32Array([1, 39, 69]), new Int32Array([1, 17, 33])], [new Int32Array([41, 151, 213]), new Int32Array([27, 123, 193]), new Int32Array([3, 82, 144]), new Int32Array([1, 58, 105]), new Int32Array([1, 32, 60]), new Int32Array([1, 13, 26])], [new Int32Array([59, 159, 220]), new Int32Array([23, 126, 198]), new Int32Array([4, 88, 151]), new Int32Array([1, 66, 114]), new Int32Array([1, 38, 71]), new Int32Array([1, 18, 34])], [new Int32Array([114, 136, 232]), new Int32Array([51, 114, 207]), new Int32Array([11, 83, 155]), new Int32Array([3, 56, 105]), new Int32Array([1, 33, 65]), new Int32Array([1, 17, 34])], [new Int32Array([149, 65, 234]), new Int32Array([121, 57, 215]), new Int32Array([61, 49, 166]), new Int32Array([28, 36, 114]), new Int32Array([12, 25, 76]), new Int32Array([3, 16, 42])]]], [[[new Int32Array([214, 49, 220]), new Int32Array([132, 63, 188]), new Int32Array([42, 65, 137]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([85, 137, 221]), new Int32Array([104, 131, 216]), new Int32Array([49, 111, 192]), new Int32Array([21, 87, 155]), new Int32Array([2, 49, 87]), new Int32Array([1, 16, 28])], [new Int32Array([89, 163, 230]), new Int32Array([90, 137, 220]), new Int32Array([29, 100, 183]), new Int32Array([10, 70, 135]), new Int32Array([2, 42, 81]), new Int32Array([1, 17, 33])], [new Int32Array([108, 167, 237]), new Int32Array([55, 133, 222]), new Int32Array([15, 97, 179]), new Int32Array([4, 72, 135]), new Int32Array([1, 45, 85]), new Int32Array([1, 19, 38])], [new Int32Array([124, 146, 240]), new Int32Array([66, 124, 224]), new Int32Array([17, 88, 175]), new Int32Array([4, 58, 122]), new Int32Array([1, 36, 75]), new Int32Array([1, 18, 37])], [new Int32Array([141, 79, 241]), new Int32Array([126, 70, 227]), new Int32Array([66, 58, 182]), new Int32Array([30, 44, 136]), new Int32Array([12, 34, 96]), new Int32Array([2, 20, 47])]], [[new Int32Array([229, 99, 249]), new Int32Array([143, 111, 235]), new Int32Array([46, 109, 192]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([82, 158, 236]), new Int32Array([94, 146, 224]), new Int32Array([25, 117, 191]), new Int32Array([9, 87, 149]), new Int32Array([3, 56, 99]), new Int32Array([1, 33, 57])], [new Int32Array([83, 167, 237]), new Int32Array([68, 145, 222]), new Int32Array([10, 103, 177]), new Int32Array([2, 72, 131]), new Int32Array([1, 41, 79]), new Int32Array([1, 20, 39])], [new Int32Array([99, 167, 239]), new Int32Array([47, 141, 224]), new Int32Array([10, 104, 178]), new Int32Array([2, 73, 133]), new Int32Array([1, 44, 85]), new Int32Array([1, 22, 47])], [new Int32Array([127, 145, 243]), new Int32Array([71, 129, 228]), new Int32Array([17, 93, 177]), new Int32Array([3, 61, 124]), new Int32Array([1, 41, 84]), new Int32Array([1, 21, 52])], [new Int32Array([157, 78, 244]), new Int32Array([140, 72, 231]), new Int32Array([69, 58, 184]), new Int32Array([31, 44, 137]), new Int32Array([14, 38, 105]), new Int32Array([8, 23, 61])]]]], [[[[new Int32Array([125, 34, 187]), new Int32Array([52, 41, 133]), new Int32Array([6, 31, 56]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([37, 109, 153]), new Int32Array([51, 102, 147]), new Int32Array([23, 87, 128]), new Int32Array([8, 67, 101]), new Int32Array([1, 41, 63]), new Int32Array([1, 19, 29])], [new Int32Array([31, 154, 185]), new Int32Array([17, 127, 175]), new Int32Array([6, 96, 145]), new Int32Array([2, 73, 114]), new Int32Array([1, 51, 82]), new Int32Array([1, 28, 45])], [new Int32Array([23, 163, 200]), new Int32Array([10, 131, 185]), new Int32Array([2, 93, 148]), new Int32Array([1, 67, 111]), new Int32Array([1, 41, 69]), new Int32Array([1, 14, 24])], [new Int32Array([29, 176, 217]), new Int32Array([12, 145, 201]), new Int32Array([3, 101, 156]), new Int32Array([1, 69, 111]), new Int32Array([1, 39, 63]), new Int32Array([1, 14, 23])], [new Int32Array([57, 192, 233]), new Int32Array([25, 154, 215]), new Int32Array([6, 109, 167]), new Int32Array([3, 78, 118]), new Int32Array([1, 48, 69]), new Int32Array([1, 21, 29])]], [[new Int32Array([202, 105, 245]), new Int32Array([108, 106, 216]), new Int32Array([18, 90, 144]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([33, 172, 219]), new Int32Array([64, 149, 206]), new Int32Array([14, 117, 177]), new Int32Array([5, 90, 141]), new Int32Array([2, 61, 95]), new Int32Array([1, 37, 57])], [new Int32Array([33, 179, 220]), new Int32Array([11, 140, 198]), new Int32Array([1, 89, 148]), new Int32Array([1, 60, 104]), new Int32Array([1, 33, 57]), new Int32Array([1, 12, 21])], [new Int32Array([30, 181, 221]), new Int32Array([8, 141, 198]), new Int32Array([1, 87, 145]), new Int32Array([1, 58, 100]), new Int32Array([1, 31, 55]), new Int32Array([1, 12, 20])], [new Int32Array([32, 186, 224]), new Int32Array([7, 142, 198]), new Int32Array([1, 86, 143]), new Int32Array([1, 58, 100]), new Int32Array([1, 31, 55]), new Int32Array([1, 12, 22])], [new Int32Array([57, 192, 227]), new Int32Array([20, 143, 204]), new Int32Array([3, 96, 154]), new Int32Array([1, 68, 112]), new Int32Array([1, 42, 69]), new Int32Array([1, 19, 32])]]], [[[new Int32Array([212, 35, 215]), new Int32Array([113, 47, 169]), new Int32Array([29, 48, 105]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([74, 129, 203]), new Int32Array([106, 120, 203]), new Int32Array([49, 107, 178]), new Int32Array([19, 84, 144]), new Int32Array([4, 50, 84]), new Int32Array([1, 15, 25])], [new Int32Array([71, 172, 217]), new Int32Array([44, 141, 209]), new Int32Array([15, 102, 173]), new Int32Array([6, 76, 133]), new Int32Array([2, 51, 89]), new Int32Array([1, 24, 42])], [new Int32Array([64, 185, 231]), new Int32Array([31, 148, 216]), new Int32Array([8, 103, 175]), new Int32Array([3, 74, 131]), new Int32Array([1, 46, 81]), new Int32Array([1, 18, 30])], [new Int32Array([65, 196, 235]), new Int32Array([25, 157, 221]), new Int32Array([5, 105, 174]), new Int32Array([1, 67, 120]), new Int32Array([1, 38, 69]), new Int32Array([1, 15, 30])], [new Int32Array([65, 204, 238]), new Int32Array([30, 156, 224]), new Int32Array([7, 107, 177]), new Int32Array([2, 70, 124]), new Int32Array([1, 42, 73]), new Int32Array([1, 18, 34])]], [[new Int32Array([225, 86, 251]), new Int32Array([144, 104, 235]), new Int32Array([42, 99, 181]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([85, 175, 239]), new Int32Array([112, 165, 229]), new Int32Array([29, 136, 200]), new Int32Array([12, 103, 162]), new Int32Array([6, 77, 123]), new Int32Array([2, 53, 84])], [new Int32Array([75, 183, 239]), new Int32Array([30, 155, 221]), new Int32Array([3, 106, 171]), new Int32Array([1, 74, 128]), new Int32Array([1, 44, 76]), new Int32Array([1, 17, 28])], [new Int32Array([73, 185, 240]), new Int32Array([27, 159, 222]), new Int32Array([2, 107, 172]), new Int32Array([1, 75, 127]), new Int32Array([1, 42, 73]), new Int32Array([1, 17, 29])], [new Int32Array([62, 190, 238]), new Int32Array([21, 159, 222]), new Int32Array([2, 107, 172]), new Int32Array([1, 72, 122]), new Int32Array([1, 40, 71]), new Int32Array([1, 18, 32])], [new Int32Array([61, 199, 240]), new Int32Array([27, 161, 226]), new Int32Array([4, 113, 180]), new Int32Array([1, 76, 129]), new Int32Array([1, 46, 80]), new Int32Array([1, 23, 41])]]]], [[[[new Int32Array([7, 27, 153]), new Int32Array([5, 30, 95]), new Int32Array([1, 16, 30]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([50, 75, 127]), new Int32Array([57, 75, 124]), new Int32Array([27, 67, 108]), new Int32Array([10, 54, 86]), new Int32Array([1, 33, 52]), new Int32Array([1, 12, 18])], [new Int32Array([43, 125, 151]), new Int32Array([26, 108, 148]), new Int32Array([7, 83, 122]), new Int32Array([2, 59, 89]), new Int32Array([1, 38, 60]), new Int32Array([1, 17, 27])], [new Int32Array([23, 144, 163]), new Int32Array([13, 112, 154]), new Int32Array([2, 75, 117]), new Int32Array([1, 50, 81]), new Int32Array([1, 31, 51]), new Int32Array([1, 14, 23])], [new Int32Array([18, 162, 185]), new Int32Array([6, 123, 171]), new Int32Array([1, 78, 125]), new Int32Array([1, 51, 86]), new Int32Array([1, 31, 54]), new Int32Array([1, 14, 23])], [new Int32Array([15, 199, 227]), new Int32Array([3, 150, 204]), new Int32Array([1, 91, 146]), new Int32Array([1, 55, 95]), new Int32Array([1, 30, 53]), new Int32Array([1, 11, 20])]], [[new Int32Array([19, 55, 240]), new Int32Array([19, 59, 196]), new Int32Array([3, 52, 105]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([41, 166, 207]), new Int32Array([104, 153, 199]), new Int32Array([31, 123, 181]), new Int32Array([14, 101, 152]), new Int32Array([5, 72, 106]), new Int32Array([1, 36, 52])], [new Int32Array([35, 176, 211]), new Int32Array([12, 131, 190]), new Int32Array([2, 88, 144]), new Int32Array([1, 60, 101]), new Int32Array([1, 36, 60]), new Int32Array([1, 16, 28])], [new Int32Array([28, 183, 213]), new Int32Array([8, 134, 191]), new Int32Array([1, 86, 142]), new Int32Array([1, 56, 96]), new Int32Array([1, 30, 53]), new Int32Array([1, 12, 20])], [new Int32Array([20, 190, 215]), new Int32Array([4, 135, 192]), new Int32Array([1, 84, 139]), new Int32Array([1, 53, 91]), new Int32Array([1, 28, 49]), new Int32Array([1, 11, 20])], [new Int32Array([13, 196, 216]), new Int32Array([2, 137, 192]), new Int32Array([1, 86, 143]), new Int32Array([1, 57, 99]), new Int32Array([1, 32, 56]), new Int32Array([1, 13, 24])]]], [[[new Int32Array([211, 29, 217]), new Int32Array([96, 47, 156]), new Int32Array([22, 43, 87]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([78, 120, 193]), new Int32Array([111, 116, 186]), new Int32Array([46, 102, 164]), new Int32Array([15, 80, 128]), new Int32Array([2, 49, 76]), new Int32Array([1, 18, 28])], [new Int32Array([71, 161, 203]), new Int32Array([42, 132, 192]), new Int32Array([10, 98, 150]), new Int32Array([3, 69, 109]), new Int32Array([1, 44, 70]), new Int32Array([1, 18, 29])], [new Int32Array([57, 186, 211]), new Int32Array([30, 140, 196]), new Int32Array([4, 93, 146]), new Int32Array([1, 62, 102]), new Int32Array([1, 38, 65]), new Int32Array([1, 16, 27])], [new Int32Array([47, 199, 217]), new Int32Array([14, 145, 196]), new Int32Array([1, 88, 142]), new Int32Array([1, 57, 98]), new Int32Array([1, 36, 62]), new Int32Array([1, 15, 26])], [new Int32Array([26, 219, 229]), new Int32Array([5, 155, 207]), new Int32Array([1, 94, 151]), new Int32Array([1, 60, 104]), new Int32Array([1, 36, 62]), new Int32Array([1, 16, 28])]], [[new Int32Array([233, 29, 248]), new Int32Array([146, 47, 220]), new Int32Array([43, 52, 140]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([100, 163, 232]), new Int32Array([179, 161, 222]), new Int32Array([63, 142, 204]), new Int32Array([37, 113, 174]), new Int32Array([26, 89, 137]), new Int32Array([18, 68, 97])], [new Int32Array([85, 181, 230]), new Int32Array([32, 146, 209]), new Int32Array([7, 100, 164]), new Int32Array([3, 71, 121]), new Int32Array([1, 45, 77]), new Int32Array([1, 18, 30])], [new Int32Array([65, 187, 230]), new Int32Array([20, 148, 207]), new Int32Array([2, 97, 159]), new Int32Array([1, 68, 116]), new Int32Array([1, 40, 70]), new Int32Array([1, 14, 29])], [new Int32Array([40, 194, 227]), new Int32Array([8, 147, 204]), new Int32Array([1, 94, 155]), new Int32Array([1, 65, 112]), new Int32Array([1, 39, 66]), new Int32Array([1, 14, 26])], [new Int32Array([16, 208, 228]), new Int32Array([3, 151, 207]), new Int32Array([1, 98, 160]), new Int32Array([1, 67, 117]), new Int32Array([1, 41, 74]), new Int32Array([1, 17, 31])]]]], [[[[new Int32Array([17, 38, 140]), new Int32Array([7, 34, 80]), new Int32Array([1, 17, 29]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([37, 75, 128]), new Int32Array([41, 76, 128]), new Int32Array([26, 66, 116]), new Int32Array([12, 52, 94]), new Int32Array([2, 32, 55]), new Int32Array([1, 10, 16])], [new Int32Array([50, 127, 154]), new Int32Array([37, 109, 152]), new Int32Array([16, 82, 121]), new Int32Array([5, 59, 85]), new Int32Array([1, 35, 54]), new Int32Array([1, 13, 20])], [new Int32Array([40, 142, 167]), new Int32Array([17, 110, 157]), new Int32Array([2, 71, 112]), new Int32Array([1, 44, 72]), new Int32Array([1, 27, 45]), new Int32Array([1, 11, 17])], [new Int32Array([30, 175, 188]), new Int32Array([9, 124, 169]), new Int32Array([1, 74, 116]), new Int32Array([1, 48, 78]), new Int32Array([1, 30, 49]), new Int32Array([1, 11, 18])], [new Int32Array([10, 222, 223]), new Int32Array([2, 150, 194]), new Int32Array([1, 83, 128]), new Int32Array([1, 48, 79]), new Int32Array([1, 27, 45]), new Int32Array([1, 11, 17])]], [[new Int32Array([36, 41, 235]), new Int32Array([29, 36, 193]), new Int32Array([10, 27, 111]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([85, 165, 222]), new Int32Array([177, 162, 215]), new Int32Array([110, 135, 195]), new Int32Array([57, 113, 168]), new Int32Array([23, 83, 120]), new Int32Array([10, 49, 61])], [new Int32Array([85, 190, 223]), new Int32Array([36, 139, 200]), new Int32Array([5, 90, 146]), new Int32Array([1, 60, 103]), new Int32Array([1, 38, 65]), new Int32Array([1, 18, 30])], [new Int32Array([72, 202, 223]), new Int32Array([23, 141, 199]), new Int32Array([2, 86, 140]), new Int32Array([1, 56, 97]), new Int32Array([1, 36, 61]), new Int32Array([1, 16, 27])], [new Int32Array([55, 218, 225]), new Int32Array([13, 145, 200]), new Int32Array([1, 86, 141]), new Int32Array([1, 57, 99]), new Int32Array([1, 35, 61]), new Int32Array([1, 13, 22])], [new Int32Array([15, 235, 212]), new Int32Array([1, 132, 184]), new Int32Array([1, 84, 139]), new Int32Array([1, 57, 97]), new Int32Array([1, 34, 56]), new Int32Array([1, 14, 23])]]], [[[new Int32Array([181, 21, 201]), new Int32Array([61, 37, 123]), new Int32Array([10, 38, 71]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([47, 106, 172]), new Int32Array([95, 104, 173]), new Int32Array([42, 93, 159]), new Int32Array([18, 77, 131]), new Int32Array([4, 50, 81]), new Int32Array([1, 17, 23])], [new Int32Array([62, 147, 199]), new Int32Array([44, 130, 189]), new Int32Array([28, 102, 154]), new Int32Array([18, 75, 115]), new Int32Array([2, 44, 65]), new Int32Array([1, 12, 19])], [new Int32Array([55, 153, 210]), new Int32Array([24, 130, 194]), new Int32Array([3, 93, 146]), new Int32Array([1, 61, 97]), new Int32Array([1, 31, 50]), new Int32Array([1, 10, 16])], [new Int32Array([49, 186, 223]), new Int32Array([17, 148, 204]), new Int32Array([1, 96, 142]), new Int32Array([1, 53, 83]), new Int32Array([1, 26, 44]), new Int32Array([1, 11, 17])], [new Int32Array([13, 217, 212]), new Int32Array([2, 136, 180]), new Int32Array([1, 78, 124]), new Int32Array([1, 50, 83]), new Int32Array([1, 29, 49]), new Int32Array([1, 14, 23])]], [[new Int32Array([197, 13, 247]), new Int32Array([82, 17, 222]), new Int32Array([25, 17, 162]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0]), new Int32Array([0, 0, 0])], [new Int32Array([126, 186, 247]), new Int32Array([234, 191, 243]), new Int32Array([176, 177, 234]), new Int32Array([104, 158, 220]), new Int32Array([66, 128, 186]), new Int32Array([55, 90, 137])], [new Int32Array([111, 197, 242]), new Int32Array([46, 158, 219]), new Int32Array([9, 104, 171]), new Int32Array([2, 65, 125]), new Int32Array([1, 44, 80]), new Int32Array([1, 17, 91])], [new Int32Array([104, 208, 245]), new Int32Array([39, 168, 224]), new Int32Array([3, 109, 162]), new Int32Array([1, 79, 124]), new Int32Array([1, 50, 102]), new Int32Array([1, 43, 102])], [new Int32Array([84, 220, 246]), new Int32Array([31, 177, 231]), new Int32Array([2, 115, 180]), new Int32Array([1, 79, 134]), new Int32Array([1, 55, 77]), new Int32Array([1, 60, 79])], [new Int32Array([43, 243, 240]), new Int32Array([8, 180, 217]), new Int32Array([1, 115, 166]), new Int32Array([1, 84, 121]), new Int32Array([1, 51, 67]), new Int32Array([1, 16, 6])]]]]];
    prototype.getSegmentationPredProb = function() {
        return null;
    };
    prototype.getSegmentationTreeProbs = function() {
        return null;
    };
    prototype.getSkipProbs = function() {
        return null;
    };
    prototype.getTxProbs = function() {
        return null;
    };
    prototype.getIsInterProbs = function() {
        return null;
    };
    prototype.getKfYModeProbs = function() {
        return null;
    };
    prototype.getKfUVModeProbs = function() {
        return null;
    };
    prototype.getYModeProbs = function() {
        return null;
    };
    prototype.getUVModeProbs = function() {
        return null;
    };
    prototype.getCompModeProbs = function() {
        return null;
    };
    prototype.getCompRefProbs = function() {
        return null;
    };
    prototype.getSingleRefProbs = function() {
        return null;
    };
    prototype.getInterpFilterProbs = function() {
        return null;
    };
    prototype.getInterModeProbs = function() {
        return null;
    };
    prototype.getMvJointProbs = function() {
        return null;
    };
    prototype.getMvBitsProb = function() {
        return null;
    };
    prototype.getMvClass0bitProbs = function() {
        return null;
    };
    prototype.getMvClassProbs = function() {
        return null;
    };
    prototype.getMvClassFrProbs = function() {
        return null;
    };
    prototype.getMvFrProbs = function() {
        return null;
    };
    prototype.getMvClass0HpProbs = function() {
        return null;
    };
    prototype.getMvHpProbs = function() {
        return null;
    };
    prototype.getCoefProbs = function() {
        return null;
    };
    prototype.getPartitionProbs = function(ctx) {
        return null;
    };
}, {default_partition_probs: "Array", default_skip_prob: "Int32Array", default_tx_probs: "Array", default_is_inter_probs: "Int32Array", kf_y_mode_probs: "Array", kf_uv_mode_probs: "Array", default_y_mode_probs: "Array", default_uv_mode_probs: "Array", default_single_ref_prob: "Array", default_comp_ref_prob: "Int32Array", default_interp_filter_probs: "Array", default_inter_mode_probs: "Array", default_mv_joint_probs: "Int32Array", default_mv_bits_prob: "Array", default_mv_class0_bit_prob: "Int32Array", default_mv_class0_hp_prob: "Int32Array", coef_probs: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var IMDCTTables = function() {};
IMDCTTables = stjs.extend(IMDCTTables, null, [], function(constructor, prototype) {
    constructor.IMDCT_TABLE_256 = [new Float32Array([1.0, -0.0]), new Float32Array([0.9996988, -0.024541229]), new Float32Array([0.99879545, -0.049067676]), new Float32Array([0.99729043, -0.07356457]), new Float32Array([0.9951847, -0.09801714]), new Float32Array([0.99247956, -0.12241068]), new Float32Array([0.9891765, -0.14673047]), new Float32Array([0.98527765, -0.1709619]), new Float32Array([0.98078525, -0.19509032]), new Float32Array([0.9757021, -0.21910124]), new Float32Array([0.97003126, -0.2429802]), new Float32Array([0.96377605, -0.26671278]), new Float32Array([0.95694035, -0.29028466]), new Float32Array([0.94952816, -0.31368175]), new Float32Array([0.94154406, -0.33688986]), new Float32Array([0.9329928, -0.35989505]), new Float32Array([0.9238795, -0.38268346]), new Float32Array([0.9142097, -0.40524134]), new Float32Array([0.9039893, -0.42755508]), new Float32Array([0.8932243, -0.44961134]), new Float32Array([0.88192123, -0.47139674]), new Float32Array([0.87008697, -0.49289823]), new Float32Array([0.8577286, -0.51410276]), new Float32Array([0.8448536, -0.53499764]), new Float32Array([0.8314696, -0.55557024]), new Float32Array([0.8175848, -0.5758082]), new Float32Array([0.8032075, -0.5956993]), new Float32Array([0.7883464, -0.61523163]), new Float32Array([0.77301043, -0.63439333]), new Float32Array([0.7572088, -0.65317285]), new Float32Array([0.7409511, -0.671559]), new Float32Array([0.7242471, -0.68954057]), new Float32Array([0.70710677, -0.70710677]), new Float32Array([0.6895405, -0.7242471]), new Float32Array([0.6715589, -0.7409512]), new Float32Array([0.6531728, -0.7572089]), new Float32Array([0.6343933, -0.77301043]), new Float32Array([0.6152316, -0.7883464]), new Float32Array([0.5956993, -0.8032075]), new Float32Array([0.57580817, -0.8175848]), new Float32Array([0.5555702, -0.83146966]), new Float32Array([0.53499764, -0.8448536]), new Float32Array([0.5141027, -0.85772866]), new Float32Array([0.4928982, -0.87008697]), new Float32Array([0.47139665, -0.8819213]), new Float32Array([0.4496113, -0.8932243]), new Float32Array([0.4275551, -0.9039893]), new Float32Array([0.40524128, -0.9142098]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([0.35989496, -0.9329928]), new Float32Array([0.33688983, -0.94154406]), new Float32Array([0.31368166, -0.9495282]), new Float32Array([0.29028463, -0.95694035]), new Float32Array([0.26671275, -0.96377605]), new Float32Array([0.24298012, -0.97003126]), new Float32Array([0.21910122, -0.9757021]), new Float32Array([0.19509023, -0.9807853]), new Float32Array([0.17096186, -0.98527765]), new Float32Array([0.1467305, -0.9891765]), new Float32Array([0.122410625, -0.99247956]), new Float32Array([0.098017134, -0.9951847]), new Float32Array([0.07356449, -0.99729043]), new Float32Array([0.04906765, -0.99879545]), new Float32Array([0.024541136, -0.9996988]), new Float32Array([-4.371139E-8, -1.0]), new Float32Array([-0.024541223, -0.9996988]), new Float32Array([-0.04906774, -0.99879545]), new Float32Array([-0.073564574, -0.99729043]), new Float32Array([-0.09801722, -0.9951847]), new Float32Array([-0.12241071, -0.9924795]), new Float32Array([-0.14673057, -0.9891765]), new Float32Array([-0.17096195, -0.98527765]), new Float32Array([-0.19509032, -0.98078525]), new Float32Array([-0.21910131, -0.9757021]), new Float32Array([-0.2429802, -0.97003126]), new Float32Array([-0.26671284, -0.96377605]), new Float32Array([-0.29028472, -0.9569403]), new Float32Array([-0.31368172, -0.94952816]), new Float32Array([-0.33688992, -0.94154406]), new Float32Array([-0.35989505, -0.9329928]), new Float32Array([-0.38268352, -0.9238795]), new Float32Array([-0.40524134, -0.9142097]), new Float32Array([-0.42755508, -0.9039893]), new Float32Array([-0.44961137, -0.8932243]), new Float32Array([-0.47139683, -0.88192123]), new Float32Array([-0.49289817, -0.870087]), new Float32Array([-0.51410276, -0.8577286]), new Float32Array([-0.5349977, -0.8448535]), new Float32Array([-0.55557036, -0.83146954]), new Float32Array([-0.57580817, -0.8175848]), new Float32Array([-0.59569937, -0.8032075]), new Float32Array([-0.6152317, -0.78834635]), new Float32Array([-0.6343933, -0.7730105]), new Float32Array([-0.65317285, -0.7572088]), new Float32Array([-0.67155904, -0.74095106]), new Float32Array([-0.6895407, -0.724247]), new Float32Array([-0.70710677, -0.70710677]), new Float32Array([-0.72424716, -0.6895405]), new Float32Array([-0.74095124, -0.67155886]), new Float32Array([-0.7572088, -0.65317285]), new Float32Array([-0.7730105, -0.6343933]), new Float32Array([-0.78834647, -0.6152315]), new Float32Array([-0.80320764, -0.59569913]), new Float32Array([-0.8175848, -0.57580817]), new Float32Array([-0.83146966, -0.5555702]), new Float32Array([-0.84485364, -0.53499746]), new Float32Array([-0.8577286, -0.51410276]), new Float32Array([-0.870087, -0.49289814]), new Float32Array([-0.88192135, -0.47139663]), new Float32Array([-0.8932243, -0.44961137]), new Float32Array([-0.9039893, -0.42755505]), new Float32Array([-0.9142098, -0.40524122]), new Float32Array([-0.9238796, -0.38268328]), new Float32Array([-0.9329928, -0.35989505]), new Float32Array([-0.9415441, -0.3368898]), new Float32Array([-0.9495282, -0.3136816]), new Float32Array([-0.95694035, -0.29028472]), new Float32Array([-0.96377605, -0.26671273]), new Float32Array([-0.97003126, -0.24298008]), new Float32Array([-0.97570217, -0.21910107]), new Float32Array([-0.9807853, -0.19509031]), new Float32Array([-0.98527765, -0.17096181]), new Float32Array([-0.9891765, -0.14673033]), new Float32Array([-0.9924795, -0.1224107]), new Float32Array([-0.9951847, -0.0980171]), new Float32Array([-0.9972905, -0.07356445]), new Float32Array([-0.99879545, -0.049067486]), new Float32Array([-0.9996988, -0.02454121])];
    constructor.IMDCT_TABLE_32 = [new Float32Array([1.0, -0.0]), new Float32Array([0.98078525, -0.19509032]), new Float32Array([0.9238795, -0.38268346]), new Float32Array([0.8314696, -0.55557024]), new Float32Array([0.70710677, -0.70710677]), new Float32Array([0.5555702, -0.83146966]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([0.19509023, -0.9807853]), new Float32Array([-4.371139E-8, -1.0]), new Float32Array([-0.19509032, -0.98078525]), new Float32Array([-0.38268352, -0.9238795]), new Float32Array([-0.55557036, -0.83146954]), new Float32Array([-0.70710677, -0.70710677]), new Float32Array([-0.83146966, -0.5555702]), new Float32Array([-0.9238796, -0.38268328]), new Float32Array([-0.9807853, -0.19509031])];
    constructor.IMDCT_POST_TABLE_256 = [new Float32Array([0.49232805, 0.50766724, 0.50147516, 0.49840719]), new Float32Array([0.47697723, 0.5229804, 0.50407255, 0.4948688]), new Float32Array([0.46162924, 0.5382531, 0.50619966, 0.49086043]), new Float32Array([0.44629848, 0.5534709, 0.50785726, 0.4863832]), new Float32Array([0.43099934, 0.5686195, 0.5090466, 0.48143846]), new Float32Array([0.41574615, 0.58368444, 0.5097693, 0.47602817]), new Float32Array([0.40055317, 0.5986516, 0.5100275, 0.47015458]), new Float32Array([0.38543463, 0.6135067, 0.50982374, 0.46382055]), new Float32Array([0.37040454, 0.6282357, 0.5091608, 0.45702913]), new Float32Array([0.35547704, 0.64282453, 0.50804234, 0.4497841]), new Float32Array([0.34066594, 0.65725935, 0.506472, 0.44208938]), new Float32Array([0.32598507, 0.6715264, 0.5044541, 0.43394947]), new Float32Array([0.31144798, 0.6856121, 0.5019932, 0.42536932]), new Float32Array([0.29706824, 0.6995029, 0.4990945, 0.41635424]), new Float32Array([0.2828591, 0.7131856, 0.49576342, 0.40690988]), new Float32Array([0.26883373, 0.726647, 0.4920059, 0.39704242]), new Float32Array([0.25500503, 0.73987424, 0.48782825, 0.3867584]), new Float32Array([0.24138579, 0.7528547, 0.48323712, 0.3760647]), new Float32Array([0.22798851, 0.76557565, 0.4782396, 0.36496866]), new Float32Array([0.21482554, 0.7780249, 0.47284314, 0.35347793]), new Float32Array([0.20190886, 0.79019046, 0.46705556, 0.3416006]), new Float32Array([0.18925038, 0.8020605, 0.4608851, 0.3293451]), new Float32Array([0.17686158, 0.8136235, 0.45434028, 0.3167202]), new Float32Array([0.16475382, 0.8248682, 0.44743007, 0.30373502]), new Float32Array([0.15293804, 0.8357836, 0.44016364, 0.2903991]), new Float32Array([0.14142501, 0.84635913, 0.4325506, 0.2767222]), new Float32Array([0.13022512, 0.85658425, 0.42460087, 0.26271448]), new Float32Array([0.11934847, 0.86644906, 0.41632465, 0.24838635]), new Float32Array([0.10880476, 0.8759437, 0.40773243, 0.23374856]), new Float32Array([0.09860358, 0.8850589, 0.39883506, 0.21881217]), new Float32Array([0.08875397, 0.89378536, 0.38964373, 0.20358856]), new Float32Array([0.0792647, 0.9021145, 0.38016963, 0.18808924]), new Float32Array([0.07014418, 0.91003793, 0.37042463, 0.1723262]), new Float32Array([0.061400414, 0.91754776, 0.36042035, 0.1563114]), new Float32Array([0.05304113, 0.92463624, 0.35016915, 0.14005733]), new Float32Array([0.0450736, 0.9312961, 0.3396833, 0.12357649]), new Float32Array([0.037504703, 0.9375206, 0.32897532, 0.106881686]), new Float32Array([0.03034103, 0.9433032, 0.3180581, 0.08998602]), new Float32Array([0.023588628, 0.94863784, 0.30694458, 0.07290262]), new Float32Array([0.01725325, 0.95351887, 0.29564792, 0.055644885]), new Float32Array([0.011340171, 0.95794106, 0.28418133, 0.038226277]), new Float32Array([0.005854279, 0.9618995, 0.27255845, 0.020660654]), new Float32Array([8.0010295E-4, 0.96538985, 0.26079288, 0.0029617846]), new Float32Array([-0.003818363, 0.9684081, 0.24889828, -0.014856413]), new Float32Array([-0.007997453, 0.9709507, 0.23688862, -0.0327797]), new Float32Array([-0.011734039, 0.9730145, 0.22477779, -0.050794043]), new Float32Array([-0.015025228, 0.97459674, 0.21258, -0.06888495]), new Float32Array([-0.017868847, 0.97569525, 0.20030917, -0.08703829]), new Float32Array([-0.020262927, 0.9763082, 0.1879797, -0.10523948]), new Float32Array([-0.022206068, 0.9764342, 0.17560576, -0.12347408]), new Float32Array([-0.023697197, 0.9760722, 0.16320162, -0.14172764]), new Float32Array([-0.024735779, 0.9752219, 0.15078172, -0.15998542]), new Float32Array([-0.025321692, 0.97388303, 0.13836022, -0.17823319]), new Float32Array([-0.025455266, 0.97205615, 0.12595156, -0.19645613]), new Float32Array([-0.025137246, 0.96974206, 0.113570005, -0.21463984]), new Float32Array([-0.024368823, 0.966942, 0.10122979, -0.23276988]), new Float32Array([-0.023151666, 0.96365774, 0.088945225, -0.25083166]), new Float32Array([-0.021487802, 0.9598913, 0.07673041, -0.26881093]), new Float32Array([-0.019379854, 0.9556455, 0.06459953, -0.28669322]), new Float32Array([-0.016830623, 0.95092314, 0.0525665, -0.3044645]), new Float32Array([-0.013843596, 0.9457279, 0.04064539, -0.32211035]), new Float32Array([-0.010422587, 0.9400635, 0.02884984, -0.33961698]), new Float32Array([-0.0065717697, 0.9339343, 0.017193556, -0.35697052]), new Float32Array([-0.002295822, 0.92734504, 0.0056901723, -0.374157]), new Float32Array([0.0024001896, 0.92030096, -0.0056470186, -0.3911631]), new Float32Array([0.0075107515, 0.91280746, -0.016804636, -0.40797502]), new Float32Array([0.013030022, 0.90487075, -0.027769819, -0.4245798]), new Float32Array([0.018951744, 0.896497, -0.038529605, -0.44096428]), new Float32Array([0.025269121, 0.88769305, -0.049071252, -0.4571154]), new Float32Array([0.03197518, 0.8784661, -0.059382424, -0.47302073]), new Float32Array([0.03906241, 0.86882365, -0.06945078, -0.48866767]), new Float32Array([0.046523094, 0.85877365, -0.07926449, -0.5040442]), new Float32Array([0.054348946, 0.84832436, -0.08881168, -0.51913816]), new Float32Array([0.06253144, 0.8374845, -0.09808087, -0.533938]), new Float32Array([0.07106161, 0.82626295, -0.107060805, -0.5484321]), new Float32Array([0.079930276, 0.81466925, -0.11574057, -0.56260943]), new Float32Array([0.0891279, 0.8027128, -0.124109596, -0.57645917]), new Float32Array([0.098644555, 0.7904038, -0.13215744, -0.58997077]), new Float32Array([0.10847002, 0.7777525, -0.13987413, -0.6031339]), new Float32Array([0.11859363, 0.7647697, -0.14724979, -0.61593866]), new Float32Array([0.12900484, 0.75146604, -0.15427522, -0.6283754]), new Float32Array([0.13969228, 0.73785305, -0.16094121, -0.640435]), new Float32Array([0.15064475, 0.7239419, -0.16723916, -0.65210843]), new Float32Array([0.16185057, 0.7097445, -0.17316064, -0.6633872]), new Float32Array([0.1732978, 0.6952729, -0.1786977, -0.674263]), new Float32Array([0.18497421, 0.6805394, -0.18384269, -0.684728]), new Float32Array([0.19686763, 0.6655563, -0.18858838, -0.69477504]), new Float32Array([0.20896536, 0.65033644, -0.1929279, -0.7043968]), new Float32Array([0.22125456, 0.6348928, -0.19685477, -0.71358657]), new Float32Array([0.23372234, 0.61923826, -0.20036295, -0.7223382]), new Float32Array([0.24635552, 0.6033862, -0.20344675, -0.7306459]), new Float32Array([0.2591407, 0.58735025, -0.20610088, -0.73850405]), new Float32Array([0.27206418, 0.5711441, -0.2083205, -0.7459076]), new Float32Array([0.28511274, 0.554781, -0.21010125, -0.752852]), new Float32Array([0.2982724, 0.5382753, -0.21143904, -0.75933313]), new Float32Array([0.31152916, 0.521641, -0.21233031, -0.765347]), new Float32Array([0.3248692, 0.50489205, -0.21277195, -0.7708905]), new Float32Array([0.33827832, 0.48804274, -0.2127612, -0.77596056]), new Float32Array([0.3517424, 0.47110736, -0.21229571, -0.7805547]), new Float32Array([0.365247, 0.4541005, -0.21137378, -0.78467095]), new Float32Array([0.37877813, 0.43703625, -0.20999387, -0.78830767]), new Float32Array([0.39232132, 0.41992924, -0.20815507, -0.79146373]), new Float32Array([0.40586197, 0.40279418, -0.20585686, -0.79413843]), new Float32Array([0.4193862, 0.3856451, -0.20309913, -0.79633147]), new Float32Array([0.43287942, 0.36849675, -0.19988227, -0.798043]), new Float32Array([0.4463272, 0.3513636, -0.19620705, -0.79927367]), new Float32Array([0.45971522, 0.33426026, -0.19207478, -0.80002457]), new Float32Array([0.47302932, 0.3172009, -0.18748704, -0.80029714]), new Float32Array([0.48625526, 0.30019996, -0.18244597, -0.8000933]), new Float32Array([0.49937868, 0.2832719, -0.17695424, -0.79941547]), new Float32Array([0.51238585, 0.2664307, -0.1710147, -0.79826653]), new Float32Array([0.52526253, 0.24969055, -0.16463086, -0.7966496]), new Float32Array([0.53799486, 0.23306563, -0.15780658, -0.7945684]), new Float32Array([0.5505693, 0.21656957, -0.15054607, -0.7920271]), new Float32Array([0.5629722, 0.20021626, -0.14285406, -0.7890301]), new Float32Array([0.5751899, 0.18401925, -0.13473573, -0.7855824]), new Float32Array([0.5872092, 0.1679922, -0.12619662, -0.78168947]), new Float32Array([0.599017, 0.15214804, -0.117242515, -0.77735686]), new Float32Array([0.61060053, 0.13650006, -0.10787988, -0.7725909]), new Float32Array([0.62194663, 0.121061325, -0.09811556, -0.7673981]), new Float32Array([0.6330432, 0.10584408, -0.08795637, -0.7617854]), new Float32Array([0.64387786, 0.09086105, -0.07741001, -0.7557601]), new Float32Array([0.6544384, 0.0761244, -0.06648436, -0.7493299]), new Float32Array([0.6647129, 0.061646253, -0.055187732, -0.74250305]), new Float32Array([0.67469, 0.047438115, -0.043528587, -0.7352879]), new Float32Array([0.6843584, 0.03351158, -0.031515926, -0.7276931]), new Float32Array([0.693707, 0.01987794, -0.019159257, -0.71972805]), new Float32Array([0.70272505, 0.006547779, -0.0064679384, -0.711402])];
    constructor.IMDCT_POST_TABLE_32 = [new Float32Array([0.43864408, 0.56105477, 0.5085104, 0.48396915]), new Float32Array([0.3186977, 0.67859274, 0.5032787, 0.4297141]), new Float32Array([0.20833567, 0.7841439, 0.46999773, 0.34758708]), new Float32Array([0.114034384, 0.87124324, 0.41206735, 0.24110544]), new Float32Array([0.041238904, 0.9344632, 0.33435628, 0.115255035]), new Float32Array([-0.0059630573, 0.9697391, 0.24290696, -0.023805834]), new Float32Array([-0.02508533, 0.9746135, 0.14457026, -0.16911149]), new Float32Array([-0.015391618, 0.9483844, 0.046591163, -0.3133039]), new Float32Array([0.022061408, 0.8921483, -0.043828517, -0.44906986]), new Float32Array([0.0844886, 0.8087357, -0.119964585, -0.5695759]), new Float32Array([0.16754475, 0.7025422, -0.1759777, -0.66887593]), new Float32Array([0.26558587, 0.57926774, -0.20726526, -0.7422629]), new Float32Array([0.37201017, 0.44557464, -0.21074113, -0.7865493]), new Float32Array([0.4796542, 0.30869222, -0.18502301, -0.80025464]), new Float32Array([0.5812251, 0.17598371, -0.13051844, -0.7836913]), new Float32Array([0.66973937, 0.054507732, -0.049402922, -0.73894346])];
}, {IMDCT_TABLE_256: "Array", IMDCT_TABLE_32: "Array", IMDCT_POST_TABLE_256: "Array", IMDCT_POST_TABLE_32: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var ReaderLE = function() {};
ReaderLE = stjs.extend(ReaderLE, null, [], function(constructor, prototype) {
    constructor.readShort = function(input) {
        var b2 = input.read();
        var b1 = input.read();
        if (b1 == -1 || b2 == -1) 
            return -1;
        return ((((b1 << 8) + b2)) << 16 >> 16);
    };
    constructor.readInt = function(input) {
        var b4 = input.read();
        var b3 = input.read();
        var b2 = input.read();
        var b1 = input.read();
        if (b1 == -1 || b2 == -1 || b3 == -1 || b4 == -1) 
            return -1;
        return ((((b1 << 24) + (b2 << 16) + (b3 << 8) + b4)) | 0);
    };
    constructor.readLong = function(input) {
        var b8 = input.read();
        var b7 = input.read();
        var b6 = input.read();
        var b5 = input.read();
        var b4 = input.read();
        var b3 = input.read();
        var b2 = input.read();
        var b1 = input.read();
        if (b1 == -1 || b2 == -1 || b3 == -1 || b4 == -1 || b5 == -1 || b6 == -1 || b7 == -1 || b8 == -1) 
            return -1;
        return ((((b1 << 56) + (b2 << 48) + (b3 << 40) + (b4 << 32) + (b5 << 24) + (b6 << 16) + (b7 << 8) + b8)) | 0);
    };
}, {}, {});
var MTSStreamType = function(tag, video, audio) {
    this.tag = tag;
    this.video = video;
    this.audio = audio;
    MTSStreamType._values.add(this);
};
MTSStreamType = stjs.extend(MTSStreamType, null, [], function(constructor, prototype) {
    constructor._values = new ArrayList();
    constructor.RESERVED = new MTSStreamType(0, false, false);
    constructor.VIDEO_MPEG1 = new MTSStreamType(1, true, false);
    constructor.VIDEO_MPEG2 = new MTSStreamType(2, true, false);
    constructor.AUDIO_MPEG1 = new MTSStreamType(3, false, true);
    constructor.AUDIO_MPEG2 = new MTSStreamType(4, false, true);
    constructor.PRIVATE_SECTION = new MTSStreamType(5, false, false);
    constructor.PRIVATE_DATA = new MTSStreamType(6, false, false);
    constructor.MHEG = new MTSStreamType(7, false, false);
    constructor.DSM_CC = new MTSStreamType(8, false, false);
    constructor.ATM_SYNC = new MTSStreamType(9, false, false);
    constructor.DSM_CC_A = new MTSStreamType(10, false, false);
    constructor.DSM_CC_B = new MTSStreamType(11, false, false);
    constructor.DSM_CC_C = new MTSStreamType(12, false, false);
    constructor.DSM_CC_D = new MTSStreamType(13, false, false);
    constructor.MPEG_AUX = new MTSStreamType(14, false, false);
    constructor.AUDIO_AAC_ADTS = new MTSStreamType(15, false, true);
    constructor.VIDEO_MPEG4 = new MTSStreamType(16, true, false);
    constructor.AUDIO_AAC_LATM = new MTSStreamType(17, false, true);
    constructor.FLEXMUX_PES = new MTSStreamType(18, false, false);
    constructor.FLEXMUX_SEC = new MTSStreamType(19, false, false);
    constructor.DSM_CC_SDP = new MTSStreamType(20, false, false);
    constructor.META_PES = new MTSStreamType(21, false, false);
    constructor.META_SEC = new MTSStreamType(22, false, false);
    constructor.DSM_CC_DATA_CAROUSEL = new MTSStreamType(23, false, false);
    constructor.DSM_CC_OBJ_CAROUSEL = new MTSStreamType(24, false, false);
    constructor.DSM_CC_SDP1 = new MTSStreamType(25, false, false);
    constructor.IPMP = new MTSStreamType(26, false, false);
    constructor.VIDEO_H264 = new MTSStreamType(27, true, false);
    constructor.AUDIO_AAC_RAW = new MTSStreamType(28, false, true);
    constructor.SUBS = new MTSStreamType(29, false, false);
    constructor.AUX_3D = new MTSStreamType(30, false, false);
    constructor.VIDEO_AVC_SVC = new MTSStreamType(31, true, false);
    constructor.VIDEO_AVC_MVC = new MTSStreamType(32, true, false);
    constructor.VIDEO_J2K = new MTSStreamType(33, true, false);
    constructor.VIDEO_MPEG2_3D = new MTSStreamType(34, true, false);
    constructor.VIDEO_H264_3D = new MTSStreamType(35, true, false);
    constructor.VIDEO_CAVS = new MTSStreamType(66, false, true);
    constructor.IPMP_STREAM = new MTSStreamType(127, false, false);
    constructor.AUDIO_AC3 = new MTSStreamType(129, false, true);
    constructor.AUDIO_DTS = new MTSStreamType(138, false, true);
    prototype.tag = 0;
    prototype.video = false;
    prototype.audio = false;
    constructor.values = function() {
        return MTSStreamType._values.toArray(Array(0));
    };
    constructor.fromTag = function(streamTypeTag) {
        var values = MTSStreamType.values();
        for (var i = 0; i < values.length; i++) {
            var streamType = values[i];
            if (streamType.tag == streamTypeTag) 
                return streamType;
        }
        return null;
    };
    prototype.getTag = function() {
        return this.tag;
    };
    prototype.isVideo = function() {
        return this.video;
    };
    prototype.isAudio = function() {
        return this.audio;
    };
}, {_values: {name: "List", arguments: ["MTSStreamType"]}, RESERVED: "MTSStreamType", VIDEO_MPEG1: "MTSStreamType", VIDEO_MPEG2: "MTSStreamType", AUDIO_MPEG1: "MTSStreamType", AUDIO_MPEG2: "MTSStreamType", PRIVATE_SECTION: "MTSStreamType", PRIVATE_DATA: "MTSStreamType", MHEG: "MTSStreamType", DSM_CC: "MTSStreamType", ATM_SYNC: "MTSStreamType", DSM_CC_A: "MTSStreamType", DSM_CC_B: "MTSStreamType", DSM_CC_C: "MTSStreamType", DSM_CC_D: "MTSStreamType", MPEG_AUX: "MTSStreamType", AUDIO_AAC_ADTS: "MTSStreamType", VIDEO_MPEG4: "MTSStreamType", AUDIO_AAC_LATM: "MTSStreamType", FLEXMUX_PES: "MTSStreamType", FLEXMUX_SEC: "MTSStreamType", DSM_CC_SDP: "MTSStreamType", META_PES: "MTSStreamType", META_SEC: "MTSStreamType", DSM_CC_DATA_CAROUSEL: "MTSStreamType", DSM_CC_OBJ_CAROUSEL: "MTSStreamType", DSM_CC_SDP1: "MTSStreamType", IPMP: "MTSStreamType", VIDEO_H264: "MTSStreamType", AUDIO_AAC_RAW: "MTSStreamType", SUBS: "MTSStreamType", AUX_3D: "MTSStreamType", VIDEO_AVC_SVC: "MTSStreamType", VIDEO_AVC_MVC: "MTSStreamType", VIDEO_J2K: "MTSStreamType", VIDEO_MPEG2_3D: "MTSStreamType", VIDEO_H264_3D: "MTSStreamType", VIDEO_CAVS: "MTSStreamType", IPMP_STREAM: "MTSStreamType", AUDIO_AC3: "MTSStreamType", AUDIO_DTS: "MTSStreamType"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MXF demuxer
 *  
 *  @author The JCodec project
 *  
 */
var MXFUtil = function() {};
MXFUtil = stjs.extend(MXFUtil, null, [], function(constructor, prototype) {
    constructor.resolveRef = function(metadata, refs, class1) {
        var res = MXFUtil.resolveRefs(metadata, [refs], class1);
        return res.size() > 0 ? res.get(0) : null;
    };
    constructor.resolveRefs = function(metadata, refs, class1) {
        var copy = new ArrayList(metadata);
        for (var iterator = copy.iterator(); iterator.hasNext(); ) {
            var next = iterator.next();
            if (next.getUid() == null || !class1.isAssignableFrom(next.getClass())) 
                iterator.remove();
        }
        var result = new ArrayList();
        for (var i = 0; i < refs.length; i++) {
            for (var iterator$meta = copy.iterator(); iterator$meta.hasNext(); ) {
                var meta = iterator$meta.next();
                if (meta.getUid().equals(refs[i])) {
                    result.add(meta);
                }
            }
        }
        return result;
    };
    constructor.findMeta = function(metadata, class1) {
        for (var iterator$mxfMetadata = metadata.iterator(); iterator$mxfMetadata.hasNext(); ) {
            var mxfMetadata = iterator$mxfMetadata.next();
            if (mxfMetadata.getClass().isAssignableFrom(class1)) 
                return mxfMetadata;
        }
        return null;
    };
    constructor.findAllMeta = function(metadata, class1) {
        var result = new ArrayList();
        for (var iterator$mxfMetadata = metadata.iterator(); iterator$mxfMetadata.hasNext(); ) {
            var mxfMetadata = iterator$mxfMetadata.next();
            if (class1.isAssignableFrom(mxfMetadata.getClass())) 
                result.add(mxfMetadata);
        }
        return result;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var CVTColorFilter = function() {};
CVTColorFilter = stjs.extend(CVTColorFilter, null, [], function(constructor, prototype) {
    prototype.yuv422BitTObgr24 = function(yuv, rgb32) {
        var y = ByteBuffer.wrap(yuv.getPlaneData(0));
        var cb = ByteBuffer.wrap(yuv.getPlaneData(1));
        var cr = ByteBuffer.wrap(yuv.getPlaneData(2));
         while (y.hasRemaining()){
            var c1 = (y.get() + 112) << 2;
            var c2 = (y.get() + 112) << 2;
            var d = cb.get() << 2;
            var e = cr.get() << 2;
            rgb32.put(CVTColorFilter.blue(d, c1));
            rgb32.put(CVTColorFilter.green(d, e, c1));
            rgb32.put(CVTColorFilter.red(e, c1));
            rgb32.put(CVTColorFilter.blue(d, c2));
            rgb32.put(CVTColorFilter.green(d, e, c2));
            rgb32.put(CVTColorFilter.red(e, c2));
        }
    };
    constructor.blue = function(d, c) {
        var blue = (1192 * c + 2064 * d + 512) >> 10;
        blue = blue < 0 ? 0 : (blue > 1023 ? 1023 : blue);
        return (((blue >> 2) & 255) << 24 >> 24);
    };
    constructor.green = function(d, e, c) {
        var green = (1192 * c - 400 * d - 832 * e + 512) >> 10;
        green = green < 0 ? 0 : (green > 1023 ? 1023 : green);
        return (((green >> 2) & 255) << 24 >> 24);
    };
    constructor.red = function(e, c) {
        var red = (1192 * c + 1636 * e + 512) >> 10;
        red = red < 0 ? 0 : (red > 1023 ? 1023 : red);
        return (((red >> 2) & 255) << 24 >> 24);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ImageOP = function() {};
ImageOP = stjs.extend(ImageOP, null, [], function(constructor, prototype) {
    /**
     *  
     *  @param src
     *  @param area
     *  @return
     */
    constructor.subImageWithFillInt = function(src, width, height, dst, dstW, dstH, offX, offY) {
        var srcHeight = Math.min(height - offY, dstH);
        var srcWidth = Math.min(width - offX, dstW);
        var srcStride = width;
        var dstOff = 0, srcOff = offY * srcStride + offX;
        var i;
        for (i = 0; i < srcHeight; i++) {
            var j;
            for (j = 0; j < srcWidth; j++) {
                dst[dstOff + j] = src[srcOff + j];
            }
            var lastPix = dst[j - 1];
            for (; j < dstW; j++) 
                dst[dstOff + j] = lastPix;
            srcOff += srcStride;
            dstOff += dstW;
        }
        var lastLine = dstOff - dstW;
        for (; i < dstH; i++) {
            System.arraycopy(dst, lastLine, dst, dstOff, dstW);
            dstOff += dstW;
        }
    };
    constructor.subImageWithFill = function(src, width, height, dst, dstW, dstH, offX, offY) {
        var srcHeight = Math.min(height - offY, dstH);
        var srcWidth = Math.min(width - offX, dstW);
        var srcStride = width;
        var dstOff = 0, srcOff = offY * srcStride + offX;
        var i;
        for (i = 0; i < srcHeight; i++) {
            var j;
            for (j = 0; j < srcWidth; j++) {
                dst[dstOff + j] = src[srcOff + j];
            }
            var lastPix = dst[j - 1];
            for (; j < dstW; j++) 
                dst[dstOff + j] = lastPix;
            srcOff += srcStride;
            dstOff += dstW;
        }
        var lastLine = dstOff - dstW;
        for (; i < dstH; i++) {
            System.arraycopy(dst, lastLine, dst, dstOff, dstW);
            dstOff += dstW;
        }
    };
    constructor.subImageWithFillPic8 = function(_in, out, rect) {
        var width = _in.getWidth();
        var height = _in.getHeight();
        var color = _in.getColor();
        var data = _in.getData();
        for (var i = 0; i < data.length; i++) {
            ImageOP.subImageWithFill(data[i], width >> color.compWidth[i], height >> color.compHeight[i], out.getPlaneData(i), rect.getWidth() >> color.compWidth[i], rect.getHeight() >> color.compHeight[i], rect.getX() >> color.compWidth[i], rect.getY() >> color.compHeight[i]);
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AudioFrame = function(buffer, format, nFrames, pts, duration, timescale, frameNo) {
    AudioBuffer.call(this, buffer, format, nFrames);
    this.pts = pts;
    this.duration = duration;
    this.timescale = timescale;
    this.frameNo = frameNo;
};
AudioFrame = stjs.extend(AudioFrame, AudioBuffer, [], function(constructor, prototype) {
    prototype.pts = 0;
    prototype.duration = 0;
    prototype.timescale = 0;
    prototype.frameNo = 0;
    prototype.getPts = function() {
        return this.pts;
    };
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getTimescale = function() {
        return this.timescale;
    };
    prototype.getFrameNo = function() {
        return this.frameNo;
    };
}, {data: "ByteBuffer", format: "AudioFormat"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEGUtil = function() {};
MPEGUtil = stjs.extend(MPEGUtil, null, [], function(constructor, prototype) {
    /**
     *  Finds next MPEG bitstream marker 0x000001xx and returns the data that
     *  preceeds it as a ByteBuffer slice
     *  
     *  Segment byte order is always little endian
     *  
     *  @param buf
     *  @return
     */
    constructor.gotoNextMarker = function(buf) {
        return MPEGUtil.gotoMarker(buf, 0, 256, 511);
    };
    /**
     *  Finds next Nth MPEG bitstream marker 0x000001xx and returns the data that
     *  preceeds it as a ByteBuffer slice
     *  
     *  Segment byte order is always little endian
     *  
     *  @param buf
     *  @return
     */
    constructor.gotoMarker = function(buf, n, mmin, mmax) {
        if (!buf.hasRemaining()) 
            return null;
        var from = buf.position();
        var result = buf.slice();
        result.order(ByteOrder.BIG_ENDIAN);
        var val = -1;
         while (buf.hasRemaining()){
            val = (val << 8) | (buf.get() & 255);
            if (val >= mmin && val <= mmax) {
                if (n == 0) {
                    buf.setPosition(buf.position() - 4);
                    result.setLimit(buf.position() - from);
                    break;
                }
                --n;
            }
        }
        return result;
    };
    /**
     *  Returns next segment between two MPEG marker
     *  
     *  i.e. searches for the next marker if the stream is not at the marker
     *  boundary already
     *  
     *  @param buf
     *  @return
     */
    constructor.nextSegment = function(buf) {
        MPEGUtil.gotoMarker(buf, 0, 256, 511);
        return MPEGUtil.gotoMarker(buf, 1, 256, 511);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AudioCodecMeta = function(fourcc, codecPrivate) {
    CodecMeta.call(this, fourcc, codecPrivate);
};
AudioCodecMeta = stjs.extend(AudioCodecMeta, CodecMeta, [], function(constructor, prototype) {
    constructor.createAudioCodecMeta = function(fourcc, sampleSize, channelCount, sampleRate, endian, pcm, labels, codecPrivate) {
        var self = new AudioCodecMeta(fourcc, codecPrivate);
        self.sampleSize = sampleSize;
        self.channelCount = channelCount;
        self.sampleRate = sampleRate;
        self.endian = endian;
        self.pcm = pcm;
        self.labels = labels;
        return self;
    };
    constructor.createAudioCodecMeta2 = function(fourcc, sampleSize, channelCount, sampleRate, endian, pcm, labels, samplesPerPacket, bytesPerPacket, bytesPerFrame, codecPrivate) {
        var self = new AudioCodecMeta(fourcc, codecPrivate);
        self.sampleSize = sampleSize;
        self.channelCount = channelCount;
        self.sampleRate = sampleRate;
        self.endian = endian;
        self.samplesPerPacket = samplesPerPacket;
        self.bytesPerPacket = bytesPerPacket;
        self.bytesPerFrame = bytesPerFrame;
        self.pcm = pcm;
        self.labels = labels;
        return self;
    };
    constructor.createAudioCodecMeta3 = function(fourcc, codecPrivate, format, pcm, labels) {
        var self = new AudioCodecMeta(fourcc, codecPrivate);
        self.sampleSize = format.getSampleSizeInBits() >> 3;
        self.channelCount = format.getChannels();
        self.sampleRate = format.getSampleRate();
        self.endian = format.isBigEndian() ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
        self.pcm = pcm;
        self.labels = labels;
        return self;
    };
    prototype.sampleSize = 0;
    prototype.channelCount = 0;
    prototype.sampleRate = 0;
    prototype.endian = null;
    prototype.samplesPerPacket = 0;
    prototype.bytesPerPacket = 0;
    prototype.bytesPerFrame = 0;
    prototype.pcm = false;
    prototype.labels = null;
    prototype.getFrameSize = function() {
        return this.sampleSize * this.channelCount;
    };
    prototype.getSampleRate = function() {
        return this.sampleRate;
    };
    prototype.getSampleSize = function() {
        return this.sampleSize;
    };
    prototype.getChannelCount = function() {
        return this.channelCount;
    };
    prototype.getSamplesPerPacket = function() {
        return this.samplesPerPacket;
    };
    prototype.getBytesPerPacket = function() {
        return this.bytesPerPacket;
    };
    prototype.getBytesPerFrame = function() {
        return this.bytesPerFrame;
    };
    prototype.getEndian = function() {
        return this.endian;
    };
    prototype.isPCM = function() {
        return this.pcm;
    };
    prototype.getFormat = function() {
        return new AudioFormat(this.sampleRate, this.sampleSize << 3, this.channelCount, true, this.endian == ByteOrder.BIG_ENDIAN);
    };
    prototype.getChannelLabels = function() {
        return this.labels;
    };
    constructor.fromAudioFormat = function(format) {
        var self = new AudioCodecMeta(null, null);
        self.sampleSize = format.getSampleSizeInBits() >> 3;
        self.channelCount = format.getChannels();
        self.sampleRate = format.getSampleRate();
        self.endian = format.isBigEndian() ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
        self.pcm = false;
        return self;
    };
}, {endian: "ByteOrder", labels: "Array", codecPrivate: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VideoCodecMeta = function(fourcc, codecPrivate) {
    CodecMeta.call(this, fourcc, codecPrivate);
};
VideoCodecMeta = stjs.extend(VideoCodecMeta, CodecMeta, [], function(constructor, prototype) {
    constructor.createVideoCodecMeta = function(fourcc, codecPrivate, size, pasp) {
        var self = new VideoCodecMeta(fourcc, codecPrivate);
        self.size = size;
        self.pasp = pasp;
        return self;
    };
    constructor.createVideoCodecMeta2 = function(fourcc, codecPrivate, size, pasp, interlaced, topFieldFirst) {
        var self = new VideoCodecMeta(fourcc, codecPrivate);
        self.size = size;
        self.pasp = pasp;
        self.interlaced = interlaced;
        self.topFieldFirst = topFieldFirst;
        return self;
    };
    prototype.size = null;
    prototype.pasp = null;
    prototype.interlaced = false;
    prototype.topFieldFirst = false;
    prototype.color = null;
    prototype.getSize = function() {
        return this.size;
    };
    prototype.getPasp = function() {
        return this.pasp;
    };
    prototype.getPixelAspectRatio = function() {
        return this.pasp;
    };
    prototype.isInterlaced = function() {
        return this.interlaced;
    };
    prototype.isTopFieldFirst = function() {
        return this.topFieldFirst;
    };
    prototype.getColor = function() {
        return this.color;
    };
    constructor.createSimpleVideoCodecMeta = function(size, color) {
        var self = new VideoCodecMeta(null, null);
        self.size = size;
        self.color = color;
        return self;
    };
    prototype.setPixelAspectRatio = function(pasp) {
        this.pasp = pasp;
    };
}, {size: "Size", pasp: "Rational", color: "ColorSpace", codecPrivate: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author Alex Zhukov
 */
var FfmpegIntDct = function() {};
FfmpegIntDct = stjs.extend(FfmpegIntDct, null, [], function(constructor, prototype) {
    constructor.DCTSIZE = 8;
    constructor.DCTSIZE_6 = FfmpegIntDct.DCTSIZE * 6;
    constructor.DCTSIZE_5 = FfmpegIntDct.DCTSIZE * 5;
    constructor.DCTSIZE_4 = FfmpegIntDct.DCTSIZE * 4;
    constructor.DCTSIZE_3 = FfmpegIntDct.DCTSIZE * 3;
    constructor.DCTSIZE_2 = FfmpegIntDct.DCTSIZE * 2;
    constructor.DCTSIZE_1 = FfmpegIntDct.DCTSIZE * 1;
    constructor.DCTSIZE_7 = FfmpegIntDct.DCTSIZE * 7;
    constructor.DCTSIZE_0 = FfmpegIntDct.DCTSIZE * 0;
    constructor.PASS1_BITS = 2;
    constructor.CONST_BITS = 13;
    constructor.D1 = FfmpegIntDct.CONST_BITS - FfmpegIntDct.PASS1_BITS;
    constructor.D2 = FfmpegIntDct.CONST_BITS + FfmpegIntDct.PASS1_BITS + 3;
    constructor.ONEHALF_11 = (1 << (FfmpegIntDct.D1 - 1));
    constructor.ONEHALF_18 = (1 << (FfmpegIntDct.D2 - 1));
    prototype.decode = function(orig) {
        var data = ShortBuffer.wrap(orig);
        FfmpegIntDct.pass1(data);
        FfmpegIntDct.pass2(data);
        return orig;
    };
    constructor.advance = function(dataptr, size) {
        dataptr.position(dataptr.position() + size);
        return dataptr.slice();
    };
    constructor.FIX_0_211164243 = 1730;
    constructor.FIX_0_275899380 = 2260;
    constructor.FIX_0_298631336 = 2446;
    constructor.FIX_0_390180644 = 3196;
    constructor.FIX_0_509795579 = 4176;
    constructor.FIX_0_541196100 = 4433;
    constructor.FIX_0_601344887 = 4926;
    constructor.FIX_0_765366865 = 6270;
    constructor.FIX_0_785694958 = 6436;
    constructor.FIX_0_899976223 = 7373;
    constructor.FIX_1_061594337 = 8697;
    constructor.FIX_1_111140466 = 9102;
    constructor.FIX_1_175875602 = 9633;
    constructor.FIX_1_306562965 = 10703;
    constructor.FIX_1_387039845 = 11363;
    constructor.FIX_1_451774981 = 11893;
    constructor.FIX_1_501321110 = 12299;
    constructor.FIX_1_662939225 = 13623;
    constructor.FIX_1_847759065 = 15137;
    constructor.FIX_1_961570560 = 16069;
    constructor.FIX_2_053119869 = 16819;
    constructor.FIX_2_172734803 = 17799;
    constructor.FIX_2_562915447 = 20995;
    constructor.FIX_3_072711026 = 25172;
    constructor.pass1 = function(data) {
        var z1;
        var tmp2;
        var tmp3;
        var tmp0;
        var tmp1;
        var tmp10;
        var tmp13;
        var tmp11;
        var tmp12;
        var z2;
        var z3;
        var z4;
        var z5;
        var dataptr = data.duplicate();
        for (var rowctr = FfmpegIntDct.DCTSIZE - 1; rowctr >= 0; rowctr--) {
            var d0 = dataptr.get(0);
            var d2 = dataptr.get(1);
            var d4 = dataptr.get(2);
            var d6 = dataptr.get(3);
            var d1 = dataptr.get(4);
            var d3 = dataptr.get(5);
            var d5 = dataptr.get(6);
            var d7 = dataptr.get(7);
            if ((d1 | d2 | d3 | d4 | d5 | d6 | d7) == 0) {
                if (d0 != 0) {
                    var dcval = stjs.trunc((d0 << FfmpegIntDct.PASS1_BITS));
                    for (var i = 0; i < 8; i++) {
                        dataptr.put(i, ((dcval) << 16 >> 16));
                    }
                }
                dataptr = FfmpegIntDct.advance(dataptr, FfmpegIntDct.DCTSIZE);
                continue;
            }
            if (d6 != 0) {
                if (d2 != 0) {
                    z1 = FfmpegIntDct.MULTIPLY(d2 + d6, FfmpegIntDct.FIX_0_541196100);
                    tmp2 = z1 + FfmpegIntDct.MULTIPLY(-d6, FfmpegIntDct.FIX_1_847759065);
                    tmp3 = z1 + FfmpegIntDct.MULTIPLY(d2, FfmpegIntDct.FIX_0_765366865);
                    tmp0 = (d0 + d4) << FfmpegIntDct.CONST_BITS;
                    tmp1 = (d0 - d4) << FfmpegIntDct.CONST_BITS;
                    tmp10 = tmp0 + tmp3;
                    tmp13 = tmp0 - tmp3;
                    tmp11 = tmp1 + tmp2;
                    tmp12 = tmp1 - tmp2;
                } else {
                    tmp2 = FfmpegIntDct.MULTIPLY(-d6, FfmpegIntDct.FIX_1_306562965);
                    tmp3 = FfmpegIntDct.MULTIPLY(d6, FfmpegIntDct.FIX_0_541196100);
                    tmp0 = (d0 + d4) << FfmpegIntDct.CONST_BITS;
                    tmp1 = (d0 - d4) << FfmpegIntDct.CONST_BITS;
                    tmp10 = tmp0 + tmp3;
                    tmp13 = tmp0 - tmp3;
                    tmp11 = tmp1 + tmp2;
                    tmp12 = tmp1 - tmp2;
                }
            } else {
                if (d2 != 0) {
                    tmp2 = FfmpegIntDct.MULTIPLY(d2, FfmpegIntDct.FIX_0_541196100);
                    tmp3 = FfmpegIntDct.MULTIPLY(d2, FfmpegIntDct.FIX_1_306562965);
                    tmp0 = (d0 + d4) << FfmpegIntDct.CONST_BITS;
                    tmp1 = (d0 - d4) << FfmpegIntDct.CONST_BITS;
                    tmp10 = tmp0 + tmp3;
                    tmp13 = tmp0 - tmp3;
                    tmp11 = tmp1 + tmp2;
                    tmp12 = tmp1 - tmp2;
                } else {
                    tmp10 = tmp13 = (d0 + d4) << FfmpegIntDct.CONST_BITS;
                    tmp11 = tmp12 = (d0 - d4) << FfmpegIntDct.CONST_BITS;
                }
            }
            if (d7 != 0) {
                if (d5 != 0) {
                    if (d3 != 0) {
                        if (d1 != 0) {
                            z1 = d7 + d1;
                            z2 = d5 + d3;
                            z3 = d7 + d3;
                            z4 = d5 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(z3 + z4, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_298631336);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_2_053119869);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_3_072711026);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_501321110);
                            z1 = FfmpegIntDct.MULTIPLY(-z1, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-z2, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-z3, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-z4, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z1 + z3;
                            tmp1 += z2 + z4;
                            tmp2 += z2 + z3;
                            tmp3 += z1 + z4;
                        } else {
                            z2 = d5 + d3;
                            z3 = d7 + d3;
                            z5 = FfmpegIntDct.MULTIPLY(z3 + d5, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_298631336);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_2_053119869);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_3_072711026);
                            z1 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-z2, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-z3, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z1 + z3;
                            tmp1 += z2 + z4;
                            tmp2 += z2 + z3;
                            tmp3 = z1 + z4;
                        }
                    } else {
                        if (d1 != 0) {
                            z1 = d7 + d1;
                            z4 = d5 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(d7 + z4, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_298631336);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_2_053119869);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_501321110);
                            z1 = FfmpegIntDct.MULTIPLY(-z1, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-z4, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z1 + z3;
                            tmp1 += z2 + z4;
                            tmp2 = z2 + z3;
                            tmp3 += z1 + z4;
                        } else {
                            tmp0 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_601344887);
                            z1 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_899976223);
                            z3 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_961570560);
                            tmp1 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_509795579);
                            z2 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_2_562915447);
                            z4 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_390180644);
                            z5 = FfmpegIntDct.MULTIPLY(d5 + d7, FfmpegIntDct.FIX_1_175875602);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z3;
                            tmp1 += z4;
                            tmp2 = z2 + z3;
                            tmp3 = z1 + z4;
                        }
                    }
                } else {
                    if (d3 != 0) {
                        if (d1 != 0) {
                            z1 = d7 + d1;
                            z3 = d7 + d3;
                            z5 = FfmpegIntDct.MULTIPLY(z3 + d1, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_298631336);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_3_072711026);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_501321110);
                            z1 = FfmpegIntDct.MULTIPLY(-z1, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-z3, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-d1, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z1 + z3;
                            tmp1 = z2 + z4;
                            tmp2 += z2 + z3;
                            tmp3 += z1 + z4;
                        } else {
                            z3 = d7 + d3;
                            tmp0 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_601344887);
                            z1 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_899976223);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_0_509795579);
                            z2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_2_562915447);
                            z5 = FfmpegIntDct.MULTIPLY(z3, FfmpegIntDct.FIX_1_175875602);
                            z3 = FfmpegIntDct.MULTIPLY(-z3, FfmpegIntDct.FIX_0_785694958);
                            tmp0 += z3;
                            tmp1 = z2 + z5;
                            tmp2 += z3;
                            tmp3 = z1 + z5;
                        }
                    } else {
                        if (d1 != 0) {
                            z1 = d7 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(z1, FfmpegIntDct.FIX_1_175875602);
                            z1 = FfmpegIntDct.MULTIPLY(z1, FfmpegIntDct.FIX_0_275899380);
                            z3 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_961570560);
                            tmp0 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_662939225);
                            z4 = FfmpegIntDct.MULTIPLY(-d1, FfmpegIntDct.FIX_0_390180644);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_111140466);
                            tmp0 += z1;
                            tmp1 = z4 + z5;
                            tmp2 = z3 + z5;
                            tmp3 += z1;
                        } else {
                            tmp0 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_387039845);
                            tmp1 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_1_175875602);
                            tmp2 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_785694958);
                            tmp3 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_275899380);
                        }
                    }
                }
            } else {
                if (d5 != 0) {
                    if (d3 != 0) {
                        if (d1 != 0) {
                            z2 = d5 + d3;
                            z4 = d5 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(d3 + z4, FfmpegIntDct.FIX_1_175875602);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_2_053119869);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_3_072711026);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_501321110);
                            z1 = FfmpegIntDct.MULTIPLY(-d1, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-z2, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-z4, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 = z1 + z3;
                            tmp1 += z2 + z4;
                            tmp2 += z2 + z3;
                            tmp3 += z1 + z4;
                        } else {
                            z2 = d5 + d3;
                            z5 = FfmpegIntDct.MULTIPLY(z2, FfmpegIntDct.FIX_1_175875602);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_1_662939225);
                            z4 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_390180644);
                            z2 = FfmpegIntDct.MULTIPLY(-z2, FfmpegIntDct.FIX_1_387039845);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_1_111140466);
                            z3 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_1_961570560);
                            tmp0 = z3 + z5;
                            tmp1 += z2;
                            tmp2 += z2;
                            tmp3 = z4 + z5;
                        }
                    } else {
                        if (d1 != 0) {
                            z4 = d5 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(z4, FfmpegIntDct.FIX_1_175875602);
                            z1 = FfmpegIntDct.MULTIPLY(-d1, FfmpegIntDct.FIX_0_899976223);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_0_601344887);
                            tmp1 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_509795579);
                            z2 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_2_562915447);
                            z4 = FfmpegIntDct.MULTIPLY(z4, FfmpegIntDct.FIX_0_785694958);
                            tmp0 = z1 + z5;
                            tmp1 += z4;
                            tmp2 = z2 + z5;
                            tmp3 += z4;
                        } else {
                            tmp0 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_1_175875602);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_0_275899380);
                            tmp2 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_1_387039845);
                            tmp3 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_0_785694958);
                        }
                    }
                } else {
                    if (d3 != 0) {
                        if (d1 != 0) {
                            z5 = d1 + d3;
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_0_211164243);
                            tmp2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_1_451774981);
                            z1 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_061594337);
                            z2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_2_172734803);
                            z4 = FfmpegIntDct.MULTIPLY(z5, FfmpegIntDct.FIX_0_785694958);
                            z5 = FfmpegIntDct.MULTIPLY(z5, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = z1 - z4;
                            tmp1 = z2 + z4;
                            tmp2 += z5;
                            tmp3 += z5;
                        } else {
                            tmp0 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_0_785694958);
                            tmp1 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_1_387039845);
                            tmp2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_0_275899380);
                            tmp3 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_1_175875602);
                        }
                    } else {
                        if (d1 != 0) {
                            tmp0 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_0_275899380);
                            tmp1 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_0_785694958);
                            tmp2 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_175875602);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_387039845);
                        } else {
                            tmp0 = tmp1 = tmp2 = tmp3 = 0;
                        }
                    }
                }
            }
            dataptr.put(0, FfmpegIntDct.DESCALE11(tmp10 + tmp3));
            dataptr.put(7, FfmpegIntDct.DESCALE11(tmp10 - tmp3));
            dataptr.put(1, FfmpegIntDct.DESCALE11(tmp11 + tmp2));
            dataptr.put(6, FfmpegIntDct.DESCALE11(tmp11 - tmp2));
            dataptr.put(2, FfmpegIntDct.DESCALE11(tmp12 + tmp1));
            dataptr.put(5, FfmpegIntDct.DESCALE11(tmp12 - tmp1));
            dataptr.put(3, FfmpegIntDct.DESCALE11(tmp13 + tmp0));
            dataptr.put(4, FfmpegIntDct.DESCALE11(tmp13 - tmp0));
            dataptr = FfmpegIntDct.advance(dataptr, FfmpegIntDct.DCTSIZE);
        }
    };
    constructor.MULTIPLY = function(x, y) {
        return y * ((x) << 16 >> 16);
    };
    /**
     *  Perform the inverse DCT on one block of coefficients.
     */
    constructor.pass2 = function(data) {
        var tmp0, tmp1, tmp2, tmp3;
        var tmp10, tmp11, tmp12, tmp13;
        var z1, z2, z3, z4, z5;
        var d0, d1, d2, d3, d4, d5, d6, d7;
        var dataptr = data.duplicate();
        for (var rowctr = FfmpegIntDct.DCTSIZE - 1; rowctr >= 0; rowctr--) {
            d0 = dataptr.get(FfmpegIntDct.DCTSIZE_0);
            d1 = dataptr.get(FfmpegIntDct.DCTSIZE_1);
            d2 = dataptr.get(FfmpegIntDct.DCTSIZE_2);
            d3 = dataptr.get(FfmpegIntDct.DCTSIZE_3);
            d4 = dataptr.get(FfmpegIntDct.DCTSIZE_4);
            d5 = dataptr.get(FfmpegIntDct.DCTSIZE_5);
            d6 = dataptr.get(FfmpegIntDct.DCTSIZE_6);
            d7 = dataptr.get(FfmpegIntDct.DCTSIZE_7);
            if (d6 != 0) {
                if (d2 != 0) {
                    z1 = FfmpegIntDct.MULTIPLY(d2 + d6, FfmpegIntDct.FIX_0_541196100);
                    tmp2 = z1 + FfmpegIntDct.MULTIPLY(-d6, FfmpegIntDct.FIX_1_847759065);
                    tmp3 = z1 + FfmpegIntDct.MULTIPLY(d2, FfmpegIntDct.FIX_0_765366865);
                    tmp0 = (d0 + d4) << FfmpegIntDct.CONST_BITS;
                    tmp1 = (d0 - d4) << FfmpegIntDct.CONST_BITS;
                    tmp10 = tmp0 + tmp3;
                    tmp13 = tmp0 - tmp3;
                    tmp11 = tmp1 + tmp2;
                    tmp12 = tmp1 - tmp2;
                } else {
                    tmp2 = FfmpegIntDct.MULTIPLY(-d6, FfmpegIntDct.FIX_1_306562965);
                    tmp3 = FfmpegIntDct.MULTIPLY(d6, FfmpegIntDct.FIX_0_541196100);
                    tmp0 = (d0 + d4) << FfmpegIntDct.CONST_BITS;
                    tmp1 = (d0 - d4) << FfmpegIntDct.CONST_BITS;
                    tmp10 = tmp0 + tmp3;
                    tmp13 = tmp0 - tmp3;
                    tmp11 = tmp1 + tmp2;
                    tmp12 = tmp1 - tmp2;
                }
            } else {
                if (d2 != 0) {
                    tmp2 = FfmpegIntDct.MULTIPLY(d2, FfmpegIntDct.FIX_0_541196100);
                    tmp3 = FfmpegIntDct.MULTIPLY(d2, FfmpegIntDct.FIX_1_306562965);
                    tmp0 = (d0 + d4) << FfmpegIntDct.CONST_BITS;
                    tmp1 = (d0 - d4) << FfmpegIntDct.CONST_BITS;
                    tmp10 = tmp0 + tmp3;
                    tmp13 = tmp0 - tmp3;
                    tmp11 = tmp1 + tmp2;
                    tmp12 = tmp1 - tmp2;
                } else {
                    tmp10 = tmp13 = (d0 + d4) << FfmpegIntDct.CONST_BITS;
                    tmp11 = tmp12 = (d0 - d4) << FfmpegIntDct.CONST_BITS;
                }
            }
            if (d7 != 0) {
                if (d5 != 0) {
                    if (d3 != 0) {
                        if (d1 != 0) {
                            z1 = d7 + d1;
                            z2 = d5 + d3;
                            z3 = d7 + d3;
                            z4 = d5 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(z3 + z4, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_298631336);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_2_053119869);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_3_072711026);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_501321110);
                            z1 = FfmpegIntDct.MULTIPLY(-z1, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-z2, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-z3, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-z4, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z1 + z3;
                            tmp1 += z2 + z4;
                            tmp2 += z2 + z3;
                            tmp3 += z1 + z4;
                        } else {
                            z1 = d7;
                            z2 = d5 + d3;
                            z3 = d7 + d3;
                            z5 = FfmpegIntDct.MULTIPLY(z3 + d5, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_298631336);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_2_053119869);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_3_072711026);
                            z1 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-z2, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-z3, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z1 + z3;
                            tmp1 += z2 + z4;
                            tmp2 += z2 + z3;
                            tmp3 = z1 + z4;
                        }
                    } else {
                        if (d1 != 0) {
                            z1 = d7 + d1;
                            z2 = d5;
                            z3 = d7;
                            z4 = d5 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(z3 + z4, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_298631336);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_2_053119869);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_501321110);
                            z1 = FfmpegIntDct.MULTIPLY(-z1, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-z4, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z1 + z3;
                            tmp1 += z2 + z4;
                            tmp2 = z2 + z3;
                            tmp3 += z1 + z4;
                        } else {
                            tmp0 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_601344887);
                            z1 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_899976223);
                            z3 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_961570560);
                            tmp1 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_509795579);
                            z2 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_2_562915447);
                            z4 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_390180644);
                            z5 = FfmpegIntDct.MULTIPLY(d5 + d7, FfmpegIntDct.FIX_1_175875602);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z3;
                            tmp1 += z4;
                            tmp2 = z2 + z3;
                            tmp3 = z1 + z4;
                        }
                    }
                } else {
                    if (d3 != 0) {
                        if (d1 != 0) {
                            z1 = d7 + d1;
                            z3 = d7 + d3;
                            z5 = FfmpegIntDct.MULTIPLY(z3 + d1, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_298631336);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_3_072711026);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_501321110);
                            z1 = FfmpegIntDct.MULTIPLY(-z1, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-z3, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-d1, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 += z1 + z3;
                            tmp1 = z2 + z4;
                            tmp2 += z2 + z3;
                            tmp3 += z1 + z4;
                        } else {
                            z3 = d7 + d3;
                            tmp0 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_601344887);
                            z1 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_899976223);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_0_509795579);
                            z2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_2_562915447);
                            z5 = FfmpegIntDct.MULTIPLY(z3, FfmpegIntDct.FIX_1_175875602);
                            z3 = FfmpegIntDct.MULTIPLY(-z3, FfmpegIntDct.FIX_0_785694958);
                            tmp0 += z3;
                            tmp1 = z2 + z5;
                            tmp2 += z3;
                            tmp3 = z1 + z5;
                        }
                    } else {
                        if (d1 != 0) {
                            z1 = d7 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(z1, FfmpegIntDct.FIX_1_175875602);
                            z1 = FfmpegIntDct.MULTIPLY(z1, FfmpegIntDct.FIX_0_275899380);
                            z3 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_961570560);
                            tmp0 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_662939225);
                            z4 = FfmpegIntDct.MULTIPLY(-d1, FfmpegIntDct.FIX_0_390180644);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_111140466);
                            tmp0 += z1;
                            tmp1 = z4 + z5;
                            tmp2 = z3 + z5;
                            tmp3 += z1;
                        } else {
                            tmp0 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_1_387039845);
                            tmp1 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_1_175875602);
                            tmp2 = FfmpegIntDct.MULTIPLY(-d7, FfmpegIntDct.FIX_0_785694958);
                            tmp3 = FfmpegIntDct.MULTIPLY(d7, FfmpegIntDct.FIX_0_275899380);
                        }
                    }
                }
            } else {
                if (d5 != 0) {
                    if (d3 != 0) {
                        if (d1 != 0) {
                            z2 = d5 + d3;
                            z4 = d5 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(d3 + z4, FfmpegIntDct.FIX_1_175875602);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_2_053119869);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_3_072711026);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_501321110);
                            z1 = FfmpegIntDct.MULTIPLY(-d1, FfmpegIntDct.FIX_0_899976223);
                            z2 = FfmpegIntDct.MULTIPLY(-z2, FfmpegIntDct.FIX_2_562915447);
                            z3 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_1_961570560);
                            z4 = FfmpegIntDct.MULTIPLY(-z4, FfmpegIntDct.FIX_0_390180644);
                            z3 += z5;
                            z4 += z5;
                            tmp0 = z1 + z3;
                            tmp1 += z2 + z4;
                            tmp2 += z2 + z3;
                            tmp3 += z1 + z4;
                        } else {
                            z2 = d5 + d3;
                            z5 = FfmpegIntDct.MULTIPLY(z2, FfmpegIntDct.FIX_1_175875602);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_1_662939225);
                            z4 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_390180644);
                            z2 = FfmpegIntDct.MULTIPLY(-z2, FfmpegIntDct.FIX_1_387039845);
                            tmp2 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_1_111140466);
                            z3 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_1_961570560);
                            tmp0 = z3 + z5;
                            tmp1 += z2;
                            tmp2 += z2;
                            tmp3 = z4 + z5;
                        }
                    } else {
                        if (d1 != 0) {
                            z4 = d5 + d1;
                            z5 = FfmpegIntDct.MULTIPLY(z4, FfmpegIntDct.FIX_1_175875602);
                            z1 = FfmpegIntDct.MULTIPLY(-d1, FfmpegIntDct.FIX_0_899976223);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_0_601344887);
                            tmp1 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_0_509795579);
                            z2 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_2_562915447);
                            z4 = FfmpegIntDct.MULTIPLY(z4, FfmpegIntDct.FIX_0_785694958);
                            tmp0 = z1 + z5;
                            tmp1 += z4;
                            tmp2 = z2 + z5;
                            tmp3 += z4;
                        } else {
                            tmp0 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_1_175875602);
                            tmp1 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_0_275899380);
                            tmp2 = FfmpegIntDct.MULTIPLY(-d5, FfmpegIntDct.FIX_1_387039845);
                            tmp3 = FfmpegIntDct.MULTIPLY(d5, FfmpegIntDct.FIX_0_785694958);
                        }
                    }
                } else {
                    if (d3 != 0) {
                        if (d1 != 0) {
                            z5 = d1 + d3;
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_0_211164243);
                            tmp2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_1_451774981);
                            z1 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_061594337);
                            z2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_2_172734803);
                            z4 = FfmpegIntDct.MULTIPLY(z5, FfmpegIntDct.FIX_0_785694958);
                            z5 = FfmpegIntDct.MULTIPLY(z5, FfmpegIntDct.FIX_1_175875602);
                            tmp0 = z1 - z4;
                            tmp1 = z2 + z4;
                            tmp2 += z5;
                            tmp3 += z5;
                        } else {
                            tmp0 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_0_785694958);
                            tmp1 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_1_387039845);
                            tmp2 = FfmpegIntDct.MULTIPLY(-d3, FfmpegIntDct.FIX_0_275899380);
                            tmp3 = FfmpegIntDct.MULTIPLY(d3, FfmpegIntDct.FIX_1_175875602);
                        }
                    } else {
                        if (d1 != 0) {
                            tmp0 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_0_275899380);
                            tmp1 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_0_785694958);
                            tmp2 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_175875602);
                            tmp3 = FfmpegIntDct.MULTIPLY(d1, FfmpegIntDct.FIX_1_387039845);
                        } else {
                            tmp0 = tmp1 = tmp2 = tmp3 = 0;
                        }
                    }
                }
            }
            dataptr.put(FfmpegIntDct.DCTSIZE_0, FfmpegIntDct.DESCALE18(tmp10 + tmp3));
            dataptr.put(FfmpegIntDct.DCTSIZE_7, FfmpegIntDct.DESCALE18(tmp10 - tmp3));
            dataptr.put(FfmpegIntDct.DCTSIZE_1, FfmpegIntDct.DESCALE18(tmp11 + tmp2));
            dataptr.put(FfmpegIntDct.DCTSIZE_6, FfmpegIntDct.DESCALE18(tmp11 - tmp2));
            dataptr.put(FfmpegIntDct.DCTSIZE_2, FfmpegIntDct.DESCALE18(tmp12 + tmp1));
            dataptr.put(FfmpegIntDct.DCTSIZE_5, FfmpegIntDct.DESCALE18(tmp12 - tmp1));
            dataptr.put(FfmpegIntDct.DCTSIZE_3, FfmpegIntDct.DESCALE18(tmp13 + tmp0));
            dataptr.put(FfmpegIntDct.DCTSIZE_4, FfmpegIntDct.DESCALE18(tmp13 - tmp0));
            dataptr = FfmpegIntDct.advance(dataptr, 1);
        }
    };
    constructor.DESCALE = function(x, n) {
        return ((x) + (1 << ((n) - 1))) >> n;
    };
    constructor.DESCALE11 = function(x) {
        return ((((x + FfmpegIntDct.ONEHALF_11) >> 11)) << 16 >> 16);
    };
    constructor.DESCALE18 = function(x) {
        return ((((x + FfmpegIntDct.ONEHALF_18) >> 18)) << 16 >> 16);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  This code is borrowed from Apache Commons String Utils
 *  
 *  @author The JCodec project
 */
var StringUtils = function() {};
StringUtils = stjs.extend(StringUtils, null, [], function(constructor, prototype) {
    constructor.splitWorker4 = function(str, separatorChars, max, preserveAllTokens) {
        if (str == null) {
            return null;
        }
        var len = str.length;
        if (len == 0) {
            return Array(0);
        }
        var list = new ArrayList();
        var sizePlus1 = 1;
        var i = 0, start = 0;
        var match = false;
        var lastMatch = false;
        if (separatorChars == null) {
             while (i < len){
                if (Character.isWhitespace(str.charAt(i))) {
                    if (match || preserveAllTokens) {
                        lastMatch = true;
                        if (sizePlus1++ == max) {
                            i = len;
                            lastMatch = false;
                        }
                        list.add(str.substring(start, i));
                        match = false;
                    }
                    start = ++i;
                    continue;
                }
                lastMatch = false;
                match = true;
                i++;
            }
        } else if (separatorChars.length == 1) {
            var sep = separatorChars.charAt(0);
             while (i < len){
                if (str.charAt(i) == sep) {
                    if (match || preserveAllTokens) {
                        lastMatch = true;
                        if (sizePlus1++ == max) {
                            i = len;
                            lastMatch = false;
                        }
                        list.add(str.substring(start, i));
                        match = false;
                    }
                    start = ++i;
                    continue;
                }
                lastMatch = false;
                match = true;
                i++;
            }
        } else {
             while (i < len){
                if (separatorChars.indexOf(str.charAt(i)) >= 0) {
                    if (match || preserveAllTokens) {
                        lastMatch = true;
                        if (sizePlus1++ == max) {
                            i = len;
                            lastMatch = false;
                        }
                        list.add(str.substring(start, i));
                        match = false;
                    }
                    start = ++i;
                    continue;
                }
                lastMatch = false;
                match = true;
                i++;
            }
        }
        if (match || (preserveAllTokens && lastMatch)) {
            list.add(str.substring(start, i));
        }
        return list.toArray(Array(list.size()));
    };
    constructor.splitWorker = function(str, separatorChar, preserveAllTokens) {
        if (str == null) {
            return null;
        }
        var len = str.length;
        if (len == 0) {
            return Array(0);
        }
        var list = new ArrayList();
        var i = 0, start = 0;
        var match = false;
        var lastMatch = false;
         while (i < len){
            if (str.charAt(i) == separatorChar) {
                if (match || preserveAllTokens) {
                    list.add(str.substring(start, i));
                    match = false;
                    lastMatch = true;
                }
                start = ++i;
                continue;
            }
            lastMatch = false;
            match = true;
            i++;
        }
        if (match || (preserveAllTokens && lastMatch)) {
            list.add(str.substring(start, i));
        }
        return list.toArray(Array(list.size()));
    };
    constructor.split = function(str) {
        return StringUtils.splitS3(str, null, -1);
    };
    constructor.splitS = function(str, separatorChars) {
        return StringUtils.splitWorker4(str, separatorChars, -1, false);
    };
    constructor.splitS3 = function(str, separatorChars, max) {
        return StringUtils.splitWorker4(str, separatorChars, max, false);
    };
    constructor.splitC = function(str, separatorChar) {
        return StringUtils.splitWorker(str, separatorChar, false);
    };
    constructor.isEmpty = function(str) {
        return str == null || str.length == 0;
    };
    constructor.isDelimiter = function(ch, delimiters) {
        if (delimiters == null) {
            return Character.isWhitespace(ch);
        }
        for (var i = 0, isize = delimiters.length; i < isize; i++) {
            if (ch == delimiters[i]) {
                return true;
            }
        }
        return false;
    };
    constructor.capitaliseAllWords = function(str) {
        return StringUtils.capitalize(str);
    };
    constructor.capitalize = function(str) {
        return StringUtils.capitalizeD(str, null);
    };
    constructor.capitalizeD = function(str, delimiters) {
        var delimLen = (delimiters == null ? -1 : delimiters.length);
        if (str == null || str.length == 0 || delimLen == 0) {
            return str;
        }
        var strLen = str.length;
        var buffer = new StringBuilder(strLen);
        var capitalizeNext = true;
        for (var i = 0; i < strLen; i++) {
            var ch = str.charAt(i);
            if (StringUtils.isDelimiter(ch, delimiters)) {
                buffer.append(ch);
                capitalizeNext = true;
            } else if (capitalizeNext) {
                buffer.append(Character.toTitleCase(ch));
                capitalizeNext = false;
            } else {
                buffer.append(ch);
            }
        }
        return buffer.toString();
    };
    constructor.join = function(array) {
        return StringUtils.joinS(array, null);
    };
    constructor.join2 = function(array, separator) {
        if (array == null) {
            return null;
        }
        return StringUtils.join4(array, separator, 0, array.length);
    };
    constructor.join4 = function(array, separator, startIndex, endIndex) {
        if (array == null) {
            return null;
        }
        var bufSize = (endIndex - startIndex);
        if (bufSize <= 0) {
            return "";
        }
        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length) + 1);
        var buf = new StringBuilder(bufSize);
        for (var i = startIndex; i < endIndex; i++) {
            if (i > startIndex) {
                buf.append(separator);
            }
            if (array[i] != null) {
                buf.append(array[i]);
            }
        }
        return buf.toString();
    };
    constructor.joinS = function(array, separator) {
        if (array == null) {
            return null;
        }
        return StringUtils.joinS4(array, separator, 0, array.length);
    };
    constructor.joinS4 = function(array, separator, startIndex, endIndex) {
        if (array == null) {
            return null;
        }
        if (separator == null) {
            separator = "";
        }
        var bufSize = (endIndex - startIndex);
        if (bufSize <= 0) {
            return "";
        }
        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length) + separator.length);
        var buf = new StringBuilder(bufSize);
        for (var i = startIndex; i < endIndex; i++) {
            if (i > startIndex) {
                buf.append(separator);
            }
            if (array[i] != null) {
                buf.append(array[i]);
            }
        }
        return buf.toString();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlUtil = function() {};
EbmlUtil = stjs.extend(EbmlUtil, null, [], function(constructor, prototype) {
    /**
     *  Encodes unsigned integer with given length
     *  
     *  @param value
     *             unsigned integer to be encoded
     *  @param length
     *             ebml sequence length
     *  @return
     */
    constructor.ebmlEncodeLen = function(value, length) {
        var b = new Int8Array(length);
        for (var idx = 0; idx < length; idx++) {
            b[length - idx - 1] = (((value >>> (8 * idx)) & 255) << 24 >> 24);
        }
        b[0] |= 128 >>> (length - 1);
        return b;
    };
    /**
     *  Encodes unsigned integer value according to ebml convention
     *  
     *  @param value
     *             unsigned integer to be encoded
     *  @return
     */
    constructor.ebmlEncode = function(value) {
        return EbmlUtil.ebmlEncodeLen(value, EbmlUtil.ebmlLength(value));
    };
    constructor.lengthOptions = new Int8Array([0, (128 << 24 >> 24), 64, 32, 16, 8, 4, 2, 1]);
    /**
     *  This method is used mostly during reading EBML bitstream. It asnwers the question "What is the length of an integer (signed/unsigned) encountered in the bitstream"
     *  
     *  @param b
     *  @return
     */
    constructor.computeLength = function(b) {
        if (b == 0) 
             throw new RuntimeException("Invalid head element for ebml sequence");
        var i = 1;
         while ((b & EbmlUtil.lengthOptions[i]) == 0)
            i++;
        return i;
    };
    constructor.one = 127;
    constructor.two = 16256;
    constructor.three = 2080768;
    constructor.four = 266338304;
    constructor.five = 34091302912;
    constructor.six = 4363686772736;
    constructor.seven = 558551906910208;
    constructor.eight = 71494644084506624;
    constructor.ebmlLengthMasks = [0, EbmlUtil.one, EbmlUtil.two, EbmlUtil.three, EbmlUtil.four, EbmlUtil.five, EbmlUtil.six, EbmlUtil.seven, EbmlUtil.eight];
    /**
     *  This method is used mostly during writing EBML bitstream. It answers the following question "How many bytes should be used to encode unsigned integer value"
     *  
     *  @param v
     *             unsigned integer to be encoded
     *  @return
     */
    constructor.ebmlLength = function(v) {
        if (v == 0) 
            return 1;
        var length = 8;
         while (length > 0 && (v & EbmlUtil.ebmlLengthMasks[length]) == 0)
            length--;
        return length;
    };
    constructor.toHexString = function(a) {
        var sb = new StringBuilder();
        for (var index$b = 0, arr$b = a; index$b < arr$b.length; index$b++) {
            var b = arr$b[index$b];
            sb.append(String.format("0x%02x ", b & 255));
        }
        return sb.toString();
    };
}, {lengthOptions: "Int8Array", ebmlLengthMasks: "Array"}, {});
var Ints = function() {};
Ints = stjs.extend(Ints, null, [], function(constructor, prototype) {
    /**
     *  Returns the {@code int} value that is equal to {@code value}, if possible.
     * 
     *  @param value any value in the range of the {@code int} type
     *  @return the {@code int} value that equals {@code value}
     *  @throws IllegalArgumentException if {@code value} is greater than {@link
     *      Integer#MAX_VALUE} or less than {@link Integer#MIN_VALUE}
     */
    constructor.checkedCast = function(value) {
        var result = ((value) | 0);
        if (result != value) {
             throw new IllegalArgumentException("Out of range: " + value);
        }
        return result;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Bitstream writer
 *  
 *  @author The JCodec project
 *  
 */
var BitWriter = function(buf) {
    this.buf = buf;
    this.initPos = buf.position();
};
BitWriter = stjs.extend(BitWriter, null, [], function(constructor, prototype) {
    prototype.buf = null;
    prototype.curInt = 0;
    prototype._curBit = 0;
    prototype.initPos = 0;
    prototype.fork = function() {
        var fork = new BitWriter(this.buf.duplicate());
        fork._curBit = this._curBit;
        fork.curInt = this.curInt;
        fork.initPos = this.initPos;
        return fork;
    };
    prototype.flush = function() {
        var toWrite = (this._curBit + 7) >> 3;
        for (var i = 0; i < toWrite; i++) {
            this.buf.put(((this.curInt >>> 24) << 24 >> 24));
            this.curInt <<= 8;
        }
    };
    prototype.putInt = function(i) {
        this.buf.put(((i >>> 24) << 24 >> 24));
        this.buf.put(((i >> 16) << 24 >> 24));
        this.buf.put(((i >> 8) << 24 >> 24));
        this.buf.put((i << 24 >> 24));
    };
    prototype.writeNBit = function(value, n) {
        if (n > 32) 
             throw new IllegalArgumentException("Max 32 bit to write");
        if (n == 0) 
            return;
        value &= -1 >>> (32 - n);
        if (32 - this._curBit >= n) {
            this.curInt |= value << (32 - this._curBit - n);
            this._curBit += n;
            if (this._curBit == 32) {
                this.putInt(this.curInt);
                this._curBit = 0;
                this.curInt = 0;
            }
        } else {
            var secPart = n - (32 - this._curBit);
            this.curInt |= value >>> secPart;
            this.putInt(this.curInt);
            this.curInt = value << (32 - secPart);
            this._curBit = secPart;
        }
    };
    prototype.write1Bit = function(bit) {
        this.curInt |= bit << (32 - this._curBit - 1);
        ++this._curBit;
        if (this._curBit == 32) {
            this.putInt(this.curInt);
            this._curBit = 0;
            this.curInt = 0;
        }
    };
    prototype.curBit = function() {
        return this._curBit & 7;
    };
    prototype.position = function() {
        return ((this.buf.position() - this.initPos) << 3) + this._curBit;
    };
    prototype.getBuffer = function() {
        return this.buf;
    };
}, {buf: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A dummy implementation of H264 RBSP reading
 *  
 *  @author The JCodec project
 *  
 */
var DummyBitstreamReader = function(is) {
    this.is = is;
    this.curByte = is.read();
    this.nextByte = is.read();
    this.secondByte = is.read();
};
DummyBitstreamReader = stjs.extend(DummyBitstreamReader, null, [], function(constructor, prototype) {
    prototype.is = null;
    prototype.curByte = 0;
    prototype.nextByte = 0;
    prototype.secondByte = 0;
    prototype.nBit = 0;
    constructor.bitsRead = 0;
    prototype.cnt = 0;
    prototype.read1Bit = function() {
        return this.read1BitInt();
    };
    prototype.read1BitInt = function() {
        if (this.nBit == 8) {
            this.advance();
            if (this.curByte == -1) {
                return -1;
            }
        }
        var res = (this.curByte >> (7 - this.nBit)) & 1;
        this.nBit++;
        ++DummyBitstreamReader.bitsRead;
        return res;
    };
    prototype.readNBit = function(n) {
        if (n > 32) 
             throw new IllegalArgumentException("Can not read more then 32 bit");
        var val = 0;
        for (var i = 0; i < n; i++) {
            val <<= 1;
            val |= this.read1BitInt();
        }
        return val;
    };
    prototype.advance1 = function() {
        this.curByte = this.nextByte;
        this.nextByte = this.secondByte;
        this.secondByte = this.is.read();
    };
    prototype.advance = function() {
        this.advance1();
        this.nBit = 0;
    };
    prototype.readByte = function() {
        if (this.nBit > 0) {
            this.advance();
        }
        var res = this.curByte;
        this.advance();
        return res;
    };
    prototype.moreRBSPData = function() {
        if (this.nBit == 8) {
            this.advance();
        }
        var tail = 1 << (8 - this.nBit - 1);
        var mask = ((tail << 1) - 1);
        var hasTail = (this.curByte & mask) == tail;
        return !(this.curByte == -1 || (this.nextByte == -1 && hasTail));
    };
    prototype.getBitPosition = function() {
        return (DummyBitstreamReader.bitsRead * 8 + (this.nBit % 8));
    };
    prototype.moreData = function() {
        if (this.nBit == 8) 
            this.advance();
        if (this.curByte == -1) 
            return false;
        if (this.nextByte == -1 || (this.nextByte == 0 && this.secondByte == -1)) {
            var mask = (1 << (8 - this.nBit)) - 1;
            return (this.curByte & mask) != 0;
        }
        return true;
    };
    prototype.readRemainingByte = function() {
        return this.readNBit(8 - this.nBit);
    };
    prototype.peakNextBits = function(n) {
        if (n > 8) 
             throw new IllegalArgumentException("N should be less then 8");
        if (this.nBit == 8) {
            this.advance();
            if (this.curByte == -1) {
                return -1;
            }
        }
        var bits = new Int32Array(16 - this.nBit);
        var cnt = 0;
        for (var i = this.nBit; i < 8; i++) {
            bits[cnt++] = (this.curByte >> (7 - i)) & 1;
        }
        for (var i = 0; i < 8; i++) {
            bits[cnt++] = (this.nextByte >> (7 - i)) & 1;
        }
        var result = 0;
        for (var i = 0; i < n; i++) {
            result <<= 1;
            result |= bits[i];
        }
        return result;
    };
    prototype.isByteAligned = function() {
        return (this.nBit % 8) == 0;
    };
    prototype.close = function() {
        this.is.close();
    };
    prototype.getCurBit = function() {
        return this.nBit;
    };
    prototype.skip = function(bits) {
        this.nBit += bits;
        var was = this.nBit;
         while (this.nBit >= 8 && this.curByte != -1){
            this.advance1();
            this.nBit -= 8;
        }
        return was - this.nBit;
    };
    prototype.align = function() {
        var n = (8 - this.nBit) & 7;
        this.skip((8 - this.nBit) & 7);
        return n;
    };
    prototype.checkNBit = function(n) {
        return this.peakNextBits(n);
    };
    prototype.curBit = function() {
        return this.nBit;
    };
    prototype.lastByte = function() {
        return this.nextByte == -1 && this.secondByte == -1;
    };
}, {is: "InputStream"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var BitReader = function(bb) {
    this.bb = bb;
    this.initPos = bb.position();
};
BitReader = stjs.extend(BitReader, null, [], function(constructor, prototype) {
    constructor.createBitReader = function(bb) {
        var r = new BitReader(bb);
        r.curInt = r.readInt();
        r.deficit = 0;
        return r;
    };
    prototype.deficit = -1;
    prototype.curInt = -1;
    prototype.bb = null;
    prototype.initPos = 0;
    prototype.fork = function() {
        var fork = new BitReader(this.bb.duplicate());
        fork.initPos = 0;
        fork.curInt = this.curInt;
        fork.deficit = this.deficit;
        return fork;
    };
    prototype.readInt = function() {
        if (this.bb.remaining() >= 4) {
            this.deficit -= 32;
            return ((this.bb.get() & 255) << 24) | ((this.bb.get() & 255) << 16) | ((this.bb.get() & 255) << 8) | (this.bb.get() & 255);
        } else 
            return this.readIntSafe();
    };
    prototype.readIntSafe = function() {
        this.deficit -= (this.bb.remaining() << 3);
        var res = 0;
        if (this.bb.hasRemaining()) 
            res |= this.bb.get() & 255;
        res <<= 8;
        if (this.bb.hasRemaining()) 
            res |= this.bb.get() & 255;
        res <<= 8;
        if (this.bb.hasRemaining()) 
            res |= this.bb.get() & 255;
        res <<= 8;
        if (this.bb.hasRemaining()) 
            res |= this.bb.get() & 255;
        return res;
    };
    prototype.read1Bit = function() {
        var ret = this.curInt >>> 31;
        this.curInt <<= 1;
        ++this.deficit;
        if (this.deficit == 32) {
            this.curInt = this.readInt();
        }
        return ret;
    };
    prototype.readNBitSigned = function(n) {
        var v = this.readNBit(n);
        return this.read1Bit() == 0 ? v : -v;
    };
    prototype.readNBit = function(n) {
        if (n > 32) 
             throw new IllegalArgumentException("Can not read more then 32 bit");
        var nn = n;
        var ret = 0;
        if (n + this.deficit > 31) {
            ret |= (this.curInt >>> this.deficit);
            n -= 32 - this.deficit;
            ret <<= n;
            this.deficit = 32;
            this.curInt = this.readInt();
        }
        if (n != 0) {
            ret |= this.curInt >>> (32 - n);
            this.curInt <<= n;
            this.deficit += n;
        }
        return ret;
    };
    prototype.moreData = function() {
        var remaining = this.bb.remaining() + 4 - ((this.deficit + 7) >> 3);
        return remaining > 1 || (remaining == 1 && this.curInt != 0);
    };
    prototype.remaining = function() {
        return (this.bb.remaining() << 3) + 32 - this.deficit;
    };
    prototype.isByteAligned = function() {
        return (this.deficit & 7) == 0;
    };
    prototype.skip = function(bits) {
        var left = bits;
        if (left + this.deficit > 31) {
            left -= 32 - this.deficit;
            this.deficit = 32;
            if (left > 31) {
                var skip = Math.min(left >> 3, this.bb.remaining());
                this.bb.setPosition(this.bb.position() + skip);
                left -= skip << 3;
            }
            this.curInt = this.readInt();
        }
        this.deficit += left;
        this.curInt <<= left;
        return bits;
    };
    prototype.skipFast = function(bits) {
        this.deficit += bits;
        this.curInt <<= bits;
        return bits;
    };
    prototype.bitsToAlign = function() {
        return (this.deficit & 7) > 0 ? 8 - (this.deficit & 7) : 0;
    };
    prototype.align = function() {
        return (this.deficit & 7) > 0 ? this.skip(8 - (this.deficit & 7)) : 0;
    };
    prototype.check24Bits = function() {
        if (this.deficit > 16) {
            this.deficit -= 16;
            this.curInt |= this.nextIgnore16() << this.deficit;
        }
        if (this.deficit > 8) {
            this.deficit -= 8;
            this.curInt |= this.nextIgnore() << this.deficit;
        }
        return this.curInt >>> 8;
    };
    prototype.check16Bits = function() {
        if (this.deficit > 16) {
            this.deficit -= 16;
            this.curInt |= this.nextIgnore16() << this.deficit;
        }
        return this.curInt >>> 16;
    };
    prototype.readFast16 = function(n) {
        if (n == 0) 
            return 0;
        if (this.deficit > 16) {
            this.deficit -= 16;
            this.curInt |= this.nextIgnore16() << this.deficit;
        }
        var ret = this.curInt >>> (32 - n);
        this.deficit += n;
        this.curInt <<= n;
        return ret;
    };
    prototype.checkNBit = function(n) {
        if (n > 24) {
             throw new IllegalArgumentException("Can not check more then 24 bit");
        }
        return this.checkNBitDontCare(n);
    };
    prototype.checkNBitDontCare = function(n) {
         while (this.deficit + n > 32){
            this.deficit -= 8;
            this.curInt |= this.nextIgnore() << this.deficit;
        }
        var res = this.curInt >>> (32 - n);
        return res;
    };
    prototype.nextIgnore16 = function() {
        return this.bb.remaining() > 1 ? this.bb.getShort() & 65535 : (this.bb.hasRemaining() ? ((this.bb.get() & 255) << 8) : 0);
    };
    prototype.nextIgnore = function() {
        return this.bb.hasRemaining() ? this.bb.get() & 255 : 0;
    };
    prototype.curBit = function() {
        return this.deficit & 7;
    };
    prototype.lastByte = function() {
        return this.bb.remaining() + 4 - (this.deficit >> 3) <= 1;
    };
    prototype.terminate = function() {
        var putBack = (32 - this.deficit) >> 3;
        this.bb.setPosition(this.bb.position() - putBack);
    };
    prototype.position = function() {
        return ((this.bb.position() - this.initPos - 4) << 3) + this.deficit;
    };
    /**
     *  Stops this bit reader. Returns underlying ByteBuffer pointer to the next
     *  byte unread byte
     */
    prototype.stop = function() {
        this.bb.setPosition(this.bb.position() - ((32 - this.deficit) >> 3));
    };
    prototype.checkAllBits = function() {
        return this.curInt;
    };
    prototype.readBool = function() {
        return this.read1Bit() == 1;
    };
}, {bb: "ByteBuffer"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Standard exception, thrown when decoding of an AAC frame fails. The message
 *  gives more detailed information about the error.
 *  
 *  @author in-somnia
 */
var AACException = function(message) {
    IOException.call(this, message);
};
AACException = stjs.extend(AACException, IOException, [], function(constructor, prototype) {
    constructor.endOfStream = function() {
        var ex = new AACException("end of stream");
        ex.eos = true;
        return ex;
    };
    prototype.eos = false;
    prototype.isEndOfStream = function() {
        return this.eos;
    };
    constructor.wrap = function(e) {
        if (e != null && stjs.isInstanceOf(e.constructor, AACException)) {
            return e;
        }
        if (e != null && e.getMessage() != null) {
            return new AACException(e.getMessage());
        }
        return new AACException("" + e);
    };
}, {}, {});
/**
 *  
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ColorSpace = function(name, nComp, compPlane, compWidth, compHeight, planar) {
    this._name = name;
    this.nComp = nComp;
    this.compPlane = compPlane;
    this.compWidth = compWidth;
    this.compHeight = compHeight;
    this.planar = planar;
    this.bitsPerPixel = ColorSpace.calcBitsPerPixel(nComp, compWidth, compHeight);
};
ColorSpace = stjs.extend(ColorSpace, null, [], function(constructor, prototype) {
    constructor.MAX_PLANES = 4;
    prototype.nComp = 0;
    prototype.compPlane = null;
    prototype.compWidth = null;
    prototype.compHeight = null;
    prototype.planar = false;
    prototype._name = null;
    prototype.bitsPerPixel = 0;
    prototype.toString = function() {
        return this._name;
    };
    constructor.calcBitsPerPixel = function(nComp, compWidth, compHeight) {
        var bitsPerPixel = 0;
        for (var i = 0; i < nComp; i++) {
            bitsPerPixel += ((8 >> compWidth[i]) >> compHeight[i]);
        }
        return bitsPerPixel;
    };
    prototype.getWidthMask = function() {
        return ~(this.nComp > 1 ? this.compWidth[1] : 0);
    };
    prototype.getHeightMask = function() {
        return ~(this.nComp > 1 ? this.compHeight[1] : 0);
    };
    /**
     *  Determines if two colors match. Aside from simply comparing the objects
     *  this function also takes into account lables ANY, ANY_INTERLEAVED, ANY
     *  PLANAR.
     *  
     *  @param inputColor
     *  @return True if the color is the same or matches the label.
     */
    prototype.matches = function(inputColor) {
        if (inputColor == this) 
            return true;
        if (inputColor == ColorSpace.ANY || this == ColorSpace.ANY) 
            return true;
        if ((inputColor == ColorSpace.ANY_INTERLEAVED || this == ColorSpace.ANY_INTERLEAVED || inputColor == ColorSpace.ANY_PLANAR || this == ColorSpace.ANY_PLANAR) && inputColor.planar == this.planar) 
            return true;
        return false;
    };
    /**
     *  Calculates the component size based on the fullt size and color subsampling of the given component index.
     *  @param size
     *  @return Component size
     */
    prototype.compSize = function(size, comp) {
        if (this.compWidth[comp] == 0 && this.compHeight[comp] == 0) 
            return size;
        return new Size(size.getWidth() >> this.compWidth[comp], size.getHeight() >> this.compHeight[comp]);
    };
    constructor._000 = new Int32Array([0, 0, 0]);
    constructor._011 = new Int32Array([0, 1, 1]);
    constructor._012 = new Int32Array([0, 1, 2]);
    constructor.BGR = new ColorSpace("BGR", 3, ColorSpace._000, ColorSpace._000, ColorSpace._000, false);
    constructor.RGB = new ColorSpace("RGB", 3, ColorSpace._000, ColorSpace._000, ColorSpace._000, false);
    constructor.YUV420 = new ColorSpace("YUV420", 3, ColorSpace._012, ColorSpace._011, ColorSpace._011, true);
    constructor.YUV420J = new ColorSpace("YUV420J", 3, ColorSpace._012, ColorSpace._011, ColorSpace._011, true);
    constructor.YUV422 = new ColorSpace("YUV422", 3, ColorSpace._012, ColorSpace._011, ColorSpace._000, true);
    constructor.YUV422J = new ColorSpace("YUV422J", 3, ColorSpace._012, ColorSpace._011, ColorSpace._000, true);
    constructor.YUV444 = new ColorSpace("YUV444", 3, ColorSpace._012, ColorSpace._000, ColorSpace._000, true);
    constructor.YUV444J = new ColorSpace("YUV444J", 3, ColorSpace._012, ColorSpace._000, ColorSpace._000, true);
    constructor.YUV422_10 = new ColorSpace("YUV422_10", 3, ColorSpace._012, ColorSpace._011, ColorSpace._000, true);
    constructor.GREY = new ColorSpace("GREY", 1, new Int32Array([0]), new Int32Array([0]), new Int32Array([0]), true);
    constructor.MONO = new ColorSpace("MONO", 1, ColorSpace._000, ColorSpace._000, ColorSpace._000, true);
    constructor.YUV444_10 = new ColorSpace("YUV444_10", 3, ColorSpace._012, ColorSpace._000, ColorSpace._000, true);
    /**
     *  Any color space, used in the cases where any color space will do.
     */
    constructor.ANY = new ColorSpace("ANY", 0, null, null, null, true);
    /**
     *  Any planar color space, used in the cases where any planar color space will do.
     */
    constructor.ANY_PLANAR = new ColorSpace("ANY_PLANAR", 0, null, null, null, true);
    /**
     *  Any interleaved color space, used in the cases where any interleaved color space will do.
     */
    constructor.ANY_INTERLEAVED = new ColorSpace("ANY_INTERLEAVED", 0, null, null, null, false);
    /**
     *  Same color, used in filters to declare that the color stays unchanged.
     */
    constructor.SAME = new ColorSpace("SAME", 0, null, null, null, false);
}, {compPlane: "Int32Array", compWidth: "Int32Array", compHeight: "Int32Array", _000: "Int32Array", _011: "Int32Array", _012: "Int32Array", BGR: "ColorSpace", RGB: "ColorSpace", YUV420: "ColorSpace", YUV420J: "ColorSpace", YUV422: "ColorSpace", YUV422J: "ColorSpace", YUV444: "ColorSpace", YUV444J: "ColorSpace", YUV422_10: "ColorSpace", GREY: "ColorSpace", MONO: "ColorSpace", YUV444_10: "ColorSpace", ANY: "ColorSpace", ANY_PLANAR: "ColorSpace", ANY_INTERLEAVED: "ColorSpace", SAME: "ColorSpace"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PictureWithMetadata = function(picture, timestamp, duration, orientation) {
    this.picture = picture;
    this.timestamp = timestamp;
    this.duration = duration;
    this.orientation = orientation;
};
PictureWithMetadata = stjs.extend(PictureWithMetadata, null, [], function(constructor, prototype) {
    prototype.picture = null;
    prototype.timestamp = 0.0;
    prototype.duration = 0.0;
    prototype.orientation = null;
    constructor.createPictureWithMetadata = function(picture, timestamp, duration) {
        return new PictureWithMetadata(picture, timestamp, duration, DemuxerTrackMeta.Orientation.D_0);
    };
    prototype.getPicture = function() {
        return this.picture;
    };
    prototype.getTimestamp = function() {
        return this.timestamp;
    };
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getOrientation = function() {
        return this.orientation;
    };
}, {picture: "Picture", orientation: {name: "Enum", arguments: ["DemuxerTrackMeta.Orientation"]}}, {});
var Boxes = function() {
    this.mappings = new HashMap();
};
Boxes = stjs.extend(Boxes, null, [], function(constructor, prototype) {
    prototype.mappings = null;
    prototype.toClass = function(fourcc) {
        return this.mappings.get(fourcc);
    };
    prototype.override = function(fourcc, cls) {
        this.mappings.put(fourcc, cls);
    };
    prototype.clear = function() {
        this.mappings.clear();
    };
}, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SeekableDemuxerTrack = function() {};
SeekableDemuxerTrack = stjs.extend(SeekableDemuxerTrack, null, [DemuxerTrack], function(constructor, prototype) {
    /**
     *  Goes to exactly frameNo.
     *  
     *  @param frameNo
     *             Frame number, zero based, to go to.
     *  @return Weather or not the operation was successful. Will fail if the
     *          frameNo is out of range.
     *  @throws IOException
     */
    prototype.gotoFrame = function(frameNo) {};
    /**
     *  Goes to a a frame that's a sync frame (key frame) and is prior or at
     *  frame frameNo.
     *  
     *  @param frameNo
     *             Frame number, zero based, related to which a sync frame will
     *             be selected.
     *  @return If the operation was successful.
     *  @throws IOException
     */
    prototype.gotoSyncFrame = function(frameNo) {};
    /**
     *  Gets an index of the frame that the next call to 'nextFrame' will return,
     *  zero based.
     *  
     *  @return An index of the next frame, zero based.
     */
    prototype.getCurFrame = function() {};
    /**
     *  Seeks this container to the second provided so that the next call to
     *  nextFrame will return a frame at that second.
     *  
     *  @param second
     *             A second to seek to.
     *  @throws IOException
     */
    prototype.seek = function(second) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Transforms Picture in RGB colorspace ( one plane, 3 integers per pixel ) to
 *  Yuv420 colorspace output picture ( 3 planes, luma - 0th plane, cb - 1th
 *  plane, cr - 2nd plane; cb and cr planes are half width and half haight )
 *  
 *  TODO: implement jpeg colorspace instead of NTSC
 *  
 *  @author The JCodec project
 *  
 */
var RgbToYuv420jHiBD = function() {};
RgbToYuv420jHiBD = stjs.extend(RgbToYuv420jHiBD, null, [TransformHiBD], function(constructor, prototype) {
    prototype.transform = function(img, dst) {
        var y = img.getData()[0];
        var dstData = dst.getData();
        var offChr = 0, offLuma = 0, offSrc = 0, strideSrc = img.getWidth() * 3, strideDst = dst.getWidth();
        for (var i = 0; i < img.getHeight() >> 1; i++) {
            for (var j = 0; j < img.getWidth() >> 1; j++) {
                dstData[1][offChr] = 0;
                dstData[2][offChr] = 0;
                RgbToYuv420jHiBD.rgb2yuv(y[offSrc], y[offSrc + 1], y[offSrc + 2], dstData[0], offLuma, dstData[1], offChr, dstData[2], offChr);
                dstData[0][offLuma] = dstData[0][offLuma];
                RgbToYuv420jHiBD.rgb2yuv(y[offSrc + strideSrc], y[offSrc + strideSrc + 1], y[offSrc + strideSrc + 2], dstData[0], offLuma + strideDst, dstData[1], offChr, dstData[2], offChr);
                dstData[0][offLuma + strideDst] = dstData[0][offLuma + strideDst];
                ++offLuma;
                RgbToYuv420jHiBD.rgb2yuv(y[offSrc + 3], y[offSrc + 4], y[offSrc + 5], dstData[0], offLuma, dstData[1], offChr, dstData[2], offChr);
                dstData[0][offLuma] = dstData[0][offLuma];
                RgbToYuv420jHiBD.rgb2yuv(y[offSrc + strideSrc + 3], y[offSrc + strideSrc + 4], y[offSrc + strideSrc + 5], dstData[0], offLuma + strideDst, dstData[1], offChr, dstData[2], offChr);
                dstData[0][offLuma + strideDst] = dstData[0][offLuma + strideDst];
                ++offLuma;
                dstData[1][offChr] = dstData[1][offChr] >> 2;
                dstData[2][offChr] = dstData[2][offChr] >> 2;
                ++offChr;
                offSrc += 6;
            }
            offLuma += strideDst;
            offSrc += strideSrc;
        }
    };
    constructor.rgb2yuv = function(r, g, b, Y, offY, U, offU, V, offV) {
        var y = 77 * r + 150 * g + 15 * b;
        var u = -43 * r - 85 * g + 128 * b;
        var v = 128 * r - 107 * g - 21 * b;
        y = (y + 128) >> 8;
        u = (u + 128) >> 8;
        v = (v + 128) >> 8;
        Y[offY] = RgbToYuv420jHiBD.clip(y);
        U[offU] += RgbToYuv420jHiBD.clip(u + 128);
        V[offV] += RgbToYuv420jHiBD.clip(v + 128);
    };
    constructor.clip = function(val) {
        return val < 0 ? 0 : (val > 255 ? 255 : val);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv422pToYuv420pHiBD = function(shiftUp, shiftDown) {
    this.shiftUp = shiftUp;
    this.shiftDown = shiftDown;
};
Yuv422pToYuv420pHiBD = stjs.extend(Yuv422pToYuv420pHiBD, null, [TransformHiBD], function(constructor, prototype) {
    prototype.shiftUp = 0;
    prototype.shiftDown = 0;
    prototype.transform = function(src, dst) {
        var lumaSize = src.getWidth() * src.getHeight();
        System.arraycopy(src.getPlaneData(0), 0, dst.getPlaneData(0), 0, lumaSize);
        this.copyAvg(src.getPlaneData(1), dst.getPlaneData(1), src.getPlaneWidth(1), src.getPlaneHeight(1));
        this.copyAvg(src.getPlaneData(2), dst.getPlaneData(2), src.getPlaneWidth(2), src.getPlaneHeight(2));
        if (this.shiftUp > this.shiftDown) {
            this.up(dst.getPlaneData(0), this.shiftUp - this.shiftDown);
            this.up(dst.getPlaneData(1), this.shiftUp - this.shiftDown);
            this.up(dst.getPlaneData(2), this.shiftUp - this.shiftDown);
        } else if (this.shiftDown > this.shiftUp) {
            this.down(dst.getPlaneData(0), this.shiftDown - this.shiftUp);
            this.down(dst.getPlaneData(1), this.shiftDown - this.shiftUp);
            this.down(dst.getPlaneData(2), this.shiftDown - this.shiftUp);
        }
    };
    prototype.down = function(dst, down) {
        for (var i = 0; i < dst.length; i++) {
            dst[i] >>= down;
        }
    };
    prototype.up = function(dst, up) {
        for (var i = 0; i < dst.length; i++) {
            dst[i] <<= up;
        }
    };
    prototype.copyAvg = function(src, dst, width, height) {
        var offSrc = 0, offDst = 0;
        for (var y = 0; y < stjs.trunc(height / 2); y++) {
            for (var x = 0; x < width; x++ , offDst++ , offSrc++) {
                dst[offDst] = (src[offSrc] + src[offSrc + width] + 1) >> 1;
            }
            offSrc += width;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Transforms Picture in RGB colorspace ( one plane, 3 integers per pixel ) to
 *  Yuv420 colorspace output picture ( 3 planes, luma - 0th plane, cb - 1th
 *  plane, cr - 2nd plane; cb and cr planes are half width and half haight )
 *  
 *  @author The JCodec project
 *  
 */
var RgbToYuv420pHiBD = function(upShift, downShift) {
    this.upShift = upShift;
    this.downShift = downShift;
    this.downShiftChr = downShift + 2;
};
RgbToYuv420pHiBD = stjs.extend(RgbToYuv420pHiBD, null, [TransformHiBD], function(constructor, prototype) {
    prototype.upShift = 0;
    prototype.downShift = 0;
    prototype.downShiftChr = 0;
    prototype.transform = function(img, dst) {
        var y = img.getData()[0];
        var dstData = dst.getData();
        var offChr = 0, offLuma = 0, offSrc = 0, strideSrc = img.getWidth() * 3, strideDst = dst.getWidth();
        for (var i = 0; i < img.getHeight() >> 1; i++) {
            for (var j = 0; j < img.getWidth() >> 1; j++) {
                dstData[1][offChr] = 0;
                dstData[2][offChr] = 0;
                RgbToYuv420pHiBD.rgb2yuv(y[offSrc], y[offSrc + 1], y[offSrc + 2], dstData[0], offLuma, dstData[1], offChr, dstData[2], offChr);
                dstData[0][offLuma] = (dstData[0][offLuma] << this.upShift) >> this.downShift;
                RgbToYuv420pHiBD.rgb2yuv(y[offSrc + strideSrc], y[offSrc + strideSrc + 1], y[offSrc + strideSrc + 2], dstData[0], offLuma + strideDst, dstData[1], offChr, dstData[2], offChr);
                dstData[0][offLuma + strideDst] = (dstData[0][offLuma + strideDst] << this.upShift) >> this.downShift;
                ++offLuma;
                RgbToYuv420pHiBD.rgb2yuv(y[offSrc + 3], y[offSrc + 4], y[offSrc + 5], dstData[0], offLuma, dstData[1], offChr, dstData[2], offChr);
                dstData[0][offLuma] = (dstData[0][offLuma] << this.upShift) >> this.downShift;
                RgbToYuv420pHiBD.rgb2yuv(y[offSrc + strideSrc + 3], y[offSrc + strideSrc + 4], y[offSrc + strideSrc + 5], dstData[0], offLuma + strideDst, dstData[1], offChr, dstData[2], offChr);
                dstData[0][offLuma + strideDst] = (dstData[0][offLuma + strideDst] << this.upShift) >> this.downShift;
                ++offLuma;
                dstData[1][offChr] = (dstData[1][offChr] << this.upShift) >> this.downShiftChr;
                dstData[2][offChr] = (dstData[2][offChr] << this.upShift) >> this.downShiftChr;
                ++offChr;
                offSrc += 6;
            }
            offLuma += strideDst;
            offSrc += strideSrc;
        }
    };
    constructor.rgb2yuv = function(r, g, b, Y, offY, U, offU, V, offV) {
        var y = 66 * r + 129 * g + 25 * b;
        var u = -38 * r - 74 * g + 112 * b;
        var v = 112 * r - 94 * g - 18 * b;
        y = (y + 128) >> 8;
        u = (u + 128) >> 8;
        v = (v + 128) >> 8;
        Y[offY] = RgbToYuv420pHiBD.clip(y + 16);
        U[offU] += RgbToYuv420pHiBD.clip(u + 128);
        V[offV] += RgbToYuv420pHiBD.clip(v + 128);
    };
    constructor.clip = function(val) {
        return val < 0 ? 0 : (val > 255 ? 255 : val);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv420pToYuv422pHiBD = function(shiftUp, shiftDown) {
    this.shiftUp = shiftUp;
    this.shiftDown = shiftDown;
};
Yuv420pToYuv422pHiBD = stjs.extend(Yuv420pToYuv422pHiBD, null, [TransformHiBD], function(constructor, prototype) {
    prototype.shiftUp = 0;
    prototype.shiftDown = 0;
    prototype.transform = function(src, dst) {
        Yuv420pToYuv422pHiBD.copy(src.getPlaneData(0), dst.getPlaneData(0), src.getWidth(), dst.getWidth(), dst.getHeight(), this.shiftUp, this.shiftDown);
        Yuv420pToYuv422pHiBD._copy(src.getPlaneData(1), dst.getPlaneData(1), 0, 0, 1, 2, src.getWidth() >> 1, dst.getWidth() >> 1, src.getHeight() >> 1, dst.getHeight(), this.shiftUp, this.shiftDown);
        Yuv420pToYuv422pHiBD._copy(src.getPlaneData(1), dst.getPlaneData(1), 0, 1, 1, 2, src.getWidth() >> 1, dst.getWidth() >> 1, src.getHeight() >> 1, dst.getHeight(), this.shiftUp, this.shiftDown);
        Yuv420pToYuv422pHiBD._copy(src.getPlaneData(2), dst.getPlaneData(2), 0, 0, 1, 2, src.getWidth() >> 1, dst.getWidth() >> 1, src.getHeight() >> 1, dst.getHeight(), this.shiftUp, this.shiftDown);
        Yuv420pToYuv422pHiBD._copy(src.getPlaneData(2), dst.getPlaneData(2), 0, 1, 1, 2, src.getWidth() >> 1, dst.getWidth() >> 1, src.getHeight() >> 1, dst.getHeight(), this.shiftUp, this.shiftDown);
    };
    constructor._copy = function(src, dest, offX, offY, stepX, stepY, strideSrc, strideDest, heightSrc, heightDst, upShift, downShift) {
        var offD = offX + offY * strideDest, srcOff = 0;
        for (var i = 0; i < heightSrc; i++) {
            for (var j = 0; j < strideSrc; j++) {
                dest[offD] = (src[srcOff++] & 255) << 2;
                offD += stepX;
            }
            var lastOff = offD - stepX;
            for (var j = strideSrc * stepX; j < strideDest; j += stepX) {
                dest[offD] = dest[lastOff];
                offD += stepX;
            }
            offD += (stepY - 1) * strideDest;
        }
        var lastLine = offD - stepY * strideDest;
        for (var i = heightSrc * stepY; i < heightDst; i += stepY) {
            for (var j = 0; j < strideDest; j += stepX) {
                dest[offD] = dest[lastLine + j];
                offD += stepX;
            }
            offD += (stepY - 1) * strideDest;
        }
    };
    constructor.copy = function(src, dest, srcWidth, dstWidth, dstHeight, shiftUp, shiftDown) {
        var height = stjs.trunc(src.length / srcWidth);
        var dstOff = 0, srcOff = 0;
        for (var i = 0; i < height; i++) {
            for (var j = 0; j < srcWidth; j++) {
                dest[dstOff++] = (src[srcOff++] & 255) << 2;
            }
            for (var j = srcWidth; j < dstWidth; j++) 
                dest[dstOff++] = dest[srcWidth - 1];
        }
        var lastLine = (height - 1) * dstWidth;
        for (var i = height; i < dstHeight; i++) {
            for (var j = 0; j < dstWidth; j++) {
                dest[dstOff++] = dest[lastLine + j];
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv444pToRgb = function(downShift, upShift) {
    this.downShift = downShift;
    this.upShift = upShift;
};
Yuv444pToRgb = stjs.extend(Yuv444pToRgb, null, [TransformHiBD], function(constructor, prototype) {
    prototype.downShift = 0;
    prototype.upShift = 0;
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        for (var i = 0, srcOff = 0, dstOff = 0; i < dst.getHeight(); i++) {
            for (var j = 0; j < dst.getWidth(); j++ , srcOff++ , dstOff += 3) {
                Yuv444pToRgb.YUV444toRGB888((y[srcOff] << this.upShift) >> this.downShift, (u[srcOff] << this.upShift) >> this.downShift, (v[srcOff] << this.upShift) >> this.downShift, data, dstOff);
            }
        }
    };
    constructor.YUV444toRGB888 = function(y, u, v, data, off) {
        var c = y - 16;
        var d = u - 128;
        var e = v - 128;
        var r = (298 * c + 409 * e + 128) >> 8;
        var g = (298 * c - 100 * d - 208 * e + 128) >> 8;
        var b = (298 * c + 516 * d + 128) >> 8;
        data[off] = Yuv444pToRgb.crop(r);
        data[off + 1] = Yuv444pToRgb.crop(g);
        data[off + 2] = Yuv444pToRgb.crop(b);
    };
    constructor.crop = function(val) {
        return val < 0 ? 0 : (val > 255 ? 255 : val);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv422jToYuv420pHiBD = function() {};
Yuv422jToYuv420pHiBD = stjs.extend(Yuv422jToYuv420pHiBD, null, [TransformHiBD], function(constructor, prototype) {
    constructor.Y_COEFF = 7168;
    prototype.transform = function(src, dst) {
        var sy = src.getPlaneData(0);
        var dy = dst.getPlaneData(0);
        for (var i = 0; i < src.getPlaneWidth(0) * src.getPlaneHeight(0); i++) 
            dy[i] = (sy[i] * Yuv422jToYuv420pHiBD.Y_COEFF >> 13) + 16;
        this.copyAvg(src.getPlaneData(1), dst.getPlaneData(1), src.getPlaneWidth(1), src.getPlaneHeight(1));
        this.copyAvg(src.getPlaneData(2), dst.getPlaneData(2), src.getPlaneWidth(2), src.getPlaneHeight(2));
    };
    prototype.copyAvg = function(src, dst, width, height) {
        var offSrc = 0, offDst = 0;
        for (var y = 0; y < stjs.trunc(height / 2); y++) {
            for (var x = 0; x < width; x++ , offDst++ , offSrc++) {
                var a = ((src[offSrc] - 128) * Yuv422jToYuv420pHiBD.Y_COEFF >> 13) + 128;
                var b = ((src[offSrc + width] - 128) * Yuv422jToYuv420pHiBD.Y_COEFF >> 13) + 128;
                dst[offDst] = (a + b + 1) >> 1;
            }
            offSrc += width;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv444pToYuv420pHiBD = function(shiftUp, shiftDown) {
    this.shiftUp = shiftUp;
    this.shiftDown = shiftDown;
};
Yuv444pToYuv420pHiBD = stjs.extend(Yuv444pToYuv420pHiBD, null, [TransformHiBD], function(constructor, prototype) {
    prototype.shiftUp = 0;
    prototype.shiftDown = 0;
    prototype.transform = function(src, dst) {
        var lumaSize = src.getWidth() * src.getHeight();
        System.arraycopy(src.getPlaneData(0), 0, dst.getPlaneData(0), 0, lumaSize);
        this.copyAvg(src.getPlaneData(1), dst.getPlaneData(1), src.getPlaneWidth(1), src.getPlaneHeight(1));
        this.copyAvg(src.getPlaneData(2), dst.getPlaneData(2), src.getPlaneWidth(2), src.getPlaneHeight(2));
        if (this.shiftUp > this.shiftDown) {
            this.up(dst.getPlaneData(0), this.shiftUp - this.shiftDown);
            this.up(dst.getPlaneData(1), this.shiftUp - this.shiftDown);
            this.up(dst.getPlaneData(2), this.shiftUp - this.shiftDown);
        } else if (this.shiftDown > this.shiftUp) {
            this.down(dst.getPlaneData(0), this.shiftDown - this.shiftUp);
            this.down(dst.getPlaneData(1), this.shiftDown - this.shiftUp);
            this.down(dst.getPlaneData(2), this.shiftDown - this.shiftUp);
        }
    };
    prototype.down = function(dst, down) {
        for (var i = 0; i < dst.length; i++) {
            dst[i] >>= down;
        }
    };
    prototype.up = function(dst, up) {
        for (var i = 0; i < dst.length; i++) {
            dst[i] <<= up;
        }
    };
    prototype.copyAvg = function(src, dst, width, height) {
        var offSrc = 0, offDst = 0;
        for (var y = 0; y < (height >> 1); y++) {
            for (var x = 0; x < width; x += 2 , offDst++ , offSrc += 2) {
                dst[offDst] = (src[offSrc] + src[offSrc + 1] + src[offSrc + width] + src[offSrc + width + 1] + 2) >> 2;
            }
            offSrc += width;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Performs color scaling from JPEG to NTSC
 *  
 *  @author The JCodec project
 *  
 */
var Yuv420jToYuv420HiBD = function() {};
Yuv420jToYuv420HiBD = stjs.extend(Yuv420jToYuv420HiBD, null, [TransformHiBD], function(constructor, prototype) {
    constructor.Y_COEFF = 7168;
    prototype.transform = function(src, dst) {
        var sy = src.getPlaneData(0);
        var dy = dst.getPlaneData(0);
        for (var i = 0; i < src.getPlaneWidth(0) * src.getPlaneHeight(0); i++) 
            dy[i] = (sy[i] * Yuv420jToYuv420HiBD.Y_COEFF >> 13) + 16;
        var su = src.getPlaneData(1);
        var du = dst.getPlaneData(1);
        for (var i = 0; i < src.getPlaneWidth(1) * src.getPlaneHeight(1); i++) 
            du[i] = ((su[i] - 128) * Yuv420jToYuv420HiBD.Y_COEFF >> 13) + 128;
        var sv = src.getPlaneData(2);
        var dv = dst.getPlaneData(2);
        for (var i = 0; i < src.getPlaneWidth(2) * src.getPlaneHeight(2); i++) 
            dv[i] = ((sv[i] - 128) * Yuv420jToYuv420HiBD.Y_COEFF >> 13) + 128;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv422pToRgbHiBD = function(downShift, upShift) {
    this.downShift = downShift;
    this.upShift = upShift;
};
Yuv422pToRgbHiBD = stjs.extend(Yuv422pToRgbHiBD, null, [TransformHiBD], function(constructor, prototype) {
    prototype.downShift = 0;
    prototype.upShift = 0;
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        var offLuma = 0, offChroma = 0;
        for (var i = 0; i < dst.getHeight(); i++) {
            for (var j = 0; j < dst.getWidth(); j += 2) {
                Yuv422pToRgbHiBD.YUV444toRGB888((y[offLuma] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, offLuma * 3);
                Yuv422pToRgbHiBD.YUV444toRGB888((y[offLuma + 1] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + 1) * 3);
                offLuma += 2;
                ++offChroma;
            }
        }
    };
    constructor.YUV444toRGB888 = function(y, u, v, data, off) {
        var c = y - 16;
        var d = u - 128;
        var e = v - 128;
        var r = (298 * c + 409 * e + 128) >> 8;
        var g = (298 * c - 100 * d - 208 * e + 128) >> 8;
        var b = (298 * c + 516 * d + 128) >> 8;
        data[off] = Yuv422pToRgbHiBD.crop(r);
        data[off + 1] = Yuv422pToRgbHiBD.crop(g);
        data[off + 2] = Yuv422pToRgbHiBD.crop(b);
    };
    constructor.crop = function(val) {
        return val < 0 ? 0 : (val > 255 ? 255 : val);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv444jToYuv420pHiBD = function() {};
Yuv444jToYuv420pHiBD = stjs.extend(Yuv444jToYuv420pHiBD, null, [TransformHiBD], function(constructor, prototype) {
    constructor.Y_COEFF = 7168;
    prototype.transform = function(src, dst) {
        var sy = src.getPlaneData(0);
        var dy = dst.getPlaneData(0);
        for (var i = 0; i < src.getPlaneWidth(0) * src.getPlaneHeight(0); i++) 
            dy[i] = (sy[i] * Yuv444jToYuv420pHiBD.Y_COEFF >> 13) + 16;
        this.copyAvg(src.getPlaneData(1), dst.getPlaneData(1), src.getPlaneWidth(1), src.getPlaneHeight(1));
        this.copyAvg(src.getPlaneData(2), dst.getPlaneData(2), src.getPlaneWidth(2), src.getPlaneHeight(2));
    };
    prototype.copyAvg = function(src, dst, width, height) {
        var offSrc = 0, offDst = 0;
        for (var y = 0; y < (height >> 1); y++) {
            for (var x = 0; x < width; x += 2 , offDst++ , offSrc += 2) {
                var a = ((src[offSrc] - 128) * Yuv444jToYuv420pHiBD.Y_COEFF >> 13) + 128;
                var b = ((src[offSrc + 1] - 128) * Yuv444jToYuv420pHiBD.Y_COEFF >> 13) + 128;
                var c = ((src[offSrc + width] - 128) * Yuv444jToYuv420pHiBD.Y_COEFF >> 13) + 128;
                var d = ((src[offSrc + width + 1] - 128) * Yuv444jToYuv420pHiBD.Y_COEFF >> 13) + 128;
                dst[offDst] = (a + b + c + d + 2) >> 2;
            }
            offSrc += width;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv422pToYuv420jHiBD = function(upshift, downshift) {
    this.shift = downshift + 13 - upshift;
    if (this.shift < 0) {
         throw new IllegalArgumentException("Maximum upshift allowed: " + (downshift + 13));
    }
    this.halfSrc = 128 << Math.max(downshift - upshift, 0);
    this.halfDst = 128 << Math.max(upshift - downshift, 0);
};
Yuv422pToYuv420jHiBD = stjs.extend(Yuv422pToYuv420jHiBD, null, [TransformHiBD], function(constructor, prototype) {
    constructor.COEFF = 9362;
    prototype.shift = 0;
    prototype.halfSrc = 0;
    prototype.halfDst = 0;
    prototype.transform = function(src, dst) {
        var sy = src.getPlaneData(0);
        var dy = dst.getPlaneData(0);
        for (var i = 0; i < src.getPlaneWidth(0) * src.getPlaneHeight(0); i++) 
            dy[i] = (sy[i] - 16) * Yuv422pToYuv420jHiBD.COEFF >> this.shift;
        this.copyAvg(src.getPlaneData(1), dst.getPlaneData(1), src.getPlaneWidth(1), src.getPlaneHeight(1));
        this.copyAvg(src.getPlaneData(2), dst.getPlaneData(2), src.getPlaneWidth(2), src.getPlaneHeight(2));
    };
    prototype.copyAvg = function(src, dst, width, height) {
        var offSrc = 0, offDst = 0;
        for (var y = 0; y < stjs.trunc(height / 2); y++) {
            for (var x = 0; x < width; x++ , offDst++ , offSrc++) {
                var a = ((src[offSrc] - this.halfSrc) * Yuv422pToYuv420jHiBD.COEFF >> this.shift) + this.halfDst;
                var b = ((src[offSrc + width] - this.halfSrc) * Yuv422pToYuv420jHiBD.COEFF >> this.shift) + this.halfDst;
                dst[offDst] = (a + b + 1) >> 1;
            }
            offSrc += width;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var VideoFrameWithPacket = function(inFrame, dec2) {
    this.packet = inFrame;
    this.frame = dec2;
};
VideoFrameWithPacket = stjs.extend(VideoFrameWithPacket, null, [Comparable], function(constructor, prototype) {
    prototype.packet = null;
    prototype.frame = null;
    prototype.compareTo = function(arg) {
        if (arg == null) 
            return -1;
         else {
            var pts1 = this.packet.getPts();
            var pts2 = arg.packet.getPts();
            return pts1 > pts2 ? 1 : (pts1 == pts2 ? 0 : -1);
        }
    };
    prototype.getPacket = function() {
        return this.packet;
    };
    prototype.getFrame = function() {
        return this.frame;
    };
}, {packet: "Packet", frame: "PixelStore.LoanerPicture"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  The encoder for yuv 10 bit 422
 *  
 *  x|x|9876543210(cr0)|9876543210(y0) |9876543210(cb0) x|x|9876543210(y2)
 *  |9876543210(cb1)|9876543210(y1) x|x|9876543210(cb2)|9876543210(y3)
 *  |9876543210(cr1) x|x|9876543210(y5) |9876543210(cr2)|9876543210(y4)
 *  
 *  @author The JCodec project
 *  
 */
var V210Encoder = function() {};
V210Encoder = stjs.extend(V210Encoder, null, [], function(constructor, prototype) {
    prototype.encodeFrame = function(_out, frame) {
        var out = _out.duplicate();
        out.order(ByteOrder.LITTLE_ENDIAN);
        var tgtStride = (stjs.trunc((frame.getPlaneWidth(0) + 47) / 48)) * 48;
        var data = frame.getData();
        var tmpY = new Int8Array(tgtStride);
        var tmpCb = new Int8Array(tgtStride >> 1);
        var tmpCr = new Int8Array(tgtStride >> 1);
        var yOff = 0, cbOff = 0, crOff = 0;
        for (var yy = 0; yy < frame.getHeight(); yy++) {
            System.arraycopy(data[0], yOff, tmpY, 0, frame.getPlaneWidth(0));
            System.arraycopy(data[1], cbOff, tmpCb, 0, frame.getPlaneWidth(1));
            System.arraycopy(data[2], crOff, tmpCr, 0, frame.getPlaneWidth(2));
            for (var yi = 0, cbi = 0, cri = 0; yi < tgtStride; ) {
                var i = 0;
                i |= V210Encoder.clip(tmpCr[cri++]) << 20;
                i |= V210Encoder.clip(tmpY[yi++]) << 10;
                i |= V210Encoder.clip(tmpCb[cbi++]);
                out.putInt(i);
                i = 0;
                i |= V210Encoder.clip(tmpY[yi++]);
                i |= V210Encoder.clip(tmpY[yi++]) << 20;
                i |= V210Encoder.clip(tmpCb[cbi++]) << 10;
                out.putInt(i);
                i = 0;
                i |= V210Encoder.clip(tmpCb[cbi++]) << 20;
                i |= V210Encoder.clip(tmpY[yi++]) << 10;
                i |= V210Encoder.clip(tmpCr[cri++]);
                out.putInt(i);
                i = 0;
                i |= V210Encoder.clip(tmpY[yi++]);
                i |= V210Encoder.clip(tmpY[yi++]) << 20;
                i |= V210Encoder.clip(tmpCr[cri++]) << 10;
                out.putInt(i);
            }
            yOff += frame.getPlaneWidth(0);
            cbOff += frame.getPlaneWidth(1);
            crOff += frame.getPlaneWidth(2);
        }
        out.flip();
        return out;
    };
    constructor.clip = function(val) {
        return MathUtil.clip((val + 128) << 2, 8, 1019);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEG4DCT = function() {};
MPEG4DCT = stjs.extend(MPEG4DCT, null, [], function(constructor, prototype) {
    constructor.W1 = 2841;
    constructor.W2 = 2676;
    constructor.W3 = 2408;
    constructor.W5 = 1609;
    constructor.W6 = 1108;
    constructor.W7 = 565;
    constructor.idctPut = function(p, block, interlacing) {
        MPEG4DCT.idctRows(block[0]);
        MPEG4DCT.idctRows(block[1]);
        MPEG4DCT.idctRows(block[2]);
        MPEG4DCT.idctRows(block[3]);
        MPEG4DCT.idctRows(block[4]);
        MPEG4DCT.idctRows(block[5]);
        var stride = 16;
        var stride2 = 8;
        var nextBlock = 128;
        if (interlacing) {
            nextBlock = stride;
            stride *= 2;
        }
        MPEG4DCT.idctColumnsPut(block[0], p[0], 0, stride);
        MPEG4DCT.idctColumnsPut(block[1], p[0], 8, stride);
        MPEG4DCT.idctColumnsPut(block[2], p[0], nextBlock, stride);
        MPEG4DCT.idctColumnsPut(block[3], p[0], nextBlock + 8, stride);
        MPEG4DCT.idctColumnsPut(block[4], p[1], 0, stride2);
        MPEG4DCT.idctColumnsPut(block[5], p[2], 0, stride2);
    };
    constructor.idctAdd = function(p, block, index, interlacing) {
        MPEG4DCT.idctRows(block);
        switch (index) {
            case 0:
                MPEG4DCT.idctColumnsAdd(block, p[0], 0, 16);
                break;
            case 1:
                MPEG4DCT.idctColumnsAdd(block, p[0], 8, 16);
                break;
            case 2:
                if (interlacing) {
                    MPEG4DCT.idctColumnsAdd(block, p[0], 16, 32);
                } else {
                    MPEG4DCT.idctColumnsAdd(block, p[0], 128, 16);
                }
                break;
            case 3:
                if (interlacing) {
                    MPEG4DCT.idctColumnsAdd(block, p[0], 24, 32);
                } else {
                    MPEG4DCT.idctColumnsAdd(block, p[0], 136, 16);
                }
                break;
            case 4:
                MPEG4DCT.idctColumnsAdd(block, p[1], 0, 8);
                break;
            case 5:
                MPEG4DCT.idctColumnsAdd(block, p[2], 0, 8);
                break;
        }
    };
    constructor.clamp255 = function(val) {
        val -= 255;
        val = -(255 + ((val >> 31) & val));
        return (((-((val >> 31) & val)) - 128) << 24 >> 24);
    };
    constructor.idctColumnsPut = function(block, dst, dstOffset, stride) {
        var X0, X1, X2, X3, X4, X5, X6, X7, X8;
        for (var i = 0; i < 8; i++) {
            var offset = dstOffset + i;
            if (((X1 = (block[i + 8 * 4] << 8)) | (X2 = block[i + 8 * 6]) | (X3 = block[i + 8 * 2]) | (X4 = block[i + 8 * 1]) | (X5 = block[i + 8 * 7]) | (X6 = block[i + 8 * 5]) | (X7 = block[i + 8 * 3])) == 0) {
                dst[offset + stride * 0] = dst[offset + stride * 1] = dst[offset + stride * 2] = dst[offset + stride * 3] = dst[offset + stride * 4] = dst[offset + stride * 5] = dst[offset + stride * 6] = dst[offset + stride * 7] = MPEG4DCT.clamp255(((block[i + 8 * 0] + 32) >> 6));
                continue;
            }
            X0 = (block[i + 8 * 0] << 8) + 8192;
            X8 = MPEG4DCT.W7 * (X4 + X5) + 4;
            X4 = (X8 + (MPEG4DCT.W1 - MPEG4DCT.W7) * X4) >> 3;
            X5 = (X8 - (MPEG4DCT.W1 + MPEG4DCT.W7) * X5) >> 3;
            X8 = MPEG4DCT.W3 * (X6 + X7) + 4;
            X6 = (X8 - (MPEG4DCT.W3 - MPEG4DCT.W5) * X6) >> 3;
            X7 = (X8 - (MPEG4DCT.W3 + MPEG4DCT.W5) * X7) >> 3;
            X8 = X0 + X1;
            X0 -= X1;
            X1 = MPEG4DCT.W6 * (X3 + X2) + 4;
            X2 = (X1 - (MPEG4DCT.W2 + MPEG4DCT.W6) * X2) >> 3;
            X3 = (X1 + (MPEG4DCT.W2 - MPEG4DCT.W6) * X3) >> 3;
            X1 = X4 + X6;
            X4 -= X6;
            X6 = X5 + X7;
            X5 -= X7;
            X7 = X8 + X3;
            X8 -= X3;
            X3 = X0 + X2;
            X0 -= X2;
            X2 = (181 * (X4 + X5) + 128) >> 8;
            X4 = (181 * (X4 - X5) + 128) >> 8;
            dst[offset + stride * 0] = MPEG4DCT.clamp255((X7 + X1) >> 14);
            dst[offset + stride * 1] = MPEG4DCT.clamp255((X3 + X2) >> 14);
            dst[offset + stride * 2] = MPEG4DCT.clamp255((X0 + X4) >> 14);
            dst[offset + stride * 3] = MPEG4DCT.clamp255((X8 + X6) >> 14);
            dst[offset + stride * 4] = MPEG4DCT.clamp255((X8 - X6) >> 14);
            dst[offset + stride * 5] = MPEG4DCT.clamp255((X0 - X4) >> 14);
            dst[offset + stride * 6] = MPEG4DCT.clamp255((X3 - X2) >> 14);
            dst[offset + stride * 7] = MPEG4DCT.clamp255((X7 - X1) >> 14);
        }
    };
    constructor.idctColumnsAdd = function(block, dst, dstOffset, stride) {
        var X0, X1, X2, X3, X4, X5, X6, X7, X8;
        for (var i = 0; i < 8; i++) {
            var offset = dstOffset + i;
            if (((X1 = (block[i + 8 * 4] << 8)) | (X2 = block[i + 8 * 6]) | (X3 = block[i + 8 * 2]) | (X4 = block[i + 8 * 1]) | (X5 = block[i + 8 * 7]) | (X6 = block[i + 8 * 5]) | (X7 = block[i + 8 * 3])) == 0) {
                var pixel = (block[i + 8 * 0] + 32) >> 6;
                dst[offset + stride * 0] = (MathUtil.clip(dst[offset + stride * 0] + pixel, -128, 127) << 24 >> 24);
                dst[offset + stride * 1] = (MathUtil.clip(dst[offset + stride * 1] + pixel, -128, 127) << 24 >> 24);
                dst[offset + stride * 2] = (MathUtil.clip(dst[offset + stride * 2] + pixel, -128, 127) << 24 >> 24);
                dst[offset + stride * 3] = (MathUtil.clip(dst[offset + stride * 3] + pixel, -128, 127) << 24 >> 24);
                dst[offset + stride * 4] = (MathUtil.clip(dst[offset + stride * 4] + pixel, -128, 127) << 24 >> 24);
                dst[offset + stride * 5] = (MathUtil.clip(dst[offset + stride * 5] + pixel, -128, 127) << 24 >> 24);
                dst[offset + stride * 6] = (MathUtil.clip(dst[offset + stride * 6] + pixel, -128, 127) << 24 >> 24);
                dst[offset + stride * 7] = (MathUtil.clip(dst[offset + stride * 7] + pixel, -128, 127) << 24 >> 24);
                continue;
            }
            X0 = (block[i + 8 * 0] << 8) + 8192;
            X8 = MPEG4DCT.W7 * (X4 + X5) + 4;
            X4 = (X8 + (MPEG4DCT.W1 - MPEG4DCT.W7) * X4) >> 3;
            X5 = (X8 - (MPEG4DCT.W1 + MPEG4DCT.W7) * X5) >> 3;
            X8 = MPEG4DCT.W3 * (X6 + X7) + 4;
            X6 = (X8 - (MPEG4DCT.W3 - MPEG4DCT.W5) * X6) >> 3;
            X7 = (X8 - (MPEG4DCT.W3 + MPEG4DCT.W5) * X7) >> 3;
            X8 = X0 + X1;
            X0 -= X1;
            X1 = MPEG4DCT.W6 * (X3 + X2) + 4;
            X2 = (X1 - (MPEG4DCT.W2 + MPEG4DCT.W6) * X2) >> 3;
            X3 = (X1 + (MPEG4DCT.W2 - MPEG4DCT.W6) * X3) >> 3;
            X1 = X4 + X6;
            X4 -= X6;
            X6 = X5 + X7;
            X5 -= X7;
            X7 = X8 + X3;
            X8 -= X3;
            X3 = X0 + X2;
            X0 -= X2;
            X2 = (181 * (X4 + X5) + 128) >> 8;
            X4 = (181 * (X4 - X5) + 128) >> 8;
            dst[offset + stride * 0] = (MathUtil.clip(dst[offset + stride * 0] + ((X7 + X1) >> 14), -128, 127) << 24 >> 24);
            dst[offset + stride * 1] = (MathUtil.clip(dst[offset + stride * 1] + ((X3 + X2) >> 14), -128, 127) << 24 >> 24);
            dst[offset + stride * 2] = (MathUtil.clip(dst[offset + stride * 2] + ((X0 + X4) >> 14), -128, 127) << 24 >> 24);
            dst[offset + stride * 3] = (MathUtil.clip(dst[offset + stride * 3] + ((X8 + X6) >> 14), -128, 127) << 24 >> 24);
            dst[offset + stride * 4] = (MathUtil.clip(dst[offset + stride * 4] + ((X8 - X6) >> 14), -128, 127) << 24 >> 24);
            dst[offset + stride * 5] = (MathUtil.clip(dst[offset + stride * 5] + ((X0 - X4) >> 14), -128, 127) << 24 >> 24);
            dst[offset + stride * 6] = (MathUtil.clip(dst[offset + stride * 6] + ((X3 - X2) >> 14), -128, 127) << 24 >> 24);
            dst[offset + stride * 7] = (MathUtil.clip(dst[offset + stride * 7] + ((X7 - X1) >> 14), -128, 127) << 24 >> 24);
        }
    };
    constructor.idctRows = function(block) {
        var X0, X1, X2, X3, X4, X5, X6, X7, X8;
        for (var i = 0; i < 8; i++) {
            var offset = i << 3;
            if (((X1 = block[offset + 4] << 11) | (X2 = block[offset + 6]) | (X3 = block[offset + 2]) | (X4 = block[offset + 1]) | (X5 = block[offset + 7]) | (X6 = block[offset + 5]) | (X7 = block[offset + 3])) == 0) {
                block[offset] = block[offset + 1] = block[offset + 2] = block[offset + 3] = block[offset + 4] = block[offset + 5] = block[offset + 6] = block[offset + 7] = (((block[offset] << 3)) << 16 >> 16);
                continue;
            }
            X0 = (block[offset] << 11) + 128;
            X8 = MPEG4DCT.W7 * (X4 + X5);
            X4 = X8 + (MPEG4DCT.W1 - MPEG4DCT.W7) * X4;
            X5 = X8 - (MPEG4DCT.W1 + MPEG4DCT.W7) * X5;
            X8 = MPEG4DCT.W3 * (X6 + X7);
            X6 = X8 - (MPEG4DCT.W3 - MPEG4DCT.W5) * X6;
            X7 = X8 - (MPEG4DCT.W3 + MPEG4DCT.W5) * X7;
            X8 = X0 + X1;
            X0 -= X1;
            X1 = MPEG4DCT.W6 * (X3 + X2);
            X2 = X1 - (MPEG4DCT.W2 + MPEG4DCT.W6) * X2;
            X3 = X1 + (MPEG4DCT.W2 - MPEG4DCT.W6) * X3;
            X1 = X4 + X6;
            X4 -= X6;
            X6 = X5 + X7;
            X5 -= X7;
            X7 = X8 + X3;
            X8 -= X3;
            X3 = X0 + X2;
            X0 -= X2;
            X2 = (181 * (X4 + X5) + 128) >> 8;
            X4 = (181 * (X4 - X5) + 128) >> 8;
            block[offset] = ((((X7 + X1) >> 8)) << 16 >> 16);
            block[offset + 1] = ((((X3 + X2) >> 8)) << 16 >> 16);
            block[offset + 2] = ((((X0 + X4) >> 8)) << 16 >> 16);
            block[offset + 3] = ((((X8 + X6) >> 8)) << 16 >> 16);
            block[offset + 4] = ((((X8 - X6) >> 8)) << 16 >> 16);
            block[offset + 5] = ((((X0 - X4) >> 8)) << 16 >> 16);
            block[offset + 6] = ((((X3 - X2) >> 8)) << 16 >> 16);
            block[offset + 7] = ((((X7 - X1) >> 8)) << 16 >> 16);
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Interpolator that operates on block level
 *  
 *  @author The JCodec project
 *  
 */
var BlockInterpolator = function() {
    this.tmp1 = new Int32Array(1024);
    this.tmp2 = new Int32Array(1024);
    this.tmp3 = new Int8Array(1024);
    this.safe = this.initSafe();
    this.unsafe = this.initUnsafe();
};
BlockInterpolator = stjs.extend(BlockInterpolator, null, [], function(constructor, prototype) {
    prototype.tmp1 = null;
    prototype.tmp2 = null;
    prototype.tmp3 = null;
    prototype.safe = null;
    prototype.unsafe = null;
    /**
     *  Get block of ( possibly interpolated ) luma pixels
     */
    prototype.getBlockLuma = function(pic, out, off, x, y, w, h) {
        var xInd = x & 3;
        var yInd = y & 3;
        var xFp = x >> 2;
        var yFp = y >> 2;
        if (xFp < 2 || yFp < 2 || xFp > pic.getWidth() - w - 5 || yFp > pic.getHeight() - h - 5) {
            this.unsafe[(yInd << 2) + xInd](pic.getData()[0], pic.getWidth(), pic.getHeight(), out.getPlaneData(0), off, out.getPlaneWidth(0), xFp, yFp, w, h);
        } else {
            this.safe[(yInd << 2) + xInd](pic.getData()[0], pic.getWidth(), pic.getHeight(), out.getPlaneData(0), off, out.getPlaneWidth(0), xFp, yFp, w, h);
        }
    };
    constructor.getBlockChroma = function(pels, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var xInd = x & 7;
        var yInd = y & 7;
        var xFull = x >> 3;
        var yFull = y >> 3;
        if (xFull < 0 || xFull > picW - blkW - 1 || yFull < 0 || yFull > picH - blkH - 1) {
            if (xInd == 0 && yInd == 0) {
                BlockInterpolator.getChroma00Unsafe(pels, picW, picH, blk, blkOff, blkStride, xFull, yFull, blkW, blkH);
            } else if (yInd == 0) {
                BlockInterpolator.getChromaX0Unsafe(pels, picW, picH, blk, blkOff, blkStride, xFull, yFull, xInd, blkW, blkH);
            } else if (xInd == 0) {
                BlockInterpolator.getChroma0XUnsafe(pels, picW, picH, blk, blkOff, blkStride, xFull, yFull, yInd, blkW, blkH);
            } else {
                BlockInterpolator.getChromaXXUnsafe(pels, picW, picH, blk, blkOff, blkStride, xFull, yFull, xInd, yInd, blkW, blkH);
            }
        } else {
            if (xInd == 0 && yInd == 0) {
                BlockInterpolator.getChroma00(pels, picW, picH, blk, blkOff, blkStride, xFull, yFull, blkW, blkH);
            } else if (yInd == 0) {
                BlockInterpolator.getChromaX0(pels, picW, picH, blk, blkOff, blkStride, xFull, yFull, xInd, blkW, blkH);
            } else if (xInd == 0) {
                BlockInterpolator.getChroma0X(pels, picW, picH, blk, blkOff, blkStride, xFull, yFull, yInd, blkW, blkH);
            } else {
                BlockInterpolator.getChromaXX(pels, picW, picH, blk, blkOff, blkStride, xFull, yFull, xInd, yInd, blkW, blkH);
            }
        }
    };
    /**
     *  Fullpel (0, 0)
     */
    constructor.getLuma00 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            System.arraycopy(pic, off, blk, blkOff, blkW);
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Fullpel (0, 0) unsafe
     */
    constructor.getLuma00Unsafe = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var maxH = picH - 1;
        var maxW = picW - 1;
        for (var j = 0; j < blkH; j++) {
            var lineStart = MathUtil.clip(j + y, 0, maxH) * picW;
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = pic[lineStart + MathUtil.clip(x + i, 0, maxW)];
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Halfpel (2,0) horizontal, int argument version
     */
    constructor.getLuma20NoRoundInt = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            var off1 = -2;
            for (var i = 0; i < blkW; i++) {
                var a = pic[off + off1] + pic[off + off1 + 5];
                var b = pic[off + off1 + 1] + pic[off + off1 + 4];
                var c = pic[off + off1 + 2] + pic[off + off1 + 3];
                blk[blkOff + i] = a + 5 * ((c << 2) - b);
                ++off1;
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Halfpel (2,0) horizontal
     */
    constructor.getLuma20NoRound = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            var off1 = -2;
            for (var i = 0; i < blkW; i++) {
                var a = pic[off + off1] + pic[off + off1 + 5];
                var b = pic[off + off1 + 1] + pic[off + off1 + 4];
                var c = pic[off + off1 + 2] + pic[off + off1 + 3];
                blk[blkOff + i] = a + 5 * ((c << 2) - b);
                ++off1;
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    constructor.getLuma20 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            var off1 = -2;
            for (var i = 0; i < blkW; i++) {
                var a = pic[off + off1] + pic[off + off1 + 5];
                var b = pic[off + off1 + 1] + pic[off + off1 + 4];
                var c = pic[off + off1 + 2] + pic[off + off1 + 3];
                blk[blkOff + i] = (MathUtil.clip((a + 5 * ((c << 2) - b) + 16) >> 5, -128, 127) << 24 >> 24);
                ++off1;
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Halfpel (2, 0) horizontal unsafe
     */
    constructor.getLuma20UnsafeNoRound = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var maxW = picW - 1;
        var maxH = picH - 1;
        for (var i = 0; i < blkW; i++) {
            var ipos_m2 = MathUtil.clip(x + i - 2, 0, maxW);
            var ipos_m1 = MathUtil.clip(x + i - 1, 0, maxW);
            var ipos = MathUtil.clip(x + i, 0, maxW);
            var ipos_p1 = MathUtil.clip(x + i + 1, 0, maxW);
            var ipos_p2 = MathUtil.clip(x + i + 2, 0, maxW);
            var ipos_p3 = MathUtil.clip(x + i + 3, 0, maxW);
            var boff = blkOff;
            for (var j = 0; j < blkH; j++) {
                var lineStart = MathUtil.clip(j + y, 0, maxH) * picW;
                var a = pic[lineStart + ipos_m2] + pic[lineStart + ipos_p3];
                var b = pic[lineStart + ipos_m1] + pic[lineStart + ipos_p2];
                var c = pic[lineStart + ipos] + pic[lineStart + ipos_p1];
                blk[boff + i] = a + 5 * ((c << 2) - b);
                boff += blkStride;
            }
        }
    };
    prototype.getLuma20Unsafe = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        BlockInterpolator.getLuma20UnsafeNoRound(pic, picW, picH, this.tmp1, blkOff, blkStride, x, y, blkW, blkH);
        for (var i = 0; i < blkW; i++) {
            var boff = blkOff;
            for (var j = 0; j < blkH; j++) {
                blk[boff + i] = (MathUtil.clip((this.tmp1[boff + i] + 16) >> 5, -128, 127) << 24 >> 24);
                boff += blkStride;
            }
        }
    };
    /**
     *  Halfpel (0, 2) vertical
     */
    constructor.getLuma02NoRoundInt = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var off = (y - 2) * picW + x, picWx2 = picW + picW, picWx3 = picWx2 + picW, picWx4 = picWx3 + picW, picWx5 = picWx4 + picW;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var a = pic[off + i] + pic[off + i + picWx5];
                var b = pic[off + i + picW] + pic[off + i + picWx4];
                var c = pic[off + i + picWx2] + pic[off + i + picWx3];
                blk[blkOff + i] = a + 5 * ((c << 2) - b);
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Halfpel (0, 2) vertical
     */
    constructor.getLuma02NoRound = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var off = (y - 2) * picW + x, picWx2 = picW + picW, picWx3 = picWx2 + picW, picWx4 = picWx3 + picW, picWx5 = picWx4 + picW;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var a = pic[off + i] + pic[off + i + picWx5];
                var b = pic[off + i + picW] + pic[off + i + picWx4];
                var c = pic[off + i + picWx2] + pic[off + i + picWx3];
                blk[blkOff + i] = a + 5 * ((c << 2) - b);
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    constructor.getLuma02 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var off = (y - 2) * picW + x, picWx2 = picW + picW, picWx3 = picWx2 + picW, picWx4 = picWx3 + picW, picWx5 = picWx4 + picW;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var a = pic[off + i] + pic[off + i + picWx5];
                var b = pic[off + i + picW] + pic[off + i + picWx4];
                var c = pic[off + i + picWx2] + pic[off + i + picWx3];
                blk[blkOff + i] = (MathUtil.clip((a + 5 * ((c << 2) - b) + 16) >> 5, -128, 127) << 24 >> 24);
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Hpel (0, 2) vertical unsafe
     */
    constructor.getLuma02UnsafeNoRound = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var maxH = picH - 1;
        var maxW = picW - 1;
        for (var j = 0; j < blkH; j++) {
            var offP0 = MathUtil.clip(y + j - 2, 0, maxH) * picW;
            var offP1 = MathUtil.clip(y + j - 1, 0, maxH) * picW;
            var offP2 = MathUtil.clip(y + j, 0, maxH) * picW;
            var offP3 = MathUtil.clip(y + j + 1, 0, maxH) * picW;
            var offP4 = MathUtil.clip(y + j + 2, 0, maxH) * picW;
            var offP5 = MathUtil.clip(y + j + 3, 0, maxH) * picW;
            for (var i = 0; i < blkW; i++) {
                var pres_x = MathUtil.clip(x + i, 0, maxW);
                var a = pic[pres_x + offP0] + pic[pres_x + offP5];
                var b = pic[pres_x + offP1] + pic[pres_x + offP4];
                var c = pic[pres_x + offP2] + pic[pres_x + offP3];
                blk[blkOff + i] = a + 5 * ((c << 2) - b);
            }
            blkOff += blkStride;
        }
    };
    prototype.getLuma02Unsafe = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        BlockInterpolator.getLuma02UnsafeNoRound(pic, picW, picH, this.tmp1, blkOff, blkStride, x, y, blkW, blkH);
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (MathUtil.clip((this.tmp1[blkOff + i] + 16) >> 5, -128, 127) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Qpel: (1,0) horizontal
     */
    constructor.getLuma10 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        BlockInterpolator.getLuma20(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((blk[blkOff + i] + pic[off + i] + 1) >> 1) << 24 >> 24);
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Qpel: (1,0) horizontal unsafe
     */
    prototype.getLuma10Unsafe = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var maxH = picH - 1;
        var maxW = picW - 1;
        this.getLuma20Unsafe(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH);
        for (var j = 0; j < blkH; j++) {
            var lineStart = MathUtil.clip(j + y, 0, maxH) * picW;
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((blk[blkOff + i] + pic[lineStart + MathUtil.clip(x + i, 0, maxW)] + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Qpel (3,0) horizontal
     */
    constructor.getLuma30 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        BlockInterpolator.getLuma20(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((pic[off + i + 1] + blk[blkOff + i] + 1) >> 1) << 24 >> 24);
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Qpel horizontal (3, 0) unsafe
     */
    prototype.getLuma30Unsafe = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var maxH = picH - 1;
        var maxW = picW - 1;
        this.getLuma20Unsafe(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH);
        for (var j = 0; j < blkH; j++) {
            var lineStart = MathUtil.clip(j + y, 0, maxH) * picW;
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((blk[blkOff + i] + pic[lineStart + MathUtil.clip(x + i + 1, 0, maxW)] + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Qpel vertical (0, 1)
     */
    constructor.getLuma01 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        BlockInterpolator.getLuma02(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((blk[blkOff + i] + pic[off + i] + 1) >> 1) << 24 >> 24);
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Qpel vertical (0, 1) unsafe
     */
    prototype.getLuma01Unsafe = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var maxH = picH - 1;
        var maxW = picW - 1;
        this.getLuma02Unsafe(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH);
        for (var j = 0; j < blkH; j++) {
            var lineStart = MathUtil.clip(y + j, 0, maxH) * picW;
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((blk[blkOff + i] + pic[lineStart + MathUtil.clip(x + i, 0, maxW)] + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Qpel vertical (0, 3)
     */
    constructor.getLuma03 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        BlockInterpolator.getLuma02(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((blk[blkOff + i] + pic[off + i + picW] + 1) >> 1) << 24 >> 24);
            }
            off += picW;
            blkOff += blkStride;
        }
    };
    /**
     *  Qpel vertical (0, 3) unsafe
     */
    prototype.getLuma03Unsafe = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var maxH = picH - 1;
        var maxW = picW - 1;
        this.getLuma02Unsafe(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH);
        for (var j = 0; j < blkH; j++) {
            var lineStart = MathUtil.clip(y + j + 1, 0, maxH) * picW;
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((blk[blkOff + i] + pic[lineStart + MathUtil.clip(x + i, 0, maxW)] + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Hpel horizontal, Qpel vertical (2, 1)
     *  
     */
    prototype.getLuma21 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        BlockInterpolator.getLuma20NoRound(pic, picW, this.tmp1, 0, blkW, x, y - 2, blkW, blkH + 7);
        BlockInterpolator.getLuma02NoRoundInt(this.tmp1, blkW, this.tmp2, blkOff, blkStride, 0, 2, blkW, blkH);
        var off = blkW << 1;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var rounded = MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127);
                var rounded2 = MathUtil.clip((this.tmp1[off + i] + 16) >> 5, -128, 127);
                blk[blkOff + i] = (((rounded + rounded2 + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            off += blkW;
        }
    };
    /**
     *  Qpel vertical (2, 1) unsafe
     */
    prototype.getLuma21Unsafe = function(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        BlockInterpolator.getLuma20UnsafeNoRound(pic, picW, imgH, this.tmp1, 0, blkW, x, y - 2, blkW, blkH + 7);
        BlockInterpolator.getLuma02NoRoundInt(this.tmp1, blkW, this.tmp2, blkOff, blkStride, 0, 2, blkW, blkH);
        var off = blkW << 1;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var rounded = MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127);
                var rounded2 = MathUtil.clip((this.tmp1[off + i] + 16) >> 5, -128, 127);
                blk[blkOff + i] = (((rounded + rounded2 + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            off += blkW;
        }
    };
    /**
     *  Hpel horizontal, Hpel vertical (2, 2)
     */
    prototype.getLuma22 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        BlockInterpolator.getLuma20NoRound(pic, picW, this.tmp1, 0, blkW, x, y - 2, blkW, blkH + 7);
        BlockInterpolator.getLuma02NoRoundInt(this.tmp1, blkW, this.tmp2, blkOff, blkStride, 0, 2, blkW, blkH);
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = ((MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127)) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Hpel (2, 2) unsafe
     */
    prototype.getLuma22Unsafe = function(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        BlockInterpolator.getLuma20UnsafeNoRound(pic, picW, imgH, this.tmp1, 0, blkW, x, y - 2, blkW, blkH + 7);
        BlockInterpolator.getLuma02NoRoundInt(this.tmp1, blkW, this.tmp2, blkOff, blkStride, 0, 2, blkW, blkH);
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Hpel horizontal, Qpel vertical (2, 3)
     *  
     */
    prototype.getLuma23 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        BlockInterpolator.getLuma20NoRound(pic, picW, this.tmp1, 0, blkW, x, y - 2, blkW, blkH + 7);
        BlockInterpolator.getLuma02NoRoundInt(this.tmp1, blkW, this.tmp2, blkOff, blkStride, 0, 2, blkW, blkH);
        var off = blkW << 1;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var rounded = MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127);
                var rounded2 = MathUtil.clip((this.tmp1[off + i + blkW] + 16) >> 5, -128, 127);
                blk[blkOff + i] = (((rounded + rounded2 + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            off += blkW;
        }
    };
    /**
     *  Qpel (2, 3) unsafe
     */
    prototype.getLuma23Unsafe = function(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        BlockInterpolator.getLuma20UnsafeNoRound(pic, picW, imgH, this.tmp1, 0, blkW, x, y - 2, blkW, blkH + 7);
        BlockInterpolator.getLuma02NoRoundInt(this.tmp1, blkW, this.tmp2, blkOff, blkStride, 0, 2, blkW, blkH);
        var off = blkW << 1;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var rounded = MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127);
                var rounded2 = MathUtil.clip((this.tmp1[off + i + blkW] + 16) >> 5, -128, 127);
                blk[blkOff + i] = (((rounded + rounded2 + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            off += blkW;
        }
    };
    /**
     *  Qpel horizontal, Hpel vertical (1, 2)
     */
    prototype.getLuma12 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var tmpW = blkW + 7;
        BlockInterpolator.getLuma02NoRound(pic, picW, this.tmp1, 0, tmpW, x - 2, y, tmpW, blkH);
        BlockInterpolator.getLuma20NoRoundInt(this.tmp1, tmpW, this.tmp2, blkOff, blkStride, 2, 0, blkW, blkH);
        var off = 2;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var rounded = MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127);
                var rounded2 = MathUtil.clip((this.tmp1[off + i] + 16) >> 5, -128, 127);
                blk[blkOff + i] = (((rounded + rounded2 + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            off += tmpW;
        }
    };
    /**
     *  Qpel (1, 2) unsafe
     */
    prototype.getLuma12Unsafe = function(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var tmpW = blkW + 7;
        BlockInterpolator.getLuma02UnsafeNoRound(pic, picW, imgH, this.tmp1, 0, tmpW, x - 2, y, tmpW, blkH);
        BlockInterpolator.getLuma20NoRoundInt(this.tmp1, tmpW, this.tmp2, blkOff, blkStride, 2, 0, blkW, blkH);
        var off = 2;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var rounded = MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127);
                var rounded2 = MathUtil.clip((this.tmp1[off + i] + 16) >> 5, -128, 127);
                blk[blkOff + i] = (((rounded + rounded2 + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            off += tmpW;
        }
    };
    /**
     *  Qpel horizontal, Hpel vertical (3, 2)
     */
    prototype.getLuma32 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var tmpW = blkW + 7;
        BlockInterpolator.getLuma02NoRound(pic, picW, this.tmp1, 0, tmpW, x - 2, y, tmpW, blkH);
        BlockInterpolator.getLuma20NoRoundInt(this.tmp1, tmpW, this.tmp2, blkOff, blkStride, 2, 0, blkW, blkH);
        var off = 2;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var rounded = MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127);
                var rounded2 = MathUtil.clip((this.tmp1[off + i + 1] + 16) >> 5, -128, 127);
                blk[blkOff + i] = (((rounded + rounded2 + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            off += tmpW;
        }
    };
    /**
     *  Qpel (3, 2) unsafe
     */
    prototype.getLuma32Unsafe = function(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var tmpW = blkW + 7;
        BlockInterpolator.getLuma02UnsafeNoRound(pic, picW, imgH, this.tmp1, 0, tmpW, x - 2, y, tmpW, blkH);
        BlockInterpolator.getLuma20NoRoundInt(this.tmp1, tmpW, this.tmp2, blkOff, blkStride, 2, 0, blkW, blkH);
        var off = 2;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var rounded = MathUtil.clip((this.tmp2[blkOff + i] + 512) >> 10, -128, 127);
                var rounded2 = MathUtil.clip((this.tmp1[off + i + 1] + 16) >> 5, -128, 127);
                blk[blkOff + i] = (((rounded + rounded2 + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            off += tmpW;
        }
    };
    /**
     *  Qpel horizontal, Qpel vertical (3, 3)
     */
    prototype.getLuma33 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        BlockInterpolator.getLuma20(pic, picW, blk, blkOff, blkStride, x, y + 1, blkW, blkH);
        BlockInterpolator.getLuma02(pic, picW, this.tmp3, 0, blkW, x + 1, y, blkW, blkH);
        BlockInterpolator.merge(blk, this.tmp3, blkOff, blkStride, blkW, blkH);
    };
    /**
     *  Qpel (3, 3) unsafe
     */
    prototype.getLuma33Unsafe = function(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20Unsafe(pic, picW, imgH, blk, blkOff, blkStride, x, y + 1, blkW, blkH);
        this.getLuma02Unsafe(pic, picW, imgH, this.tmp3, 0, blkW, x + 1, y, blkW, blkH);
        BlockInterpolator.merge(blk, this.tmp3, blkOff, blkStride, blkW, blkH);
    };
    /**
     *  Qpel horizontal, Qpel vertical (1, 1)
     */
    prototype.getLuma11 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        BlockInterpolator.getLuma20(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        BlockInterpolator.getLuma02(pic, picW, this.tmp3, 0, blkW, x, y, blkW, blkH);
        BlockInterpolator.merge(blk, this.tmp3, blkOff, blkStride, blkW, blkH);
    };
    /**
     *  Qpel (1, 1) unsafe
     */
    prototype.getLuma11Unsafe = function(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20Unsafe(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        this.getLuma02Unsafe(pic, picW, imgH, this.tmp3, 0, blkW, x, y, blkW, blkH);
        BlockInterpolator.merge(blk, this.tmp3, blkOff, blkStride, blkW, blkH);
    };
    /**
     *  Qpel horizontal, Qpel vertical (1, 3)
     */
    prototype.getLuma13 = function(pic, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        BlockInterpolator.getLuma20(pic, picW, blk, blkOff, blkStride, x, y + 1, blkW, blkH);
        BlockInterpolator.getLuma02(pic, picW, this.tmp3, 0, blkW, x, y, blkW, blkH);
        BlockInterpolator.merge(blk, this.tmp3, blkOff, blkStride, blkW, blkH);
    };
    /**
     *  Qpel (1, 3) unsafe
     */
    prototype.getLuma13Unsafe = function(pic, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20Unsafe(pic, picW, imgH, blk, blkOff, blkStride, x, y + 1, blkW, blkH);
        this.getLuma02Unsafe(pic, picW, imgH, this.tmp3, 0, blkW, x, y, blkW, blkH);
        BlockInterpolator.merge(blk, this.tmp3, blkOff, blkStride, blkW, blkH);
    };
    /**
     *  Qpel horizontal, Qpel vertical (3, 1)
     */
    prototype.getLuma31 = function(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH) {
        BlockInterpolator.getLuma20(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        BlockInterpolator.getLuma02(pels, picW, this.tmp3, 0, blkW, x + 1, y, blkW, blkH);
        BlockInterpolator.merge(blk, this.tmp3, blkOff, blkStride, blkW, blkH);
    };
    /**
     *  Qpel (3, 1) unsafe
     */
    prototype.getLuma31Unsafe = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        this.getLuma20Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        this.getLuma02Unsafe(pels, picW, imgH, this.tmp3, 0, blkW, x + 1, y, blkW, blkH);
        BlockInterpolator.merge(blk, this.tmp3, blkOff, blkStride, blkW, blkH);
    };
    constructor.merge = function(first, second, blkOff, blkStride, blkW, blkH) {
        var tOff = 0;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                first[blkOff + i] = (((first[blkOff + i] + second[tOff + i] + 1) >> 1) << 24 >> 24);
            }
            blkOff += blkStride;
            tOff += blkW;
        }
    };
    /**
     *  Chroma (0,0)
     */
    constructor.getChroma00 = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var off = y * picW + x;
        for (var j = 0; j < blkH; j++) {
            System.arraycopy(pic, off, blk, blkOff, blkW);
            off += picW;
            blkOff += blkStride;
        }
    };
    constructor.getChroma00Unsafe = function(pic, picW, picH, blk, blkOff, blkStride, x, y, blkW, blkH) {
        var maxH = picH - 1;
        var maxW = picW - 1;
        for (var j = 0; j < blkH; j++) {
            var lineStart = MathUtil.clip(j + y, 0, maxH) * picW;
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = pic[lineStart + MathUtil.clip(x + i, 0, maxW)];
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Chroma (X,0)
     */
    constructor.getChroma0X = function(pels, picW, picH, blk, blkOff, blkStride, fullX, fullY, fracY, blkW, blkH) {
        var w00 = fullY * picW + fullX;
        var w01 = w00 + (fullY < picH - 1 ? picW : 0);
        var eMy = 8 - fracY;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((eMy * pels[w00 + i] + fracY * pels[w01 + i] + 4) >> 3) << 24 >> 24);
            }
            w00 += picW;
            w01 += picW;
            blkOff += blkStride;
        }
    };
    constructor.getChroma0XUnsafe = function(pels, picW, picH, blk, blkOff, blkStride, fullX, fullY, fracY, blkW, blkH) {
        var maxW = picW - 1;
        var maxH = picH - 1;
        var eMy = 8 - fracY;
        for (var j = 0; j < blkH; j++) {
            var off00 = MathUtil.clip(fullY + j, 0, maxH) * picW;
            var off01 = MathUtil.clip(fullY + j + 1, 0, maxH) * picW;
            for (var i = 0; i < blkW; i++) {
                var w00 = MathUtil.clip(fullX + i, 0, maxW) + off00;
                var w01 = MathUtil.clip(fullX + i, 0, maxW) + off01;
                blk[blkOff + i] = (((eMy * pels[w00] + fracY * pels[w01] + 4) >> 3) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Chroma (X,0)
     */
    constructor.getChromaX0 = function(pels, picW, imgH, blk, blkOff, blkStride, fullX, fullY, fracX, blkW, blkH) {
        var w00 = fullY * picW + fullX;
        var w10 = w00 + (fullX < picW - 1 ? 1 : 0);
        var eMx = 8 - fracX;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((eMx * pels[w00 + i] + fracX * pels[w10 + i] + 4) >> 3) << 24 >> 24);
            }
            w00 += picW;
            w10 += picW;
            blkOff += blkStride;
        }
    };
    constructor.getChromaX0Unsafe = function(pels, picW, picH, blk, blkOff, blkStride, fullX, fullY, fracX, blkW, blkH) {
        var eMx = 8 - fracX;
        var maxW = picW - 1;
        var maxH = picH - 1;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var w00 = MathUtil.clip(fullY + j, 0, maxH) * picW + MathUtil.clip(fullX + i, 0, maxW);
                var w10 = MathUtil.clip(fullY + j, 0, maxH) * picW + MathUtil.clip(fullX + i + 1, 0, maxW);
                blk[blkOff + i] = (((eMx * pels[w00] + fracX * pels[w10] + 4) >> 3) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    /**
     *  Chroma (X,X)
     */
    constructor.getChromaXX = function(pels, picW, picH, blk, blkOff, blkStride, fullX, fullY, fracX, fracY, blkW, blkH) {
        var w00 = fullY * picW + fullX;
        var w01 = w00 + (fullY < picH - 1 ? picW : 0);
        var w10 = w00 + (fullX < picW - 1 ? 1 : 0);
        var w11 = w10 + w01 - w00;
        var eMx = 8 - fracX;
        var eMy = 8 - fracY;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                blk[blkOff + i] = (((eMx * eMy * pels[w00 + i] + fracX * eMy * pels[w10 + i] + eMx * fracY * pels[w01 + i] + fracX * fracY * pels[w11 + i] + 32) >> 6) << 24 >> 24);
            }
            blkOff += blkStride;
            w00 += picW;
            w01 += picW;
            w10 += picW;
            w11 += picW;
        }
    };
    constructor.getChromaXXUnsafe = function(pels, picW, picH, blk, blkOff, blkStride, fullX, fullY, fracX, fracY, blkW, blkH) {
        var maxH = picH - 1;
        var maxW = picW - 1;
        var eMx = 8 - fracX;
        var eMy = 8 - fracY;
        for (var j = 0; j < blkH; j++) {
            for (var i = 0; i < blkW; i++) {
                var w00 = MathUtil.clip(fullY + j, 0, maxH) * picW + MathUtil.clip(fullX + i, 0, maxW);
                var w01 = MathUtil.clip(fullY + j + 1, 0, maxH) * picW + MathUtil.clip(fullX + i, 0, maxW);
                var w10 = MathUtil.clip(fullY + j, 0, maxH) * picW + MathUtil.clip(fullX + i + 1, 0, maxW);
                var w11 = MathUtil.clip(fullY + j + 1, 0, maxH) * picW + MathUtil.clip(fullX + i + 1, 0, maxW);
                blk[blkOff + i] = (((eMx * eMy * pels[w00] + fracX * eMy * pels[w10] + eMx * fracY * pels[w01] + fracX * fracY * pels[w11] + 32) >> 6) << 24 >> 24);
            }
            blkOff += blkStride;
        }
    };
    constructor.LumaInterpolator = function() {};
    constructor.LumaInterpolator = stjs.extend(constructor.LumaInterpolator, null, [], function(constructor, prototype) {
        prototype.getLuma = function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {};
    }, {}, {});
    prototype.initSafe = function() {
        var self = this;
        return [function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            BlockInterpolator.getLuma00(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            BlockInterpolator.getLuma10(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            BlockInterpolator.getLuma20(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            BlockInterpolator.getLuma30(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            BlockInterpolator.getLuma01(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma11(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma21(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma31(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            BlockInterpolator.getLuma02(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma12(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma22(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma32(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            BlockInterpolator.getLuma03(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma13(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma23(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma33(pels, picW, blk, blkOff, blkStride, x, y, blkW, blkH);
        }];
    };
    prototype.initUnsafe = function() {
        var self = this;
        return [function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            BlockInterpolator.getLuma00Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma10Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma20Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma30Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma01Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma11Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma21Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma31Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma02Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma12Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma22Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma32Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma03Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma13Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma23Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        }, function(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH) {
            self.getLuma33Unsafe(pels, picW, imgH, blk, blkOff, blkStride, x, y, blkW, blkH);
        }];
    };
}, {tmp1: "Int32Array", tmp2: "Int32Array", tmp3: "Int8Array", safe: "Array", unsafe: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Builds intra prediction for intra 4x4 coded macroblocks
 *  
 *  @author The JCodec project
 *  
 */
var Intra4x4PredictionBuilder = function() {};
Intra4x4PredictionBuilder = stjs.extend(Intra4x4PredictionBuilder, null, [], function(constructor, prototype) {
    constructor.predictWithMode = function(mode, residual, leftAvailable, topAvailable, topRightAvailable, leftRow, topLine, topLeft, mbOffX, blkX, blkY, pixOut) {
        switch (mode) {
            case 0:
                Intra4x4PredictionBuilder.predictVertical(residual, topAvailable, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 1:
                Intra4x4PredictionBuilder.predictHorizontal(residual, leftAvailable, leftRow, mbOffX, blkX, blkY, pixOut);
                break;
            case 2:
                Intra4x4PredictionBuilder.predictDC(residual, leftAvailable, topAvailable, leftRow, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 3:
                Intra4x4PredictionBuilder.predictDiagonalDownLeft(residual, topAvailable, topRightAvailable, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 4:
                Intra4x4PredictionBuilder.predictDiagonalDownRight(residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, mbOffX, blkX, blkY, pixOut);
                break;
            case 5:
                Intra4x4PredictionBuilder.predictVerticalRight(residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, mbOffX, blkX, blkY, pixOut);
                break;
            case 6:
                Intra4x4PredictionBuilder.predictHorizontalDown(residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, mbOffX, blkX, blkY, pixOut);
                break;
            case 7:
                Intra4x4PredictionBuilder.predictVerticalLeft(residual, topAvailable, topRightAvailable, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 8:
                Intra4x4PredictionBuilder.predictHorizontalUp(residual, leftAvailable, leftRow, mbOffX, blkX, blkY, pixOut);
                break;
        }
        var oo1 = mbOffX + blkX;
        var off1 = (blkY << 4) + blkX + 3;
        topLeft[blkY >> 2] = topLine[oo1 + 3];
        leftRow[blkY] = pixOut[off1];
        leftRow[blkY + 1] = pixOut[off1 + 16];
        leftRow[blkY + 2] = pixOut[off1 + 32];
        leftRow[blkY + 3] = pixOut[off1 + 48];
        var off2 = (blkY << 4) + blkX + 48;
        topLine[oo1] = pixOut[off2];
        topLine[oo1 + 1] = pixOut[off2 + 1];
        topLine[oo1 + 2] = pixOut[off2 + 2];
        topLine[oo1 + 3] = pixOut[off2 + 3];
    };
    constructor.predictVertical = function(residual, topAvailable, topLine, mbOffX, blkX, blkY, pixOut) {
        var pixOff = (blkY << 4) + blkX;
        var toff = mbOffX + blkX;
        var rOff = 0;
        for (var j = 0; j < 4; ++j) {
            pixOut[pixOff] = (MathUtil.clip(residual[rOff] + topLine[toff], -128, 127) << 24 >> 24);
            pixOut[pixOff + 1] = (MathUtil.clip(residual[rOff + 1] + topLine[toff + 1], -128, 127) << 24 >> 24);
            pixOut[pixOff + 2] = (MathUtil.clip(residual[rOff + 2] + topLine[toff + 2], -128, 127) << 24 >> 24);
            pixOut[pixOff + 3] = (MathUtil.clip(residual[rOff + 3] + topLine[toff + 3], -128, 127) << 24 >> 24);
            rOff += 4;
            pixOff += 16;
        }
    };
    constructor.predictHorizontal = function(residual, leftAvailable, leftRow, mbOffX, blkX, blkY, pixOut) {
        var pixOff = (blkY << 4) + blkX;
        var rOff = 0;
        for (var j = 0; j < 4; j++) {
            var l = leftRow[blkY + j];
            pixOut[pixOff] = (MathUtil.clip(residual[rOff] + l, -128, 127) << 24 >> 24);
            pixOut[pixOff + 1] = (MathUtil.clip(residual[rOff + 1] + l, -128, 127) << 24 >> 24);
            pixOut[pixOff + 2] = (MathUtil.clip(residual[rOff + 2] + l, -128, 127) << 24 >> 24);
            pixOut[pixOff + 3] = (MathUtil.clip(residual[rOff + 3] + l, -128, 127) << 24 >> 24);
            rOff += 4;
            pixOff += 16;
        }
    };
    constructor.predictDC = function(residual, leftAvailable, topAvailable, leftRow, topLine, mbOffX, blkX, blkY, pixOut) {
        var val;
        if (leftAvailable && topAvailable) {
            val = (leftRow[blkY] + leftRow[blkY + 1] + leftRow[blkY + 2] + leftRow[blkY + 3] + topLine[mbOffX + blkX] + topLine[mbOffX + blkX + 1] + topLine[mbOffX + blkX + 2] + topLine[mbOffX + blkX + 3] + 4) >> 3;
        } else if (leftAvailable) {
            val = (leftRow[blkY] + leftRow[blkY + 1] + leftRow[blkY + 2] + leftRow[blkY + 3] + 2) >> 2;
        } else if (topAvailable) {
            val = (topLine[mbOffX + blkX] + topLine[mbOffX + blkX + 1] + topLine[mbOffX + blkX + 2] + topLine[mbOffX + blkX + 3] + 2) >> 2;
        } else {
            val = 0;
        }
        var pixOff = (blkY << 4) + blkX;
        var rOff = 0;
        for (var j = 0; j < 4; j++) {
            pixOut[pixOff] = (MathUtil.clip(residual[rOff] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 1] = (MathUtil.clip(residual[rOff + 1] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 2] = (MathUtil.clip(residual[rOff + 2] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 3] = (MathUtil.clip(residual[rOff + 3] + val, -128, 127) << 24 >> 24);
            pixOff += 16;
            rOff += 4;
        }
    };
    constructor.predictDiagonalDownLeft = function(residual, topAvailable, topRightAvailable, topLine, mbOffX, blkX, blkY, pixOut) {
        var to = mbOffX + blkX;
        var tr0 = topLine[to + 3], tr1 = topLine[to + 3], tr2 = topLine[to + 3], tr3 = topLine[to + 3];
        if (topRightAvailable) {
            tr0 = topLine[to + 4];
            tr1 = topLine[to + 5];
            tr2 = topLine[to + 6];
            tr3 = topLine[to + 7];
        }
        var c0 = ((topLine[to] + topLine[to + 2] + (topLine[to + 1] << 1) + 2) >> 2);
        var c1 = ((topLine[to + 1] + topLine[to + 3] + (topLine[to + 2] << 1) + 2) >> 2);
        var c2 = ((topLine[to + 2] + tr0 + (topLine[to + 3] << 1) + 2) >> 2);
        var c3 = ((topLine[to + 3] + tr1 + (tr0 << 1) + 2) >> 2);
        var c4 = ((tr0 + tr2 + (tr1 << 1) + 2) >> 2);
        var c5 = ((tr1 + tr3 + (tr2 << 1) + 2) >> 2);
        var c6 = ((tr2 + 3 * (tr3) + 2) >> 2);
        var off = (blkY << 4) + blkX;
        pixOut[off] = (MathUtil.clip(residual[0] + c0, -128, 127) << 24 >> 24);
        pixOut[off + 1] = (MathUtil.clip(residual[1] + c1, -128, 127) << 24 >> 24);
        pixOut[off + 2] = (MathUtil.clip(residual[2] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 3] = (MathUtil.clip(residual[3] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 16] = (MathUtil.clip(residual[4] + c1, -128, 127) << 24 >> 24);
        pixOut[off + 17] = (MathUtil.clip(residual[5] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 18] = (MathUtil.clip(residual[6] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 19] = (MathUtil.clip(residual[7] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 32] = (MathUtil.clip(residual[8] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 33] = (MathUtil.clip(residual[9] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 34] = (MathUtil.clip(residual[10] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 35] = (MathUtil.clip(residual[11] + c5, -128, 127) << 24 >> 24);
        pixOut[off + 48] = (MathUtil.clip(residual[12] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 49] = (MathUtil.clip(residual[13] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 50] = (MathUtil.clip(residual[14] + c5, -128, 127) << 24 >> 24);
        pixOut[off + 51] = (MathUtil.clip(residual[15] + c6, -128, 127) << 24 >> 24);
    };
    constructor.predictDiagonalDownRight = function(residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, mbOffX, blkX, blkY, pixOut) {
        var off = (blkY << 4) + blkX;
        var c0 = ((topLine[mbOffX + blkX] + 2 * topLeft[blkY >> 2] + leftRow[blkY] + 2) >> 2);
        var c1 = ((topLeft[blkY >> 2] + (topLine[mbOffX + blkX + 0] << 1) + topLine[mbOffX + blkX + 1] + 2) >> 2);
        var c2 = ((topLine[mbOffX + blkX] + (topLine[mbOffX + blkX + 1] << 1) + topLine[mbOffX + blkX + 2] + 2) >> 2);
        var c3 = ((topLine[mbOffX + blkX + 1] + (topLine[mbOffX + blkX + 2] << 1) + topLine[mbOffX + blkX + 3] + 2) >> 2);
        pixOut[off] = (MathUtil.clip(residual[0] + c0, -128, 127) << 24 >> 24);
        pixOut[off + 1] = (MathUtil.clip(residual[1] + c1, -128, 127) << 24 >> 24);
        pixOut[off + 2] = (MathUtil.clip(residual[2] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 3] = (MathUtil.clip(residual[3] + c3, -128, 127) << 24 >> 24);
        var c4 = ((topLeft[blkY >> 2] + (leftRow[blkY] << 1) + leftRow[blkY + 1] + 2) >> 2);
        var c6 = ((topLeft[blkY >> 2] + (topLine[mbOffX + blkX] << 1) + topLine[mbOffX + blkX + 1] + 2) >> 2);
        var c7 = ((topLine[mbOffX + blkX] + (topLine[mbOffX + blkX + 1] << 1) + topLine[mbOffX + blkX + 2] + 2) >> 2);
        pixOut[off + 16] = (MathUtil.clip(residual[4] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 17] = (MathUtil.clip(residual[5] + c0, -128, 127) << 24 >> 24);
        pixOut[off + 18] = (MathUtil.clip(residual[6] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 19] = (MathUtil.clip(residual[7] + c7, -128, 127) << 24 >> 24);
        var c8 = ((leftRow[blkY + 0] + (leftRow[blkY + 1] << 1) + leftRow[blkY + 2] + 2) >> 2);
        var c9 = ((topLeft[blkY >> 2] + (leftRow[blkY] << 1) + leftRow[blkY + 1] + 2) >> 2);
        var c11 = ((topLeft[blkY >> 2] + (topLine[mbOffX + blkX] << 1) + topLine[mbOffX + blkX + 1] + 2) >> 2);
        pixOut[off + 32] = (MathUtil.clip(residual[8] + c8, -128, 127) << 24 >> 24);
        pixOut[off + 33] = (MathUtil.clip(residual[9] + c9, -128, 127) << 24 >> 24);
        pixOut[off + 34] = (MathUtil.clip(residual[10] + c0, -128, 127) << 24 >> 24);
        pixOut[off + 35] = (MathUtil.clip(residual[11] + c11, -128, 127) << 24 >> 24);
        var c12 = ((leftRow[blkY + 1] + (leftRow[blkY + 2] << 1) + leftRow[blkY + 3] + 2) >> 2);
        var c13 = ((leftRow[blkY] + (leftRow[blkY + 1] << 1) + leftRow[blkY + 2] + 2) >> 2);
        var c14 = ((topLeft[blkY >> 2] + (leftRow[blkY] << 1) + leftRow[blkY + 1] + 2) >> 2);
        pixOut[off + 48] = (MathUtil.clip(residual[12] + c12, -128, 127) << 24 >> 24);
        pixOut[off + 49] = (MathUtil.clip(residual[13] + c13, -128, 127) << 24 >> 24);
        pixOut[off + 50] = (MathUtil.clip(residual[14] + c14, -128, 127) << 24 >> 24);
        pixOut[off + 51] = (MathUtil.clip(residual[15] + c0, -128, 127) << 24 >> 24);
    };
    constructor.predictVerticalRight = function(residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, mbOffX, blkX, blkY, pixOut) {
        var v1 = (topLeft[blkY >> 2] + topLine[mbOffX + blkX + 0] + 1) >> 1;
        var v2 = (topLine[mbOffX + blkX + 0] + topLine[mbOffX + blkX + 1] + 1) >> 1;
        var v3 = (topLine[mbOffX + blkX + 1] + topLine[mbOffX + blkX + 2] + 1) >> 1;
        var v4 = (topLine[mbOffX + blkX + 2] + topLine[mbOffX + blkX + 3] + 1) >> 1;
        var v5 = (leftRow[blkY] + 2 * topLeft[blkY >> 2] + topLine[mbOffX + blkX + 0] + 2) >> 2;
        var v6 = (topLeft[blkY >> 2] + 2 * topLine[mbOffX + blkX + 0] + topLine[mbOffX + blkX + 1] + 2) >> 2;
        var v7 = (topLine[mbOffX + blkX + 0] + 2 * topLine[mbOffX + blkX + 1] + topLine[mbOffX + blkX + 2] + 2) >> 2;
        var v8 = (topLine[mbOffX + blkX + 1] + 2 * topLine[mbOffX + blkX + 2] + topLine[mbOffX + blkX + 3] + 2) >> 2;
        var v9 = (topLeft[blkY >> 2] + 2 * leftRow[blkY] + leftRow[blkY + 1] + 2) >> 2;
        var v10 = (leftRow[blkY] + 2 * leftRow[blkY + 1] + leftRow[blkY + 2] + 2) >> 2;
        var off = (blkY << 4) + blkX;
        pixOut[off] = (MathUtil.clip(residual[0] + v1, -128, 127) << 24 >> 24);
        pixOut[off + 1] = (MathUtil.clip(residual[1] + v2, -128, 127) << 24 >> 24);
        pixOut[off + 2] = (MathUtil.clip(residual[2] + v3, -128, 127) << 24 >> 24);
        pixOut[off + 3] = (MathUtil.clip(residual[3] + v4, -128, 127) << 24 >> 24);
        pixOut[off + 16] = (MathUtil.clip(residual[4] + v5, -128, 127) << 24 >> 24);
        pixOut[off + 17] = (MathUtil.clip(residual[5] + v6, -128, 127) << 24 >> 24);
        pixOut[off + 18] = (MathUtil.clip(residual[6] + v7, -128, 127) << 24 >> 24);
        pixOut[off + 19] = (MathUtil.clip(residual[7] + v8, -128, 127) << 24 >> 24);
        pixOut[off + 32] = (MathUtil.clip(residual[8] + v9, -128, 127) << 24 >> 24);
        pixOut[off + 33] = (MathUtil.clip(residual[9] + v1, -128, 127) << 24 >> 24);
        pixOut[off + 34] = (MathUtil.clip(residual[10] + v2, -128, 127) << 24 >> 24);
        pixOut[off + 35] = (MathUtil.clip(residual[11] + v3, -128, 127) << 24 >> 24);
        pixOut[off + 48] = (MathUtil.clip(residual[12] + v10, -128, 127) << 24 >> 24);
        pixOut[off + 49] = (MathUtil.clip(residual[13] + v5, -128, 127) << 24 >> 24);
        pixOut[off + 50] = (MathUtil.clip(residual[14] + v6, -128, 127) << 24 >> 24);
        pixOut[off + 51] = (MathUtil.clip(residual[15] + v7, -128, 127) << 24 >> 24);
    };
    constructor.predictHorizontalDown = function(residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, mbOffX, blkX, blkY, pixOut) {
        var c0 = (topLeft[blkY >> 2] + leftRow[blkY] + 1) >> 1;
        var c1 = (leftRow[blkY] + 2 * topLeft[blkY >> 2] + topLine[mbOffX + blkX + 0] + 2) >> 2;
        var c2 = (topLeft[blkY >> 2] + 2 * topLine[mbOffX + blkX + 0] + topLine[mbOffX + blkX + 1] + 2) >> 2;
        var c3 = (topLine[mbOffX + blkX + 0] + 2 * topLine[mbOffX + blkX + 1] + topLine[mbOffX + blkX + 2] + 2) >> 2;
        var c4 = (leftRow[blkY] + leftRow[blkY + 1] + 1) >> 1;
        var c5 = (topLeft[blkY >> 2] + 2 * leftRow[blkY] + leftRow[blkY + 1] + 2) >> 2;
        var c6 = (leftRow[blkY + 1] + leftRow[blkY + 2] + 1) >> 1;
        var c7 = (leftRow[blkY] + 2 * leftRow[blkY + 1] + leftRow[blkY + 2] + 2) >> 2;
        var c8 = (leftRow[blkY + 2] + leftRow[blkY + 3] + 1) >> 1;
        var c9 = (leftRow[blkY + 1] + 2 * leftRow[blkY + 2] + leftRow[blkY + 3] + 2) >> 2;
        var off = (blkY << 4) + blkX;
        pixOut[off] = (MathUtil.clip(residual[0] + c0, -128, 127) << 24 >> 24);
        pixOut[off + 1] = (MathUtil.clip(residual[1] + c1, -128, 127) << 24 >> 24);
        pixOut[off + 2] = (MathUtil.clip(residual[2] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 3] = (MathUtil.clip(residual[3] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 16] = (MathUtil.clip(residual[4] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 17] = (MathUtil.clip(residual[5] + c5, -128, 127) << 24 >> 24);
        pixOut[off + 18] = (MathUtil.clip(residual[6] + c0, -128, 127) << 24 >> 24);
        pixOut[off + 19] = (MathUtil.clip(residual[7] + c1, -128, 127) << 24 >> 24);
        pixOut[off + 32] = (MathUtil.clip(residual[8] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 33] = (MathUtil.clip(residual[9] + c7, -128, 127) << 24 >> 24);
        pixOut[off + 34] = (MathUtil.clip(residual[10] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 35] = (MathUtil.clip(residual[11] + c5, -128, 127) << 24 >> 24);
        pixOut[off + 48] = (MathUtil.clip(residual[12] + c8, -128, 127) << 24 >> 24);
        pixOut[off + 49] = (MathUtil.clip(residual[13] + c9, -128, 127) << 24 >> 24);
        pixOut[off + 50] = (MathUtil.clip(residual[14] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 51] = (MathUtil.clip(residual[15] + c7, -128, 127) << 24 >> 24);
    };
    constructor.predictVerticalLeft = function(residual, topAvailable, topRightAvailable, topLine, mbOffX, blkX, blkY, pixOut) {
        var to = mbOffX + blkX;
        var tr0 = topLine[to + 3], tr1 = topLine[to + 3], tr2 = topLine[to + 3];
        if (topRightAvailable) {
            tr0 = topLine[to + 4];
            tr1 = topLine[to + 5];
            tr2 = topLine[to + 6];
        }
        var c0 = ((topLine[to] + topLine[to + 1] + 1) >> 1);
        var c1 = ((topLine[to + 1] + topLine[to + 2] + 1) >> 1);
        var c2 = ((topLine[to + 2] + topLine[to + 3] + 1) >> 1);
        var c3 = ((topLine[to + 3] + tr0 + 1) >> 1);
        var c4 = ((tr0 + tr1 + 1) >> 1);
        var c5 = ((topLine[to] + 2 * topLine[to + 1] + topLine[to + 2] + 2) >> 2);
        var c6 = ((topLine[to + 1] + 2 * topLine[to + 2] + topLine[to + 3] + 2) >> 2);
        var c7 = ((topLine[to + 2] + 2 * topLine[to + 3] + tr0 + 2) >> 2);
        var c8 = ((topLine[to + 3] + 2 * tr0 + tr1 + 2) >> 2);
        var c9 = ((tr0 + 2 * tr1 + tr2 + 2) >> 2);
        var off = (blkY << 4) + blkX;
        pixOut[off] = (MathUtil.clip(residual[0] + c0, -128, 127) << 24 >> 24);
        pixOut[off + 1] = (MathUtil.clip(residual[1] + c1, -128, 127) << 24 >> 24);
        pixOut[off + 2] = (MathUtil.clip(residual[2] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 3] = (MathUtil.clip(residual[3] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 16] = (MathUtil.clip(residual[4] + c5, -128, 127) << 24 >> 24);
        pixOut[off + 17] = (MathUtil.clip(residual[5] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 18] = (MathUtil.clip(residual[6] + c7, -128, 127) << 24 >> 24);
        pixOut[off + 19] = (MathUtil.clip(residual[7] + c8, -128, 127) << 24 >> 24);
        pixOut[off + 32] = (MathUtil.clip(residual[8] + c1, -128, 127) << 24 >> 24);
        pixOut[off + 33] = (MathUtil.clip(residual[9] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 34] = (MathUtil.clip(residual[10] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 35] = (MathUtil.clip(residual[11] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 48] = (MathUtil.clip(residual[12] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 49] = (MathUtil.clip(residual[13] + c7, -128, 127) << 24 >> 24);
        pixOut[off + 50] = (MathUtil.clip(residual[14] + c8, -128, 127) << 24 >> 24);
        pixOut[off + 51] = (MathUtil.clip(residual[15] + c9, -128, 127) << 24 >> 24);
    };
    constructor.predictHorizontalUp = function(residual, leftAvailable, leftRow, mbOffX, blkX, blkY, pixOut) {
        var c0 = ((leftRow[blkY] + leftRow[blkY + 1] + 1) >> 1);
        var c1 = ((leftRow[blkY] + (leftRow[blkY + 1] << 1) + leftRow[blkY + 2] + 2) >> 2);
        var c2 = ((leftRow[blkY + 1] + leftRow[blkY + 2] + 1) >> 1);
        var c3 = ((leftRow[blkY + 1] + (leftRow[blkY + 2] << 1) + leftRow[blkY + 3] + 2) >> 2);
        var c4 = ((leftRow[blkY + 2] + leftRow[blkY + 3] + 1) >> 1);
        var c5 = ((leftRow[blkY + 2] + (leftRow[blkY + 3] << 1) + leftRow[blkY + 3] + 2) >> 2);
        var c6 = leftRow[blkY + 3];
        var off = (blkY << 4) + blkX;
        pixOut[off] = (MathUtil.clip(residual[0] + c0, -128, 127) << 24 >> 24);
        pixOut[off + 1] = (MathUtil.clip(residual[1] + c1, -128, 127) << 24 >> 24);
        pixOut[off + 2] = (MathUtil.clip(residual[2] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 3] = (MathUtil.clip(residual[3] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 16] = (MathUtil.clip(residual[4] + c2, -128, 127) << 24 >> 24);
        pixOut[off + 17] = (MathUtil.clip(residual[5] + c3, -128, 127) << 24 >> 24);
        pixOut[off + 18] = (MathUtil.clip(residual[6] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 19] = (MathUtil.clip(residual[7] + c5, -128, 127) << 24 >> 24);
        pixOut[off + 32] = (MathUtil.clip(residual[8] + c4, -128, 127) << 24 >> 24);
        pixOut[off + 33] = (MathUtil.clip(residual[9] + c5, -128, 127) << 24 >> 24);
        pixOut[off + 34] = (MathUtil.clip(residual[10] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 35] = (MathUtil.clip(residual[11] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 48] = (MathUtil.clip(residual[12] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 49] = (MathUtil.clip(residual[13] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 50] = (MathUtil.clip(residual[14] + c6, -128, 127) << 24 >> 24);
        pixOut[off + 51] = (MathUtil.clip(residual[15] + c6, -128, 127) << 24 >> 24);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var MBEncoderHelper = function() {};
MBEncoderHelper = stjs.extend(MBEncoderHelper, null, [], function(constructor, prototype) {
    constructor.takeSubtract = function(planeData, planeWidth, planeHeight, x, y, coeff, pred, blkW, blkH) {
        if (x + blkW < planeWidth && y + blkH < planeHeight) 
            MBEncoderHelper.takeSubtractSafe(planeData, planeWidth, planeHeight, x, y, coeff, pred, blkW, blkH);
         else 
            MBEncoderHelper.takeSubtractUnsafe(planeData, planeWidth, planeHeight, x, y, coeff, pred, blkW, blkH);
    };
    constructor.takeSubtractSafe = function(planeData, planeWidth, planeHeight, x, y, coeff, pred, blkW, blkH) {
        for (var i = 0, srcOff = y * planeWidth + x, dstOff = 0; i < blkH; i++ , srcOff += planeWidth) {
            for (var j = 0, srcOff1 = srcOff; j < blkW; j += 4 , dstOff += 4 , srcOff1 += 4) {
                coeff[dstOff] = planeData[srcOff1] - pred[dstOff];
                coeff[dstOff + 1] = planeData[srcOff1 + 1] - pred[dstOff + 1];
                coeff[dstOff + 2] = planeData[srcOff1 + 2] - pred[dstOff + 2];
                coeff[dstOff + 3] = planeData[srcOff1 + 3] - pred[dstOff + 3];
            }
        }
    };
    constructor.take = function(planeData, planeWidth, planeHeight, x, y, patch, blkW, blkH) {
        if (x + blkW < planeWidth && y + blkH < planeHeight) 
            MBEncoderHelper.takeSafe(planeData, planeWidth, planeHeight, x, y, patch, blkW, blkH);
         else 
            MBEncoderHelper.takeExtendBorder(planeData, planeWidth, planeHeight, x, y, patch, blkW, blkH);
    };
    constructor.takeSafe = function(planeData, planeWidth, planeHeight, x, y, patch, blkW, blkH) {
        for (var i = 0, srcOff = y * planeWidth + x, dstOff = 0; i < blkH; i++ , srcOff += planeWidth) {
            for (var j = 0, srcOff1 = srcOff; j < blkW; ++j , ++dstOff , ++srcOff1) {
                patch[dstOff] = planeData[srcOff1];
            }
        }
    };
    constructor.takeExtendBorder = function(planeData, planeWidth, planeHeight, x, y, patch, blkW, blkH) {
        var outOff = 0;
        var i;
        for (i = y; i < Math.min(y + blkH, planeHeight); i++) {
            var off = i * planeWidth + Math.min(x, planeWidth);
            var j;
            for (j = x; j < Math.min(x + blkW, planeWidth); j++ , outOff++ , off++) {
                patch[outOff] = planeData[off];
            }
            --off;
            for (; j < x + blkW; j++ , outOff++) {
                patch[outOff] = planeData[off];
            }
        }
        for (; i < y + blkH; i++) {
            var off = planeHeight * planeWidth - planeWidth + Math.min(x, planeWidth);
            var j;
            for (j = x; j < Math.min(x + blkW, planeWidth); j++ , outOff++ , off++) {
                patch[outOff] = planeData[off];
            }
            --off;
            for (; j < x + blkW; j++ , outOff++) {
                patch[outOff] = planeData[off];
            }
        }
    };
    constructor.takeSafe2 = function(planeData, planeWidth, planeHeight, x, y, coeff, blkW, blkH) {
        for (var i = 0, srcOff = y * planeWidth + x, dstOff = 0; i < blkH; i++ , srcOff += planeWidth) {
            for (var j = 0, srcOff1 = srcOff; j < blkW; ++j , ++dstOff , ++srcOff1) {
                coeff[dstOff] = planeData[srcOff1];
            }
        }
    };
    constructor.takeSubtractUnsafe = function(planeData, planeWidth, planeHeight, x, y, coeff, pred, blkW, blkH) {
        var outOff = 0;
        var i;
        for (i = y; i < Math.min(y + blkH, planeHeight); i++) {
            var off = i * planeWidth + Math.min(x, planeWidth);
            var j;
            for (j = x; j < Math.min(x + blkW, planeWidth); j++ , outOff++ , off++) {
                coeff[outOff] = planeData[off] - pred[outOff];
            }
            --off;
            for (; j < x + blkW; j++ , outOff++) {
                coeff[outOff] = planeData[off] - pred[outOff];
            }
        }
        for (; i < y + blkH; i++) {
            var off = planeHeight * planeWidth - planeWidth + Math.min(x, planeWidth);
            var j;
            for (j = x; j < Math.min(x + blkW, planeWidth); j++ , outOff++ , off++) {
                coeff[outOff] = planeData[off] - pred[outOff];
            }
            --off;
            for (; j < x + blkW; j++ , outOff++) {
                coeff[outOff] = planeData[off] - pred[outOff];
            }
        }
    };
    constructor.putBlk = function(planeData, block, pred, log2stride, blkX, blkY, blkW, blkH) {
        var stride = 1 << log2stride;
        for (var line = 0, srcOff = 0, dstOff = (blkY << log2stride) + blkX; line < blkH; line++) {
            var dstOff1 = dstOff;
            for (var row = 0; row < blkW; row += 4) {
                planeData[dstOff1] = (MathUtil.clip(block[srcOff] + pred[srcOff], -128, 127) << 24 >> 24);
                planeData[dstOff1 + 1] = (MathUtil.clip(block[srcOff + 1] + pred[srcOff + 1], -128, 127) << 24 >> 24);
                planeData[dstOff1 + 2] = (MathUtil.clip(block[srcOff + 2] + pred[srcOff + 2], -128, 127) << 24 >> 24);
                planeData[dstOff1 + 3] = (MathUtil.clip(block[srcOff + 3] + pred[srcOff + 3], -128, 127) << 24 >> 24);
                srcOff += 4;
                dstOff1 += 4;
            }
            dstOff += stride;
        }
    };
    constructor.putBlkPic = function(dest, src, x, y) {
        if (dest.getColor() != src.getColor()) 
             throw new RuntimeException("Incompatible color");
        for (var c = 0; c < dest.getColor().nComp; c++) {
            MBEncoderHelper.pubBlkOnePlane(dest.getPlaneData(c), dest.getPlaneWidth(c), src.getPlaneData(c), src.getPlaneWidth(c), src.getPlaneHeight(c), x >> dest.getColor().compWidth[c], y >> dest.getColor().compHeight[c]);
        }
    };
    constructor.pubBlkOnePlane = function(dest, destWidth, src, srcWidth, srcHeight, x, y) {
        var destOff = y * destWidth + x;
        var srcOff = 0;
        for (var i = 0; i < srcHeight; i++) {
            for (var j = 0; j < srcWidth; j++ , ++destOff , ++srcOff) 
                dest[destOff] = src[srcOff];
            destOff += destWidth - srcWidth;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv420jToRgbHiBD = function() {};
Yuv420jToRgbHiBD = stjs.extend(Yuv420jToRgbHiBD, null, [TransformHiBD], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        var offLuma = 0, offChroma = 0;
        var stride = dst.getWidth();
        for (var i = 0; i < (dst.getHeight() >> 1); i++) {
            for (var k = 0; k < (dst.getWidth() >> 1); k++) {
                var j = k << 1;
                Yuv420jToRgbHiBD.YUVJtoRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                Yuv420jToRgbHiBD.YUVJtoRGB(y[offLuma + j + 1], u[offChroma], v[offChroma], data, (offLuma + j + 1) * 3);
                Yuv420jToRgbHiBD.YUVJtoRGB(y[offLuma + j + stride], u[offChroma], v[offChroma], data, (offLuma + j + stride) * 3);
                Yuv420jToRgbHiBD.YUVJtoRGB(y[offLuma + j + stride + 1], u[offChroma], v[offChroma], data, (offLuma + j + stride + 1) * 3);
                ++offChroma;
            }
            if ((dst.getWidth() & 1) != 0) {
                var j = dst.getWidth() - 1;
                Yuv420jToRgbHiBD.YUVJtoRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                Yuv420jToRgbHiBD.YUVJtoRGB(y[offLuma + j + stride], u[offChroma], v[offChroma], data, (offLuma + j + stride) * 3);
                ++offChroma;
            }
            offLuma += 2 * stride;
        }
        if ((dst.getHeight() & 1) != 0) {
            for (var k = 0; k < (dst.getWidth() >> 1); k++) {
                var j = k << 1;
                Yuv420jToRgbHiBD.YUVJtoRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                Yuv420jToRgbHiBD.YUVJtoRGB(y[offLuma + j + 1], u[offChroma], v[offChroma], data, (offLuma + j + 1) * 3);
                ++offChroma;
            }
            if ((dst.getWidth() & 1) != 0) {
                var j = dst.getWidth() - 1;
                Yuv420jToRgbHiBD.YUVJtoRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                ++offChroma;
            }
        }
    };
    constructor.SCALEBITS = 10;
    constructor.ONE_HALF = (1 << (Yuv420jToRgbHiBD.SCALEBITS - 1));
    constructor.FIX = function(x) {
        return (stjs.trunc(((x) * (1 << Yuv420jToRgbHiBD.SCALEBITS) + 0.5)));
    };
    constructor.FIX_0_71414 = Yuv420jToRgbHiBD.FIX(0.71414);
    constructor.FIX_1_772 = Yuv420jToRgbHiBD.FIX(1.772);
    constructor._FIX_0_34414 = -Yuv420jToRgbHiBD.FIX(0.34414);
    constructor.FIX_1_402 = Yuv420jToRgbHiBD.FIX(1.402);
    constructor.YUVJtoRGB = function(y, cb, cr, data, off) {
        y = y << Yuv420jToRgbHiBD.SCALEBITS;
        cb = cb - 128;
        cr = cr - 128;
        var add_r = Yuv420jToRgbHiBD.FIX_1_402 * cr + Yuv420jToRgbHiBD.ONE_HALF;
        var add_g = Yuv420jToRgbHiBD._FIX_0_34414 * cb - Yuv420jToRgbHiBD.FIX_0_71414 * cr + Yuv420jToRgbHiBD.ONE_HALF;
        var add_b = Yuv420jToRgbHiBD.FIX_1_772 * cb + Yuv420jToRgbHiBD.ONE_HALF;
        var r = (y + add_r) >> Yuv420jToRgbHiBD.SCALEBITS;
        var g = (y + add_g) >> Yuv420jToRgbHiBD.SCALEBITS;
        var b = (y + add_b) >> Yuv420jToRgbHiBD.SCALEBITS;
        data[off] = MathUtil.clip(r, 0, 255);
        data[off + 1] = MathUtil.clip(g, 0, 255);
        data[off + 2] = MathUtil.clip(b, 0, 255);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var LongArrayList = function(growAmount) {
    this.growAmount = growAmount;
    this.storage = Array(growAmount);
};
LongArrayList = stjs.extend(LongArrayList, null, [], function(constructor, prototype) {
    constructor.DEFAULT_GROW_AMOUNT = 128;
    prototype.storage = null;
    prototype.limit = 0;
    prototype.start = 0;
    prototype.growAmount = 0;
    constructor.createLongArrayList = function() {
        return new LongArrayList(LongArrayList.DEFAULT_GROW_AMOUNT);
    };
    prototype.toArray = function() {
        var result = Array(this.limit - this.start);
        System.arraycopy(this.storage, this.start, result, 0, this.limit - this.start);
        return result;
    };
    prototype.add = function(val) {
        if (this.limit > this.storage.length - 1) {
            var ns = Array(this.storage.length + this.growAmount - this.start);
            System.arraycopy(this.storage, this.start, ns, 0, this.storage.length - this.start);
            this.storage = ns;
            this.limit -= this.start;
            this.start = 0;
        }
        this.storage[this.limit++] = val;
    };
    prototype.push = function(id) {
        this.add(id);
    };
    prototype.pop = function() {
        if (this.limit <= this.start) 
             throw new IllegalStateException();
        return this.storage[this.limit--];
    };
    prototype.set = function(index, value) {
        this.storage[index + this.start] = value;
    };
    prototype.get = function(index) {
        return this.storage[index + this.start];
    };
    prototype.shift = function() {
        if (this.start >= this.limit) 
             throw new IllegalStateException();
        return this.storage[this.start++];
    };
    prototype.fill = function(from, to, val) {
        if (to > this.storage.length) {
            var ns = Array(to + this.growAmount - this.start);
            System.arraycopy(this.storage, this.start, ns, 0, this.storage.length - this.start);
            this.storage = ns;
        }
        Arrays.fillRange(this.storage, from, to, val);
        this.limit = Math.max(this.limit, to);
    };
    prototype.size = function() {
        return this.limit - this.start;
    };
    prototype.addAll = function(other) {
        if (this.limit + other.length >= this.storage.length) {
            var ns = Array(this.limit + this.growAmount + other.length - this.start);
            System.arraycopy(this.storage, this.start, ns, 0, this.limit);
            this.storage = ns;
        }
        System.arraycopy(other, 0, this.storage, this.limit, other.length);
        this.limit += other.length;
    };
    prototype.clear = function() {
        this.limit = 0;
        this.start = 0;
    };
    prototype.contains = function(needle) {
        for (var i = this.start; i < this.limit; i++) 
            if (this.storage[i] == needle) 
                return true;
        return false;
    };
}, {storage: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Mp3Mdct = function() {};
Mp3Mdct = stjs.extend(Mp3Mdct, null, [], function(constructor, prototype) {
    constructor.factor36pt0 = 0.34729636;
    constructor.factor36pt1 = 1.5320889;
    constructor.factor36pt2 = 1.8793852;
    constructor.factor36pt3 = 1.7320508;
    constructor.factor36pt4 = 1.9696155;
    constructor.factor36pt5 = 1.2855753;
    constructor.factor36pt6 = 0.6840403;
    constructor.factor36 = new Float32Array([0.5019099, 0.5176381, 0.55168897, 0.61038727, 0.8717234, 1.1831008, 1.9318516, 5.7368565]);
    constructor.cos075 = 0.9914449;
    constructor.cos225 = 0.9238795;
    constructor.cos300 = 0.8660254;
    constructor.cos375 = 0.7933533;
    constructor.cos450 = 0.70710677;
    constructor.cos525 = 0.6087614;
    constructor.cos600 = 0.5;
    constructor.cos675 = 0.38268343;
    constructor.cos825 = 0.13052619;
    constructor.factor12pt0 = 1.9318516;
    constructor.factor12pt1 = 0.5176381;
    constructor.factor12 = new Float32Array([0.5043145, 0.5411961, 0.6302362, 0.8213398, 1.306563, 3.830649]);
    constructor.tmp = new Float32Array(16);
    constructor.oneLong = function(src, dst) {
        for (var i = 17; i > 0; i--) 
            src[i] += src[i - 1];
        for (var i = 17; i > 2; i -= 2) 
            src[i] += src[i - 2];
        for (var i = 0, k = 0; i < 2; i++ , k += 8) {
            var tmp0 = src[i] + src[i];
            var tmp1 = tmp0 + src[12 + i];
            var tmp2 = src[6 + i] * Mp3Mdct.factor36pt3;
            Mp3Mdct.tmp[k + 0] = tmp1 + src[4 + i] * Mp3Mdct.factor36pt2 + src[8 + i] * Mp3Mdct.factor36pt1 + src[16 + i] * Mp3Mdct.factor36pt0;
            Mp3Mdct.tmp[k + 1] = tmp0 + src[4 + i] - src[8 + i] - src[12 + i] - src[12 + i] - src[16 + i];
            Mp3Mdct.tmp[k + 2] = tmp1 - src[4 + i] * Mp3Mdct.factor36pt0 - src[8 + i] * Mp3Mdct.factor36pt2 + src[16 + i] * Mp3Mdct.factor36pt1;
            Mp3Mdct.tmp[k + 3] = tmp1 - src[4 + i] * Mp3Mdct.factor36pt1 + src[8 + i] * Mp3Mdct.factor36pt0 - src[16 + i] * Mp3Mdct.factor36pt2;
            Mp3Mdct.tmp[k + 4] = src[2 + i] * Mp3Mdct.factor36pt4 + tmp2 + src[10 + i] * Mp3Mdct.factor36pt5 + src[14 + i] * Mp3Mdct.factor36pt6;
            Mp3Mdct.tmp[k + 5] = (src[2 + i] - src[10 + i] - src[14 + i]) * Mp3Mdct.factor36pt3;
            Mp3Mdct.tmp[k + 6] = src[2 + i] * Mp3Mdct.factor36pt5 - tmp2 - src[10 + i] * Mp3Mdct.factor36pt6 + src[14 + i] * Mp3Mdct.factor36pt4;
            Mp3Mdct.tmp[k + 7] = src[2 + i] * Mp3Mdct.factor36pt6 - tmp2 + src[10 + i] * Mp3Mdct.factor36pt4 - src[14 + i] * Mp3Mdct.factor36pt5;
        }
        for (var i = 0, j = 4, k = 8, l = 12; i < 4; i++ , j++ , k++ , l++) {
            var q1 = Mp3Mdct.tmp[i];
            var q2 = Mp3Mdct.tmp[k];
            Mp3Mdct.tmp[i] += Mp3Mdct.tmp[j];
            Mp3Mdct.tmp[j] = q1 - Mp3Mdct.tmp[j];
            Mp3Mdct.tmp[k] = (Mp3Mdct.tmp[k] + Mp3Mdct.tmp[l]) * Mp3Mdct.factor36[i];
            Mp3Mdct.tmp[l] = (q2 - Mp3Mdct.tmp[l]) * Mp3Mdct.factor36[7 - i];
        }
        for (var i = 0; i < 4; i++) {
            dst[26 - i] = Mp3Mdct.tmp[i] + Mp3Mdct.tmp[8 + i];
            dst[8 - i] = Mp3Mdct.tmp[8 + i] - Mp3Mdct.tmp[i];
            dst[27 + i] = dst[26 - i];
            dst[9 + i] = -dst[8 - i];
        }
        for (var i = 0; i < 4; i++) {
            dst[21 - i] = Mp3Mdct.tmp[7 - i] + Mp3Mdct.tmp[15 - i];
            dst[3 - i] = Mp3Mdct.tmp[15 - i] - Mp3Mdct.tmp[7 - i];
            dst[32 + i] = dst[21 - i];
            dst[14 + i] = -dst[3 - i];
        }
        var tmp0 = src[0] - src[4] + src[8] - src[12] + src[16];
        var tmp1 = (src[1] - src[5] + src[9] - src[13] + src[17]) * Mp3Mdct.cos450;
        dst[4] = tmp1 - tmp0;
        dst[13] = -dst[4];
        dst[31] = dst[22] = tmp0 + tmp1;
    };
    constructor.threeShort = function(src, dst) {
        Arrays.fill(dst, 0.0);
        for (var i = 0, outOff = 0; i < 3; i++ , outOff += 6) {
            Mp3Mdct.imdct12(src, dst, outOff, i);
        }
    };
    constructor.imdct12 = function(src, dst, outOff, wndIdx) {
        for (var j = 15 + wndIdx, k = 12 + wndIdx; j >= 3 + wndIdx; j -= 3 , k -= 3) 
            src[j] += src[k];
        src[15 + wndIdx] += src[9 + wndIdx];
        src[9 + wndIdx] += src[3 + wndIdx];
        var pp2 = src[12 + wndIdx] * Mp3Mdct.cos600;
        var pp1 = src[6 + wndIdx] * Mp3Mdct.cos300;
        var sum = src[0 + wndIdx] + pp2;
        Mp3Mdct.tmp[1] = src[wndIdx] - src[12 + wndIdx];
        Mp3Mdct.tmp[0] = sum + pp1;
        Mp3Mdct.tmp[2] = sum - pp1;
        pp2 = src[15 + wndIdx] * Mp3Mdct.cos600;
        pp1 = src[9 + wndIdx] * Mp3Mdct.cos300;
        sum = src[3 + wndIdx] + pp2;
        Mp3Mdct.tmp[4] = src[3 + wndIdx] - src[15 + wndIdx];
        Mp3Mdct.tmp[5] = sum + pp1;
        Mp3Mdct.tmp[3] = sum - pp1;
        Mp3Mdct.tmp[3] *= Mp3Mdct.factor12pt0;
        Mp3Mdct.tmp[4] *= Mp3Mdct.cos450;
        Mp3Mdct.tmp[5] *= Mp3Mdct.factor12pt1;
        var t = Mp3Mdct.tmp[0];
        Mp3Mdct.tmp[0] += Mp3Mdct.tmp[5];
        Mp3Mdct.tmp[5] = t - Mp3Mdct.tmp[5];
        t = Mp3Mdct.tmp[1];
        Mp3Mdct.tmp[1] += Mp3Mdct.tmp[4];
        Mp3Mdct.tmp[4] = t - Mp3Mdct.tmp[4];
        t = Mp3Mdct.tmp[2];
        Mp3Mdct.tmp[2] += Mp3Mdct.tmp[3];
        Mp3Mdct.tmp[3] = t - Mp3Mdct.tmp[3];
        for (var j = 0; j < 6; j++) 
            Mp3Mdct.tmp[j] *= Mp3Mdct.factor12[j];
        Mp3Mdct.tmp[8] = -Mp3Mdct.tmp[0] * Mp3Mdct.cos375;
        Mp3Mdct.tmp[9] = -Mp3Mdct.tmp[0] * Mp3Mdct.cos525;
        Mp3Mdct.tmp[7] = -Mp3Mdct.tmp[1] * Mp3Mdct.cos225;
        Mp3Mdct.tmp[10] = -Mp3Mdct.tmp[1] * Mp3Mdct.cos675;
        Mp3Mdct.tmp[6] = -Mp3Mdct.tmp[2] * Mp3Mdct.cos075;
        Mp3Mdct.tmp[11] = -Mp3Mdct.tmp[2] * Mp3Mdct.cos825;
        Mp3Mdct.tmp[0] = Mp3Mdct.tmp[3];
        Mp3Mdct.tmp[1] = Mp3Mdct.tmp[4] * Mp3Mdct.cos675;
        Mp3Mdct.tmp[2] = Mp3Mdct.tmp[5] * Mp3Mdct.cos525;
        Mp3Mdct.tmp[3] = -Mp3Mdct.tmp[5] * Mp3Mdct.cos375;
        Mp3Mdct.tmp[4] = -Mp3Mdct.tmp[4] * Mp3Mdct.cos225;
        Mp3Mdct.tmp[5] = -Mp3Mdct.tmp[0] * Mp3Mdct.cos075;
        Mp3Mdct.tmp[0] *= Mp3Mdct.cos825;
        for (var i = 0, j = outOff + 6; i < 12; i++ , j++) {
            dst[j] += Mp3Mdct.tmp[i];
        }
    };
}, {factor36: "Float32Array", factor12: "Float32Array", tmp: "Float32Array"}, {});
var Platform = function() {};
Platform = stjs.extend(Platform, null, [], function(constructor, prototype) {
    constructor.UTF_8 = "UTF-8";
    constructor.UTF_16 = "UTF-16";
    constructor.UTF_16BE = "UTF-16BE";
    constructor.ISO8859_1 = "iso8859-1";
    constructor.newInstance = function(clazz, params) {
        return new (Function.prototype.bind.apply(clazz, [null].concat(params)));
    };
    constructor.getDeclaredFields = function(class1) {
        return null;
    };
    constructor.getFields = function(class1) {
        return null;
    };
    constructor.stringFromCharset = function(data, charset) {
        if (charset.equals(Platform.UTF_8)) {
            return Platform.stringFromBytes(data);
        }
         throw new RuntimeException("charset not supported " + charset);
    };
    constructor.getBytesForCharset = function(str, charset) {
        return str.getBytes();
    };
    constructor.stringFromCharset4 = function(data, offset, len, charset) {
         throw new RuntimeException("TODO stringFromCharset4");
    };
    constructor.getResource = function(class1, string) {
         throw new RuntimeException("TODO getResource");
    };
    constructor.arrayEqualsInt = function(a, a2) {
        return Arrays.arrayEquals(a, a2);
    };
    constructor.arrayEqualsByte = function(a, a2) {
        return Arrays.arrayEquals(a, a2);
    };
    constructor.arrayEqualsObj = function(a, a2) {
        return Arrays.arrayEquals(a, a2);
    };
    constructor.copyOfRangeO = function(original, from, to) {
        return Arrays.copyOfRange(original, from, to);
    };
    constructor.copyOfRangeL = function(original, from, to) {
        return Arrays.copyOfRange(original, from, to);
    };
    constructor.copyOfRangeI = function(original, from, to) {
        return Arrays.copyOfRange(original, from, to);
    };
    constructor.copyOfRangeB = function(original, from, to) {
        return Arrays.copyOfRange(original, from, to);
    };
    constructor.copyOfObj = function(original, newLength) {
        return Arrays.copyOf(original, newLength);
    };
    constructor.copyOfLong = function(original, newLength) {
        return Arrays.copyOf(original, newLength);
    };
    constructor.copyOfInt = function(original, newLength) {
        return Arrays.copyOf(original, newLength);
    };
    constructor.copyOfBool = function(original, newLength) {
        return Arrays.copyOf(original, newLength);
    };
    constructor.copyOfByte = function(original, newLength) {
        return Arrays.copyOf(original, newLength);
    };
    constructor.arrayToString = function(a) {
        return Arrays.arrayToString(a);
    };
    constructor.deleteFile = function(file) {
        file.$delete();
    };
    constructor.getBytes = function(fourcc) {
        return Platform.getBytesForCharset(fourcc, Platform.ISO8859_1);
    };
    constructor.stringFromBytes = function(bytes) {
        return String.fromCharCode.apply(null, bytes);
    };
    constructor.isAssignableFrom = function(class1, class2) {
        if (class1 == class2) {
            return true;
        }
        var parents = ((class2)["$inherit"] || []);
        return parents.indexOf(class1) >= 0;
    };
    constructor.stdin = function() {
        return null;
    };
    constructor.toJSON = function(o) {
        return JSON.stringify(o);
    };
    constructor.invokeStaticMethod = function(cls, methodName, params) {
        var method = (cls)[methodName];
        return (method).apply(cls, (params));
    };
    constructor.unsignedInt = function(signed) {
        return (signed & 2147483647) + ((signed >>> 31) * -2147483648);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IntArrayList = function(growAmount) {
    this.growAmount = growAmount;
    this.storage = new Int32Array(growAmount);
};
IntArrayList = stjs.extend(IntArrayList, null, [], function(constructor, prototype) {
    constructor.DEFAULT_GROW_AMOUNT = 128;
    prototype.storage = null;
    prototype._size = 0;
    prototype.growAmount = 0;
    constructor.createIntArrayList = function() {
        return new IntArrayList(IntArrayList.DEFAULT_GROW_AMOUNT);
    };
    prototype.toArray = function() {
        var result = new Int32Array(this._size);
        System.arraycopy(this.storage, 0, result, 0, this._size);
        return result;
    };
    prototype.add = function(val) {
        if (this._size >= this.storage.length) {
            var ns = new Int32Array(this.storage.length + this.growAmount);
            System.arraycopy(this.storage, 0, ns, 0, this.storage.length);
            this.storage = ns;
        }
        this.storage[this._size++] = val;
    };
    prototype.push = function(id) {
        this.add(id);
    };
    prototype.pop = function() {
        if (this._size == 0) 
            return;
        this._size--;
    };
    prototype.set = function(index, value) {
        this.storage[index] = value;
    };
    prototype.get = function(index) {
        return this.storage[index];
    };
    prototype.fill = function(start, end, val) {
        if (end > this.storage.length) {
            var ns = new Int32Array(end + this.growAmount);
            System.arraycopy(this.storage, 0, ns, 0, this.storage.length);
            this.storage = ns;
        }
        Arrays.fillRange(this.storage, start, end, val);
        this._size = Math.max(this._size, end);
    };
    prototype.size = function() {
        return this._size;
    };
    prototype.addAll = function(other) {
        if (this._size + other.length >= this.storage.length) {
            var ns = new Int32Array(this._size + this.growAmount + other.length);
            System.arraycopy(this.storage, 0, ns, 0, this._size);
            this.storage = ns;
        }
        System.arraycopy(other, 0, this.storage, this._size, other.length);
        this._size += other.length;
    };
    prototype.clear = function() {
        this._size = 0;
    };
    prototype.contains = function(needle) {
        for (var i = 0; i < this._size; i++) 
            if (this.storage[i] == needle) 
                return true;
        return false;
    };
}, {storage: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ByteArrayList = function(growAmount) {
    this.growAmount = growAmount;
    this.storage = new Int8Array(growAmount);
};
ByteArrayList = stjs.extend(ByteArrayList, null, [], function(constructor, prototype) {
    constructor.DEFAULT_GROW_AMOUNT = 2048;
    constructor.createByteArrayList = function() {
        return new ByteArrayList(ByteArrayList.DEFAULT_GROW_AMOUNT);
    };
    prototype.storage = null;
    prototype._size = 0;
    prototype.growAmount = 0;
    prototype.toArray = function() {
        var result = new Int8Array(this._size);
        System.arraycopy(this.storage, 0, result, 0, this._size);
        return result;
    };
    prototype.add = function(val) {
        if (this._size >= this.storage.length) {
            var ns = new Int8Array(this.storage.length + this.growAmount);
            System.arraycopy(this.storage, 0, ns, 0, this.storage.length);
            this.storage = ns;
        }
        this.storage[this._size++] = val;
    };
    prototype.push = function(id) {
        this.add(id);
    };
    prototype.pop = function() {
        if (this._size == 0) 
            return;
        this._size--;
    };
    prototype.set = function(index, value) {
        this.storage[index] = value;
    };
    prototype.get = function(index) {
        return this.storage[index];
    };
    prototype.fill = function(start, end, val) {
        if (end > this.storage.length) {
            var ns = new Int8Array(end + this.growAmount);
            System.arraycopy(this.storage, 0, ns, 0, this.storage.length);
            this.storage = ns;
        }
        Arrays.fillRange(this.storage, start, end, val);
        this._size = Math.max(this._size, end);
    };
    prototype.size = function() {
        return this._size;
    };
    prototype.addAll = function(other) {
        if (this._size + other.length >= this.storage.length) {
            var ns = new Int8Array(this._size + this.growAmount + other.length);
            System.arraycopy(this.storage, 0, ns, 0, this._size);
            this.storage = ns;
        }
        System.arraycopy(other, 0, this.storage, this._size, other.length);
        this._size += other.length;
    };
    prototype.contains = function(needle) {
        for (var i = 0; i < this._size; i++) 
            if (this.storage[i] == needle) 
                return true;
        return false;
    };
}, {storage: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Performs IDCT of 8x8 block.
 *  
 *  See MPEGDecoder for example.
 *  
 *  @author The JCodec project
 *  
 */
var SparseIDCT = function() {};
SparseIDCT = stjs.extend(SparseIDCT, null, [], function(constructor, prototype) {
    constructor.COEFF = Array(64);
    constructor.PRECISION = 13;
    constructor.DC_SHIFT = SparseIDCT.PRECISION - 3;
    /**
     *  Starts DCT reconstruction
     *  
     *  Faster then call to 'coeff' with ind = 0
     *  
     *  @param block
     *  @param dc
     */
    constructor.start = function(block, dc) {
        dc <<= SparseIDCT.DC_SHIFT;
        for (var i = 0; i < 64; i += 4) {
            block[i + 0] = dc;
            block[i + 1] = dc;
            block[i + 2] = dc;
            block[i + 3] = dc;
        }
    };
    /**
     *  Recalculates image based on new DCT coefficient
     *  
     *  @param block
     *  @param ind
     *  @param level
     */
    constructor.coeff = function(block, ind, level) {
        for (var i = 0; i < 64; i += 4) {
            block[i] += SparseIDCT.COEFF[ind][i] * level;
            block[i + 1] += SparseIDCT.COEFF[ind][i + 1] * level;
            block[i + 2] += SparseIDCT.COEFF[ind][i + 2] * level;
            block[i + 3] += SparseIDCT.COEFF[ind][i + 3] * level;
        }
    };
    /**
     *  Finalizes DCT calculation
     *  
     *  @param block
     */
    constructor.finish = function(block) {
        for (var i = 0; i < 64; i += 4) {
            block[i] = SparseIDCT.div(block[i]);
            block[i + 1] = SparseIDCT.div(block[i + 1]);
            block[i + 2] = SparseIDCT.div(block[i + 2]);
            block[i + 3] = SparseIDCT.div(block[i + 3]);
        }
    };
    constructor.div = function(x) {
        var m = x >> 31;
        var n = x >>> 31;
        return ((((x ^ m) + n) >> SparseIDCT.PRECISION) ^ m) + n;
    };
}, {COEFF: "Array"}, {});
(function() {
    SparseIDCT.COEFF[0] = new Int32Array(64);
    Arrays.fill(SparseIDCT.COEFF[0], 1 << SparseIDCT.DC_SHIFT);
    var ac = 1 << SparseIDCT.PRECISION;
    for (var i = 1; i < 64; i++) {
        SparseIDCT.COEFF[i] = new Int32Array(64);
        SparseIDCT.COEFF[i][i] = ac;
        SimpleIDCT10Bit.idct10(SparseIDCT.COEFF[i], 0);
    }
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IntIntMap = function() {
    this.storage = this.createArray(IntIntMap.GROW_BY);
    Arrays.fill(this.storage, Integer.MIN_VALUE);
};
IntIntMap = stjs.extend(IntIntMap, null, [], function(constructor, prototype) {
    constructor.GROW_BY = 128;
    prototype.storage = null;
    prototype._size = 0;
    prototype.put = function(key, val) {
        if (val == Integer.MIN_VALUE) 
             throw new IllegalArgumentException("This implementation can not store " + Integer.MIN_VALUE);
        if (this.storage.length <= key) {
            var ns = this.createArray(key + IntIntMap.GROW_BY);
            System.arraycopy(this.storage, 0, ns, 0, this.storage.length);
            Arrays.fillRange(ns, this.storage.length, ns.length, Integer.MIN_VALUE);
            this.storage = ns;
        }
        if (this.storage[key] == Integer.MIN_VALUE) 
            this._size++;
        this.storage[key] = val;
    };
    prototype.get = function(key) {
        return key >= this.storage.length ? Integer.MIN_VALUE : this.storage[key];
    };
    prototype.contains = function(key) {
        return key >= 0 && key < this.storage.length;
    };
    prototype.keys = function() {
        var result = new Int32Array(this._size);
        for (var i = 0, r = 0; i < this.storage.length; i++) {
            if (this.storage[i] != Integer.MIN_VALUE) 
                result[r++] = i;
        }
        return result;
    };
    prototype.clear = function() {
        for (var i = 0; i < this.storage.length; i++) 
            this.storage[i] = Integer.MIN_VALUE;
        this._size = 0;
    };
    prototype.size = function() {
        return this._size;
    };
    prototype.remove = function(key) {
        if (this.storage[key] != Integer.MIN_VALUE) 
            this._size--;
        this.storage[key] = Integer.MIN_VALUE;
    };
    prototype.values = function() {
        var result = this.createArray(this._size);
        for (var i = 0, r = 0; i < this.storage.length; i++) {
            if (this.storage[i] != Integer.MIN_VALUE) 
                result[r++] = this.storage[i];
        }
        return result;
    };
    prototype.createArray = function(size) {
        return new Int32Array(size);
    };
}, {storage: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ModeInfo = function(segmentId, skip, txSize, yMode, subModes, uvMode) {
    this.segmentId = segmentId;
    this.skip = skip;
    this.txSize = txSize;
    this.yMode = yMode;
    this.subModes = subModes;
    this.uvMode = uvMode;
};
ModeInfo = stjs.extend(ModeInfo, null, [], function(constructor, prototype) {
    prototype.segmentId = 0;
    prototype.skip = false;
    prototype.txSize = 0;
    prototype.yMode = 0;
    prototype.subModes = 0;
    prototype.uvMode = 0;
    prototype.getSegmentId = function() {
        return this.segmentId;
    };
    prototype.isSkip = function() {
        return this.skip;
    };
    prototype.getTxSize = function() {
        return this.txSize;
    };
    prototype.getyMode = function() {
        return this.yMode;
    };
    prototype.getSubModes = function() {
        return this.subModes;
    };
    prototype.getUvMode = function() {
        return this.uvMode;
    };
    constructor.read = function(miCol, miRow, blSz, decoder, probs, c) {
        var segmentId = 0;
        if (c.isSegmentationEnabled() && c.isUpdateSegmentMap()) 
            segmentId = ModeInfo.readSegmentId(decoder, probs);
        var skip = true;
        if (!c.isSegmentFeatureActive(segmentId, Consts.SEG_LVL_SKIP)) 
            skip = ModeInfo.readSkipFlag(miCol, miRow, blSz, decoder, probs, c);
        var txSize = ModeInfo.readTxSize(miCol, miRow, blSz, true, decoder, probs, c);
        var yMode;
        var subModes = 0;
        if (blSz >= Consts.BLOCK_8X8) {
            yMode = ModeInfo.readDefaultIntraMode(miCol, miRow, blSz, decoder, probs, c);
        } else {
            subModes = ModeInfo.readDefaultIntraModeSub(miCol, miRow, blSz, decoder, probs, c);
            yMode = subModes & 255;
        }
        var uvMode = ModeInfo.readDefaultUVMode(yMode, decoder, probs, c);
        return new ModeInfo(segmentId, skip, txSize, yMode, subModes, uvMode);
    };
    constructor.readDefaultIntraMode = function(miCol, miRow, blSz, decoder, probStore, c) {
        var availAbove = miRow > 0;
        var availLeft = miCol > c.getTileStart();
        var aboveIntraModes = c.getAboveIntraModes();
        var leftIntraModes = c.getLeftIntraModes();
        var aboveMode;
        var leftMode;
        aboveMode = availAbove ? aboveIntraModes[miCol] : Consts.DC_PRED;
        leftMode = availLeft ? leftIntraModes[miRow % 8] : Consts.DC_PRED;
        var probs = probStore.getKfYModeProbs();
        var intraMode = decoder.readTree(Consts.TREE_INTRA_MODE, probs[aboveMode][leftMode]);
        aboveIntraModes[miCol] = intraMode;
        leftIntraModes[miRow % 8] = intraMode;
        return intraMode;
    };
    constructor.readDefaultIntraModeSub = function(miCol, miRow, blSz, decoder, probStore, c) {
        var availAbove = miRow > 0;
        var availLeft = miCol > c.getTileStart();
        var aboveIntraModes = c.getAboveIntraModes();
        var leftIntraModes = c.getLeftIntraModes();
        var aboveMode;
        var leftMode;
        var probs = probStore.getKfYModeProbs();
        aboveMode = availAbove ? aboveIntraModes[2 * miCol + 1] : Consts.DC_PRED;
        leftMode = availLeft ? leftIntraModes[2 * (miRow % 8) + 1] : Consts.DC_PRED;
        var mode0 = decoder.readTree(Consts.TREE_INTRA_MODE, probs[aboveMode][leftMode]);
        var mode1 = 0, mode2 = 0, mode3 = 0;
        if (blSz == Consts.BLOCK_4X4) {
            mode1 = decoder.readTree(Consts.TREE_INTRA_MODE, probs[aboveMode][mode0]);
            mode2 = decoder.readTree(Consts.TREE_INTRA_MODE, probs[mode0][leftMode]);
            mode3 = decoder.readTree(Consts.TREE_INTRA_MODE, probs[mode1][mode2]);
            aboveIntraModes[miCol] = mode2;
            leftIntraModes[miRow % 8] = mode1;
            return (mode0 << 24) | (mode1 << 16) | (mode2 << 8) | mode3;
        } else if (blSz == Consts.BLOCK_4X8) {
            mode1 = decoder.readTree(Consts.TREE_INTRA_MODE, probs[aboveMode][mode0]);
            aboveIntraModes[miCol] = mode0;
            leftIntraModes[miRow % 8] = mode1;
            return (mode0 << 8) | mode1;
        } else if (blSz == Consts.BLOCK_8X4) {
            mode1 = decoder.readTree(Consts.TREE_INTRA_MODE, probs[mode0][leftMode]);
            aboveIntraModes[miCol] = mode1;
            leftIntraModes[miRow % 8] = mode0;
            return (mode0 << 8) | mode1;
        }
        return 0;
    };
    constructor.readDefaultUVMode = function(yMode, decoder, probStore, c) {
        var probs = probStore.getKfUVModeProbs();
        return decoder.readTree(Consts.TREE_INTRA_MODE, probs[yMode]);
    };
    constructor.readTxSize = function(miCol, miRow, blSz, allowSelect, decoder, probStore, c) {
        var maxTxSize = Consts.maxTxLookup[blSz];
        var txSize = Math.min(maxTxSize, c.getTxMode());
        var txSizes = c.getTxSizes();
        var skipped = c.getSkippedBlockes();
        if (allowSelect && c.getTxMode() == Consts.TX_MODE_SELECT && blSz >= Consts.BLOCK_8X8) {
            var availAbove = miRow > 0;
            var availLeft = miCol > c.getTileStart();
            var above = maxTxSize;
            var left = maxTxSize;
            if (availAbove && !skipped[miRow - 1][miCol]) 
                above = txSizes[miRow - 1][miCol];
            if (availLeft && !skipped[miRow][miCol - 1]) 
                left = txSizes[miRow][miCol - 1];
            if (!availLeft) 
                left = above;
            if (!availAbove) 
                above = left;
            var ctx = (above + left) > maxTxSize ? 1 : 0;
            var probs = probStore.getTxProbs();
            txSize = decoder.readTree(Consts.TREE_TX_SIZE[maxTxSize], probs[maxTxSize][ctx]);
        }
        for (var i = 0; i < Consts.blH[blSz]; i++) {
            for (var j = 0; j < Consts.blW[blSz]; j++) {
                txSizes[i + miRow][j + miCol] = txSize;
            }
        }
        return 0;
    };
    constructor.readSegmentId = function(decoder, probStore) {
        var probs = probStore.getSegmentationTreeProbs();
        return decoder.readTree(Consts.TREE_SEGMENT_ID, probs);
    };
    constructor.readSkipFlag = function(miCol, miRow, blSz, decoder, probStore, c) {
        var ctx = 0;
        var availAbove = miRow > 0;
        var availLeft = miCol > c.getTileStart();
        var skipped = c.getSkippedBlockes();
        if (availAbove) 
            ctx += skipped[miRow - 1][miCol] ? 1 : 0;
        if (availLeft) 
            ctx += skipped[miRow][miCol - 1] ? 1 : 0;
        var probs = probStore.getSkipProbs();
        var ret = decoder.readBit(probs[ctx]) == 1;
        for (var i = 0; i < Consts.blH[blSz]; i++) {
            for (var j = 0; j < Consts.blW[blSz]; j++) {
                skipped[i + miRow][j + miCol] = ret;
            }
        }
        return ret;
    };
    prototype.isInter = function() {
        return false;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Residual = function(coefs) {
    this.coefs = coefs;
};
Residual = stjs.extend(Residual, null, [], function(constructor, prototype) {
    prototype.coefs = null;
    constructor.read = function(miCol, miRow, blSz, decoder, probStore, c, mode) {
        var coefs = Array(3);
        for (var pl = 0; pl < 3; pl++) {
            var subW = Residual.msb(stjs.trunc(Consts.blW[blSz] / c.getSubX())) - 2;
            var subH = Residual.msb(stjs.trunc(Consts.blH[blSz] / c.getSubY())) - 2;
            var uvBlSz = Residual.blk_size_lookup[subH][subW - subH + 1];
            var txSize = pl == 0 ? mode.getTxSize() : Residual.uvTxSize(c, mode.getTxSize(), blSz, uvBlSz);
            var step4x4 = 1 << txSize;
            var plBlSz = pl == 0 ? blSz : uvBlSz;
            var frameWPix = (c.getMiFrameWidth() << 3) >> c.getSubX();
            var frameHPix = (c.getMiFrameHeight() << 3) >> c.getSubY();
            var blX = (miCol << 3) >> c.getSubX();
            var blY = (miRow << 3) >> c.getSubY();
            coefs[pl] = Array(Consts.blH[plBlSz] * Consts.blW[plBlSz]);
            for (var y = 0, blkIdx = 0; y < Consts.blH[plBlSz]; y += step4x4) {
                for (var x = 0; x < Consts.blW[plBlSz]; x += step4x4 , blkIdx++) {
                    var posX = blX + (x << 2);
                    var posY = blY + (y << 2);
                    if (!mode.isSkip() && posX < frameWPix && posY < frameHPix) {
                        coefs[pl][blkIdx] = Residual.tokens(pl, posX, posY, txSize, blkIdx, mode.isInter(), decoder, probStore, c);
                    }
                }
            }
        }
        return new Residual(coefs);
    };
    constructor.msb = function(v) {
        v &= 255;
        if ((v & 240) != 0) {
            if ((v & 192) != 0) {
                return 6 | (v >> 7);
            } else {
                return 4 | (v >> 5);
            }
        } else {
            if ((v & 12) != 0) {
                return 2 | (v >> 3);
            } else {
                return v >> 1;
            }
        }
    };
    constructor.blk_size_lookup = [new Int32Array([Consts.BLOCK_INVALID, Consts.BLOCK_4X4, Consts.BLOCK_8X4]), new Int32Array([Consts.BLOCK_4X8, Consts.BLOCK_8X8, Consts.BLOCK_16X8]), new Int32Array([Consts.BLOCK_8X16, Consts.BLOCK_16X16, Consts.BLOCK_32X16]), new Int32Array([Consts.BLOCK_16X32, Consts.BLOCK_32X32, Consts.BLOCK_64X32]), new Int32Array([Consts.BLOCK_32X64, Consts.BLOCK_64X64, Consts.BLOCK_INVALID])];
    constructor.uvTxSize = function(c, txSize, blSz, uvBlSz) {
        if (blSz < Consts.BLOCK_8X8) 
            return Consts.TX_4X4;
        return Math.min(txSize, Consts.maxTxLookup[uvBlSz]);
    };
    constructor.tokens = function(plane, startX, startY, txSz, blockIdx, isInter, decoder, probStore, c) {
        var maxCoeff = 16 << (txSz << 1);
        var expectMoreCoefs = true;
        var scan = c.getScan(plane, txSz, blockIdx);
        var txType = c.getTxType(plane, txSz, blockIdx);
        var coefs = new Int32Array(maxCoeff);
        for (var cf = 0; cf < maxCoeff; cf++) {
            var band = (txSz == Consts.TX_4X4) ? Consts.coefband_4x4[cf] : Consts.coefband_8x8plus[cf];
            var pos = scan[cf];
            if (!expectMoreCoefs) {
                var moreCoefs = Residual.readMoreCoefs(plane, pos, txSz, startX, startY, txType, band, isInter, decoder, probStore, c);
                if (!moreCoefs) 
                    break;
            }
            var token = Residual.readToken(plane, pos, txSz, startX, startY, txType, band, isInter, decoder, probStore, c);
            if (token == Consts.ZERO_TOKEN) {
                expectMoreCoefs = true;
                coefs[pos] = 0;
            } else {
                var coef = Residual.readCoef(token, decoder, c);
                var sign = decoder.readBitEq();
                coefs[pos] = sign == 1 ? -coef : coef;
                expectMoreCoefs = false;
            }
        }
        return coefs;
    };
    constructor.readCoef = function(token, decoder, c) {
        var cat = Consts.extra_bits[token][0];
        var numExtra = Consts.extra_bits[token][1];
        var coef = Consts.extra_bits[token][2];
        if (token == Consts.DCT_VAL_CAT6) {
            for (var bit = 0; bit < c.getBitDepth() - 8; bit++) {
                var high_bit = decoder.readBit(255);
                coef += high_bit << (5 + c.getBitDepth() - bit);
            }
        }
        for (var bit = 0; bit < numExtra; bit++) {
            var coef_bit = decoder.readBit(Consts.cat_probs[cat][bit]);
            coef += coef_bit << (numExtra - 1 - bit);
        }
        return coef;
    };
    constructor.pareto = function(bin, prob) {
        if (bin < 2) {
            return prob;
        }
        var x = stjs.trunc((prob - 1) / 2);
        if ((prob & 1) != 0) 
            return Consts.PARETO_TABLE[x][bin - 2];
         else 
            return (Consts.PARETO_TABLE[x][bin - 2] + Consts.PARETO_TABLE[x + 1][bin - 2]) >> 1;
    };
    constructor.readToken = function(plane, coefi, txSz, posX, posY, txType, band, isInter, decoder, probStore, c) {
        var ctx = Residual.calcTokenContext(plane, coefi, txSz, posX, posY, txType, c);
        var probs = probStore.getCoefProbs();
        var prob0 = Residual.pareto(0, probs[txSz][plane > 0 ? 1 : 0][isInter ? 1 : 0][band][ctx][1]);
        var prob1 = Residual.pareto(1, probs[txSz][plane > 0 ? 1 : 0][isInter ? 1 : 0][band][ctx][2]);
        return decoder.readTree3(Consts.TOKEN_TREE, prob0, prob1);
    };
    constructor.readMoreCoefs = function(plane, coefi, txSz, posX, posY, txType, band, isInter, decoder, probStore, c) {
        var ctx = Residual.calcTokenContext(plane, coefi, txSz, posX, posY, txType, c);
        var probs = probStore.getCoefProbs();
        return decoder.readBit(probs[txSz][plane > 0 ? 1 : 0][isInter ? 1 : 0][band][ctx][0]) == 1;
    };
    constructor.calcTokenContext = function(plane, coefi, txSz, posX, posY, txType, c) {
        if (coefi == 0) {
            var aboveNonzeroContext = c.getAboveNonzeroContext();
            var leftNonzeroContext = c.getLeftNonzeroContext();
            var subX = plane > 0 ? c.getSubX() : 0;
            var subY = plane > 0 ? c.getSubY() : 0;
            var max4x = (c.getMiFrameWidth() << 1) >> subX;
            var max4y = (c.getMiFrameHeight() << 1) >> subY;
            var tx4 = 1 << txSz;
            var pos4x = posX >> 2;
            var pos4y = posY >> 2;
            var aboveNz = 0;
            var leftNz = 0;
            for (var i = 0; i < tx4; i++) {
                if (pos4x + i < max4x) 
                    aboveNz |= aboveNonzeroContext[plane][pos4x + i];
                if (pos4y + i < max4y) 
                    leftNz |= leftNonzeroContext[plane][pos4y + i];
            }
            return aboveNz + leftNz;
        } else {
            var abovePos = 0;
            var leftPos = 0;
            if (coefi != 0) {
                txSz += 2;
                var y = coefi >> txSz;
                var x = coefi & (63 >> (6 - txSz));
                abovePos = ((y - 1) << txSz) + x;
                leftPos = (y << txSz) + x - 1;
                if (txType == Consts.DCT_ADST || x == 0) {
                    leftPos = abovePos;
                }
                if (txType == Consts.ADST_DCT || y == 0) {
                    abovePos = leftPos;
                }
            }
            var tokenCache = c.getTokenCache();
            return (1 + tokenCache[abovePos] + tokenCache[leftPos]) >> 1;
        }
    };
}, {coefs: "Array", blk_size_lookup: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv420pToRgb = function() {};
Yuv420pToRgb = stjs.extend(Yuv420pToRgb, null, [Transform], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        var yh = src.getPlaneData(0);
        var uh = src.getPlaneData(1);
        var vh = src.getPlaneData(2);
        var yl = null;
        var ul = null;
        var vl = null;
        var low = src.getLowBits();
        if (low != null) {
            yl = low[0];
            ul = low[1];
            vl = low[2];
        }
        var data = dst.getPlaneData(0);
        var lowBits = dst.getLowBits() == null ? null : dst.getLowBits()[0];
        var hbd = src.isHiBD() && dst.isHiBD();
        var lowBitsNumSrc = src.getLowBitsNum();
        var lowBitsNumDst = dst.getLowBitsNum();
        var offLuma = 0, offChroma = 0;
        var stride = dst.getWidth();
        for (var i = 0; i < (dst.getHeight() >> 1); i++) {
            for (var k = 0; k < (dst.getWidth() >> 1); k++) {
                var j = k << 1;
                if (hbd) {
                    Yuv420pToRgb.YUV420pToRGBH2H(yh[offLuma + j], yl[offLuma + j], uh[offChroma], ul[offChroma], vh[offChroma], vl[offChroma], lowBitsNumSrc, data, lowBits, lowBitsNumDst, (offLuma + j) * 3);
                    Yuv420pToRgb.YUV420pToRGBH2H(yh[offLuma + j + 1], yl[offLuma + j + 1], uh[offChroma], ul[offChroma], vh[offChroma], vl[offChroma], lowBitsNumSrc, data, lowBits, lowBitsNumDst, (offLuma + j + 1) * 3);
                    Yuv420pToRgb.YUV420pToRGBH2H(yh[offLuma + j + stride], yl[offLuma + j + stride], uh[offChroma], ul[offChroma], vh[offChroma], vl[offChroma], lowBitsNumSrc, data, lowBits, lowBitsNumDst, (offLuma + j + stride) * 3);
                    Yuv420pToRgb.YUV420pToRGBH2H(yh[offLuma + j + stride + 1], yl[offLuma + j + stride + 1], uh[offChroma], ul[offChroma], vh[offChroma], vl[offChroma], lowBitsNumSrc, data, lowBits, lowBitsNumDst, (offLuma + j + stride + 1) * 3);
                } else {
                    Yuv420pToRgb.YUV420pToRGBN2N(yh[offLuma + j], uh[offChroma], vh[offChroma], data, (offLuma + j) * 3);
                    Yuv420pToRgb.YUV420pToRGBN2N(yh[offLuma + j + 1], uh[offChroma], vh[offChroma], data, (offLuma + j + 1) * 3);
                    Yuv420pToRgb.YUV420pToRGBN2N(yh[offLuma + j + stride], uh[offChroma], vh[offChroma], data, (offLuma + j + stride) * 3);
                    Yuv420pToRgb.YUV420pToRGBN2N(yh[offLuma + j + stride + 1], uh[offChroma], vh[offChroma], data, (offLuma + j + stride + 1) * 3);
                }
                ++offChroma;
            }
            if ((dst.getWidth() & 1) != 0) {
                var j = dst.getWidth() - 1;
                Yuv420pToRgb.YUV420pToRGBN2N(yh[offLuma + j], uh[offChroma], vh[offChroma], data, (offLuma + j) * 3);
                Yuv420pToRgb.YUV420pToRGBN2N(yh[offLuma + j + stride], uh[offChroma], vh[offChroma], data, (offLuma + j + stride) * 3);
                ++offChroma;
            }
            offLuma += 2 * stride;
        }
        if ((dst.getHeight() & 1) != 0) {
            for (var k = 0; k < (dst.getWidth() >> 1); k++) {
                var j = k << 1;
                Yuv420pToRgb.YUV420pToRGBN2N(yh[offLuma + j], uh[offChroma], vh[offChroma], data, (offLuma + j) * 3);
                Yuv420pToRgb.YUV420pToRGBN2N(yh[offLuma + j + 1], uh[offChroma], vh[offChroma], data, (offLuma + j + 1) * 3);
                ++offChroma;
            }
            if ((dst.getWidth() & 1) != 0) {
                var j = dst.getWidth() - 1;
                Yuv420pToRgb.YUV420pToRGBN2N(yh[offLuma + j], uh[offChroma], vh[offChroma], data, (offLuma + j) * 3);
                ++offChroma;
            }
        }
    };
    constructor.YUV420pToRGBN2N = function(y, u, v, data, off) {
        var c = y + 112;
        var r = (298 * c + 409 * v + 128) >> 8;
        var g = (298 * c - 100 * u - 208 * v + 128) >> 8;
        var b = (298 * c + 516 * u + 128) >> 8;
        data[off] = ((MathUtil.clip(r, 0, 255) - 128) << 24 >> 24);
        data[off + 1] = ((MathUtil.clip(g, 0, 255) - 128) << 24 >> 24);
        data[off + 2] = ((MathUtil.clip(b, 0, 255) - 128) << 24 >> 24);
    };
    constructor.YUV420pToRGBH2H = function(yh, yl, uh, ul, vh, vl, nlbi, data, lowBits, nlbo, off) {
        var clipMax = ((1 << nlbo) << 8) - 1;
        var round = (1 << nlbo) >> 1;
        var c = ((yh + 128) << nlbi) + yl - 64;
        var d = ((uh + 128) << nlbi) + ul - 512;
        var e = ((vh + 128) << nlbi) + vl - 512;
        var r = MathUtil.clip((298 * c + 409 * e + 128) >> 8, 0, clipMax);
        var g = MathUtil.clip((298 * c - 100 * d - 208 * e + 128) >> 8, 0, clipMax);
        var b = MathUtil.clip((298 * c + 516 * d + 128) >> 8, 0, clipMax);
        var valR = MathUtil.clip((r + round) >> nlbo, 0, 255);
        data[off] = ((valR - 128) << 24 >> 24);
        lowBits[off] = ((r - (valR << nlbo)) << 24 >> 24);
        var valG = MathUtil.clip((g + round) >> nlbo, 0, 255);
        data[off + 1] = ((valG - 128) << 24 >> 24);
        lowBits[off + 1] = ((g - (valG << nlbo)) << 24 >> 24);
        var valB = MathUtil.clip((b + round) >> nlbo, 0, 255);
        data[off + 2] = ((valB - 128) << 24 >> 24);
        lowBits[off + 2] = ((b - (valB << nlbo)) << 24 >> 24);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv422pToYuv420p = function() {};
Yuv422pToYuv420p = stjs.extend(Yuv422pToYuv420p, null, [Transform], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        var lumaSize = src.getWidth() * src.getHeight();
        System.arraycopy(src.getPlaneData(0), 0, dst.getPlaneData(0), 0, lumaSize);
        this.copyAvg(src.getPlaneData(1), dst.getPlaneData(1), src.getPlaneWidth(1), src.getPlaneHeight(1));
        this.copyAvg(src.getPlaneData(2), dst.getPlaneData(2), src.getPlaneWidth(2), src.getPlaneHeight(2));
    };
    prototype.copyAvg = function(src, dst, width, height) {
        var offSrc = 0, offDst = 0;
        for (var y = 0; y < stjs.trunc(height / 2); y++) {
            for (var x = 0; x < width; x++ , offDst++ , offSrc++) {
                dst[offDst] = (((src[offSrc] + src[offSrc + width] + 1) >> 1) << 24 >> 24);
            }
            offSrc += width;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Transforms Picture in RGB colorspace ( one plane, 3 integers per pixel ) to
 *  Yuv420 colorspace output picture ( 3 planes, luma - 0th plane, cb - 1th
 *  plane, cr - 2nd plane; cb and cr planes are half width and half haight )
 *  
 *  TODO: implement jpeg colorspace instead of NTSC
 *  
 *  @author The JCodec project
 *  
 */
var RgbToYuv420j = function() {};
RgbToYuv420j = stjs.extend(RgbToYuv420j, null, [Transform], function(constructor, prototype) {
    prototype.transform = function(img, dst) {
        var y = img.getData()[0];
        var dstData = dst.getData();
        var out = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(3);
        });
        var offChr = 0, offLuma = 0, offSrc = 0, strideSrc = img.getWidth() * 3, strideDst = dst.getWidth();
        for (var i = 0; i < img.getHeight() >> 1; i++) {
            for (var j = 0; j < img.getWidth() >> 1; j++) {
                dstData[1][offChr] = 0;
                dstData[2][offChr] = 0;
                RgbToYuv420j.rgb2yuv(y[offSrc], y[offSrc + 1], y[offSrc + 2], out[0]);
                dstData[0][offLuma] = (out[0][0] << 24 >> 24);
                RgbToYuv420j.rgb2yuv(y[offSrc + strideSrc], y[offSrc + strideSrc + 1], y[offSrc + strideSrc + 2], out[1]);
                dstData[0][offLuma + strideDst] = (out[1][0] << 24 >> 24);
                ++offLuma;
                RgbToYuv420j.rgb2yuv(y[offSrc + 3], y[offSrc + 4], y[offSrc + 5], out[2]);
                dstData[0][offLuma] = (out[2][0] << 24 >> 24);
                RgbToYuv420j.rgb2yuv(y[offSrc + strideSrc + 3], y[offSrc + strideSrc + 4], y[offSrc + strideSrc + 5], out[3]);
                dstData[0][offLuma + strideDst] = (out[3][0] << 24 >> 24);
                ++offLuma;
                dstData[1][offChr] = (((out[0][1] + out[1][1] + out[2][1] + out[3][1] + 2) >> 2) << 24 >> 24);
                dstData[2][offChr] = (((out[0][2] + out[1][2] + out[2][2] + out[3][2] + 2) >> 2) << 24 >> 24);
                ++offChr;
                offSrc += 6;
            }
            offLuma += strideDst;
            offSrc += strideSrc;
        }
    };
    constructor.rgb2yuv = function(r, g, b, out) {
        var rS = r + 128;
        var gS = g + 128;
        var bS = b + 128;
        var y = 77 * rS + 150 * gS + 15 * bS;
        var u = -43 * rS - 85 * gS + 128 * bS;
        var v = 128 * rS - 107 * gS - 21 * bS;
        y = (y + 128) >> 8;
        u = (u + 128) >> 8;
        v = (v + 128) >> 8;
        out[0] = MathUtil.clip(y - 128, -128, 127);
        out[1] = MathUtil.clip(u, -128, 127);
        out[2] = MathUtil.clip(v, -128, 127);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv420jToRgb = function() {};
Yuv420jToRgb = stjs.extend(Yuv420jToRgb, null, [Transform], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        var offLuma = 0, offChroma = 0;
        var stride = dst.getWidth();
        for (var i = 0; i < (dst.getHeight() >> 1); i++) {
            for (var k = 0; k < (dst.getWidth() >> 1); k++) {
                var j = k << 1;
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j + 1], u[offChroma], v[offChroma], data, (offLuma + j + 1) * 3);
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j + stride], u[offChroma], v[offChroma], data, (offLuma + j + stride) * 3);
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j + stride + 1], u[offChroma], v[offChroma], data, (offLuma + j + stride + 1) * 3);
                ++offChroma;
            }
            if ((dst.getWidth() & 1) != 0) {
                var j = dst.getWidth() - 1;
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j + stride], u[offChroma], v[offChroma], data, (offLuma + j + stride) * 3);
                ++offChroma;
            }
            offLuma += 2 * stride;
        }
        if ((dst.getHeight() & 1) != 0) {
            for (var k = 0; k < (dst.getWidth() >> 1); k++) {
                var j = k << 1;
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j + 1], u[offChroma], v[offChroma], data, (offLuma + j + 1) * 3);
                ++offChroma;
            }
            if ((dst.getWidth() & 1) != 0) {
                var j = dst.getWidth() - 1;
                Yuv420jToRgb.YUVJtoRGB(y[offLuma + j], u[offChroma], v[offChroma], data, (offLuma + j) * 3);
                ++offChroma;
            }
        }
    };
    constructor.SCALEBITS = 10;
    constructor.ONE_HALF = (1 << (Yuv420jToRgb.SCALEBITS - 1));
    constructor.FIX = function(x) {
        return (stjs.trunc(((x) * (1 << Yuv420jToRgb.SCALEBITS) + 0.5)));
    };
    constructor.FIX_0_71414 = Yuv420jToRgb.FIX(0.71414);
    constructor.FIX_1_772 = Yuv420jToRgb.FIX(1.772);
    constructor._FIX_0_34414 = -Yuv420jToRgb.FIX(0.34414);
    constructor.FIX_1_402 = Yuv420jToRgb.FIX(1.402);
    constructor.YUVJtoRGB = function(y, cb, cr, data, off) {
        var y_ = (y + 128) << Yuv420jToRgb.SCALEBITS;
        var add_r = Yuv420jToRgb.FIX_1_402 * cr + Yuv420jToRgb.ONE_HALF;
        var add_g = Yuv420jToRgb._FIX_0_34414 * cb - Yuv420jToRgb.FIX_0_71414 * cr + Yuv420jToRgb.ONE_HALF;
        var add_b = Yuv420jToRgb.FIX_1_772 * cb + Yuv420jToRgb.ONE_HALF;
        var r = (y_ + add_r) >> Yuv420jToRgb.SCALEBITS;
        var g = (y_ + add_g) >> Yuv420jToRgb.SCALEBITS;
        var b = (y_ + add_b) >> Yuv420jToRgb.SCALEBITS;
        data[off] = (MathUtil.clip(r - 128, -128, 127) << 24 >> 24);
        data[off + 1] = (MathUtil.clip(g - 128, -128, 127) << 24 >> 24);
        data[off + 2] = (MathUtil.clip(b - 128, -128, 127) << 24 >> 24);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Transforms Picture in RGB colorspace ( one plane, 3 integers per pixel ) to
 *  Yuv420 colorspace output picture ( 3 planes, luma - 0th plane, cb - 1th
 *  plane, cr - 2nd plane; cb and cr planes are half width and half haight )
 *  
 *  TODO: implement jpeg colorspace instead of NTSC
 *  
 *  @author The JCodec project
 *  
 */
var RgbToYuv420p = function() {};
RgbToYuv420p = stjs.extend(RgbToYuv420p, null, [Transform], function(constructor, prototype) {
    prototype.transform = function(img, dst) {
        var y = img.getData()[0];
        var dstData = dst.getData();
        var out = Array.apply(null, Array(4)).map(function() {
            return new Int8Array(3);
        });
        var offChr = 0, offLuma = 0, offSrc = 0, strideSrc = img.getWidth() * 3, strideDst = dst.getWidth();
        for (var i = 0; i < img.getHeight() >> 1; i++) {
            for (var j = 0; j < img.getWidth() >> 1; j++) {
                dstData[1][offChr] = 0;
                dstData[2][offChr] = 0;
                RgbToYuv420p.rgb2yuv(y[offSrc], y[offSrc + 1], y[offSrc + 2], out[0]);
                dstData[0][offLuma] = out[0][0];
                RgbToYuv420p.rgb2yuv(y[offSrc + strideSrc], y[offSrc + strideSrc + 1], y[offSrc + strideSrc + 2], out[1]);
                dstData[0][offLuma + strideDst] = out[1][0];
                ++offLuma;
                RgbToYuv420p.rgb2yuv(y[offSrc + 3], y[offSrc + 4], y[offSrc + 5], out[2]);
                dstData[0][offLuma] = out[2][0];
                RgbToYuv420p.rgb2yuv(y[offSrc + strideSrc + 3], y[offSrc + strideSrc + 4], y[offSrc + strideSrc + 5], out[3]);
                dstData[0][offLuma + strideDst] = out[3][0];
                ++offLuma;
                dstData[1][offChr] = (((out[0][1] + out[1][1] + out[2][1] + out[3][1] + 2) >> 2) << 24 >> 24);
                dstData[2][offChr] = (((out[0][2] + out[1][2] + out[2][2] + out[3][2] + 2) >> 2) << 24 >> 24);
                ++offChr;
                offSrc += 6;
            }
            offLuma += strideDst;
            offSrc += strideSrc;
        }
    };
    constructor.rgb2yuv = function(r, g, b, out) {
        var rS = r + 128;
        var gS = g + 128;
        var bS = b + 128;
        var y = 66 * rS + 129 * gS + 25 * bS;
        var u = -38 * rS - 74 * gS + 112 * bS;
        var v = 112 * rS - 94 * gS - 18 * bS;
        y = (y + 128) >> 8;
        u = (u + 128) >> 8;
        v = (v + 128) >> 8;
        out[0] = (MathUtil.clip(y - 112, -128, 127) << 24 >> 24);
        out[1] = (MathUtil.clip(u, -128, 127) << 24 >> 24);
        out[2] = (MathUtil.clip(v, -128, 127) << 24 >> 24);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv422pToRgb = function() {};
Yuv422pToRgb = stjs.extend(Yuv422pToRgb, null, [Transform], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        var offLuma = 0, offChroma = 0;
        for (var i = 0; i < dst.getHeight(); i++) {
            for (var j = 0; j < dst.getWidth(); j += 2) {
                Yuv422pToRgb.YUV444toRGB888(y[offLuma], u[offChroma], v[offChroma], data, offLuma * 3);
                Yuv422pToRgb.YUV444toRGB888(y[offLuma + 1], u[offChroma], v[offChroma], data, (offLuma + 1) * 3);
                offLuma += 2;
                ++offChroma;
            }
        }
    };
    constructor.YUV444toRGB888 = function(y, u, v, data, off) {
        var c = y + 112;
        var d = u;
        var e = v;
        var r = (298 * c + 409 * e + 128) >> 8;
        var g = (298 * c - 100 * d - 208 * e + 128) >> 8;
        var b = (298 * c + 516 * d + 128) >> 8;
        data[off] = ((MathUtil.clip(r, 0, 255) - 128) << 24 >> 24);
        data[off + 1] = ((MathUtil.clip(g, 0, 255) - 128) << 24 >> 24);
        data[off + 2] = ((MathUtil.clip(b, 0, 255) - 128) << 24 >> 24);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author Stanislav Vitvitskyy
 */
var Yuv444jToYuv420j = function() {};
Yuv444jToYuv420j = stjs.extend(Yuv444jToYuv420j, null, [Transform], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        var size = src.getWidth() * src.getHeight();
        System.arraycopy(src.getPlaneData(0), 0, dst.getPlaneData(0), 0, size);
        for (var plane = 1; plane < 3; plane++) {
            var srcPl = src.getPlaneData(plane);
            var dstPl = dst.getPlaneData(plane);
            var srcStride = src.getPlaneWidth(plane);
            for (var y = 0, srcOff = 0, dstOff = 0; y < src.getHeight(); y += 2 , srcOff += srcStride) {
                for (var x = 0; x < src.getWidth(); x += 2 , srcOff += 2 , dstOff++) {
                    dstPl[dstOff] = (((srcPl[srcOff] + srcPl[srcOff + 1] + srcPl[srcOff + srcStride] + srcPl[srcOff + srcStride + 1] + 2) >> 2) << 24 >> 24);
                }
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv420pToYuv422p = function() {};
Yuv420pToYuv422p = stjs.extend(Yuv420pToYuv422p, null, [Transform], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        Yuv420pToYuv422p.copy(src.getPlaneData(0), dst.getPlaneData(0), src.getWidth(), dst.getWidth(), dst.getHeight());
        Yuv420pToYuv422p._copy(src.getPlaneData(1), dst.getPlaneData(1), 0, 0, 1, 2, src.getWidth() >> 1, dst.getWidth() >> 1, src.getHeight() >> 1, dst.getHeight());
        Yuv420pToYuv422p._copy(src.getPlaneData(1), dst.getPlaneData(1), 0, 1, 1, 2, src.getWidth() >> 1, dst.getWidth() >> 1, src.getHeight() >> 1, dst.getHeight());
        Yuv420pToYuv422p._copy(src.getPlaneData(2), dst.getPlaneData(2), 0, 0, 1, 2, src.getWidth() >> 1, dst.getWidth() >> 1, src.getHeight() >> 1, dst.getHeight());
        Yuv420pToYuv422p._copy(src.getPlaneData(2), dst.getPlaneData(2), 0, 1, 1, 2, src.getWidth() >> 1, dst.getWidth() >> 1, src.getHeight() >> 1, dst.getHeight());
    };
    constructor._copy = function(src, dest, offX, offY, stepX, stepY, strideSrc, strideDest, heightSrc, heightDst) {
        var offD = offX + offY * strideDest, srcOff = 0;
        for (var i = 0; i < heightSrc; i++) {
            for (var j = 0; j < strideSrc; j++) {
                dest[offD] = src[srcOff++];
                offD += stepX;
            }
            var lastOff = offD - stepX;
            for (var j = strideSrc * stepX; j < strideDest; j += stepX) {
                dest[offD] = dest[lastOff];
                offD += stepX;
            }
            offD += (stepY - 1) * strideDest;
        }
        var lastLine = offD - stepY * strideDest;
        for (var i = heightSrc * stepY; i < heightDst; i += stepY) {
            for (var j = 0; j < strideDest; j += stepX) {
                dest[offD] = dest[lastLine + j];
                offD += stepX;
            }
            offD += (stepY - 1) * strideDest;
        }
    };
    constructor.copy = function(src, dest, srcWidth, dstWidth, dstHeight) {
        var height = stjs.trunc(src.length / srcWidth);
        var dstOff = 0, srcOff = 0;
        for (var i = 0; i < height; i++) {
            for (var j = 0; j < srcWidth; j++) {
                dest[dstOff++] = src[srcOff++];
            }
            for (var j = srcWidth; j < dstWidth; j++) 
                dest[dstOff++] = dest[srcWidth - 1];
        }
        var lastLine = (height - 1) * dstWidth;
        for (var i = height; i < dstHeight; i++) {
            for (var j = 0; j < dstWidth; j++) {
                dest[dstOff++] = dest[lastLine + j];
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A fork that splits the channels into different streams
 *  
 *  @author The JCodec project
 *  
 */
var ChannelSplit = function(format) {
    this.format = format;
};
ChannelSplit = stjs.extend(ChannelSplit, null, [AudioFilter], function(constructor, prototype) {
    prototype.format = null;
    prototype.filter = function(_in, inPos, out) {
        if (_in.length != 1) {
             throw new IllegalArgumentException("Channel split invoked on more then one input");
        }
        if (out.length != this.format.getChannels()) {
             throw new IllegalArgumentException("Channel split must be supplied with " + this.format.getChannels() + " output buffers to hold the channels.");
        }
        var in0 = _in[0];
        var outSampleCount = stjs.trunc(in0.remaining() / out.length);
        for (var i = 0; i < out.length; i++) {
            if (out[i].remaining() < outSampleCount) 
                 throw new IllegalArgumentException("Supplied buffer for " + i + "th channel doesn't have sufficient space to put the samples ( required: " + outSampleCount + ", actual: " + out[i].remaining() + ")");
        }
         while (in0.remaining() >= this.format.getChannels()){
            for (var i = 0; i < out.length; i++) {
                out[i].put(in0.get());
            }
        }
    };
    prototype.getDelay = function() {
        return 0;
    };
    prototype.getNInputs = function() {
        return 1;
    };
    prototype.getNOutputs = function() {
        return this.format.getChannels();
    };
}, {format: "AudioFormat"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A class with many audio helper functions
 *  
 *  @author The JCodec project
 *  
 */
var Audio = function() {};
Audio = stjs.extend(Audio, null, [], function(constructor, prototype) {
    constructor.transfer = function(src, sink) {
        Audio.filterTransfer(src, new Audio.DummyFilter(1), sink);
    };
    constructor.filterTransfer = function(src, filter, sink) {
        if (filter.getNInputs() != 1) 
             throw new IllegalArgumentException("Audio filter has # inputs != 1");
        if (filter.getNOutputs() != 1) 
             throw new IllegalArgumentException("Audio filter has # outputs != 1");
        if (filter.getDelay() != 0) 
             throw new IllegalArgumentException("Audio filter has delay");
        var ins = [FloatBuffer.allocate(4096)];
        var outs = [FloatBuffer.allocate(8192)];
        var pos = Array(1);
         while (src.readFloat(ins[0]) != -1){
            ins[0].flip();
            filter.filter(ins, pos, outs);
            pos[0] += ins[0].position();
            Audio.rotate(ins[0]);
            outs[0].flip();
            sink.writeFloat(outs[0]);
            outs[0].clear();
        }
    };
    constructor.print = function(buf) {
        var dup = buf.duplicate();
         while (dup.hasRemaining())
            System.out.print(String.format("%.3f,", dup.get()));
        System.out.println();
    };
    constructor.rotate = function(buf) {
        var pos;
        for (pos = 0; buf.hasRemaining(); pos++) 
            buf.put(pos, buf.get());
        buf.position(pos);
        buf.limit(buf.capacity());
    };
    constructor.DummyFilter = function(nInputs) {
        this.nInputs = nInputs;
    };
    constructor.DummyFilter = stjs.extend(constructor.DummyFilter, null, [AudioFilter], function(constructor, prototype) {
        prototype.nInputs = 0;
        prototype.filter = function(_in, inPos, out) {
            for (var i = 0; i < _in.length; i++) {
                if (out[i].remaining() >= _in[i].remaining()) 
                    out[i].put(_in[i]);
                 else {
                    var duplicate = _in[i].duplicate();
                    duplicate.limit(_in[i].position() + out[i].remaining());
                    out[i].put(duplicate);
                }
            }
        };
        prototype.getDelay = function() {
            return 0;
        };
        prototype.getNInputs = function() {
            return this.nInputs;
        };
        prototype.getNOutputs = function() {
            return this.nInputs;
        };
    }, {}, {});
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Base for all filters that use convolution with kernel
 *  
 *  @author The JCodec project
 *  
 */
var ConvolutionFilter = function() {};
ConvolutionFilter = stjs.extend(ConvolutionFilter, null, [AudioFilter], function(constructor, prototype) {
    prototype.kernel = null;
    prototype.buildKernel = function() {};
    prototype.filter = function(_in, pos, out) {
        if (_in.length != 1) 
             throw new IllegalArgumentException(this.getClass().getName() + " filter is designed to work only on one input");
        if (out.length != 1) 
             throw new IllegalArgumentException(this.getClass().getName() + " filter is designed to work only on one output");
        var in0 = _in[0];
        var out0 = out[0];
        if (this.kernel == null) {
            this.kernel = this.buildKernel();
        }
        if (out0.remaining() < in0.remaining() - this.kernel.length) 
             throw new IllegalArgumentException("Output buffer is too small");
        if (in0.remaining() <= this.kernel.length) 
             throw new IllegalArgumentException("Input buffer should contain > kernel lenght (" + this.kernel.length + ") samples.");
        var halfKernel = stjs.trunc(this.kernel.length / 2);
        var i;
        for (i = in0.position() + halfKernel; i < in0.limit() - halfKernel; i++) {
            var result = 0;
            for (var j = 0; j < this.kernel.length; j++) {
                result += this.kernel[j] * in0.get(i + j - halfKernel);
            }
            out0.put(result);
        }
        in0.position(i - halfKernel);
    };
    prototype.getDelay = function() {
        if (this.kernel == null) {
            this.kernel = this.buildKernel();
        }
        return stjs.trunc(this.kernel.length / 2);
    };
    prototype.getNInputs = function() {
        return 1;
    };
    prototype.getNOutputs = function() {
        return 1;
    };
}, {kernel: "Float64Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Lanczos resampler
 *  
 *  @author The JCodec project
 *  
 */
var LanczosInterpolator = function(fromRate, toRate) {
    this.rateStep = fromRate / toRate;
};
LanczosInterpolator = stjs.extend(LanczosInterpolator, null, [AudioFilter], function(constructor, prototype) {
    constructor.lanczos = function(x, a) {
        return x < -a ? 0 : x > a ? 0 : (a * Math.sin(Math.PI * x) * Math.sin(Math.PI * x / a)) / (Math.PI * Math.PI * x * x);
    };
    prototype.rateStep = 0.0;
    prototype.filter = function(_in, pos, out) {
        if (_in.length != 1) 
             throw new IllegalArgumentException(this.getClass().getName() + " filter is designed to work only on one input");
        if (out.length != 1) 
             throw new IllegalArgumentException(this.getClass().getName() + " filter is designed to work only on one output");
        var in0 = _in[0];
        var out0 = out[0];
        if (out0.remaining() < (in0.remaining() - 6) / this.rateStep) 
             throw new IllegalArgumentException("Output buffer is too small");
        if (in0.remaining() <= 6) 
             throw new IllegalArgumentException("Input buffer should contain > 6 samples.");
        for (var outSample = 0; ; outSample++) {
            var inSample = 3 + outSample * this.rateStep + Math.ceil(pos[0] / this.rateStep) * this.rateStep - pos[0];
            var p0i = stjs.trunc(Math.floor(inSample));
            var q0i = stjs.trunc(Math.ceil(inSample));
            if (p0i >= in0.limit() - 3) {
                in0.position(p0i - 3);
                break;
            }
            var p0d = p0i - inSample;
            if (p0d < -0.001) {
                var q0d = q0i - inSample;
                var p0c = LanczosInterpolator.lanczos(p0d, 3);
                var q0c = LanczosInterpolator.lanczos(q0d, 3);
                var p1c = LanczosInterpolator.lanczos(p0d - 1, 3);
                var q1c = LanczosInterpolator.lanczos(q0d + 1, 3);
                var p2c = LanczosInterpolator.lanczos(p0d - 2, 3);
                var q2c = LanczosInterpolator.lanczos(q0d + 2, 3);
                var factor = 1.0 / (p0c + p1c + p2c + q0c + q1c + q2c);
                out0.put(((in0.get(q0i) * q0c + in0.get(q0i + 1) * q1c + in0.get(q0i + 2) * q2c + in0.get(p0i) * p0c + in0.get(p0i - 1) * p1c + in0.get(p0i - 2) * p2c) * factor));
            } else {
                out0.put(in0.get(p0i));
            }
        }
    };
    prototype.getDelay = function() {
        return 3;
    };
    prototype.getNInputs = function() {
        return 1;
    };
    prototype.getNOutputs = function() {
        return 1;
    };
}, {}, {});
var BaseOutputStream = function() {
    OutputStream.call(this);
};
BaseOutputStream = stjs.extend(BaseOutputStream, OutputStream, [], function(constructor, prototype) {
    prototype.writeByte = function(b) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Binary ariphmetic encoder
 *  
 *  Half-way to MQ Coder
 *  
 *  @author The JCodec project
 *  
 */
var MQEncoder = function(out) {
    this.range = 32768;
    this.offset = 0;
    this.bitsToCode = 12;
    this.out = out;
};
MQEncoder = stjs.extend(MQEncoder, null, [], function(constructor, prototype) {
    constructor.CARRY_MASK = (1 << 27);
    prototype.range = 0;
    prototype.offset = 0;
    prototype.bitsToCode = 0;
    prototype.bytesOutput = 0;
    prototype.byteToGo = 0;
    prototype.out = null;
    /**
     *  Encodes one symbol either 0 or 1
     *  
     *  @param symbol
     *  @throws IOException
     */
    prototype.encode = function(symbol, cm) {
        var rangeLps = MQConst.pLps[cm.getState()];
        if (symbol == cm.getMps()) {
            this.range -= rangeLps;
            this.offset += rangeLps;
            if (this.range < 32768) {
                 while (this.range < 32768)
                    this.renormalize();
                cm.setState(MQConst.transitMPS[cm.getState()]);
            }
        } else {
            this.range = rangeLps;
             while (this.range < 32768)
                this.renormalize();
            if (MQConst.mpsSwitch[cm.getState()] != 0) 
                cm.setMps(1 - cm.getMps());
            cm.setState(MQConst.transitLPS[cm.getState()]);
        }
    };
    prototype.finish = function() {
        this.finalizeValue();
        this.offset <<= this.bitsToCode;
        var bitsToOutput = 12 - this.bitsToCode;
        this.outputByte();
        bitsToOutput -= this.bitsToCode;
        if (bitsToOutput > 0) {
            this.offset <<= this.bitsToCode;
            this.outputByte();
        }
        this.out.write(this.byteToGo);
    };
    prototype.finalizeValue = function() {
        var halfBit = this.offset & 32768;
        this.offset &= -65536;
        if (halfBit == 0) {
            this.offset |= 32768;
        } else {
            this.offset += 65536;
        }
    };
    prototype.renormalize = function() {
        this.offset <<= 1;
        this.range <<= 1;
        this.range &= 65535;
        --this.bitsToCode;
        if (this.bitsToCode == 0) 
            this.outputByte();
    };
    prototype.outputByte = function() {
        if (this.bytesOutput == 0) 
            this.outputByteNoStuffing();
         else {
            if (this.byteToGo == 255) 
                this.outputByteWithStuffing();
             else {
                if ((this.offset & MQEncoder.CARRY_MASK) != 0) {
                    ++this.byteToGo;
                    this.offset &= 134217727;
                    if (this.byteToGo == 255) 
                        this.outputByteWithStuffing();
                     else 
                        this.outputByteNoStuffing();
                } else 
                    this.outputByteNoStuffing();
            }
        }
    };
    prototype.outputByteWithStuffing = function() {
        this.bitsToCode = 7;
        if (this.bytesOutput > 0) {
            this.out.write(this.byteToGo);
        }
        this.byteToGo = (this.offset >> 20) & 255;
        this.offset &= 1048575;
        ++this.bytesOutput;
    };
    prototype.outputByteNoStuffing = function() {
        this.bitsToCode = 8;
        if (this.bytesOutput > 0) {
            this.out.write(this.byteToGo);
        }
        this.byteToGo = (this.offset >> 19) & 255;
        this.offset &= 524287;
        ++this.bytesOutput;
    };
}, {out: "OutputStream"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  Binary ariphmetic decoder
 *  
 *  Half-way to MQ Coder
 *  
 *  @author The JCodec project
 */
var MQDecoder = function(is) {
    this.is = is;
    this.range = 32768;
    this.value = 0;
    this.fetchByte();
    this.value <<= 8;
    this.fetchByte();
    this.value <<= (this.availableBits - 1);
    this.availableBits = 1;
};
MQDecoder = stjs.extend(MQDecoder, null, [], function(constructor, prototype) {
    prototype.range = 0;
    prototype.value = 0;
    prototype.availableBits = 0;
    prototype.lastByte = 0;
    prototype.decodedBytes = 0;
    prototype.is = null;
    prototype.decode = function(cm) {
        var rangeLps = MQConst.pLps[cm.getState()];
        var decoded;
        if (this.value > rangeLps) {
            this.range -= rangeLps;
            this.value -= rangeLps;
            if (this.range < 32768) {
                 while (this.range < 32768)
                    this.renormalize();
                cm.setState(MQConst.transitMPS[cm.getState()]);
            }
            decoded = cm.getMps();
        } else {
            this.range = rangeLps;
             while (this.range < 32768)
                this.renormalize();
            if (MQConst.mpsSwitch[cm.getState()] != 0) 
                cm.setMps(1 - cm.getMps());
            cm.setState(MQConst.transitLPS[cm.getState()]);
            decoded = 1 - cm.getMps();
        }
        return decoded;
    };
    prototype.fetchByte = function() {
        this.availableBits = 8;
        if (this.decodedBytes > 0 && this.lastByte == 255) {
            this.availableBits = 7;
        }
        this.lastByte = this.is.read();
        var shiftCarry = 8 - this.availableBits;
        this.value += (this.lastByte << shiftCarry);
        ++this.decodedBytes;
    };
    prototype.renormalize = function() {
        this.value <<= 1;
        this.range <<= 1;
        this.range &= 65535;
        --this.availableBits;
        if (this.availableBits == 0) 
            this.fetchByte();
    };
}, {is: "InputStream"}, {});
/**
 *  Static convenience methods that help a method or constructor check whether it was invoked
 *  correctly (whether its <i>preconditions</i> have been met). These methods generally accept a
 *  {@code boolean} expression which is expected to be {@code true} (or in the case of {@code
 *  checkNotNull}, an object reference which is expected to be non-null). When {@code false} (or
 *  {@code null}) is passed instead, the {@code Preconditions} method throws an unchecked exception,
 *  which helps the calling method communicate to <i>its</i> caller that <i>that</i> caller has made
 *  a mistake. Example: <pre>   {@code
 * 
 *    /**
 *     * Returns the positive square root of the given value.
 *     *
 *     * @throws IllegalArgumentException if the value is negative
 *     *}{@code /
 *    public static double sqrt(double value) {
 *      Preconditions.checkArgument(value >= 0.0, "negative value: %s", value);
 *      // calculate the square root
 *    }
 * 
 *    void exampleBadCaller() {
 *      double d = sqrt(-1.0);
 *    }}</pre>
 * 
 *  In this example, {@code checkArgument} throws an {@code IllegalArgumentException} to indicate
 *  that {@code exampleBadCaller} made an error in <i>its</i> call to {@code sqrt}.
 * 
 *  <h3>Warning about performance</h3>
 * 
 *  <p>The goal of this class is to improve readability of code, but in some circumstances this may
 *  come at a significant performance cost. Remember that parameter values for message construction
 *  must all be computed eagerly, and autoboxing and varargs array creation may happen as well, even
 *  when the precondition check then succeeds (as it should almost always do in production). In some
 *  circumstances these wasted CPU cycles and allocations can add up to a real problem.
 *  Performance-sensitive precondition checks can always be converted to the customary form:
 *  <pre>   {@code
 * 
 *    if (value < 0.0) {
 *      throw new IllegalArgumentException("negative value: " + value);
 *    }}</pre>
 * 
 *  <h3>Other types of preconditions</h3>
 * 
 *  <p>Not every type of precondition failure is supported by these methods. Continue to throw
 *  standard JDK exceptions such as {@link java.util.NoSuchElementException} or
 *  {@link UnsupportedOperationException} in the situations they are intended for.
 * 
 *  <h3>Non-preconditions</h3>
 * 
 *  <p>It is of course possible to use the methods of this class to check for invalid conditions
 *  which are <i>not the caller's fault</i>. Doing so is <b>not recommended</b> because it is
 *  misleading to future readers of the code and of stack traces. See
 *  <a href="https://github.com/google/guava/wiki/ConditionalFailuresExplained">Conditional failures
 *  explained</a> in the Guava User Guide for more advice.
 * 
 *  <h3>{@code java.util.Objects.requireNonNull()}</h3>
 * 
 *  <p>Projects which use {@code com.google.common} should generally avoid the use of
 *  {@link java.util.Objects#requireNonNull(Object)}. Instead, use whichever of
 *  {@link #checkNotNull(Object)} or {@link Verify#verifyNotNull(Object)} is appropriate to the
 *  situation. (The same goes for the message-accepting overloads.)
 * 
 *  <h3>Only {@code %s} is supported</h3>
 * 
 *  <p>In {@code Preconditions} error message template strings, only the {@code "%s"} specifier is
 *  supported, not the full range of {@link java.util.Formatter} specifiers.
 * 
 *  <h3>More information</h3>
 * 
 *  <p>See the Guava User Guide on
 *  <a href="https://github.com/google/guava/wiki/PreconditionsExplained">using {@code
 *  Preconditions}</a>.
 * 
 *  @author Kevin Bourrillion
 *  @since 2.0
 */
var Preconditions = function() {};
Preconditions = stjs.extend(Preconditions, null, [], function(constructor, prototype) {
    /**
     *  Ensures the truth of an expression involving one or more parameters to the calling method.
     * 
     *  @param expression a boolean expression
     *  @throws IllegalArgumentException if {@code expression} is false
     */
    constructor.checkArgument = function(_arguments) {
        var expression = arguments[0];
        if (!expression) {
             throw new IllegalArgumentException();
        }
    };
    /**
     *  Ensures the truth of an expression involving the state of the calling instance, but not
     *  involving any parameters to the calling method.
     * 
     *  @param expression a boolean expression
     *  @throws IllegalStateException if {@code expression} is false
     */
    constructor.checkState = function(_arguments) {
        var expression = arguments[0];
        if (!expression) {
             throw new IllegalStateException();
        }
    };
    /**
     *  Ensures that an object reference passed as a parameter to the calling method is not null.
     * 
     *  @param reference an object reference
     *  @return the non-null reference that was validated
     *  @throws NullPointerException if {@code reference} is null
     */
    constructor.checkNotNull = function(_arguments) {
        var reference = arguments[0];
        if (reference == null) {
             throw new NullPointerException();
        }
        return reference;
    };
    /**
     *  Ensures that {@code index} specifies a valid <i>element</i> in an array, list or string of size
     *  {@code size}. An element index may range from zero, inclusive, to {@code size}, exclusive.
     * 
     *  @param index a user-supplied index identifying an element of an array, list or string
     *  @param size the size of that array, list or string
     *  @param desc the text to use to describe this index in an error message
     *  @return the value of {@code index}
     *  @throws IndexOutOfBoundsException if {@code index} is negative or is not less than {@code size}
     *  @throws IllegalArgumentException if {@code size} is negative
     */
    constructor.checkElementIndex = function(index, size, desc) {
        if (index < 0 || index >= size) {
             throw new IndexOutOfBoundsException(Preconditions.badElementIndex(index, size, desc));
        }
        return index;
    };
    constructor.badElementIndex = function(index, size, desc) {
        if (index < 0) {
            return Preconditions.format("%s (%s) must not be negative", desc, index);
        } else if (size < 0) {
             throw new IllegalArgumentException("negative size: " + size);
        } else {
            return Preconditions.format("%s (%s) must be less than size (%s)", desc, index, size);
        }
    };
    /**
     *  Ensures that {@code index} specifies a valid <i>position</i> in an array, list or string of
     *  size {@code size}. A position index may range from zero to {@code size}, inclusive.
     * 
     *  @param index a user-supplied index identifying a position in an array, list or string
     *  @param size the size of that array, list or string
     *  @param desc the text to use to describe this index in an error message
     *  @return the value of {@code index}
     *  @throws IndexOutOfBoundsException if {@code index} is negative or is greater than {@code size}
     *  @throws IllegalArgumentException if {@code size} is negative
     */
    constructor.checkPositionIndex = function(index, size, desc) {
        if (index < 0 || index > size) {
             throw new IndexOutOfBoundsException(Preconditions.badPositionIndex(index, size, desc));
        }
        return index;
    };
    constructor.badPositionIndex = function(index, size, desc) {
        if (index < 0) {
            return Preconditions.format("%s (%s) must not be negative", desc, index);
        } else if (size < 0) {
             throw new IllegalArgumentException("negative size: " + size);
        } else {
            return Preconditions.format("%s (%s) must not be greater than size (%s)", desc, index, size);
        }
    };
    /**
     *  Ensures that {@code start} and {@code end} specify a valid <i>positions</i> in an array, list
     *  or string of size {@code size}, and are in order. A position index may range from zero to
     *  {@code size}, inclusive.
     * 
     *  @param start a user-supplied index identifying a starting position in an array, list or string
     *  @param end a user-supplied index identifying a ending position in an array, list or string
     *  @param size the size of that array, list or string
     *  @throws IndexOutOfBoundsException if either index is negative or is greater than {@code size},
     *      or if {@code end} is less than {@code start}
     *  @throws IllegalArgumentException if {@code size} is negative
     */
    constructor.checkPositionIndexes = function(start, end, size) {
        if (start < 0 || end < start || end > size) {
             throw new IndexOutOfBoundsException(Preconditions.badPositionIndexes(start, end, size));
        }
    };
    constructor.badPositionIndexes = function(start, end, size) {
        if (start < 0 || start > size) {
            return Preconditions.badPositionIndex(start, size, "start index");
        }
        if (end < 0 || end > size) {
            return Preconditions.badPositionIndex(end, size, "end index");
        }
        return Preconditions.format("end index (%s) must not be less than start index (%s)", end, start);
    };
    /**
     *  Substitutes each {@code %s} in {@code template} with an argument. These are matched by
     *  position: the first {@code %s} gets {@code args[0]}, etc. If there are more arguments than
     *  placeholders, the unmatched arguments will be appended to the end of the formatted message in
     *  square braces.
     * 
     *  @param template a non-null string containing 0 or more {@code %s} placeholders.
     *  @param args the arguments to be substituted into the message template. Arguments are converted
     *      to strings using {@link String#valueOf(Object)}. Arguments can be null.
     */
    constructor.format = function(_arguments) {
        var template = arguments[0];
        var args = arguments;
        if (args == null) {
             throw new NullPointerException();
        }
        template = String.valueOf(template);
        var builder = new StringBuilder(template.length + 16 * args.length);
        var templateStart = 0;
        var i = 1;
         while (i < args.length){
            var placeholderStart = template.indexOf("%s", templateStart);
            if (placeholderStart == -1) {
                break;
            }
            builder.append(template, templateStart, placeholderStart);
            builder.append(args[i++]);
            templateStart = placeholderStart + 2;
        }
        builder.append(template, templateStart, template.length);
        if (i < args.length) {
            builder.append(" [");
            builder.append(args[i++]);
             while (i < args.length){
                builder.append(", ");
                builder.append(args[i++]);
            }
            builder.append(']'.charCodeAt(0));
        }
        return builder.toString();
    };
}, {}, {});
var BaseInputStream = function() {
    InputStream.call(this);
};
BaseInputStream = stjs.extend(BaseInputStream, InputStream, [], function(constructor, prototype) {
    prototype.readByte = function() {};
    prototype.readBuffer = function(b, from, len) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A block map that that maps macroblocks sequentially in scan order
 *  
 *  @author The JCodec project
 *  
 */
var FlatMBlockMapper = function(frameWidthInMbs, firstMBAddr) {
    this.frameWidthInMbs = frameWidthInMbs;
    this.firstMBAddr = firstMBAddr;
};
FlatMBlockMapper = stjs.extend(FlatMBlockMapper, null, [Mapper], function(constructor, prototype) {
    prototype.frameWidthInMbs = 0;
    prototype.firstMBAddr = 0;
    prototype.leftAvailable = function(index) {
        var mbAddr = index + this.firstMBAddr;
        var atTheBorder = mbAddr % this.frameWidthInMbs == 0;
        return !atTheBorder && (mbAddr > this.firstMBAddr);
    };
    prototype.topAvailable = function(index) {
        var mbAddr = index + this.firstMBAddr;
        return mbAddr - this.frameWidthInMbs >= this.firstMBAddr;
    };
    prototype.getAddress = function(index) {
        return this.firstMBAddr + index;
    };
    prototype.getMbX = function(index) {
        return this.getAddress(index) % this.frameWidthInMbs;
    };
    prototype.getMbY = function(index) {
        return stjs.trunc(this.getAddress(index) / this.frameWidthInMbs);
    };
    prototype.topRightAvailable = function(index) {
        var mbAddr = index + this.firstMBAddr;
        var atTheBorder = (mbAddr + 1) % this.frameWidthInMbs == 0;
        return !atTheBorder && mbAddr - this.frameWidthInMbs + 1 >= this.firstMBAddr;
    };
    prototype.topLeftAvailable = function(index) {
        var mbAddr = index + this.firstMBAddr;
        var atTheBorder = mbAddr % this.frameWidthInMbs == 0;
        return !atTheBorder && mbAddr - this.frameWidthInMbs - 1 >= this.firstMBAddr;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A macrboblock to slice group mapper that operates on prebuilt map, passed to
 *  it in the constructor
 *  
 *  @author The JCodec project
 *  
 */
var PrebuiltMBlockMapper = function(map, firstMBInSlice, picWidthInMbs) {
    this.map = map;
    this.firstMBInSlice = firstMBInSlice;
    this.groupId = map.getGroups()[firstMBInSlice];
    this.picWidthInMbs = picWidthInMbs;
    this.indexOfFirstMb = map.getIndices()[firstMBInSlice];
};
PrebuiltMBlockMapper = stjs.extend(PrebuiltMBlockMapper, null, [Mapper], function(constructor, prototype) {
    prototype.map = null;
    prototype.firstMBInSlice = 0;
    prototype.groupId = 0;
    prototype.picWidthInMbs = 0;
    prototype.indexOfFirstMb = 0;
    prototype.getAddress = function(mbIndex) {
        return this.map.getInverse()[this.groupId][mbIndex + this.indexOfFirstMb];
    };
    prototype.leftAvailable = function(mbIndex) {
        var mbAddr = this.map.getInverse()[this.groupId][mbIndex + this.indexOfFirstMb];
        var leftMBAddr = mbAddr - 1;
        return !((leftMBAddr < this.firstMBInSlice) || ((mbAddr % this.picWidthInMbs) == 0) || (this.map.getGroups()[leftMBAddr] != this.groupId));
    };
    prototype.topAvailable = function(mbIndex) {
        var mbAddr = this.map.getInverse()[this.groupId][mbIndex + this.indexOfFirstMb];
        var topMBAddr = mbAddr - this.picWidthInMbs;
        return !((topMBAddr < this.firstMBInSlice) || (this.map.getGroups()[topMBAddr] != this.groupId));
    };
    prototype.getMbX = function(index) {
        return this.getAddress(index) % this.picWidthInMbs;
    };
    prototype.getMbY = function(index) {
        return stjs.trunc(this.getAddress(index) / this.picWidthInMbs);
    };
    prototype.topRightAvailable = function(mbIndex) {
        var mbAddr = this.map.getInverse()[this.groupId][mbIndex + this.indexOfFirstMb];
        var topRMBAddr = mbAddr - this.picWidthInMbs + 1;
        return !((topRMBAddr < this.firstMBInSlice) || (((mbAddr + 1) % this.picWidthInMbs) == 0) || (this.map.getGroups()[topRMBAddr] != this.groupId));
    };
    prototype.topLeftAvailable = function(mbIndex) {
        var mbAddr = this.map.getInverse()[this.groupId][mbIndex + this.indexOfFirstMb];
        var topLMBAddr = mbAddr - this.picWidthInMbs - 1;
        return !((topLMBAddr < this.firstMBInSlice) || ((mbAddr % this.picWidthInMbs) == 0) || (this.map.getGroups()[topLMBAddr] != this.groupId));
    };
}, {map: "MBToSliceGroupMap"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Demuxer = function() {};
Demuxer = stjs.extend(Demuxer, null, [Closeable], function(constructor, prototype) {
    prototype.getTracks = function() {};
    prototype.getVideoTracks = function() {};
    prototype.getAudioTracks = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  This class is analogous to DataInputStream, it's backed by the Channel and
 *  buffers the IO
 *  
 *  @author The JCodec project
 *  
 */
var DataReader = function(channel, order, bufferSize) {
    this.channel = channel;
    this.buffer = ByteBuffer.allocate(bufferSize);
    this.buffer.setLimit(0);
    this.buffer.order(order);
};
DataReader = stjs.extend(DataReader, null, [Closeable], function(constructor, prototype) {
    constructor.DEFAULT_BUFFER_SIZE = 1 << 20;
    prototype.channel = null;
    prototype.buffer = null;
    constructor.createDataReader = function(channel, order) {
        return new DataReader(channel, order, DataReader.DEFAULT_BUFFER_SIZE);
    };
    prototype.readFully3 = function(b, off, len) {
        var initOff = off;
         while (len > 0){
            this.fetchIfNeeded(len);
            if (this.buffer.remaining() == 0) 
                break;
            var toRead = Math.min(this.buffer.remaining(), len);
            this.buffer.getBuf3(b, off, toRead);
            off += toRead;
            len -= toRead;
        }
        return off - initOff;
    };
    prototype.skipBytes = function(n) {
        var oldPosition = this.position();
        if (n < this.buffer.remaining()) {
            this.buffer.setPosition(this.buffer.position() + n);
        } else {
            this.setPosition(oldPosition + n);
        }
        return (((this.position() - oldPosition)) | 0);
    };
    prototype.readByte = function() {
        this.fetchIfNeeded(1);
        return this.buffer.get();
    };
    prototype.readShort = function() {
        this.fetchIfNeeded(2);
        return this.buffer.getShort();
    };
    prototype.readChar = function() {
        this.fetchIfNeeded(2);
        return this.buffer.getChar();
    };
    prototype.readInt = function() {
        this.fetchIfNeeded(4);
        return this.buffer.getInt();
    };
    prototype.readLong = function() {
        this.fetchIfNeeded(8);
        return this.buffer.getLong();
    };
    prototype.readFloat = function() {
        this.fetchIfNeeded(4);
        return this.buffer.getFloat();
    };
    prototype.readDouble = function() {
        this.fetchIfNeeded(8);
        return this.buffer.getDouble();
    };
    prototype.position = function() {
        return this.channel.position() - this.buffer.limit() + this.buffer.position();
    };
    prototype.setPosition = function(newPos) {
        var relative = (((newPos - (this.channel.position() - this.buffer.limit()))) | 0);
        if (relative >= 0 && relative < this.buffer.limit()) {
            this.buffer.setPosition(relative);
        } else {
            this.buffer.setLimit(0);
            this.channel.setPosition(newPos);
        }
        return this.position();
    };
    prototype.close = function() {
        this.channel.close();
    };
    prototype.fetchIfNeeded = function(length) {
        if (this.buffer.remaining() < length) {
            DataReader.moveRemainderToTheStart(this.buffer);
            this.channel.read(this.buffer);
            this.buffer.flip();
        }
    };
    constructor.moveRemainderToTheStart = function(readBuf) {
        var rem = readBuf.remaining();
        for (var i = 0; i < rem; i++) {
            readBuf.putAt(i, readBuf.get());
        }
        readBuf.clear();
        readBuf.setPosition(rem);
    };
    prototype.size = function() {
        return this.channel.size();
    };
    prototype.readFully = function(b) {
        return this.readFully3(b, 0, b.length);
    };
}, {channel: "SeekableByteChannel", buffer: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SeekableByteChannel = function() {};
SeekableByteChannel = stjs.extend(SeekableByteChannel, null, [ByteChannel, Channel, Closeable, ReadableByteChannel, WritableByteChannel], function(constructor, prototype) {
    prototype.position = function() {};
    prototype.setPosition = function(newPosition) {};
    prototype.size = function() {};
    prototype.truncate = function(size) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var ProresConsts = function() {};
ProresConsts = stjs.extend(ProresConsts, null, [], function(constructor, prototype) {
    constructor.firstDCCodebook = new Codebook(5, 6, 0);
    constructor.dcCodebooks = [new Codebook(0, 1, 0), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(2, 3, 1), new Codebook(2, 3, 1), new Codebook(3, 4, 0), new Codebook(3, 4, 0)];
    constructor.runCodebooks = [new Codebook(0, 1, 2), new Codebook(0, 1, 2), new Codebook(0, 1, 1), new Codebook(0, 1, 1), new Codebook(0, 1, 0), new Codebook(1, 2, 1), new Codebook(1, 2, 1), new Codebook(1, 2, 1), new Codebook(1, 2, 1), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(2, 3, 0)];
    constructor.levCodebooks = [new Codebook(0, 1, 0), new Codebook(0, 2, 2), new Codebook(0, 1, 1), new Codebook(0, 1, 2), new Codebook(0, 1, 0), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(1, 2, 0), new Codebook(2, 3, 0)];
    constructor.progressive_scan = new Int32Array([0, 1, 8, 9, 2, 3, 10, 11, 16, 17, 24, 25, 18, 19, 26, 27, 4, 5, 12, 20, 13, 6, 7, 14, 21, 28, 29, 22, 15, 23, 30, 31, 32, 33, 40, 48, 41, 34, 35, 42, 49, 56, 57, 50, 43, 36, 37, 44, 51, 58, 59, 52, 45, 38, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
    constructor.interlaced_scan = new Int32Array([0, 8, 1, 9, 16, 24, 17, 25, 2, 10, 3, 11, 18, 26, 19, 27, 32, 40, 33, 34, 41, 48, 56, 49, 42, 35, 43, 50, 57, 58, 51, 59, 4, 12, 5, 6, 13, 20, 28, 21, 14, 7, 15, 22, 29, 36, 44, 37, 30, 23, 31, 38, 45, 52, 60, 53, 46, 39, 47, 54, 61, 62, 55, 63]);
    constructor.QMAT_LUMA_APCH = new Int32Array([4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 5, 5, 4, 4, 4, 4, 4, 5, 5, 6, 4, 4, 4, 4, 5, 5, 6, 7, 4, 4, 4, 4, 5, 6, 7, 7]);
    constructor.QMAT_CHROMA_APCH = new Int32Array([4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 4, 5, 5, 4, 4, 4, 4, 4, 5, 5, 6, 4, 4, 4, 4, 5, 5, 6, 7, 4, 4, 4, 4, 5, 6, 7, 7]);
    constructor.QMAT_LUMA_APCO = new Int32Array([4, 7, 9, 11, 13, 14, 15, 63, 7, 7, 11, 12, 14, 15, 63, 63, 9, 11, 13, 14, 15, 63, 63, 63, 11, 11, 13, 14, 63, 63, 63, 63, 11, 13, 14, 63, 63, 63, 63, 63, 13, 14, 63, 63, 63, 63, 63, 63, 13, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63]);
    constructor.QMAT_CHROMA_APCO = new Int32Array([4, 7, 9, 11, 13, 14, 63, 63, 7, 7, 11, 12, 14, 63, 63, 63, 9, 11, 13, 14, 63, 63, 63, 63, 11, 11, 13, 14, 63, 63, 63, 63, 11, 13, 14, 63, 63, 63, 63, 63, 13, 14, 63, 63, 63, 63, 63, 63, 13, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63]);
    constructor.QMAT_LUMA_APCN = new Int32Array([4, 4, 5, 5, 6, 7, 7, 9, 4, 4, 5, 6, 7, 7, 9, 9, 5, 5, 6, 7, 7, 9, 9, 10, 5, 5, 6, 7, 7, 9, 9, 10, 5, 6, 7, 7, 8, 9, 10, 12, 6, 7, 7, 8, 9, 10, 12, 15, 6, 7, 7, 9, 10, 11, 14, 17, 7, 7, 9, 10, 11, 14, 17, 21]);
    constructor.QMAT_CHROMA_APCN = new Int32Array([4, 4, 5, 5, 6, 7, 7, 9, 4, 4, 5, 6, 7, 7, 9, 9, 5, 5, 6, 7, 7, 9, 9, 10, 5, 5, 6, 7, 7, 9, 9, 10, 5, 6, 7, 7, 8, 9, 10, 12, 6, 7, 7, 8, 9, 10, 12, 15, 6, 7, 7, 9, 10, 11, 14, 17, 7, 7, 9, 10, 11, 14, 17, 21]);
    constructor.QMAT_LUMA_APCS = new Int32Array([4, 5, 6, 7, 9, 11, 13, 15, 5, 5, 7, 8, 11, 13, 15, 17, 6, 7, 9, 11, 13, 15, 15, 17, 7, 7, 9, 11, 13, 15, 17, 19, 7, 9, 11, 13, 14, 16, 19, 23, 9, 11, 13, 14, 16, 19, 23, 29, 9, 11, 13, 15, 17, 21, 28, 35, 11, 13, 16, 17, 21, 28, 35, 41]);
    constructor.QMAT_CHROMA_APCS = new Int32Array([4, 5, 6, 7, 9, 11, 13, 15, 5, 5, 7, 8, 11, 13, 15, 17, 6, 7, 9, 11, 13, 15, 15, 17, 7, 7, 9, 11, 13, 15, 17, 19, 7, 9, 11, 13, 14, 16, 19, 23, 9, 11, 13, 14, 16, 19, 23, 29, 9, 11, 13, 15, 17, 21, 28, 35, 11, 13, 16, 17, 21, 28, 35, 41]);
    constructor.FrameHeader = function(frameSize, width, height, frameType, topFieldFirst, scan, qMatLuma, qMatChroma, chromaType) {
        this.payloadSize = frameSize;
        this.width = width;
        this.height = height;
        this.frameType = frameType;
        this.topFieldFirst = topFieldFirst;
        this.scan = scan;
        this.qMatChroma = qMatChroma;
        this.qMatLuma = qMatLuma;
        this.chromaType = chromaType;
    };
    constructor.FrameHeader = stjs.extend(constructor.FrameHeader, null, [], function(constructor, prototype) {
        prototype.payloadSize = 0;
        prototype.width = 0;
        prototype.height = 0;
        prototype.frameType = 0;
        prototype.topFieldFirst = false;
        prototype.chromaType = 0;
        prototype.scan = null;
        prototype.qMatLuma = null;
        prototype.qMatChroma = null;
    }, {scan: "Int32Array", qMatLuma: "Int32Array", qMatChroma: "Int32Array"}, {});
    constructor.PictureHeader = function(log2SliceMbWidth, sliceSizes) {
        this.log2SliceMbWidth = log2SliceMbWidth;
        this.sliceSizes = sliceSizes;
    };
    constructor.PictureHeader = stjs.extend(constructor.PictureHeader, null, [], function(constructor, prototype) {
        prototype.log2SliceMbWidth = 0;
        prototype.sliceSizes = null;
    }, {sliceSizes: "Int16Array"}, {});
}, {firstDCCodebook: "Codebook", dcCodebooks: "Array", runCodebooks: "Array", levCodebooks: "Array", progressive_scan: "Int32Array", interlaced_scan: "Int32Array", QMAT_LUMA_APCH: "Int32Array", QMAT_CHROMA_APCH: "Int32Array", QMAT_LUMA_APCO: "Int32Array", QMAT_CHROMA_APCO: "Int32Array", QMAT_LUMA_APCN: "Int32Array", QMAT_CHROMA_APCN: "Int32Array", QMAT_LUMA_APCS: "Int32Array", QMAT_CHROMA_APCS: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Network abstraction layer (NAL) unit
 *  
 *  @author The JCodec project
 *  
 */
var NALUnit = function(type, nal_ref_idc) {
    this.type = type;
    this.nal_ref_idc = nal_ref_idc;
};
NALUnit = stjs.extend(NALUnit, null, [], function(constructor, prototype) {
    prototype.type = null;
    prototype.nal_ref_idc = 0;
    constructor.read = function(_in) {
        var nalu = _in.get() & 255;
        var nal_ref_idc = (nalu >> 5) & 3;
        var nb = nalu & 31;
        var type = NALUnitType.fromValue(nb);
        return new NALUnit(type, nal_ref_idc);
    };
    prototype.write = function(out) {
        var nalu = this.type.getValue() | (this.nal_ref_idc << 5);
        out.put((nalu << 24 >> 24));
    };
}, {type: "NALUnitType"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VPXQuantizer = function() {};
VPXQuantizer = stjs.extend(VPXQuantizer, null, [], function(constructor, prototype) {
    prototype.y1_dc_delta_q = 0;
    prototype.uv_dc_delta_q = 0;
    prototype.uv_ac_delta_q = 0;
    prototype.y2_dc_delta_q = 0;
    prototype.y2_ac_delta_q = 0;
    prototype.quantizeY = function(coeffs, qp) {
        var factDC = MathUtil.clip(VPXConst.dc_qlookup[qp + this.y1_dc_delta_q], 8, 132);
        var invFactAC = MathUtil.clip(VPXConst.ac_qlookup[qp], 8, 132);
        this.quantize(coeffs, factDC, invFactAC);
    };
    prototype.quantizeUV = function(coeffs, qp) {
        var factDC = MathUtil.clip(VPXConst.dc_qlookup[qp + this.uv_dc_delta_q], 8, 132);
        var invFactAC = MathUtil.clip(VPXConst.ac_qlookup[qp + this.uv_ac_delta_q], 8, 132);
        this.quantize(coeffs, factDC, invFactAC);
    };
    prototype.quantizeY2 = function(coeffs, qp) {
        var factDC = MathUtil.clip(VPXConst.dc_qlookup[qp + this.y2_dc_delta_q] * 2, 8, 132);
        var invFactAC = MathUtil.clip(stjs.trunc(VPXConst.ac_qlookup[qp + this.y2_ac_delta_q] * 155 / 100), 8, 132);
        this.quantize(coeffs, factDC, invFactAC);
    };
    prototype.quantize = function(coeffs, factDC, factAC) {
        coeffs[0] = stjs.trunc(coeffs[0] / (factDC));
        for (var i = 1; i < 16; i++) 
            coeffs[i] = stjs.trunc(coeffs[i] / factAC);
    };
    prototype.dequantizeY = function(coeffs, qp) {
        var factDC = MathUtil.clip(VPXConst.dc_qlookup[qp + this.y1_dc_delta_q], 8, 132);
        var factAC = MathUtil.clip(VPXConst.ac_qlookup[qp], 8, 132);
        this.dequantize(coeffs, factDC, factAC);
    };
    prototype.dequantizeUV = function(coeffs, qp) {
        var factDC = MathUtil.clip(VPXConst.dc_qlookup[qp + this.uv_dc_delta_q], 8, 132);
        var factAC = MathUtil.clip(VPXConst.ac_qlookup[qp + this.uv_ac_delta_q], 8, 132);
        this.dequantize(coeffs, factDC, factAC);
    };
    prototype.dequantizeY2 = function(coeffs, qp) {
        var factDC = MathUtil.clip(VPXConst.dc_qlookup[qp + this.y2_dc_delta_q] * 2, 8, 132);
        var factAC = MathUtil.clip(stjs.trunc(VPXConst.ac_qlookup[qp + this.y2_ac_delta_q] * 155 / 100), 8, 132);
        this.dequantize(coeffs, factDC, factAC);
    };
    prototype.dequantize = function(coeffs, factDC, factAC) {
        coeffs[0] *= factDC;
        for (var i = 1; i < 16; i++) 
            coeffs[i] *= factAC;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Containes boolean encoder from VPx codecs
 *  
 *  @author The JCodec project
 *  
 */
var VPXBooleanEncoder = function(out) {
    this.out = out;
    this.lowvalue = 0;
    this.range = 255;
    this.count = -24;
};
VPXBooleanEncoder = stjs.extend(VPXBooleanEncoder, null, [], function(constructor, prototype) {
    prototype.out = null;
    prototype.lowvalue = 0;
    prototype.range = 0;
    prototype.count = 0;
    prototype.writeBit = function(prob, bb) {
        var split = 1 + (((this.range - 1) * prob) >> 8);
        if (bb != 0) {
            this.lowvalue += split;
            this.range -= split;
        } else {
            this.range = split;
        }
        var shift = VPXConst.vp8Norm[this.range];
        this.range <<= shift;
        this.count += shift;
        if (this.count >= 0) {
            var offset = shift - this.count;
            if (((this.lowvalue << (offset - 1)) & -2147483648) != 0) {
                var x = this.out.position() - 1;
                 while (x >= 0 && this.out.getAt(x) == -1){
                    this.out.putAt(x, (0 << 24 >> 24));
                    x--;
                }
                this.out.putAt(x, (((this.out.getAt(x) & 255) + 1) << 24 >> 24));
            }
            this.out.put(((this.lowvalue >> (24 - offset)) << 24 >> 24));
            this.lowvalue <<= offset;
            shift = this.count;
            this.lowvalue &= 16777215;
            this.count -= 8;
        }
        this.lowvalue <<= shift;
    };
    prototype.stop = function() {
        var i;
        for (i = 0; i < 32; i++) 
            this.writeBit(128, 0);
    };
    prototype.position = function() {
        return this.out.position() + ((this.count + 24) >> 3);
    };
}, {out: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VPXBitstream = function(tokenBinProbs, mbWidth) {
    this.dctNzLeft = [new Int32Array(4), new Int32Array(2), new Int32Array(2)];
    this.tokenBinProbs = tokenBinProbs;
    this.whtNzTop = new Int32Array(mbWidth);
    this.dctNzTop = [new Int32Array(mbWidth << 2), new Int32Array(mbWidth << 1), new Int32Array(mbWidth << 1)];
};
VPXBitstream = stjs.extend(VPXBitstream, null, [], function(constructor, prototype) {
    constructor.coeffBandMapping = new Int32Array([0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7]);
    prototype.tokenBinProbs = null;
    prototype.whtNzLeft = 0;
    prototype.whtNzTop = null;
    prototype.dctNzLeft = null;
    prototype.dctNzTop = null;
    prototype.encodeCoeffsWHT = function(bc, coeffs, mbX) {
        var nCoeff = this.fastCountCoeffWHT(coeffs);
        this.encodeCoeffs(bc, coeffs, 0, nCoeff, 1, (mbX == 0 || this.whtNzLeft <= 0 ? 0 : 1) + (this.whtNzTop[mbX] > 0 ? 1 : 0));
        this.whtNzLeft = nCoeff;
        this.whtNzTop[mbX] = nCoeff;
    };
    prototype.encodeCoeffsDCT15 = function(bc, coeffs, mbX, blkX, blkY) {
        var nCoeff = this.countCoeff(coeffs, 16);
        var blkAbsX = (mbX << 2) + blkX;
        this.encodeCoeffs(bc, coeffs, 1, nCoeff, 0, (blkAbsX == 0 || this.dctNzLeft[0][blkY] <= 0 ? 0 : 1) + (this.dctNzTop[0][blkAbsX] > 0 ? 1 : 0));
        this.dctNzLeft[0][blkY] = Math.max(nCoeff - 1, 0);
        this.dctNzTop[0][blkAbsX] = Math.max(nCoeff - 1, 0);
    };
    prototype.encodeCoeffsDCT16 = function(bc, coeffs, mbX, blkX, blkY) {
        var nCoeff = this.countCoeff(coeffs, 16);
        var blkAbsX = (mbX << 2) + blkX;
        this.encodeCoeffs(bc, coeffs, 0, nCoeff, 3, (blkAbsX == 0 || this.dctNzLeft[0][blkY] <= 0 ? 0 : 1) + (this.dctNzTop[0][blkAbsX] > 0 ? 1 : 0));
        this.dctNzLeft[0][blkY] = nCoeff;
        this.dctNzTop[0][blkAbsX] = nCoeff;
    };
    prototype.encodeCoeffsDCTUV = function(bc, coeffs, comp, mbX, blkX, blkY) {
        var nCoeff = this.countCoeff(coeffs, 16);
        var blkAbsX = (mbX << 1) + blkX;
        this.encodeCoeffs(bc, coeffs, 0, nCoeff, 2, (blkAbsX == 0 || this.dctNzLeft[comp][blkY] <= 0 ? 0 : 1) + (this.dctNzTop[comp][blkAbsX] > 0 ? 1 : 0));
        this.dctNzLeft[comp][blkY] = nCoeff;
        this.dctNzTop[comp][blkAbsX] = nCoeff;
    };
    /**
     *  Encodes DCT/WHT coefficients into the provided instance of a boolean
     *  encoder
     *  
     *  @param bc
     *  @param coeffs
     */
    prototype.encodeCoeffs = function(bc, coeffs, firstCoeff, nCoeff, blkType, ctx) {
        var prevZero = false;
        var i;
        for (i = firstCoeff; i < nCoeff; i++) {
            var probs = this.tokenBinProbs[blkType][VPXBitstream.coeffBandMapping[i]][ctx];
            var coeffAbs = MathUtil.abs(coeffs[i]);
            if (!prevZero) 
                bc.writeBit(probs[0], 1);
            if (coeffAbs == 0) {
                bc.writeBit(probs[1], 0);
                ctx = 0;
            } else {
                bc.writeBit(probs[1], 1);
                if (coeffAbs == 1) {
                    bc.writeBit(probs[2], 0);
                    ctx = 1;
                } else {
                    ctx = 2;
                    bc.writeBit(probs[2], 1);
                    if (coeffAbs <= 4) {
                        bc.writeBit(probs[3], 0);
                        if (coeffAbs == 2) 
                            bc.writeBit(probs[4], 0);
                         else {
                            bc.writeBit(probs[4], 1);
                            bc.writeBit(probs[5], coeffAbs - 3);
                        }
                    } else {
                        bc.writeBit(probs[3], 1);
                        if (coeffAbs <= 10) {
                            bc.writeBit(probs[6], 0);
                            if (coeffAbs <= 6) {
                                bc.writeBit(probs[7], 0);
                                bc.writeBit(159, coeffAbs - 5);
                            } else {
                                bc.writeBit(probs[7], 1);
                                var d = coeffAbs - 7;
                                bc.writeBit(165, d >> 1);
                                bc.writeBit(145, d & 1);
                            }
                        } else {
                            bc.writeBit(probs[6], 1);
                            if (coeffAbs <= 34) {
                                bc.writeBit(probs[8], 0);
                                if (coeffAbs <= 18) {
                                    bc.writeBit(probs[9], 0);
                                    VPXBitstream.writeCat3Ext(bc, coeffAbs);
                                } else {
                                    bc.writeBit(probs[9], 1);
                                    VPXBitstream.writeCat4Ext(bc, coeffAbs);
                                }
                            } else {
                                bc.writeBit(probs[8], 1);
                                if (coeffAbs <= 66) {
                                    bc.writeBit(probs[10], 0);
                                    VPXBitstream.writeCatExt(bc, coeffAbs, 35, VPXConst.probCoeffExtCat5);
                                } else {
                                    bc.writeBit(probs[10], 1);
                                    VPXBitstream.writeCatExt(bc, coeffAbs, 67, VPXConst.probCoeffExtCat6);
                                }
                            }
                        }
                    }
                }
                bc.writeBit(128, MathUtil.sign(coeffs[i]));
            }
            prevZero = coeffAbs == 0;
        }
        if (nCoeff < 16) {
            var probs = this.tokenBinProbs[blkType][VPXBitstream.coeffBandMapping[i]][ctx];
            bc.writeBit(probs[0], 0);
        }
    };
    constructor.writeCat3Ext = function(bc, coeff) {
        var d = coeff - 11;
        bc.writeBit(173, d >> 2);
        bc.writeBit(148, (d >> 1) & 1);
        bc.writeBit(140, d & 1);
    };
    constructor.writeCat4Ext = function(bc, coeff) {
        var d = coeff - 19;
        bc.writeBit(176, d >> 3);
        bc.writeBit(155, (d >> 2) & 1);
        bc.writeBit(140, (d >> 1) & 1);
        bc.writeBit(135, d & 1);
    };
    constructor.writeCatExt = function(bc, coeff, catOff, cat) {
        var d = coeff - catOff;
        for (var b = cat.length - 1, i = 0; b >= 0; b--) {
            bc.writeBit(cat[i++], (d >> b) & 1);
        }
    };
    /**
     *  Counts number of non-zero coefficients for a WHT block, with shortcut as
     *  most of them are likely to be non-zero
     *  
     *  @param coeffs
     *  @return
     */
    prototype.fastCountCoeffWHT = function(coeffs) {
        if (coeffs[15] != 0) 
            return 16;
         else 
            return this.countCoeff(coeffs, 15);
    };
    /**
     *  Counts number of non-zero coefficients
     *  
     *  @param coeffs
     *  @param nCoeff
     *  @return
     */
    prototype.countCoeff = function(coeffs, nCoeff) {
         while (nCoeff > 0){
            --nCoeff;
            if (coeffs[nCoeff] != 0) 
                return nCoeff + 1;
        }
        return nCoeff;
    };
}, {coeffBandMapping: "Int32Array", tokenBinProbs: "Array", whtNzTop: "Int32Array", dctNzLeft: "Array", dctNzTop: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Label = function(val) {
    this.labelVal = val;
    this.bitmapVal = (this.labelVal > 18 || this.labelVal < 1) ? 0 : 1 << (this.labelVal - 1);
    Label._values.add(this);
};
Label = stjs.extend(Label, null, [], function(constructor, prototype) {
    constructor._values = new ArrayList();
    /**
     * unknown role or unspecified other use for channel 
     */
    constructor.Unknown = new Label(-1);
    /**
     * channel is present, but has no intended role or destination 
     */
    constructor.Unused = new Label(0);
    /**
     * channel is described solely by the mCoordinates fields 
     */
    constructor.UseCoordinates = new Label(100);
    constructor.Left = new Label(1);
    constructor.Right = new Label(2);
    constructor.Center = new Label(3);
    constructor.LFEScreen = new Label(4);
    /**
     * WAVE (.wav files): "Back Left" 
     */
    constructor.LeftSurround = new Label(5);
    /**
     * WAVE: "Back Right" 
     */
    constructor.RightSurround = new Label(6);
    constructor.LeftCenter = new Label(7);
    constructor.RightCenter = new Label(8);
    /**
     * WAVE: "Back  Center or  plain "Rear Surround" 
     */
    constructor.CenterSurround = new Label(9);
    /**
     * WAVE: "Side Left" 
     */
    constructor.LeftSurroundDirect = new Label(10);
    /**
     * WAVE: "Side Right" 
     */
    constructor.RightSurroundDirect = new Label(11);
    constructor.TopCenterSurround = new Label(12);
    /**
     * WAVE: "Top Front Left" 
     */
    constructor.VerticalHeightLeft = new Label(13);
    /**
     * WAVE: "Top Front Center" 
     */
    constructor.VerticalHeightCenter = new Label(14);
    /**
     * WAVE: "Top Front Right" 
     */
    constructor.VerticalHeightRight = new Label(15);
    constructor.TopBackLeft = new Label(16);
    constructor.TopBackCenter = new Label(17);
    constructor.TopBackRight = new Label(18);
    constructor.RearSurroundLeft = new Label(33);
    constructor.RearSurroundRight = new Label(34);
    constructor.LeftWide = new Label(35);
    constructor.RightWide = new Label(36);
    constructor.LFE2 = new Label(37);
    /**
     * matrix encoded 4 channels 
     */
    constructor.LeftTotal = new Label(38);
    /**
     * matrix encoded 4 channels 
     */
    constructor.RightTotal = new Label(39);
    constructor.HearingImpaired = new Label(40);
    constructor.Narration = new Label(41);
    constructor.Mono = new Label(42);
    constructor.DialogCentricMix = new Label(43);
    /**
     * center, non diffuse first order ambisonic channels 
     */
    constructor.CenterSurroundDirect = new Label(44);
    constructor.Ambisonic_W = new Label(200);
    constructor.Ambisonic_X = new Label(201);
    constructor.Ambisonic_Y = new Label(202);
    constructor.Ambisonic_Z = new Label(203);
    /**
     * Mid/Side Recording 
     */
    constructor.MS_Mid = new Label(204);
    constructor.MS_Side = new Label(205);
    /**
     * X-Y Recording 
     */
    constructor.XY_X = new Label(206);
    constructor.XY_Y = new Label(207);
    constructor.HeadphonesLeft = new Label(301);
    constructor.HeadphonesRight = new Label(302);
    constructor.ClickTrack = new Label(304);
    constructor.ForeignLanguage = new Label(305);
    constructor.Discrete = new Label(400);
    constructor.Discrete_0 = new Label((1 << 16) | 0);
    constructor.Discrete_1 = new Label((1 << 16) | 1);
    constructor.Discrete_2 = new Label((1 << 16) | 2);
    constructor.Discrete_3 = new Label((1 << 16) | 3);
    constructor.Discrete_4 = new Label((1 << 16) | 4);
    constructor.Discrete_5 = new Label((1 << 16) | 5);
    constructor.Discrete_6 = new Label((1 << 16) | 6);
    constructor.Discrete_7 = new Label((1 << 16) | 7);
    constructor.Discrete_8 = new Label((1 << 16) | 8);
    constructor.Discrete_9 = new Label((1 << 16) | 9);
    constructor.Discrete_10 = new Label((1 << 16) | 10);
    constructor.Discrete_11 = new Label((1 << 16) | 11);
    constructor.Discrete_12 = new Label((1 << 16) | 12);
    constructor.Discrete_13 = new Label((1 << 16) | 13);
    constructor.Discrete_14 = new Label((1 << 16) | 14);
    constructor.Discrete_15 = new Label((1 << 16) | 15);
    constructor.Discrete_65535 = new Label((1 << 16) | 65535);
    prototype.labelVal = 0;
    prototype.bitmapVal = 0;
    constructor.channelMappingRegex = Pattern.compile("[_\\ \\.][a-zA-Z]+$");
    constructor.values = function() {
        return Label._values.toArray(Array(0));
    };
    constructor.getByVal = function(val) {
        var values = Label.values();
        for (var i = 0; i < values.length; i++) {
            var label = values[i];
            if (label.labelVal == val) 
                return label;
        }
        return Label.Mono;
    };
    prototype.getVal = function() {
        return this.labelVal;
    };
}, {_values: {name: "List", arguments: ["Label"]}, Unknown: "Label", Unused: "Label", UseCoordinates: "Label", Left: "Label", Right: "Label", Center: "Label", LFEScreen: "Label", LeftSurround: "Label", RightSurround: "Label", LeftCenter: "Label", RightCenter: "Label", CenterSurround: "Label", LeftSurroundDirect: "Label", RightSurroundDirect: "Label", TopCenterSurround: "Label", VerticalHeightLeft: "Label", VerticalHeightCenter: "Label", VerticalHeightRight: "Label", TopBackLeft: "Label", TopBackCenter: "Label", TopBackRight: "Label", RearSurroundLeft: "Label", RearSurroundRight: "Label", LeftWide: "Label", RightWide: "Label", LFE2: "Label", LeftTotal: "Label", RightTotal: "Label", HearingImpaired: "Label", Narration: "Label", Mono: "Label", DialogCentricMix: "Label", CenterSurroundDirect: "Label", Ambisonic_W: "Label", Ambisonic_X: "Label", Ambisonic_Y: "Label", Ambisonic_Z: "Label", MS_Mid: "Label", MS_Side: "Label", XY_X: "Label", XY_Y: "Label", HeadphonesLeft: "Label", HeadphonesRight: "Label", ClickTrack: "Label", ForeignLanguage: "Label", Discrete: "Label", Discrete_0: "Label", Discrete_1: "Label", Discrete_2: "Label", Discrete_3: "Label", Discrete_4: "Label", Discrete_5: "Label", Discrete_6: "Label", Discrete_7: "Label", Discrete_8: "Label", Discrete_9: "Label", Discrete_10: "Label", Discrete_11: "Label", Discrete_12: "Label", Discrete_13: "Label", Discrete_14: "Label", Discrete_15: "Label", Discrete_65535: "Label", channelMappingRegex: "Pattern"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Rate control that does nothing
 *  
 *  @author The JCodec project
 *  
 */
var NopRateControl = function(qp) {
    this.qp = qp;
};
NopRateControl = stjs.extend(NopRateControl, null, [RateControl], function(constructor, prototype) {
    prototype.qp = 0;
    prototype.getSegmentQps = function() {
        return new Int32Array([this.qp]);
    };
    prototype.getSegment = function() {
        return 0;
    };
    prototype.report = function(bits) {};
    prototype.reset = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Makes all frames of a fixed size
 *  
 *  @author The JCodec project
 *  
 */
var VP8FixedRateControl = function(rate) {
    this.rate = rate;
};
VP8FixedRateControl = stjs.extend(VP8FixedRateControl, null, [RateControl], function(constructor, prototype) {
    prototype.rate = 0;
    prototype.getSegmentQps = function() {
        return null;
    };
    prototype.getSegment = function() {
        return 0;
    };
    prototype.report = function(bits) {};
    prototype.reset = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Tuple = function() {};
Tuple = stjs.extend(Tuple, null, [], function(constructor, prototype) {
    constructor._1 = function(v0) {
        this.v0 = v0;
    };
    constructor._1 = stjs.extend(constructor._1, null, [], function(constructor, prototype) {
        prototype.v0 = null;
    }, {}, {});
    constructor._2 = function(v0, v1) {
        this.v0 = v0;
        this.v1 = v1;
    };
    constructor._2 = stjs.extend(constructor._2, null, [], function(constructor, prototype) {
        prototype.v0 = null;
        prototype.v1 = null;
    }, {}, {});
    constructor._3 = function(v0, v1, v2) {
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
    };
    constructor._3 = stjs.extend(constructor._3, null, [], function(constructor, prototype) {
        prototype.v0 = null;
        prototype.v1 = null;
        prototype.v2 = null;
    }, {}, {});
    constructor._4 = function(v0, v1, v2, v3) {
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    };
    constructor._4 = stjs.extend(constructor._4, null, [], function(constructor, prototype) {
        prototype.v0 = null;
        prototype.v1 = null;
        prototype.v2 = null;
        prototype.v3 = null;
    }, {}, {});
    constructor.single = function(v0) {
        return new Tuple._1(v0);
    };
    constructor.pair = function(v0, v1) {
        return new Tuple._2(v0, v1);
    };
    constructor.triple = function(v0, v1, v2) {
        return new Tuple._3(v0, v1, v2);
    };
    constructor.quad = function(v0, v1, v2, v3) {
        return new Tuple._4(v0, v1, v2, v3);
    };
    constructor.asMap = function(it) {
        var result = new HashMap();
        for (var iterator$el = it.iterator(); iterator$el.hasNext(); ) {
            var el = iterator$el.next();
            result.put(el.v0, el.v1);
        }
        return result;
    };
    constructor.arrayAsMap = function(arr) {
        var result = new HashMap();
        for (var i = 0; i < arr.length; i++) {
            var el = arr[i];
            result.put(el.v0, el.v1);
        }
        return result;
    };
    constructor.asList = function(m) {
        var result = new LinkedList();
        var entrySet = m.entrySet();
        for (var iterator$entry = entrySet.iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            result.add(Tuple.pair(entry.getKey(), entry.getValue()));
        }
        return result;
    };
    constructor._1_project0 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_1 = temp.iterator(); iterator$_1.hasNext(); ) {
            var _1 = iterator$_1.next();
            result.add(_1.v0);
        }
        return result;
    };
    constructor._2_project0 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_2 = temp.iterator(); iterator$_2.hasNext(); ) {
            var _2 = iterator$_2.next();
            result.add(_2.v0);
        }
        return result;
    };
    constructor._2_project1 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_2 = temp.iterator(); iterator$_2.hasNext(); ) {
            var _2 = iterator$_2.next();
            result.add(_2.v1);
        }
        return result;
    };
    constructor._3_project0 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_3 = temp.iterator(); iterator$_3.hasNext(); ) {
            var _3 = iterator$_3.next();
            result.add(_3.v0);
        }
        return result;
    };
    constructor._3_project1 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_3 = temp.iterator(); iterator$_3.hasNext(); ) {
            var _3 = iterator$_3.next();
            result.add(_3.v1);
        }
        return result;
    };
    constructor._3_project2 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_3 = temp.iterator(); iterator$_3.hasNext(); ) {
            var _3 = iterator$_3.next();
            result.add(_3.v2);
        }
        return result;
    };
    constructor._4_project0 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_4 = temp.iterator(); iterator$_4.hasNext(); ) {
            var _4 = iterator$_4.next();
            result.add(_4.v0);
        }
        return result;
    };
    constructor._4_project1 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_4 = temp.iterator(); iterator$_4.hasNext(); ) {
            var _4 = iterator$_4.next();
            result.add(_4.v1);
        }
        return result;
    };
    constructor._4_project2 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_4 = temp.iterator(); iterator$_4.hasNext(); ) {
            var _4 = iterator$_4.next();
            result.add(_4.v2);
        }
        return result;
    };
    constructor._4_project3 = function(temp) {
        var result = new LinkedList();
        for (var iterator$_4 = temp.iterator(); iterator$_4.hasNext(); ) {
            var _4 = iterator$_4.next();
            result.add(_4.v3);
        }
        return result;
    };
    constructor.Mapper = function() {};
    constructor.Mapper = stjs.extend(constructor.Mapper, null, [], function(constructor, prototype) {
        prototype.map = function(t) {};
    }, {}, {});
    constructor._1map0 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_1 = l.iterator(); iterator$_1.hasNext(); ) {
            var _1 = iterator$_1.next();
            result.add(Tuple.single(mapper.map(_1.v0)));
        }
        return result;
    };
    constructor._2map0 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_2 = l.iterator(); iterator$_2.hasNext(); ) {
            var _2 = iterator$_2.next();
            result.add(Tuple.pair(mapper.map(_2.v0), _2.v1));
        }
        return result;
    };
    constructor._2map1 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_2 = l.iterator(); iterator$_2.hasNext(); ) {
            var _2 = iterator$_2.next();
            result.add(Tuple.pair(_2.v0, mapper.map(_2.v1)));
        }
        return result;
    };
    constructor._3map0 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_3 = l.iterator(); iterator$_3.hasNext(); ) {
            var _3 = iterator$_3.next();
            result.add(Tuple.triple(mapper.map(_3.v0), _3.v1, _3.v2));
        }
        return result;
    };
    constructor._3map1 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_3 = l.iterator(); iterator$_3.hasNext(); ) {
            var _3 = iterator$_3.next();
            result.add(Tuple.triple(_3.v0, mapper.map(_3.v1), _3.v2));
        }
        return result;
    };
    constructor._3map3 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_3 = l.iterator(); iterator$_3.hasNext(); ) {
            var _3 = iterator$_3.next();
            result.add(Tuple.triple(_3.v0, _3.v1, mapper.map(_3.v2)));
        }
        return result;
    };
    constructor._4map0 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_4 = l.iterator(); iterator$_4.hasNext(); ) {
            var _4 = iterator$_4.next();
            result.add(Tuple.quad(mapper.map(_4.v0), _4.v1, _4.v2, _4.v3));
        }
        return result;
    };
    constructor._4map1 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_4 = l.iterator(); iterator$_4.hasNext(); ) {
            var _4 = iterator$_4.next();
            result.add(Tuple.quad(_4.v0, mapper.map(_4.v1), _4.v2, _4.v3));
        }
        return result;
    };
    constructor._4map3 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_4 = l.iterator(); iterator$_4.hasNext(); ) {
            var _4 = iterator$_4.next();
            result.add(Tuple.quad(_4.v0, _4.v1, mapper.map(_4.v2), _4.v3));
        }
        return result;
    };
    constructor._4map4 = function(l, mapper) {
        var result = new LinkedList();
        for (var iterator$_4 = l.iterator(); iterator$_4.hasNext(); ) {
            var _4 = iterator$_4.next();
            result.add(Tuple.quad(_4.v0, _4.v1, _4.v2, mapper.map(_4.v3)));
        }
        return result;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  The list of formats known to JCodec
 *  
 *  @author The JCodec project
 *  
 */
var Format = function(name, video, audio) {
    this.name = name;
    this.video = video;
    this.audio = audio;
};
Format = stjs.extend(Format, null, [], function(constructor, prototype) {
    constructor.MOV = new Format("MOV", true, true);
    constructor.MPEG_PS = new Format("MPEG_PS", true, true);
    constructor.MPEG_TS = new Format("MPEG_TS", true, true);
    constructor.MKV = new Format("MKV", true, true);
    constructor.H264 = new Format("H264", true, false);
    constructor.RAW = new Format("RAW", true, true);
    constructor.FLV = new Format("FLV", true, true);
    constructor.AVI = new Format("AVI", true, true);
    constructor.IMG = new Format("IMG", true, false);
    constructor.IVF = new Format("IVF", true, false);
    constructor.MJPEG = new Format("MJPEG", true, false);
    constructor.Y4M = new Format("Y4M", true, false);
    constructor.WAV = new Format("WAV", false, true);
    constructor.WEBP = new Format("WEBP", true, false);
    constructor.MPEG_AUDIO = new Format("MPEG_AUDIO", false, true);
    constructor._values = new LinkedHashMap();
    prototype.video = false;
    prototype.audio = false;
    prototype.name = null;
    prototype.isAudio = function() {
        return this.audio;
    };
    prototype.isVideo = function() {
        return this.video;
    };
    constructor.valueOf = function(s) {
        return Format._values.get(s);
    };
}, {MOV: "Format", MPEG_PS: "Format", MPEG_TS: "Format", MKV: "Format", H264: "Format", RAW: "Format", FLV: "Format", AVI: "Format", IMG: "Format", IVF: "Format", MJPEG: "Format", Y4M: "Format", WAV: "Format", WEBP: "Format", MPEG_AUDIO: "Format", _values: {name: "Map", arguments: [null, "Format"]}}, {});
(function() {
    Format._values.put("MOV", Format.MOV);
    Format._values.put("MPEG_PS", Format.MPEG_PS);
    Format._values.put("MPEG_TS", Format.MPEG_TS);
    Format._values.put("MKV", Format.MKV);
    Format._values.put("H264", Format.H264);
    Format._values.put("RAW", Format.RAW);
    Format._values.put("FLV", Format.FLV);
    Format._values.put("AVI", Format.AVI);
    Format._values.put("IMG", Format.IMG);
    Format._values.put("IVF", Format.IVF);
    Format._values.put("MJPEG", Format.MJPEG);
    Format._values.put("Y4M", Format.Y4M);
    Format._values.put("WAV", Format.WAV);
    Format._values.put("WEBP", Format.WEBP);
    Format._values.put("MPEG_AUDIO", Format.MPEG_AUDIO);
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 * 
 *  @author The JCodec project
 */
var Codec = function(type) {
    this.type = type;
};
Codec = stjs.extend(Codec, null, [], function(constructor, prototype) {
    constructor.H264 = new Codec(TrackType.VIDEO);
    constructor.MPEG2 = new Codec(TrackType.VIDEO);
    constructor.MPEG4 = new Codec(TrackType.VIDEO);
    constructor.PRORES = new Codec(TrackType.VIDEO);
    constructor.DV = new Codec(TrackType.VIDEO);
    constructor.VC1 = new Codec(TrackType.VIDEO);
    constructor.VC3 = new Codec(TrackType.VIDEO);
    constructor.V210 = new Codec(TrackType.VIDEO);
    constructor.SORENSON = new Codec(TrackType.VIDEO);
    constructor.FLASH_SCREEN_VIDEO = new Codec(TrackType.VIDEO);
    constructor.FLASH_SCREEN_V2 = new Codec(TrackType.VIDEO);
    constructor.PNG = new Codec(TrackType.VIDEO);
    constructor.JPEG = new Codec(TrackType.VIDEO);
    constructor.J2K = new Codec(TrackType.VIDEO);
    constructor.VP6 = new Codec(TrackType.VIDEO);
    constructor.VP8 = new Codec(TrackType.VIDEO);
    constructor.VP9 = new Codec(TrackType.VIDEO);
    constructor.VORBIS = new Codec(TrackType.VIDEO);
    constructor.AAC = new Codec(TrackType.AUDIO);
    constructor.MP3 = new Codec(TrackType.AUDIO);
    constructor.MP2 = new Codec(TrackType.AUDIO);
    constructor.MP1 = new Codec(TrackType.AUDIO);
    constructor.AC3 = new Codec(TrackType.AUDIO);
    constructor.DTS = new Codec(TrackType.AUDIO);
    constructor.TRUEHD = new Codec(TrackType.AUDIO);
    constructor.PCM_DVD = new Codec(TrackType.AUDIO);
    constructor.PCM = new Codec(TrackType.AUDIO);
    constructor.ADPCM = new Codec(TrackType.AUDIO);
    constructor.ALAW = new Codec(TrackType.AUDIO);
    constructor.NELLYMOSER = new Codec(TrackType.AUDIO);
    constructor.G711 = new Codec(TrackType.AUDIO);
    constructor.SPEEX = new Codec(TrackType.AUDIO);
    constructor.RAW = new Codec(null);
    constructor.TIMECODE = new Codec(TrackType.OTHER);
    constructor._values = new LinkedHashMap();
    prototype.type = null;
    prototype.getType = function() {
        return this.type;
    };
    constructor.codecByFourcc = function(fourcc) {
        if (fourcc.equals("avc1")) {
            return Codec.H264;
        } else if (fourcc.equals("m1v1") || fourcc.equals("m2v1")) {
            return Codec.MPEG2;
        } else if (fourcc.equals("apco") || fourcc.equals("apcs") || fourcc.equals("apcn") || fourcc.equals("apch") || fourcc.equals("ap4h")) {
            return Codec.PRORES;
        } else if (fourcc.equals("mp4a")) {
            return Codec.AAC;
        } else if (fourcc.equals("jpeg")) {
            return Codec.JPEG;
        }
        return null;
    };
    constructor.valueOf = function(s) {
        return Codec._values.get(s);
    };
}, {H264: "Codec", MPEG2: "Codec", MPEG4: "Codec", PRORES: "Codec", DV: "Codec", VC1: "Codec", VC3: "Codec", V210: "Codec", SORENSON: "Codec", FLASH_SCREEN_VIDEO: "Codec", FLASH_SCREEN_V2: "Codec", PNG: "Codec", JPEG: "Codec", J2K: "Codec", VP6: "Codec", VP8: "Codec", VP9: "Codec", VORBIS: "Codec", AAC: "Codec", MP3: "Codec", MP2: "Codec", MP1: "Codec", AC3: "Codec", DTS: "Codec", TRUEHD: "Codec", PCM_DVD: "Codec", PCM: "Codec", ADPCM: "Codec", ALAW: "Codec", NELLYMOSER: "Codec", G711: "Codec", SPEEX: "Codec", RAW: "Codec", TIMECODE: "Codec", _values: {name: "Map", arguments: [null, "Codec"]}, type: {name: "Enum", arguments: ["TrackType"]}}, {});
(function() {
    Codec._values.put("H264", Codec.H264);
    Codec._values.put("MPEG2", Codec.MPEG2);
    Codec._values.put("MPEG4", Codec.MPEG4);
    Codec._values.put("PRORES", Codec.PRORES);
    Codec._values.put("DV", Codec.DV);
    Codec._values.put("VC1", Codec.VC1);
    Codec._values.put("VC3", Codec.VC3);
    Codec._values.put("V210", Codec.V210);
    Codec._values.put("SORENSON", Codec.SORENSON);
    Codec._values.put("FLASH_SCREEN_VIDEO", Codec.FLASH_SCREEN_VIDEO);
    Codec._values.put("FLASH_SCREEN_V2", Codec.FLASH_SCREEN_V2);
    Codec._values.put("PNG", Codec.PNG);
    Codec._values.put("JPEG", Codec.JPEG);
    Codec._values.put("J2K", Codec.J2K);
    Codec._values.put("VP6", Codec.VP6);
    Codec._values.put("VP8", Codec.VP8);
    Codec._values.put("VP9", Codec.VP9);
    Codec._values.put("VORBIS", Codec.VORBIS);
    Codec._values.put("AAC", Codec.AAC);
    Codec._values.put("MP3", Codec.MP3);
    Codec._values.put("MP2", Codec.MP2);
    Codec._values.put("MP1", Codec.MP1);
    Codec._values.put("AC3", Codec.AC3);
    Codec._values.put("DTS", Codec.DTS);
    Codec._values.put("TRUEHD", Codec.TRUEHD);
    Codec._values.put("PCM_DVD", Codec.PCM_DVD);
    Codec._values.put("PCM", Codec.PCM);
    Codec._values.put("ADPCM", Codec.ADPCM);
    Codec._values.put("ALAW", Codec.ALAW);
    Codec._values.put("NELLYMOSER", Codec.NELLYMOSER);
    Codec._values.put("G711", Codec.G711);
    Codec._values.put("SPEEX", Codec.SPEEX);
    Codec._values.put("RAW", Codec.RAW);
    Codec._values.put("TIMECODE", Codec.TIMECODE);
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Encodes image data into raw bytes according to the color space.
 *  
 *  @author The JCodec project
 *  
 */
var RAWVideoEncoder = function() {
    VideoEncoder.call(this);
};
RAWVideoEncoder = stjs.extend(RAWVideoEncoder, VideoEncoder, [], function(constructor, prototype) {
    prototype.encodeFrame = function(pic, _out) {
        var dup = _out.duplicate();
        var color = pic.getColor();
        if (color.planar) {
            for (var plane = 0; plane < color.nComp; plane++) {
                var width = pic.getWidth() >> color.compWidth[plane];
                var startX = pic.getStartX();
                var startY = pic.getStartY();
                var cropW = pic.getCroppedWidth() >> color.compWidth[plane];
                var cropH = pic.getCroppedHeight() >> color.compHeight[plane];
                var planeData = pic.getPlaneData(plane);
                var pos = width * startY + startX;
                for (var y = 0; y < cropH; y++) {
                    for (var x = 0; x < cropW; x++) {
                        dup.put(((planeData[pos + x] + 128) << 24 >> 24));
                    }
                    pos += width;
                }
            }
        } else {
            var bytesPerPixel = (color.bitsPerPixel + 7) >> 3;
            var stride = pic.getWidth() * bytesPerPixel;
            var startX = pic.getStartX();
            var startY = pic.getStartY();
            var cropW = pic.getCroppedWidth();
            var cropH = pic.getCroppedHeight();
            var planeData = pic.getPlaneData(0);
            var pos = stride * startY + startX * bytesPerPixel;
            for (var y = 0; y < cropH; y++) {
                for (var x = 0, off = 0; x < cropW; x++ , off += bytesPerPixel) {
                    for (var b = 0; b < bytesPerPixel; b++) 
                        dup.put(((planeData[pos + off + b] + 128) << 24 >> 24));
                }
                pos += stride;
            }
        }
        dup.flip();
        return new VideoEncoder.EncodedFrame(dup, true);
    };
    prototype.getSupportedColorSpaces = function() {
        return null;
    };
    prototype.estimateBufferSize = function(frame) {
        var fullPlaneSize = frame.getWidth() * frame.getCroppedHeight();
        var color = frame.getColor();
        var totalSize = 0;
        for (var i = 0; i < color.nComp; i++) {
            totalSize += (fullPlaneSize >> color.compWidth[i]) >> color.compHeight[i];
        }
        return totalSize;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  H.264 rate control policy that would produce frames of exactly equal size
 *  
 *  @author The JCodec project
 *  
 */
var H264FixedRateControl = function(bitsPer256) {
    this.perMb = bitsPer256;
    this.curQp = H264FixedRateControl.INIT_QP;
};
H264FixedRateControl = stjs.extend(H264FixedRateControl, null, [RateControl], function(constructor, prototype) {
    constructor.INIT_QP = 26;
    prototype.balance = 0;
    prototype.perMb = 0;
    prototype.curQp = 0;
    prototype.startPicture = function(sz, maxSize, sliceType) {
        return H264FixedRateControl.INIT_QP + (sliceType == SliceType.P ? 4 : 0);
    };
    prototype.initialQpDelta = function() {
        var qpDelta = this.balance < 0 ? (this.balance < -(this.perMb >> 1) ? 2 : 1) : (this.balance > this.perMb ? (this.balance > (this.perMb << 2) ? -2 : -1) : 0);
        var prevQp = this.curQp;
        this.curQp = MathUtil.clip(this.curQp + qpDelta, 12, 30);
        return this.curQp - prevQp;
    };
    prototype.accept = function(bits) {
        this.balance += this.perMb - bits;
        return 0;
    };
    prototype.reset = function() {
        this.balance = 0;
        this.curQp = H264FixedRateControl.INIT_QP;
    };
    prototype.calcFrameSize = function(nMB) {
        return ((256 + nMB * (this.perMb + 9)) >> 3) + (nMB >> 6);
    };
    prototype.setRate = function(rate) {
        this.perMb = rate;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 * 
 *  Dumb rate control policy, always maintains the same QP for the whole video
 *  
 *  @author The JCodec project
 *  
 */
var DumbRateControl = function() {};
DumbRateControl = stjs.extend(DumbRateControl, null, [RateControl], function(constructor, prototype) {
    constructor.QP = 20;
    prototype.bitsPerMb = 0;
    prototype.totalQpDelta = 0;
    prototype.justSwitched = false;
    prototype.accept = function(bits) {
        if (bits >= this.bitsPerMb) {
            this.totalQpDelta++;
            this.justSwitched = true;
            return 1;
        } else {
            if (this.totalQpDelta > 0 && !this.justSwitched && (this.bitsPerMb - bits > (this.bitsPerMb >> 3))) {
                --this.totalQpDelta;
                this.justSwitched = true;
                return -1;
            } else {
                this.justSwitched = false;
            }
            return 0;
        }
    };
    prototype.startPicture = function(sz, maxSize, sliceType) {
        var totalMb = ((sz.getWidth() + 15) >> 4) * ((sz.getHeight() + 15) >> 4);
        this.bitsPerMb = stjs.trunc((maxSize << 3) / totalMb);
        this.totalQpDelta = 0;
        this.justSwitched = false;
        return DumbRateControl.QP + (sliceType == SliceType.P ? 6 : 0);
    };
    prototype.initialQpDelta = function() {
        return 0;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var S302MUtils = function() {};
S302MUtils = stjs.extend(S302MUtils, null, [], function(constructor, prototype) {
    constructor.name = function(channels) {
        switch (channels) {
            case 1:
                return "Mono";
            case 2:
                return "Stereo 2.0";
            case 4:
                return "Surround 4.0";
            case 8:
                return "Stereo 2.0 + Surround 5.1";
        }
        return null;
    };
    constructor.labels = function(channels) {
        switch (channels) {
            case 1:
                return [ChannelLabel.MONO];
            case 2:
                return [ChannelLabel.STEREO_LEFT, ChannelLabel.STEREO_RIGHT];
            case 4:
                return [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT];
            case 8:
                return [ChannelLabel.STEREO_LEFT, ChannelLabel.STEREO_RIGHT, ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT, ChannelLabel.CENTER, ChannelLabel.LFE];
        }
        return null;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FilterUtil = function() {};
FilterUtil = stjs.extend(FilterUtil, null, [], function(constructor, prototype) {
    /**
     *   Clamp, then convert signed number back to pixel value. 
     */
    constructor.clipPlus128 = function(v) {
        return stjs.trunc((FilterUtil.clipSigned(v) + 128));
    };
    constructor.Segment = function() {};
    constructor.Segment = stjs.extend(constructor.Segment, null, [], function(constructor, prototype) {
        /**
         *  pixels before edge
         */
        prototype.p0 = 0;
        /**
         *  pixels before edge
         */
        prototype.p1 = 0;
        /**
         *  pixels before edge
         */
        prototype.p2 = 0;
        /**
         *  pixels before edge
         */
        prototype.p3 = 0;
        /**
         *  pixels after edge
         */
        prototype.q0 = 0;
        /**
         *  pixels after edge
         */
        prototype.q1 = 0;
        /**
         *  pixels after edge
         */
        prototype.q2 = 0;
        /**
         *  pixels after edge
         */
        prototype.q3 = 0;
        /**
         *  All functions take (among other things) a segment (of length at most 4 + 4 = 8) symmetrically 
         *  straddling an edge. The pixel values (or pointers) are always given in order, from the 
         *  "beforemost" to the "aftermost". So, for a horizontal edge (written "|"), an 8-pixel segment 
         *  would be ordered p3 p2 p1 p0 | q0 q1 q2 q3.
         * 
         *  Filtering is disabled if the difference between any two adjacent "interior" pixels in the 
         *  8-pixel segment exceeds the relevant threshold (I). A more complex thresholding calculation 
         *  is done for the group of four pixels that straddle the edge, in line with the calculation in simple_segment() above.
         *  @interior limit on interior differences 
         *  @edge limit at the edge 
         */
        prototype.isFilterRequired = function(interior, edge) {
            return ((Math.abs(this.p0 - this.q0) << 2) + (Math.abs(this.p1 - this.q1) >> 2)) <= edge && Math.abs(this.p3 - this.p2) <= interior && Math.abs(this.p2 - this.p1) <= interior && Math.abs(this.p1 - this.p0) <= interior && Math.abs(this.q3 - this.q2) <= interior && Math.abs(this.q2 - this.q1) <= interior && Math.abs(this.q1 - this.q0) <= interior;
        };
        /**
         *   HEV - Hight Edge Variance. Filtering is altered 
         *   if (at least) one of the differences on either side of 
         *   the edge exceeds a threshold (we have "high edge variance").
         *  @param threshold
         *  @param p1 before
         *  @param p0 before
         *  @param q0 after
         *  @param q1 after
         *  @return
         */
        prototype.isHighVariance = function(threshold) {
            return Math.abs(this.p1 - this.p0) > threshold || Math.abs(this.q1 - this.q0) > threshold;
        };
        prototype.getSigned = function() {
            var seg = new FilterUtil.Segment();
            seg.p3 = FilterUtil.minus128(this.p3);
            seg.p2 = FilterUtil.minus128(this.p2);
            seg.p1 = FilterUtil.minus128(this.p1);
            seg.p0 = FilterUtil.minus128(this.p0);
            seg.q0 = FilterUtil.minus128(this.q0);
            seg.q1 = FilterUtil.minus128(this.q1);
            seg.q2 = FilterUtil.minus128(this.q2);
            seg.q3 = FilterUtil.minus128(this.q3);
            return seg;
        };
        constructor.horizontal = function(right, left, a) {
            var seg = new FilterUtil.Segment();
            seg.p0 = left.val[3 * 4 + a];
            seg.p1 = left.val[2 * 4 + a];
            seg.p2 = left.val[1 * 4 + a];
            seg.p3 = left.val[0 * 4 + a];
            seg.q0 = right.val[0 * 4 + a];
            seg.q1 = right.val[1 * 4 + a];
            seg.q2 = right.val[2 * 4 + a];
            seg.q3 = right.val[3 * 4 + a];
            return seg;
        };
        constructor.vertical = function(lower, upper, a) {
            var seg = new FilterUtil.Segment();
            seg.p0 = upper.val[a * 4 + 3];
            seg.p1 = upper.val[a * 4 + 2];
            seg.p2 = upper.val[a * 4 + 1];
            seg.p3 = upper.val[a * 4 + 0];
            seg.q0 = lower.val[a * 4 + 0];
            seg.q1 = lower.val[a * 4 + 1];
            seg.q2 = lower.val[a * 4 + 2];
            seg.q3 = lower.val[a * 4 + 3];
            return seg;
        };
        prototype.applyHorizontally = function(right, left, a) {
            left.val[3 * 4 + a] = this.p0;
            left.val[2 * 4 + a] = this.p1;
            left.val[1 * 4 + a] = this.p2;
            left.val[0 * 4 + a] = this.p3;
            right.val[0 * 4 + a] = this.q0;
            right.val[1 * 4 + a] = this.q1;
            right.val[2 * 4 + a] = this.q2;
            right.val[3 * 4 + a] = this.q3;
        };
        prototype.applyVertically = function(lower, upper, a) {
            upper.val[a * 4 + 3] = this.p0;
            upper.val[a * 4 + 2] = this.p1;
            upper.val[a * 4 + 1] = this.p2;
            upper.val[a * 4 + 0] = this.p3;
            lower.val[a * 4 + 0] = this.q0;
            lower.val[a * 4 + 1] = this.q1;
            lower.val[a * 4 + 2] = this.q2;
            lower.val[a * 4 + 3] = this.q3;
        };
        /**
         *  
         *  @param hevThreshold detect high edge variance
         *  @param interiorLimit possibly disable filter
         *  @param edgeLimit
         *  @param this
         */
        prototype.filterMb = function(hevThreshold, interiorLimit, edgeLimit) {
            var signedSeg = this.getSigned();
            if (signedSeg.isFilterRequired(interiorLimit, edgeLimit)) {
                if (!signedSeg.isHighVariance(hevThreshold)) {
                    var w = FilterUtil.clipSigned(FilterUtil.clipSigned(signedSeg.p1 - signedSeg.q1) + 3 * (signedSeg.q0 - signedSeg.p0));
                    var a = (27 * w + 63) >> 7;
                    this.q0 = FilterUtil.clipPlus128(signedSeg.q0 - a);
                    this.p0 = FilterUtil.clipPlus128(signedSeg.p0 + a);
                    a = (18 * w + 63) >> 7;
                    this.q1 = FilterUtil.clipPlus128(signedSeg.q1 - a);
                    this.p1 = FilterUtil.clipPlus128(signedSeg.p1 + a);
                    a = (9 * w + 63) >> 7;
                    this.q2 = FilterUtil.clipPlus128(signedSeg.q2 - a);
                    this.p2 = FilterUtil.clipPlus128(signedSeg.p2 + a);
                } else 
                    this.adjust(true);
            }
        };
        /**
         *  
         *  @param hev_threshold detect high edge variance
         *  @param interior_limit disable filter
         *  @param edge_limit
         *  @param this
         */
        prototype.filterSb = function(hev_threshold, interior_limit, edge_limit) {
            var signedSeg = this.getSigned();
            if (signedSeg.isFilterRequired(interior_limit, edge_limit)) {
                var hv = signedSeg.isHighVariance(hev_threshold);
                var a = (this.adjust(hv) + 1) >> 1;
                if (!hv) {
                    this.q1 = FilterUtil.clipPlus128(signedSeg.q1 - a);
                    this.p1 = FilterUtil.clipPlus128(signedSeg.p1 + a);
                }
            }
        };
        /**
         *  filter is 2 or 4 taps wide
         */
        prototype.adjust = function(use_outer_taps) {
            var p1 = FilterUtil.minus128(this.p1);
            var p0 = FilterUtil.minus128(this.p0);
            var q0 = FilterUtil.minus128(this.q0);
            var q1 = FilterUtil.minus128(this.q1);
            var a = FilterUtil.clipSigned((use_outer_taps ? FilterUtil.clipSigned(p1 - q1) : 0) + 3 * (q0 - p0));
            var b = (FilterUtil.clipSigned(a + 3)) >> 3;
            a = FilterUtil.clipSigned(a + 4) >> 3;
            this.q0 = FilterUtil.clipPlus128(q0 - a);
            this.p0 = FilterUtil.clipPlus128(p0 + b);
            return a;
        };
    }, {}, {});
    constructor.clipSigned = function(v) {
        return stjs.trunc((v < -128 ? -128 : (v > 127 ? 127 : v)));
    };
    constructor.minus128 = function(v) {
        return stjs.trunc((v - 128));
    };
    constructor.loopFilterUV = function(mbs, sharpnessLevel, keyFrame) {
        for (var y = 0; y < (mbs.length - 2); y++) {
            for (var x = 0; x < (mbs[0].length - 2); x++) {
                var rmb = mbs[y + 1][x + 1];
                var bmb = mbs[y + 1][x + 1];
                var loop_filter_level = rmb.filterLevel;
                if (loop_filter_level != 0) {
                    var interior_limit = rmb.filterLevel;
                    if (sharpnessLevel > 0) {
                        interior_limit >>= sharpnessLevel > 4 ? 2 : 1;
                        if (interior_limit > 9 - sharpnessLevel) 
                            interior_limit = 9 - sharpnessLevel;
                    }
                    if (interior_limit == 0) 
                        interior_limit = 1;
                    var hev_threshold = 0;
                    if (keyFrame) {
                        if (loop_filter_level >= 40) 
                            hev_threshold = 2;
                         else if (loop_filter_level >= 15) 
                            hev_threshold = 1;
                    } else {
                         throw new NotImplementedException("TODO: non-key frames are not supported yet.");
                    }
                    var mbedge_limit = ((loop_filter_level + 2) * 2) + interior_limit;
                    var sub_bedge_limit = (loop_filter_level * 2) + interior_limit;
                    if (x > 0) {
                        var lmb = mbs[y + 1][x + 1 - 1];
                        for (var b = 0; b < 2; b++) {
                            var rsbU = rmb.uSubblocks[b][0];
                            var lsbU = lmb.uSubblocks[b][1];
                            var rsbV = rmb.vSubblocks[b][0];
                            var lsbV = lmb.vSubblocks[b][1];
                            for (var a = 0; a < 4; a++) {
                                var seg = FilterUtil.Segment.horizontal(rsbU, lsbU, a);
                                seg.filterMb(hev_threshold, interior_limit, mbedge_limit);
                                seg.applyHorizontally(rsbU, lsbU, a);
                                seg = FilterUtil.Segment.horizontal(rsbV, lsbV, a);
                                seg.filterMb(hev_threshold, interior_limit, mbedge_limit);
                                seg.applyHorizontally(rsbV, lsbV, a);
                            }
                        }
                    }
                    if (!rmb.skipFilter) {
                        for (var a = 1; a < 2; a++) {
                            for (var b = 0; b < 2; b++) {
                                var lsbU = rmb.uSubblocks[b][a - 1];
                                var rsbU = rmb.uSubblocks[b][a];
                                var lsbV = rmb.vSubblocks[b][a - 1];
                                var rsbV = rmb.vSubblocks[b][a];
                                for (var c = 0; c < 4; c++) {
                                    var seg = FilterUtil.Segment.horizontal(rsbU, lsbU, c);
                                    seg.filterSb(hev_threshold, interior_limit, sub_bedge_limit);
                                    seg.applyHorizontally(rsbU, lsbU, c);
                                    seg = FilterUtil.Segment.horizontal(rsbV, lsbV, c);
                                    seg.filterSb(hev_threshold, interior_limit, sub_bedge_limit);
                                    seg.applyHorizontally(rsbV, lsbV, c);
                                }
                            }
                        }
                    }
                    if (y > 0) {
                        var tmb = mbs[y + 1 - 1][x + 1];
                        for (var b = 0; b < 2; b++) {
                            var tsbU = tmb.uSubblocks[1][b];
                            var bsbU = bmb.uSubblocks[0][b];
                            var tsbV = tmb.vSubblocks[1][b];
                            var bsbV = bmb.vSubblocks[0][b];
                            for (var a = 0; a < 4; a++) {
                                var seg = FilterUtil.Segment.vertical(bsbU, tsbU, a);
                                seg.filterMb(hev_threshold, interior_limit, mbedge_limit);
                                seg.applyVertically(bsbU, tsbU, a);
                                seg = FilterUtil.Segment.vertical(bsbV, tsbV, a);
                                seg.filterMb(hev_threshold, interior_limit, mbedge_limit);
                                seg.applyVertically(bsbV, tsbV, a);
                            }
                        }
                    }
                    if (!rmb.skipFilter) {
                        for (var a = 1; a < 2; a++) {
                            for (var b = 0; b < 2; b++) {
                                var tsbU = bmb.uSubblocks[a - 1][b];
                                var bsbU = bmb.uSubblocks[a][b];
                                var tsbV = bmb.vSubblocks[a - 1][b];
                                var bsbV = bmb.vSubblocks[a][b];
                                for (var c = 0; c < 4; c++) {
                                    var seg = FilterUtil.Segment.vertical(bsbU, tsbU, c);
                                    seg.filterSb(hev_threshold, interior_limit, sub_bedge_limit);
                                    seg.applyVertically(bsbU, tsbU, c);
                                    seg = FilterUtil.Segment.vertical(bsbV, tsbV, c);
                                    seg.filterSb(hev_threshold, interior_limit, sub_bedge_limit);
                                    seg.applyVertically(bsbV, tsbV, c);
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    constructor.loopFilterY = function(mbs, sharpnessLevel, keyFrame) {
        for (var y = 0; y < (mbs.length - 2); y++) {
            for (var x = 0; x < (mbs[0].length - 2); x++) {
                var rmb = mbs[y + 1][x + 1];
                var bmb = mbs[y + 1][x + 1];
                var loopFilterLevel = rmb.filterLevel;
                if (loopFilterLevel != 0) {
                    var interiorLimit = rmb.filterLevel;
                    if (sharpnessLevel > 0) {
                        interiorLimit >>= sharpnessLevel > 4 ? 2 : 1;
                        if (interiorLimit > 9 - sharpnessLevel) 
                            interiorLimit = 9 - sharpnessLevel;
                    }
                    if (interiorLimit == 0) 
                        interiorLimit = 1;
                    var varianceThreshold = 0;
                    if (keyFrame) {
                        if (loopFilterLevel >= 40) 
                            varianceThreshold = 2;
                         else if (loopFilterLevel >= 15) 
                            varianceThreshold = 1;
                    } else {
                         throw new NotImplementedException("TODO: non-key frames are not supported yet");
                    }
                    var edgeLimitMb = ((loopFilterLevel + 2) * 2) + interiorLimit;
                    var edgeLimitSb = (loopFilterLevel * 2) + interiorLimit;
                    if (x > 0) {
                        var lmb = mbs[y + 1][x - 1 + 1];
                        for (var b = 0; b < 4; b++) {
                            var rsb = rmb.ySubblocks[b][0];
                            var lsb = lmb.ySubblocks[b][3];
                            for (var a = 0; a < 4; a++) {
                                var seg = FilterUtil.Segment.horizontal(rsb, lsb, a);
                                seg.filterMb(varianceThreshold, interiorLimit, edgeLimitMb);
                                seg.applyHorizontally(rsb, lsb, a);
                            }
                        }
                    }
                    if (!rmb.skipFilter) {
                        for (var a = 1; a < 4; a++) {
                            for (var b = 0; b < 4; b++) {
                                var lsb = rmb.ySubblocks[b][a - 1];
                                var rsb = rmb.ySubblocks[b][a];
                                for (var c = 0; c < 4; c++) {
                                    var seg = FilterUtil.Segment.horizontal(rsb, lsb, c);
                                    seg.filterSb(varianceThreshold, interiorLimit, edgeLimitSb);
                                    seg.applyHorizontally(rsb, lsb, c);
                                }
                            }
                        }
                    }
                    if (y > 0) {
                        var tmb = mbs[y - 1 + 1][x + 1];
                        for (var b = 0; b < 4; b++) {
                            var tsb = tmb.ySubblocks[3][b];
                            var bsb = bmb.ySubblocks[0][b];
                            for (var a = 0; a < 4; a++) {
                                var seg = FilterUtil.Segment.vertical(bsb, tsb, a);
                                seg.filterMb(varianceThreshold, interiorLimit, edgeLimitMb);
                                seg.applyVertically(bsb, tsb, a);
                            }
                        }
                    }
                    if (!rmb.skipFilter) {
                        for (var a = 1; a < 4; a++) {
                            for (var b = 0; b < 4; b++) {
                                var tsb = bmb.ySubblocks[a - 1][b];
                                var bsb = bmb.ySubblocks[a][b];
                                for (var c = 0; c < 4; c++) {
                                    var seg = FilterUtil.Segment.vertical(bsb, tsb, c);
                                    seg.filterSb(varianceThreshold, interiorLimit, edgeLimitSb);
                                    seg.applyVertically(bsb, tsb, c);
                                }
                            }
                        }
                    }
                }
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEG4Consts = function() {};
MPEG4Consts = stjs.extend(MPEG4Consts, null, [], function(constructor, prototype) {
    constructor.ZERO_MV = Macroblock.vec();
    constructor.BS_VERSION_BUGGY_DC_CLIP = 34;
    constructor.MODE_INTER = 0;
    constructor.MODE_INTER_Q = 1;
    constructor.MODE_INTER4V = 2;
    constructor.MODE_INTRA = 3;
    constructor.MODE_INTRA_Q = 4;
    constructor.MODE_NOT_CODED = 16;
    constructor.MODE_NOT_CODED_GMC = 17;
    constructor.MODE_DIRECT = 0;
    constructor.MODE_INTERPOLATE = 1;
    constructor.MODE_BACKWARD = 2;
    constructor.MODE_FORWARD = 3;
    constructor.MODE_DIRECT_NONE_MV = 4;
    constructor.MODE_DIRECT_NO4V = 5;
    constructor.ROUNDTAB_76 = new Int32Array([0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1]);
    constructor.ROUNDTAB_79 = new Int32Array([0, 1, 0, 0]);
    constructor.ALT_CHROMA_ROUNDING = 1;
    constructor.INTRA_DC_THRESHOLD_TABLE = new Int32Array([32, 13, 15, 17, 19, 21, 23, 1]);
    constructor.DEFAULT_INTRA_MATRIX = new Int16Array([8, 17, 18, 19, 21, 23, 25, 27, 17, 18, 19, 21, 23, 25, 27, 28, 20, 21, 22, 23, 24, 26, 28, 30, 21, 22, 23, 24, 26, 28, 30, 32, 22, 23, 24, 26, 28, 30, 32, 35, 23, 24, 26, 28, 30, 32, 35, 38, 25, 26, 28, 30, 32, 35, 38, 41, 27, 28, 30, 32, 35, 38, 41, 45]);
    constructor.DEFAULT_INTER_MATRIX = new Int16Array([16, 17, 18, 19, 20, 21, 22, 23, 17, 18, 19, 20, 21, 22, 23, 24, 18, 19, 20, 21, 22, 23, 24, 25, 19, 20, 21, 22, 23, 24, 26, 27, 20, 21, 22, 23, 25, 26, 27, 28, 21, 22, 23, 24, 26, 27, 28, 30, 22, 23, 24, 26, 27, 28, 30, 31, 23, 24, 25, 27, 28, 30, 31, 33]);
    constructor.MCBPC_INTRA_TABLE = [new Int32Array([-1, 0]), new Int32Array([20, 6]), new Int32Array([36, 6]), new Int32Array([52, 6]), new Int32Array([4, 4]), new Int32Array([4, 4]), new Int32Array([4, 4]), new Int32Array([4, 4]), new Int32Array([19, 3]), new Int32Array([19, 3]), new Int32Array([19, 3]), new Int32Array([19, 3]), new Int32Array([19, 3]), new Int32Array([19, 3]), new Int32Array([19, 3]), new Int32Array([19, 3]), new Int32Array([35, 3]), new Int32Array([35, 3]), new Int32Array([35, 3]), new Int32Array([35, 3]), new Int32Array([35, 3]), new Int32Array([35, 3]), new Int32Array([35, 3]), new Int32Array([35, 3]), new Int32Array([51, 3]), new Int32Array([51, 3]), new Int32Array([51, 3]), new Int32Array([51, 3]), new Int32Array([51, 3]), new Int32Array([51, 3]), new Int32Array([51, 3]), new Int32Array([51, 3]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1]), new Int32Array([3, 1])];
    constructor.MCBPC_INTER_TABLE = [new Int32Array([-1, 0]), new Int32Array([255, 9]), new Int32Array([52, 9]), new Int32Array([36, 9]), new Int32Array([20, 9]), new Int32Array([49, 9]), new Int32Array([35, 8]), new Int32Array([35, 8]), new Int32Array([19, 8]), new Int32Array([19, 8]), new Int32Array([50, 8]), new Int32Array([50, 8]), new Int32Array([51, 7]), new Int32Array([51, 7]), new Int32Array([51, 7]), new Int32Array([51, 7]), new Int32Array([34, 7]), new Int32Array([34, 7]), new Int32Array([34, 7]), new Int32Array([34, 7]), new Int32Array([18, 7]), new Int32Array([18, 7]), new Int32Array([18, 7]), new Int32Array([18, 7]), new Int32Array([33, 7]), new Int32Array([33, 7]), new Int32Array([33, 7]), new Int32Array([33, 7]), new Int32Array([17, 7]), new Int32Array([17, 7]), new Int32Array([17, 7]), new Int32Array([17, 7]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([48, 6]), new Int32Array([48, 6]), new Int32Array([48, 6]), new Int32Array([48, 6]), new Int32Array([48, 6]), new Int32Array([48, 6]), new Int32Array([48, 6]), new Int32Array([48, 6]), new Int32Array([3, 5]), new Int32Array([3, 5]), new Int32Array([3, 5]), new Int32Array([3, 5]), new Int32Array([3, 5]), new Int32Array([3, 5]), new Int32Array([3, 5]), new Int32Array([3, 5]), new Int32Array([3, 5]), new Int32Array([3, 5]), new Int32Array([3, 5]), new Int32Array([3, 5]), new Int32Array([3, 5]), new Int32Array([3, 5]), new Int32Array([3, 5]), new Int32Array([3, 5]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([32, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([16, 4]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([1, 3]), new Int32Array([0, 1])];
    constructor.CBPY_TABLE = [new Int32Array([-1, 0]), new Int32Array([-1, 0]), new Int32Array([6, 6]), new Int32Array([9, 6]), new Int32Array([8, 5]), new Int32Array([8, 5]), new Int32Array([4, 5]), new Int32Array([4, 5]), new Int32Array([2, 5]), new Int32Array([2, 5]), new Int32Array([1, 5]), new Int32Array([1, 5]), new Int32Array([0, 4]), new Int32Array([0, 4]), new Int32Array([0, 4]), new Int32Array([0, 4]), new Int32Array([12, 4]), new Int32Array([12, 4]), new Int32Array([12, 4]), new Int32Array([12, 4]), new Int32Array([10, 4]), new Int32Array([10, 4]), new Int32Array([10, 4]), new Int32Array([10, 4]), new Int32Array([14, 4]), new Int32Array([14, 4]), new Int32Array([14, 4]), new Int32Array([14, 4]), new Int32Array([5, 4]), new Int32Array([5, 4]), new Int32Array([5, 4]), new Int32Array([5, 4]), new Int32Array([13, 4]), new Int32Array([13, 4]), new Int32Array([13, 4]), new Int32Array([13, 4]), new Int32Array([3, 4]), new Int32Array([3, 4]), new Int32Array([3, 4]), new Int32Array([3, 4]), new Int32Array([11, 4]), new Int32Array([11, 4]), new Int32Array([11, 4]), new Int32Array([11, 4]), new Int32Array([7, 4]), new Int32Array([7, 4]), new Int32Array([7, 4]), new Int32Array([7, 4]), new Int32Array([15, 2]), new Int32Array([15, 2]), new Int32Array([15, 2]), new Int32Array([15, 2]), new Int32Array([15, 2]), new Int32Array([15, 2]), new Int32Array([15, 2]), new Int32Array([15, 2]), new Int32Array([15, 2]), new Int32Array([15, 2]), new Int32Array([15, 2]), new Int32Array([15, 2]), new Int32Array([15, 2]), new Int32Array([15, 2]), new Int32Array([15, 2]), new Int32Array([15, 2])];
    constructor.TMNMV_TAB_0 = [new Int32Array([3, 4]), new Int32Array([-3, 4]), new Int32Array([2, 3]), new Int32Array([2, 3]), new Int32Array([-2, 3]), new Int32Array([-2, 3]), new Int32Array([1, 2]), new Int32Array([1, 2]), new Int32Array([1, 2]), new Int32Array([1, 2]), new Int32Array([-1, 2]), new Int32Array([-1, 2]), new Int32Array([-1, 2]), new Int32Array([-1, 2])];
    constructor.TMNMV_TAB_1 = [new Int32Array([12, 10]), new Int32Array([-12, 10]), new Int32Array([11, 10]), new Int32Array([-11, 10]), new Int32Array([10, 9]), new Int32Array([10, 9]), new Int32Array([-10, 9]), new Int32Array([-10, 9]), new Int32Array([9, 9]), new Int32Array([9, 9]), new Int32Array([-9, 9]), new Int32Array([-9, 9]), new Int32Array([8, 9]), new Int32Array([8, 9]), new Int32Array([-8, 9]), new Int32Array([-8, 9]), new Int32Array([7, 7]), new Int32Array([7, 7]), new Int32Array([7, 7]), new Int32Array([7, 7]), new Int32Array([7, 7]), new Int32Array([7, 7]), new Int32Array([7, 7]), new Int32Array([7, 7]), new Int32Array([-7, 7]), new Int32Array([-7, 7]), new Int32Array([-7, 7]), new Int32Array([-7, 7]), new Int32Array([-7, 7]), new Int32Array([-7, 7]), new Int32Array([-7, 7]), new Int32Array([-7, 7]), new Int32Array([6, 7]), new Int32Array([6, 7]), new Int32Array([6, 7]), new Int32Array([6, 7]), new Int32Array([6, 7]), new Int32Array([6, 7]), new Int32Array([6, 7]), new Int32Array([6, 7]), new Int32Array([-6, 7]), new Int32Array([-6, 7]), new Int32Array([-6, 7]), new Int32Array([-6, 7]), new Int32Array([-6, 7]), new Int32Array([-6, 7]), new Int32Array([-6, 7]), new Int32Array([-6, 7]), new Int32Array([5, 7]), new Int32Array([5, 7]), new Int32Array([5, 7]), new Int32Array([5, 7]), new Int32Array([5, 7]), new Int32Array([5, 7]), new Int32Array([5, 7]), new Int32Array([5, 7]), new Int32Array([-5, 7]), new Int32Array([-5, 7]), new Int32Array([-5, 7]), new Int32Array([-5, 7]), new Int32Array([-5, 7]), new Int32Array([-5, 7]), new Int32Array([-5, 7]), new Int32Array([-5, 7]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([4, 6]), new Int32Array([-4, 6]), new Int32Array([-4, 6]), new Int32Array([-4, 6]), new Int32Array([-4, 6]), new Int32Array([-4, 6]), new Int32Array([-4, 6]), new Int32Array([-4, 6]), new Int32Array([-4, 6]), new Int32Array([-4, 6]), new Int32Array([-4, 6]), new Int32Array([-4, 6]), new Int32Array([-4, 6]), new Int32Array([-4, 6]), new Int32Array([-4, 6]), new Int32Array([-4, 6]), new Int32Array([-4, 6])];
    constructor.TMNMV_TAB_2 = [new Int32Array([32, 12]), new Int32Array([-32, 12]), new Int32Array([31, 12]), new Int32Array([-31, 12]), new Int32Array([30, 11]), new Int32Array([30, 11]), new Int32Array([-30, 11]), new Int32Array([-30, 11]), new Int32Array([29, 11]), new Int32Array([29, 11]), new Int32Array([-29, 11]), new Int32Array([-29, 11]), new Int32Array([28, 11]), new Int32Array([28, 11]), new Int32Array([-28, 11]), new Int32Array([-28, 11]), new Int32Array([27, 11]), new Int32Array([27, 11]), new Int32Array([-27, 11]), new Int32Array([-27, 11]), new Int32Array([26, 11]), new Int32Array([26, 11]), new Int32Array([-26, 11]), new Int32Array([-26, 11]), new Int32Array([25, 11]), new Int32Array([25, 11]), new Int32Array([-25, 11]), new Int32Array([-25, 11]), new Int32Array([24, 10]), new Int32Array([24, 10]), new Int32Array([24, 10]), new Int32Array([24, 10]), new Int32Array([-24, 10]), new Int32Array([-24, 10]), new Int32Array([-24, 10]), new Int32Array([-24, 10]), new Int32Array([23, 10]), new Int32Array([23, 10]), new Int32Array([23, 10]), new Int32Array([23, 10]), new Int32Array([-23, 10]), new Int32Array([-23, 10]), new Int32Array([-23, 10]), new Int32Array([-23, 10]), new Int32Array([22, 10]), new Int32Array([22, 10]), new Int32Array([22, 10]), new Int32Array([22, 10]), new Int32Array([-22, 10]), new Int32Array([-22, 10]), new Int32Array([-22, 10]), new Int32Array([-22, 10]), new Int32Array([21, 10]), new Int32Array([21, 10]), new Int32Array([21, 10]), new Int32Array([21, 10]), new Int32Array([-21, 10]), new Int32Array([-21, 10]), new Int32Array([-21, 10]), new Int32Array([-21, 10]), new Int32Array([20, 10]), new Int32Array([20, 10]), new Int32Array([20, 10]), new Int32Array([20, 10]), new Int32Array([-20, 10]), new Int32Array([-20, 10]), new Int32Array([-20, 10]), new Int32Array([-20, 10]), new Int32Array([19, 10]), new Int32Array([19, 10]), new Int32Array([19, 10]), new Int32Array([19, 10]), new Int32Array([-19, 10]), new Int32Array([-19, 10]), new Int32Array([-19, 10]), new Int32Array([-19, 10]), new Int32Array([18, 10]), new Int32Array([18, 10]), new Int32Array([18, 10]), new Int32Array([18, 10]), new Int32Array([-18, 10]), new Int32Array([-18, 10]), new Int32Array([-18, 10]), new Int32Array([-18, 10]), new Int32Array([17, 10]), new Int32Array([17, 10]), new Int32Array([17, 10]), new Int32Array([17, 10]), new Int32Array([-17, 10]), new Int32Array([-17, 10]), new Int32Array([-17, 10]), new Int32Array([-17, 10]), new Int32Array([16, 10]), new Int32Array([16, 10]), new Int32Array([16, 10]), new Int32Array([16, 10]), new Int32Array([-16, 10]), new Int32Array([-16, 10]), new Int32Array([-16, 10]), new Int32Array([-16, 10]), new Int32Array([15, 10]), new Int32Array([15, 10]), new Int32Array([15, 10]), new Int32Array([15, 10]), new Int32Array([-15, 10]), new Int32Array([-15, 10]), new Int32Array([-15, 10]), new Int32Array([-15, 10]), new Int32Array([14, 10]), new Int32Array([14, 10]), new Int32Array([14, 10]), new Int32Array([14, 10]), new Int32Array([-14, 10]), new Int32Array([-14, 10]), new Int32Array([-14, 10]), new Int32Array([-14, 10]), new Int32Array([13, 10]), new Int32Array([13, 10]), new Int32Array([13, 10]), new Int32Array([13, 10]), new Int32Array([-13, 10]), new Int32Array([-13, 10]), new Int32Array([-13, 10]), new Int32Array([-13, 10])];
    constructor.MAX_LEVEL = [[new Int8Array([12, 6, 4, 3, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Int8Array([3, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])], [new Int8Array([27, 10, 5, 4, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Int8Array([8, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])]];
    constructor.MAX_RUN = [[new Int8Array([0, 26, 10, 6, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Int8Array([0, 40, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])], [new Int8Array([0, 14, 9, 7, 3, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Int8Array([0, 20, 6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])]];
    constructor.COEFF_TAB = [[new Int32Array([2, 2, 0, 0, 1]), new Int32Array([15, 4, 0, 0, 2]), new Int32Array([21, 6, 0, 0, 3]), new Int32Array([23, 7, 0, 0, 4]), new Int32Array([31, 8, 0, 0, 5]), new Int32Array([37, 9, 0, 0, 6]), new Int32Array([36, 9, 0, 0, 7]), new Int32Array([33, 10, 0, 0, 8]), new Int32Array([32, 10, 0, 0, 9]), new Int32Array([7, 11, 0, 0, 10]), new Int32Array([6, 11, 0, 0, 11]), new Int32Array([32, 11, 0, 0, 12]), new Int32Array([6, 3, 0, 1, 1]), new Int32Array([20, 6, 0, 1, 2]), new Int32Array([30, 8, 0, 1, 3]), new Int32Array([15, 10, 0, 1, 4]), new Int32Array([33, 11, 0, 1, 5]), new Int32Array([80, 12, 0, 1, 6]), new Int32Array([14, 4, 0, 2, 1]), new Int32Array([29, 8, 0, 2, 2]), new Int32Array([14, 10, 0, 2, 3]), new Int32Array([81, 12, 0, 2, 4]), new Int32Array([13, 5, 0, 3, 1]), new Int32Array([35, 9, 0, 3, 2]), new Int32Array([13, 10, 0, 3, 3]), new Int32Array([12, 5, 0, 4, 1]), new Int32Array([34, 9, 0, 4, 2]), new Int32Array([82, 12, 0, 4, 3]), new Int32Array([11, 5, 0, 5, 1]), new Int32Array([12, 10, 0, 5, 2]), new Int32Array([83, 12, 0, 5, 3]), new Int32Array([19, 6, 0, 6, 1]), new Int32Array([11, 10, 0, 6, 2]), new Int32Array([84, 12, 0, 6, 3]), new Int32Array([18, 6, 0, 7, 1]), new Int32Array([10, 10, 0, 7, 2]), new Int32Array([17, 6, 0, 8, 1]), new Int32Array([9, 10, 0, 8, 2]), new Int32Array([16, 6, 0, 9, 1]), new Int32Array([8, 10, 0, 9, 2]), new Int32Array([22, 7, 0, 10, 1]), new Int32Array([85, 12, 0, 10, 2]), new Int32Array([21, 7, 0, 11, 1]), new Int32Array([20, 7, 0, 12, 1]), new Int32Array([28, 8, 0, 13, 1]), new Int32Array([27, 8, 0, 14, 1]), new Int32Array([33, 9, 0, 15, 1]), new Int32Array([32, 9, 0, 16, 1]), new Int32Array([31, 9, 0, 17, 1]), new Int32Array([30, 9, 0, 18, 1]), new Int32Array([29, 9, 0, 19, 1]), new Int32Array([28, 9, 0, 20, 1]), new Int32Array([27, 9, 0, 21, 1]), new Int32Array([26, 9, 0, 22, 1]), new Int32Array([34, 11, 0, 23, 1]), new Int32Array([35, 11, 0, 24, 1]), new Int32Array([86, 12, 0, 25, 1]), new Int32Array([87, 12, 0, 26, 1]), new Int32Array([7, 4, 1, 0, 1]), new Int32Array([25, 9, 1, 0, 2]), new Int32Array([5, 11, 1, 0, 3]), new Int32Array([15, 6, 1, 1, 1]), new Int32Array([4, 11, 1, 1, 2]), new Int32Array([14, 6, 1, 2, 1]), new Int32Array([13, 6, 1, 3, 1]), new Int32Array([12, 6, 1, 4, 1]), new Int32Array([19, 7, 1, 5, 1]), new Int32Array([18, 7, 1, 6, 1]), new Int32Array([17, 7, 1, 7, 1]), new Int32Array([16, 7, 1, 8, 1]), new Int32Array([26, 8, 1, 9, 1]), new Int32Array([25, 8, 1, 10, 1]), new Int32Array([24, 8, 1, 11, 1]), new Int32Array([23, 8, 1, 12, 1]), new Int32Array([22, 8, 1, 13, 1]), new Int32Array([21, 8, 1, 14, 1]), new Int32Array([20, 8, 1, 15, 1]), new Int32Array([19, 8, 1, 16, 1]), new Int32Array([24, 9, 1, 17, 1]), new Int32Array([23, 9, 1, 18, 1]), new Int32Array([22, 9, 1, 19, 1]), new Int32Array([21, 9, 1, 20, 1]), new Int32Array([20, 9, 1, 21, 1]), new Int32Array([19, 9, 1, 22, 1]), new Int32Array([18, 9, 1, 23, 1]), new Int32Array([17, 9, 1, 24, 1]), new Int32Array([7, 10, 1, 25, 1]), new Int32Array([6, 10, 1, 26, 1]), new Int32Array([5, 10, 1, 27, 1]), new Int32Array([4, 10, 1, 28, 1]), new Int32Array([36, 11, 1, 29, 1]), new Int32Array([37, 11, 1, 30, 1]), new Int32Array([38, 11, 1, 31, 1]), new Int32Array([39, 11, 1, 32, 1]), new Int32Array([88, 12, 1, 33, 1]), new Int32Array([89, 12, 1, 34, 1]), new Int32Array([90, 12, 1, 35, 1]), new Int32Array([91, 12, 1, 36, 1]), new Int32Array([92, 12, 1, 37, 1]), new Int32Array([93, 12, 1, 38, 1]), new Int32Array([94, 12, 1, 39, 1]), new Int32Array([95, 12, 1, 40, 1])], [new Int32Array([2, 2, 0, 0, 1]), new Int32Array([15, 4, 0, 0, 3]), new Int32Array([21, 6, 0, 0, 6]), new Int32Array([23, 7, 0, 0, 9]), new Int32Array([31, 8, 0, 0, 10]), new Int32Array([37, 9, 0, 0, 13]), new Int32Array([36, 9, 0, 0, 14]), new Int32Array([33, 10, 0, 0, 17]), new Int32Array([32, 10, 0, 0, 18]), new Int32Array([7, 11, 0, 0, 21]), new Int32Array([6, 11, 0, 0, 22]), new Int32Array([32, 11, 0, 0, 23]), new Int32Array([6, 3, 0, 0, 2]), new Int32Array([20, 6, 0, 1, 2]), new Int32Array([30, 8, 0, 0, 11]), new Int32Array([15, 10, 0, 0, 19]), new Int32Array([33, 11, 0, 0, 24]), new Int32Array([80, 12, 0, 0, 25]), new Int32Array([14, 4, 0, 1, 1]), new Int32Array([29, 8, 0, 0, 12]), new Int32Array([14, 10, 0, 0, 20]), new Int32Array([81, 12, 0, 0, 26]), new Int32Array([13, 5, 0, 0, 4]), new Int32Array([35, 9, 0, 0, 15]), new Int32Array([13, 10, 0, 1, 7]), new Int32Array([12, 5, 0, 0, 5]), new Int32Array([34, 9, 0, 4, 2]), new Int32Array([82, 12, 0, 0, 27]), new Int32Array([11, 5, 0, 2, 1]), new Int32Array([12, 10, 0, 2, 4]), new Int32Array([83, 12, 0, 1, 9]), new Int32Array([19, 6, 0, 0, 7]), new Int32Array([11, 10, 0, 3, 4]), new Int32Array([84, 12, 0, 6, 3]), new Int32Array([18, 6, 0, 0, 8]), new Int32Array([10, 10, 0, 4, 3]), new Int32Array([17, 6, 0, 3, 1]), new Int32Array([9, 10, 0, 8, 2]), new Int32Array([16, 6, 0, 4, 1]), new Int32Array([8, 10, 0, 5, 3]), new Int32Array([22, 7, 0, 1, 3]), new Int32Array([85, 12, 0, 1, 10]), new Int32Array([21, 7, 0, 2, 2]), new Int32Array([20, 7, 0, 7, 1]), new Int32Array([28, 8, 0, 1, 4]), new Int32Array([27, 8, 0, 3, 2]), new Int32Array([33, 9, 0, 0, 16]), new Int32Array([32, 9, 0, 1, 5]), new Int32Array([31, 9, 0, 1, 6]), new Int32Array([30, 9, 0, 2, 3]), new Int32Array([29, 9, 0, 3, 3]), new Int32Array([28, 9, 0, 5, 2]), new Int32Array([27, 9, 0, 6, 2]), new Int32Array([26, 9, 0, 7, 2]), new Int32Array([34, 11, 0, 1, 8]), new Int32Array([35, 11, 0, 9, 2]), new Int32Array([86, 12, 0, 2, 5]), new Int32Array([87, 12, 0, 7, 3]), new Int32Array([7, 4, 1, 0, 1]), new Int32Array([25, 9, 0, 11, 1]), new Int32Array([5, 11, 1, 0, 6]), new Int32Array([15, 6, 1, 1, 1]), new Int32Array([4, 11, 1, 0, 7]), new Int32Array([14, 6, 1, 2, 1]), new Int32Array([13, 6, 0, 5, 1]), new Int32Array([12, 6, 1, 0, 2]), new Int32Array([19, 7, 1, 5, 1]), new Int32Array([18, 7, 0, 6, 1]), new Int32Array([17, 7, 1, 3, 1]), new Int32Array([16, 7, 1, 4, 1]), new Int32Array([26, 8, 1, 9, 1]), new Int32Array([25, 8, 0, 8, 1]), new Int32Array([24, 8, 0, 9, 1]), new Int32Array([23, 8, 0, 10, 1]), new Int32Array([22, 8, 1, 0, 3]), new Int32Array([21, 8, 1, 6, 1]), new Int32Array([20, 8, 1, 7, 1]), new Int32Array([19, 8, 1, 8, 1]), new Int32Array([24, 9, 0, 12, 1]), new Int32Array([23, 9, 1, 0, 4]), new Int32Array([22, 9, 1, 1, 2]), new Int32Array([21, 9, 1, 10, 1]), new Int32Array([20, 9, 1, 11, 1]), new Int32Array([19, 9, 1, 12, 1]), new Int32Array([18, 9, 1, 13, 1]), new Int32Array([17, 9, 1, 14, 1]), new Int32Array([7, 10, 0, 13, 1]), new Int32Array([6, 10, 1, 0, 5]), new Int32Array([5, 10, 1, 1, 3]), new Int32Array([4, 10, 1, 2, 2]), new Int32Array([36, 11, 1, 3, 2]), new Int32Array([37, 11, 1, 4, 2]), new Int32Array([38, 11, 1, 15, 1]), new Int32Array([39, 11, 1, 16, 1]), new Int32Array([88, 12, 0, 14, 1]), new Int32Array([89, 12, 1, 0, 8]), new Int32Array([90, 12, 1, 5, 2]), new Int32Array([91, 12, 1, 6, 2]), new Int32Array([92, 12, 1, 17, 1]), new Int32Array([93, 12, 1, 18, 1]), new Int32Array([94, 12, 1, 19, 1]), new Int32Array([95, 12, 1, 20, 1])]];
    constructor.SCAN_TABLES = [new Int16Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), new Int16Array([0, 1, 2, 3, 8, 9, 16, 17, 10, 11, 4, 5, 6, 7, 15, 14, 13, 12, 19, 18, 24, 25, 32, 33, 26, 27, 20, 21, 22, 23, 28, 29, 30, 31, 34, 35, 40, 41, 48, 49, 42, 43, 36, 37, 38, 39, 44, 45, 46, 47, 50, 51, 56, 57, 58, 59, 52, 53, 54, 55, 60, 61, 62, 63]), new Int16Array([0, 8, 16, 24, 1, 9, 2, 10, 17, 25, 32, 40, 48, 56, 57, 49, 41, 33, 26, 18, 3, 11, 4, 12, 19, 27, 34, 42, 50, 58, 35, 43, 51, 59, 20, 28, 5, 13, 6, 14, 21, 29, 36, 44, 52, 60, 37, 45, 53, 61, 22, 30, 7, 15, 23, 31, 38, 46, 54, 62, 39, 47, 55, 63])];
    constructor.DEFAULT_ACDC_VALUES = new Int16Array([1024, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    constructor.DC_LUM_TAB = [new Int32Array([0, 0]), new Int32Array([4, 3]), new Int32Array([3, 3]), new Int32Array([0, 3]), new Int32Array([2, 2]), new Int32Array([2, 2]), new Int32Array([1, 2]), new Int32Array([1, 2])];
    constructor.FILTER_TAB = [new Int32Array([14, 23, -7, 3, -1]), new Int32Array([-3, 19, 20, -6, 3, -1]), new Int32Array([2, -6, 20, 20, -6, 3, -1]), new Int32Array([-1, 3, -6, 20, 20, -6, 3, -1])];
    constructor.SPRITE_TRAJECTORY_LEN = [new Int32Array([0, 2]), new Int32Array([2, 3]), new Int32Array([3, 3]), new Int32Array([4, 3]), new Int32Array([5, 3]), new Int32Array([6, 3]), new Int32Array([14, 4]), new Int32Array([30, 5]), new Int32Array([62, 6]), new Int32Array([126, 7]), new Int32Array([254, 8]), new Int32Array([510, 9]), new Int32Array([1022, 10]), new Int32Array([2046, 11]), new Int32Array([4094, 12])];
}, {ZERO_MV: "Macroblock.Vector", ROUNDTAB_76: "Int32Array", ROUNDTAB_79: "Int32Array", INTRA_DC_THRESHOLD_TABLE: "Int32Array", DEFAULT_INTRA_MATRIX: "Int16Array", DEFAULT_INTER_MATRIX: "Int16Array", MCBPC_INTRA_TABLE: "Array", MCBPC_INTER_TABLE: "Array", CBPY_TABLE: "Array", TMNMV_TAB_0: "Array", TMNMV_TAB_1: "Array", TMNMV_TAB_2: "Array", MAX_LEVEL: "Array", MAX_RUN: "Array", COEFF_TAB: "Array", SCAN_TABLES: "Array", DEFAULT_ACDC_VALUES: "Int16Array", DC_LUM_TAB: "Array", FILTER_TAB: "Array", SPRITE_TRAJECTORY_LEN: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Writes blocks to form AAC frame
 *  
 *  @author The JCodec project
 *  
 */
var BlockWriter = function() {};
BlockWriter = stjs.extend(BlockWriter, null, [], function(constructor, prototype) {
    prototype.nextBlock = function(bits, block) {
        bits.writeNBit(block.getType().ordinal(), 3);
        if (block.getType() == BlockType.TYPE_END) 
            return;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Reads blocks of AAC frame
 *  
 *  @author The JCodec project
 *  
 */
var BlockReader = function() {};
BlockReader = stjs.extend(BlockReader, null, [], function(constructor, prototype) {
    prototype.nextBlock = function(bits) {
        var type = BlockType.values()[((stjs.trunc(bits.readNBit(3))) | 0)];
        if (type == BlockType.TYPE_END) 
            return null;
        var id = stjs.trunc(bits.readNBit(4));
        return null;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Skip data_stream_element; reference: table 4.10.
 *  
 *  @author The JCodec project
 *  
 */
var BlockDSE = function() {
    Block.call(this);
};
BlockDSE = stjs.extend(BlockDSE, Block, [], function(constructor, prototype) {
    prototype.parse = function(_in) {
        var elemType = stjs.trunc(_in.readNBit(4));
        var byte_align = _in.read1Bit();
        var count = stjs.trunc(_in.readNBit(8));
        if (count == 255) 
            count += _in.readNBit(8);
        if (byte_align != 0) 
            _in.align();
        if (_in.skip(8 * count) != 8 * count) {
             throw new RuntimeException("Overread");
        }
    };
}, {type: {name: "Enum", arguments: ["BlockType"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var BlockFil = function() {
    Block.call(this);
};
BlockFil = stjs.extend(BlockFil, Block, [], function(constructor, prototype) {
    prototype.parse = function(_in) {
        var num = stjs.trunc(_in.readNBit(4));
        if (num == 15) 
            num += stjs.trunc(_in.readNBit(8)) - 1;
        if (num > 0) 
            if (_in.skip(8 * num) != 8 * num) 
                 throw new RuntimeException("Overread");
    };
}, {type: {name: "Enum", arguments: ["BlockType"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  H264 CABAC M-encoder
 *  
 *  @author The JCodec project
 *  
 */
var MEncoder = function(out, models) {
    this.range = 510;
    this.models = models;
    this.out = out;
};
MEncoder = stjs.extend(MEncoder, null, [], function(constructor, prototype) {
    prototype.out = null;
    prototype.range = 0;
    prototype.offset = 0;
    prototype.onesOutstanding = 0;
    prototype.zeroBorrowed = false;
    prototype.outReg = 0;
    prototype.bitsInOutReg = 0;
    prototype.models = null;
    /**
     *  Encodes one bin in normal mode using supplied context model
     *  
     *  @param bin
     *  @param cm
     *  @throws IOException
     */
    prototype.encodeBin = function(model, bin) {
        var qs = (this.range >> 6) & 3;
        var rangeLPS = MConst.rangeLPS[qs][this.models[0][model]];
        this.range -= rangeLPS;
        if (bin != this.models[1][model]) {
            this.offset += this.range;
            this.range = rangeLPS;
            if (this.models[0][model] == 0) 
                this.models[1][model] = 1 - this.models[1][model];
            this.models[0][model] = MConst.transitLPS[this.models[0][model]];
        } else {
            if (this.models[0][model] < 62) 
                this.models[0][model]++;
        }
        this.renormalize();
    };
    /**
     *  Codes one bin in bypass mode for symbols with uniform probability
     *  distribution
     *  
     *  @param bin
     *  @throws IOException
     */
    prototype.encodeBinBypass = function(bin) {
        this.offset <<= 1;
        if (bin == 1) {
            this.offset += this.range;
        }
        if ((this.offset & 1024) != 0) {
            this.flushOutstanding(1);
            this.offset &= 1023;
        } else if ((this.offset & 512) != 0) {
            this.offset &= 511;
            ++this.onesOutstanding;
        } else {
            this.flushOutstanding(0);
        }
    };
    /**
     *  Codes termination flag. Range for LPS is preset to be 2
     *  
     *  @param bin
     *  @throws IOException
     */
    prototype.encodeBinFinal = function(bin) {
        this.range -= 2;
        if (bin == 0) {
            this.renormalize();
        } else {
            this.offset += this.range;
            this.range = 2;
            this.renormalize();
        }
    };
    prototype.finishEncoding = function() {
        this.flushOutstanding((this.offset >> 9) & 1);
        this.putBit((this.offset >> 8) & 1);
        this.stuffBits();
    };
    prototype.renormalize = function() {
         while (this.range < 256){
            if (this.offset < 256) {
                this.flushOutstanding(0);
            } else if (this.offset < 512) {
                this.offset &= 255;
                ++this.onesOutstanding;
            } else {
                this.offset &= 511;
                this.flushOutstanding(1);
            }
            this.range <<= 1;
            this.offset <<= 1;
        }
    };
    prototype.flushOutstanding = function(hasCarry) {
        if (this.zeroBorrowed) 
            this.putBit(hasCarry);
        var trailingBit = 1 - hasCarry;
        for (; this.onesOutstanding > 0; this.onesOutstanding--) 
            this.putBit(trailingBit);
        this.zeroBorrowed = true;
    };
    prototype.putBit = function(bit) {
        this.outReg = (this.outReg << 1) | bit;
        ++this.bitsInOutReg;
        if (this.bitsInOutReg == 8) {
            this.out.put((this.outReg << 24 >> 24));
            this.outReg = 0;
            this.bitsInOutReg = 0;
        }
    };
    prototype.stuffBits = function() {
        if (this.bitsInOutReg == 0) {
            this.out.put((128 << 24 >> 24));
        } else {
            this.outReg = (this.outReg << 1) | 1;
            this.outReg <<= (8 - (this.bitsInOutReg + 1));
            this.out.put((this.outReg << 24 >> 24));
            this.outReg = 0;
            this.bitsInOutReg = 0;
        }
    };
}, {out: "ByteBuffer", models: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  H264 CABAC M-Coder ( decoder module )
 *  
 *  @author The JCodec project
 *  
 */
var MDecoder = function(_in, cm) {
    this._in = _in;
    this.range = 510;
    this.cm = cm;
    this.initCodeRegister();
};
MDecoder = stjs.extend(MDecoder, null, [], function(constructor, prototype) {
    prototype._in = null;
    prototype.range = 0;
    prototype.code = 0;
    prototype.nBitsPending = 0;
    prototype.cm = null;
    /**
     *  Initializes code register. Loads 9 bits from the stream into working area
     *  of code register ( bits 8 - 16) leaving 7 bits in the pending area of
     *  code register (bits 0 - 7)
     *  
     *  @throws IOException
     */
    prototype.initCodeRegister = function() {
        this.readOneByte();
        if (this.nBitsPending != 8) 
             throw new RuntimeException("Empty stream");
        this.code <<= 8;
        this.readOneByte();
        this.code <<= 1;
        this.nBitsPending -= 9;
    };
    prototype.readOneByte = function() {
        if (!this._in.hasRemaining()) 
            return;
        var b = this._in.get() & 255;
        this.code |= b;
        this.nBitsPending += 8;
    };
    /**
     *  Decodes one bin from arithmetice code word
     *  
     *  @param cm
     *  @return
     *  @throws IOException
     */
    prototype.decodeBin = function(m) {
        var bin;
        var qIdx = (this.range >> 6) & 3;
        var rLPS = MConst.rangeLPS[qIdx][this.cm[0][m]];
        this.range -= rLPS;
        var rs8 = this.range << 8;
        if (this.code < rs8) {
            if (this.cm[0][m] < 62) 
                this.cm[0][m]++;
            this.renormalize();
            bin = this.cm[1][m];
        } else {
            this.range = rLPS;
            this.code -= rs8;
            this.renormalize();
            bin = 1 - this.cm[1][m];
            if (this.cm[0][m] == 0) 
                this.cm[1][m] = 1 - this.cm[1][m];
            this.cm[0][m] = MConst.transitLPS[this.cm[0][m]];
        }
        return bin;
    };
    /**
     *  Special decoding process for 'end of slice' flag. Uses probability state
     *  63.
     *  
     *  @param cm
     *  @return
     *  @throws IOException
     */
    prototype.decodeFinalBin = function() {
        this.range -= 2;
        if (this.code < (this.range << 8)) {
            this.renormalize();
            return 0;
        } else {
            return 1;
        }
    };
    /**
     *  Special decoding process for symbols with uniform distribution
     *  
     *  @return
     *  @throws IOException
     */
    prototype.decodeBinBypass = function() {
        this.code <<= 1;
        --this.nBitsPending;
        if (this.nBitsPending <= 0) 
            this.readOneByte();
        var tmp = this.code - (this.range << 8);
        if (tmp < 0) {
            return 0;
        } else {
            this.code = tmp;
            return 1;
        }
    };
    /**
     *  Shifts the current interval to either 1/2 or 0 (code = (code << 1) &
     *  0x1ffff) and scales it by 2 (range << 1).
     *  
     *  Reads new byte from the input stream into code value if there are no more
     *  bits pending
     *  
     *  @throws IOException
     */
    prototype.renormalize = function() {
         while (this.range < 256){
            this.range <<= 1;
            this.code <<= 1;
            this.code &= 131071;
            --this.nBitsPending;
            if (this.nBitsPending <= 0) 
                this.readOneByte();
        }
    };
}, {_in: "ByteBuffer", cm: "Array"}, {});
/**
 *  Resamples image interpolating points using Lanczos sinc over sine windowed
 *  filter.
 *  
 *  @author Stanislav Vitvitskiy
 */
var BaseResampler = function(from, to) {
    this.toSize = to;
    this.fromSize = from;
    this.scaleFactorX = from.getWidth() / to.getWidth();
    this.scaleFactorY = from.getHeight() / to.getHeight();
    this.tempBuffers = new ThreadLocal();
};
BaseResampler = stjs.extend(BaseResampler, null, [], function(constructor, prototype) {
    prototype.tempBuffers = null;
    prototype.toSize = null;
    prototype.fromSize = null;
    prototype.scaleFactorX = 0.0;
    prototype.scaleFactorY = 0.0;
    prototype.getPel = function(pic, plane, x, y) {
        if (x < 0) 
            x = 0;
        if (y < 0) 
            y = 0;
        var w = pic.getPlaneWidth(plane);
        if (x > w - 1) 
            x = w - 1;
        var h = pic.getPlaneHeight(plane);
        if (y > h - 1) 
            y = h - 1;
        return pic.getData()[plane][x + y * w];
    };
    prototype.getTapsX = function(dstX) {};
    prototype.getTapsY = function(dstY) {};
    prototype.nTaps = function() {};
    /**
     *  Converts floating point taps to fixed precision taps.
     *  
     *  @param taps
     *             The 64 bit double representation
     *  @param precBits
     *             Precision bits
     *  @param out
     *             Taps converted to fixed precision
     */
    constructor.normalizeAndGenerateFixedPrecision = function(taps, precBits, out) {
        var sum = 0;
        for (var i = 0; i < taps.length; i++) {
            sum += taps[i];
        }
        var sumFix = 0;
        var precNum = 1 << precBits;
        for (var i = 0; i < taps.length; i++) {
            var d = (taps[i] * precNum) / sum + precNum;
            var s = stjs.trunc(d);
            taps[i] = d - s;
            out[i] = (((s - precNum)) << 16 >> 16);
            sumFix += out[i];
        }
        var tapsTaken = 0;
         while (sumFix < precNum){
            var maxI = -1;
            for (var i = 0; i < taps.length; i++) {
                if ((tapsTaken & (1 << i)) == 0 && (maxI == -1 || taps[i] > taps[maxI])) 
                    maxI = i;
            }
            out[maxI]++;
            sumFix++;
            tapsTaken |= (1 << maxI);
        }
        for (var i = 0; i < taps.length; i++) {
            taps[i] += out[i];
            if ((tapsTaken & (1 << i)) != 0) 
                taps[i] -= 1;
        }
    };
    /**
     *  Interpolates points using a 2d convolution
     */
    prototype.resample = function(src, dst) {
        var temp = this.tempBuffers.get();
        if (temp == null) {
            temp = new Int32Array(this.toSize.getWidth() * (this.fromSize.getHeight() + this.nTaps()));
            this.tempBuffers.set(temp);
        }
        for (var p = 0; p < src.getColor().nComp; p++) {
            for (var y = 0; y < src.getPlaneHeight(p) + this.nTaps(); y++) {
                for (var x = 0; x < dst.getPlaneWidth(p); x++) {
                    var tapsXs = this.getTapsX(x);
                    var srcX = stjs.trunc((this.scaleFactorX * x)) - stjs.trunc(this.nTaps() / 2) + 1;
                    var sum = 0;
                    for (var i = 0; i < this.nTaps(); i++) {
                        sum += (this.getPel(src, p, srcX + i, y - stjs.trunc(this.nTaps() / 2) + 1) + 128) * tapsXs[i];
                    }
                    temp[y * this.toSize.getWidth() + x] = sum;
                }
            }
            for (var y = 0; y < dst.getPlaneHeight(p); y++) {
                for (var x = 0; x < dst.getPlaneWidth(p); x++) {
                    var tapsYs = this.getTapsY(y);
                    var srcY = stjs.trunc((this.scaleFactorY * y));
                    var sum = 0;
                    for (var i = 0; i < this.nTaps(); i++) {
                        sum += temp[x + (srcY + i) * this.toSize.getWidth()] * tapsYs[i];
                    }
                    dst.getPlaneData(p)[y * dst.getPlaneWidth(p) + x] = ((MathUtil.clip((sum + 8192) >> 14, 0, 255) - 128) << 24 >> 24);
                }
            }
        }
    };
}, {tempBuffers: {name: "ThreadLocal", arguments: ["Int32Array"]}, toSize: "Size", fromSize: "Size"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var UnsupportedFormatException = function(arg0) {
    JCodecException.call(this, arg0);
};
UnsupportedFormatException = stjs.extend(UnsupportedFormatException, JCodecException, [], null, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author Jay Codec
 *  
 */
var ArrayUtil = function() {};
ArrayUtil = stjs.extend(ArrayUtil, null, [], function(constructor, prototype) {
    constructor.shiftRight1 = function(array) {
        for (var i = 1; i < array.length; i++) {
            array[i] = array[i - 1];
        }
        array[0] = null;
    };
    constructor.shiftLeft1 = function(array) {
        for (var i = 0; i < array.length - 1; i++) {
            array[i] = array[i + 1];
        }
        array[array.length - 1] = null;
    };
    constructor.shiftRight3 = function(array, from, to) {
        for (var i = to - 1; i > from; i--) {
            array[i] = array[i - 1];
        }
        array[from] = null;
    };
    constructor.shiftLeft3 = function(array, from, to) {
        for (var i = from; i < to - 1; i++) {
            array[i] = array[i + 1];
        }
        array[to - 1] = null;
    };
    constructor.shiftLeft2 = function(array, from) {
        ArrayUtil.shiftLeft3(array, from, array.length);
    };
    constructor.shiftRight2 = function(array, to) {
        ArrayUtil.shiftRight3(array, 0, to);
    };
    constructor.swap = function(arr, ind1, ind2) {
        if (ind1 == ind2) 
            return;
        var tmp = arr[ind1];
        arr[ind1] = arr[ind2];
        arr[ind2] = tmp;
    };
    constructor.sumInt = function(array) {
        var result = 0;
        for (var i = 0; i < array.length; i++) {
            result += array[i];
        }
        return result;
    };
    constructor.sumByte = function(array) {
        var result = 0;
        for (var i = 0; i < array.length; i++) {
            result += array[i];
        }
        return result;
    };
    constructor.sumInt3 = function(array, from, count) {
        var result = 0;
        for (var i = from; i < from + count; i++) {
            result += array[i];
        }
        return result;
    };
    constructor.sumByte3 = function(array, from, count) {
        var result = 0;
        for (var i = from; i < from + count; i++) {
            result += array[i];
        }
        return result;
    };
    constructor.addInt = function(array, val) {
        for (var i = 0; i < array.length; i++) 
            array[i] += val;
    };
    constructor.addAllInt = function(array1, array2) {
        if (array1 == null) {
            return ArrayUtil.cloneInt(array2);
        } else if (array2 == null) {
            return ArrayUtil.cloneInt(array1);
        }
        var joinedArray = new Int32Array(array1.length + array2.length);
        System.arraycopy(array1, 0, joinedArray, 0, array1.length);
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
        return joinedArray;
    };
    constructor.addAllLong = function(array1, array2) {
        if (array1 == null) {
            return ArrayUtil.cloneLong(array2);
        } else if (array2 == null) {
            return ArrayUtil.cloneLong(array1);
        }
        var joinedArray = Array(array1.length + array2.length);
        System.arraycopy(array1, 0, joinedArray, 0, array1.length);
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
        return joinedArray;
    };
    constructor.addAllObj = function(array1, array2) {
        if (array1 == null) {
            return ArrayUtil.cloneObj(array2);
        } else if (array2 == null) {
            return ArrayUtil.cloneObj(array1);
        }
        var joinedArray = jslang.reflect.Array.newInstance(array1.getClass().getComponentType(), array1.length + array2.length);
        System.arraycopy(array1, 0, joinedArray, 0, array1.length);
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
        return joinedArray;
    };
    constructor.cloneInt = function(array) {
        if (array == null) {
            return null;
        }
        return array.clone();
    };
    constructor.cloneLong = function(array) {
        if (array == null) {
            return null;
        }
        return array.clone();
    };
    constructor.cloneObj = function(array) {
        if (array == null) {
            return null;
        }
        return array.clone();
    };
    constructor.toByteArrayShifted = function(_arguments) {
        var result = new Int8Array(arguments.length);
        for (var i = 0; i < arguments.length; i++) 
            result[i] = ((arguments[i] - 128) << 24 >> 24);
        return result;
    };
    constructor.toByteArrayShifted2 = function(intArray) {
        var result = Array(intArray.length);
        for (var i = 0; i < intArray.length; i++) {
            result[i] = ArrayUtil.toByteArrayShifted(intArray[i]);
        }
        return result;
    };
    constructor.toIntArrayUnshifted = function(_arguments) {
        var result = new Int32Array(arguments.length);
        for (var i = 0; i < result.length; i++) 
            result[i] = ((arguments[i] + 128) << 24 >> 24);
        return result;
    };
    constructor.toByteArray = function(_arguments) {
        var result = new Int8Array(arguments.length);
        for (var i = 0; i < arguments.length; i++) 
            result[i] = (arguments[i] << 24 >> 24);
        return result;
    };
    constructor.toIntArray = function(_arguments) {
        var result = new Int32Array(arguments.length);
        for (var i = 0; i < result.length; i++) 
            result[i] = arguments[i];
        return result;
    };
    constructor.toUnsignedIntArray = function(val) {
        var result = new Int32Array(val.length);
        for (var i = 0; i < val.length; i++) 
            result[i] = val[i] & 255;
        return result;
    };
    constructor.reverse = function(frames) {
        for (var i = 0, j = frames.length - 1; i < frames.length >> 1; ++i , --j) {
            var tmp = frames[i];
            frames[i] = frames[j];
            frames[j] = tmp;
        }
    };
    constructor.max = function(array) {
        var max = Integer.MIN_VALUE;
        for (var i = 0; i < array.length; i++) {
            if (array[i] > max) {
                max = array[i];
            }
        }
        return max;
    };
    constructor.rotate = function(src) {
        var dst = Array.apply(null, Array(src[0].length)).map(function() {
            return new Int32Array(src.length);
        });
        for (var i = 0; i < src.length; i++) {
            for (var j = 0; j < src[0].length; j++) {
                dst[j][i] = src[i][j];
            }
        }
        return dst;
    };
    constructor.create2D = function(width, height) {
        var result = Array(height);
        for (var i = 0; i < height; i++) 
            result[i] = new Int8Array(width);
        return result;
    };
    constructor.printMatrixBytes = function(array, format, width) {
        var strings = Array(array.length);
        var maxLen = 0;
        for (var i = 0; i < array.length; i++) {
            strings[i] = String.format(format, array[i]);
            maxLen = Math.max(maxLen, strings[i].length);
        }
        for (var ind = 0; ind < strings.length; ) {
            var builder = new StringBuilder();
            for (var i = 0; i < width && ind < strings.length; i++ , ind++) {
                for (var j = 0; j < maxLen - strings[ind].length + 1; j++) 
                    builder.append(' '.charCodeAt(0));
                builder.append(strings[ind]);
            }
            System.out.println(builder);
        }
    };
    constructor.printMatrix = function(array, format, width) {
        var strings = Array(array.length);
        var maxLen = 0;
        for (var i = 0; i < array.length; i++) {
            strings[i] = String.format(format, array[i]);
            maxLen = Math.max(maxLen, strings[i].length);
        }
        for (var ind = 0; ind < strings.length; ) {
            var builder = new StringBuilder();
            for (var i = 0; i < width && ind < strings.length; i++ , ind++) {
                for (var j = 0; j < maxLen - strings[ind].length + 1; j++) 
                    builder.append(' '.charCodeAt(0));
                builder.append(strings[ind]);
            }
            System.out.println(builder);
        }
    };
    constructor.padLeft = function(array, padLength) {
        var result = new Int8Array(array.length + padLength);
        for (var i = padLength; i < result.length; i++) 
            result[i] = array[i - padLength];
        return result;
    };
    constructor.randomIntArray = function(size, from, to) {
        var width = to - from;
        var result = new Int32Array(size);
        for (var i = 0; i < size; i++) 
            result[i] = stjs.trunc(((Math.random() * width) % width)) + from;
        return result;
    };
    constructor.randomByteArray = function(size, from, to) {
        var width = ((to - from) << 24 >> 24);
        var result = new Int8Array(size);
        for (var i = 0; i < size; i++) 
            result[i] = stjs.trunc((((Math.random() * width) % width) + from));
        return result;
    };
    /**
     *  Implements a quicksort algorithm
     */
    constructor.quickSort = function(a, start, end, p) {
        var len = end - start;
        if (len < 2) {
            return;
        } else {
            var startPlus1 = start + 1;
            if (len == 2) {
                if (a[start] > a[startPlus1]) {
                    ArrayUtil.swap(a, start, startPlus1);
                    if (p != null) 
                        ArrayUtil.swap(p, start, startPlus1);
                }
                return;
            } else if (len == 3) {
                if (a[start] > a[startPlus1]) {
                    ArrayUtil.swap(a, start, startPlus1);
                    if (p != null) 
                        ArrayUtil.swap(p, start, startPlus1);
                }
                var startPlus2 = start + 2;
                if (a[startPlus1] > a[startPlus2]) {
                    ArrayUtil.swap(a, startPlus1, startPlus2);
                    if (p != null) 
                        ArrayUtil.swap(p, startPlus1, startPlus2);
                }
                if (a[start] > a[startPlus1]) {
                    ArrayUtil.swap(a, start, startPlus1);
                    if (p != null) 
                        ArrayUtil.swap(p, start, startPlus1);
                }
            }
        }
        var pivot = a[0];
        var p_large = end - 1;
        for (var i = end - 1; i >= start; i--) {
            if (a[i] > pivot) {
                ArrayUtil.swap(a, i, p_large);
                if (p != null) 
                    ArrayUtil.swap(p, i, p_large);
                p_large--;
            }
        }
        ArrayUtil.swap(a, start, p_large);
        if (p != null) 
            ArrayUtil.swap(p, start, p_large);
        ArrayUtil.quickSort(a, start, p_large, p);
        ArrayUtil.quickSort(a, p_large + 1, end, p);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IntObjectMap = function() {
    this.storage = Array(IntObjectMap.GROW_BY);
};
IntObjectMap = stjs.extend(IntObjectMap, null, [], function(constructor, prototype) {
    constructor.GROW_BY = 128;
    prototype.storage = null;
    prototype._size = 0;
    prototype.put = function(key, val) {
        if (this.storage.length <= key) {
            var ns = Array(key + IntObjectMap.GROW_BY);
            System.arraycopy(this.storage, 0, ns, 0, this.storage.length);
            this.storage = ns;
        }
        if (this.storage[key] == null) 
            this._size++;
        this.storage[key] = val;
    };
    prototype.get = function(key) {
        return key >= this.storage.length ? null : this.storage[key];
    };
    prototype.keys = function() {
        var result = new Int32Array(this._size);
        for (var i = 0, r = 0; i < this.storage.length; i++) {
            if (this.storage[i] != null) 
                result[r++] = i;
        }
        return result;
    };
    prototype.clear = function() {
        for (var i = 0; i < this.storage.length; i++) 
            this.storage[i] = null;
        this._size = 0;
    };
    prototype.size = function() {
        return this._size;
    };
    prototype.remove = function(key) {
        if (this.storage[key] != null) 
            this._size--;
        this.storage[key] = null;
    };
    prototype.values = function(runtime) {
        var result = jslang.reflect.Array.newInstance(runtime.getClass().getComponentType(), this._size);
        for (var i = 0, r = 0; i < this.storage.length; i++) {
            if (this.storage[i] != null) 
                result[r++] = this.storage[i];
        }
        return result;
    };
}, {storage: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Just stores log messages to be extracted at later point
 *  
 *  @author The JCodec project
 */
var BufferLogSink = function() {
    this.messages = new LinkedList();
};
BufferLogSink = stjs.extend(BufferLogSink, null, [LogSink], function(constructor, prototype) {
    prototype.messages = null;
    prototype.postMessage = function(msg) {
        this.messages.add(msg);
    };
    prototype.getMessages = function() {
        return this.messages;
    };
}, {messages: {name: "List", arguments: ["Message"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  Binarization and context modeling using binary search tree
 *  
 *  @author The JCodec project
 *  
 */
var TreeBinarizer = function() {
    this.initContextModels();
};
TreeBinarizer = stjs.extend(TreeBinarizer, null, [], function(constructor, prototype) {
    prototype.models = null;
    prototype.initContextModels = function() {
        this.models = Array(255);
        for (var i = 0; i < 255; i++) {
            this.models[i] = new Context(0, 0);
        }
    };
    prototype.binarize = function(symbol, encoder) {
        var inverted = 0;
        var nextModel = 0;
        var levelOffset = 0;
        for (var i = 0; i < 8; ++i) {
            var bin = (symbol >> (7 - i)) & 1;
            encoder.encode(bin, this.models[nextModel]);
            inverted |= bin << i;
            levelOffset += (1 << i);
            nextModel = levelOffset + inverted;
        }
    };
    prototype.debinarize = function(decoder) {
        var symbol = 0;
        var inverted = 0;
        var nextModel = 0;
        var levelOffset = 0;
        for (var i = 0; i < 8; ++i) {
            var bin = decoder.decode(this.models[nextModel]);
            symbol |= (bin << (7 - i));
            inverted |= bin << i;
            levelOffset += (1 << i);
            nextModel = levelOffset + inverted;
        }
        return symbol;
    };
}, {models: "Array"}, {});
/**
 *  Stores frames into Y4M file.
 *  
 *  @author Stanislav Vitvitskiy
 *  
 */
var Y4MMuxer = function(ch) {
    this.ch = ch;
};
Y4MMuxer = stjs.extend(Y4MMuxer, null, [Muxer, MuxerTrack], function(constructor, prototype) {
    prototype.ch = null;
    prototype.headerWritten = false;
    prototype.meta = null;
    constructor.frameTag = "FRAME\n".getBytes();
    prototype.writeHeader = function() {
        var size = this.meta.getSize();
        var bytes = String.format("YUV4MPEG2 W%d H%d F25:1 Ip A0:0 C420jpeg XYSCSS=420JPEG\n", size.getWidth(), size.getHeight()).getBytes();
        this.ch.write(ByteBuffer.wrap(bytes));
    };
    prototype.addFrame = function(outPacket) {
        if (!this.headerWritten) {
            this.writeHeader();
            this.headerWritten = true;
        }
        this.ch.write(ByteBuffer.wrap(Y4MMuxer.frameTag));
        this.ch.write(outPacket.data.duplicate());
    };
    prototype.addVideoTrack = function(codec, meta) {
        this.meta = meta;
        return this;
    };
    prototype.addAudioTrack = function(codec, meta) {
         throw new RuntimeException("Y4M doesn't support audio");
    };
    prototype.finish = function() {};
}, {ch: "WritableByteChannel", meta: "VideoCodecMeta", frameTag: "Int8Array"}, {});
var RawMuxer = function(destStream) {
    this.ch = destStream;
};
RawMuxer = stjs.extend(RawMuxer, null, [Muxer, MuxerTrack], function(constructor, prototype) {
    prototype.ch = null;
    prototype.hasVideo = false;
    prototype.hasAudio = false;
    prototype.addVideoTrack = function(codec, meta) {
        if (this.hasAudio) 
             throw new RuntimeException("Raw muxer supports either video or audio track but not both.");
        this.hasVideo = true;
        return this;
    };
    prototype.addAudioTrack = function(codec, meta) {
        if (this.hasVideo) 
             throw new RuntimeException("Raw muxer supports either video or audio track but not both.");
        this.hasAudio = true;
        return this;
    };
    prototype.finish = function() {};
    prototype.addFrame = function(outPacket) {
        this.ch.write(outPacket.getData().duplicate());
    };
}, {ch: "SeekableByteChannel"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Mid/side stereo
 *  @author in-somnia
 */
var MS = function() {};
MS = stjs.extend(MS, null, [SyntaxConstants, HCB], function(constructor, prototype) {
    constructor.process = function(cpe, specL, specR) {
        var ics = cpe.getLeftChannel();
        var info = ics.getInfo();
        var offsets = info.getSWBOffsets();
        var windowGroups = info.getWindowGroupCount();
        var maxSFB = info.getMaxSFB();
        var sfbCBl = ics.getSfbCB();
        var sfbCBr = cpe.getRightChannel().getSfbCB();
        var groupOff = 0;
        var g, i, w, j, idx = 0;
        for (g = 0; g < windowGroups; g++) {
            for (i = 0; i < maxSFB; i++ , idx++) {
                if (cpe.isMSUsed(idx) && sfbCBl[idx] < HCB.NOISE_HCB && sfbCBr[idx] < HCB.NOISE_HCB) {
                    for (w = 0; w < info.getWindowGroupLength(g); w++) {
                        var off = groupOff + w * 128 + offsets[i];
                        for (j = 0; j < offsets[i + 1] - offsets[i]; j++) {
                            var t = specL[off + j] - specR[off + j];
                            specL[off + j] += specR[off + j];
                            specR[off + j] = t;
                        }
                    }
                }
            }
            groupOff += info.getWindowGroupLength(g) * 128;
        }
    };
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var PSTables = function() {};
PSTables = stjs.extend(PSTables, null, [PSConstants], function(constructor, prototype) {
    constructor.nr_iid_par_tab = new Int32Array([10, 20, 34, 10, 20, 34, 0, 0]);
    constructor.nr_icc_par_tab = new Int32Array([10, 20, 34, 10, 20, 34, 0, 0]);
    constructor.nr_ipdopd_par_tab = new Int32Array([5, 11, 17, 5, 11, 17, 0, 0]);
    constructor.num_env_tab = [new Int32Array([0, 1, 2, 4]), new Int32Array([1, 2, 3, 4])];
    constructor.filter_a = new Float32Array([0.6514391, 0.5647181, 0.48954165]);
    constructor.group_border20 = new Int32Array([6, 7, 0, 1, 2, 3, 9, 8, 10, 11, 3, 4, 5, 6, 7, 8, 9, 11, 14, 18, 23, 35, 64]);
    constructor.group_border34 = new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32 - 27, 33 - 27, 34 - 27, 35 - 27, 36 - 27, 37 - 27, 38 - 27, 40 - 27, 42 - 27, 44 - 27, 46 - 27, 48 - 27, 51 - 27, 54 - 27, 57 - 27, 60 - 27, 64 - 27, 68 - 27, 91 - 27]);
    constructor.map_group2bk20 = new Int32Array([(PSConstants.NEGATE_IPD_MASK | 1), (PSConstants.NEGATE_IPD_MASK | 0), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]);
    constructor.map_group2bk34 = new Int32Array([0, 1, 2, 3, 4, 5, 6, 6, 7, (PSConstants.NEGATE_IPD_MASK | 2), (PSConstants.NEGATE_IPD_MASK | 1), (PSConstants.NEGATE_IPD_MASK | 0), 10, 10, 4, 5, 6, 7, 8, 9, 10, 11, 12, 9, 14, 11, 12, 13, 14, 15, 16, 13, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33]);
    constructor.delay_length_d = new Int32Array([3, 4, 5]);
    constructor.p8_13_20 = new Float32Array([0.0074608293, 0.02270421, 0.04546866, 0.07266114, 0.098851085, 0.1179371, 0.125]);
    constructor.p2_13_20 = new Float32Array([0.0, 0.018994875, 0.0, -0.072931394, 0.0, 0.30596632, 0.5]);
    constructor.p12_13_34 = new Float32Array([0.0408118, 0.03812811, 0.051449083, 0.06399831, 0.07428314, 0.08100348, 0.083333336]);
    constructor.p8_13_34 = new Float32Array([0.015656756, 0.037527163, 0.054178912, 0.08417044, 0.10307344, 0.122224525, 0.125]);
    constructor.p4_13_34 = new Float32Array([-0.059082113, -0.048714984, 0.0, 0.07778724, 0.16486304, 0.23279856, 0.25]);
    constructor.Phi_Fract_Qmf = [new Float32Array([0.81814975, 0.57500523]), new Float32Array([-0.26387304, 0.9645574]), new Float32Array([-0.9969173, 0.0784591]), new Float32Array([-0.41151437, -0.9114033]), new Float32Array([0.7181263, -0.6959128]), new Float32Array([0.8980276, 0.43993917]), new Float32Array([-0.10973431, 0.993961]), new Float32Array([-0.9723699, 0.23344536]), new Float32Array([-0.5490228, -0.8358074]), new Float32Array([0.60042024, -0.79968464]), new Float32Array([0.955793, 0.29404032]), new Float32Array([0.047106452, 0.99888986]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([-0.6730125, -0.7396311]), new Float32Array([0.4679298, -0.88376564]), new Float32Array([0.9900237, 0.14090124]), new Float32Array([0.2027873, 0.97922283]), new Float32Array([-0.85264015, 0.52249855]), new Float32Array([-0.78043044, -0.62524265]), new Float32Array([0.32391742, -0.94608533]), new Float32Array([0.9998766, -0.015707318]), new Float32Array([0.35347486, 0.93544406]), new Float32Array([-0.76040596, 0.64944804]), new Float32Array([-0.86863154, -0.49545866]), new Float32Array([0.1719291, -0.9851093]), new Float32Array([0.9851093, -0.1719291]), new Float32Array([0.49545866, 0.86863154]), new Float32Array([-0.64944804, 0.76040596]), new Float32Array([-0.93544406, -0.35347486]), new Float32Array([0.015707318, -0.9998766]), new Float32Array([0.94608533, -0.32391742]), new Float32Array([0.62524265, 0.78043044]), new Float32Array([-0.52249855, 0.85264015]), new Float32Array([-0.97922283, -0.2027873]), new Float32Array([-0.14090124, -0.9900237]), new Float32Array([0.88376564, -0.4679298]), new Float32Array([0.7396311, 0.6730125]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([-0.99888986, -0.047106452]), new Float32Array([-0.29404032, -0.955793]), new Float32Array([0.79968464, -0.60042024]), new Float32Array([0.8358074, 0.5490228]), new Float32Array([-0.23344536, 0.9723699]), new Float32Array([-0.993961, 0.10973431]), new Float32Array([-0.43993917, -0.8980276]), new Float32Array([0.6959128, -0.7181263]), new Float32Array([0.9114033, 0.41151437]), new Float32Array([-0.0784591, 0.9969173]), new Float32Array([-0.9645574, 0.26387304]), new Float32Array([-0.57500523, -0.81814975]), new Float32Array([0.57500523, -0.81814975]), new Float32Array([0.9645574, 0.26387304]), new Float32Array([0.0784591, 0.9969173]), new Float32Array([-0.9114033, 0.41151437]), new Float32Array([-0.6959128, -0.7181263]), new Float32Array([0.43993917, -0.8980276]), new Float32Array([0.993961, 0.10973431]), new Float32Array([0.23344536, 0.9723699]), new Float32Array([-0.8358074, 0.5490228]), new Float32Array([-0.79968464, -0.60042024]), new Float32Array([0.29404032, -0.955793]), new Float32Array([0.99888986, -0.047106452]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([-0.7396311, 0.6730125])];
    constructor.Phi_Fract_SubQmf20 = [new Float32Array([0.988295, 0.15255463]), new Float32Array([0.89629304, 0.4434623]), new Float32Array([0.72085357, 0.69308734]), new Float32Array([0.4783087, 0.87819177]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([0.89629304, -0.4434623]), new Float32Array([0.988295, -0.15255463]), new Float32Array([-0.54244155, 0.84009355]), new Float32Array([0.039259817, 0.999229]), new Float32Array([-0.9268566, 0.37541556]), new Float32Array([-0.97417337, -0.22580127])];
    constructor.Phi_Fract_SubQmf34 = [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([0.33873793, 0.9408808]), new Float32Array([0.33873793, 0.9408808]), new Float32Array([0.33873793, 0.9408808]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([-0.77051324, 0.637424]), new Float32Array([-0.77051324, 0.637424]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([0.33873793, 0.9408808]), new Float32Array([0.33873793, 0.9408808]), new Float32Array([0.33873793, 0.9408808]), new Float32Array([0.33873793, 0.9408808]), new Float32Array([-0.77051324, 0.637424]), new Float32Array([-0.77051324, 0.637424]), new Float32Array([-0.86074203, -0.5090414]), new Float32Array([0.33873793, 0.9408808]), new Float32Array([0.18738131, -0.9822872]), new Float32Array([-0.77051324, 0.637424]), new Float32Array([-0.86074203, -0.5090414]), new Float32Array([-0.86074203, -0.5090414]), new Float32Array([0.18738131, -0.9822872]), new Float32Array([0.18738131, -0.9822872]), new Float32Array([0.98768836, -0.15643446]), new Float32Array([-0.86074203, -0.5090414])];
    constructor.Q_Fract_allpass_Qmf = [[new Float32Array([0.7804304, 0.62524265]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([0.8550929, 0.5184748])], [new Float32Array([-0.4399392, 0.89802754]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([-0.06435815, 0.9979269])], [new Float32Array([-0.9723699, -0.23344542]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([-0.91460717, 0.40434358])], [new Float32Array([0.015707396, -0.9998766]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([-0.7814115, -0.624016])], [new Float32Array([0.97922283, -0.20278719]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([0.19200818, -0.98139334])], [new Float32Array([0.41151425, 0.9114033]), new Float32Array([0.9238795, 0.38268343]), new Float32Array([0.95896834, -0.28351322])], [new Float32Array([-0.79968476, 0.6004201]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([0.69478387, 0.7192186])], [new Float32Array([-0.76040584, -0.64944816]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([-0.31647703, 0.9486002])], [new Float32Array([0.46793, -0.8837655]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([-0.9874414, 0.15798566])], [new Float32Array([0.96455735, 0.26387325]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([-0.59664506, -0.80250525])], [new Float32Array([-0.047106687, 0.99888986]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([0.43570253, -0.9000907])], [new Float32Array([-0.9851094, 0.17192885]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([0.9995547, -0.029840596])], [new Float32Array([-0.3826832, -0.9238796]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([0.48862115, 0.87249607])], [new Float32Array([0.81814986, -0.575005]), new Float32Array([0.9238795, 0.38268343]), new Float32Array([-0.54770935, 0.83666867])], [new Float32Array([0.7396309, 0.67301273]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([-0.9951074, -0.098798856])], [new Float32Array([-0.49545896, 0.86863136]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([-0.3725018, -0.9280315])], [new Float32Array([-0.9557929, -0.29404068]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([0.6506418, -0.75938475])], [new Float32Array([0.07845949, -0.9969173]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([0.97417337, 0.22580142])], [new Float32Array([0.99002373, -0.14090082]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([0.25021085, 0.9681914])], [new Float32Array([0.35347444, 0.9354442]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([-0.7427945, 0.6695195])], [new Float32Array([-0.8358076, 0.54902244]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([-0.9370993, -0.34906292])], [new Float32Array([-0.71812594, -0.69591314]), new Float32Array([0.9238795, 0.38268343]), new Float32Array([-0.12377448, -0.99231035])], [new Float32Array([0.522499, -0.8526399]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([0.82264066, -0.5685617])], [new Float32Array([0.9460852, 0.32391793]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([0.8844995, 0.4665412])], [new Float32Array([-0.109734856, 0.9939609]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([-0.004712592, 0.9999889])], [new Float32Array([-0.99396104, 0.10973374]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([-0.88885736, 0.458184])], [new Float32Array([-0.32391685, -0.9460856]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([-0.81724536, -0.5762899])], [new Float32Array([0.8526405, -0.522498]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([0.13312158, -0.9910997])], [new Float32Array([0.69591236, 0.7181267]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([0.9403476, -0.3402152])], [new Float32Array([-0.5490234, 0.835807]), new Float32Array([0.9238795, 0.38268343]), new Float32Array([0.7364512, 0.67649066])], [new Float32Array([-0.93544376, -0.35347548]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([-0.25932503, 0.9657901])], [new Float32Array([0.14090194, -0.99002355]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([-0.9762583, 0.21660973])], [new Float32Array([0.99691737, -0.07845837]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([-0.6434556, -0.7654834])], [new Float32Array([0.2940396, 0.95579326]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([0.38123202, -0.9244794])], [new Float32Array([-0.8686319, 0.495458]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([0.9959944, -0.0894155])], [new Float32Array([-0.6730119, -0.73963165]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([0.5397994, 0.8417937])], [new Float32Array([0.57500595, -0.81814927]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([-0.49682277, 0.86785203])], [new Float32Array([0.9238792, 0.3826842]), new Float32Array([0.9238795, 0.38268343]), new Float32Array([-0.999229, -0.039260153])], [new Float32Array([-0.17192996, 0.98510915]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([-0.42719975, -0.9041573])], [new Float32Array([-0.9988899, 0.047105566]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([0.60418224, -0.79684615])], [new Float32Array([-0.26387218, -0.96455765]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([0.9859085, 0.16728535])], [new Float32Array([0.88376606, -0.46792898]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([0.30752236, 0.9515409])], [new Float32Array([0.6494473, 0.7604066]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([-0.7015317, 0.71263826])], [new Float32Array([-0.600421, 0.79968405]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([-0.9562536, -0.29253897])], [new Float32Array([-0.9114029, -0.41151527]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([-0.18274994, -0.9831594])], [new Float32Array([0.2027883, -0.9792226]), new Float32Array([0.9238795, 0.38268343]), new Float32Array([0.78725827, -0.6166234])], [new Float32Array([0.9998767, -0.015706273]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([0.9107556, 0.41294587])], [new Float32Array([0.23344433, 0.97237015]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([0.054949753, 0.99848914])], [new Float32Array([-0.8980281, 0.4399382]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([-0.8599416, 0.5103925])], [new Float32Array([-0.6252418, -0.7804311]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([-0.8501682, -0.5265111])], [new Float32Array([0.62524354, -0.7804297]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([0.07376083, -0.99727595])], [new Float32Array([0.89802706, 0.4399402]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([0.9183775, -0.39570537])], [new Float32Array([-0.23344651, 0.9723697]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([0.77549547, 0.63135314])], [new Float32Array([-0.9998766, -0.01570852]), new Float32Array([0.9238795, 0.38268343]), new Float32Array([-0.20124936, 0.97954005])], [new Float32Array([-0.2027861, -0.9792231]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([-0.96159786, 0.27446228])], [new Float32Array([0.9114038, -0.4115132]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([-0.68797433, -0.725735])], [new Float32Array([0.6004192, 0.7996854]), new Float32Array([0.38268343, 0.9238795]), new Float32Array([0.3254036, -0.94557524])], [new Float32Array([-0.64944905, 0.7604051]), new Float32Array([-0.9238795, -0.38268343]), new Float32Array([0.9888866, -0.14867193])], [new Float32Array([-0.88376504, -0.46793097]), new Float32Array([0.9238795, -0.38268343]), new Float32Array([0.5890549, 0.808093])], [new Float32Array([0.26387435, -0.96455705]), new Float32Array([-0.38268343, 0.9238795]), new Float32Array([-0.4441666, 0.89594424])], [new Float32Array([0.9988898, 0.04710781]), new Float32Array([-0.38268343, -0.9238795]), new Float32Array([-0.9997915, 0.020418389])], [new Float32Array([0.17192774, 0.98510957]), new Float32Array([0.9238795, 0.38268343]), new Float32Array([-0.4803761, -0.8770626])], [new Float32Array([-0.92388004, 0.38268214]), new Float32Array([-0.9238795, 0.38268343]), new Float32Array([0.5555707, -0.8314693])], [new Float32Array([-0.5750041, -0.8181505]), new Float32Array([0.38268343, -0.9238795]), new Float32Array([0.99413204, 0.10817343])]];
    constructor.Q_Fract_allpass_SubQmf20 = [[new Float32Array([0.9857769, 0.16805927]), new Float32Array([0.95694035, 0.29028466]), new Float32Array([0.99073005, 0.13584526])], [new Float32Array([0.87440807, 0.4851912]), new Float32Array([0.6343933, 0.77301043]), new Float32Array([0.9175986, 0.39750826])], [new Float32Array([0.6642524, 0.74750835]), new Float32Array([0.09801714, 0.9951847]), new Float32Array([0.7767339, 0.62982893])], [new Float32Array([0.3790524, 0.9253752]), new Float32Array([-0.47139674, 0.8819213]), new Float32Array([0.578534, 0.8156583])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([0.87440807, -0.4851912]), new Float32Array([0.6343933, -0.77301043]), new Float32Array([0.9175986, -0.39750826])], [new Float32Array([0.9857769, -0.16805927]), new Float32Array([0.95694035, -0.29028466]), new Float32Array([0.99073005, -0.13584526])], [new Float32Array([-0.71263856, 0.7015314]), new Float32Array([-0.55557024, -0.8314696]), new Float32Array([-0.33059677, 0.9437721])], [new Float32Array([-0.117537424, 0.99306846]), new Float32Array([-0.98078525, 0.19509032]), new Float32Array([0.20663111, 0.97841895])], [new Float32Array([-0.99479216, 0.101924405]), new Float32Array([0.55557024, -0.8314696]), new Float32Array([-0.772013, 0.6356067])], [new Float32Array([-0.8400935, -0.5424416]), new Float32Array([0.98078525, 0.19509032]), new Float32Array([-0.98968893, 0.14323351])]];
    constructor.Q_Fract_allpass_SubQmf34 = [[new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([0.21814322, 0.97591674]), new Float32Array([-0.70710677, 0.70710677]), new Float32Array([0.46236774, 0.88668823])], [new Float32Array([0.21814322, 0.97591674]), new Float32Array([-0.70710677, 0.70710677]), new Float32Array([0.46236774, 0.88668823])], [new Float32Array([0.21814322, 0.97591674]), new Float32Array([-0.70710677, 0.70710677]), new Float32Array([0.46236774, 0.88668823])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([-0.90482706, 0.42577925]), new Float32Array([-0.0, -1.0]), new Float32Array([-0.57243216, 0.8199521])], [new Float32Array([-0.90482706, 0.42577925]), new Float32Array([-0.0, -1.0]), new Float32Array([-0.57243216, 0.8199521])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0]), new Float32Array([1.0, 0.0])], [new Float32Array([0.21814322, 0.97591674]), new Float32Array([-0.70710677, 0.70710677]), new Float32Array([0.46236774, 0.88668823])], [new Float32Array([0.21814322, 0.97591674]), new Float32Array([-0.70710677, 0.70710677]), new Float32Array([0.46236774, 0.88668823])], [new Float32Array([0.21814322, 0.97591674]), new Float32Array([-0.70710677, 0.70710677]), new Float32Array([0.46236774, 0.88668823])], [new Float32Array([0.21814322, 0.97591674]), new Float32Array([-0.70710677, 0.70710677]), new Float32Array([0.46236774, 0.88668823])], [new Float32Array([-0.90482706, 0.42577925]), new Float32Array([-0.0, -1.0]), new Float32Array([-0.57243216, 0.8199521])], [new Float32Array([-0.90482706, 0.42577925]), new Float32Array([-0.0, -1.0]), new Float32Array([-0.57243216, 0.8199521])], [new Float32Array([-0.612907, -0.79015505]), new Float32Array([0.70710677, 0.70710677]), new Float32Array([-0.991716, -0.12844945])], [new Float32Array([0.21814322, 0.97591674]), new Float32Array([-0.70710677, 0.70710677]), new Float32Array([0.46236774, 0.88668823])], [new Float32Array([0.63742405, -0.7705132]), new Float32Array([-1.0, 0.0]), new Float32Array([-0.34464288, -0.9387339])], [new Float32Array([-0.90482706, 0.42577925]), new Float32Array([-0.0, -1.0]), new Float32Array([-0.57243216, 0.8199521])], [new Float32Array([-0.612907, -0.79015505]), new Float32Array([0.70710677, 0.70710677]), new Float32Array([-0.991716, -0.12844945])], [new Float32Array([-0.612907, -0.79015505]), new Float32Array([0.70710677, 0.70710677]), new Float32Array([-0.991716, -0.12844945])], [new Float32Array([0.63742405, -0.7705132]), new Float32Array([-1.0, 0.0]), new Float32Array([-0.34464288, -0.9387339])], [new Float32Array([0.63742405, -0.7705132]), new Float32Array([-1.0, 0.0]), new Float32Array([-0.34464288, -0.9387339])], [new Float32Array([0.89100647, 0.4539906]), new Float32Array([0.70710677, -0.70710677]), new Float32Array([0.67301255, -0.73963106])], [new Float32Array([-0.612907, -0.79015505]), new Float32Array([0.70710677, 0.70710677]), new Float32Array([-0.991716, -0.12844945])]];
    constructor.cos_alphas = new Float32Array([1.0, 0.98412395, 0.95947385, 0.8946843, 0.8269341, 0.70710677, 0.4533211, 0.0]);
    constructor.sin_alphas = new Float32Array([0.0, 0.17748243, 0.28179777, 0.446699, 0.56229883, 0.70710677, 0.8913473, 1.0]);
    constructor.cos_betas_normal = [new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 0.9995872, 0.9989419, 0.99722046, 0.9953791, 0.99201125, 0.98434085, 0.9681727]), new Float32Array([1.0, 0.9984498, 0.99602795, 0.98957384, 0.98268145, 0.9701058, 0.94160986, 0.8822106]), new Float32Array([1.0, 0.9959399, 0.9896038, 0.97275895, 0.95483553, 0.922307, 0.849435, 0.70130056]), new Float32Array([1.0, 0.9932417, 0.9827072, 0.9547731, 0.9251669, 0.8717462, 0.7535521, 0.51988274]), new Float32Array([1.0, 0.99020684, 0.9749614, 0.9346539, 0.8921231, 0.8158851, 0.64959645, 0.33133706]), new Float32Array([1.0, 0.9880511, 0.96946704, 0.9204348, 0.8688623, 0.77685165, 0.5782162, 0.20699704]), new Float32Array([1.0, 0.9858997, 0.9639899, 0.90630347, 0.84582144, 0.7384262, 0.5089811, 0.09054659])];
    constructor.sin_betas_normal = [new Float32Array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]), new Float32Array([0.0, -0.028731337, -0.045989715, -0.07450743, -0.09602333, -0.12614924, -0.17627579, -0.25028294]), new Float32Array([0.0, -0.05566011, -0.08904127, -0.14402643, -0.18530284, -0.24268231, -0.33670583, -0.47085506]), new Float32Array([0.0, -0.09002074, -0.14382043, -0.23181884, -0.29713482, -0.38645792, -0.52769333, -0.7128657]), new Float32Array([0.0, -0.116063975, -0.18516637, -0.2973354, -0.37956056, -0.48995778, -0.6573882, -0.8542376]), new Float32Array([0.0, -0.1396083, -0.22237422, -0.35555896, -0.45179233, -0.57821405, -0.76027924, -0.94351244]), new Float32Array([0.0, -0.15412669, -0.2452217, -0.39089614, -0.49505386, -0.6296836, -0.8158836, -0.9783416]), new Float32Array([0.0, -0.16733736, -0.2659389, -0.4226275, -0.5334661, -0.6743343, -0.8607777, -0.9958922])];
    constructor.cos_betas_fine = [new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 0.9995872, 0.9989419, 0.99722046, 0.9953791, 0.99201125, 0.98434085, 0.9681727]), new Float32Array([1.0, 0.9984498, 0.99602795, 0.98957384, 0.98268145, 0.9701058, 0.94160986, 0.8822106]), new Float32Array([1.0, 0.9968361, 0.9918968, 0.97875404, 0.96475154, 0.9392903, 0.8820167, 0.76453257]), new Float32Array([1.0, 0.9950263, 0.9872675, 0.9666585, 0.94475883, 0.9050918, 0.8165997, 0.6383825]), new Float32Array([1.0, 0.9932417, 0.9827072, 0.9547731, 0.9251669, 0.8717462, 0.7535521, 0.51988274]), new Float32Array([1.0, 0.9908828, 0.9766856, 0.93912494, 0.89945316, 0.82823527, 0.6723983, 0.37194732]), new Float32Array([1.0, 0.98902404, 0.971946, 0.92684484, 0.87933886, 0.7944023, 0.6101812, 0.2621501]), new Float32Array([1.0, 0.987635, 0.96840733, 0.91769737, 0.864393, 0.7693796, 0.56467205, 0.18388996]), new Float32Array([1.0, 0.9866247, 0.965835, 0.9110591, 0.8535668, 0.75131655, 0.5320915, 0.1289531]), new Float32Array([1.0, 0.9858997, 0.9639899, 0.90630347, 0.84582144, 0.7384262, 0.5089811, 0.09054659]), new Float32Array([1.0, 0.9851246, 0.962018, 0.9012266, 0.8375623, 0.7247108, 0.48452044, 0.0504115]), new Float32Array([1.0, 0.984687, 0.96090525, 0.89836395, 0.8329098, 0.71699834, 0.47082454, 0.028173251]), new Float32Array([1.0, 0.9844406, 0.96027887, 0.8967534, 0.83029366, 0.7126658, 0.46314928, 0.015785115]), new Float32Array([1.0, 0.98430204, 0.95992655, 0.89584774, 0.8288229, 0.7102316, 0.45884293, 0.008857806]), new Float32Array([1.0, 0.98422414, 0.9597284, 0.89533854, 0.82799613, 0.70886356, 0.45642468, 0.0049751354])];
    constructor.sin_betas_fine = [new Float32Array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]), new Float32Array([0.0, -0.028731337, -0.045989715, -0.07450743, -0.09602333, -0.12614924, -0.17627579, -0.25028294]), new Float32Array([0.0, -0.05566011, -0.08904127, -0.14402643, -0.18530284, -0.24268231, -0.33670583, -0.47085506]), new Float32Array([0.0, -0.07948406, -0.12704612, -0.20503783, -0.26316252, -0.3431235, -0.47121814, -0.64458513]), new Float32Array([0.0, -0.099612646, -0.15906878, -0.25606918, -0.3277662, -0.42521614, -0.57720435, -0.7697193]), new Float32Array([0.0, -0.116063975, -0.18516637, -0.2973354, -0.37956056, -0.48995778, -0.6573882, -0.8542376]), new Float32Array([0.0, -0.13472667, -0.21467477, -0.34357587, -0.43701714, -0.5603805, -0.7401895, -0.9282538]), new Float32Array([0.0, -0.14775485, -0.23520416, -0.37544465, -0.4761966, -0.6073919, -0.7922619, -0.9650271]), new Float32Array([0.0, -0.15677059, -0.24937364, -0.39728013, -0.5028168, -0.63879186, -0.82531536, -0.9829468]), new Float32Array([0.0, -0.16300823, -0.2591579, -0.41227582, -0.5209834, -0.65994203, -0.84668684, -0.9916507]), new Float32Array([0.0, -0.16733736, -0.2659389, -0.4226275, -0.5334661, -0.6743343, -0.8607777, -0.9958922]), new Float32Array([0.0, -0.17184179, -0.27298594, -0.43334824, -0.5463418, -0.6890532, -0.87477994, -0.9987285]), new Float32Array([0.0, -0.1743317, -0.27687746, -0.43925187, -0.5534087, -0.6970749, -0.8822269, -0.99960303]), new Float32Array([0.0, -0.1757175, -0.27904215, -0.44253063, -0.5573262, -0.7015037, -0.8862803, -0.9998754]), new Float32Array([0.0, -0.17649214, -0.28025177, -0.44436115, -0.559511, -0.7039681, -0.8885174, -0.9999608]), new Float32Array([0.0, -0.17692624, -0.28092957, -0.4453863, -0.5607338, -0.70534563, -0.88976204, -0.9999876])];
    constructor.sincos_alphas_B_normal = [new Float32Array([0.05614541, 0.052638587, 0.047293734, 0.033841062, 0.020726107, 0.0028205635, 0.0028205635, 0.0028205635]), new Float32Array([0.12490651, 0.11736977, 0.10578883, 0.07619851, 0.04687327, 0.0063956105, 0.0063956105, 0.0063956105]), new Float32Array([0.19566931, 0.18460901, 0.16736451, 0.122062184, 0.07573625, 0.010388263, 0.010388263, 0.010388263]), new Float32Array([0.30151132, 0.28705257, 0.2637739, 0.19845739, 0.12607498, 0.017560013, 0.017560013, 0.017560013]), new Float32Array([0.40784496, 0.39298525, 0.36805892, 0.29110292, 0.19345124, 0.027868671, 0.027868671, 0.027868671]), new Float32Array([0.53361714, 0.5226638, 0.5033653, 0.43491626, 0.32246822, 0.052199904, 0.052199904, 0.052199904]), new Float32Array([0.62198323, 0.6161847, 0.6057251, 0.5654343, 0.482615, 0.10580447, 0.10580447, 0.10580447]), new Float32Array([0.70710677, 0.70710677, 0.70710677, 0.70710677, 0.70710677, 0.70710677, 0.70710677, 0.70710677]), new Float32Array([0.78303057, 0.78760165, 0.79567397, 0.82479334, 0.8758326, 0.994387, 0.994387, 0.994387]), new Float32Array([0.8457262, 0.8525389, 0.86407375, 0.9004709, 0.9465803, 0.99863666, 0.99863666, 0.99863666]), new Float32Array([0.9130512, 0.91954476, 0.9298024, 0.95669174, 0.98110986, 0.9996116, 0.9996116, 0.9996116]), new Float32Array([0.9534626, 0.9579148, 0.9645845, 0.9801095, 0.9920207, 0.9998458, 0.9998458, 0.9998458]), new Float32Array([0.9806699, 0.98281205, 0.9858951, 0.9925224, 0.9971279, 0.99994606, 0.99994606, 0.99994606]), new Float32Array([0.9921685, 0.99308825, 0.99438864, 0.99709266, 0.99890083, 0.99997956, 0.99997956, 0.99997956]), new Float32Array([0.9984226, 0.99861366, 0.99888104, 0.9994272, 0.9997852, 0.999996, 0.999996, 0.999996])];
    constructor.sincos_alphas_B_fine = [new Float32Array([0.0031622157, 0.0029630181, 0.0026599893, 0.0019002703, 0.0011626042, 1.580278E-4, 1.580278E-4, 1.580278E-4]), new Float32Array([0.0056232675, 0.0052689826, 0.0047302824, 0.0033791757, 0.0020674015, 2.81171E-4, 2.81171E-4, 2.81171E-4]), new Float32Array([0.009999422, 0.0093696695, 0.008411742, 0.0060093794, 0.003676601, 5.000392E-4, 5.000392E-4, 5.000392E-4]), new Float32Array([0.01777992, 0.01666071, 0.014958138, 0.010687581, 0.0065392544, 8.893767E-4, 8.893767E-4, 8.893767E-4]), new Float32Array([0.03160697, 0.029621158, 0.02659873, 0.019011382, 0.011634997, 0.0015826974, 0.0015826974, 0.0015826974]), new Float32Array([0.05614541, 0.052638587, 0.047293734, 0.033841062, 0.020726107, 0.0028205635, 0.0028205635, 0.0028205635]), new Float32Array([0.07918341, 0.07427981, 0.06679073, 0.047870528, 0.029350074, 0.0039966754, 0.0039966754, 0.0039966754]), new Float32Array([0.11150212, 0.1047142, 0.094305314, 0.067812055, 0.041666914, 0.0056813215, 0.0056813215, 0.0056813215]), new Float32Array([0.1565355, 0.14732584, 0.1330924, 0.09632822, 0.05945091, 0.008127795, 0.008127795, 0.008127795]), new Float32Array([0.21846437, 0.20645796, 0.18762654, 0.13757442, 0.08568967, 0.0117817335, 0.0117817335, 0.0117817335]), new Float32Array([0.30151132, 0.28705257, 0.2637739, 0.19845739, 0.12607498, 0.017560013, 0.017560013, 0.017560013]), new Float32Array([0.36987412, 0.35477272, 0.32982522, 0.2556266, 0.166599, 0.023634454, 0.023634454, 0.023634454]), new Float32Array([0.4480624, 0.433941, 0.4098614, 0.33227092, 0.22667848, 0.033409413, 0.033409413, 0.033409413]), new Float32Array([0.53361714, 0.5226638, 0.5033653, 0.43491626, 0.32246822, 0.052199904, 0.052199904, 0.052199904]), new Float32Array([0.62198323, 0.6161847, 0.6057251, 0.5654343, 0.482615, 0.10580447, 0.10580447, 0.10580447]), new Float32Array([0.70710677, 0.70710677, 0.70710677, 0.70710677, 0.70710677, 0.70710677, 0.70710677, 0.70710677]), new Float32Array([0.78303057, 0.78760165, 0.79567397, 0.82479334, 0.8758326, 0.994387, 0.994387, 0.994387]), new Float32Array([0.8457262, 0.8525389, 0.86407375, 0.9004709, 0.9465803, 0.99863666, 0.99863666, 0.99863666]), new Float32Array([0.8940022, 0.90094125, 0.91214776, 0.94318396, 0.97396964, 0.99944174, 0.99944174, 0.99944174]), new Float32Array([0.92908186, 0.93495256, 0.944042, 0.9667756, 0.98602474, 0.9997207, 0.9997207, 0.9997207]), new Float32Array([0.9534626, 0.9579148, 0.9645845, 0.9801095, 0.9920207, 0.9998458, 0.9998458, 0.9998458]), new Float32Array([0.9758449, 0.9784555, 0.98224044, 0.99049145, 0.99632186, 0.9999306, 0.9999306, 0.9999306]), new Float32Array([0.9876723, 0.989088, 0.99110365, 0.99534965, 0.99823123, 0.999967, 0.999967, 0.999967]), new Float32Array([0.99376416, 0.99450237, 0.9955433, 0.9976981, 0.99913156, 0.99998385, 0.99998385, 0.99998385]), new Float32Array([0.9968601, 0.99723744, 0.99776703, 0.99885356, 0.9995692, 0.999992, 0.999992, 0.999992]), new Float32Array([0.9984226, 0.99861366, 0.99888104, 0.9994272, 0.9997852, 0.999996, 0.999996, 0.999996]), new Float32Array([0.9995004, 0.9995612, 0.9996462, 0.9998193, 0.9999323, 0.99999875, 0.99999875, 0.99999875]), new Float32Array([0.9998419, 0.9998612, 0.9998881, 0.9999429, 0.9999786, 0.9999996, 0.9999996, 0.9999996]), new Float32Array([0.99995, 0.99995613, 0.9999646, 0.99998194, 0.99999326, 0.9999999, 0.9999999, 0.9999999]), new Float32Array([0.9999842, 0.9999861, 0.9999888, 0.9999943, 0.99999785, 0.99999994, 0.99999994, 0.99999994]), new Float32Array([0.999995, 0.9999956, 0.9999965, 0.9999982, 0.99999934, 1.0, 1.0, 1.0])];
    constructor.cos_gammas_normal = [new Float32Array([1.0, 0.98412395, 0.95947385, 0.8946843, 0.8269341, 0.72456884, 0.72456884, 0.72456884]), new Float32Array([1.0, 0.9849691, 0.9617777, 0.9020941, 0.84368306, 0.7846833, 0.7846833, 0.7846833]), new Float32Array([1.0, 0.98716563, 0.9676775, 0.9199103, 0.8785067, 0.8464232, 0.8464232, 0.8464232]), new Float32Array([1.0, 0.9913534, 0.9786, 0.94960636, 0.9277157, 0.9133354, 0.9133354, 0.9133354]), new Float32Array([1.0, 0.9948924, 0.9875319, 0.97163296, 0.9604805, 0.953595, 0.953595, 0.953595]), new Float32Array([1.0, 0.9977406, 0.99454236, 0.9878737, 0.983398, 0.98072076, 0.98072076, 0.98072076]), new Float32Array([1.0, 0.9990607, 0.99774176, 0.99503237, 0.9932453, 0.99218845, 0.99218845, 0.99218845]), new Float32Array([1.0, 0.9998082, 0.99954003, 0.99899364, 0.99863654, 0.99842656, 0.99842656, 0.99842656])];
    constructor.cos_gammas_fine = [new Float32Array([1.0, 0.98412395, 0.95947385, 0.8946843, 0.8269341, 0.72456884, 0.72456884, 0.72456884]), new Float32Array([1.0, 0.9849691, 0.9617777, 0.9020941, 0.84368306, 0.7846833, 0.7846833, 0.7846833]), new Float32Array([1.0, 0.98716563, 0.9676775, 0.9199103, 0.8785067, 0.8464232, 0.8464232, 0.8464232]), new Float32Array([1.0, 0.9899597, 0.97500986, 0.9402334, 0.9129699, 0.8943766, 0.8943766, 0.8943766]), new Float32Array([1.0, 0.99266076, 0.9819296, 0.95801604, 0.94049937, 0.9293004, 0.9293004, 0.9293004]), new Float32Array([1.0, 0.9948924, 0.9875319, 0.97163296, 0.9604805, 0.953595, 0.953595, 0.953595]), new Float32Array([1.0, 0.99720746, 0.9932414, 0.9849198, 0.97929263, 0.97590923, 0.97590923, 0.97590923]), new Float32Array([1.0, 0.99853617, 0.9964742, 0.9922136, 0.98938453, 0.98770416, 0.98770416, 0.98770416]), new Float32Array([1.0, 0.99924946, 0.9981967, 0.9960387, 0.9946186, 0.99378, 0.99378, 0.99378]), new Float32Array([1.0, 0.9996195, 0.9990869, 0.9979996, 0.9972874, 0.99686795, 0.99686795, 0.99686795]), new Float32Array([1.0, 0.9998082, 0.99954003, 0.99899364, 0.99863654, 0.99842656, 0.99842656, 0.99842656]), new Float32Array([1.0, 0.9999391, 0.999854, 0.99968094, 0.999568, 0.99950165, 0.99950165, 0.99950165]), new Float32Array([1.0, 0.9999807, 0.9999538, 0.999899, 0.99986327, 0.99984235, 0.99984235, 0.99984235]), new Float32Array([1.0, 0.9999939, 0.9999854, 0.99996805, 0.9999568, 0.9999501, 0.9999501, 0.9999501]), new Float32Array([1.0, 0.9999981, 0.99999535, 0.99998987, 0.99998635, 0.9999842, 0.9999842, 0.9999842]), new Float32Array([1.0, 0.9999994, 0.99999857, 0.9999968, 0.99999565, 0.999995, 0.999995, 0.999995])];
    constructor.sin_gammas_normal = [new Float32Array([0.0, 0.17748243, 0.28179777, 0.446699, 0.56229883, 0.6892024, 0.6892024, 0.6892024]), new Float32Array([0.0, 0.17273088, 0.27383152, 0.43153927, 0.53684163, 0.6198969, 0.6198969, 0.6198969]), new Float32Array([0.0, 0.1596999, 0.252191, 0.39212888, 0.47773004, 0.53251076, 0.53251076, 0.53251076]), new Float32Array([0.0, 0.13121906, 0.20577173, 0.31344506, 0.37328747, 0.40720809, 0.40720809, 0.40720809]), new Float32Array([0.0, 0.100940704, 0.1574189, 0.23649386, 0.2783472, 0.30109245, 0.30109245, 0.30109245]), new Float32Array([0.0, 0.06718363, 0.10433334, 0.15525985, 0.1814615, 0.19541448, 0.19541448, 0.19541448]), new Float32Array([0.0, 0.043332487, 0.06716661, 0.09955164, 0.11603327, 0.12474787, 0.12474787, 0.12474787]), new Float32Array([0.0, 0.019586058, 0.030326985, 0.04485193, 0.052202202, 0.056075003, 0.056075003, 0.056075003])];
    constructor.sin_gammas_fine = [new Float32Array([0.0, 0.17748243, 0.28179777, 0.446699, 0.56229883, 0.6892024, 0.6892024, 0.6892024]), new Float32Array([0.0, 0.17273088, 0.27383152, 0.43153927, 0.53684163, 0.6198969, 0.6198969, 0.6198969]), new Float32Array([0.0, 0.1596999, 0.252191, 0.39212888, 0.47773004, 0.53251076, 0.53251076, 0.53251076]), new Float32Array([0.0, 0.14134967, 0.22216155, 0.34053072, 0.40802696, 0.44731477, 0.44731477, 0.44731477]), new Float32Array([0.0, 0.12093227, 0.18924671, 0.2867147, 0.33979544, 0.36932462, 0.36932462, 0.36932462]), new Float32Array([0.0, 0.100940704, 0.1574189, 0.23649386, 0.2783472, 0.30109245, 0.30109245, 0.30109245]), new Float32Array([0.0, 0.07468114, 0.11606665, 0.17301174, 0.20244971, 0.21817683, 0.21817683, 0.21817683]), new Float32Array([0.0, 0.05408753, 0.08389972, 0.12454762, 0.14532112, 0.1563347, 0.1563347, 0.1563347]), new Float32Array([0.0, 0.038737107, 0.06002761, 0.08892122, 0.103604406, 0.11136096, 0.11136096, 0.11136096]), new Float32Array([0.0, 0.02758461, 0.042723317, 0.063219815, 0.07360646, 0.07908376, 0.07908376, 0.07908376]), new Float32Array([0.0, 0.019586058, 0.030326985, 0.04485193, 0.052202202, 0.056075003, 0.056075003, 0.056075003]), new Float32Array([0.0, 0.011036395, 0.017085798, 0.025259212, 0.029391602, 0.031567305, 0.031567305, 0.031567305]), new Float32Array([0.0, 0.0062101283, 0.00961382, 0.014210965, 0.016534565, 0.017757632, 0.017757632, 0.017757632]), new Float32Array([0.0, 0.0034934508, 0.0054071187, 0.007992832, 0.009299404, 0.009987163, 0.009987163, 0.009987163]), new Float32Array([0.0, 0.0019645398, 0.0030419906, 0.004495151, 0.0052291853, 0.00561665, 0.00561665, 0.00561665]), new Float32Array([0.0, 0.0011053943, 0.0017089869, 0.002528367, 0.0029398552, 0.0031573684, 0.0031573684, 0.0031573684])];
    constructor.sf_iid_normal = new Float32Array([1.4119828, 1.4031382, 1.3868767, 1.3483998, 1.2912494, 1.1960374, 1.1073724, 1.0, 0.87961715, 0.75464857, 0.5767799, 0.42640144, 0.2767183, 0.17664462, 0.07940163]);
    constructor.sf_iid_fine = new Float32Array([1.4142065, 1.4141912, 1.4141428, 1.41399, 1.413507, 1.4119828, 1.409773, 1.4053948, 1.3967797, 1.380053, 1.3483998, 1.3139201, 1.2643101, 1.1960374, 1.1073724, 1.0, 0.87961715, 0.75464857, 0.6336561, 0.52308106, 0.42640144, 0.3089554, 0.22137465, 0.15768789, 0.11198225, 0.07940163, 0.044699017, 0.025144693, 0.014141428, 0.007952581, 0.0044721137]);
    constructor.ipdopd_cos_tab = new Float32Array([1.0, 0.70710677, 0.0, -0.70710677, -1.0, -0.70710677, -0.0, 0.70710677, 1.0]);
    constructor.ipdopd_sin_tab = new Float32Array([0.0, 0.70710677, 1.0, 0.70710677, 0.0, -0.70710677, -1.0, -0.70710677, -0.0]);
}, {nr_iid_par_tab: "Int32Array", nr_icc_par_tab: "Int32Array", nr_ipdopd_par_tab: "Int32Array", num_env_tab: "Array", filter_a: "Float32Array", group_border20: "Int32Array", group_border34: "Int32Array", map_group2bk20: "Int32Array", map_group2bk34: "Int32Array", delay_length_d: "Int32Array", p8_13_20: "Float32Array", p2_13_20: "Float32Array", p12_13_34: "Float32Array", p8_13_34: "Float32Array", p4_13_34: "Float32Array", Phi_Fract_Qmf: "Array", Phi_Fract_SubQmf20: "Array", Phi_Fract_SubQmf34: "Array", Q_Fract_allpass_Qmf: "Array", Q_Fract_allpass_SubQmf20: "Array", Q_Fract_allpass_SubQmf34: "Array", cos_alphas: "Float32Array", sin_alphas: "Float32Array", cos_betas_normal: "Array", sin_betas_normal: "Array", cos_betas_fine: "Array", sin_betas_fine: "Array", sincos_alphas_B_normal: "Array", sincos_alphas_B_fine: "Array", cos_gammas_normal: "Array", cos_gammas_fine: "Array", sin_gammas_normal: "Array", sin_gammas_fine: "Array", sf_iid_normal: "Float32Array", sf_iid_fine: "Float32Array", ipdopd_cos_tab: "Float32Array", ipdopd_sin_tab: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Asserts = function() {};
Asserts = stjs.extend(Asserts, null, [], function(constructor, prototype) {
    constructor.assertEquals = function(expected, actual) {
        if (expected != actual) {
             throw new AssertionException("assert failed: " + expected + " != " + actual);
        }
    };
    constructor.assertInRange = function(message, low, up, val) {
        if (val < low || val > up) {
             throw new AssertionException(message);
        }
    };
    constructor.assertEpsilonEqualsInt = function(expected, actual, eps) {
        if (expected.length != actual.length) 
             throw new AssertionException("arrays of different size");
        for (var i = 0; i < expected.length; i++) {
            var e = expected[i];
            var a = actual[i];
            if (Math.abs(e - a) > eps) {
                 throw new AssertionException("array element out of expected diff range");
            }
        }
    };
    constructor.assertEpsilonEquals = function(expected, actual, eps) {
        if (expected.length != actual.length) 
             throw new AssertionException("arrays of different size");
        for (var i = 0; i < expected.length; i++) {
            var e = expected[i] & 255;
            var a = actual[i] & 255;
            if (Math.abs(e - a) > eps) {
                 throw new AssertionException("array element out of expected diff range: " + (Math.abs(e - a)));
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VPXMacroblock = function(y, x) {
    this.ySubblocks = Array.apply(null, Array(4)).map(function() {
        return Array(4);
    });
    this.y2 = new VPXMacroblock.Subblock(this, 0, 0, VP8Util.PLANE.Y2);
    this.uSubblocks = Array.apply(null, Array(2)).map(function() {
        return Array(2);
    });
    this.vSubblocks = Array.apply(null, Array(2)).map(function() {
        return Array(2);
    });
    this.Rrow = y;
    this.column = x;
    for (var row = 0; row < 4; row++) 
        for (var col = 0; col < 4; col++) 
            this.ySubblocks[row][col] = new VPXMacroblock.Subblock(this, row, col, VP8Util.PLANE.Y1);
    for (var row = 0; row < 2; row++) 
        for (var col = 0; col < 2; col++) {
            this.uSubblocks[row][col] = new VPXMacroblock.Subblock(this, row, col, VP8Util.PLANE.U);
            this.vSubblocks[row][col] = new VPXMacroblock.Subblock(this, row, col, VP8Util.PLANE.V);
        }
};
VPXMacroblock = stjs.extend(VPXMacroblock, null, [], function(constructor, prototype) {
    prototype.filterLevel = 0;
    prototype.chromaMode = 0;
    prototype.skipCoeff = 0;
    prototype.ySubblocks = null;
    prototype.y2 = null;
    prototype.uSubblocks = null;
    prototype.vSubblocks = null;
    prototype.Rrow = 0;
    prototype.column = 0;
    prototype.lumaMode = 0;
    prototype.skipFilter = false;
    prototype.segment = 0;
    prototype.debug = true;
    prototype.quants = null;
    prototype.dequantMacroBlock = function(mbs) {
        var p = this.quants;
        if (this.lumaMode != VP8Util.SubblockConstants.B_PRED) {
            var acQValue = p.y2AC;
            var dcQValue = p.y2DC;
            var input = new Int32Array(16);
            input[0] = this.y2.tokens[0] * dcQValue;
            for (var x = 1; x < 16; x++) 
                input[x] = this.y2.tokens[x] * acQValue;
            this.y2.residue = VP8DCT.decodeWHT(input);
            for (var row = 0; row < 4; row++) 
                for (var col = 0; col < 4; col++) 
                    this.ySubblocks[row][col].dequantSubblock(p.yDC, p.yAC, this.y2.residue[row * 4 + col]);
            this.predictY(mbs);
            this.predictUV(mbs);
            for (var row = 0; row < 2; row++) {
                for (var col = 0; col < 2; col++) {
                    this.uSubblocks[row][col].dequantSubblock(p.chromaDC, p.chromaAC, null);
                    this.vSubblocks[row][col].dequantSubblock(p.chromaDC, p.chromaAC, null);
                }
            }
            this.reconstruct();
        } else {
            for (var row = 0; row < 4; row++) {
                for (var col = 0; col < 4; col++) {
                    var sb = this.ySubblocks[row][col];
                    sb.dequantSubblock(p.yDC, p.yAC, null);
                    sb.predict(mbs);
                    sb.reconstruct();
                }
            }
            this.predictUV(mbs);
            for (var row = 0; row < 2; row++) {
                for (var col = 0; col < 2; col++) {
                    var sb = this.uSubblocks[row][col];
                    sb.dequantSubblock(p.chromaDC, p.chromaAC, null);
                    sb.reconstruct();
                }
            }
            for (var row = 0; row < 2; row++) {
                for (var col = 0; col < 2; col++) {
                    var sb = this.vSubblocks[row][col];
                    sb.dequantSubblock(p.chromaDC, p.chromaAC, null);
                    sb.reconstruct();
                }
            }
        }
    };
    prototype.reconstruct = function() {
        for (var row = 0; row < 4; row++) 
            for (var col = 0; col < 4; col++) 
                this.ySubblocks[row][col].reconstruct();
        for (var row = 0; row < 2; row++) 
            for (var col = 0; col < 2; col++) 
                this.uSubblocks[row][col].reconstruct();
        for (var row = 0; row < 2; row++) 
            for (var col = 0; col < 2; col++) 
                this.vSubblocks[row][col].reconstruct();
    };
    prototype.predictUV = function(mbs) {
        var aboveMb = mbs[this.Rrow - 1][this.column];
        var leftMb = mbs[this.Rrow][this.column - 1];
        switch (this.chromaMode) {
            case VP8Util.SubblockConstants.DC_PRED:
                var up_available = false;
                var left_available = false;
                var uAvg = 0;
                var vAvg = 0;
                var expected_udc = 128;
                var expected_vdc = 128;
                if (this.column > 1) 
                    left_available = true;
                if (this.Rrow > 1) 
                    up_available = true;
                if (up_available || left_available) {
                    if (up_available) {
                        for (var j = 0; j < 2; j++) {
                            var usb = aboveMb.uSubblocks[1][j];
                            var vsb = aboveMb.vSubblocks[1][j];
                            for (var i = 0; i < 4; i++) {
                                uAvg += usb.val[3 * 4 + i];
                                vAvg += vsb.val[3 * 4 + i];
                            }
                        }
                    }
                    if (left_available) {
                        for (var j = 0; j < 2; j++) {
                            var usb = leftMb.uSubblocks[j][1];
                            var vsb = leftMb.vSubblocks[j][1];
                            for (var i = 0; i < 4; i++) {
                                uAvg += usb.val[i * 4 + 3];
                                vAvg += vsb.val[i * 4 + 3];
                            }
                        }
                    }
                    var shift = 2;
                    if (up_available) 
                        shift++;
                    if (left_available) 
                        shift++;
                    expected_udc = (uAvg + (1 << (shift - 1))) >> shift;
                    expected_vdc = (vAvg + (1 << (shift - 1))) >> shift;
                }
                var ufill = new Int32Array(16);
                for (var aRow = 0; aRow < 4; aRow++) 
                    for (var aCol = 0; aCol < 4; aCol++) 
                        ufill[aRow * 4 + aCol] = expected_udc;
                var vfill = new Int32Array(16);
                for (var aRow = 0; aRow < 4; aRow++) 
                    for (var aCol = 0; aCol < 4; aCol++) 
                        vfill[aRow * 4 + aCol] = expected_vdc;
                for (var aRow = 0; aRow < 2; aRow++) {
                    for (var aCol = 0; aCol < 2; aCol++) {
                        var usb = this.uSubblocks[aRow][aCol];
                        var vsb = this.vSubblocks[aRow][aCol];
                        usb._predict = ufill;
                        vsb._predict = vfill;
                    }
                }
                break;
            case VP8Util.SubblockConstants.V_PRED:
                var aboveUSb = Array(2);
                var aboveVSb = Array(2);
                for (var aCol = 0; aCol < 2; aCol++) {
                    aboveUSb[aCol] = aboveMb.uSubblocks[1][aCol];
                    aboveVSb[aCol] = aboveMb.vSubblocks[1][aCol];
                }
                for (var aRow = 0; aRow < 2; aRow++) 
                    for (var aCol = 0; aCol < 2; aCol++) {
                        var usb = this.uSubblocks[aRow][aCol];
                        var vsb = this.vSubblocks[aRow][aCol];
                        var ublock = new Int32Array(16);
                        var vblock = new Int32Array(16);
                        for (var pRow = 0; pRow < 4; pRow++) 
                            for (var pCol = 0; pCol < 4; pCol++) {
                                ublock[pRow * 4 + pCol] = aboveUSb[aCol].val != null ? aboveUSb[aCol].val[3 * 4 + pCol] : 127;
                                vblock[pRow * 4 + pCol] = aboveVSb[aCol].val != null ? aboveVSb[aCol].val[3 * 4 + pCol] : 127;
                            }
                        usb._predict = ublock;
                        vsb._predict = vblock;
                    }
                break;
            case VP8Util.SubblockConstants.H_PRED:
                var leftUSb = Array(2);
                var leftVSb = Array(2);
                for (var aCol = 0; aCol < 2; aCol++) {
                    leftUSb[aCol] = leftMb.uSubblocks[aCol][1];
                    leftVSb[aCol] = leftMb.vSubblocks[aCol][1];
                }
                for (var aRow = 0; aRow < 2; aRow++) 
                    for (var aCol = 0; aCol < 2; aCol++) {
                        var usb = this.uSubblocks[aRow][aCol];
                        var vsb = this.vSubblocks[aRow][aCol];
                        var ublock = new Int32Array(16);
                        var vblock = new Int32Array(16);
                        for (var pRow = 0; pRow < 4; pRow++) 
                            for (var pCol = 0; pCol < 4; pCol++) {
                                ublock[pRow * 4 + pCol] = leftUSb[aRow].val != null ? leftUSb[aRow].val[pRow * 4 + 3] : 129;
                                vblock[pRow * 4 + pCol] = leftVSb[aRow].val != null ? leftVSb[aRow].val[pRow * 4 + 3] : 129;
                            }
                        usb._predict = ublock;
                        vsb._predict = vblock;
                    }
                break;
            case VP8Util.SubblockConstants.TM_PRED:
                var ALMb = mbs[this.Rrow - 1][this.column - 1];
                var ALUSb = ALMb.uSubblocks[1][1];
                var alu = ALUSb.val[3 * 4 + 3];
                var ALVSb = ALMb.vSubblocks[1][1];
                var alv = ALVSb.val[3 * 4 + 3];
                aboveUSb = Array(2);
                leftUSb = Array(2);
                aboveVSb = Array(2);
                leftVSb = Array(2);
                for (var x = 0; x < 2; x++) {
                    aboveUSb[x] = aboveMb.uSubblocks[1][x];
                    leftUSb[x] = leftMb.uSubblocks[x][1];
                    aboveVSb[x] = aboveMb.vSubblocks[1][x];
                    leftVSb[x] = leftMb.vSubblocks[x][1];
                }
                for (var sbRow = 0; sbRow < 2; sbRow++) {
                    for (var pRow = 0; pRow < 4; pRow++) {
                        for (var sbCol = 0; sbCol < 2; sbCol++) {
                            if (this.uSubblocks[sbRow][sbCol].val == null) 
                                this.uSubblocks[sbRow][sbCol].val = new Int32Array(16);
                            if (this.vSubblocks[sbRow][sbCol].val == null) 
                                this.vSubblocks[sbRow][sbCol].val = new Int32Array(16);
                            for (var pCol = 0; pCol < 4; pCol++) {
                                var upred = leftUSb[sbRow].val[pRow * 4 + 3] + aboveUSb[sbCol].val[3 * 4 + pCol] - alu;
                                upred = VP8Util.QuantizationParams.clip255(upred);
                                this.uSubblocks[sbRow][sbCol].val[pRow * 4 + pCol] = upred;
                                var vpred = leftVSb[sbRow].val[pRow * 4 + 3] + aboveVSb[sbCol].val[3 * 4 + pCol] - alv;
                                vpred = VP8Util.QuantizationParams.clip255(vpred);
                                this.vSubblocks[sbRow][sbCol].val[pRow * 4 + pCol] = vpred;
                            }
                        }
                    }
                }
                break;
            default:
                System.err.println("TODO predict_mb_uv: " + this.lumaMode);
                System.exit(0);
        }
    };
    prototype.predictY = function(mbs) {
        var aboveMb = mbs[this.Rrow - 1][this.column];
        var leftMb = mbs[this.Rrow][this.column - 1];
        switch (this.lumaMode) {
            case VP8Util.SubblockConstants.DC_PRED:
                this.predictLumaDC(aboveMb, leftMb);
                break;
            case VP8Util.SubblockConstants.V_PRED:
                this.predictLumaV(aboveMb);
                break;
            case VP8Util.SubblockConstants.H_PRED:
                this.predictLumaH(leftMb);
                break;
            case VP8Util.SubblockConstants.TM_PRED:
                var upperLeft = mbs[this.Rrow - 1][this.column - 1];
                var ALSb = upperLeft.ySubblocks[3][3];
                var aboveLeft = ALSb.val[3 * 4 + 3];
                this.predictLumaTM(aboveMb, leftMb, aboveLeft);
                break;
            default:
                System.err.println("TODO predict_mb_y: " + this.lumaMode);
                System.exit(0);
        }
    };
    prototype.predictLumaDC = function(above, left) {
        var hasAbove = this.Rrow > 1;
        var hasLeft = this.column > 1;
        var expected_dc = 128;
        if (hasAbove || hasLeft) {
            var average = 0;
            if (hasAbove) {
                for (var j = 0; j < 4; j++) {
                    var sb = above.ySubblocks[3][j];
                    for (var i = 0; i < 4; i++) 
                        average += sb.val[3 * 4 + i];
                }
            }
            if (hasLeft) {
                for (var j = 0; j < 4; j++) {
                    var sb = left.ySubblocks[j][3];
                    for (var i = 0; i < 4; i++) 
                        average += sb.val[i * 4 + 3];
                }
            }
            var shift = 3;
            if (hasAbove) 
                shift++;
            if (hasLeft) 
                shift++;
            expected_dc = (average + (1 << (shift - 1))) >> shift;
        }
        var fill = new Int32Array(16);
        for (var i = 0; i < 16; i++) 
            fill[i] = expected_dc;
        for (var y = 0; y < 4; y++) 
            for (var x = 0; x < 4; x++) 
                this.ySubblocks[y][x]._predict = fill;
    };
    prototype.predictLumaH = function(leftMb) {
        var leftYSb = Array(4);
        for (var row = 0; row < 4; row++) 
            leftYSb[row] = leftMb.ySubblocks[row][3];
        for (var row = 0; row < 4; row++) 
            for (var col = 0; col < 4; col++) {
                var sb = this.ySubblocks[row][col];
                var block = new Int32Array(16);
                for (var bRow = 0; bRow < 4; bRow++) 
                    for (var bCol = 0; bCol < 4; bCol++) {
                        block[bRow * 4 + bCol] = leftYSb[row].val != null ? leftYSb[row].val[bRow * 4 + 3] : 129;
                    }
                sb._predict = block;
            }
    };
    prototype.predictLumaTM = function(above, left, aboveLeft) {
        var leftYSb;
        var aboveYSb = Array(4);
        leftYSb = Array(4);
        for (var col = 0; col < 4; col++) 
            aboveYSb[col] = above.ySubblocks[3][col];
        for (var row = 0; row < 4; row++) 
            leftYSb[row] = left.ySubblocks[row][3];
        for (var row = 0; row < 4; row++) 
            for (var pRow = 0; pRow < 4; pRow++) 
                for (var col = 0; col < 4; col++) {
                    if (this.ySubblocks[row][col].val == null) 
                        this.ySubblocks[row][col].val = new Int32Array(16);
                    for (var pCol = 0; pCol < 4; pCol++) {
                        var pred = leftYSb[row].val[pRow * 4 + 3] + aboveYSb[col].val[3 * 4 + pCol] - aboveLeft;
                        this.ySubblocks[row][col].val[pRow * 4 + pCol] = VP8Util.QuantizationParams.clip255(pred);
                    }
                }
    };
    prototype.predictLumaV = function(above) {
        var aboveYSb = Array(4);
        for (var col = 0; col < 4; col++) 
            aboveYSb[col] = above.ySubblocks[3][col];
        for (var row = 0; row < 4; row++) {
            for (var col = 0; col < 4; col++) {
                var sb = this.ySubblocks[row][col];
                var block = new Int32Array(16);
                for (var j = 0; j < 4; j++) 
                    for (var i = 0; i < 4; i++) {
                        block[j * 4 + i] = aboveYSb[col].val != null ? aboveYSb[col].val[3 * 4 + i] : 127;
                    }
                sb._predict = block;
            }
        }
    };
    prototype.getBottomSubblock = function(x, plane) {
        if (plane == VP8Util.PLANE.Y1) {
            return this.ySubblocks[3][x];
        } else if (plane == VP8Util.PLANE.U) {
            return this.uSubblocks[1][x];
        } else if (plane == VP8Util.PLANE.V) {
            return this.vSubblocks[1][x];
        } else if (plane == VP8Util.PLANE.Y2) {
            return this.y2;
        }
        return null;
    };
    prototype.getRightSubBlock = function(y, plane) {
        if (plane == VP8Util.PLANE.Y1) {
            return this.ySubblocks[y][3];
        } else if (plane == VP8Util.PLANE.U) {
            return this.uSubblocks[y][1];
        } else if (plane == VP8Util.PLANE.V) {
            return this.vSubblocks[y][1];
        } else if (plane == VP8Util.PLANE.Y2) {
            return this.y2;
        }
        return null;
    };
    prototype.decodeMacroBlock = function(mbs, tockenDecoder, coefProbs) {
        if (this.skipCoeff > 0) {
            this.skipFilter = this.lumaMode != VP8Util.SubblockConstants.B_PRED;
        } else if (this.lumaMode != VP8Util.SubblockConstants.B_PRED) 
            this.decodeMacroBlockTokens(true, mbs, tockenDecoder, coefProbs);
         else 
            this.decodeMacroBlockTokens(false, mbs, tockenDecoder, coefProbs);
    };
    prototype.decodeMacroBlockTokens = function(withY2, mbs, decoder, coefProbs) {
        this.skipFilter = false;
        if (withY2) {
            this.skipFilter = this.skipFilter | this.decodePlaneTokens(1, VP8Util.PLANE.Y2, false, mbs, decoder, coefProbs);
        }
        this.skipFilter = this.skipFilter | this.decodePlaneTokens(4, VP8Util.PLANE.Y1, withY2, mbs, decoder, coefProbs);
        this.skipFilter = this.skipFilter | this.decodePlaneTokens(2, VP8Util.PLANE.U, false, mbs, decoder, coefProbs);
        this.skipFilter = this.skipFilter | this.decodePlaneTokens(2, VP8Util.PLANE.V, false, mbs, decoder, coefProbs);
        this.skipFilter = !this.skipFilter;
    };
    prototype.decodePlaneTokens = function(dimentions, plane, withY2, mbs, decoder, coefProbs) {
        var r = false;
        for (var row = 0; row < dimentions; row++) {
            for (var col = 0; col < dimentions; col++) {
                var lc = 0;
                var sb = null;
                if (VP8Util.PLANE.Y1.equals(plane)) {
                    sb = this.ySubblocks[row][col];
                } else if (VP8Util.PLANE.U.equals(plane)) {
                    sb = this.uSubblocks[row][col];
                } else if (VP8Util.PLANE.V.equals(plane)) {
                    sb = this.vSubblocks[row][col];
                } else if (VP8Util.PLANE.Y2.equals(plane)) {
                    sb = this.y2;
                } else {
                     throw new IllegalStateException("unknown plane type " + plane);
                }
                var l = sb.getLeft(plane, mbs);
                var a = sb.getAbove(plane, mbs);
                lc = (l.someValuePresent ? 1 : 0) + (a.someValuePresent ? 1 : 0);
                sb.decodeSubBlock(decoder, coefProbs, lc, VP8Util.planeToType(plane, withY2), withY2);
                r = r | sb.someValuePresent;
            }
        }
        return r;
    };
    constructor.Subblock = function(self, row, col, plane) {
        this.self = self;
        this.row = row;
        this.col = col;
        this.plane = plane;
        this.tokens = new Int32Array(16);
    };
    constructor.Subblock = stjs.extend(constructor.Subblock, null, [], function(constructor, prototype) {
        prototype.val = null;
        prototype._predict = null;
        prototype.residue = null;
        prototype.col = 0;
        prototype.row = 0;
        prototype.plane = null;
        prototype.mode = 0;
        prototype.someValuePresent = false;
        prototype.tokens = null;
        prototype.self = null;
        prototype.predict = function(mbs) {
            var aboveSb = this.getAbove(this.plane, mbs);
            var leftSb = this.getLeft(this.plane, mbs);
            var above = new Int32Array(4);
            var left = new Int32Array(4);
            var aboveValues = aboveSb.val != null ? aboveSb.val : VP8Util.PRED_BLOCK_127;
            above[0] = aboveValues[0 + 4 * 3];
            above[1] = aboveValues[1 + 4 * 3];
            above[2] = aboveValues[2 + 4 * 3];
            above[3] = aboveValues[3 + 4 * 3];
            var leftValues = leftSb.val != null ? leftSb.val : VP8Util.pickDefaultPrediction(this.mode);
            left[0] = leftValues[3 + 4 * 0];
            left[1] = leftValues[3 + 4 * 1];
            left[2] = leftValues[3 + 4 * 2];
            left[3] = leftValues[3 + 4 * 3];
            var aboveLeftSb = aboveSb.getLeft(this.plane, mbs);
            var aboveLeft;
            if (leftSb.val == null && aboveSb.val == null) {
                aboveLeft = 127;
            } else if (aboveSb.val == null) {
                aboveLeft = 127;
            } else {
                aboveLeft = aboveLeftSb.val != null ? aboveLeftSb.val[3 + 4 * 3] : VP8Util.pickDefaultPrediction(this.mode)[3 + 4 * 3];
            }
            var ar = this.getAboveRightLowestRow(mbs);
            switch (this.mode) {
                case VP8Util.SubblockConstants.B_DC_PRED:
                    this._predict = VP8Util.predictDC(above, left);
                    break;
                case VP8Util.SubblockConstants.B_TM_PRED:
                    this._predict = VP8Util.predictTM(above, left, aboveLeft);
                    break;
                case VP8Util.SubblockConstants.B_VE_PRED:
                    this._predict = VP8Util.predictVE(above, aboveLeft, ar);
                    break;
                case VP8Util.SubblockConstants.B_HE_PRED:
                    this._predict = VP8Util.predictHE(left, aboveLeft);
                    break;
                case VP8Util.SubblockConstants.B_LD_PRED:
                    this._predict = VP8Util.predictLD(above, ar);
                    break;
                case VP8Util.SubblockConstants.B_RD_PRED:
                    this._predict = VP8Util.predictRD(above, left, aboveLeft);
                    break;
                case VP8Util.SubblockConstants.B_VR_PRED:
                    this._predict = VP8Util.predictVR(above, left, aboveLeft);
                    break;
                case VP8Util.SubblockConstants.B_VL_PRED:
                    this._predict = VP8Util.predictVL(above, ar);
                    break;
                case VP8Util.SubblockConstants.B_HD_PRED:
                    this._predict = VP8Util.predictHD(above, left, aboveLeft);
                    break;
                case VP8Util.SubblockConstants.B_HU_PRED:
                    this._predict = VP8Util.predictHU(left);
                    break;
                default:
                     throw new NotSupportedException("TODO: unknowwn mode: " + this.mode);
            }
        };
        prototype.reconstruct = function() {
            var aRow, aCol;
            var p = this.val != null ? this.val : this._predict;
            var dest = new Int32Array(16);
            for (aRow = 0; aRow < 4; aRow++) {
                for (aCol = 0; aCol < 4; aCol++) {
                    var a = VP8Util.QuantizationParams.clip255(this.residue[aRow * 4 + aCol] + p[aRow * 4 + aCol]);
                    dest[aRow * 4 + aCol] = a;
                }
            }
            this.val = dest;
        };
        prototype.getAbove = function(plane, mbs) {
            if (this.row > 0) 
                if (VP8Util.PLANE.Y1.equals(this.plane)) 
                    return this.self.ySubblocks[this.row - 1][this.col];
                 else if (VP8Util.PLANE.U.equals(this.plane)) 
                    return this.self.uSubblocks[this.row - 1][this.col];
                 else if (VP8Util.PLANE.V.equals(this.plane)) 
                    return this.self.vSubblocks[this.row - 1][this.col];
            var x = this.col;
            var mb2 = mbs[this.self.Rrow - 1][this.self.column];
            if (plane == VP8Util.PLANE.Y2) {
                 while (mb2.lumaMode == VP8Util.SubblockConstants.B_PRED)
                    mb2 = mbs[mb2.Rrow - 1][mb2.column];
            }
            return mb2.getBottomSubblock(x, plane);
        };
        prototype.getLeft = function(p, mbs) {
            if (this.col > 0) 
                if (VP8Util.PLANE.Y1.equals(this.plane)) 
                    return this.self.ySubblocks[this.row][this.col - 1];
                 else if (VP8Util.PLANE.U.equals(this.plane)) 
                    return this.self.uSubblocks[this.row][this.col - 1];
                 else if (VP8Util.PLANE.V.equals(this.plane)) 
                    return this.self.vSubblocks[this.row][this.col - 1];
            var y = this.row;
            var mb2 = mbs[this.self.Rrow][this.self.column - 1];
            if (p == VP8Util.PLANE.Y2) 
                 while (mb2.lumaMode == VP8Util.SubblockConstants.B_PRED)
                    mb2 = mbs[mb2.Rrow][mb2.column - 1];
            return mb2.getRightSubBlock(y, p);
        };
        prototype.getAboveRightLowestRow = function(mbs) {
            if (!VP8Util.PLANE.Y1.equals(this.plane)) 
                 throw new NotImplementedException("Decoder.getAboveRight: not implemented for Y2 and chroma planes");
            var aboveRightDistValues;
            if (this.row == 0 && this.col < 3) {
                var mb2 = mbs[this.self.Rrow - 1][this.self.column];
                var aboveRight = mb2.ySubblocks[3][this.col + 1];
                aboveRightDistValues = aboveRight.val;
            } else if (this.row > 0 && this.col < 3) {
                var aboveRight = this.self.ySubblocks[this.row - 1][this.col + 1];
                aboveRightDistValues = aboveRight.val;
            } else if (this.row == 0 && this.col == 3) {
                var aboveRightMb = mbs[this.self.Rrow - 1][this.self.column + 1];
                if (aboveRightMb.column < (mbs[0].length - 1)) {
                    var aboveRightSb = aboveRightMb.ySubblocks[3][0];
                    aboveRightDistValues = aboveRightSb.val;
                } else {
                    aboveRightDistValues = new Int32Array(16);
                    var fillVal = aboveRightMb.Rrow == 0 ? 127 : mbs[this.self.Rrow - 1][this.self.column].ySubblocks[3][3].val[3 * 4 + 3];
                    Arrays.fill(aboveRightDistValues, fillVal);
                }
            } else {
                var sb2 = this.self.ySubblocks[0][3];
                return sb2.getAboveRightLowestRow(mbs);
            }
            if (aboveRightDistValues == null) 
                aboveRightDistValues = VP8Util.PRED_BLOCK_127;
            var ar = new Int32Array(4);
            ar[0] = aboveRightDistValues[0 + 4 * 3];
            ar[1] = aboveRightDistValues[1 + 4 * 3];
            ar[2] = aboveRightDistValues[2 + 4 * 3];
            ar[3] = aboveRightDistValues[3 + 4 * 3];
            return ar;
        };
        prototype.decodeSubBlock = function(decoder, allProbs, ilc, type, withY2) {
            var startAt = 0;
            if (withY2) 
                startAt = 1;
            var lc = ilc;
            var count = 0;
            var v = 1;
            var skip = false;
            this.someValuePresent = false;
             while (!(v == VP8Util.SubblockConstants.dct_eob) && count + startAt < 16){
                var probs = allProbs[type][VP8Util.SubblockConstants.vp8CoefBands[count + startAt]][lc];
                if (!skip) {
                    v = decoder.readTree(VP8Util.SubblockConstants.vp8CoefTree, probs);
                } else {
                    v = decoder.readTreeSkip(VP8Util.SubblockConstants.vp8CoefTree, probs, 1);
                }
                var dv = this.decodeToken(decoder, v);
                lc = 0;
                skip = false;
                if (dv == 1 || dv == -1) 
                    lc = 1;
                 else if (dv > 1 || dv < -1) 
                    lc = 2;
                 else if (dv == VP8Util.SubblockConstants.DCT_0) 
                    skip = true;
                if (v != VP8Util.SubblockConstants.dct_eob) 
                    this.tokens[VP8Util.SubblockConstants.vp8defaultZigZag1d[count + startAt]] = dv;
                count++;
            }
            for (var x = 0; x < 16; x++) 
                if (this.tokens[x] != 0) 
                    this.someValuePresent = true;
        };
        prototype.decodeToken = function(decoder, initialValue) {
            var token = initialValue;
            if (initialValue == VP8Util.SubblockConstants.cat_5_6) {
                token = 5 + this.DCTextra(decoder, VP8Util.SubblockConstants.Pcat1);
            }
            if (initialValue == VP8Util.SubblockConstants.cat_7_10) {
                token = 7 + this.DCTextra(decoder, VP8Util.SubblockConstants.Pcat2);
            }
            if (initialValue == VP8Util.SubblockConstants.cat_11_18) {
                token = 11 + this.DCTextra(decoder, VP8Util.SubblockConstants.Pcat3);
            }
            if (initialValue == VP8Util.SubblockConstants.cat_19_34) {
                token = 19 + this.DCTextra(decoder, VP8Util.SubblockConstants.Pcat4);
            }
            if (initialValue == VP8Util.SubblockConstants.cat_35_66) {
                token = 35 + this.DCTextra(decoder, VP8Util.SubblockConstants.Pcat5);
            }
            if (initialValue == VP8Util.SubblockConstants.cat_67_2048) {
                token = 67 + this.DCTextra(decoder, VP8Util.SubblockConstants.Pcat6);
            }
            if (initialValue != VP8Util.SubblockConstants.DCT_0 && initialValue != VP8Util.SubblockConstants.dct_eob) {
                if (decoder.readBitEq() > 0) 
                    token = -token;
            }
            return token;
        };
        prototype.DCTextra = function(decoder, p) {
            var v = 0;
            var offset = 0;
            do {
                v += v + decoder.readBit(p[offset]);
                offset++;
            } while (p[offset] > 0);
            return v;
        };
        prototype.dequantSubblock = function(dc, ac, Dc) {
            var adjustedValues = new Int32Array(16);
            adjustedValues[0] = this.tokens[0] * dc;
            for (var i = 1; i < 16; i++) 
                adjustedValues[i] = this.tokens[i] * ac;
            if (Dc != null) 
                adjustedValues[0] = Dc;
            this.residue = VP8DCT.decodeDCT(adjustedValues);
        };
    }, {val: "Int32Array", _predict: "Int32Array", residue: "Int32Array", plane: {name: "Enum", arguments: ["VP8Util.PLANE"]}, tokens: "Int32Array", self: "VPXMacroblock"}, {});
    prototype.put = function(mbRow, mbCol, p) {
        var luma = p.getPlaneData(0);
        var cb = p.getPlaneData(1);
        var cr = p.getPlaneData(2);
        var strideLuma = p.getPlaneWidth(0);
        var strideChroma = p.getPlaneWidth(1);
        for (var lumaRow = 0; lumaRow < 4; lumaRow++) 
            for (var lumaCol = 0; lumaCol < 4; lumaCol++) 
                for (var lumaPRow = 0; lumaPRow < 4; lumaPRow++) 
                    for (var lumaPCol = 0; lumaPCol < 4; lumaPCol++) {
                        var y = (mbRow << 4) + (lumaRow << 2) + lumaPRow;
                        var x = (mbCol << 4) + (lumaCol << 2) + lumaPCol;
                        if (x >= strideLuma || y >= stjs.trunc(luma.length / strideLuma)) 
                            continue;
                        var yy = this.ySubblocks[lumaRow][lumaCol].val[lumaPRow * 4 + lumaPCol];
                        luma[strideLuma * y + x] = ((yy - 128) << 24 >> 24);
                    }
        for (var chromaRow = 0; chromaRow < 2; chromaRow++) 
            for (var chromaCol = 0; chromaCol < 2; chromaCol++) 
                for (var chromaPRow = 0; chromaPRow < 4; chromaPRow++) 
                    for (var chromaPCol = 0; chromaPCol < 4; chromaPCol++) {
                        var y = (mbRow << 3) + (chromaRow << 2) + chromaPRow;
                        var x = (mbCol << 3) + (chromaCol << 2) + chromaPCol;
                        if (x >= strideChroma || y >= stjs.trunc(cb.length / strideChroma)) 
                            continue;
                        var u = this.uSubblocks[chromaRow][chromaCol].val[chromaPRow * 4 + chromaPCol];
                        var v = this.vSubblocks[chromaRow][chromaCol].val[chromaPRow * 4 + chromaPCol];
                        cb[strideChroma * y + x] = ((u - 128) << 24 >> 24);
                        cr[strideChroma * y + x] = ((v - 128) << 24 >> 24);
                    }
    };
}, {ySubblocks: "Array", y2: "VPXMacroblock.Subblock", uSubblocks: "Array", vSubblocks: "Array", quants: "VP8Util.QuantizationParams"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var DCT = function() {};
DCT = stjs.extend(DCT, null, [], function(constructor, prototype) {
    prototype.encode = function(orig) {
         throw new NotSupportedException();
    };
    prototype.decode = function(orig) {};
    prototype.decodeAll = function(src) {
        for (var i = 0; i < src.length; i++) {
            src[i] = this.decode(src[i]);
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AudioUtil = function() {};
AudioUtil = stjs.extend(AudioUtil, null, [], function(constructor, prototype) {
    constructor.f24 = 8388607.0;
    constructor.f16 = 32767.0;
    constructor.r16 = 1.0 / 32768.0;
    constructor.r24 = 1.0 / 8388608.0;
    /**
     *  Converts PCM samples stored in buf and described with format to float
     *  array representation
     *  
     *  @param format
     *             Supported formats - *_*_S16_LE, *_*_S24_LE, *_*_S16_BE,
     *             *_*_S24_LE
     *  @param buf
     *  @param floatBuf
     *  @return Total number of samples read from the buffer
     */
    constructor.toFloat = function(format, buf, floatBuf) {
        if (!format.isSigned()) 
             throw new NotSupportedException("Unsigned PCM is not supported ( yet? ).");
        if (format.getSampleSizeInBits() != 16 && format.getSampleSizeInBits() != 24) 
             throw new NotSupportedException(format.getSampleSizeInBits() + " bit PCM is not supported ( yet? ).");
        if (format.isBigEndian()) {
            if (format.getSampleSizeInBits() == 16) {
                AudioUtil.toFloat16BE(buf, floatBuf);
            } else {
                AudioUtil.toFloat24BE(buf, floatBuf);
            }
        } else {
            if (format.getSampleSizeInBits() == 16) {
                AudioUtil.toFloat16LE(buf, floatBuf);
            } else {
                AudioUtil.toFloat24LE(buf, floatBuf);
            }
        }
    };
    /**
     *  Converts float PCM samples stored in floatBuf to integer representation
     *  according to format and stores them in buf
     *  
     *  @param format
     *             Supported formats - *_*_S16_LE, *_*_S24_LE, *_*_S16_BE,
     *             *_*_S24_LE
     *  @param buf
     *  @param floatBuf
     *  @return Total number of samples written to the buffer
     */
    constructor.fromFloat = function(floatBuf, format, buf) {
        if (!format.isSigned()) 
             throw new NotSupportedException("Unsigned PCM is not supported ( yet? ).");
        if (format.getSampleSizeInBits() != 16 && format.getSampleSizeInBits() != 24) 
             throw new NotSupportedException(format.getSampleSizeInBits() + " bit PCM is not supported ( yet? ).");
        if (format.isBigEndian()) {
            if (format.getSampleSizeInBits() == 16) {
                AudioUtil.fromFloat16BE(buf, floatBuf);
            } else {
                AudioUtil.fromFloat24BE(buf, floatBuf);
            }
        } else {
            if (format.getSampleSizeInBits() == 16) {
                AudioUtil.fromFloat16LE(buf, floatBuf);
            } else {
                AudioUtil.fromFloat24LE(buf, floatBuf);
            }
        }
    };
    constructor.toFloat24LE = function(buf, out) {
         while (buf.remaining() >= 3 && out.hasRemaining()){
            out.put(AudioUtil.r24 * ((((buf.get() & 255) << 8) | ((buf.get() & 255) << 16) | ((buf.get() & 255) << 24)) >> 8));
        }
    };
    constructor.toFloat16LE = function(buf, out) {
         while (buf.remaining() >= 2 && out.hasRemaining()){
            out.put(AudioUtil.r16 * ((((buf.get() & 255) | ((buf.get() & 255) << 8))) << 16 >> 16));
        }
    };
    constructor.toFloat24BE = function(buf, out) {
         while (buf.remaining() >= 3 && out.hasRemaining()){
            out.put(AudioUtil.r24 * ((((buf.get() & 255) << 24) | ((buf.get() & 255) << 16) | ((buf.get() & 255) << 8)) >> 8));
        }
    };
    constructor.toFloat16BE = function(buf, out) {
         while (buf.remaining() >= 2 && out.hasRemaining()){
            out.put(AudioUtil.r16 * (((((buf.get() & 255) << 8) | (buf.get() & 255))) << 16 >> 16));
        }
    };
    constructor.fromFloat24LE = function(buf, _in) {
         while (buf.remaining() >= 3 && _in.hasRemaining()){
            var val = MathUtil.clip(stjs.trunc((_in.get() * AudioUtil.f24)), -8388608, 8388607) & 16777215;
            buf.put((val << 24 >> 24));
            buf.put(((val >> 8) << 24 >> 24));
            buf.put(((val >> 16) << 24 >> 24));
        }
    };
    constructor.fromFloat16LE = function(buf, _in) {
         while (buf.remaining() >= 2 && _in.hasRemaining()){
            var val = MathUtil.clip(stjs.trunc((_in.get() * AudioUtil.f16)), -32768, 32767) & 65535;
            buf.put((val << 24 >> 24));
            buf.put(((val >> 8) << 24 >> 24));
        }
    };
    constructor.fromFloat24BE = function(buf, _in) {
         while (buf.remaining() >= 3 && _in.hasRemaining()){
            var val = MathUtil.clip(stjs.trunc((_in.get() * AudioUtil.f24)), -8388608, 8388607) & 16777215;
            buf.put(((val >> 16) << 24 >> 24));
            buf.put(((val >> 8) << 24 >> 24));
            buf.put((val << 24 >> 24));
        }
    };
    constructor.fromFloat16BE = function(buf, _in) {
         while (buf.remaining() >= 2 && _in.hasRemaining()){
            var val = MathUtil.clip(stjs.trunc((_in.get() * AudioUtil.f16)), -32768, 32767) & 65535;
            buf.put(((val >> 8) << 24 >> 24));
            buf.put((val << 24 >> 24));
        }
    };
    constructor.fromInt = function(data, len, format, buf) {
        if (!format.isSigned()) 
             throw new NotSupportedException("Unsigned PCM is not supported ( yet? ).");
        if (format.getSampleSizeInBits() != 16 && format.getSampleSizeInBits() != 24) 
             throw new NotSupportedException(format.getSampleSizeInBits() + " bit PCM is not supported ( yet? ).");
        if (format.isBigEndian()) {
            if (format.getSampleSizeInBits() == 16) {
                return AudioUtil.fromInt16BE(buf, data, len);
            } else {
                return AudioUtil.fromInt24BE(buf, data, len);
            }
        } else {
            if (format.getSampleSizeInBits() == 16) {
                return AudioUtil.fromInt16LE(buf, data, len);
            } else {
                return AudioUtil.fromInt24LE(buf, data, len);
            }
        }
    };
    constructor.fromInt24LE = function(buf, out, len) {
        var samples = 0;
         while (buf.remaining() >= 3 && samples < len){
            var val = out[samples++];
            buf.put((val << 24 >> 24));
            buf.put(((val >> 8) << 24 >> 24));
            buf.put(((val >> 16) << 24 >> 24));
        }
        return samples;
    };
    constructor.fromInt16LE = function(buf, out, len) {
        var samples = 0;
         while (buf.remaining() >= 2 && samples < len){
            var val = out[samples++];
            buf.put((val << 24 >> 24));
            buf.put(((val >> 8) << 24 >> 24));
        }
        return samples;
    };
    constructor.fromInt24BE = function(buf, out, len) {
        var samples = 0;
         while (buf.remaining() >= 3 && samples < len){
            var val = out[samples++];
            buf.put(((val >> 16) << 24 >> 24));
            buf.put(((val >> 8) << 24 >> 24));
            buf.put((val << 24 >> 24));
        }
        return samples;
    };
    constructor.fromInt16BE = function(buf, out, len) {
        var samples = 0;
         while (buf.remaining() >= 2 && samples < len){
            var val = out[samples++];
            buf.put(((val >> 8) << 24 >> 24));
            buf.put((val << 24 >> 24));
        }
        return samples;
    };
    constructor.toInt = function(format, buf, samples) {
        if (!format.isSigned()) 
             throw new NotSupportedException("Unsigned PCM is not supported ( yet? ).");
        if (format.getSampleSizeInBits() != 16 && format.getSampleSizeInBits() != 24) 
             throw new NotSupportedException(format.getSampleSizeInBits() + " bit PCM is not supported ( yet? ).");
        if (format.isBigEndian()) {
            if (format.getSampleSizeInBits() == 16) {
                return AudioUtil.toInt16BE(buf, samples);
            } else {
                return AudioUtil.toInt24BE(buf, samples);
            }
        } else {
            if (format.getSampleSizeInBits() == 16) {
                return AudioUtil.toInt16LE(buf, samples);
            } else {
                return AudioUtil.toInt24LE(buf, samples);
            }
        }
    };
    constructor.toInt24LE = function(buf, out) {
        var samples = 0;
         while (buf.remaining() >= 3 && samples < out.length){
            out[samples++] = (((buf.get() & 255) << 8) | ((buf.get() & 255) << 16) | ((buf.get() & 255) << 24)) >> 8;
        }
        return samples;
    };
    constructor.toInt16LE = function(buf, out) {
        var samples = 0;
         while (buf.remaining() >= 2 && samples < out.length){
            out[samples++] = ((((buf.get() & 255) | ((buf.get() & 255) << 8))) << 16 >> 16);
        }
        return samples;
    };
    constructor.toInt24BE = function(buf, out) {
        var samples = 0;
         while (buf.remaining() >= 3 && samples < out.length){
            out[samples++] = (((buf.get() & 255) << 24) | ((buf.get() & 255) << 16) | ((buf.get() & 255) << 8)) >> 8;
        }
        return samples;
    };
    constructor.toInt16BE = function(buf, out) {
        var samples = 0;
         while (buf.remaining() >= 2 && samples < out.length){
            out[samples++] = (((((buf.get() & 255) << 8) | (buf.get() & 255))) << 16 >> 16);
        }
        return samples;
    };
    /**
     *  Interleaves audio samples in ins into outb using sample size from the
     *  format
     *  
     *  @param format
     *  @param ins
     *  @param outb
     */
    constructor.interleave = function(format, ins, outb) {
        var bytesPerSample = format.getSampleSizeInBits() >> 3;
        var bytesPerFrame = bytesPerSample * ins.length;
        var max = 0;
        for (var i = 0; i < ins.length; i++) 
            if (ins[i].remaining() > max) 
                max = ins[i].remaining();
        for (var frames = 0; frames < max && outb.remaining() >= bytesPerFrame; frames++) {
            for (var j = 0; j < ins.length; j++) {
                if (ins[j].remaining() < bytesPerSample) {
                    for (var i = 0; i < bytesPerSample; i++) 
                        outb.put((0 << 24 >> 24));
                } else {
                    for (var i = 0; i < bytesPerSample; i++) {
                        outb.put(ins[j].get());
                    }
                }
            }
        }
    };
    /**
     *  Deinterleaves audio samples from inb into outs using sample size from
     *  format
     *  
     *  @param format
     *  @param inb
     *  @param outs
     */
    constructor.deinterleave = function(format, inb, outs) {
        var bytesPerSample = format.getSampleSizeInBits() >> 3;
        var bytesPerFrame = bytesPerSample * outs.length;
         while (inb.remaining() >= bytesPerFrame){
            for (var j = 0; j < outs.length; j++) {
                for (var i = 0; i < bytesPerSample; i++) {
                    outs[j].put(inb.get());
                }
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Integer to byte and vice versa conversion routines
 *  
 *  @author The JCodec project
 *  
 */
var DataConvert = function() {};
DataConvert = stjs.extend(DataConvert, null, [], function(constructor, prototype) {
    constructor.from16BE = function(b) {
        var result = new Int32Array(b.length >> 1);
        var off = 0;
        for (var i = 0; i < result.length; i++) {
            result[i] = ((b[off++] & 255) << 8) | (b[off++] & 255);
        }
        return result;
    };
    constructor.from24BE = function(b) {
        var result = new Int32Array(stjs.trunc(b.length / 3));
        var off = 0;
        for (var i = 0; i < result.length; i++) {
            result[i] = ((b[off++] & 255) << 16) | ((b[off++] & 255) << 8) | (b[off++] & 255);
        }
        return result;
    };
    constructor.from16LE = function(b) {
        var result = new Int32Array(b.length >> 1);
        var off = 0;
        for (var i = 0; i < result.length; i++) {
            result[i] = (b[off++] & 255) | ((b[off++] & 255) << 8);
        }
        return result;
    };
    constructor.from24LE = function(b) {
        var result = new Int32Array(stjs.trunc(b.length / 3));
        var off = 0;
        for (var i = 0; i < result.length; i++) {
            result[i] = (b[off++] & 255) | ((b[off++] & 255) << 8) | ((b[off++] & 255) << 16);
        }
        return result;
    };
    constructor.to16BE = function(ia) {
        var result = new Int8Array(ia.length << 1);
        var off = 0;
        for (var i = 0; i < ia.length; i++) {
            result[off++] = (((ia[i] >> 8) & 255) << 24 >> 24);
            result[off++] = ((ia[i] & 255) << 24 >> 24);
        }
        return result;
    };
    constructor.to24BE = function(ia) {
        var result = new Int8Array(ia.length * 3);
        var off = 0;
        for (var i = 0; i < ia.length; i++) {
            result[off++] = (((ia[i] >> 16) & 255) << 24 >> 24);
            result[off++] = (((ia[i] >> 8) & 255) << 24 >> 24);
            result[off++] = ((ia[i] & 255) << 24 >> 24);
        }
        return result;
    };
    constructor.to16LE = function(ia) {
        var result = new Int8Array(ia.length << 1);
        var off = 0;
        for (var i = 0; i < ia.length; i++) {
            result[off++] = ((ia[i] & 255) << 24 >> 24);
            result[off++] = (((ia[i] >> 8) & 255) << 24 >> 24);
        }
        return result;
    };
    constructor.to24LE = function(ia) {
        var result = new Int8Array(ia.length * 3);
        var off = 0;
        for (var i = 0; i < ia.length; i++) {
            result[off++] = ((ia[i] & 255) << 24 >> 24);
            result[off++] = (((ia[i] >> 8) & 255) << 24 >> 24);
            result[off++] = (((ia[i] >> 16) & 255) << 24 >> 24);
        }
        return result;
    };
    /**
     *  Generic byte-array to integer-array conversion
     *  
     *  Converts each depth-bit sequence from the input byte array into integer
     *  
     *  @param b
     *             Input bytes
     *  @param depth
     *             Bit depth of the integers
     *  @param isBe
     *             If integers are big-endian or little-endian
     *  @return
     */
    constructor.fromByte = function(b, depth, isBe) {
        if (depth == 24) 
            if (isBe) 
                return DataConvert.from24BE(b);
             else 
                return DataConvert.from24LE(b);
         else if (depth == 16) 
            if (isBe) 
                return DataConvert.from16BE(b);
             else 
                return DataConvert.from16LE(b);
         throw new NotSupportedException("Conversion from " + depth + "bit " + (isBe ? "big endian" : "little endian") + " is not supported.");
    };
    /**
     *  Generic integer-array to byte-array conversion
     *  
     *  Converts each integer into depth-bit sequence in the output byte array
     *  
     *  @param ia
     *             Integer array
     *  @param depth
     *             Bit depth of the integers
     *  @param isBe
     *             If integers are big-endian or little-endian
     *  @return
     */
    constructor.toByte = function(ia, depth, isBe) {
        if (depth == 24) 
            if (isBe) 
                return DataConvert.to24BE(ia);
             else 
                return DataConvert.to24LE(ia);
         else if (depth == 16) 
            if (isBe) 
                return DataConvert.to16BE(ia);
             else 
                return DataConvert.to16LE(ia);
         throw new NotSupportedException("Conversion to " + depth + "bit " + (isBe ? "big endian" : "little endian") + " is not supported.");
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Like MP4Edit
 *  
 *  @author The JCodec project
 *  
 */
var CompoundMP4Edit = function(edits) {
    this.edits = edits;
};
CompoundMP4Edit = stjs.extend(CompoundMP4Edit, null, [MP4Edit], function(constructor, prototype) {
    prototype.edits = null;
    prototype.applyToFragment = function(mov, fragmentBox) {
        for (var iterator$command = this.edits.iterator(); iterator$command.hasNext(); ) {
            var command = iterator$command.next();
            command.applyToFragment(mov, fragmentBox);
        }
    };
    prototype.apply = function(mov) {
        for (var iterator$command = this.edits.iterator(); iterator$command.hasNext(); ) {
            var command = iterator$command.next();
            command.apply(mov);
        }
    };
}, {edits: {name: "List", arguments: ["MP4Edit"]}}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var AnalysisFilterbank = function(channels) {
    this.channels = channels;
    this.x = new Float32Array(2 * channels * 10);
    this.x_index = 0;
};
AnalysisFilterbank = stjs.extend(AnalysisFilterbank, null, [FilterbankTable], function(constructor, prototype) {
    prototype.x = null;
    prototype.x_index = 0;
    prototype.channels = 0;
    prototype.reset = function() {
        Arrays.fill(this.x, 0);
    };
    prototype.sbr_qmf_analysis_32 = function(sbr, input, X, offset, kx) {
        var u = new Float32Array(64);
        var in_real = new Float32Array(32), in_imag = new Float32Array(32);
        var out_real = new Float32Array(32), out_imag = new Float32Array(32);
        var _in = 0;
        var l;
        for (l = 0; l < sbr.numTimeSlotsRate; l++) {
            var n;
            for (n = 32 - 1; n >= 0; n--) {
                this.x[this.x_index + n] = this.x[this.x_index + n + 320] = input[_in++];
            }
            for (n = 0; n < 64; n++) {
                u[n] = (this.x[this.x_index + n] * FilterbankTable.qmf_c[2 * n]) + (this.x[this.x_index + n + 64] * FilterbankTable.qmf_c[2 * (n + 64)]) + (this.x[this.x_index + n + 128] * FilterbankTable.qmf_c[2 * (n + 128)]) + (this.x[this.x_index + n + 192] * FilterbankTable.qmf_c[2 * (n + 192)]) + (this.x[this.x_index + n + 256] * FilterbankTable.qmf_c[2 * (n + 256)]);
            }
            this.x_index -= 32;
            if (this.x_index < 0) 
                this.x_index = (320 - 32);
            in_imag[31] = u[1];
            in_real[0] = u[0];
            for (n = 1; n < 31; n++) {
                in_imag[31 - n] = u[n + 1];
                in_real[n] = -u[64 - n];
            }
            in_imag[0] = u[32];
            in_real[31] = -u[33];
            DCT.dct4_kernel(in_real, in_imag, out_real, out_imag);
            for (n = 0; n < 16; n++) {
                if (2 * n + 1 < kx) {
                    X[l + offset][2 * n][0] = 2.0 * out_real[n];
                    X[l + offset][2 * n][1] = 2.0 * out_imag[n];
                    X[l + offset][2 * n + 1][0] = -2.0 * out_imag[31 - n];
                    X[l + offset][2 * n + 1][1] = -2.0 * out_real[31 - n];
                } else {
                    if (2 * n < kx) {
                        X[l + offset][2 * n][0] = 2.0 * out_real[n];
                        X[l + offset][2 * n][1] = 2.0 * out_imag[n];
                    } else {
                        X[l + offset][2 * n][0] = 0;
                        X[l + offset][2 * n][1] = 0;
                    }
                    X[l + offset][2 * n + 1][0] = 0;
                    X[l + offset][2 * n + 1][1] = 0;
                }
            }
        }
    };
}, {x: "Float32Array", qmf_c: "Float32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var SynthesisFilterbank = function(channels) {
    this.channels = channels;
    this.v = new Float32Array(2 * channels * 20);
    this.v_index = 0;
};
SynthesisFilterbank = stjs.extend(SynthesisFilterbank, null, [FilterbankTable], function(constructor, prototype) {
    constructor.qmf32_pre_twiddle = [new Float32Array([0.9999247, -0.012271538]), new Float32Array([0.99932235, -0.036807224]), new Float32Array([0.9981181, -0.061320737]), new Float32Array([0.9963126, -0.08579731]), new Float32Array([0.993907, -0.110222206]), new Float32Array([0.99090266, -0.1345807]), new Float32Array([0.9873014, -0.15885815]), new Float32Array([0.9831055, -0.18303989]), new Float32Array([0.9783174, -0.20711137]), new Float32Array([0.97293997, -0.2310581]), new Float32Array([0.96697646, -0.25486565]), new Float32Array([0.9604305, -0.2785197]), new Float32Array([0.953306, -0.30200595]), new Float32Array([0.9456073, -0.3253103]), new Float32Array([0.937339, -0.34841868]), new Float32Array([0.9285061, -0.3713172]), new Float32Array([0.9191139, -0.39399204]), new Float32Array([0.909168, -0.41642955]), new Float32Array([0.8986745, -0.43861625]), new Float32Array([0.88763964, -0.46053872]), new Float32Array([0.8760701, -0.48218378]), new Float32Array([0.86397284, -0.50353837]), new Float32Array([0.8513552, -0.52458966]), new Float32Array([0.8382247, -0.545325]), new Float32Array([0.8245893, -0.5657318]), new Float32Array([0.81045717, -0.58579785]), new Float32Array([0.7958369, -0.60551107]), new Float32Array([0.7807372, -0.6248595]), new Float32Array([0.76516724, -0.64383155]), new Float32Array([0.7491364, -0.6624158]), new Float32Array([0.7326543, -0.680601]), new Float32Array([0.71573085, -0.69837624])];
    prototype.v = null;
    prototype.v_index = 0;
    prototype.channels = 0;
    prototype.reset = function() {
        Arrays.fill(this.v, 0);
    };
    prototype.sbr_qmf_synthesis_32 = function(sbr, X, output) {
        var x1 = new Float32Array(32), x2 = new Float32Array(32);
        var scale = 1.0 / 64.0;
        var n, k, out = 0;
        var l;
        for (l = 0; l < sbr.numTimeSlotsRate; l++) {
            for (k = 0; k < 32; k++) {
                x1[k] = (X[l][k][0] * SynthesisFilterbank.qmf32_pre_twiddle[k][0]) - (X[l][k][1] * SynthesisFilterbank.qmf32_pre_twiddle[k][1]);
                x2[k] = (X[l][k][1] * SynthesisFilterbank.qmf32_pre_twiddle[k][0]) + (X[l][k][0] * SynthesisFilterbank.qmf32_pre_twiddle[k][1]);
                x1[k] *= scale;
                x2[k] *= scale;
            }
            this.DCT4_32(x1, x1);
            this.DST4_32(x2, x2);
            for (n = 0; n < 32; n++) {
                this.v[this.v_index + n] = this.v[this.v_index + 640 + n] = -x1[n] + x2[n];
                this.v[this.v_index + 63 - n] = this.v[this.v_index + 640 + 63 - n] = x1[n] + x2[n];
            }
            for (k = 0; k < 32; k++) {
                output[out++] = (this.v[this.v_index + k] * FilterbankTable.qmf_c[2 * k]) + (this.v[this.v_index + 96 + k] * FilterbankTable.qmf_c[64 + 2 * k]) + (this.v[this.v_index + 128 + k] * FilterbankTable.qmf_c[128 + 2 * k]) + (this.v[this.v_index + 224 + k] * FilterbankTable.qmf_c[192 + 2 * k]) + (this.v[this.v_index + 256 + k] * FilterbankTable.qmf_c[256 + 2 * k]) + (this.v[this.v_index + 352 + k] * FilterbankTable.qmf_c[320 + 2 * k]) + (this.v[this.v_index + 384 + k] * FilterbankTable.qmf_c[384 + 2 * k]) + (this.v[this.v_index + 480 + k] * FilterbankTable.qmf_c[448 + 2 * k]) + (this.v[this.v_index + 512 + k] * FilterbankTable.qmf_c[512 + 2 * k]) + (this.v[this.v_index + 608 + k] * FilterbankTable.qmf_c[576 + 2 * k]);
            }
            this.v_index -= 64;
            if (this.v_index < 0) 
                this.v_index = (640 - 64);
        }
    };
    prototype.sbr_qmf_synthesis_64 = function(sbr, X, output) {
        var in_real1 = new Float32Array(32), in_imag1 = new Float32Array(32), out_real1 = new Float32Array(32), out_imag1 = new Float32Array(32);
        var in_real2 = new Float32Array(32), in_imag2 = new Float32Array(32), out_real2 = new Float32Array(32), out_imag2 = new Float32Array(32);
        var pX;
        var scale = 1.0 / 64.0;
        var n, k, out = 0;
        var l;
        for (l = 0; l < sbr.numTimeSlotsRate; l++) {
            pX = X[l];
            in_imag1[31] = scale * pX[1][0];
            in_real1[0] = scale * pX[0][0];
            in_imag2[31] = scale * pX[63 - 1][1];
            in_real2[0] = scale * pX[63 - 0][1];
            for (k = 1; k < 31; k++) {
                in_imag1[31 - k] = scale * pX[2 * k + 1][0];
                in_real1[k] = scale * pX[2 * k][0];
                in_imag2[31 - k] = scale * pX[63 - (2 * k + 1)][1];
                in_real2[k] = scale * pX[63 - (2 * k)][1];
            }
            in_imag1[0] = scale * pX[63][0];
            in_real1[31] = scale * pX[62][0];
            in_imag2[0] = scale * pX[63 - 63][1];
            in_real2[31] = scale * pX[63 - 62][1];
            DCT.dct4_kernel(in_real1, in_imag1, out_real1, out_imag1);
            DCT.dct4_kernel(in_real2, in_imag2, out_real2, out_imag2);
            var pring_buffer_1 = this.v_index;
            var pring_buffer_3 = pring_buffer_1 + 1280;
            for (n = 0; n < 32; n++) {
                this.v[pring_buffer_1 + 2 * n] = this.v[pring_buffer_3 + 2 * n] = out_real2[n] - out_real1[n];
                this.v[pring_buffer_1 + 127 - 2 * n] = this.v[pring_buffer_3 + 127 - 2 * n] = out_real2[n] + out_real1[n];
                this.v[pring_buffer_1 + 2 * n + 1] = this.v[pring_buffer_3 + 2 * n + 1] = out_imag2[31 - n] + out_imag1[31 - n];
                this.v[pring_buffer_1 + 127 - (2 * n + 1)] = this.v[pring_buffer_3 + 127 - (2 * n + 1)] = out_imag2[31 - n] - out_imag1[31 - n];
            }
            pring_buffer_1 = this.v_index;
            for (k = 0; k < 64; k++) {
                output[out++] = (this.v[pring_buffer_1 + k + 0] * FilterbankTable.qmf_c[k + 0]) + (this.v[pring_buffer_1 + k + 192] * FilterbankTable.qmf_c[k + 64]) + (this.v[pring_buffer_1 + k + 256] * FilterbankTable.qmf_c[k + 128]) + (this.v[pring_buffer_1 + k + (256 + 192)] * FilterbankTable.qmf_c[k + 192]) + (this.v[pring_buffer_1 + k + 512] * FilterbankTable.qmf_c[k + 256]) + (this.v[pring_buffer_1 + k + (512 + 192)] * FilterbankTable.qmf_c[k + 320]) + (this.v[pring_buffer_1 + k + 768] * FilterbankTable.qmf_c[k + 384]) + (this.v[pring_buffer_1 + k + (768 + 192)] * FilterbankTable.qmf_c[k + 448]) + (this.v[pring_buffer_1 + k + 1024] * FilterbankTable.qmf_c[k + 512]) + (this.v[pring_buffer_1 + k + (1024 + 192)] * FilterbankTable.qmf_c[k + 576]);
            }
            this.v_index -= 128;
            if (this.v_index < 0) 
                this.v_index = (1280 - 128);
        }
    };
    prototype.DCT4_32 = function(y, x) {
        var f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10;
        var f11, f12, f13, f14, f15, f16, f17, f18, f19, f20;
        var f21, f22, f23, f24, f25, f26, f27, f28, f29, f30;
        var f31, f32, f33, f34, f35, f36, f37, f38, f39, f40;
        var f41, f42, f43, f44, f45, f46, f47, f48, f49, f50;
        var f51, f52, f53, f54, f55, f56, f57, f58, f59, f60;
        var f61, f62, f63, f64, f65, f66, f67, f68, f69, f70;
        var f71, f72, f73, f74, f75, f76, f77, f78, f79, f80;
        var f81, f82, f83, f84, f85, f86, f87, f88, f89, f90;
        var f91, f92, f93, f94, f95, f96, f97, f98, f99, f100;
        var f101, f102, f103, f104, f105, f106, f107, f108, f109, f110;
        var f111, f112, f113, f114, f115, f116, f117, f118, f119, f120;
        var f121, f122, f123, f124, f125, f126, f127, f128, f129, f130;
        var f131, f132, f133, f134, f135, f136, f137, f138, f139, f140;
        var f141, f142, f143, f144, f145, f146, f147, f148, f149, f150;
        var f151, f152, f153, f154, f155, f156, f157, f158, f159, f160;
        var f161, f162, f163, f164, f165, f166, f167, f168, f169, f170;
        var f171, f172, f173, f174, f175, f176, f177, f178, f179, f180;
        var f181, f182, f183, f184, f185, f186, f187, f188, f189, f190;
        var f191, f192, f193, f194, f195, f196, f197, f198, f199, f200;
        var f201, f202, f203, f204, f205, f206, f207, f208, f209, f210;
        var f211, f212, f213, f214, f215, f216, f217, f218, f219, f220;
        var f221, f222, f223, f224, f225, f226, f227, f228, f229, f230;
        var f231, f232, f233, f234, f235, f236, f237, f238, f239, f240;
        var f241, f242, f243, f244, f245, f246, f247, f248, f249, f250;
        var f251, f252, f253, f254, f255, f256, f257, f258, f259, f260;
        var f261, f262, f263, f264, f265, f266, f267, f268, f269, f270;
        var f271, f272, f273, f274, f275, f276, f277, f278, f279, f280;
        var f281, f282, f283, f284, f285, f286, f287, f288, f289, f290;
        var f291, f292, f293, f294, f295, f296, f297, f298, f299, f300;
        var f301, f302, f303, f304, f305, f306, f307, f310, f311, f312;
        var f313, f316, f317, f318, f319, f322, f323, f324, f325, f328;
        var f329, f330, f331, f334, f335, f336, f337, f340, f341, f342;
        var f343, f346, f347, f348, f349, f352, f353, f354, f355, f358;
        var f359, f360, f361, f364, f365, f366, f367, f370, f371, f372;
        var f373, f376, f377, f378, f379, f382, f383, f384, f385, f388;
        var f389, f390, f391, f394, f395, f396, f397;
        f0 = x[15] - x[16];
        f1 = x[15] + x[16];
        f2 = (0.70710677 * f1);
        f3 = (0.70710677 * f0);
        f4 = x[8] - x[23];
        f5 = x[8] + x[23];
        f6 = (0.70710677 * f5);
        f7 = (0.70710677 * f4);
        f8 = x[12] - x[19];
        f9 = x[12] + x[19];
        f10 = (0.70710677 * f9);
        f11 = (0.70710677 * f8);
        f12 = x[11] - x[20];
        f13 = x[11] + x[20];
        f14 = (0.70710677 * f13);
        f15 = (0.70710677 * f12);
        f16 = x[14] - x[17];
        f17 = x[14] + x[17];
        f18 = (0.70710677 * f17);
        f19 = (0.70710677 * f16);
        f20 = x[9] - x[22];
        f21 = x[9] + x[22];
        f22 = (0.70710677 * f21);
        f23 = (0.70710677 * f20);
        f24 = x[13] - x[18];
        f25 = x[13] + x[18];
        f26 = (0.70710677 * f25);
        f27 = (0.70710677 * f24);
        f28 = x[10] - x[21];
        f29 = x[10] + x[21];
        f30 = (0.70710677 * f29);
        f31 = (0.70710677 * f28);
        f32 = x[0] - f2;
        f33 = x[0] + f2;
        f34 = x[31] - f3;
        f35 = x[31] + f3;
        f36 = x[7] - f6;
        f37 = x[7] + f6;
        f38 = x[24] - f7;
        f39 = x[24] + f7;
        f40 = x[3] - f10;
        f41 = x[3] + f10;
        f42 = x[28] - f11;
        f43 = x[28] + f11;
        f44 = x[4] - f14;
        f45 = x[4] + f14;
        f46 = x[27] - f15;
        f47 = x[27] + f15;
        f48 = x[1] - f18;
        f49 = x[1] + f18;
        f50 = x[30] - f19;
        f51 = x[30] + f19;
        f52 = x[6] - f22;
        f53 = x[6] + f22;
        f54 = x[25] - f23;
        f55 = x[25] + f23;
        f56 = x[2] - f26;
        f57 = x[2] + f26;
        f58 = x[29] - f27;
        f59 = x[29] + f27;
        f60 = x[5] - f30;
        f61 = x[5] + f30;
        f62 = x[26] - f31;
        f63 = x[26] + f31;
        f64 = f39 + f37;
        f65 = (-0.5411961 * f39);
        f66 = (0.9238795 * f64);
        f67 = (1.306563 * f37);
        f68 = f65 + f66;
        f69 = f67 - f66;
        f70 = f38 + f36;
        f71 = (1.306563 * f38);
        f72 = (-0.38268343 * f70);
        f73 = (0.5411961 * f36);
        f74 = f71 + f72;
        f75 = f73 - f72;
        f76 = f47 + f45;
        f77 = (-0.5411961 * f47);
        f78 = (0.9238795 * f76);
        f79 = (1.306563 * f45);
        f80 = f77 + f78;
        f81 = f79 - f78;
        f82 = f46 + f44;
        f83 = (1.306563 * f46);
        f84 = (-0.38268343 * f82);
        f85 = (0.5411961 * f44);
        f86 = f83 + f84;
        f87 = f85 - f84;
        f88 = f55 + f53;
        f89 = (-0.5411961 * f55);
        f90 = (0.9238795 * f88);
        f91 = (1.306563 * f53);
        f92 = f89 + f90;
        f93 = f91 - f90;
        f94 = f54 + f52;
        f95 = (1.306563 * f54);
        f96 = (-0.38268343 * f94);
        f97 = (0.5411961 * f52);
        f98 = f95 + f96;
        f99 = f97 - f96;
        f100 = f63 + f61;
        f101 = (-0.5411961 * f63);
        f102 = (0.9238795 * f100);
        f103 = (1.306563 * f61);
        f104 = f101 + f102;
        f105 = f103 - f102;
        f106 = f62 + f60;
        f107 = (1.306563 * f62);
        f108 = (-0.38268343 * f106);
        f109 = (0.5411961 * f60);
        f110 = f107 + f108;
        f111 = f109 - f108;
        f112 = f33 - f68;
        f113 = f33 + f68;
        f114 = f35 - f69;
        f115 = f35 + f69;
        f116 = f32 - f74;
        f117 = f32 + f74;
        f118 = f34 - f75;
        f119 = f34 + f75;
        f120 = f41 - f80;
        f121 = f41 + f80;
        f122 = f43 - f81;
        f123 = f43 + f81;
        f124 = f40 - f86;
        f125 = f40 + f86;
        f126 = f42 - f87;
        f127 = f42 + f87;
        f128 = f49 - f92;
        f129 = f49 + f92;
        f130 = f51 - f93;
        f131 = f51 + f93;
        f132 = f48 - f98;
        f133 = f48 + f98;
        f134 = f50 - f99;
        f135 = f50 + f99;
        f136 = f57 - f104;
        f137 = f57 + f104;
        f138 = f59 - f105;
        f139 = f59 + f105;
        f140 = f56 - f110;
        f141 = f56 + f110;
        f142 = f58 - f111;
        f143 = f58 + f111;
        f144 = f123 + f121;
        f145 = (-0.78569496 * f123);
        f146 = (0.98078525 * f144);
        f147 = (1.1758755 * f121);
        f148 = f145 + f146;
        f149 = f147 - f146;
        f150 = f127 + f125;
        f151 = (0.27589938 * f127);
        f152 = (0.55557024 * f150);
        f153 = (1.3870399 * f125);
        f154 = f151 + f152;
        f155 = f153 - f152;
        f156 = f122 + f120;
        f157 = (1.1758755 * f122);
        f158 = (-0.19509032 * f156);
        f159 = (0.78569496 * f120);
        f160 = f157 + f158;
        f161 = f159 - f158;
        f162 = f126 + f124;
        f163 = (1.3870399 * f126);
        f164 = (-0.8314696 * f162);
        f165 = (-0.27589938 * f124);
        f166 = f163 + f164;
        f167 = f165 - f164;
        f168 = f139 + f137;
        f169 = (-0.78569496 * f139);
        f170 = (0.98078525 * f168);
        f171 = (1.1758755 * f137);
        f172 = f169 + f170;
        f173 = f171 - f170;
        f174 = f143 + f141;
        f175 = (0.27589938 * f143);
        f176 = (0.55557024 * f174);
        f177 = (1.3870399 * f141);
        f178 = f175 + f176;
        f179 = f177 - f176;
        f180 = f138 + f136;
        f181 = (1.1758755 * f138);
        f182 = (-0.19509032 * f180);
        f183 = (0.78569496 * f136);
        f184 = f181 + f182;
        f185 = f183 - f182;
        f186 = f142 + f140;
        f187 = (1.3870399 * f142);
        f188 = (-0.8314696 * f186);
        f189 = (-0.27589938 * f140);
        f190 = f187 + f188;
        f191 = f189 - f188;
        f192 = f113 - f148;
        f193 = f113 + f148;
        f194 = f115 - f149;
        f195 = f115 + f149;
        f196 = f117 - f154;
        f197 = f117 + f154;
        f198 = f119 - f155;
        f199 = f119 + f155;
        f200 = f112 - f160;
        f201 = f112 + f160;
        f202 = f114 - f161;
        f203 = f114 + f161;
        f204 = f116 - f166;
        f205 = f116 + f166;
        f206 = f118 - f167;
        f207 = f118 + f167;
        f208 = f129 - f172;
        f209 = f129 + f172;
        f210 = f131 - f173;
        f211 = f131 + f173;
        f212 = f133 - f178;
        f213 = f133 + f178;
        f214 = f135 - f179;
        f215 = f135 + f179;
        f216 = f128 - f184;
        f217 = f128 + f184;
        f218 = f130 - f185;
        f219 = f130 + f185;
        f220 = f132 - f190;
        f221 = f132 + f190;
        f222 = f134 - f191;
        f223 = f134 + f191;
        f224 = f211 + f209;
        f225 = (-0.89716756 * f211);
        f226 = (0.9951847 * f224);
        f227 = (1.0932019 * f209);
        f228 = f225 + f226;
        f229 = f227 - f226;
        f230 = f215 + f213;
        f231 = (-0.41052452 * f215);
        f232 = (0.8819213 * f230);
        f233 = (1.353318 * f213);
        f234 = f231 + f232;
        f235 = f233 - f232;
        f236 = f219 + f217;
        f237 = (0.13861717 * f219);
        f238 = (0.6343933 * f236);
        f239 = (1.4074037 * f217);
        f240 = f237 + f238;
        f241 = f239 - f238;
        f242 = f223 + f221;
        f243 = (0.66665566 * f223);
        f244 = (0.29028466 * f242);
        f245 = (1.247225 * f221);
        f246 = f243 + f244;
        f247 = f245 - f244;
        f248 = f210 + f208;
        f249 = (1.0932019 * f210);
        f250 = (-0.09801714 * f248);
        f251 = (0.89716756 * f208);
        f252 = f249 + f250;
        f253 = f251 - f250;
        f254 = f214 + f212;
        f255 = (1.353318 * f214);
        f256 = (-0.47139674 * f254);
        f257 = (0.41052452 * f212);
        f258 = f255 + f256;
        f259 = f257 - f256;
        f260 = f218 + f216;
        f261 = (1.4074037 * f218);
        f262 = (-0.77301043 * f260);
        f263 = (-0.13861717 * f216);
        f264 = f261 + f262;
        f265 = f263 - f262;
        f266 = f222 + f220;
        f267 = (1.247225 * f222);
        f268 = (-0.95694035 * f266);
        f269 = (-0.66665566 * f220);
        f270 = f267 + f268;
        f271 = f269 - f268;
        f272 = f193 - f228;
        f273 = f193 + f228;
        f274 = f195 - f229;
        f275 = f195 + f229;
        f276 = f197 - f234;
        f277 = f197 + f234;
        f278 = f199 - f235;
        f279 = f199 + f235;
        f280 = f201 - f240;
        f281 = f201 + f240;
        f282 = f203 - f241;
        f283 = f203 + f241;
        f284 = f205 - f246;
        f285 = f205 + f246;
        f286 = f207 - f247;
        f287 = f207 + f247;
        f288 = f192 - f252;
        f289 = f192 + f252;
        f290 = f194 - f253;
        f291 = f194 + f253;
        f292 = f196 - f258;
        f293 = f196 + f258;
        f294 = f198 - f259;
        f295 = f198 + f259;
        f296 = f200 - f264;
        f297 = f200 + f264;
        f298 = f202 - f265;
        f299 = f202 + f265;
        f300 = f204 - f270;
        f301 = f204 + f270;
        f302 = f206 - f271;
        f303 = f206 + f271;
        f304 = f275 + f273;
        f305 = (-0.9751576 * f275);
        f306 = (0.9996988 * f304);
        f307 = (1.02424 * f273);
        y[0] = f305 + f306;
        y[31] = f307 - f306;
        f310 = f279 + f277;
        f311 = (-0.87006885 * f279);
        f312 = (0.99247956 * f310);
        f313 = (1.1148902 * f277);
        y[2] = f311 + f312;
        y[29] = f313 - f312;
        f316 = f283 + f281;
        f317 = (-0.7566009 * f283);
        f318 = (0.9757021 * f316);
        f319 = (1.1948034 * f281);
        y[4] = f317 + f318;
        y[27] = f319 - f318;
        f322 = f287 + f285;
        f323 = (-0.63584644 * f287);
        f324 = (0.94952816 * f322);
        f325 = (1.2632099 * f285);
        y[6] = f323 + f324;
        y[25] = f325 - f324;
        f328 = f291 + f289;
        f329 = (-0.5089684 * f291);
        f330 = (0.9142098 * f328);
        f331 = (1.3194511 * f289);
        y[8] = f329 + f330;
        y[23] = f331 - f330;
        f334 = f295 + f293;
        f335 = (-0.3771888 * f295);
        f336 = (0.87008697 * f334);
        f337 = (1.3629851 * f293);
        y[10] = f335 + f336;
        y[21] = f337 - f336;
        f340 = f299 + f297;
        f341 = (-0.24177662 * f299);
        f342 = (0.8175848 * f340);
        f343 = (1.393393 * f297);
        y[12] = f341 + f342;
        y[19] = f343 - f342;
        f346 = f303 + f301;
        f347 = (-0.104036 * f303);
        f348 = (0.7572088 * f346);
        f349 = (1.4103817 * f301);
        y[14] = f347 + f348;
        y[17] = f349 - f348;
        f352 = f274 + f272;
        f353 = (0.034706537 * f274);
        f354 = (0.68954057 * f352);
        f355 = (1.4137876 * f272);
        y[16] = f353 + f354;
        y[15] = f355 - f354;
        f358 = f278 + f276;
        f359 = (0.17311484 * f278);
        f360 = (0.6152316 * f358);
        f361 = (1.403578 * f276);
        y[18] = f359 + f360;
        y[13] = f361 - f360;
        f364 = f282 + f280;
        f365 = (0.30985594 * f282);
        f366 = (0.53499764 * f364);
        f367 = (1.3798512 * f280);
        y[20] = f365 + f366;
        y[11] = f367 - f366;
        f370 = f286 + f284;
        f371 = (0.44361296 * f286);
        f372 = (0.44961134 * f370);
        f373 = (1.3428357 * f284);
        y[22] = f371 + f372;
        y[9] = f373 - f372;
        f376 = f290 + f288;
        f377 = (0.57309777 * f290);
        f378 = (0.35989505 * f376);
        f379 = (1.2928878 * f288);
        y[24] = f377 + f378;
        y[7] = f379 - f378;
        f382 = f294 + f292;
        f383 = (0.6970633 * f294);
        f384 = (0.26671275 * f382);
        f385 = (1.2304888 * f292);
        y[26] = f383 + f384;
        y[5] = f385 - f384;
        f388 = f298 + f296;
        f389 = (0.81431574 * f298);
        f390 = (0.17096189 * f388);
        f391 = (1.1562395 * f296);
        y[28] = f389 + f390;
        y[3] = f391 - f390;
        f394 = f302 + f300;
        f395 = (0.9237259 * f302);
        f396 = (0.07356457 * f394);
        f397 = (1.070855 * f300);
        y[30] = f395 + f396;
        y[1] = f397 - f396;
    };
    prototype.DST4_32 = function(y, x) {
        var f0, f1, f2, f3, f4, f5, f6, f7, f8, f9;
        var f10, f11, f12, f13, f14, f15, f16, f17, f18, f19;
        var f20, f21, f22, f23, f24, f25, f26, f27, f28, f29;
        var f30, f31, f32, f33, f34, f35, f36, f37, f38, f39;
        var f40, f41, f42, f43, f44, f45, f46, f47, f48, f49;
        var f50, f51, f52, f53, f54, f55, f56, f57, f58, f59;
        var f60, f61, f62, f63, f64, f65, f66, f67, f68, f69;
        var f70, f71, f72, f73, f74, f75, f76, f77, f78, f79;
        var f80, f81, f82, f83, f84, f85, f86, f87, f88, f89;
        var f90, f91, f92, f93, f94, f95, f96, f97, f98, f99;
        var f100, f101, f102, f103, f104, f105, f106, f107, f108, f109;
        var f110, f111, f112, f113, f114, f115, f116, f117, f118, f119;
        var f120, f121, f122, f123, f124, f125, f126, f127, f128, f129;
        var f130, f131, f132, f133, f134, f135, f136, f137, f138, f139;
        var f140, f141, f142, f143, f144, f145, f146, f147, f148, f149;
        var f150, f151, f152, f153, f154, f155, f156, f157, f158, f159;
        var f160, f161, f162, f163, f164, f165, f166, f167, f168, f169;
        var f170, f171, f172, f173, f174, f175, f176, f177, f178, f179;
        var f180, f181, f182, f183, f184, f185, f186, f187, f188, f189;
        var f190, f191, f192, f193, f194, f195, f196, f197, f198, f199;
        var f200, f201, f202, f203, f204, f205, f206, f207, f208, f209;
        var f210, f211, f212, f213, f214, f215, f216, f217, f218, f219;
        var f220, f221, f222, f223, f224, f225, f226, f227, f228, f229;
        var f230, f231, f232, f233, f234, f235, f236, f237, f238, f239;
        var f240, f241, f242, f243, f244, f245, f246, f247, f248, f249;
        var f250, f251, f252, f253, f254, f255, f256, f257, f258, f259;
        var f260, f261, f262, f263, f264, f265, f266, f267, f268, f269;
        var f270, f271, f272, f273, f274, f275, f276, f277, f278, f279;
        var f280, f281, f282, f283, f284, f285, f286, f287, f288, f289;
        var f290, f291, f292, f293, f294, f295, f296, f297, f298, f299;
        var f300, f301, f302, f303, f304, f305, f306, f307, f308, f309;
        var f310, f311, f312, f313, f314, f315, f316, f317, f318, f319;
        var f320, f321, f322, f323, f324, f325, f326, f327, f328, f329;
        var f330, f331, f332, f333, f334, f335;
        f0 = x[0] - x[1];
        f1 = x[2] - x[1];
        f2 = x[2] - x[3];
        f3 = x[4] - x[3];
        f4 = x[4] - x[5];
        f5 = x[6] - x[5];
        f6 = x[6] - x[7];
        f7 = x[8] - x[7];
        f8 = x[8] - x[9];
        f9 = x[10] - x[9];
        f10 = x[10] - x[11];
        f11 = x[12] - x[11];
        f12 = x[12] - x[13];
        f13 = x[14] - x[13];
        f14 = x[14] - x[15];
        f15 = x[16] - x[15];
        f16 = x[16] - x[17];
        f17 = x[18] - x[17];
        f18 = x[18] - x[19];
        f19 = x[20] - x[19];
        f20 = x[20] - x[21];
        f21 = x[22] - x[21];
        f22 = x[22] - x[23];
        f23 = x[24] - x[23];
        f24 = x[24] - x[25];
        f25 = x[26] - x[25];
        f26 = x[26] - x[27];
        f27 = x[28] - x[27];
        f28 = x[28] - x[29];
        f29 = x[30] - x[29];
        f30 = x[30] - x[31];
        f31 = (0.70710677 * f15);
        f32 = x[0] - f31;
        f33 = x[0] + f31;
        f34 = f7 + f23;
        f35 = (1.306563 * f7);
        f36 = (-0.9238795 * f34);
        f37 = (-0.5411961 * f23);
        f38 = f35 + f36;
        f39 = f37 - f36;
        f40 = f33 - f39;
        f41 = f33 + f39;
        f42 = f32 - f38;
        f43 = f32 + f38;
        f44 = f11 - f19;
        f45 = f11 + f19;
        f46 = (0.70710677 * f45);
        f47 = f3 - f46;
        f48 = f3 + f46;
        f49 = (0.70710677 * f44);
        f50 = f49 - f27;
        f51 = f49 + f27;
        f52 = f51 + f48;
        f53 = (-0.78569496 * f51);
        f54 = (0.98078525 * f52);
        f55 = (1.1758755 * f48);
        f56 = f53 + f54;
        f57 = f55 - f54;
        f58 = f50 + f47;
        f59 = (-0.27589938 * f50);
        f60 = (0.8314696 * f58);
        f61 = (1.3870399 * f47);
        f62 = f59 + f60;
        f63 = f61 - f60;
        f64 = f41 - f56;
        f65 = f41 + f56;
        f66 = f43 - f62;
        f67 = f43 + f62;
        f68 = f42 - f63;
        f69 = f42 + f63;
        f70 = f40 - f57;
        f71 = f40 + f57;
        f72 = f5 - f9;
        f73 = f5 + f9;
        f74 = f13 - f17;
        f75 = f13 + f17;
        f76 = f21 - f25;
        f77 = f21 + f25;
        f78 = (0.70710677 * f75);
        f79 = f1 - f78;
        f80 = f1 + f78;
        f81 = f73 + f77;
        f82 = (1.306563 * f73);
        f83 = (-0.9238795 * f81);
        f84 = (-0.5411961 * f77);
        f85 = f82 + f83;
        f86 = f84 - f83;
        f87 = f80 - f86;
        f88 = f80 + f86;
        f89 = f79 - f85;
        f90 = f79 + f85;
        f91 = (0.70710677 * f74);
        f92 = f29 - f91;
        f93 = f29 + f91;
        f94 = f76 + f72;
        f95 = (1.306563 * f76);
        f96 = (-0.9238795 * f94);
        f97 = (-0.5411961 * f72);
        f98 = f95 + f96;
        f99 = f97 - f96;
        f100 = f93 - f99;
        f101 = f93 + f99;
        f102 = f92 - f98;
        f103 = f92 + f98;
        f104 = f101 + f88;
        f105 = (-0.89716756 * f101);
        f106 = (0.9951847 * f104);
        f107 = (1.0932019 * f88);
        f108 = f105 + f106;
        f109 = f107 - f106;
        f110 = f90 - f103;
        f111 = (-0.66665566 * f103);
        f112 = (0.95694035 * f110);
        f113 = (1.247225 * f90);
        f114 = f112 - f111;
        f115 = f113 - f112;
        f116 = f102 + f89;
        f117 = (-0.41052452 * f102);
        f118 = (0.8819213 * f116);
        f119 = (1.353318 * f89);
        f120 = f117 + f118;
        f121 = f119 - f118;
        f122 = f87 - f100;
        f123 = (-0.13861717 * f100);
        f124 = (0.77301043 * f122);
        f125 = (1.4074037 * f87);
        f126 = f124 - f123;
        f127 = f125 - f124;
        f128 = f65 - f108;
        f129 = f65 + f108;
        f130 = f67 - f114;
        f131 = f67 + f114;
        f132 = f69 - f120;
        f133 = f69 + f120;
        f134 = f71 - f126;
        f135 = f71 + f126;
        f136 = f70 - f127;
        f137 = f70 + f127;
        f138 = f68 - f121;
        f139 = f68 + f121;
        f140 = f66 - f115;
        f141 = f66 + f115;
        f142 = f64 - f109;
        f143 = f64 + f109;
        f144 = f0 + f30;
        f145 = (1.0478631 * f0);
        f146 = (-0.99879545 * f144);
        f147 = (-0.9497278 * f30);
        f148 = f145 + f146;
        f149 = f147 - f146;
        f150 = f4 + f26;
        f151 = (1.2130114 * f4);
        f152 = (-0.97003126 * f150);
        f153 = (-0.7270511 * f26);
        f154 = f151 + f152;
        f155 = f153 - f152;
        f156 = f8 + f22;
        f157 = (1.3315444 * f8);
        f158 = (-0.9039893 * f156);
        f159 = (-0.4764342 * f22);
        f160 = f157 + f158;
        f161 = f159 - f158;
        f162 = f12 + f18;
        f163 = (1.3989068 * f12);
        f164 = (-0.8032075 * f162);
        f165 = (-0.20750822 * f18);
        f166 = f163 + f164;
        f167 = f165 - f164;
        f168 = f16 + f14;
        f169 = (1.41251 * f16);
        f170 = (-0.671559 * f168);
        f171 = (0.06939217 * f14);
        f172 = f169 + f170;
        f173 = f171 - f170;
        f174 = f20 + f10;
        f175 = (1.3718313 * f20);
        f176 = (-0.51410276 * f174);
        f177 = (0.34362587 * f10);
        f178 = f175 + f176;
        f179 = f177 - f176;
        f180 = f24 + f6;
        f181 = (1.2784339 * f24);
        f182 = (-0.33688986 * f180);
        f183 = (0.6046542 * f6);
        f184 = f181 + f182;
        f185 = f183 - f182;
        f186 = f28 + f2;
        f187 = (1.1359069 * f28);
        f188 = (-0.14673047 * f186);
        f189 = (0.842446 * f2);
        f190 = f187 + f188;
        f191 = f189 - f188;
        f192 = f149 - f173;
        f193 = f149 + f173;
        f194 = f148 - f172;
        f195 = f148 + f172;
        f196 = f155 - f179;
        f197 = f155 + f179;
        f198 = f154 - f178;
        f199 = f154 + f178;
        f200 = f161 - f185;
        f201 = f161 + f185;
        f202 = f160 - f184;
        f203 = f160 + f184;
        f204 = f167 - f191;
        f205 = f167 + f191;
        f206 = f166 - f190;
        f207 = f166 + f190;
        f208 = f192 + f194;
        f209 = (1.1758755 * f192);
        f210 = (-0.98078525 * f208);
        f211 = (-0.78569496 * f194);
        f212 = f209 + f210;
        f213 = f211 - f210;
        f214 = f196 + f198;
        f215 = (1.3870399 * f196);
        f216 = (-0.55557024 * f214);
        f217 = (0.27589938 * f198);
        f218 = f215 + f216;
        f219 = f217 - f216;
        f220 = f200 + f202;
        f221 = (0.78569496 * f200);
        f222 = (0.19509032 * f220);
        f223 = (1.1758755 * f202);
        f224 = f221 + f222;
        f225 = f223 - f222;
        f226 = f204 + f206;
        f227 = (-0.27589938 * f204);
        f228 = (0.8314696 * f226);
        f229 = (1.3870399 * f206);
        f230 = f227 + f228;
        f231 = f229 - f228;
        f232 = f193 - f201;
        f233 = f193 + f201;
        f234 = f195 - f203;
        f235 = f195 + f203;
        f236 = f197 - f205;
        f237 = f197 + f205;
        f238 = f199 - f207;
        f239 = f199 + f207;
        f240 = f213 - f225;
        f241 = f213 + f225;
        f242 = f212 - f224;
        f243 = f212 + f224;
        f244 = f219 - f231;
        f245 = f219 + f231;
        f246 = f218 - f230;
        f247 = f218 + f230;
        f248 = f232 + f234;
        f249 = (1.306563 * f232);
        f250 = (-0.9238795 * f248);
        f251 = (-0.5411961 * f234);
        f252 = f249 + f250;
        f253 = f251 - f250;
        f254 = f236 + f238;
        f255 = (0.5411961 * f236);
        f256 = (0.38268343 * f254);
        f257 = (1.306563 * f238);
        f258 = f255 + f256;
        f259 = f257 - f256;
        f260 = f240 + f242;
        f261 = (1.306563 * f240);
        f262 = (-0.9238795 * f260);
        f263 = (-0.5411961 * f242);
        f264 = f261 + f262;
        f265 = f263 - f262;
        f266 = f244 + f246;
        f267 = (0.5411961 * f244);
        f268 = (0.38268343 * f266);
        f269 = (1.306563 * f246);
        f270 = f267 + f268;
        f271 = f269 - f268;
        f272 = f233 - f237;
        f273 = f233 + f237;
        f274 = f235 - f239;
        f275 = f235 + f239;
        f276 = f253 - f259;
        f277 = f253 + f259;
        f278 = f252 - f258;
        f279 = f252 + f258;
        f280 = f241 - f245;
        f281 = f241 + f245;
        f282 = f243 - f247;
        f283 = f243 + f247;
        f284 = f265 - f271;
        f285 = f265 + f271;
        f286 = f264 - f270;
        f287 = f264 + f270;
        f288 = f272 - f274;
        f289 = f272 + f274;
        f290 = (0.70710677 * f288);
        f291 = (0.70710677 * f289);
        f292 = f276 - f278;
        f293 = f276 + f278;
        f294 = (0.70710677 * f292);
        f295 = (0.70710677 * f293);
        f296 = f280 - f282;
        f297 = f280 + f282;
        f298 = (0.70710677 * f296);
        f299 = (0.70710677 * f297);
        f300 = f284 - f286;
        f301 = f284 + f286;
        f302 = (0.70710677 * f300);
        f303 = (0.70710677 * f301);
        f304 = f129 - f273;
        f305 = f129 + f273;
        f306 = f131 - f281;
        f307 = f131 + f281;
        f308 = f133 - f285;
        f309 = f133 + f285;
        f310 = f135 - f277;
        f311 = f135 + f277;
        f312 = f137 - f295;
        f313 = f137 + f295;
        f314 = f139 - f303;
        f315 = f139 + f303;
        f316 = f141 - f299;
        f317 = f141 + f299;
        f318 = f143 - f291;
        f319 = f143 + f291;
        f320 = f142 - f290;
        f321 = f142 + f290;
        f322 = f140 - f298;
        f323 = f140 + f298;
        f324 = f138 - f302;
        f325 = f138 + f302;
        f326 = f136 - f294;
        f327 = f136 + f294;
        f328 = f134 - f279;
        f329 = f134 + f279;
        f330 = f132 - f287;
        f331 = f132 + f287;
        f332 = f130 - f283;
        f333 = f130 + f283;
        f334 = f128 - f275;
        f335 = f128 + f275;
        y[31] = (0.5001506 * f305);
        y[30] = (0.50135845 * f307);
        y[29] = (0.5037887 * f309);
        y[28] = (0.50747114 * f311);
        y[27] = (0.51245147 * f313);
        y[26] = (0.5187927 * f315);
        y[25] = (0.5265773 * f317);
        y[24] = (0.53590983 * f319);
        y[23] = (0.5469204 * f321);
        y[22] = (0.5597698 * f323);
        y[21] = (0.5746552 * f325);
        y[20] = (0.5918185 * f327);
        y[19] = (0.61155736 * f329);
        y[18] = (0.63423896 * f331);
        y[17] = (0.6603198 * f333);
        y[16] = (0.6903721 * f335);
        y[15] = (0.72512054 * f334);
        y[14] = (0.76549417 * f332);
        y[13] = (0.8127021 * f330);
        y[12] = (0.8683447 * f328);
        y[11] = (0.9345836 * f326);
        y[10] = (1.0144082 * f324);
        y[9] = (1.1120716 * f322);
        y[8] = (1.2338327 * f320);
        y[7] = (1.3892939 * f318);
        y[6] = (1.5939723 * f316);
        y[5] = (1.874676 * f314);
        y[4] = (2.2820501 * f312);
        y[3] = (2.9246285 * f310);
        y[2] = (4.084611 * f308);
        y[1] = (6.7967505 * f306);
        y[0] = (20.373878 * f304);
    };
}, {qmf32_pre_twiddle: "Array", v: "Float32Array", qmf_c: "Float32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var TFGrid = function() {};
TFGrid = stjs.extend(TFGrid, null, [SBRConstants], function(constructor, prototype) {
    constructor.envelope_time_border_vector = function(sbr, ch) {
        var l, border, temp;
        var t_E_temp = new Int32Array(6);
        t_E_temp[0] = sbr.rate * sbr.abs_bord_lead[ch];
        t_E_temp[sbr.L_E[ch]] = sbr.rate * sbr.abs_bord_trail[ch];
        switch (sbr.bs_frame_class[ch]) {
            case SBRConstants.FIXFIX:
                switch (sbr.L_E[ch]) {
                    case 4:
                        temp = (stjs.trunc(sbr.numTimeSlots / 4));
                        t_E_temp[3] = sbr.rate * 3 * temp;
                        t_E_temp[2] = sbr.rate * 2 * temp;
                        t_E_temp[1] = sbr.rate * temp;
                        break;
                    case 2:
                        t_E_temp[1] = sbr.rate * (stjs.trunc(sbr.numTimeSlots / 2));
                        break;
                    default:
                        break;
                }
                break;
            case SBRConstants.FIXVAR:
                if (sbr.L_E[ch] > 1) {
                    var i = sbr.L_E[ch];
                    border = sbr.abs_bord_trail[ch];
                    for (l = 0; l < (sbr.L_E[ch] - 1); l++) {
                        if (border < sbr.bs_rel_bord[ch][l]) 
                            return 1;
                        border -= sbr.bs_rel_bord[ch][l];
                        t_E_temp[--i] = sbr.rate * border;
                    }
                }
                break;
            case SBRConstants.VARFIX:
                if (sbr.L_E[ch] > 1) {
                    var i = 1;
                    border = sbr.abs_bord_lead[ch];
                    for (l = 0; l < (sbr.L_E[ch] - 1); l++) {
                        border += sbr.bs_rel_bord[ch][l];
                        if (sbr.rate * border + sbr.tHFAdj > sbr.numTimeSlotsRate + sbr.tHFGen) 
                            return 1;
                        t_E_temp[i++] = sbr.rate * border;
                    }
                }
                break;
            case SBRConstants.VARVAR:
                if (sbr.bs_num_rel_0[ch] != 0) {
                    var i = 1;
                    border = sbr.abs_bord_lead[ch];
                    for (l = 0; l < sbr.bs_num_rel_0[ch]; l++) {
                        border += sbr.bs_rel_bord_0[ch][l];
                        if (sbr.rate * border + sbr.tHFAdj > sbr.numTimeSlotsRate + sbr.tHFGen) 
                            return 1;
                        t_E_temp[i++] = sbr.rate * border;
                    }
                }
                if (sbr.bs_num_rel_1[ch] != 0) {
                    var i = sbr.L_E[ch];
                    border = sbr.abs_bord_trail[ch];
                    for (l = 0; l < sbr.bs_num_rel_1[ch]; l++) {
                        if (border < sbr.bs_rel_bord_1[ch][l]) 
                            return 1;
                        border -= sbr.bs_rel_bord_1[ch][l];
                        t_E_temp[--i] = sbr.rate * border;
                    }
                }
                break;
        }
        for (l = 0; l < 6; l++) {
            sbr.t_E[ch][l] = t_E_temp[l];
        }
        return 0;
    };
    constructor.noise_floor_time_border_vector = function(sbr, ch) {
        sbr.t_Q[ch][0] = sbr.t_E[ch][0];
        if (sbr.L_E[ch] == 1) {
            sbr.t_Q[ch][1] = sbr.t_E[ch][1];
            sbr.t_Q[ch][2] = 0;
        } else {
            var index = TFGrid.middleBorder(sbr, ch);
            sbr.t_Q[ch][1] = sbr.t_E[ch][index];
            sbr.t_Q[ch][2] = sbr.t_E[ch][sbr.L_E[ch]];
        }
    };
    constructor.middleBorder = function(sbr, ch) {
        var retval = 0;
        switch (sbr.bs_frame_class[ch]) {
            case SBRConstants.FIXFIX:
                retval = stjs.trunc(sbr.L_E[ch] / 2);
                break;
            case SBRConstants.VARFIX:
                if (sbr.bs_pointer[ch] == 0) 
                    retval = 1;
                 else if (sbr.bs_pointer[ch] == 1) 
                    retval = sbr.L_E[ch] - 1;
                 else 
                    retval = sbr.bs_pointer[ch] - 1;
                break;
            case SBRConstants.FIXVAR:
            case SBRConstants.VARVAR:
                if (sbr.bs_pointer[ch] > 1) 
                    retval = sbr.L_E[ch] + 1 - sbr.bs_pointer[ch];
                 else 
                    retval = sbr.L_E[ch] - 1;
                break;
        }
        return (retval > 0) ? retval : 0;
    };
}, {startMinTable: "Int32Array", offsetIndexTable: "Int32Array", OFFSET: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var NoiseEnvelope = function() {};
NoiseEnvelope = stjs.extend(NoiseEnvelope, null, [SBRConstants], function(constructor, prototype) {
    constructor.E_deq_tab = new Float32Array([64.0, 128.0, 256.0, 512.0, 1024.0, 2048.0, 4096.0, 8192.0, 16384.0, 32768.0, 65536.0, 131072.0, 262144.0, 524288.0, 1048580.0, 2097150.0, 4194300.0, 8388610.0, 1.67772E7, 3.35544E7, 6.7108896E7, 1.34218E8, 2.68435008E8, 5.3687098E8, 1.07374003E9, 2.14748006E9, 4.2949699E9, 8.58993E9, 1.71798999E10, 3.43596995E10, 6.8719501E10, 1.37439003E11, 2.74878005E11, 5.4975601E11, 1.09950999E12, 2.19901998E12, 4.3980502E12, 8.7960899E12, 1.75922007E13, 3.5184401E13, 7.0368698E13, 1.40737002E14, 2.8147501E14, 5.6295002E14, 1.12590004E15, 2.25180008E15, 4.5036002E15, 9.0072003E15, 1.80144007E16, 3.6028801E16, 7.2057603E16, 1.44114999E17, 2.88229998E17, 5.7646103E17, 1.15291999E18, 2.30583999E18, 4.6116899E18, 9.2233698E18, 1.84467E19, 3.68935E19, 7.3787E19, 1.47574E20, 2.95148E20, 5.90296E20]);
    constructor.Q_div2_tab = new Float32Array([0.984615, 0.969697, 0.941176, 0.888889, 0.8, 0.666667, 0.5, 0.333333, 0.2, 0.111111, 0.0588235, 0.030303, 0.0153846, 0.00775194, 0.00389105, 0.00194932, 9.7561E-4, 4.88043E-4, 2.44081E-4, 1.22055E-4, 6.10314E-5, 3.05166E-5, 1.52586E-5, 7.62934E-6, 3.81468E-6, 1.90734E-6, 9.53673E-7, 4.76837E-7, 2.38419E-7, 1.19209E-7, 5.96046E-8]);
    constructor.Q_div2_tab_left = [new Float32Array([0.0302959, 0.111015, 0.332468, 0.663212, 0.882759, 0.962406, 0.984615, 0.990329, 0.991768, 0.992128, 0.992218, 0.992241, 0.992246]), new Float32Array([0.0153809, 0.0587695, 0.199377, 0.496124, 0.790123, 0.927536, 0.969697, 0.980843, 0.98367, 0.984379, 0.984556, 0.984601, 0.984612]), new Float32Array([0.00775006, 0.0302744, 0.110727, 0.329897, 0.653061, 0.864865, 0.941176, 0.962406, 0.967864, 0.969238, 0.969582, 0.969668, 0.96969]), new Float32Array([0.0038901, 0.0153698, 0.0586081, 0.197531, 0.484848, 0.761905, 0.888889, 0.927536, 0.937729, 0.940312, 0.94096, 0.941122, 0.941163]), new Float32Array([0.00194884, 0.00774443, 0.0301887, 0.109589, 0.32, 0.615385, 0.8, 0.864865, 0.882759, 0.887348, 0.888503, 0.888792, 0.888865]), new Float32Array([9.75372E-4, 0.00388727, 0.0153257, 0.057971, 0.190476, 0.444444, 0.666667, 0.761905, 0.790123, 0.797508, 0.799375, 0.799844, 0.799961]), new Float32Array([4.87924E-4, 0.00194742, 0.00772201, 0.0298507, 0.105263, 0.285714, 0.5, 0.615385, 0.653061, 0.663212, 0.6658, 0.66645, 0.666612]), new Float32Array([2.44021E-4, 9.74659E-4, 0.00387597, 0.0151515, 0.0555556, 0.166667, 0.333333, 0.444444, 0.484848, 0.496124, 0.499025, 0.499756, 0.499939]), new Float32Array([1.22026E-4, 4.87567E-4, 0.00194175, 0.00763359, 0.0285714, 0.0909091, 0.2, 0.285714, 0.32, 0.329897, 0.332468, 0.333116, 0.333279]), new Float32Array([6.10165E-5, 2.43843E-4, 9.71817E-4, 0.00383142, 0.0144928, 0.047619, 0.111111, 0.166667, 0.190476, 0.197531, 0.199377, 0.199844, 0.199961]), new Float32Array([3.05092E-5, 1.21936E-4, 4.86145E-4, 0.00191939, 0.00729927, 0.0243902, 0.0588235, 0.0909091, 0.105263, 0.109589, 0.110727, 0.111015, 0.111087]), new Float32Array([1.52548E-5, 6.09719E-5, 2.43132E-4, 9.60615E-4, 0.003663, 0.0123457, 0.030303, 0.047619, 0.0555556, 0.057971, 0.0586081, 0.0587695, 0.05881]), new Float32Array([7.62747E-6, 3.04869E-5, 1.21581E-4, 4.80538E-4, 0.00183486, 0.00621118, 0.0153846, 0.0243902, 0.0285714, 0.0298507, 0.0301887, 0.0302744, 0.0302959]), new Float32Array([3.81375E-6, 1.52437E-5, 6.0794E-5, 2.40327E-4, 9.18274E-4, 0.00311526, 0.00775194, 0.0123457, 0.0144928, 0.0151515, 0.0153257, 0.0153698, 0.0153809]), new Float32Array([1.90688E-6, 7.62189E-6, 3.03979E-5, 1.20178E-4, 4.59348E-4, 0.00156006, 0.00389105, 0.00621118, 0.00729927, 0.00763359, 0.00772201, 0.00774443, 0.00775006]), new Float32Array([9.53441E-7, 3.81096E-6, 1.51992E-5, 6.00925E-5, 2.29727E-4, 7.8064E-4, 0.00194932, 0.00311526, 0.003663, 0.00383142, 0.00387597, 0.00388727, 0.0038901]), new Float32Array([4.76721E-7, 1.90548E-6, 7.59965E-6, 3.00472E-5, 1.14877E-4, 3.90472E-4, 9.7561E-4, 0.00156006, 0.00183486, 0.00191939, 0.00194175, 0.00194742, 0.00194884]), new Float32Array([2.3836E-7, 9.52743E-7, 3.79984E-6, 1.50238E-5, 5.74416E-5, 1.95274E-4, 4.88043E-4, 7.8064E-4, 9.18274E-4, 9.60615E-4, 9.71817E-4, 9.74659E-4, 9.75372E-4]), new Float32Array([1.1918E-7, 4.76372E-7, 1.89992E-6, 7.51196E-6, 2.87216E-5, 9.76467E-5, 2.44081E-4, 3.90472E-4, 4.59348E-4, 4.80538E-4, 4.86145E-4, 4.87567E-4, 4.87924E-4]), new Float32Array([5.95901E-8, 2.38186E-7, 9.49963E-7, 3.756E-6, 1.4361E-5, 4.88257E-5, 1.22055E-4, 1.95274E-4, 2.29727E-4, 2.40327E-4, 2.43132E-4, 2.43843E-4, 2.44021E-4]), new Float32Array([2.9795E-8, 1.19093E-7, 4.74982E-7, 1.878E-6, 7.18056E-6, 2.44135E-5, 6.10314E-5, 9.76467E-5, 1.14877E-4, 1.20178E-4, 1.21581E-4, 1.21936E-4, 1.22026E-4]), new Float32Array([1.48975E-8, 5.95465E-8, 2.37491E-7, 9.39002E-7, 3.59029E-6, 1.22069E-5, 3.05166E-5, 4.88257E-5, 5.74416E-5, 6.00925E-5, 6.0794E-5, 6.09719E-5, 6.10165E-5]), new Float32Array([7.44876E-9, 2.97732E-8, 1.18745E-7, 4.69501E-7, 1.79515E-6, 6.10348E-6, 1.52586E-5, 2.44135E-5, 2.87216E-5, 3.00472E-5, 3.03979E-5, 3.04869E-5, 3.05092E-5]), new Float32Array([3.72438E-9, 1.48866E-8, 5.93727E-8, 2.34751E-7, 8.97575E-7, 3.05175E-6, 7.62934E-6, 1.22069E-5, 1.4361E-5, 1.50238E-5, 1.51992E-5, 1.52437E-5, 1.52548E-5]), new Float32Array([1.86219E-9, 7.44331E-9, 2.96864E-8, 1.17375E-7, 4.48788E-7, 1.52588E-6, 3.81468E-6, 6.10348E-6, 7.18056E-6, 7.51196E-6, 7.59965E-6, 7.62189E-6, 7.62747E-6]), new Float32Array([9.31095E-10, 3.72166E-9, 1.48432E-8, 5.86876E-8, 2.24394E-7, 7.62939E-7, 1.90734E-6, 3.05175E-6, 3.59029E-6, 3.756E-6, 3.79984E-6, 3.81096E-6, 3.81375E-6]), new Float32Array([4.65548E-10, 1.86083E-9, 7.42159E-9, 2.93438E-8, 1.12197E-7, 3.8147E-7, 9.53673E-7, 1.52588E-6, 1.79515E-6, 1.878E-6, 1.89992E-6, 1.90548E-6, 1.90688E-6]), new Float32Array([2.32774E-10, 9.30414E-10, 3.71079E-9, 1.46719E-8, 5.60985E-8, 1.90735E-7, 4.76837E-7, 7.62939E-7, 8.97575E-7, 9.39002E-7, 9.49963E-7, 9.52743E-7, 9.53441E-7]), new Float32Array([1.16387E-10, 4.65207E-10, 1.8554E-9, 7.33596E-9, 2.80492E-8, 9.53674E-8, 2.38419E-7, 3.8147E-7, 4.48788E-7, 4.69501E-7, 4.74982E-7, 4.76372E-7, 4.76721E-7]), new Float32Array([5.81935E-11, 2.32603E-10, 9.27699E-10, 3.66798E-9, 1.40246E-8, 4.76837E-8, 1.19209E-7, 1.90735E-7, 2.24394E-7, 2.34751E-7, 2.37491E-7, 2.38186E-7, 2.3836E-7]), new Float32Array([2.90967E-11, 1.16302E-10, 4.63849E-10, 1.83399E-9, 7.01231E-9, 2.38419E-8, 5.96046E-8, 9.53674E-8, 1.12197E-7, 1.17375E-7, 1.18745E-7, 1.19093E-7, 1.1918E-7])];
    constructor.Q_div2_tab_right = [new Float32Array([0.992246, 0.992241, 0.992218, 0.992128, 0.991768, 0.990329, 0.984615, 0.962406, 0.882759, 0.663212, 0.332468, 0.111015, 0.0302959]), new Float32Array([0.984612, 0.984601, 0.984556, 0.984379, 0.98367, 0.980843, 0.969697, 0.927536, 0.790123, 0.496124, 0.199377, 0.0587695, 0.0153809]), new Float32Array([0.96969, 0.969668, 0.969582, 0.969238, 0.967864, 0.962406, 0.941176, 0.864865, 0.653061, 0.329897, 0.110727, 0.0302744, 0.00775006]), new Float32Array([0.941163, 0.941122, 0.94096, 0.940312, 0.937729, 0.927536, 0.888889, 0.761905, 0.484848, 0.197531, 0.0586081, 0.0153698, 0.0038901]), new Float32Array([0.888865, 0.888792, 0.888503, 0.887348, 0.882759, 0.864865, 0.8, 0.615385, 0.32, 0.109589, 0.0301887, 0.00774443, 0.00194884]), new Float32Array([0.799961, 0.799844, 0.799375, 0.797508, 0.790123, 0.761905, 0.666667, 0.444444, 0.190476, 0.057971, 0.0153257, 0.00388727, 9.75372E-4]), new Float32Array([0.666612, 0.66645, 0.6658, 0.663212, 0.653061, 0.615385, 0.5, 0.285714, 0.105263, 0.0298507, 0.00772201, 0.00194742, 4.87924E-4]), new Float32Array([0.499939, 0.499756, 0.499025, 0.496124, 0.484848, 0.444444, 0.333333, 0.166667, 0.0555556, 0.0151515, 0.00387597, 9.74659E-4, 2.44021E-4]), new Float32Array([0.333279, 0.333116, 0.332468, 0.329897, 0.32, 0.285714, 0.2, 0.0909091, 0.0285714, 0.00763359, 0.00194175, 4.87567E-4, 1.22026E-4]), new Float32Array([0.199961, 0.199844, 0.199377, 0.197531, 0.190476, 0.166667, 0.111111, 0.047619, 0.0144928, 0.00383142, 9.71817E-4, 2.43843E-4, 6.10165E-5]), new Float32Array([0.111087, 0.111015, 0.110727, 0.109589, 0.105263, 0.0909091, 0.0588235, 0.0243902, 0.00729927, 0.00191939, 4.86145E-4, 1.21936E-4, 3.05092E-5]), new Float32Array([0.05881, 0.0587695, 0.0586081, 0.057971, 0.0555556, 0.047619, 0.030303, 0.0123457, 0.003663, 9.60615E-4, 2.43132E-4, 6.09719E-5, 1.52548E-5]), new Float32Array([0.0302959, 0.0302744, 0.0301887, 0.0298507, 0.0285714, 0.0243902, 0.0153846, 0.00621118, 0.00183486, 4.80538E-4, 1.21581E-4, 3.04869E-5, 7.62747E-6]), new Float32Array([0.0153809, 0.0153698, 0.0153257, 0.0151515, 0.0144928, 0.0123457, 0.00775194, 0.00311526, 9.18274E-4, 2.40327E-4, 6.0794E-5, 1.52437E-5, 3.81375E-6]), new Float32Array([0.00775006, 0.00774443, 0.00772201, 0.00763359, 0.00729927, 0.00621118, 0.00389105, 0.00156006, 4.59348E-4, 1.20178E-4, 3.03979E-5, 7.62189E-6, 1.90688E-6]), new Float32Array([0.0038901, 0.00388727, 0.00387597, 0.00383142, 0.003663, 0.00311526, 0.00194932, 7.8064E-4, 2.29727E-4, 6.00925E-5, 1.51992E-5, 3.81096E-6, 9.53441E-7]), new Float32Array([0.00194884, 0.00194742, 0.00194175, 0.00191939, 0.00183486, 0.00156006, 9.7561E-4, 3.90472E-4, 1.14877E-4, 3.00472E-5, 7.59965E-6, 1.90548E-6, 4.76721E-7]), new Float32Array([9.75372E-4, 9.74659E-4, 9.71817E-4, 9.60615E-4, 9.18274E-4, 7.8064E-4, 4.88043E-4, 1.95274E-4, 5.74416E-5, 1.50238E-5, 3.79984E-6, 9.52743E-7, 2.3836E-7]), new Float32Array([4.87924E-4, 4.87567E-4, 4.86145E-4, 4.80538E-4, 4.59348E-4, 3.90472E-4, 2.44081E-4, 9.76467E-5, 2.87216E-5, 7.51196E-6, 1.89992E-6, 4.76372E-7, 1.1918E-7]), new Float32Array([2.44021E-4, 2.43843E-4, 2.43132E-4, 2.40327E-4, 2.29727E-4, 1.95274E-4, 1.22055E-4, 4.88257E-5, 1.4361E-5, 3.756E-6, 9.49963E-7, 2.38186E-7, 5.95901E-8]), new Float32Array([1.22026E-4, 1.21936E-4, 1.21581E-4, 1.20178E-4, 1.14877E-4, 9.76467E-5, 6.10314E-5, 2.44135E-5, 7.18056E-6, 1.878E-6, 4.74982E-7, 1.19093E-7, 2.9795E-8]), new Float32Array([6.10165E-5, 6.09719E-5, 6.0794E-5, 6.00925E-5, 5.74416E-5, 4.88257E-5, 3.05166E-5, 1.22069E-5, 3.59029E-6, 9.39002E-7, 2.37491E-7, 5.95465E-8, 1.48975E-8]), new Float32Array([3.05092E-5, 3.04869E-5, 3.03979E-5, 3.00472E-5, 2.87216E-5, 2.44135E-5, 1.52586E-5, 6.10348E-6, 1.79515E-6, 4.69501E-7, 1.18745E-7, 2.97732E-8, 7.44876E-9]), new Float32Array([1.52548E-5, 1.52437E-5, 1.51992E-5, 1.50238E-5, 1.4361E-5, 1.22069E-5, 7.62934E-6, 3.05175E-6, 8.97575E-7, 2.34751E-7, 5.93727E-8, 1.48866E-8, 3.72438E-9]), new Float32Array([7.62747E-6, 7.62189E-6, 7.59965E-6, 7.51196E-6, 7.18056E-6, 6.10348E-6, 3.81468E-6, 1.52588E-6, 4.48788E-7, 1.17375E-7, 2.96864E-8, 7.44331E-9, 1.86219E-9]), new Float32Array([3.81375E-6, 3.81096E-6, 3.79984E-6, 3.756E-6, 3.59029E-6, 3.05175E-6, 1.90734E-6, 7.62939E-7, 2.24394E-7, 5.86876E-8, 1.48432E-8, 3.72166E-9, 9.31095E-10]), new Float32Array([1.90688E-6, 1.90548E-6, 1.89992E-6, 1.878E-6, 1.79515E-6, 1.52588E-6, 9.53673E-7, 3.8147E-7, 1.12197E-7, 2.93438E-8, 7.42159E-9, 1.86083E-9, 4.65548E-10]), new Float32Array([9.53441E-7, 9.52743E-7, 9.49963E-7, 9.39002E-7, 8.97575E-7, 7.62939E-7, 4.76837E-7, 1.90735E-7, 5.60985E-8, 1.46719E-8, 3.71079E-9, 9.30414E-10, 2.32774E-10]), new Float32Array([4.76721E-7, 4.76372E-7, 4.74982E-7, 4.69501E-7, 4.48788E-7, 3.8147E-7, 2.38419E-7, 9.53674E-8, 2.80492E-8, 7.33596E-9, 1.8554E-9, 4.65207E-10, 1.16387E-10]), new Float32Array([2.3836E-7, 2.38186E-7, 2.37491E-7, 2.34751E-7, 2.24394E-7, 1.90735E-7, 1.19209E-7, 4.76837E-8, 1.40246E-8, 3.66798E-9, 9.27699E-10, 2.32603E-10, 5.81935E-11]), new Float32Array([1.1918E-7, 1.19093E-7, 1.18745E-7, 1.17375E-7, 1.12197E-7, 9.53674E-8, 5.96046E-8, 2.38419E-8, 7.01231E-9, 1.83399E-9, 4.63849E-10, 1.16302E-10, 2.90967E-11])];
    constructor.Q_div_tab = new Float32Array([0.0153846, 0.030303, 0.0588235, 0.111111, 0.2, 0.333333, 0.5, 0.666667, 0.8, 0.888889, 0.941176, 0.969697, 0.984615, 0.992248, 0.996109, 0.998051, 0.999024, 0.999512, 0.999756, 0.999878, 0.999939, 0.999969, 0.999985, 0.999992, 0.999996, 0.999998, 0.999999, 1.0, 1.0, 1.0, 1.0]);
    constructor.Q_div_tab_left = [new Float32Array([0.969704, 0.888985, 0.667532, 0.336788, 0.117241, 0.037594, 0.0153846, 0.00967118, 0.00823245, 0.00787211, 0.00778198, 0.00775945, 0.00775382]), new Float32Array([0.984619, 0.94123, 0.800623, 0.503876, 0.209877, 0.0724638, 0.030303, 0.0191571, 0.0163305, 0.0156212, 0.0154438, 0.0153994, 0.0153883]), new Float32Array([0.99225, 0.969726, 0.889273, 0.670103, 0.346939, 0.135135, 0.0588235, 0.037594, 0.0321361, 0.0307619, 0.0304178, 0.0303317, 0.0303102]), new Float32Array([0.99611, 0.98463, 0.941392, 0.802469, 0.515152, 0.238095, 0.111111, 0.0724638, 0.0622711, 0.0596878, 0.0590397, 0.0588776, 0.058837]), new Float32Array([0.998051, 0.992256, 0.969811, 0.890411, 0.68, 0.384615, 0.2, 0.135135, 0.117241, 0.112652, 0.111497, 0.111208, 0.111135]), new Float32Array([0.999025, 0.996113, 0.984674, 0.942029, 0.809524, 0.555556, 0.333333, 0.238095, 0.209877, 0.202492, 0.200625, 0.200156, 0.200039]), new Float32Array([0.999512, 0.998053, 0.992278, 0.970149, 0.894737, 0.714286, 0.5, 0.384615, 0.346939, 0.336788, 0.3342, 0.33355, 0.333388]), new Float32Array([0.999756, 0.999025, 0.996124, 0.984848, 0.944444, 0.833333, 0.666667, 0.555556, 0.515152, 0.503876, 0.500975, 0.500244, 0.500061]), new Float32Array([0.999878, 0.999512, 0.998058, 0.992366, 0.971429, 0.909091, 0.8, 0.714286, 0.68, 0.670103, 0.667532, 0.666884, 0.666721]), new Float32Array([0.999939, 0.999756, 0.999028, 0.996169, 0.985507, 0.952381, 0.888889, 0.833333, 0.809524, 0.802469, 0.800623, 0.800156, 0.800039]), new Float32Array([0.999969, 0.999878, 0.999514, 0.998081, 0.992701, 0.97561, 0.941176, 0.909091, 0.894737, 0.890411, 0.889273, 0.888985, 0.888913]), new Float32Array([0.999985, 0.999939, 0.999757, 0.999039, 0.996337, 0.987654, 0.969697, 0.952381, 0.944444, 0.942029, 0.941392, 0.94123, 0.94119]), new Float32Array([0.999992, 0.99997, 0.999878, 0.999519, 0.998165, 0.993789, 0.984615, 0.97561, 0.971429, 0.970149, 0.969811, 0.969726, 0.969704]), new Float32Array([0.999996, 0.999985, 0.999939, 0.99976, 0.999082, 0.996885, 0.992248, 0.987654, 0.985507, 0.984848, 0.984674, 0.98463, 0.984619]), new Float32Array([0.999998, 0.999992, 0.99997, 0.99988, 0.999541, 0.99844, 0.996109, 0.993789, 0.992701, 0.992366, 0.992278, 0.992256, 0.99225]), new Float32Array([0.999999, 0.999996, 0.999985, 0.99994, 0.99977, 0.999219, 0.998051, 0.996885, 0.996337, 0.996169, 0.996124, 0.996113, 0.99611]), new Float32Array([1.0, 0.999998, 0.999992, 0.99997, 0.999885, 0.99961, 0.999024, 0.99844, 0.998165, 0.998081, 0.998058, 0.998053, 0.998051]), new Float32Array([1.0, 0.999999, 0.999996, 0.999985, 0.999943, 0.999805, 0.999512, 0.999219, 0.999082, 0.999039, 0.999028, 0.999025, 0.999025]), new Float32Array([1.0, 1.0, 0.999998, 0.999992, 0.999971, 0.999902, 0.999756, 0.99961, 0.999541, 0.999519, 0.999514, 0.999512, 0.999512]), new Float32Array([1.0, 1.0, 0.999999, 0.999996, 0.999986, 0.999951, 0.999878, 0.999805, 0.99977, 0.99976, 0.999757, 0.999756, 0.999756]), new Float32Array([1.0, 1.0, 1.0, 0.999998, 0.999993, 0.999976, 0.999939, 0.999902, 0.999885, 0.99988, 0.999878, 0.999878, 0.999878]), new Float32Array([1.0, 1.0, 1.0, 0.999999, 0.999996, 0.999988, 0.999969, 0.999951, 0.999943, 0.99994, 0.999939, 0.999939, 0.999939]), new Float32Array([1.0, 1.0, 1.0, 1.0, 0.999998, 0.999994, 0.999985, 0.999976, 0.999971, 0.99997, 0.99997, 0.99997, 0.999969]), new Float32Array([1.0, 1.0, 1.0, 1.0, 0.999999, 0.999997, 0.999992, 0.999988, 0.999986, 0.999985, 0.999985, 0.999985, 0.999985]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 0.999998, 0.999996, 0.999994, 0.999993, 0.999992, 0.999992, 0.999992, 0.999992]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 0.999999, 0.999998, 0.999997, 0.999996, 0.999996, 0.999996, 0.999996, 0.999996]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.999999, 0.999998, 0.999998, 0.999998, 0.999998, 0.999998, 0.999998]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.999999, 0.999999, 0.999999, 0.999999, 0.999999, 0.999999]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])];
    constructor.Q_div_tab_right = [new Float32Array([0.00775382, 0.00775945, 0.00778198, 0.00787211, 0.00823245, 0.00967118, 0.0153846, 0.037594, 0.117241, 0.336788, 0.667532, 0.888985, 0.969704]), new Float32Array([0.0153883, 0.0153994, 0.0154438, 0.0156212, 0.0163305, 0.0191571, 0.030303, 0.0724638, 0.209877, 0.503876, 0.800623, 0.94123, 0.984619]), new Float32Array([0.0303102, 0.0303317, 0.0304178, 0.0307619, 0.0321361, 0.037594, 0.0588235, 0.135135, 0.346939, 0.670103, 0.889273, 0.969726, 0.99225]), new Float32Array([0.058837, 0.0588776, 0.0590397, 0.0596878, 0.0622711, 0.0724638, 0.111111, 0.238095, 0.515152, 0.802469, 0.941392, 0.98463, 0.99611]), new Float32Array([0.111135, 0.111208, 0.111497, 0.112652, 0.117241, 0.135135, 0.2, 0.384615, 0.68, 0.890411, 0.969811, 0.992256, 0.998051]), new Float32Array([0.200039, 0.200156, 0.200625, 0.202492, 0.209877, 0.238095, 0.333333, 0.555556, 0.809524, 0.942029, 0.984674, 0.996113, 0.999025]), new Float32Array([0.333388, 0.33355, 0.3342, 0.336788, 0.346939, 0.384615, 0.5, 0.714286, 0.894737, 0.970149, 0.992278, 0.998053, 0.999512]), new Float32Array([0.500061, 0.500244, 0.500975, 0.503876, 0.515152, 0.555556, 0.666667, 0.833333, 0.944444, 0.984848, 0.996124, 0.999025, 0.999756]), new Float32Array([0.666721, 0.666884, 0.667532, 0.670103, 0.68, 0.714286, 0.8, 0.909091, 0.971429, 0.992366, 0.998058, 0.999512, 0.999878]), new Float32Array([0.800039, 0.800156, 0.800623, 0.802469, 0.809524, 0.833333, 0.888889, 0.952381, 0.985507, 0.996169, 0.999028, 0.999756, 0.999939]), new Float32Array([0.888913, 0.888985, 0.889273, 0.890411, 0.894737, 0.909091, 0.941176, 0.97561, 0.992701, 0.998081, 0.999514, 0.999878, 0.999969]), new Float32Array([0.94119, 0.94123, 0.941392, 0.942029, 0.944444, 0.952381, 0.969697, 0.987654, 0.996337, 0.999039, 0.999757, 0.999939, 0.999985]), new Float32Array([0.969704, 0.969726, 0.969811, 0.970149, 0.971429, 0.97561, 0.984615, 0.993789, 0.998165, 0.999519, 0.999878, 0.99997, 0.999992]), new Float32Array([0.984619, 0.98463, 0.984674, 0.984848, 0.985507, 0.987654, 0.992248, 0.996885, 0.999082, 0.99976, 0.999939, 0.999985, 0.999996]), new Float32Array([0.99225, 0.992256, 0.992278, 0.992366, 0.992701, 0.993789, 0.996109, 0.99844, 0.999541, 0.99988, 0.99997, 0.999992, 0.999998]), new Float32Array([0.99611, 0.996113, 0.996124, 0.996169, 0.996337, 0.996885, 0.998051, 0.999219, 0.99977, 0.99994, 0.999985, 0.999996, 0.999999]), new Float32Array([0.998051, 0.998053, 0.998058, 0.998081, 0.998165, 0.99844, 0.999024, 0.99961, 0.999885, 0.99997, 0.999992, 0.999998, 1.0]), new Float32Array([0.999025, 0.999025, 0.999028, 0.999039, 0.999082, 0.999219, 0.999512, 0.999805, 0.999943, 0.999985, 0.999996, 0.999999, 1.0]), new Float32Array([0.999512, 0.999512, 0.999514, 0.999519, 0.999541, 0.99961, 0.999756, 0.999902, 0.999971, 0.999992, 0.999998, 1.0, 1.0]), new Float32Array([0.999756, 0.999756, 0.999757, 0.99976, 0.99977, 0.999805, 0.999878, 0.999951, 0.999986, 0.999996, 0.999999, 1.0, 1.0]), new Float32Array([0.999878, 0.999878, 0.999878, 0.99988, 0.999885, 0.999902, 0.999939, 0.999976, 0.999993, 0.999998, 1.0, 1.0, 1.0]), new Float32Array([0.999939, 0.999939, 0.999939, 0.99994, 0.999943, 0.999951, 0.999969, 0.999988, 0.999996, 0.999999, 1.0, 1.0, 1.0]), new Float32Array([0.999969, 0.99997, 0.99997, 0.99997, 0.999971, 0.999976, 0.999985, 0.999994, 0.999998, 1.0, 1.0, 1.0, 1.0]), new Float32Array([0.999985, 0.999985, 0.999985, 0.999985, 0.999986, 0.999988, 0.999992, 0.999997, 0.999999, 1.0, 1.0, 1.0, 1.0]), new Float32Array([0.999992, 0.999992, 0.999992, 0.999992, 0.999993, 0.999994, 0.999996, 0.999998, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([0.999996, 0.999996, 0.999996, 0.999996, 0.999996, 0.999997, 0.999998, 0.999999, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([0.999998, 0.999998, 0.999998, 0.999998, 0.999998, 0.999998, 0.999999, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([0.999999, 0.999999, 0.999999, 0.999999, 0.999999, 0.999999, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])];
    constructor.extract_envelope_data = function(sbr, ch) {
        var l, k;
        for (l = 0; l < sbr.L_E[ch]; l++) {
            if (sbr.bs_df_env[ch][l] == 0) {
                for (k = 1; k < sbr.n[sbr.f[ch][l]]; k++) {
                    sbr.E[ch][k][l] = sbr.E[ch][k - 1][l] + sbr.E[ch][k][l];
                    if (sbr.E[ch][k][l] < 0) 
                        sbr.E[ch][k][l] = 0;
                }
            } else {
                var g = (l == 0) ? sbr.f_prev[ch] : sbr.f[ch][l - 1];
                var E_prev;
                if (sbr.f[ch][l] == g) {
                    for (k = 0; k < sbr.n[sbr.f[ch][l]]; k++) {
                        if (l == 0) 
                            E_prev = sbr.E_prev[ch][k];
                         else 
                            E_prev = sbr.E[ch][k][l - 1];
                        sbr.E[ch][k][l] = E_prev + sbr.E[ch][k][l];
                    }
                } else if ((g == 1) && (sbr.f[ch][l] == 0)) {
                    var i;
                    for (k = 0; k < sbr.n[sbr.f[ch][l]]; k++) {
                        for (i = 0; i < sbr.N_high; i++) {
                            if (sbr.f_table_res[SBRConstants.HI_RES][i] == sbr.f_table_res[SBRConstants.LO_RES][k]) {
                                if (l == 0) 
                                    E_prev = sbr.E_prev[ch][i];
                                 else 
                                    E_prev = sbr.E[ch][i][l - 1];
                                sbr.E[ch][k][l] = E_prev + sbr.E[ch][k][l];
                            }
                        }
                    }
                } else if ((g == 0) && (sbr.f[ch][l] == 1)) {
                    var i;
                    for (k = 0; k < sbr.n[sbr.f[ch][l]]; k++) {
                        for (i = 0; i < sbr.N_low; i++) {
                            if ((sbr.f_table_res[SBRConstants.LO_RES][i] <= sbr.f_table_res[SBRConstants.HI_RES][k]) && (sbr.f_table_res[SBRConstants.HI_RES][k] < sbr.f_table_res[SBRConstants.LO_RES][i + 1])) {
                                if (l == 0) 
                                    E_prev = sbr.E_prev[ch][i];
                                 else 
                                    E_prev = sbr.E[ch][i][l - 1];
                                sbr.E[ch][k][l] = E_prev + sbr.E[ch][k][l];
                            }
                        }
                    }
                }
            }
        }
    };
    constructor.extract_noise_floor_data = function(sbr, ch) {
        var l, k;
        for (l = 0; l < sbr.L_Q[ch]; l++) {
            if (sbr.bs_df_noise[ch][l] == 0) {
                for (k = 1; k < sbr.N_Q; k++) {
                    sbr.Q[ch][k][l] = sbr.Q[ch][k][l] + sbr.Q[ch][k - 1][l];
                }
            } else {
                if (l == 0) {
                    for (k = 0; k < sbr.N_Q; k++) {
                        sbr.Q[ch][k][l] = sbr.Q_prev[ch][k] + sbr.Q[ch][k][0];
                    }
                } else {
                    for (k = 0; k < sbr.N_Q; k++) {
                        sbr.Q[ch][k][l] = sbr.Q[ch][k][l - 1] + sbr.Q[ch][k][l];
                    }
                }
            }
        }
    };
    constructor.calc_Q_div = function(sbr, ch, m, l) {
        if (sbr.bs_coupling) {
            if ((sbr.Q[0][m][l] < 0 || sbr.Q[0][m][l] > 30) || (sbr.Q[1][m][l] < 0 || sbr.Q[1][m][l] > 24)) {
                return 0;
            } else {
                if (ch == 0) {
                    return NoiseEnvelope.Q_div_tab_left[sbr.Q[0][m][l]][sbr.Q[1][m][l] >> 1];
                } else {
                    return NoiseEnvelope.Q_div_tab_right[sbr.Q[0][m][l]][sbr.Q[1][m][l] >> 1];
                }
            }
        } else {
            if (sbr.Q[ch][m][l] < 0 || sbr.Q[ch][m][l] > 30) {
                return 0;
            } else {
                return NoiseEnvelope.Q_div_tab[sbr.Q[ch][m][l]];
            }
        }
    };
    constructor.calc_Q_div2 = function(sbr, ch, m, l) {
        if (sbr.bs_coupling) {
            if ((sbr.Q[0][m][l] < 0 || sbr.Q[0][m][l] > 30) || (sbr.Q[1][m][l] < 0 || sbr.Q[1][m][l] > 24)) {
                return 0;
            } else {
                if (ch == 0) {
                    return NoiseEnvelope.Q_div2_tab_left[sbr.Q[0][m][l]][sbr.Q[1][m][l] >> 1];
                } else {
                    return NoiseEnvelope.Q_div2_tab_right[sbr.Q[0][m][l]][sbr.Q[1][m][l] >> 1];
                }
            }
        } else {
            if (sbr.Q[ch][m][l] < 0 || sbr.Q[ch][m][l] > 30) {
                return 0;
            } else {
                return NoiseEnvelope.Q_div2_tab[sbr.Q[ch][m][l]];
            }
        }
    };
    constructor.dequantChannel = function(sbr, ch) {
        if (!sbr.bs_coupling) {
            var exp;
            var l, k;
            var amp = (sbr.amp_res[ch]) ? 0 : 1;
            for (l = 0; l < sbr.L_E[ch]; l++) {
                for (k = 0; k < sbr.n[sbr.f[ch][l]]; k++) {
                    exp = (sbr.E[ch][k][l] >> amp);
                    if ((exp < 0) || (exp >= 64)) {
                        sbr.E_orig[ch][k][l] = 0;
                    } else {
                        sbr.E_orig[ch][k][l] = NoiseEnvelope.E_deq_tab[exp];
                        if (amp != 0 && (sbr.E[ch][k][l] & 1) != 0) {
                            sbr.E_orig[ch][k][l] = (sbr.E_orig[ch][k][l] * 1.4142135);
                        }
                    }
                }
            }
            for (l = 0; l < sbr.L_Q[ch]; l++) {
                for (k = 0; k < sbr.N_Q; k++) {
                    sbr.Q_div[ch][k][l] = NoiseEnvelope.calc_Q_div(sbr, ch, k, l);
                    sbr.Q_div2[ch][k][l] = NoiseEnvelope.calc_Q_div2(sbr, ch, k, l);
                }
            }
        }
    };
    constructor.E_pan_tab = new Float32Array([2.44081E-4, 4.88043E-4, 9.7561E-4, 0.00194932, 0.00389105, 0.00775194, 0.0153846, 0.030303, 0.0588235, 0.111111, 0.2, 0.333333, 0.5, 0.666667, 0.8, 0.888889, 0.941176, 0.969697, 0.984615, 0.992248, 0.996109, 0.998051, 0.999024, 0.999512, 0.999756]);
    constructor.unmap = function(sbr) {
        var tmp;
        var exp0, exp1;
        var l, k;
        var amp0 = (sbr.amp_res[0]) ? 0 : 1;
        var amp1 = (sbr.amp_res[1]) ? 0 : 1;
        for (l = 0; l < sbr.L_E[0]; l++) {
            for (k = 0; k < sbr.n[sbr.f[0][l]]; k++) {
                exp0 = (sbr.E[0][k][l] >> amp0) + 1;
                exp1 = (sbr.E[1][k][l] >> amp1);
                if ((exp0 < 0) || (exp0 >= 64) || (exp1 < 0) || (exp1 > 24)) {
                    sbr.E_orig[1][k][l] = 0;
                    sbr.E_orig[0][k][l] = 0;
                } else {
                    tmp = NoiseEnvelope.E_deq_tab[exp0];
                    if (amp0 != 0 && (sbr.E[0][k][l] & 1) != 0) {
                        tmp *= 1.414213562;
                    }
                    sbr.E_orig[0][k][l] = (tmp * NoiseEnvelope.E_pan_tab[exp1]);
                    sbr.E_orig[1][k][l] = (tmp * NoiseEnvelope.E_pan_tab[24 - exp1]);
                }
            }
        }
        for (l = 0; l < sbr.L_Q[0]; l++) {
            for (k = 0; k < sbr.N_Q; k++) {
                sbr.Q_div[0][k][l] = NoiseEnvelope.calc_Q_div(sbr, 0, k, l);
                sbr.Q_div[1][k][l] = NoiseEnvelope.calc_Q_div(sbr, 1, k, l);
                sbr.Q_div2[0][k][l] = NoiseEnvelope.calc_Q_div2(sbr, 0, k, l);
                sbr.Q_div2[1][k][l] = NoiseEnvelope.calc_Q_div2(sbr, 1, k, l);
            }
        }
    };
}, {E_deq_tab: "Float32Array", Q_div2_tab: "Float32Array", Q_div2_tab_left: "Array", Q_div2_tab_right: "Array", Q_div_tab: "Float32Array", Q_div_tab_left: "Array", Q_div_tab_right: "Array", E_pan_tab: "Float32Array", startMinTable: "Int32Array", offsetIndexTable: "Int32Array", OFFSET: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var FBT = function() {};
FBT = stjs.extend(FBT, null, [SBRConstants], function(constructor, prototype) {
    constructor.qmf_start_channel = function(bs_start_freq, bs_samplerate_mode, sample_rate) {
        var startMin = SBRConstants.startMinTable[sample_rate.getIndex()];
        var offsetIndex = SBRConstants.offsetIndexTable[sample_rate.getIndex()];
        if (bs_samplerate_mode != 0) {
            return startMin + SBRConstants.OFFSET[offsetIndex][bs_start_freq];
        } else {
            return startMin + SBRConstants.OFFSET[6][bs_start_freq];
        }
    };
    constructor.stopMinTable = new Int32Array([13, 15, 20, 21, 23, 32, 32, 35, 48, 64, 70, 96]);
    constructor.STOP_OFFSET_TABLE = [new Int32Array([0, 2, 4, 6, 8, 11, 14, 18, 22, 26, 31, 37, 44, 51]), new Int32Array([0, 2, 4, 6, 8, 11, 14, 18, 22, 26, 31, 36, 42, 49]), new Int32Array([0, 2, 4, 6, 8, 11, 14, 17, 21, 25, 29, 34, 39, 44]), new Int32Array([0, 2, 4, 6, 8, 11, 14, 17, 20, 24, 28, 33, 38, 43]), new Int32Array([0, 2, 4, 6, 8, 11, 14, 17, 20, 24, 28, 32, 36, 41]), new Int32Array([0, 2, 4, 6, 8, 10, 12, 14, 17, 20, 23, 26, 29, 32]), new Int32Array([0, 2, 4, 6, 8, 10, 12, 14, 17, 20, 23, 26, 29, 32]), new Int32Array([0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 20, 23, 26, 29]), new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16]), new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Int32Array([0, -1, -2, -3, -4, -5, -6, -6, -6, -6, -6, -6, -6, -6]), new Int32Array([0, -3, -6, -9, -12, -15, -18, -20, -22, -24, -26, -28, -30, -32])];
    constructor.qmf_stop_channel = function(bs_stop_freq, sample_rate, k0) {
        if (bs_stop_freq == 15) {
            return Math.min(64, k0 * 3);
        } else if (bs_stop_freq == 14) {
            return Math.min(64, k0 * 2);
        } else {
            var stopMin = FBT.stopMinTable[sample_rate.getIndex()];
            return Math.min(64, stopMin + FBT.STOP_OFFSET_TABLE[sample_rate.getIndex()][Math.min(bs_stop_freq, 13)]);
        }
    };
    constructor.master_frequency_table_fs0 = function(sbr, k0, k2, bs_alter_scale) {
        var incr;
        var k;
        var dk;
        var nrBands, k2Achieved;
        var k2Diff;
        var vDk = new Int32Array(64);
        if (k2 <= k0) {
            sbr.N_master = 0;
            return 1;
        }
        dk = bs_alter_scale ? 2 : 1;
        if (bs_alter_scale) {
            nrBands = (((k2 - k0 + 2) >> 2) << 1);
        } else {
            nrBands = (((k2 - k0) >> 1) << 1);
        }
        nrBands = Math.min(nrBands, 63);
        if (nrBands <= 0) 
            return 1;
        k2Achieved = k0 + nrBands * dk;
        k2Diff = k2 - k2Achieved;
        for (k = 0; k < nrBands; k++) {
            vDk[k] = dk;
        }
        if (k2Diff != 0) {
            incr = (k2Diff > 0) ? -1 : 1;
            k = ((k2Diff > 0) ? (nrBands - 1) : 0);
             while (k2Diff != 0){
                vDk[k] -= incr;
                k += incr;
                k2Diff += incr;
            }
        }
        sbr.f_master[0] = k0;
        for (k = 1; k <= nrBands; k++) {
            sbr.f_master[k] = (sbr.f_master[k - 1] + vDk[k - 1]);
        }
        sbr.N_master = nrBands;
        sbr.N_master = Math.min(sbr.N_master, 64);
        return 0;
    };
    constructor.find_bands = function(warp, bands, a0, a1) {
        var div = Math.log(2.0);
        if (warp != 0) 
            div *= 1.3;
        return stjs.trunc((bands * Math.log(a1 / a0) / div + 0.5));
    };
    constructor.find_initial_power = function(bands, a0, a1) {
        return Math.pow(a1 / a0, 1.0 / bands);
    };
    constructor.master_frequency_table = function(sbr, k0, k2, bs_freq_scale, bs_alter_scale) {
        var k, bands;
        var twoRegions;
        var k1;
        var nrBand0, nrBand1;
        var vDk0 = new Int32Array(64), vDk1 = new Int32Array(64);
        var vk0 = new Int32Array(64), vk1 = new Int32Array(64);
        var temp1 = new Int32Array([6, 5, 4]);
        var q, qk;
        var A_1;
        if (k2 <= k0) {
            sbr.N_master = 0;
            return 1;
        }
        bands = temp1[bs_freq_scale - 1];
        if (k2 / k0 > 2.2449) {
            twoRegions = true;
            k1 = k0 << 1;
        } else {
            twoRegions = false;
            k1 = k2;
        }
        nrBand0 = (2 * FBT.find_bands(0, bands, k0, k1));
        nrBand0 = Math.min(nrBand0, 63);
        if (nrBand0 <= 0) 
            return 1;
        q = FBT.find_initial_power(nrBand0, k0, k1);
        qk = k0;
        A_1 = stjs.trunc((qk + 0.5));
        for (k = 0; k <= nrBand0; k++) {
            var A_0 = A_1;
            qk *= q;
            A_1 = stjs.trunc((qk + 0.5));
            vDk0[k] = A_1 - A_0;
        }
        Arrays.sort(vDk0, 0, nrBand0);
        vk0[0] = k0;
        for (k = 1; k <= nrBand0; k++) {
            vk0[k] = vk0[k - 1] + vDk0[k - 1];
            if (vDk0[k - 1] == 0) 
                return 1;
        }
        if (!twoRegions) {
            for (k = 0; k <= nrBand0; k++) {
                sbr.f_master[k] = vk0[k];
            }
            sbr.N_master = nrBand0;
            sbr.N_master = Math.min(sbr.N_master, 64);
            return 0;
        }
        nrBand1 = (2 * FBT.find_bands(1, bands, k1, k2));
        nrBand1 = Math.min(nrBand1, 63);
        q = FBT.find_initial_power(nrBand1, k1, k2);
        qk = k1;
        A_1 = stjs.trunc((qk + 0.5));
        for (k = 0; k <= nrBand1 - 1; k++) {
            var A_0 = A_1;
            qk *= q;
            A_1 = stjs.trunc((qk + 0.5));
            vDk1[k] = A_1 - A_0;
        }
        if (vDk1[0] < vDk0[nrBand0 - 1]) {
            var change;
            Arrays.sort(vDk1, 0, nrBand1 + 1);
            change = vDk0[nrBand0 - 1] - vDk1[0];
            vDk1[0] = vDk0[nrBand0 - 1];
            vDk1[nrBand1 - 1] = vDk1[nrBand1 - 1] - change;
        }
        Arrays.sort(vDk1, 0, nrBand1);
        vk1[0] = k1;
        for (k = 1; k <= nrBand1; k++) {
            vk1[k] = vk1[k - 1] + vDk1[k - 1];
            if (vDk1[k - 1] == 0) 
                return 1;
        }
        sbr.N_master = nrBand0 + nrBand1;
        sbr.N_master = Math.min(sbr.N_master, 64);
        for (k = 0; k <= nrBand0; k++) {
            sbr.f_master[k] = vk0[k];
        }
        for (k = nrBand0 + 1; k <= sbr.N_master; k++) {
            sbr.f_master[k] = vk1[k - nrBand0];
        }
        return 0;
    };
    constructor.derived_frequency_table = function(sbr, bs_xover_band, k2) {
        var k, i = 0;
        var minus;
        if (sbr.N_master <= bs_xover_band) 
            return 1;
        sbr.N_high = sbr.N_master - bs_xover_band;
        sbr.N_low = (sbr.N_high >> 1) + (sbr.N_high - ((sbr.N_high >> 1) << 1));
        sbr.n[0] = sbr.N_low;
        sbr.n[1] = sbr.N_high;
        for (k = 0; k <= sbr.N_high; k++) {
            sbr.f_table_res[SBRConstants.HI_RES][k] = sbr.f_master[k + bs_xover_band];
        }
        sbr.M = sbr.f_table_res[SBRConstants.HI_RES][sbr.N_high] - sbr.f_table_res[SBRConstants.HI_RES][0];
        sbr.kx = sbr.f_table_res[SBRConstants.HI_RES][0];
        if (sbr.kx > 32) 
            return 1;
        if (sbr.kx + sbr.M > 64) 
            return 1;
        minus = ((sbr.N_high & 1) != 0) ? 1 : 0;
        for (k = 0; k <= sbr.N_low; k++) {
            if (k == 0) 
                i = 0;
             else 
                i = (2 * k - minus);
            sbr.f_table_res[SBRConstants.LO_RES][k] = sbr.f_table_res[SBRConstants.HI_RES][i];
        }
        sbr.N_Q = 0;
        if (sbr.bs_noise_bands == 0) {
            sbr.N_Q = 1;
        } else {
            sbr.N_Q = (Math.max(1, FBT.find_bands(0, sbr.bs_noise_bands, sbr.kx, k2)));
            sbr.N_Q = Math.min(5, sbr.N_Q);
        }
        for (k = 0; k <= sbr.N_Q; k++) {
            if (k == 0) {
                i = 0;
            } else {
                i += stjs.trunc((sbr.N_low - i) / (sbr.N_Q + 1 - k));
            }
            sbr.f_table_noise[k] = sbr.f_table_res[SBRConstants.LO_RES][i];
        }
        for (k = 0; k < 64; k++) {
            var g;
            for (g = 0; g < sbr.N_Q; g++) {
                if ((sbr.f_table_noise[g] <= k) && (k < sbr.f_table_noise[g + 1])) {
                    sbr.table_map_k_to_g[k] = g;
                    break;
                }
            }
        }
        return 0;
    };
    constructor.limiterBandsCompare = new Float32Array([1.327152, 1.185093, 1.119872]);
    constructor.limiter_frequency_table = function(sbr) {
        var k, s;
        var nrLim;
        sbr.f_table_lim[0][0] = sbr.f_table_res[SBRConstants.LO_RES][0] - sbr.kx;
        sbr.f_table_lim[0][1] = sbr.f_table_res[SBRConstants.LO_RES][sbr.N_low] - sbr.kx;
        sbr.N_L[0] = 1;
        for (s = 1; s < 4; s++) {
            var limTable = new Int32Array(100);
            var patchBorders = new Int32Array(64);
            patchBorders[0] = sbr.kx;
            for (k = 1; k <= sbr.noPatches; k++) {
                patchBorders[k] = patchBorders[k - 1] + sbr.patchNoSubbands[k - 1];
            }
            for (k = 0; k <= sbr.N_low; k++) {
                limTable[k] = sbr.f_table_res[SBRConstants.LO_RES][k];
            }
            for (k = 1; k < sbr.noPatches; k++) {
                limTable[k + sbr.N_low] = patchBorders[k];
            }
            Arrays.sort(limTable, 0, sbr.noPatches + sbr.N_low);
            k = 1;
            nrLim = sbr.noPatches + sbr.N_low - 1;
            if (nrLim < 0) 
                return;
            restart:
                 while (k <= nrLim){
                    var nOctaves;
                    if (limTable[k - 1] != 0) 
                        nOctaves = limTable[k] / limTable[k - 1];
                     else 
                        nOctaves = 0;
                    if (nOctaves < FBT.limiterBandsCompare[s - 1]) {
                        var i;
                        if (limTable[k] != limTable[k - 1]) {
                            var found = false, found2 = false;
                            for (i = 0; i <= sbr.noPatches; i++) {
                                if (limTable[k] == patchBorders[i]) 
                                    found = true;
                            }
                            if (found) {
                                found2 = false;
                                for (i = 0; i <= sbr.noPatches; i++) {
                                    if (limTable[k - 1] == patchBorders[i]) 
                                        found2 = true;
                                }
                                if (found2) {
                                    k++;
                                    continue;
                                } else {
                                    limTable[k - 1] = sbr.f_table_res[SBRConstants.LO_RES][sbr.N_low];
                                    Arrays.sort(limTable, 0, sbr.noPatches + sbr.N_low);
                                    nrLim--;
                                    continue;
                                }
                            }
                        }
                        limTable[k] = sbr.f_table_res[SBRConstants.LO_RES][sbr.N_low];
                        Arrays.sort(limTable, 0, nrLim);
                        nrLim--;
                    } else {
                        k++;
                    }
                }
            sbr.N_L[s] = nrLim;
            for (k = 0; k <= nrLim; k++) {
                sbr.f_table_lim[s][k] = limTable[k] - sbr.kx;
            }
        }
    };
}, {stopMinTable: "Int32Array", STOP_OFFSET_TABLE: "Array", limiterBandsCompare: "Float32Array", startMinTable: "Int32Array", offsetIndexTable: "Int32Array", OFFSET: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Intensity stereo
 *  @author in-somnia
 */
var IS = function() {};
IS = stjs.extend(IS, null, [SyntaxConstants, ISScaleTable, HCB], function(constructor, prototype) {
    constructor.process = function(cpe, specL, specR) {
        var ics = cpe.getRightChannel();
        var info = ics.getInfo();
        var offsets = info.getSWBOffsets();
        var windowGroups = info.getWindowGroupCount();
        var maxSFB = info.getMaxSFB();
        var sfbCB = ics.getSfbCB();
        var sectEnd = ics.getSectEnd();
        var scaleFactors = ics.getScaleFactors();
        var w, i, j, c, end, off;
        var idx = 0, groupOff = 0;
        var scale;
        for (var g = 0; g < windowGroups; g++) {
            for (i = 0; i < maxSFB; ) {
                if (sfbCB[idx] == HCB.INTENSITY_HCB || sfbCB[idx] == HCB.INTENSITY_HCB2) {
                    end = sectEnd[idx];
                    for (; i < end; i++ , idx++) {
                        c = sfbCB[idx] == HCB.INTENSITY_HCB ? 1 : -1;
                        if (cpe.isMSMaskPresent()) 
                            c *= cpe.isMSUsed(idx) ? -1 : 1;
                        scale = c * scaleFactors[idx];
                        for (w = 0; w < info.getWindowGroupLength(g); w++) {
                            off = groupOff + w * 128 + offsets[i];
                            for (j = 0; j < offsets[i + 1] - offsets[i]; j++) {
                                specR[off + j] = specL[off + j] * scale;
                            }
                        }
                    }
                } else {
                    end = sectEnd[idx];
                    idx += end - i;
                    i = end;
                }
            }
            groupOff += info.getWindowGroupLength(g) * 128;
        }
    };
}, {SCALE_TABLE: "Float32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var IPQF = function() {
    this.buf = new Float32Array(GCConstants.BANDS);
    this.tmp1 = Array.apply(null, Array(stjs.trunc(GCConstants.BANDS / 2))).map(function() {
        return new Float32Array(stjs.trunc(GCConstants.NPQFTAPS / GCConstants.BANDS));
    });
    this.tmp2 = Array.apply(null, Array(stjs.trunc(GCConstants.BANDS / 2))).map(function() {
        return new Float32Array(stjs.trunc(GCConstants.NPQFTAPS / GCConstants.BANDS));
    });
};
IPQF = stjs.extend(IPQF, null, [GCConstants, PQFTables], function(constructor, prototype) {
    prototype.buf = null;
    prototype.tmp1 = null;
    prototype.tmp2 = null;
    prototype.process = function(_in, frameLen, maxBand, out) {
        var i, j;
        for (i = 0; i < frameLen; i++) {
            out[i] = 0.0;
        }
        for (i = 0; i < stjs.trunc(frameLen / GCConstants.BANDS); i++) {
            for (j = 0; j < GCConstants.BANDS; j++) {
                this.buf[j] = _in[j][i];
            }
            this.performSynthesis(this.buf, out, i * GCConstants.BANDS);
        }
    };
    prototype.performSynthesis = function(_in, out, outOff) {
        var kk = stjs.trunc(GCConstants.NPQFTAPS / (2 * GCConstants.BANDS));
        var i, n, k;
        var acc;
        for (n = 0; n < stjs.trunc(GCConstants.BANDS / 2); ++n) {
            for (k = 0; k < 2 * kk - 1; ++k) {
                this.tmp1[n][k] = this.tmp1[n][k + 1];
                this.tmp2[n][k] = this.tmp2[n][k + 1];
            }
        }
        for (n = 0; n < stjs.trunc(GCConstants.BANDS / 2); ++n) {
            acc = 0.0;
            for (i = 0; i < GCConstants.BANDS; ++i) {
                acc += PQFTables.COEFS_Q0[n][i] * _in[i];
            }
            this.tmp1[n][2 * kk - 1] = acc;
            acc = 0.0;
            for (i = 0; i < GCConstants.BANDS; ++i) {
                acc += PQFTables.COEFS_Q1[n][i] * _in[i];
            }
            this.tmp2[n][2 * kk - 1] = acc;
        }
        for (n = 0; n < stjs.trunc(GCConstants.BANDS / 2); ++n) {
            acc = 0.0;
            for (k = 0; k < kk; ++k) {
                acc += PQFTables.COEFS_T0[n][k] * this.tmp1[n][2 * kk - 1 - 2 * k];
            }
            for (k = 0; k < kk; ++k) {
                acc += PQFTables.COEFS_T1[n][k] * this.tmp2[n][2 * kk - 2 - 2 * k];
            }
            out[outOff + n] = acc;
            acc = 0.0;
            for (k = 0; k < kk; ++k) {
                acc += PQFTables.COEFS_T0[GCConstants.BANDS - 1 - n][k] * this.tmp1[n][2 * kk - 1 - 2 * k];
            }
            for (k = 0; k < kk; ++k) {
                acc -= PQFTables.COEFS_T1[GCConstants.BANDS - 1 - n][k] * this.tmp2[n][2 * kk - 2 - 2 * k];
            }
            out[outOff + GCConstants.BANDS - 1 - n] = acc;
        }
    };
}, {buf: "Float32Array", tmp1: "Array", tmp2: "Array", LN_GAIN: "Int32Array", PROTO_TABLE: "Float32Array", COEFS_Q0: "Array", COEFS_Q1: "Array", COEFS_T0: "Array", COEFS_T1: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Reversable variable length coding
 *  Decodes scalefactors if error resilience is used.
 *  
 *  @author in-somnia
 */
var RVLC = function() {};
RVLC = stjs.extend(RVLC, null, [RVLCTables], function(constructor, prototype) {
    constructor.ESCAPE_FLAG = 7;
    prototype.decode = function(_in, ics, scaleFactors) {
        var bits = (ics.getInfo().isEightShortFrame()) ? 11 : 9;
        var sfConcealment = _in.readBool();
        var revGlobalGain = _in.readBits(8);
        var rvlcSFLen = _in.readBits(bits);
        var info = ics.getInfo();
        var windowGroupCount = info.getWindowGroupCount();
        var maxSFB = info.getMaxSFB();
        var sfbCB = [new Int32Array()];
        var sf = ics.getGlobalGain();
        var intensityPosition = 0;
        var noiseEnergy = sf - 90 - 256;
        var intensityUsed = false, noiseUsed = false;
        var sfb;
        for (var g = 0; g < windowGroupCount; g++) {
            for (sfb = 0; sfb < maxSFB; sfb++) {
                switch (sfbCB[g][sfb]) {
                    case HCB.ZERO_HCB:
                        scaleFactors[g][sfb] = 0;
                        break;
                    case HCB.INTENSITY_HCB:
                    case HCB.INTENSITY_HCB2:
                        if (!intensityUsed) 
                            intensityUsed = true;
                        intensityPosition += this.decodeHuffman(_in);
                        scaleFactors[g][sfb] = intensityPosition;
                        break;
                    case HCB.NOISE_HCB:
                        if (noiseUsed) {
                            noiseEnergy += this.decodeHuffman(_in);
                            scaleFactors[g][sfb] = noiseEnergy;
                        } else {
                            noiseUsed = true;
                            noiseEnergy = this.decodeHuffman(_in);
                        }
                        break;
                    default:
                        sf += this.decodeHuffman(_in);
                        scaleFactors[g][sfb] = sf;
                        break;
                }
            }
        }
        var lastIntensityPosition = 0;
        if (intensityUsed) 
            lastIntensityPosition = this.decodeHuffman(_in);
        noiseUsed = false;
        if (_in.readBool()) 
            this.decodeEscapes(_in, ics, scaleFactors);
    };
    prototype.decodeEscapes = function(_in, ics, scaleFactors) {
        var info = ics.getInfo();
        var windowGroupCount = info.getWindowGroupCount();
        var maxSFB = info.getMaxSFB();
        var sfbCB = [new Int32Array()];
        var escapesLen = _in.readBits(8);
        var noiseUsed = false;
        var sfb, val;
        for (var g = 0; g < windowGroupCount; g++) {
            for (sfb = 0; sfb < maxSFB; sfb++) {
                if (sfbCB[g][sfb] == HCB.NOISE_HCB && !noiseUsed) 
                    noiseUsed = true;
                 else if (Math.abs(sfbCB[g][sfb]) == RVLC.ESCAPE_FLAG) {
                    val = this.decodeHuffmanEscape(_in);
                    if (sfbCB[g][sfb] == -RVLC.ESCAPE_FLAG) 
                        scaleFactors[g][sfb] -= val;
                     else 
                        scaleFactors[g][sfb] += val;
                }
            }
        }
    };
    prototype.decodeHuffman = function(_in) {
        var off = 0;
        var i = RVLCTables.RVLC_BOOK[off][1];
        var cw = _in.readBits(i);
        var j;
         while ((cw != RVLCTables.RVLC_BOOK[off][2]) && (i < 10)){
            off++;
            j = RVLCTables.RVLC_BOOK[off][1] - i;
            i += j;
            cw <<= j;
            cw |= _in.readBits(j);
        }
        return RVLCTables.RVLC_BOOK[off][0];
    };
    prototype.decodeHuffmanEscape = function(_in) {
        var off = 0;
        var i = RVLCTables.ESCAPE_BOOK[off][1];
        var cw = _in.readBits(i);
        var j;
         while ((cw != RVLCTables.ESCAPE_BOOK[off][2]) && (i < 21)){
            off++;
            j = RVLCTables.ESCAPE_BOOK[off][1] - i;
            i += j;
            cw <<= j;
            cw |= _in.readBits(j);
        }
        return RVLCTables.ESCAPE_BOOK[off][0];
    };
}, {RVLC_BOOK: "Array", ESCAPE_BOOK: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PriorityCallable = function() {};
PriorityCallable = stjs.extend(PriorityCallable, null, [Callable], function(constructor, prototype) {
    prototype.getPriority = function() {};
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var HFAdjustment = function() {
    this.G_lim_boost = Array.apply(null, Array(SBRConstants.MAX_L_E)).map(function() {
        return new Float32Array(SBRConstants.MAX_M);
    });
    this.Q_M_lim_boost = Array.apply(null, Array(SBRConstants.MAX_L_E)).map(function() {
        return new Float32Array(SBRConstants.MAX_M);
    });
    this.S_M_boost = Array.apply(null, Array(SBRConstants.MAX_L_E)).map(function() {
        return new Float32Array(SBRConstants.MAX_M);
    });
};
HFAdjustment = stjs.extend(HFAdjustment, null, [SBRConstants, NoiseTable], function(constructor, prototype) {
    constructor.h_smooth = new Float32Array([0.0318305, 0.11516383, 0.2181695, 0.30150282, 0.33333334]);
    constructor.phi_re = new Int32Array([1, 0, -1, 0]);
    constructor.phi_im = new Int32Array([0, 1, 0, -1]);
    constructor.limGain = new Float32Array([0.5, 1.0, 2.0, 1.0E10]);
    constructor.EPS = 1.0E-12;
    prototype.G_lim_boost = null;
    prototype.Q_M_lim_boost = null;
    prototype.S_M_boost = null;
    constructor.hf_adjustment = function(sbr, Xsbr, ch) {
        var adj = new HFAdjustment();
        var ret = 0;
        if (sbr.bs_frame_class[ch] == SBRConstants.FIXFIX) {
            sbr.l_A[ch] = -1;
        } else if (sbr.bs_frame_class[ch] == SBRConstants.VARFIX) {
            if (sbr.bs_pointer[ch] > 1) 
                sbr.l_A[ch] = sbr.bs_pointer[ch] - 1;
             else 
                sbr.l_A[ch] = -1;
        } else {
            if (sbr.bs_pointer[ch] == 0) 
                sbr.l_A[ch] = -1;
             else 
                sbr.l_A[ch] = sbr.L_E[ch] + 1 - sbr.bs_pointer[ch];
        }
        ret = HFAdjustment.estimate_current_envelope(sbr, adj, Xsbr, ch);
        if (ret > 0) 
            return 1;
        HFAdjustment.calculate_gain(sbr, adj, ch);
        HFAdjustment.hf_assembly(sbr, adj, Xsbr, ch);
        return 0;
    };
    constructor.get_S_mapped = function(sbr, ch, l, current_band) {
        if (sbr.f[ch][l] == SBRConstants.HI_RES) {
            if ((l >= sbr.l_A[ch]) || (sbr.bs_add_harmonic_prev[ch][current_band] != 0 && sbr.bs_add_harmonic_flag_prev[ch])) {
                return sbr.bs_add_harmonic[ch][current_band];
            }
        } else {
            var b, lb, ub;
            lb = 2 * current_band - ((sbr.N_high & 1) != 0 ? 1 : 0);
            ub = 2 * (current_band + 1) - ((sbr.N_high & 1) != 0 ? 1 : 0);
            for (b = lb; b < ub; b++) {
                if ((l >= sbr.l_A[ch]) || (sbr.bs_add_harmonic_prev[ch][b] != 0 && sbr.bs_add_harmonic_flag_prev[ch])) {
                    if (sbr.bs_add_harmonic[ch][b] == 1) 
                        return 1;
                }
            }
        }
        return 0;
    };
    constructor.estimate_current_envelope = function(sbr, adj, Xsbr, ch) {
        var m, l, j, k, k_l, k_h, p;
        var nrg, div;
        if (sbr.bs_interpol_freq) {
            for (l = 0; l < sbr.L_E[ch]; l++) {
                var i, l_i, u_i;
                l_i = sbr.t_E[ch][l];
                u_i = sbr.t_E[ch][l + 1];
                div = (u_i - l_i);
                if (div == 0) 
                    div = 1;
                for (m = 0; m < sbr.M; m++) {
                    nrg = 0;
                    for (i = l_i + sbr.tHFAdj; i < u_i + sbr.tHFAdj; i++) {
                        nrg += (Xsbr[i][m + sbr.kx][0] * Xsbr[i][m + sbr.kx][0]) + (Xsbr[i][m + sbr.kx][1] * Xsbr[i][m + sbr.kx][1]);
                    }
                    sbr.E_curr[ch][m][l] = nrg / div;
                }
            }
        } else {
            for (l = 0; l < sbr.L_E[ch]; l++) {
                for (p = 0; p < sbr.n[sbr.f[ch][l]]; p++) {
                    k_l = sbr.f_table_res[sbr.f[ch][l]][p];
                    k_h = sbr.f_table_res[sbr.f[ch][l]][p + 1];
                    for (k = k_l; k < k_h; k++) {
                        var i, l_i, u_i;
                        nrg = 0;
                        l_i = sbr.t_E[ch][l];
                        u_i = sbr.t_E[ch][l + 1];
                        div = ((u_i - l_i) * (k_h - k_l));
                        if (div == 0) 
                            div = 1;
                        for (i = l_i + sbr.tHFAdj; i < u_i + sbr.tHFAdj; i++) {
                            for (j = k_l; j < k_h; j++) {
                                nrg += (Xsbr[i][j][0] * Xsbr[i][j][0]) + (Xsbr[i][j][1] * Xsbr[i][j][1]);
                            }
                        }
                        sbr.E_curr[ch][k - sbr.kx][l] = nrg / div;
                    }
                }
            }
        }
        return 0;
    };
    constructor.hf_assembly = function(sbr, adj, Xsbr, ch) {
        var m, l, i, n;
        var fIndexNoise = 0;
        var fIndexSine = 0;
        var assembly_reset = false;
        var G_filt, Q_filt;
        var h_SL;
        if (sbr.Reset) {
            assembly_reset = true;
            fIndexNoise = 0;
        } else {
            fIndexNoise = sbr.index_noise_prev[ch];
        }
        fIndexSine = sbr.psi_is_prev[ch];
        for (l = 0; l < sbr.L_E[ch]; l++) {
            var no_noise = (l == sbr.l_A[ch] || l == sbr.prevEnvIsShort[ch]);
            h_SL = (sbr.bs_smoothing_mode) ? 0 : 4;
            h_SL = (no_noise ? 0 : h_SL);
            if (assembly_reset) {
                for (n = 0; n < 4; n++) {
                    System.arraycopy(adj.G_lim_boost[l], 0, sbr.G_temp_prev[ch][n], 0, sbr.M);
                    System.arraycopy(adj.Q_M_lim_boost[l], 0, sbr.Q_temp_prev[ch][n], 0, sbr.M);
                }
                sbr.GQ_ringbuf_index[ch] = 4;
                assembly_reset = false;
            }
            for (i = sbr.t_E[ch][l]; i < sbr.t_E[ch][l + 1]; i++) {
                System.arraycopy(adj.G_lim_boost[l], 0, sbr.G_temp_prev[ch][sbr.GQ_ringbuf_index[ch]], 0, sbr.M);
                System.arraycopy(adj.Q_M_lim_boost[l], 0, sbr.Q_temp_prev[ch][sbr.GQ_ringbuf_index[ch]], 0, sbr.M);
                for (m = 0; m < sbr.M; m++) {
                    var psi = new Float32Array(2);
                    G_filt = 0;
                    Q_filt = 0;
                    if (h_SL != 0) {
                        var ri = sbr.GQ_ringbuf_index[ch];
                        for (n = 0; n <= 4; n++) {
                            var curr_h_smooth = HFAdjustment.h_smooth[n];
                            ri++;
                            if (ri >= 5) 
                                ri -= 5;
                            G_filt += (sbr.G_temp_prev[ch][ri][m] * curr_h_smooth);
                            Q_filt += (sbr.Q_temp_prev[ch][ri][m] * curr_h_smooth);
                        }
                    } else {
                        G_filt = sbr.G_temp_prev[ch][sbr.GQ_ringbuf_index[ch]][m];
                        Q_filt = sbr.Q_temp_prev[ch][sbr.GQ_ringbuf_index[ch]][m];
                    }
                    Q_filt = (adj.S_M_boost[l][m] != 0 || no_noise) ? 0 : Q_filt;
                    fIndexNoise = (fIndexNoise + 1) & 511;
                    Xsbr[i + sbr.tHFAdj][m + sbr.kx][0] = G_filt * Xsbr[i + sbr.tHFAdj][m + sbr.kx][0] + (Q_filt * NoiseTable.NOISE_TABLE[fIndexNoise][0]);
                    if (sbr.bs_extension_id == 3 && sbr.bs_extension_data == 42) 
                        Xsbr[i + sbr.tHFAdj][m + sbr.kx][0] = 16428320;
                    Xsbr[i + sbr.tHFAdj][m + sbr.kx][1] = G_filt * Xsbr[i + sbr.tHFAdj][m + sbr.kx][1] + (Q_filt * NoiseTable.NOISE_TABLE[fIndexNoise][1]);
                    {
                        var rev = (((m + sbr.kx) & 1) != 0 ? -1 : 1);
                        psi[0] = adj.S_M_boost[l][m] * HFAdjustment.phi_re[fIndexSine];
                        Xsbr[i + sbr.tHFAdj][m + sbr.kx][0] += psi[0];
                        psi[1] = rev * adj.S_M_boost[l][m] * HFAdjustment.phi_im[fIndexSine];
                        Xsbr[i + sbr.tHFAdj][m + sbr.kx][1] += psi[1];
                    }}
                fIndexSine = (fIndexSine + 1) & 3;
                sbr.GQ_ringbuf_index[ch]++;
                if (sbr.GQ_ringbuf_index[ch] >= 5) 
                    sbr.GQ_ringbuf_index[ch] = 0;
            }
        }
        sbr.index_noise_prev[ch] = fIndexNoise;
        sbr.psi_is_prev[ch] = fIndexSine;
    };
    constructor.calculate_gain = function(sbr, adj, ch) {
        var m, l, k;
        var current_t_noise_band = 0;
        var S_mapped;
        var Q_M_lim = new Float32Array(SBRConstants.MAX_M);
        var G_lim = new Float32Array(SBRConstants.MAX_M);
        var G_boost;
        var S_M = new Float32Array(SBRConstants.MAX_M);
        for (l = 0; l < sbr.L_E[ch]; l++) {
            var current_f_noise_band = 0;
            var current_res_band = 0;
            var current_res_band2 = 0;
            var current_hi_res_band = 0;
            var delta = (l == sbr.l_A[ch] || l == sbr.prevEnvIsShort[ch]) ? 0 : 1;
            S_mapped = HFAdjustment.get_S_mapped(sbr, ch, l, current_res_band2);
            if (sbr.t_E[ch][l + 1] > sbr.t_Q[ch][current_t_noise_band + 1]) {
                current_t_noise_band++;
            }
            for (k = 0; k < sbr.N_L[sbr.bs_limiter_bands]; k++) {
                var G_max;
                var den = 0;
                var acc1 = 0;
                var acc2 = 0;
                var current_res_band_size = 0;
                var ml1, ml2;
                ml1 = sbr.f_table_lim[sbr.bs_limiter_bands][k];
                ml2 = sbr.f_table_lim[sbr.bs_limiter_bands][k + 1];
                for (m = ml1; m < ml2; m++) {
                    if ((m + sbr.kx) == sbr.f_table_res[sbr.f[ch][l]][current_res_band + 1]) {
                        current_res_band++;
                    }
                    acc1 += sbr.E_orig[ch][current_res_band][l];
                    acc2 += sbr.E_curr[ch][m][l];
                }
                G_max = ((HFAdjustment.EPS + acc1) / (HFAdjustment.EPS + acc2)) * HFAdjustment.limGain[sbr.bs_limiter_gains];
                G_max = Math.min(G_max, 1.0E10);
                for (m = ml1; m < ml2; m++) {
                    var Q_M, G;
                    var Q_div, Q_div2;
                    var S_index_mapped;
                    if ((m + sbr.kx) == sbr.f_table_noise[current_f_noise_band + 1]) {
                        current_f_noise_band++;
                    }
                    if ((m + sbr.kx) == sbr.f_table_res[sbr.f[ch][l]][current_res_band2 + 1]) {
                        current_res_band2++;
                        S_mapped = HFAdjustment.get_S_mapped(sbr, ch, l, current_res_band2);
                    }
                    if ((m + sbr.kx) == sbr.f_table_res[SBRConstants.HI_RES][current_hi_res_band + 1]) {
                        current_hi_res_band++;
                    }
                    S_index_mapped = 0;
                    if ((l >= sbr.l_A[ch]) || (sbr.bs_add_harmonic_prev[ch][current_hi_res_band] != 0 && sbr.bs_add_harmonic_flag_prev[ch])) {
                        if ((m + sbr.kx) == (sbr.f_table_res[SBRConstants.HI_RES][current_hi_res_band + 1] + sbr.f_table_res[SBRConstants.HI_RES][current_hi_res_band]) >> 1) 
                            S_index_mapped = sbr.bs_add_harmonic[ch][current_hi_res_band];
                    }
                    Q_div = sbr.Q_div[ch][current_f_noise_band][current_t_noise_band];
                    Q_div2 = sbr.Q_div2[ch][current_f_noise_band][current_t_noise_band];
                    Q_M = sbr.E_orig[ch][current_res_band2][l] * Q_div2;
                    if (S_index_mapped == 0) {
                        S_M[m] = 0;
                    } else {
                        S_M[m] = sbr.E_orig[ch][current_res_band2][l] * Q_div;
                        den += S_M[m];
                    }
                    G = sbr.E_orig[ch][current_res_band2][l] / (1.0 + sbr.E_curr[ch][m][l]);
                    if ((S_mapped == 0) && (delta == 1)) 
                        G *= Q_div;
                     else if (S_mapped == 1) 
                        G *= Q_div2;
                    if (G_max > G) {
                        Q_M_lim[m] = Q_M;
                        G_lim[m] = G;
                    } else {
                        Q_M_lim[m] = Q_M * G_max / G;
                        G_lim[m] = G_max;
                    }
                    den += sbr.E_curr[ch][m][l] * G_lim[m];
                    if ((S_index_mapped == 0) && (l != sbr.l_A[ch])) 
                        den += Q_M_lim[m];
                }
                G_boost = (acc1 + HFAdjustment.EPS) / (den + HFAdjustment.EPS);
                G_boost = Math.min(G_boost, 2.5118864);
                for (m = ml1; m < ml2; m++) {
                    adj.G_lim_boost[l][m] = Math.sqrt(G_lim[m] * G_boost);
                    adj.Q_M_lim_boost[l][m] = Math.sqrt(Q_M_lim[m] * G_boost);
                    if (S_M[m] != 0) {
                        adj.S_M_boost[l][m] = Math.sqrt(S_M[m] * G_boost);
                    } else {
                        adj.S_M_boost[l][m] = 0;
                    }
                }
            }
        }
    };
}, {h_smooth: "Float32Array", phi_re: "Int32Array", phi_im: "Int32Array", limGain: "Float32Array", G_lim_boost: "Array", Q_M_lim_boost: "Array", S_M_boost: "Array", startMinTable: "Int32Array", offsetIndexTable: "Int32Array", OFFSET: "Array", NOISE_TABLE: "Array"}, {});
var CropFilter = function() {};
CropFilter = stjs.extend(CropFilter, null, [Filter], function(constructor, prototype) {
    prototype.filter = function(picture, store) {
        return null;
    };
    prototype.getInputColor = function() {
        return null;
    };
    prototype.getOutputColor = function() {
        return null;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Decode program configuration element; reference: table 4.2.
 *  
 *  @author The JCodec project
 *  
 */
var BlockPCE = function() {
    Block.call(this);
};
BlockPCE = stjs.extend(BlockPCE, Block, [], function(constructor, prototype) {
    constructor.MAX_ELEM_ID = 16;
    constructor.ChannelMapping = function() {};
    constructor.ChannelMapping = stjs.extend(constructor.ChannelMapping, null, [], function(constructor, prototype) {
        prototype.syn_ele = null;
        prototype.someInt = 0;
        prototype.position = null;
    }, {syn_ele: {name: "Enum", arguments: ["RawDataBlockType"]}, position: {name: "Enum", arguments: ["ChannelPosition"]}}, {});
    prototype.parse = function(_in) {
        _in.readNBit(2);
        var samplingIndex = stjs.trunc(_in.readNBit(4));
        var num_front = stjs.trunc(_in.readNBit(4));
        var num_side = stjs.trunc(_in.readNBit(4));
        var num_back = stjs.trunc(_in.readNBit(4));
        var num_lfe = stjs.trunc(_in.readNBit(2));
        var num_assoc_data = stjs.trunc(_in.readNBit(3));
        var num_cc = stjs.trunc(_in.readNBit(4));
        if (_in.read1Bit() != 0) 
            _in.readNBit(4);
        if (_in.read1Bit() != 0) 
            _in.readNBit(4);
        if (_in.read1Bit() != 0) 
            _in.readNBit(3);
        var layout_map = Array(BlockPCE.MAX_ELEM_ID * 4);
        var tags = 0;
        this.decodeChannelMap(layout_map, tags, ChannelPosition.AAC_CHANNEL_FRONT, _in, num_front);
        tags = num_front;
        this.decodeChannelMap(layout_map, tags, ChannelPosition.AAC_CHANNEL_SIDE, _in, num_side);
        tags += num_side;
        this.decodeChannelMap(layout_map, tags, ChannelPosition.AAC_CHANNEL_BACK, _in, num_back);
        tags += num_back;
        this.decodeChannelMap(layout_map, tags, ChannelPosition.AAC_CHANNEL_LFE, _in, num_lfe);
        tags += num_lfe;
        _in.skip(4 * num_assoc_data);
        this.decodeChannelMap(layout_map, tags, ChannelPosition.AAC_CHANNEL_CC, _in, num_cc);
        tags += num_cc;
        _in.align();
        var comment_len = stjs.trunc(_in.readNBit(8)) * 8;
        _in.skip(comment_len);
    };
    /**
     *  Decode an array of 4 bit element IDs, optionally interleaved with a
     *  stereo/mono switching bit.
     *  
     *  @throws IOException
     */
    prototype.decodeChannelMap = function(layout_map, offset, type, _in, n) {
         while (n-- > 0){
            var syn_ele = null;
            switch (type) {
                case ChannelPosition.AAC_CHANNEL_FRONT:
                case ChannelPosition.AAC_CHANNEL_BACK:
                case ChannelPosition.AAC_CHANNEL_SIDE:
                    syn_ele = RawDataBlockType.values()[_in.read1Bit()];
                    break;
                case ChannelPosition.AAC_CHANNEL_CC:
                    _in.read1Bit();
                    syn_ele = RawDataBlockType.TYPE_CCE;
                    break;
                case ChannelPosition.AAC_CHANNEL_LFE:
                    syn_ele = RawDataBlockType.TYPE_LFE;
                    break;
            }
            layout_map[offset].syn_ele = syn_ele;
            layout_map[offset].someInt = stjs.trunc(_in.readNBit(4));
            layout_map[offset].position = type;
            offset++;
        }
    };
}, {type: {name: "Enum", arguments: ["BlockType"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var MD5 = function() {};
MD5 = stjs.extend(MD5, null, [], function(constructor, prototype) {
    constructor.md5sumBytes = function(bytes) {
        var md5 = MD5.getDigest();
        md5.update(bytes);
        return MD5.digestToString(md5.digest());
    };
    constructor.digestToString = function(digest) {
        var sb = new StringBuilder();
        for (var i = 0; i < digest.length; i++) {
            var item = digest[i];
            var b = item & 255;
            if (b < 16) 
                sb.append('0'.charCodeAt(0));
            sb.append(Integer.toHexString(b));
        }
        return sb.toString();
    };
    constructor.md5sum = function(bytes) {
        var md5 = MD5.getDigest();
        md5.update(bytes);
        var digest = md5.digest();
        return MD5.digestToString(digest);
    };
    constructor.getDigest = function() {
        var md5;
        try {
            md5 = MessageDigest.getInstance("MD5");
        }catch (e) {
             throw new RuntimeException(e);
        }
        return md5;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var AutoPool = function() {
    this.resources = Collections.synchronizedList(new ArrayList());
    this.scheduler = Executors.newScheduledThreadPool(1, this.daemonThreadFactory());
    var res = this.resources;
    this.scheduler.scheduleAtFixedRate(new (stjs.extend(function AutoPool$1() {}, null, [Runnable], function(constructor, prototype) {
        prototype.run = function() {
            var curTime = System.currentTimeMillis();
            for (var iterator$autoResource = res.iterator(); iterator$autoResource.hasNext(); ) {
                var autoResource = iterator$autoResource.next();
                autoResource.setCurTime(curTime);
            }
        };
    }, {}, {}))(), 0, 100, TimeUnit.MILLISECONDS);
};
AutoPool = stjs.extend(AutoPool, null, [], function(constructor, prototype) {
    prototype.resources = null;
    prototype.scheduler = null;
    prototype.daemonThreadFactory = function() {
        return new (stjs.extend(function AutoPool$2() {}, null, [ThreadFactory], function(constructor, prototype) {
            prototype.newThread = function(r) {
                var t = new Thread(r);
                t.setDaemon(true);
                t.setName(AutoPool.getName());
                return t;
            };
        }, {}, {}))();
    };
    constructor.getInstance = function() {
        return AutoPool.instance;
    };
    prototype.add = function(res) {
        this.resources.add(res);
    };
    constructor.instance = new AutoPool();
}, {resources: {name: "List", arguments: ["AutoResource"]}, scheduler: "ScheduledExecutorService", instance: "AutoPool"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var TimeUtil = function() {};
TimeUtil = stjs.extend(TimeUtil, null, [], function(constructor, prototype) {
    constructor.MOV_TIME_OFFSET = 0;
    constructor.macTimeToDate = function(movSec) {
        return new jsutil.Date(TimeUtil.fromMovTime(movSec));
    };
    constructor.fromMovTime = function(movSec) {
        return (stjs.trunc(movSec)) * 1000 + TimeUtil.MOV_TIME_OFFSET;
    };
    constructor.toMovTime = function(millis) {
        return (((stjs.trunc((millis - TimeUtil.MOV_TIME_OFFSET) / 1000))) | 0);
    };
}, {}, {});
(function() {
    var calendar = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
    calendar.set(1904, 0, 1, 0, 0, 0);
    calendar.set(Calendar.MILLISECOND, 0);
    TimeUtil.MOV_TIME_OFFSET = calendar.getTimeInMillis();
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  SMPTE 302m decoder
 *  
 *  @author The JCodec project
 *  
 */
var S302MDecoder = function() {};
S302MDecoder = stjs.extend(S302MDecoder, null, [AudioDecoder], function(constructor, prototype) {
    constructor.SAMPLE_RATE = 48000;
    prototype.decodeFrame = function(frame, dst) {
        frame.order(ByteOrder.BIG_ENDIAN);
        var dup = dst.duplicate();
        var h = frame.getInt();
        var frameSize = (h >> 16) & 65535;
        if (frame.remaining() != frameSize) 
             throw new IllegalArgumentException("Wrong s302m frame");
        var channels = ((h >> 14) & 3) * 2 + 2;
        var sampleSizeInBits = ((h >> 4) & 3) * 4 + 16;
        if (sampleSizeInBits == 24) {
            var nSamples = (stjs.trunc(frame.remaining() / 7)) * 2;
             while (frame.remaining() > 6){
                var c = (MathUtil.reverse(frame.get() & 255) << 24 >> 24);
                var b = (MathUtil.reverse(frame.get() & 255) << 24 >> 24);
                var a = (MathUtil.reverse(frame.get() & 255) << 24 >> 24);
                var g = MathUtil.reverse(frame.get() & 15);
                var f = MathUtil.reverse(frame.get() & 255);
                var e = MathUtil.reverse(frame.get() & 255);
                var d = MathUtil.reverse(frame.get() & 240);
                dup.put(a);
                dup.put(b);
                dup.put(c);
                dup.put((((d << 4) | (e >> 4)) << 24 >> 24));
                dup.put((((e << 4) | (f >> 4)) << 24 >> 24));
                dup.put((((f << 4) | (g >> 4)) << 24 >> 24));
            }
            dup.flip();
            return new AudioBuffer(dup, new AudioFormat(S302MDecoder.SAMPLE_RATE, 24, channels, true, true), stjs.trunc(nSamples / channels));
        } else if (sampleSizeInBits == 20) {
            var nSamples = (stjs.trunc(frame.remaining() / 6)) * 2;
             while (frame.remaining() > 5){
                var c = MathUtil.reverse(frame.get() & 255);
                var b = MathUtil.reverse(frame.get() & 255);
                var a = MathUtil.reverse(frame.get() & 240);
                dup.put((((a << 4) | (b >> 4)) << 24 >> 24));
                dup.put((((b << 4) | (c >> 4)) << 24 >> 24));
                dup.put(((c << 4) << 24 >> 24));
                var cc = MathUtil.reverse(frame.get() & 255);
                var bb = MathUtil.reverse(frame.get() & 255);
                var aa = MathUtil.reverse(frame.get() & 240);
                dup.put((((aa << 4) | (bb >> 4)) << 24 >> 24));
                dup.put((((bb << 4) | (cc >> 4)) << 24 >> 24));
                dup.put(((cc << 4) << 24 >> 24));
            }
            dup.flip();
            return new AudioBuffer(dup, new AudioFormat(S302MDecoder.SAMPLE_RATE, 24, channels, true, true), stjs.trunc(nSamples / channels));
        } else {
            var nSamples = (stjs.trunc(frame.remaining() / 5)) * 2;
             while (frame.remaining() > 4){
                var bb = (MathUtil.reverse(frame.get() & 255) << 24 >> 24);
                var aa = (MathUtil.reverse(frame.get() & 255) << 24 >> 24);
                var c = MathUtil.reverse(frame.get() & 255);
                var b = MathUtil.reverse(frame.get() & 255);
                var a = MathUtil.reverse(frame.get() & 240);
                dst.put(aa);
                dst.put(bb);
                dst.put((((a << 4) | (b >> 4)) << 24 >> 24));
                dst.put((((b << 4) | (c >> 4)) << 24 >> 24));
            }
            dup.flip();
            return new AudioBuffer(dup, new AudioFormat(S302MDecoder.SAMPLE_RATE, 16, channels, true, true), stjs.trunc(nSamples / channels));
        }
    };
    prototype.getCodecMeta = function(_data) {
        var frame = _data.duplicate();
        frame.order(ByteOrder.BIG_ENDIAN);
        var h = frame.getInt();
        var frameSize = (h >> 16) & 65535;
        if (frame.remaining() != frameSize) 
             throw new IllegalArgumentException("Wrong s302m frame");
        var channels = ((h >> 14) & 3) * 2 + 2;
        var sampleSizeInBits = ((h >> 4) & 3) * 4 + 16;
        return AudioCodecMeta.fromAudioFormat(new AudioFormat(S302MDecoder.SAMPLE_RATE, sampleSizeInBits, channels, true, true));
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var RationalLarge = function(num, den) {
    this.num = num;
    this.den = den;
};
RationalLarge = stjs.extend(RationalLarge, null, [], function(constructor, prototype) {
    constructor.ONE = new RationalLarge(1, 1);
    constructor.HALF = new RationalLarge(1, 2);
    constructor.ZERO = new RationalLarge(0, 1);
    prototype.num = 0;
    prototype.den = 0;
    prototype.getNum = function() {
        return this.num;
    };
    prototype.getDen = function() {
        return this.den;
    };
    constructor.parse = function(string) {
        var split = StringUtils.splitS(string, ":");
        return split.length > 1 ? RationalLarge.R(Long.parseLong(split[0]), Long.parseLong(split[1])) : RationalLarge.R(Long.parseLong(string), 1);
    };
    prototype.hashCode = function() {
        var prime = 31;
        var result = 1;
        result = prime * result + (((this.den ^ (this.den >>> 32))) | 0);
        result = prime * result + (((this.num ^ (this.num >>> 32))) | 0);
        return result;
    };
    prototype.equals = function(obj) {
        if (this == obj) 
            return true;
        if (obj == null) 
            return false;
        if (this.getClass() != obj.getClass()) 
            return false;
        var other = obj;
        if (this.den != other.den) 
            return false;
        if (this.num != other.num) 
            return false;
        return true;
    };
    prototype.multiplyS = function(scalar) {
        return stjs.trunc((this.num * scalar) / this.den);
    };
    prototype.divideS = function(scalar) {
        return stjs.trunc((this.den * scalar) / this.num);
    };
    prototype.divideByS = function(scalar) {
        return stjs.trunc(this.num / (this.den * scalar));
    };
    prototype.flip = function() {
        return new RationalLarge(this.den, this.num);
    };
    constructor.R = function(num, den) {
        return new RationalLarge(num, den);
    };
    constructor.R1 = function(num) {
        return RationalLarge.R(num, 1);
    };
    prototype.lessThen = function(sec) {
        return this.num * sec.den < sec.num * this.den;
    };
    prototype.greaterThen = function(sec) {
        return this.num * sec.den > sec.num * this.den;
    };
    prototype.smallerOrEqualTo = function(sec) {
        return this.num * sec.den <= sec.num * this.den;
    };
    prototype.greaterOrEqualTo = function(sec) {
        return this.num * sec.den >= sec.num * this.den;
    };
    prototype.equalsLarge = function(other) {
        return this.num * other.den == other.num * this.den;
    };
    prototype.plus = function(other) {
        return RationalLarge.reduceLong(this.num * other.den + other.num * this.den, this.den * other.den);
    };
    prototype.plusR = function(other) {
        return RationalLarge.reduceLong(this.num * other.den + other.num * this.den, this.den * other.den);
    };
    prototype.minus = function(other) {
        return RationalLarge.reduceLong(this.num * other.den - other.num * this.den, this.den * other.den);
    };
    prototype.minusR = function(other) {
        return RationalLarge.reduceLong(this.num * other.den - other.num * this.den, this.den * other.den);
    };
    prototype.plusLong = function(scalar) {
        return new RationalLarge(this.num + scalar * this.den, this.den);
    };
    prototype.minusLong = function(scalar) {
        return new RationalLarge(this.num - scalar * this.den, this.den);
    };
    prototype.multiplyLong = function(scalar) {
        return new RationalLarge(this.num * scalar, this.den);
    };
    prototype.divideLong = function(scalar) {
        return new RationalLarge(this.den * scalar, this.num);
    };
    prototype.divideByLong = function(scalar) {
        return new RationalLarge(this.num, this.den * scalar);
    };
    prototype.multiply = function(other) {
        return RationalLarge.reduceLong(this.num * other.num, this.den * other.den);
    };
    prototype.multiplyR = function(other) {
        return RationalLarge.reduceLong(this.num * other.num, this.den * other.den);
    };
    prototype.divideRL = function(other) {
        return RationalLarge.reduceLong(other.num * this.den, other.den * this.num);
    };
    prototype.divideR = function(other) {
        return RationalLarge.reduceLong(other.num * this.den, other.den * this.num);
    };
    prototype.divideBy = function(other) {
        return RationalLarge.reduceLong(this.num * other.den, this.den * other.num);
    };
    prototype.divideByR = function(other) {
        return RationalLarge.reduceLong(this.num * other.den, this.den * other.num);
    };
    prototype.scalar = function() {
        return (this.num) / this.den;
    };
    prototype.scalarClip = function() {
        return stjs.trunc(this.num / this.den);
    };
    prototype.toString = function() {
        return this.num + ":" + this.den;
    };
    constructor.reduceLong = function(num, den) {
        var gcd = MathUtil.gcdLong(num, den);
        return new RationalLarge(stjs.trunc(num / gcd), stjs.trunc(den / gcd));
    };
}, {ONE: "RationalLarge", HALF: "RationalLarge", ZERO: "RationalLarge"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var CopyrightExtension = function() {};
CopyrightExtension = stjs.extend(CopyrightExtension, null, [MPEGHeader], function(constructor, prototype) {
    prototype.copyright_flag = 0;
    prototype.copyright_identifier = 0;
    prototype.original_or_copy = 0;
    prototype.copyright_number_1 = 0;
    prototype.copyright_number_2 = 0;
    prototype.copyright_number_3 = 0;
    constructor.Copyright_Extension = 4;
    constructor.read = function(_in) {
        var ce = new CopyrightExtension();
        ce.copyright_flag = _in.read1Bit();
        ce.copyright_identifier = _in.readNBit(8);
        ce.original_or_copy = _in.read1Bit();
        _in.skip(7);
        _in.read1Bit();
        ce.copyright_number_1 = _in.readNBit(20);
        _in.read1Bit();
        ce.copyright_number_2 = _in.readNBit(22);
        _in.read1Bit();
        ce.copyright_number_3 = _in.readNBit(22);
        return ce;
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(CopyrightExtension.Copyright_Extension, 4);
        bw.write1Bit(this.copyright_flag);
        bw.writeNBit(this.copyright_identifier, 8);
        bw.write1Bit(this.original_or_copy);
        bw.writeNBit(0, 7);
        bw.write1Bit(1);
        bw.writeNBit(this.copyright_number_1, 20);
        bw.write1Bit(1);
        bw.writeNBit(this.copyright_number_2, 22);
        bw.write1Bit(1);
        bw.writeNBit(this.copyright_number_3, 22);
        bw.flush();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PictureTemporalScalableExtension = function() {};
PictureTemporalScalableExtension = stjs.extend(PictureTemporalScalableExtension, null, [MPEGHeader], function(constructor, prototype) {
    prototype.reference_select_code = 0;
    prototype.forward_temporal_reference = 0;
    prototype.backward_temporal_reference = 0;
    constructor.Picture_Temporal_Scalable_Extension = 16;
    constructor.read = function(_in) {
        var ptse = new PictureTemporalScalableExtension();
        ptse.reference_select_code = _in.readNBit(2);
        ptse.forward_temporal_reference = _in.readNBit(10);
        _in.read1Bit();
        ptse.backward_temporal_reference = _in.readNBit(10);
        return ptse;
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(PictureTemporalScalableExtension.Picture_Temporal_Scalable_Extension, 4);
        bw.writeNBit(this.reference_select_code, 2);
        bw.writeNBit(this.forward_temporal_reference, 10);
        bw.write1Bit(1);
        bw.writeNBit(this.backward_temporal_reference, 10);
        bw.flush();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var QuantMatrixExtension = function() {};
QuantMatrixExtension = stjs.extend(QuantMatrixExtension, null, [MPEGHeader], function(constructor, prototype) {
    prototype.intra_quantiser_matrix = null;
    prototype.non_intra_quantiser_matrix = null;
    prototype.chroma_intra_quantiser_matrix = null;
    prototype.chroma_non_intra_quantiser_matrix = null;
    constructor.Quant_Matrix_Extension = 3;
    constructor.read = function(_in) {
        var qme = new QuantMatrixExtension();
        if (_in.read1Bit() != 0) 
            qme.intra_quantiser_matrix = QuantMatrixExtension.readQMat(_in);
        if (_in.read1Bit() != 0) 
            qme.non_intra_quantiser_matrix = QuantMatrixExtension.readQMat(_in);
        if (_in.read1Bit() != 0) 
            qme.chroma_intra_quantiser_matrix = QuantMatrixExtension.readQMat(_in);
        if (_in.read1Bit() != 0) 
            qme.chroma_non_intra_quantiser_matrix = QuantMatrixExtension.readQMat(_in);
        return qme;
    };
    constructor.readQMat = function(_in) {
        var qmat = new Int32Array(64);
        for (var i = 0; i < 64; i++) 
            qmat[i] = _in.readNBit(8);
        return qmat;
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(QuantMatrixExtension.Quant_Matrix_Extension, 4);
        bw.write1Bit(this.intra_quantiser_matrix != null ? 1 : 0);
        if (this.intra_quantiser_matrix != null) 
            this.writeQMat(this.intra_quantiser_matrix, bw);
        bw.write1Bit(this.non_intra_quantiser_matrix != null ? 1 : 0);
        if (this.non_intra_quantiser_matrix != null) 
            this.writeQMat(this.non_intra_quantiser_matrix, bw);
        bw.write1Bit(this.chroma_intra_quantiser_matrix != null ? 1 : 0);
        if (this.chroma_intra_quantiser_matrix != null) 
            this.writeQMat(this.chroma_intra_quantiser_matrix, bw);
        bw.write1Bit(this.chroma_non_intra_quantiser_matrix != null ? 1 : 0);
        if (this.chroma_non_intra_quantiser_matrix != null) 
            this.writeQMat(this.chroma_non_intra_quantiser_matrix, bw);
        bw.flush();
    };
    prototype.writeQMat = function(matrix, ob) {
        for (var i = 0; i < 64; i++) 
            ob.writeNBit(matrix[i], 8);
    };
}, {intra_quantiser_matrix: "Int32Array", non_intra_quantiser_matrix: "Int32Array", chroma_intra_quantiser_matrix: "Int32Array", chroma_non_intra_quantiser_matrix: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PictureCodingExtension = function() {
    this.f_code = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(2);
    });
};
PictureCodingExtension = stjs.extend(PictureCodingExtension, null, [MPEGHeader], function(constructor, prototype) {
    constructor.Top_Field = 1;
    constructor.Bottom_Field = 2;
    constructor.Frame = 3;
    prototype.f_code = null;
    prototype.intra_dc_precision = 0;
    prototype.picture_structure = 0;
    prototype.top_field_first = 0;
    prototype.frame_pred_frame_dct = 0;
    prototype.concealment_motion_vectors = 0;
    prototype.q_scale_type = 0;
    prototype.intra_vlc_format = 0;
    prototype.alternate_scan = 0;
    prototype.repeat_first_field = 0;
    prototype.chroma_420_type = 0;
    prototype.progressive_frame = 0;
    prototype.compositeDisplay = null;
    constructor.Picture_Coding_Extension = 8;
    constructor.CompositeDisplay = function() {};
    constructor.CompositeDisplay = stjs.extend(constructor.CompositeDisplay, null, [], function(constructor, prototype) {
        prototype.v_axis = 0;
        prototype.field_sequence = 0;
        prototype.sub_carrier = 0;
        prototype.burst_amplitude = 0;
        prototype.sub_carrier_phase = 0;
        constructor.read = function(_in) {
            var cd = new PictureCodingExtension.CompositeDisplay();
            cd.v_axis = _in.read1Bit();
            cd.field_sequence = _in.readNBit(3);
            cd.sub_carrier = _in.read1Bit();
            cd.burst_amplitude = _in.readNBit(7);
            cd.sub_carrier_phase = _in.readNBit(8);
            return cd;
        };
        prototype.write = function(out) {
            out.write1Bit(this.v_axis);
            out.writeNBit(this.field_sequence, 3);
            out.write1Bit(this.sub_carrier);
            out.writeNBit(this.burst_amplitude, 7);
            out.writeNBit(this.sub_carrier_phase, 8);
        };
    }, {}, {});
    constructor.read = function(_in) {
        var pce = new PictureCodingExtension();
        pce.f_code[0][0] = _in.readNBit(4);
        pce.f_code[0][1] = _in.readNBit(4);
        pce.f_code[1][0] = _in.readNBit(4);
        pce.f_code[1][1] = _in.readNBit(4);
        pce.intra_dc_precision = _in.readNBit(2);
        pce.picture_structure = _in.readNBit(2);
        pce.top_field_first = _in.read1Bit();
        pce.frame_pred_frame_dct = _in.read1Bit();
        pce.concealment_motion_vectors = _in.read1Bit();
        pce.q_scale_type = _in.read1Bit();
        pce.intra_vlc_format = _in.read1Bit();
        pce.alternate_scan = _in.read1Bit();
        pce.repeat_first_field = _in.read1Bit();
        pce.chroma_420_type = _in.read1Bit();
        pce.progressive_frame = _in.read1Bit();
        if (_in.read1Bit() != 0) {
            pce.compositeDisplay = PictureCodingExtension.CompositeDisplay.read(_in);
        }
        return pce;
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(PictureCodingExtension.Picture_Coding_Extension, 4);
        bw.writeNBit(this.f_code[0][0], 4);
        bw.writeNBit(this.f_code[0][1], 4);
        bw.writeNBit(this.f_code[1][0], 4);
        bw.writeNBit(this.f_code[1][1], 4);
        bw.writeNBit(this.intra_dc_precision, 2);
        bw.writeNBit(this.picture_structure, 2);
        bw.write1Bit(this.top_field_first);
        bw.write1Bit(this.frame_pred_frame_dct);
        bw.write1Bit(this.concealment_motion_vectors);
        bw.write1Bit(this.q_scale_type);
        bw.write1Bit(this.intra_vlc_format);
        bw.write1Bit(this.alternate_scan);
        bw.write1Bit(this.repeat_first_field);
        bw.write1Bit(this.chroma_420_type);
        bw.write1Bit(this.progressive_frame);
        bw.write1Bit(this.compositeDisplay != null ? 1 : 0);
        if (this.compositeDisplay != null) 
            this.compositeDisplay.write(bw);
        bw.flush();
    };
}, {f_code: "Array", compositeDisplay: "PictureCodingExtension.CompositeDisplay"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PictureSpatialScalableExtension = function() {};
PictureSpatialScalableExtension = stjs.extend(PictureSpatialScalableExtension, null, [MPEGHeader], function(constructor, prototype) {
    prototype.lower_layer_temporal_reference = 0;
    prototype.lower_layer_horizontal_offset = 0;
    prototype.lower_layer_vertical_offset = 0;
    prototype.spatial_temporal_weight_code_table_index = 0;
    prototype.lower_layer_progressive_frame = 0;
    prototype.lower_layer_deinterlaced_field_select = 0;
    constructor.Picture_Spatial_Scalable_Extension = 9;
    constructor.read = function(_in) {
        var psse = new PictureSpatialScalableExtension();
        psse.lower_layer_temporal_reference = _in.readNBit(10);
        _in.read1Bit();
        psse.lower_layer_horizontal_offset = _in.readNBit(15);
        _in.read1Bit();
        psse.lower_layer_vertical_offset = _in.readNBit(15);
        psse.spatial_temporal_weight_code_table_index = _in.readNBit(2);
        psse.lower_layer_progressive_frame = _in.read1Bit();
        psse.lower_layer_deinterlaced_field_select = _in.read1Bit();
        return psse;
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(PictureSpatialScalableExtension.Picture_Spatial_Scalable_Extension, 4);
        bw.writeNBit(this.lower_layer_temporal_reference, 10);
        bw.write1Bit(1);
        bw.writeNBit(this.lower_layer_horizontal_offset, 15);
        bw.write1Bit(1);
        bw.writeNBit(this.lower_layer_vertical_offset, 15);
        bw.writeNBit(this.spatial_temporal_weight_code_table_index, 2);
        bw.write1Bit(this.lower_layer_progressive_frame);
        bw.write1Bit(this.lower_layer_deinterlaced_field_select);
        bw.flush();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SequenceDisplayExtension = function() {};
SequenceDisplayExtension = stjs.extend(SequenceDisplayExtension, null, [MPEGHeader], function(constructor, prototype) {
    prototype.video_format = 0;
    prototype.display_horizontal_size = 0;
    prototype.display_vertical_size = 0;
    prototype.colorDescription = null;
    constructor.Sequence_Display_Extension = 2;
    constructor.ColorDescription = function() {};
    constructor.ColorDescription = stjs.extend(constructor.ColorDescription, null, [], function(constructor, prototype) {
        prototype.colour_primaries = 0;
        prototype.transfer_characteristics = 0;
        prototype.matrix_coefficients = 0;
        constructor.read = function(_in) {
            var cd = new SequenceDisplayExtension.ColorDescription();
            cd.colour_primaries = _in.readNBit(8);
            cd.transfer_characteristics = _in.readNBit(8);
            cd.matrix_coefficients = _in.readNBit(8);
            return cd;
        };
        prototype.write = function(out) {
            out.writeNBit(this.colour_primaries, 8);
            out.writeNBit(this.transfer_characteristics, 8);
            out.writeNBit(this.matrix_coefficients, 8);
        };
    }, {}, {});
    constructor.read = function(_in) {
        var sde = new SequenceDisplayExtension();
        sde.video_format = _in.readNBit(3);
        if (_in.read1Bit() == 1) {
            sde.colorDescription = SequenceDisplayExtension.ColorDescription.read(_in);
        }
        sde.display_horizontal_size = _in.readNBit(14);
        _in.read1Bit();
        sde.display_vertical_size = _in.readNBit(14);
        return sde;
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(SequenceDisplayExtension.Sequence_Display_Extension, 4);
        bw.writeNBit(this.video_format, 3);
        bw.write1Bit(this.colorDescription != null ? 1 : 0);
        if (this.colorDescription != null) 
            this.colorDescription.write(bw);
        bw.writeNBit(this.display_horizontal_size, 14);
        bw.write1Bit(1);
        bw.writeNBit(this.display_vertical_size, 14);
        bw.flush();
    };
}, {colorDescription: "SequenceDisplayExtension.ColorDescription"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SequenceExtension = function() {};
SequenceExtension = stjs.extend(SequenceExtension, null, [MPEGHeader], function(constructor, prototype) {
    constructor.Chroma420 = 1;
    constructor.Chroma422 = 2;
    constructor.Chroma444 = 3;
    prototype.profile_and_level = 0;
    prototype.progressive_sequence = 0;
    prototype.chroma_format = 0;
    prototype.horizontal_size_extension = 0;
    prototype.vertical_size_extension = 0;
    prototype.bit_rate_extension = 0;
    prototype.vbv_buffer_size_extension = 0;
    prototype.low_delay = 0;
    prototype.frame_rate_extension_n = 0;
    prototype.frame_rate_extension_d = 0;
    constructor.Sequence_Extension = 1;
    constructor.createSequenceExtension = function(profile_and_level, progressive_sequence, chroma_format, horizontal_size_extension, vertical_size_extension, bit_rate_extension, vbv_buffer_size_extension, low_delay, frame_rate_extension_n, frame_rate_extension_d) {
        var se = new SequenceExtension();
        se.profile_and_level = profile_and_level;
        se.progressive_sequence = progressive_sequence;
        se.chroma_format = chroma_format;
        se.horizontal_size_extension = horizontal_size_extension;
        se.vertical_size_extension = vertical_size_extension;
        se.bit_rate_extension = bit_rate_extension;
        se.vbv_buffer_size_extension = vbv_buffer_size_extension;
        se.low_delay = low_delay;
        se.frame_rate_extension_n = frame_rate_extension_n;
        se.frame_rate_extension_d = frame_rate_extension_d;
        return se;
    };
    constructor.read = function(_in) {
        var se = new SequenceExtension();
        se.profile_and_level = _in.readNBit(8);
        se.progressive_sequence = _in.read1Bit();
        se.chroma_format = _in.readNBit(2);
        se.horizontal_size_extension = _in.readNBit(2);
        se.vertical_size_extension = _in.readNBit(2);
        se.bit_rate_extension = _in.readNBit(12);
        se.vbv_buffer_size_extension = _in.readNBit(8);
        se.low_delay = _in.read1Bit();
        se.frame_rate_extension_n = _in.readNBit(2);
        se.frame_rate_extension_d = _in.readNBit(5);
        return se;
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(SequenceExtension.Sequence_Extension, 4);
        bw.writeNBit(this.profile_and_level, 8);
        bw.write1Bit(this.progressive_sequence);
        bw.writeNBit(this.chroma_format, 2);
        bw.writeNBit(this.horizontal_size_extension, 2);
        bw.writeNBit(this.vertical_size_extension, 2);
        bw.writeNBit(this.bit_rate_extension, 12);
        bw.write1Bit(1);
        bw.writeNBit(this.vbv_buffer_size_extension, 8);
        bw.write1Bit(this.low_delay);
        bw.writeNBit(this.frame_rate_extension_n, 2);
        bw.writeNBit(this.frame_rate_extension_d, 5);
        bw.flush();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Class for convenient reading JPEG entropy coded bit stream
 *  
 *  @author The JCodec project
 *  
 */
var JPEGBitStream = function(b, huff, lumaLen) {
    this.dcPredictor = new Int32Array(3);
    this._in = BitReader.createBitReader(b);
    this.huff = huff;
    this.lumaLen = lumaLen;
};
JPEGBitStream = stjs.extend(JPEGBitStream, null, [], function(constructor, prototype) {
    prototype.huff = null;
    prototype._in = null;
    prototype.dcPredictor = null;
    prototype.lumaLen = 0;
    prototype.readMCU = function(buf) {
        var blk = 0;
        for (var i = 0; i < this.lumaLen; i++ , blk++) {
            this.dcPredictor[0] = buf[blk][0] = this.readDCValue(this.dcPredictor[0], this.huff[0]);
            this.readACValues(buf[blk], this.huff[2]);
        }
        this.dcPredictor[1] = buf[blk][0] = this.readDCValue(this.dcPredictor[1], this.huff[1]);
        this.readACValues(buf[blk], this.huff[3]);
        ++blk;
        this.dcPredictor[2] = buf[blk][0] = this.readDCValue(this.dcPredictor[2], this.huff[1]);
        this.readACValues(buf[blk], this.huff[3]);
        ++blk;
    };
    prototype.readDCValue = function(prevDC, table) {
        var code = table.readVLC(this._in);
        return code != 0 ? this.toValue(this._in.readNBit(code), code) + prevDC : prevDC;
    };
    prototype.readACValues = function(target, table) {
        var code;
        var curOff = 1;
        do {
            code = table.readVLC(this._in);
            if (code == 240) {
                curOff += 16;
            } else if (code > 0) {
                var rle = code >> 4;
                curOff += rle;
                var len = code & 15;
                target[curOff] = this.toValue(this._in.readNBit(len), len);
                curOff++;
            }
        } while (code != 0 && curOff < 64);
    };
    prototype.toValue = function(raw, length) {
        return (length >= 1 && raw < (1 << length - 1)) ? -(1 << length) + 1 + raw : raw;
    };
}, {huff: "Array", _in: "BitReader", dcPredictor: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ADTSParser = function() {};
ADTSParser = stjs.extend(ADTSParser, null, [], function(constructor, prototype) {
    constructor.adtsToStreamInfo = function(hdr) {
        var si = ByteBuffer.allocate(2);
        var wr = new BitWriter(si);
        wr.writeNBit(hdr.getObjectType(), 5);
        wr.writeNBit(hdr.getSamplingIndex(), 4);
        wr.writeNBit(hdr.getChanConfig(), 4);
        wr.flush();
        si.clear();
        return si;
    };
    constructor.Header = function(object_type, chanConfig, crcAbsent, numAACFrames, samplingIndex, size) {
        this.objectType = object_type;
        this.chanConfig = chanConfig;
        this.crcAbsent = crcAbsent;
        this.numAACFrames = numAACFrames;
        this.samplingIndex = samplingIndex;
        this.size = size;
    };
    constructor.Header = stjs.extend(constructor.Header, null, [], function(constructor, prototype) {
        prototype.objectType = 0;
        prototype.chanConfig = 0;
        prototype.crcAbsent = 0;
        prototype.numAACFrames = 0;
        prototype.samplingIndex = 0;
        prototype.samples = 0;
        prototype.size = 0;
        prototype.getObjectType = function() {
            return this.objectType;
        };
        prototype.getChanConfig = function() {
            return this.chanConfig;
        };
        prototype.getCrcAbsent = function() {
            return this.crcAbsent;
        };
        prototype.getNumAACFrames = function() {
            return this.numAACFrames;
        };
        prototype.getSamplingIndex = function() {
            return this.samplingIndex;
        };
        prototype.getSamples = function() {
            return this.samples;
        };
        prototype.getSize = function() {
            return this.size;
        };
        prototype.getSampleRate = function() {
            return AACConts.AAC_SAMPLE_RATES[this.samplingIndex];
        };
    }, {}, {});
    constructor.read = function(data) {
        var dup = data.duplicate();
        var br = BitReader.createBitReader(dup);
        if (br.readNBit(12) != 4095) {
            return null;
        }
        var id = br.read1Bit();
        var layer = br.readNBit(2);
        var crc_abs = br.read1Bit();
        var aot = br.readNBit(2);
        var sr = br.readNBit(4);
        var pb = br.read1Bit();
        var ch = br.readNBit(3);
        var origCopy = br.read1Bit();
        var home = br.read1Bit();
        var copy = br.read1Bit();
        var copyStart = br.read1Bit();
        var size = br.readNBit(13);
        if (size < 7) 
            return null;
        var buffer = br.readNBit(11);
        var rdb = br.readNBit(2);
        br.stop();
        data.setPosition(dup.position());
        return new ADTSParser.Header(aot + 1, ch, crc_abs, rdb + 1, sr, size);
    };
    constructor.write = function(header, buf) {
        var data = buf.duplicate();
        var br = new BitWriter(data);
        br.writeNBit(4095, 12);
        br.write1Bit(1);
        br.writeNBit(0, 2);
        br.write1Bit(header.getCrcAbsent());
        br.writeNBit(header.getObjectType() - 1, 2);
        br.writeNBit(header.getSamplingIndex(), 4);
        br.write1Bit(0);
        br.writeNBit(header.getChanConfig(), 3);
        br.write1Bit(0);
        br.write1Bit(0);
        br.write1Bit(0);
        br.write1Bit(0);
        br.writeNBit(header.getSize(), 13);
        br.writeNBit(0, 11);
        br.writeNBit(header.getNumAACFrames() - 1, 2);
        br.flush();
        data.flip();
        return data;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var GOPHeader = function(timeCode, closedGop, brokenLink) {
    this.timeCode = timeCode;
    this.closedGop = closedGop;
    this.brokenLink = brokenLink;
};
GOPHeader = stjs.extend(GOPHeader, null, [MPEGHeader], function(constructor, prototype) {
    prototype.timeCode = null;
    prototype.closedGop = false;
    prototype.brokenLink = false;
    constructor.read = function(bb) {
        var _in = BitReader.createBitReader(bb);
        var dropFrame = _in.read1Bit() == 1;
        var hours = ((_in.readNBit(5)) << 16 >> 16);
        var minutes = (_in.readNBit(6) << 24 >> 24);
        _in.skip(1);
        var seconds = (_in.readNBit(6) << 24 >> 24);
        var frames = (_in.readNBit(6) << 24 >> 24);
        var closedGop = _in.read1Bit() == 1;
        var brokenLink = _in.read1Bit() == 1;
        return new GOPHeader(new TapeTimecode(hours, minutes, seconds, frames, dropFrame, 0), closedGop, brokenLink);
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        if (this.timeCode == null) 
            bw.writeNBit(0, 25);
         else {
            bw.write1Bit(this.timeCode.isDropFrame() ? 1 : 0);
            bw.writeNBit(this.timeCode.getHour(), 5);
            bw.writeNBit(this.timeCode.getMinute(), 6);
            bw.write1Bit(1);
            bw.writeNBit(this.timeCode.getSecond(), 6);
            bw.writeNBit(this.timeCode.getFrame(), 6);
        }
        bw.write1Bit(this.closedGop ? 1 : 0);
        bw.write1Bit(this.brokenLink ? 1 : 0);
        bw.flush();
    };
    prototype.getTimeCode = function() {
        return this.timeCode;
    };
    prototype.isClosedGop = function() {
        return this.closedGop;
    };
    prototype.isBrokenLink = function() {
        return this.brokenLink;
    };
}, {timeCode: "TapeTimecode"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var FFT = function(length) {
    this.length = length;
    switch (length) {
        case 64:
            this.roots = FFTTables.FFT_TABLE_64;
            break;
        case 512:
            this.roots = FFTTables.FFT_TABLE_512;
            break;
        case 60:
            this.roots = FFTTables.FFT_TABLE_60;
            break;
        case 480:
            this.roots = FFTTables.FFT_TABLE_480;
            break;
        default:
             throw new AACException("unexpected FFT length: " + length);
    }
    this.rev = Array.apply(null, Array(length)).map(function() {
        return new Float32Array(2);
    });
    this.a = new Float32Array(2);
    this.b = new Float32Array(2);
    this.c = new Float32Array(2);
    this.d = new Float32Array(2);
    this.e1 = new Float32Array(2);
    this.e2 = new Float32Array(2);
};
FFT = stjs.extend(FFT, null, [FFTTables], function(constructor, prototype) {
    prototype.length = 0;
    prototype.roots = null;
    prototype.rev = null;
    prototype.a = null;
    prototype.b = null;
    prototype.c = null;
    prototype.d = null;
    prototype.e1 = null;
    prototype.e2 = null;
    prototype.process = function(_in, forward) {
        var imOff = (forward ? 2 : 1);
        var scale = (forward ? this.length : 1);
        var ii = 0;
        for (var i = 0; i < this.length; i++) {
            this.rev[i][0] = _in[ii][0];
            this.rev[i][1] = _in[ii][1];
            var k = this.length >> 1;
             while (ii >= k && k > 0){
                ii -= k;
                k >>= 1;
            }
            ii += k;
        }
        for (var i = 0; i < this.length; i++) {
            _in[i][0] = this.rev[i][0];
            _in[i][1] = this.rev[i][1];
        }
        for (var i = 0; i < this.length; i += 4) {
            this.a[0] = _in[i][0] + _in[i + 1][0];
            this.a[1] = _in[i][1] + _in[i + 1][1];
            this.b[0] = _in[i + 2][0] + _in[i + 3][0];
            this.b[1] = _in[i + 2][1] + _in[i + 3][1];
            this.c[0] = _in[i][0] - _in[i + 1][0];
            this.c[1] = _in[i][1] - _in[i + 1][1];
            this.d[0] = _in[i + 2][0] - _in[i + 3][0];
            this.d[1] = _in[i + 2][1] - _in[i + 3][1];
            _in[i][0] = this.a[0] + this.b[0];
            _in[i][1] = this.a[1] + this.b[1];
            _in[i + 2][0] = this.a[0] - this.b[0];
            _in[i + 2][1] = this.a[1] - this.b[1];
            this.e1[0] = this.c[0] - this.d[1];
            this.e1[1] = this.c[1] + this.d[0];
            this.e2[0] = this.c[0] + this.d[1];
            this.e2[1] = this.c[1] - this.d[0];
            if (forward) {
                _in[i + 1][0] = this.e2[0];
                _in[i + 1][1] = this.e2[1];
                _in[i + 3][0] = this.e1[0];
                _in[i + 3][1] = this.e1[1];
            } else {
                _in[i + 1][0] = this.e1[0];
                _in[i + 1][1] = this.e1[1];
                _in[i + 3][0] = this.e2[0];
                _in[i + 3][1] = this.e2[1];
            }
        }
        var shift, m, km;
        var rootRe, rootIm, zRe, zIm;
        for (var i = 4; i < this.length; i <<= 1) {
            shift = i << 1;
            m = stjs.trunc(this.length / shift);
            for (var j = 0; j < this.length; j += shift) {
                for (var k = 0; k < i; k++) {
                    km = k * m;
                    rootRe = this.roots[km][0];
                    rootIm = this.roots[km][imOff];
                    zRe = _in[i + j + k][0] * rootRe - _in[i + j + k][1] * rootIm;
                    zIm = _in[i + j + k][0] * rootIm + _in[i + j + k][1] * rootRe;
                    _in[i + j + k][0] = (_in[j + k][0] - zRe) * scale;
                    _in[i + j + k][1] = (_in[j + k][1] - zIm) * scale;
                    _in[j + k][0] = (_in[j + k][0] + zRe) * scale;
                    _in[j + k][1] = (_in[j + k][1] + zIm) * scale;
                }
            }
        }
    };
}, {roots: "Array", rev: "Array", a: "Float32Array", b: "Float32Array", c: "Float32Array", d: "Float32Array", e1: "Float32Array", e2: "Float32Array", FFT_TABLE_512: "Array", FFT_TABLE_64: "Array", FFT_TABLE_480: "Array", FFT_TABLE_60: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Temporal Noise Shaping
 *  @author in-somnia
 */
var TNS = function() {
    this.nFilt = new Int32Array(8);
    this.length = Array.apply(null, Array(8)).map(function() {
        return new Int32Array(4);
    });
    this.direction = Array.apply(null, Array(8)).map(function() {
        return new Int8Array(4);
    });
    this.order = Array.apply(null, Array(8)).map(function() {
        return new Int32Array(4);
    });
    this.coef = Array.apply(null, Array(8)).map(function() {
        return Array.apply(null, Array(4)).map(function() {
            return new Float32Array(TNS.TNS_MAX_ORDER);
        });
    });
};
TNS = stjs.extend(TNS, null, [SyntaxConstants, TNSTables], function(constructor, prototype) {
    constructor.TNS_MAX_ORDER = 20;
    constructor.SHORT_BITS = new Int32Array([1, 4, 3]);
    constructor.LONG_BITS = new Int32Array([2, 6, 5]);
    prototype.nFilt = null;
    prototype.length = null;
    prototype.order = null;
    prototype.direction = null;
    prototype.coef = null;
    prototype.decode = function(_in, info) {
        var windowCount = info.getWindowCount();
        var bits = info.isEightShortFrame() ? TNS.SHORT_BITS : TNS.LONG_BITS;
        var w, i, filt, coefLen, coefRes, coefCompress, tmp;
        for (w = 0; w < windowCount; w++) {
            if ((this.nFilt[w] = _in.readBits(bits[0])) != 0) {
                coefRes = _in.readBit();
                for (filt = 0; filt < this.nFilt[w]; filt++) {
                    this.length[w][filt] = _in.readBits(bits[1]);
                    if ((this.order[w][filt] = _in.readBits(bits[2])) > 20) 
                         throw new AACException("TNS filter out of range: " + this.order[w][filt]);
                     else if (this.order[w][filt] != 0) {
                        this.direction[w][filt] = _in.readBool();
                        coefCompress = _in.readBit();
                        coefLen = coefRes + 3 - coefCompress;
                        tmp = 2 * coefCompress + coefRes;
                        for (i = 0; i < this.order[w][filt]; i++) {
                            this.coef[w][filt][i] = TNSTables.TNS_TABLES[tmp][_in.readBits(coefLen)];
                        }
                    }
                }
            }
        }
    };
    prototype.process = function(ics, spec, sf, decode) {};
}, {SHORT_BITS: "Int32Array", LONG_BITS: "Int32Array", nFilt: "Int32Array", length: "Array", order: "Array", direction: "Array", coef: "Array", TNS_COEF_1_3: "Float32Array", TNS_COEF_0_3: "Float32Array", TNS_COEF_1_4: "Float32Array", TNS_COEF_0_4: "Float32Array", TNS_TABLES: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var Huffman = function() {};
Huffman = stjs.extend(Huffman, null, [Codebooks], function(constructor, prototype) {
    constructor.UNSIGNED = new Int8Array([false, false, true, true, false, false, true, true, true, true, true]);
    constructor.QUAD_LEN = 4;
    constructor.PAIR_LEN = 2;
    constructor.findOffset = function(_in, table) {
        var off = 0;
        var len = table[off][0];
        var cw = _in.readBits(len);
        var j;
         while (cw != table[off][1]){
            off++;
            j = table[off][0] - len;
            len = table[off][0];
            cw <<= j;
            cw |= _in.readBits(j);
        }
        return off;
    };
    constructor.signValues = function(_in, data, off, len) {
        for (var i = off; i < off + len; i++) {
            if (data[i] != 0) {
                if (_in.readBool()) 
                    data[i] = -data[i];
            }
        }
    };
    constructor.getEscape = function(_in, s) {
        var neg = s < 0;
        var i = 4;
         while (_in.readBool()){
            i++;
        }
        var j = _in.readBits(i) | (1 << i);
        return (neg ? -j : j);
    };
    constructor.decodeScaleFactor = function(_in) {
        var offset = Huffman.findOffset(_in, Codebooks.HCB_SF);
        return Codebooks.HCB_SF[offset][2];
    };
    constructor.decodeSpectralData = function(_in, cb, data, off) {
        var HCB = Codebooks.CODEBOOKS[cb - 1];
        var offset = Huffman.findOffset(_in, HCB);
        data[off] = HCB[offset][2];
        data[off + 1] = HCB[offset][3];
        if (cb < 5) {
            data[off + 2] = HCB[offset][4];
            data[off + 3] = HCB[offset][5];
        }
        if (cb < 11) {
            if (Huffman.UNSIGNED[cb - 1]) 
                Huffman.signValues(_in, data, off, cb < 5 ? Huffman.QUAD_LEN : Huffman.PAIR_LEN);
        } else if (cb == 11 || cb > 15) {
            Huffman.signValues(_in, data, off, cb < 5 ? Huffman.QUAD_LEN : Huffman.PAIR_LEN);
            if (Math.abs(data[off]) == 16) 
                data[off] = Huffman.getEscape(_in, data[off]);
            if (Math.abs(data[off + 1]) == 16) 
                data[off + 1] = Huffman.getEscape(_in, data[off + 1]);
        } else 
             throw new AACException("Huffman: unknown spectral codebook: " + cb);
    };
}, {UNSIGNED: "Int8Array", HCB1: "Array", HCB2: "Array", HCB3: "Array", HCB4: "Array", HCB5: "Array", HCB6: "Array", HCB7: "Array", HCB8: "Array", HCB9: "Array", HCB10: "Array", HCB11: "Array", HCB_SF: "Array", CODEBOOKS: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Huffman Codeword Reordering
 *  Decodes spectral data for ICStreams if error resilience is used for
 *  section data.
 *  
 *  @author in-somnia
 */
var HCR = function() {};
HCR = stjs.extend(HCR, null, [SyntaxConstants], function(constructor, prototype) {
    constructor.Codeword = function() {};
    constructor.Codeword = stjs.extend(constructor.Codeword, null, [], function(constructor, prototype) {
        prototype.cb = 0;
        prototype.decoded = 0;
        prototype.sp_offset = 0;
        prototype.bits = null;
        prototype.fill = function(sp, cb) {
            this.sp_offset = sp;
            this.cb = cb;
            this.decoded = 0;
            this.bits = new BitsBuffer();
        };
    }, {bits: "BitsBuffer"}, {});
    constructor.NUM_CB = 6;
    constructor.NUM_CB_ER = 22;
    constructor.MAX_CB = 32;
    constructor.VCB11_FIRST = 16;
    constructor.VCB11_LAST = 31;
    constructor.PRE_SORT_CB_STD = new Int32Array([11, 9, 7, 5, 3, 1]);
    constructor.PRE_SORT_CB_ER = new Int32Array([11, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 9, 7, 5, 3, 1]);
    constructor.MAX_CW_LEN = new Int32Array([0, 11, 9, 20, 16, 13, 11, 14, 12, 17, 14, 49, 0, 0, 0, 0, 14, 17, 21, 21, 25, 25, 29, 29, 29, 29, 33, 33, 33, 37, 37, 41]);
    constructor.isGoodCB = function(cb, sectCB) {
        var b = false;
        if ((sectCB > HCB.ZERO_HCB && sectCB <= HCB.ESCAPE_HCB) || (sectCB >= HCR.VCB11_FIRST && sectCB <= HCR.VCB11_LAST)) {
            if (cb < HCB.ESCAPE_HCB) 
                b = ((sectCB == cb) || (sectCB == cb + 1));
             else 
                b = (sectCB == cb);
        }
        return b;
    };
    constructor.decodeReorderedSpectralData = function(ics, _in, spectralData, sectionDataResilience) {
        var info = ics.getInfo();
        var windowGroupCount = info.getWindowGroupCount();
        var maxSFB = info.getMaxSFB();
        var swbOffsets = info.getSWBOffsets();
        var swbOffsetMax = info.getSWBOffsetMax();
        var sectStart = Array.apply(null, Array(0)).map(function() {
            return new Int32Array(0);
        });
        var sectEnd = Array.apply(null, Array(0)).map(function() {
            return new Int32Array(0);
        });
        var numSec = new Int32Array(0);
        var sectCB = Array.apply(null, Array(0)).map(function() {
            return new Int32Array(0);
        });
        var sectSFBOffsets = Array.apply(null, Array(0)).map(function() {
            return new Int32Array(0);
        });
        var spDataLen = ics.getReorderedSpectralDataLength();
        if (spDataLen == 0) 
            return;
        var longestLen = ics.getLongestCodewordLength();
        if (longestLen == 0 || longestLen >= spDataLen) 
             throw new AACException("length of longest HCR codeword out of range");
        var spOffsets = new Int32Array(8);
        var shortFrameLen = stjs.trunc(spectralData.length / 8);
        spOffsets[0] = 0;
        var g;
        for (g = 1; g < windowGroupCount; g++) {
            spOffsets[g] = spOffsets[g - 1] + shortFrameLen * info.getWindowGroupLength(g - 1);
        }
        var codeword = Array(512);
        var segment = Array(512);
        var lastCB;
        var preSortCB;
        if (sectionDataResilience) {
            preSortCB = HCR.PRE_SORT_CB_ER;
            lastCB = HCR.NUM_CB_ER;
        } else {
            preSortCB = HCR.PRE_SORT_CB_STD;
            lastCB = HCR.NUM_CB;
        }
        var PCWs_done = 0;
        var segmentsCount = 0;
        var numberOfCodewords = 0;
        var bitsread = 0;
        var sfb, w_idx, i, thisCB, thisSectCB, cws;
        for (var sortloop = 0; sortloop < lastCB; sortloop++) {
            thisCB = preSortCB[sortloop];
            for (sfb = 0; sfb < maxSFB; sfb++) {
                for (w_idx = 0; 4 * w_idx < (Math.min(swbOffsets[sfb + 1], swbOffsetMax) - swbOffsets[sfb]); w_idx++) {
                    for (g = 0; g < windowGroupCount; g++) {
                        for (i = 0; i < numSec[g]; i++) {
                            if ((sectStart[g][i] <= sfb) && (sectEnd[g][i] > sfb)) {
                                thisSectCB = sectCB[g][i];
                                if (HCR.isGoodCB(thisCB, thisSectCB)) {
                                    var sect_sfb_size = sectSFBOffsets[g][sfb + 1] - sectSFBOffsets[g][sfb];
                                    var inc = (thisSectCB < HCB.FIRST_PAIR_HCB) ? 4 : 2;
                                    var group_cws_count = stjs.trunc((4 * info.getWindowGroupLength(g)) / inc);
                                    var segwidth = Math.min(HCR.MAX_CW_LEN[thisSectCB], longestLen);
                                    for (cws = 0; (cws < group_cws_count) && ((cws + w_idx * group_cws_count) < sect_sfb_size); cws++) {
                                        var sp = spOffsets[g] + sectSFBOffsets[g][sfb] + inc * (cws + w_idx * group_cws_count);
                                        if (PCWs_done == 0) {
                                            if (bitsread + segwidth <= spDataLen) {
                                                segment[segmentsCount].readSegment(segwidth, _in);
                                                bitsread += segwidth;
                                                segment[segmentsCount].rewindReverse();
                                                segmentsCount++;
                                            } else {
                                                if (bitsread < spDataLen) {
                                                    var additional_bits = spDataLen - bitsread;
                                                    segment[segmentsCount].readSegment(additional_bits, _in);
                                                    segment[segmentsCount].len += segment[segmentsCount - 1].len;
                                                    segment[segmentsCount].rewindReverse();
                                                    if (segment[segmentsCount - 1].len > 32) {
                                                        segment[segmentsCount - 1].bufb = segment[segmentsCount].bufb + segment[segmentsCount - 1].showBits(segment[segmentsCount - 1].len - 32);
                                                        segment[segmentsCount - 1].bufa = segment[segmentsCount].bufa + segment[segmentsCount - 1].showBits(32);
                                                    } else {
                                                        segment[segmentsCount - 1].bufa = segment[segmentsCount].bufa + segment[segmentsCount - 1].showBits(segment[segmentsCount - 1].len);
                                                        segment[segmentsCount - 1].bufb = segment[segmentsCount].bufb;
                                                    }
                                                    segment[segmentsCount - 1].len += additional_bits;
                                                }
                                                bitsread = spDataLen;
                                                PCWs_done = 1;
                                                codeword[0].fill(sp, thisSectCB);
                                            }
                                        } else {
                                            codeword[numberOfCodewords - segmentsCount].fill(sp, thisSectCB);
                                        }
                                        numberOfCodewords++;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (segmentsCount == 0) 
             throw new AACException("no segments _in HCR");
        var numberOfSets = stjs.trunc(numberOfCodewords / segmentsCount);
        var trial, codewordBase, segmentID, codewordID;
        for (var set = 1; set <= numberOfSets; set++) {
            for (trial = 0; trial < segmentsCount; trial++) {
                for (codewordBase = 0; codewordBase < segmentsCount; codewordBase++) {
                    segmentID = (trial + codewordBase) % segmentsCount;
                    codewordID = codewordBase + set * segmentsCount - segmentsCount;
                    if (codewordID >= numberOfCodewords - segmentsCount) 
                        break;
                    if ((codeword[codewordID].decoded == 0) && (segment[segmentID].len > 0)) {
                        if (codeword[codewordID].bits.len != 0) 
                            segment[segmentID].concatBits(codeword[codewordID].bits);
                        var tmplen = segment[segmentID].len;
                    }
                }
            }
            for (i = 0; i < segmentsCount; i++) {
                segment[i].rewindReverse();
            }
        }
    };
}, {PRE_SORT_CB_STD: "Int32Array", PRE_SORT_CB_ER: "Int32Array", MAX_CW_LEN: "Int32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var BitStream = function() {};
BitStream = stjs.extend(BitStream, null, [IBitStream], function(constructor, prototype) {
    constructor.WORD_BITS = 32;
    constructor.WORD_BYTES = 4;
    constructor.BYTE_MASK = 255;
    constructor.createBitStream = function(data) {
        var bs = new BitStream();
        bs.setData(data);
        return bs;
    };
    prototype.buffer = null;
    prototype.pos = 0;
    prototype.cache = 0;
    prototype.bitsCached = 0;
    prototype.position = 0;
    prototype.destroy = function() {
        this.reset();
        this.buffer = null;
    };
    prototype.setData = function(data) {
        var size = BitStream.WORD_BYTES * (stjs.trunc((data.length + BitStream.WORD_BYTES - 1) / BitStream.WORD_BYTES));
        if (this.buffer == null || this.buffer.length != size) 
            this.buffer = new Int8Array(size);
        System.arraycopy(data, 0, this.buffer, 0, data.length);
        this.reset();
    };
    prototype.byteAlign = function() {
        var toFlush = this.bitsCached & 7;
        if (toFlush > 0) 
            this.skipBits(toFlush);
    };
    prototype.reset = function() {
        this.pos = 0;
        this.bitsCached = 0;
        this.cache = 0;
        this.position = 0;
    };
    prototype.getPosition = function() {
        return this.position;
    };
    prototype.getBitsLeft = function() {
        return this.buffer != null ? 8 * (this.buffer.length - this.pos) + this.bitsCached : 0;
    };
    /**
     *  Reads the next four bytes.
     *  @param peek if true, the stream pointer will not be increased
     */
    prototype.readCache = function(peek) {
        var i;
        if (this.pos > this.buffer.length - BitStream.WORD_BYTES) 
             throw AACException.endOfStream();
         else 
            i = ((this.buffer[this.pos] & BitStream.BYTE_MASK) << 24) | ((this.buffer[this.pos + 1] & BitStream.BYTE_MASK) << 16) | ((this.buffer[this.pos + 2] & BitStream.BYTE_MASK) << 8) | (this.buffer[this.pos + 3] & BitStream.BYTE_MASK);
        if (!peek) 
            this.pos += BitStream.WORD_BYTES;
        return i;
    };
    prototype.readBits = function(n) {
        var result;
        if (this.bitsCached >= n) {
            this.bitsCached -= n;
            result = (this.cache >> this.bitsCached) & this.maskBits(n);
            this.position += n;
        } else {
            this.position += n;
            var c = this.cache & this.maskBits(this.bitsCached);
            var left = n - this.bitsCached;
            this.cache = this.readCache(false);
            this.bitsCached = BitStream.WORD_BITS - left;
            result = ((this.cache >> this.bitsCached) & this.maskBits(left)) | (c << left);
        }
        return result;
    };
    prototype.readBit = function() {
        var i;
        if (this.bitsCached > 0) {
            this.bitsCached--;
            i = (this.cache >> (this.bitsCached)) & 1;
            this.position++;
        } else {
            this.cache = this.readCache(false);
            this.bitsCached = BitStream.WORD_BITS - 1;
            this.position++;
            i = (this.cache >> this.bitsCached) & 1;
        }
        return i;
    };
    prototype.readBool = function() {
        return (this.readBit() & 1) != 0;
    };
    prototype.peekBits = function(n) {
        var ret;
        if (this.bitsCached >= n) {
            ret = (this.cache >> (this.bitsCached - n)) & this.maskBits(n);
        } else {
            var c = this.cache & this.maskBits(this.bitsCached);
            n -= this.bitsCached;
            ret = ((this.readCache(true) >> BitStream.WORD_BITS - n) & this.maskBits(n)) | (c << n);
        }
        return ret;
    };
    prototype.peekBit = function() {
        var ret;
        if (this.bitsCached > 0) {
            ret = (this.cache >> (this.bitsCached - 1)) & 1;
        } else {
            var word = this.readCache(true);
            ret = (word >> BitStream.WORD_BITS - 1) & 1;
        }
        return ret;
    };
    prototype.skipBits = function(n) {
        this.position += n;
        if (n <= this.bitsCached) {
            this.bitsCached -= n;
        } else {
            n -= this.bitsCached;
             while (n >= BitStream.WORD_BITS){
                n -= BitStream.WORD_BITS;
                this.readCache(false);
            }
            if (n > 0) {
                this.cache = this.readCache(false);
                this.bitsCached = BitStream.WORD_BITS - n;
            } else {
                this.cache = 0;
                this.bitsCached = 0;
            }
        }
    };
    prototype.skipBit = function() {
        this.position++;
        if (this.bitsCached > 0) {
            this.bitsCached--;
        } else {
            this.cache = this.readCache(false);
            this.bitsCached = BitStream.WORD_BITS - 1;
        }
    };
    prototype.maskBits = function(n) {
        var i;
        if (n == 32) 
            i = -1;
         else 
            i = (1 << n) - 1;
        return i;
    };
}, {buffer: "Int8Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var NIOBitStream = function(br) {
    this.br = br;
};
NIOBitStream = stjs.extend(NIOBitStream, null, [IBitStream], function(constructor, prototype) {
    prototype.br = null;
    prototype.destroy = function() {
        this.reset();
        this.br = null;
    };
    prototype.setData = function(data) {
        this.br = BitReader.createBitReader(ByteBuffer.wrap(data));
    };
    prototype.byteAlign = function() {
        this.br.align();
    };
    prototype.reset = function() {
         throw new RuntimeException("todo");
    };
    prototype.getPosition = function() {
        return this.br.position();
    };
    prototype.getBitsLeft = function() {
        return this.br.remaining();
    };
    prototype.readBits = function(n) {
        if (this.br.remaining() >= n) {
            return this.br.readNBit(n);
        }
         throw AACException.endOfStream();
    };
    prototype.readBit = function() {
        if (this.br.remaining() >= 1) {
            return this.br.read1Bit();
        }
         throw AACException.endOfStream();
    };
    prototype.readBool = function() {
        var read1Bit = this.readBit();
        return read1Bit != 0;
    };
    prototype.peekBits = function(n) {
        var checkNBit = this.br.checkNBit(n);
        return checkNBit;
    };
    prototype.peekBit = function() {
        var curBit = this.br.curBit();
        return curBit;
    };
    prototype.skipBits = function(n) {
        this.br.skip(n);
    };
    prototype.skipBit = function() {
        this.skipBits(1);
    };
    prototype.maskBits = function(n) {
        var i;
        if (n == 32) 
            i = -1;
         else 
            i = (1 << n) - 1;
        return i;
    };
}, {br: "BitReader"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var RgbToBgrHiBD = function() {};
RgbToBgrHiBD = stjs.extend(RgbToBgrHiBD, null, [TransformHiBD], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        if (src.getColor() != ColorSpace.RGB && src.getColor() != ColorSpace.BGR || dst.getColor() != ColorSpace.RGB && dst.getColor() != ColorSpace.BGR) {
             throw new IllegalArgumentException("Expected RGB or BGR inputs, was: " + src.getColor() + ", " + dst.getColor());
        }
        if (src.getCrop() != null || dst.getCrop() != null) 
             throw new NotSupportedException("Cropped images not supported");
        var dataSrc = src.getPlaneData(0);
        var dataDst = dst.getPlaneData(0);
        for (var i = 0; i < dataSrc.length; i += 3) {
            var tmp = dataSrc[i + 2];
            dataDst[i + 2] = dataSrc[i];
            dataDst[i] = tmp;
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A YUV picture
 *  
 *  @author The JCodec project
 */
var PictureHiBD = function(width, height, data, color, bitDepth, crop) {
    this.width = width;
    this.height = height;
    this.data = data;
    this.color = color;
    this.crop = crop;
    this.bitDepth = bitDepth;
};
PictureHiBD = stjs.extend(PictureHiBD, null, [], function(constructor, prototype) {
    prototype.color = null;
    prototype.width = 0;
    prototype.height = 0;
    prototype.data = null;
    prototype.crop = null;
    prototype.bitDepth = 0;
    constructor.createPicture = function(width, height, data, color) {
        return new PictureHiBD(width, height, data, color, 8, new Rect(0, 0, width, height));
    };
    constructor.createPictureWithDepth = function(width, height, data, color, bitDepth) {
        return new PictureHiBD(width, height, data, color, bitDepth, new Rect(0, 0, width, height));
    };
    constructor.createPictureCropped = function(width, height, data, color, crop) {
        return new PictureHiBD(width, height, data, color, 8, crop);
    };
    constructor.clonePicture = function(other) {
        return new PictureHiBD(other.width, other.height, other.data, other.color, other.bitDepth, other.crop);
    };
    constructor.create = function(width, height, colorSpace) {
        return PictureHiBD.doCreate(width, height, colorSpace, 8, null);
    };
    constructor.createWithDepth = function(width, height, colorSpace, bitDepth) {
        return PictureHiBD.doCreate(width, height, colorSpace, bitDepth, null);
    };
    constructor.createCropped = function(width, height, colorSpace, crop) {
        return PictureHiBD.doCreate(width, height, colorSpace, 8, crop);
    };
    constructor.doCreate = function(width, height, colorSpace, bitDepth, crop) {
        var planeSizes = new Int32Array(ColorSpace.MAX_PLANES);
        for (var i = 0; i < colorSpace.nComp; i++) {
            planeSizes[colorSpace.compPlane[i]] += (width >> colorSpace.compWidth[i]) * (height >> colorSpace.compHeight[i]);
        }
        var nPlanes = 0;
        for (var i = 0; i < ColorSpace.MAX_PLANES; i++) 
            nPlanes += planeSizes[i] != 0 ? 1 : 0;
        var data = Array(nPlanes);
        for (var i = 0, plane = 0; i < ColorSpace.MAX_PLANES; i++) {
            if (planeSizes[i] != 0) {
                data[plane++] = new Int32Array(planeSizes[i]);
            }
        }
        return new PictureHiBD(width, height, data, colorSpace, 8, crop);
    };
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.getPlaneData = function(plane) {
        return this.data[plane];
    };
    prototype.getColor = function() {
        return this.color;
    };
    prototype.getData = function() {
        return this.data;
    };
    prototype.getCrop = function() {
        return this.crop;
    };
    prototype.getPlaneWidth = function(plane) {
        return this.width >> this.color.compWidth[plane];
    };
    prototype.getPlaneHeight = function(plane) {
        return this.height >> this.color.compHeight[plane];
    };
    prototype.compatible = function(src) {
        return src.color == this.color && src.width == this.width && src.height == this.height;
    };
    prototype.createCompatible = function() {
        return PictureHiBD.create(this.width, this.height, this.color);
    };
    prototype.copyFrom = function(src) {
        if (!this.compatible(src)) 
             throw new IllegalArgumentException("Can not copy to incompatible picture");
        for (var plane = 0; plane < this.color.nComp; plane++) {
            if (this.data[plane] == null) 
                continue;
            System.arraycopy(src.data[plane], 0, this.data[plane], 0, (this.width >> this.color.compWidth[plane]) * (this.height >> this.color.compHeight[plane]));
        }
    };
    prototype.cropped = function() {
        if (this.crop == null || (this.crop.getX() == 0 && this.crop.getY() == 0 && this.crop.getWidth() == this.width && this.crop.getHeight() == this.height)) 
            return this;
        var result = PictureHiBD.create(this.crop.getWidth(), this.crop.getHeight(), this.color);
        for (var plane = 0; plane < this.color.nComp; plane++) {
            if (this.data[plane] == null) 
                continue;
            this.cropSub(this.data[plane], this.crop.getX() >> this.color.compWidth[plane], this.crop.getY() >> this.color.compHeight[plane], this.crop.getWidth() >> this.color.compWidth[plane], this.crop.getHeight() >> this.color.compHeight[plane], this.width >> this.color.compWidth[plane], result.data[plane]);
        }
        return result;
    };
    prototype.cropSub = function(src, x, y, w, h, srcStride, tgt) {
        var srcOff = y * srcStride + x, dstOff = 0;
        for (var i = 0; i < h; i++) {
            for (var j = 0; j < w; j++) 
                tgt[dstOff + j] = src[srcOff + j];
            srcOff += srcStride;
            dstOff += w;
        }
    };
    prototype.setCrop = function(crop) {
        this.crop = crop;
    };
    prototype.getCroppedWidth = function() {
        return this.crop == null ? this.width : this.crop.getWidth();
    };
    prototype.getCroppedHeight = function() {
        return this.crop == null ? this.height : this.crop.getHeight();
    };
    prototype.setBitDepth = function(bitDepth) {
        this.bitDepth = bitDepth;
    };
    prototype.getBitDepth = function() {
        return this.bitDepth;
    };
    prototype.equals = function(obj) {
        if (obj == null || !(stjs.isInstanceOf(obj.constructor, PictureHiBD))) 
            return false;
        var other = obj;
        if (other.getCroppedWidth() != this.getCroppedWidth() || other.getCroppedHeight() != this.getCroppedHeight() || other.getColor() != this.color) 
            return false;
        for (var i = 0; i < this.getData().length; i++) 
            if (!this.planeEquals(other, i)) 
                return false;
        return true;
    };
    prototype.planeEquals = function(other, plane) {
        var cw = this.color.compWidth[plane];
        var ch = this.color.compHeight[plane];
        var offA = other.getCrop() == null ? 0 : ((other.getCrop().getX() >> cw) + (other.getCrop().getY() >> ch) * (other.getWidth() >> cw));
        var offB = this.crop == null ? 0 : ((this.crop.getX() >> cw) + (this.crop.getY() >> ch) * (this.width >> cw));
        var planeData = other.getPlaneData(plane);
        for (var i = 0; i < this.getCroppedHeight() >> ch; i++ , offA += (other.getWidth() >> cw) , offB += (this.width >> cw)) {
            for (var j = 0; j < this.getCroppedWidth() >> cw; j++) {
                if (planeData[offA + j] != this.data[plane][offB + j]) 
                    return false;
            }
        }
        return true;
    };
}, {color: "ColorSpace", data: "Array", crop: "Rect"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var RgbToBgr = function() {};
RgbToBgr = stjs.extend(RgbToBgr, null, [Transform], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        if (src.getColor() != ColorSpace.RGB && src.getColor() != ColorSpace.BGR || dst.getColor() != ColorSpace.RGB && dst.getColor() != ColorSpace.BGR) {
             throw new IllegalArgumentException("Expected RGB or BGR inputs, was: " + src.getColor() + ", " + dst.getColor());
        }
        var dataSrc = src.getPlaneData(0);
        var dataDst = dst.getPlaneData(0);
        for (var i = 0; i < dataSrc.length; i += 3) {
            var tmp = dataSrc[i + 2];
            dataDst[i + 2] = dataSrc[i];
            dataDst[i] = tmp;
            dataDst[i + 1] = dataSrc[i + 1];
        }
    };
}, {}, {});
var TimecodeBoxes = function() {
    Boxes.call(this);
};
TimecodeBoxes = stjs.extend(TimecodeBoxes, Boxes, [], null, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var RgbToYuv422pHiBD = function(upShift, downShift) {
    this.upShift = upShift;
    this.downShift = downShift;
    this.downShiftChr = downShift + 1;
};
RgbToYuv422pHiBD = stjs.extend(RgbToYuv422pHiBD, null, [TransformHiBD], function(constructor, prototype) {
    prototype.upShift = 0;
    prototype.downShift = 0;
    prototype.downShiftChr = 0;
    prototype.transform = function(img, dst) {
        var y = img.getData()[0];
        var dstData = dst.getData();
        var off = 0, offSrc = 0;
        for (var i = 0; i < img.getHeight(); i++) {
            for (var j = 0; j < img.getWidth() >> 1; j++) {
                dstData[1][off] = 0;
                dstData[2][off] = 0;
                var offY = off << 1;
                RgbToYuv420pHiBD.rgb2yuv(y[offSrc++], y[offSrc++], y[offSrc++], dstData[0], offY, dstData[1], off, dstData[2], off);
                dstData[0][offY] = (dstData[0][offY] << this.upShift) >> this.downShift;
                RgbToYuv420pHiBD.rgb2yuv(y[offSrc++], y[offSrc++], y[offSrc++], dstData[0], offY + 1, dstData[1], off, dstData[2], off);
                dstData[0][offY + 1] = (dstData[0][offY + 1] << this.upShift) >> this.downShift;
                dstData[1][off] = (dstData[1][off] << this.upShift) >> this.downShiftChr;
                dstData[2][off] = (dstData[2][off] << this.upShift) >> this.downShiftChr;
                ++off;
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv420pToRgbHiBD = function(upShift, downShift) {
    this.upShift = upShift;
    this.downShift = downShift;
};
Yuv420pToRgbHiBD = stjs.extend(Yuv420pToRgbHiBD, null, [TransformHiBD], function(constructor, prototype) {
    prototype.downShift = 0;
    prototype.upShift = 0;
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        var offLuma = 0, offChroma = 0;
        var stride = dst.getWidth();
        for (var i = 0; i < (dst.getHeight() >> 1); i++) {
            for (var k = 0; k < (dst.getWidth() >> 1); k++) {
                var j = k << 1;
                Yuv422pToRgbHiBD.YUV444toRGB888((y[offLuma + j] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j) * 3);
                Yuv422pToRgbHiBD.YUV444toRGB888((y[offLuma + j + 1] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j + 1) * 3);
                Yuv422pToRgbHiBD.YUV444toRGB888((y[offLuma + j + stride] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j + stride) * 3);
                Yuv422pToRgbHiBD.YUV444toRGB888((y[offLuma + j + stride + 1] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j + stride + 1) * 3);
                ++offChroma;
            }
            if ((dst.getWidth() & 1) != 0) {
                var j = dst.getWidth() - 1;
                Yuv422pToRgbHiBD.YUV444toRGB888((y[offLuma + j] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j) * 3);
                Yuv422pToRgbHiBD.YUV444toRGB888((y[offLuma + j + stride] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j + stride) * 3);
                ++offChroma;
            }
            offLuma += 2 * stride;
        }
        if ((dst.getHeight() & 1) != 0) {
            for (var k = 0; k < (dst.getWidth() >> 1); k++) {
                var j = k << 1;
                Yuv422pToRgbHiBD.YUV444toRGB888((y[offLuma + j] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j) * 3);
                Yuv422pToRgbHiBD.YUV444toRGB888((y[offLuma + j + 1] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j + 1) * 3);
                ++offChroma;
            }
            if ((dst.getWidth() & 1) != 0) {
                var j = dst.getWidth() - 1;
                Yuv422pToRgbHiBD.YUV444toRGB888((y[offLuma + j] << this.upShift) >> this.downShift, (u[offChroma] << this.upShift) >> this.downShift, (v[offChroma] << this.upShift) >> this.downShift, data, (offLuma + j) * 3);
                ++offChroma;
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Estimates motion using diagonal search
 *  
 *  @author Stanislav Vitvitskyy
 */
var MotionEstimator = function(maxSearchRange) {
    this.maxSearchRange = maxSearchRange;
};
MotionEstimator = stjs.extend(MotionEstimator, null, [], function(constructor, prototype) {
    prototype.maxSearchRange = 0;
    prototype.estimate = function(ref, patch, mbX, mbY, mvpx, mvpy) {
        var searchPatch = new Int8Array((this.maxSearchRange * 2 + 16) * (this.maxSearchRange * 2 + 16));
        var startX = (mbX << 4);
        var startY = (mbY << 4);
        var patchTlX = Math.max(startX - this.maxSearchRange, 0);
        var patchTlY = Math.max(startY - this.maxSearchRange, 0);
        var patchBrX = Math.min(startX + this.maxSearchRange + 16, ref.getPlaneWidth(0));
        var patchBrY = Math.min(startY + this.maxSearchRange + 16, ref.getPlaneHeight(0));
        var centerX = startX - patchTlX;
        var centerY = startY - patchTlY;
        var patchW = patchBrX - patchTlX;
        var patchH = patchBrY - patchTlY;
        MBEncoderHelper.takeSafe(ref.getPlaneData(0), ref.getPlaneWidth(0), ref.getPlaneHeight(0), patchTlX, patchTlY, searchPatch, patchW, patchH);
        var bestMvX = centerX, bestMvY = centerY;
        var bestScore = this.sad(searchPatch, patchW, patch, bestMvX, bestMvY);
        for (var i = 0; i < this.maxSearchRange; i++) {
            var score1 = bestMvX > 0 ? this.sad(searchPatch, patchW, patch, bestMvX - 1, bestMvY) : Integer.MAX_VALUE;
            var score2 = bestMvX < patchW - 1 ? this.sad(searchPatch, patchW, patch, bestMvX + 1, bestMvY) : Integer.MAX_VALUE;
            var score3 = bestMvY > 0 ? this.sad(searchPatch, patchW, patch, bestMvX, bestMvY - 1) : Integer.MAX_VALUE;
            var score4 = bestMvY < patchH - 1 ? this.sad(searchPatch, patchW, patch, bestMvX, bestMvY + 1) : Integer.MAX_VALUE;
            var min = Math.min(Math.min(Math.min(score1, score2), score3), score4);
            if (min > bestScore) 
                break;
            bestScore = min;
            if (score1 == min) {
                --bestMvX;
            } else if (score2 == min) {
                ++bestMvX;
            } else if (score3 == min) {
                --bestMvY;
            } else {
                ++bestMvY;
            }
        }
        return new Int32Array([((bestMvX - centerX) << 2), ((bestMvY - centerY) << 2)]);
    };
    prototype.sad = function(big, bigStride, small, offX, offY) {
        var score = 0, bigOff = offY * bigStride + offX, smallOff = 0;
        for (var i = 0; i < 16; i++) {
            for (var j = 0; j < 16; j++ , ++bigOff , ++smallOff) {
                score += MathUtil.abs(big[bigOff] - small[smallOff]);
            }
            bigOff += bigStride - 16;
        }
        return score;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv422jToRgbHiBD = function() {};
Yuv422jToRgbHiBD = stjs.extend(Yuv422jToRgbHiBD, null, [TransformHiBD], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        var offLuma = 0, offChroma = 0;
        for (var i = 0; i < dst.getHeight(); i++) {
            for (var j = 0; j < dst.getWidth(); j += 2) {
                Yuv420jToRgbHiBD.YUVJtoRGB(y[offLuma], u[offChroma], v[offChroma], data, offLuma * 3);
                Yuv420jToRgbHiBD.YUVJtoRGB(y[offLuma + 1], u[offChroma], v[offChroma], data, (offLuma + 1) * 3);
                offLuma += 2;
                ++offChroma;
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Yuv444jToRgbHiBD = function() {};
Yuv444jToRgbHiBD = stjs.extend(Yuv444jToRgbHiBD, null, [TransformHiBD], function(constructor, prototype) {
    prototype.transform = function(src, dst) {
        var y = src.getPlaneData(0);
        var u = src.getPlaneData(1);
        var v = src.getPlaneData(2);
        var data = dst.getPlaneData(0);
        for (var i = 0, srcOff = 0, dstOff = 0; i < dst.getHeight(); i++) {
            for (var j = 0; j < dst.getWidth(); j++ , srcOff++ , dstOff += 3) {
                Yuv420jToRgbHiBD.YUVJtoRGB(y[srcOff], u[srcOff], v[srcOff], data, dstOff);
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Reference picture marking used for IDR frames
 *  
 *  @author The JCodec project
 *  
 */
var RefPicMarkingIDR = function(discardDecodedPics, useForlongTerm) {
    this.discardDecodedPics = discardDecodedPics;
    this.useForlongTerm = useForlongTerm;
};
RefPicMarkingIDR = stjs.extend(RefPicMarkingIDR, null, [], function(constructor, prototype) {
    prototype.discardDecodedPics = false;
    prototype.useForlongTerm = false;
    prototype.isDiscardDecodedPics = function() {
        return this.discardDecodedPics;
    };
    prototype.isUseForlongTerm = function() {
        return this.useForlongTerm;
    };
    prototype.toString = function() {
        return Platform.toJSON(this);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlBase = function(id) {
    this.id = id;
};
EbmlBase = stjs.extend(EbmlBase, null, [], function(constructor, prototype) {
    prototype.parent = null;
    prototype.type = null;
    prototype.id = null;
    prototype.dataLen = 0;
    prototype.offset = 0;
    prototype.dataOffset = 0;
    prototype.typeSizeLength = 0;
    prototype.equalId = function(typeId) {
        return Platform.arrayEqualsByte(this.id, typeId);
    };
    prototype.getData = function() {};
    prototype.size = function() {
        return this.dataLen + EbmlUtil.ebmlLength(this.dataLen) + this.id.length;
    };
    prototype.mux = function(os) {
        var bb = this.getData();
        return os.write(bb);
    };
}, {parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var StringReader = function() {};
StringReader = stjs.extend(StringReader, null, [], function(constructor, prototype) {
    constructor.readString = function(input, len) {
        var bs = StringReader._sureRead(input, len);
        return bs == null ? null : Platform.stringFromBytes(bs);
    };
    constructor._sureRead = function(input, len) {
        var res = new Int8Array(len);
        if (StringReader.sureRead(input, res, res.length) == len) 
            return res;
        return null;
    };
    constructor.sureRead = function(input, buf, len) {
        var read = 0;
         while (read < len){
            var tmp = input.read(buf, read, len - read);
            if (tmp == -1) 
                break;
            read += tmp;
        }
        return read;
    };
    constructor.sureSkip = function(is, l) {
         while (l > 0)
            l -= is.skip(l);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A script of instructions applied to reference picture list
 *  
 *  @author The JCodec project
 *  
 */
var RefPicMarking = function(instructions) {
    this.instructions = instructions;
};
RefPicMarking = stjs.extend(RefPicMarking, null, [], function(constructor, prototype) {
    constructor.InstrType = stjs.enumeration("REMOVE_SHORT", "REMOVE_LONG", "CONVERT_INTO_LONG", "TRUNK_LONG", "CLEAR", "MARK_LONG");
    constructor.Instruction = function(type, arg1, arg2) {
        this.type = type;
        this.arg1 = arg1;
        this.arg2 = arg2;
    };
    constructor.Instruction = stjs.extend(constructor.Instruction, null, [], function(constructor, prototype) {
        prototype.type = null;
        prototype.arg1 = 0;
        prototype.arg2 = 0;
        prototype.getType = function() {
            return this.type;
        };
        prototype.getArg1 = function() {
            return this.arg1;
        };
        prototype.getArg2 = function() {
            return this.arg2;
        };
    }, {type: {name: "Enum", arguments: ["RefPicMarking.InstrType"]}}, {});
    prototype.instructions = null;
    prototype.getInstructions = function() {
        return this.instructions;
    };
    prototype.toString = function() {
        return Platform.toJSON(this);
    };
}, {instructions: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MetaValue = function(type, locale, data) {
    this.type = type;
    this.locale = locale;
    this.data = data;
};
MetaValue = stjs.extend(MetaValue, null, [], function(constructor, prototype) {
    constructor.TYPE_STRING_UTF16 = 2;
    constructor.TYPE_STRING_UTF8 = 1;
    constructor.TYPE_FLOAT_64 = 24;
    constructor.TYPE_FLOAT_32 = 23;
    constructor.TYPE_INT_32 = 67;
    constructor.TYPE_INT_16 = 66;
    constructor.TYPE_INT_8 = 65;
    constructor.TYPE_INT_V = 22;
    constructor.TYPE_UINT_V = 21;
    constructor.TYPE_JPEG = 13;
    constructor.TYPE_PNG = 13;
    constructor.TYPE_BMP = 27;
    prototype.type = 0;
    prototype.locale = 0;
    prototype.data = null;
    constructor.createInt = function(value) {
        return new MetaValue(21, 0, MetaValue.fromInt(value));
    };
    constructor.createFloat = function(value) {
        return new MetaValue(23, 0, MetaValue.fromFloat(value));
    };
    constructor.createString = function(value) {
        return new MetaValue(1, 0, Platform.getBytesForCharset(value, Platform.UTF_8));
    };
    constructor.createOther = function(type, data) {
        return new MetaValue(type, 0, data);
    };
    constructor.createOtherWithLocale = function(type, locale, data) {
        return new MetaValue(type, locale, data);
    };
    prototype.getInt = function() {
        if (this.type == MetaValue.TYPE_UINT_V || this.type == MetaValue.TYPE_INT_V) {
            switch (this.data.length) {
                case 1:
                    return this.data[0];
                case 2:
                    return this.toInt16(this.data);
                case 3:
                    return this.toInt24(this.data);
                case 4:
                    return this.toInt32(this.data);
            }
        }
        if (this.type == MetaValue.TYPE_INT_8) 
            return this.data[0];
        if (this.type == MetaValue.TYPE_INT_16) 
            return this.toInt16(this.data);
        if (this.type == MetaValue.TYPE_INT_32) 
            return this.toInt32(this.data);
        return 0;
    };
    prototype.getFloat = function() {
        if (this.type == MetaValue.TYPE_FLOAT_32) 
            return this.toFloat(this.data);
        if (this.type == MetaValue.TYPE_FLOAT_64) 
            return this.toDouble(this.data);
        return 0;
    };
    prototype.getString = function() {
        if (this.type == MetaValue.TYPE_STRING_UTF8) 
            return Platform.stringFromCharset(this.data, Platform.UTF_8);
        if (this.type == MetaValue.TYPE_STRING_UTF16) {
            return Platform.stringFromCharset(this.data, Platform.UTF_16BE);
        }
        return null;
    };
    prototype.isInt = function() {
        return this.type == MetaValue.TYPE_UINT_V || this.type == MetaValue.TYPE_INT_V || this.type == MetaValue.TYPE_INT_8 || this.type == MetaValue.TYPE_INT_16 || this.type == MetaValue.TYPE_INT_32;
    };
    prototype.isString = function() {
        return this.type == MetaValue.TYPE_STRING_UTF8 || this.type == MetaValue.TYPE_STRING_UTF16;
    };
    prototype.isFloat = function() {
        return this.type == MetaValue.TYPE_FLOAT_32 || this.type == MetaValue.TYPE_FLOAT_64;
    };
    prototype.toString = function() {
        if (this.isInt()) 
            return String.valueOf(this.getInt());
         else if (this.isFloat()) 
            return String.valueOf(this.getFloat());
         else if (this.isString()) 
            return String.valueOf(this.getString());
         else 
            return "BLOB";
    };
    prototype.getType = function() {
        return this.type;
    };
    prototype.getLocale = function() {
        return this.locale;
    };
    prototype.getData = function() {
        return this.data;
    };
    constructor.fromFloat = function(floatValue) {
        var bytes = new Int8Array(4);
        var bb = ByteBuffer.wrap(bytes);
        bb.order(ByteOrder.BIG_ENDIAN);
        bb.putFloat(floatValue);
        return bytes;
    };
    constructor.fromInt = function(value) {
        var bytes = new Int8Array(4);
        var bb = ByteBuffer.wrap(bytes);
        bb.order(ByteOrder.BIG_ENDIAN);
        bb.putInt(value);
        return bytes;
    };
    prototype.toInt16 = function(data) {
        var bb = ByteBuffer.wrap(data);
        bb.order(ByteOrder.BIG_ENDIAN);
        return bb.getShort();
    };
    prototype.toInt24 = function(data) {
        var bb = ByteBuffer.wrap(data);
        bb.order(ByteOrder.BIG_ENDIAN);
        return ((bb.getShort() & 65535) << 8) | (bb.get() & 255);
    };
    prototype.toInt32 = function(data) {
        var bb = ByteBuffer.wrap(data);
        bb.order(ByteOrder.BIG_ENDIAN);
        return bb.getInt();
    };
    prototype.toFloat = function(data) {
        var bb = ByteBuffer.wrap(data);
        bb.order(ByteOrder.BIG_ENDIAN);
        return bb.getFloat();
    };
    prototype.toDouble = function(data) {
        var bb = ByteBuffer.wrap(data);
        bb.order(ByteOrder.BIG_ENDIAN);
        return bb.getDouble();
    };
    prototype.isBlob = function() {
        return !this.isFloat() && !this.isInt() && !this.isString();
    };
}, {data: "Int8Array"}, {});
var Fourcc = function() {};
Fourcc = stjs.extend(Fourcc, null, [], function(constructor, prototype) {
    constructor.makeInt = function(b3, b2, b1, b0) {
        return (((b3) << 24) | ((b2 & 255) << 16) | ((b1 & 255) << 8) | ((b0 & 255)));
    };
    constructor.intFourcc = function(string) {
        var b = Platform.getBytes(string);
        return Fourcc.makeInt(b[0], b[1], b[2], b[3]);
    };
    constructor.ftyp = Fourcc.intFourcc("ftyp");
    constructor.free = Fourcc.intFourcc("free");
    constructor.moov = Fourcc.intFourcc("moov");
    constructor.mdat = Fourcc.intFourcc("mdat");
    constructor.wide = Fourcc.intFourcc("wide");
}, {}, {});
var JCodecUtil2 = function() {};
JCodecUtil2 = stjs.extend(JCodecUtil2, null, [], function(constructor, prototype) {
    constructor.writeBER32 = function(buffer, value) {
        buffer.put((((value >> 21) | 128) << 24 >> 24));
        buffer.put((((value >> 14) | 128) << 24 >> 24));
        buffer.put((((value >> 7) | 128) << 24 >> 24));
        buffer.put(((value & 127) << 24 >> 24));
    };
    constructor.readBER32 = function(input) {
        var size = 0;
        for (var i = 0; i < 4; i++) {
            var b = input.get();
            size = (size << 7) | (b & 127);
            if (((b & 255) >> 7) == 0) 
                break;
        }
        return size;
    };
    constructor.writeBER32Var = function(bb, value) {
        for (var i = 0, bits = MathUtil.log2(value); i < 4 && bits > 0; i++) {
            bits -= 7;
            var out = value >> bits;
            if (bits > 0) 
                out |= 128;
            bb.put((out << 24 >> 24));
        }
    };
    constructor.asciiString = function(fourcc) {
        return Platform.getBytes(fourcc);
    };
    constructor.getAsIntArray = function(yuv, size) {
        var b = new Int8Array(size);
        var result = new Int32Array(size);
        yuv.getBuf(b);
        for (var i = 0; i < b.length; i++) {
            result[i] = b[i] & 255;
        }
        return result;
    };
    constructor.removeExtension = function(name) {
        if (name == null) 
            return null;
        return name.replaceAll("\\.[^\\.]+$", "");
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Slice header H264 bitstream entity
 *  
 *  capable to serialize / deserialize with CAVLC bitstream
 *  
 *  @author The JCodec project
 *  
 */
var SliceHeader = function() {
    this.numRefIdxActiveMinus1 = new Int32Array(2);
};
SliceHeader = stjs.extend(SliceHeader, null, [], function(constructor, prototype) {
    prototype.sps = null;
    prototype.pps = null;
    prototype.refPicMarkingNonIDR = null;
    prototype.refPicMarkingIDR = null;
    prototype.refPicReordering = null;
    prototype.predWeightTable = null;
    prototype.firstMbInSlice = 0;
    prototype.fieldPicFlag = false;
    prototype.sliceType = null;
    prototype.sliceTypeRestr = false;
    prototype.picParameterSetId = 0;
    prototype.frameNum = 0;
    prototype.bottomFieldFlag = false;
    prototype.idrPicId = 0;
    prototype.picOrderCntLsb = 0;
    prototype.deltaPicOrderCntBottom = 0;
    prototype.deltaPicOrderCnt = null;
    prototype.redundantPicCnt = 0;
    prototype.directSpatialMvPredFlag = false;
    prototype.numRefIdxActiveOverrideFlag = false;
    prototype.numRefIdxActiveMinus1 = null;
    prototype.cabacInitIdc = 0;
    prototype.sliceQpDelta = 0;
    prototype.spForSwitchFlag = false;
    prototype.sliceQsDelta = 0;
    prototype.disableDeblockingFilterIdc = 0;
    prototype.sliceAlphaC0OffsetDiv2 = 0;
    prototype.sliceBetaOffsetDiv2 = 0;
    prototype.sliceGroupChangeCycle = 0;
    prototype.toString = function() {
        return Platform.toJSON(this);
    };
}, {sps: "SeqParameterSet", pps: "PictureParameterSet", refPicMarkingNonIDR: "RefPicMarking", refPicMarkingIDR: "RefPicMarkingIDR", refPicReordering: "Array", predWeightTable: "PredictionWeightTable", sliceType: "SliceType", deltaPicOrderCnt: "Int32Array", numRefIdxActiveMinus1: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  FLV metadata
 *  
 *  @author Stan Vitvitskyy
 *  
 */
var FLVMetadata = function(md) {
    var declaredFields = Platform.getDeclaredFields(this.getClass());
    for (var i = 0; i < declaredFields.length; i++) {
        var field = declaredFields[i];
        var object = md.get(field.getName());
        try {
            if (stjs.isInstanceOf(object.constructor, Double)) {
                field.setDouble(this, object);
            } else if (stjs.isInstanceOf(object.constructor, Boolean)) {
                field.setBoolean(this, object);
            } else {
                field.set(this, object);
            }
        }catch (e) {}
    }
};
FLVMetadata = stjs.extend(FLVMetadata, null, [], function(constructor, prototype) {
    prototype.duration = 0.0;
    prototype.width = 0.0;
    prototype.height = 0.0;
    prototype.framerate = 0.0;
    prototype.audiocodecid = null;
    prototype.videokeyframe_frequency = 0.0;
    prototype.videodevice = null;
    prototype.avclevel = 0.0;
    prototype.audiosamplerate = 0.0;
    prototype.audiochannels = 0.0;
    prototype.presetname = null;
    prototype.videodatarate = 0.0;
    prototype.audioinputvolume = 0.0;
    prototype.creationdate = null;
    prototype.videocodecid = null;
    prototype.avcprofile = 0.0;
    prototype.audiodevice = null;
    prototype.audiodatarate = 0.0;
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.getFramerate = function() {
        return this.framerate;
    };
    prototype.getAudiocodecid = function() {
        return this.audiocodecid;
    };
    prototype.getVideokeyframe_frequency = function() {
        return this.videokeyframe_frequency;
    };
    prototype.getVideodevice = function() {
        return this.videodevice;
    };
    prototype.getAvclevel = function() {
        return this.avclevel;
    };
    prototype.getAudiosamplerate = function() {
        return this.audiosamplerate;
    };
    prototype.getAudiochannels = function() {
        return this.audiochannels;
    };
    prototype.getPresetname = function() {
        return this.presetname;
    };
    prototype.getVideodatarate = function() {
        return this.videodatarate;
    };
    prototype.getAudioinputvolume = function() {
        return this.audioinputvolume;
    };
    prototype.getCreationdate = function() {
        return this.creationdate;
    };
    prototype.getVideocodecid = function() {
        return this.videocodecid;
    };
    prototype.getAvcprofile = function() {
        return this.avcprofile;
    };
    prototype.getAudiodevice = function() {
        return this.audiodevice;
    };
    prototype.getAudiodatarate = function() {
        return this.audiodatarate;
    };
}, {creationdate: "jsutil.Date"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Table-based prefix VLC reader
 *  
 *  @author The JCodec project
 *  
 */
var VLC = function(codes, codeSizes) {
    this.codes = codes;
    this.codeSizes = codeSizes;
    this._invert();
};
VLC = stjs.extend(VLC, null, [], function(constructor, prototype) {
    /**
     *  @param arguments
     *             vlc codes
     *  @return
     */
    constructor.createVLC = function(_arguments) {
        var _codes = IntArrayList.createIntArrayList();
        var _codeSizes = IntArrayList.createIntArrayList();
        for (var i = 0; i < arguments.length; i++) {
            var string = arguments[i];
            _codes.add(Integer.parseInt(string, 2) << (32 - string.length));
            _codeSizes.add(string.length);
        }
        var vlc = new VLC(_codes.toArray(), _codeSizes.toArray());
        return vlc;
    };
    prototype.codes = null;
    prototype.codeSizes = null;
    prototype.values = null;
    prototype.valueSizes = null;
    prototype._invert = function() {
        var values = IntArrayList.createIntArrayList();
        var valueSizes = IntArrayList.createIntArrayList();
        this.invert(0, 0, 0, values, valueSizes);
        this.values = values.toArray();
        this.valueSizes = valueSizes.toArray();
    };
    prototype.invert = function(startOff, level, prefix, values, valueSizes) {
        var tableEnd = startOff + 256;
        values.fill(startOff, tableEnd, -1);
        valueSizes.fill(startOff, tableEnd, 0);
        var prefLen = level << 3;
        for (var i = 0; i < this.codeSizes.length; i++) {
            if ((this.codeSizes[i] <= prefLen) || (level > 0 && (this.codes[i] >>> (32 - prefLen)) != prefix)) 
                continue;
            var pref = this.codes[i] >>> (32 - prefLen - 8);
            var code = pref & 255;
            var len = this.codeSizes[i] - prefLen;
            if (len <= 8) {
                for (var k = 0; k < (1 << (8 - len)); k++) {
                    values.set(startOff + code + k, i);
                    valueSizes.set(startOff + code + k, len);
                }
            } else {
                if (values.get(startOff + code) == -1) {
                    values.set(startOff + code, tableEnd);
                    tableEnd = this.invert(tableEnd, level + 1, pref, values, valueSizes);
                }
            }
        }
        return tableEnd;
    };
    prototype.readVLC16 = function(_in) {
        var string = _in.check16Bits();
        var b = string >>> 8;
        var code = this.values[b];
        var len = this.valueSizes[b];
        if (len == 0) {
            b = (string & 255) + code;
            code = this.values[b];
            _in.skipFast(8 + this.valueSizes[b]);
        } else 
            _in.skipFast(len);
        return code;
    };
    prototype.readVLC = function(_in) {
        var code = 0, len = 0, overall = 0, total = 0;
        for (var i = 0; len == 0; i++) {
            var string = _in.checkNBit(8);
            var ind = string + code;
            code = this.values[ind];
            len = this.valueSizes[ind];
            var bits = len != 0 ? len : 8;
            total += bits;
            overall = (overall << bits) | (string >> (8 - bits));
            _in.skip(bits);
            if (code == -1) 
                 throw new RuntimeException("Invalid code prefix " + this.binary(overall, (i << 3) + bits));
        }
        return code;
    };
    prototype.binary = function(string, len) {
        var symb = new Uint16Array(len);
        for (var i = 0; i < len; i++) {
            symb[i] = (string & (1 << (len - i - 1))) != 0 ? '1'.charCodeAt(0) : '0'.charCodeAt(0);
        }
        return new String(symb);
    };
    prototype.writeVLC = function(out, code) {
        out.writeNBit(this.codes[code] >>> (32 - this.codeSizes[code]), this.codeSizes[code]);
    };
    prototype.printTable = function(ps) {
        for (var i = 0; i < this.values.length; i++) {
            ps.println(i + ": " + this.extracted(i) + " (" + this.valueSizes[i] + ") -> " + this.values[i]);
        }
    };
    prototype.extracted = function(num) {
        var str = Integer.toString(num & 255, 2);
        var builder = new StringBuilder();
        for (var i = 0; i < 8 - str.length; i++) 
            builder.append('0'.charCodeAt(0));
        builder.append(str);
        return builder.toString();
    };
    prototype.getCodes = function() {
        return this.codes;
    };
    prototype.getCodeSizes = function() {
        return this.codeSizes;
    };
}, {codes: "Int32Array", codeSizes: "Int32Array", values: "Int32Array", valueSizes: "Int32Array"}, {});
var IntIntHistogram = function() {
    IntIntMap.call(this);
};
IntIntHistogram = stjs.extend(IntIntHistogram, IntIntMap, [], function(constructor, prototype) {
    prototype.maxBin = -1;
    prototype.max = function() {
        return this.maxBin;
    };
    prototype.increment = function(bin) {
        var count = this.get(bin);
        count = count == Integer.MIN_VALUE ? 1 : 1 + count;
        this.put(bin, count);
        if (this.maxBin == -1) 
            this.maxBin = bin;
        var maxCount = this.get(this.maxBin);
        if (count > maxCount) {
            this.maxBin = bin;
            maxCount = count;
        }
    };
}, {storage: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Represents PAT ( Program Association Table ) PSI payload of MPEG Transport
 *  stream
 *  
 *  @author The JCodec project
 *  
 */
var PATSection = function(psi, networkPids, programs) {
    PSISection.call(this, psi.tableId, psi.specificId, psi.versionNumber, psi.currentNextIndicator, psi.sectionNumber, psi.lastSectionNumber);
    this.networkPids = networkPids;
    this.programs = programs;
};
PATSection = stjs.extend(PATSection, PSISection, [], function(constructor, prototype) {
    prototype.networkPids = null;
    prototype.programs = null;
    prototype.getNetworkPids = function() {
        return this.networkPids;
    };
    prototype.getPrograms = function() {
        return this.programs;
    };
    constructor.parsePAT = function(data) {
        var psi = PSISection.parsePSI(data);
        var networkPids = IntArrayList.createIntArrayList();
        var programs = new IntIntMap();
         while (data.remaining() > 4){
            var programNum = data.getShort() & 65535;
            var w = data.getShort();
            var pid = w & 8191;
            if (programNum == 0) 
                networkPids.add(pid);
             else 
                programs.put(programNum, pid);
        }
        return new PATSection(psi, networkPids.toArray(), programs);
    };
}, {networkPids: "Int32Array", programs: "IntIntMap"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var InterModeInfo = function(segmentId, skip, txSize, yMode, subModes, uvMode, mvl0, mvl1, mvl2, mvl3) {
    ModeInfo.call(this, segmentId, skip, txSize, yMode, subModes, uvMode);
    this.mvl0 = mvl0;
    this.mvl1 = mvl1;
    this.mvl2 = mvl2;
    this.mvl3 = mvl3;
};
InterModeInfo = stjs.extend(InterModeInfo, ModeInfo, [], function(constructor, prototype) {
    prototype.mvl0 = 0;
    prototype.mvl1 = 0;
    prototype.mvl2 = 0;
    prototype.mvl3 = 0;
    prototype.isInter = function() {
        return true;
    };
    prototype.getMvl0 = function() {
        return this.mvl0;
    };
    prototype.getMvl1 = function() {
        return this.mvl1;
    };
    prototype.getMvl2 = function() {
        return this.mvl2;
    };
    prototype.getMvl3 = function() {
        return this.mvl3;
    };
    constructor.readInter = function(miCol, miRow, blSz, decoder, probs, c) {
        var segmentId = 0;
        if (c.isSegmentationEnabled()) {
            segmentId = InterModeInfo.predicSegmentId(miCol, miRow, blSz, c);
            if (c.isUpdateSegmentMap()) {
                if (!c.isSegmentMapConditionalUpdate() || !InterModeInfo.readSegIdPredicted(miCol, miRow, blSz, decoder, probs, c)) {
                    segmentId = ModeInfo.readSegmentId(decoder, probs);
                }
            }
        }
        var skip = true;
        if (!c.isSegmentFeatureActive(segmentId, Consts.SEG_LVL_SKIP)) 
            skip = ModeInfo.readSkipFlag(miCol, miRow, blSz, decoder, probs, c);
        var isInter = c.getSegmentFeature(segmentId, Consts.SEG_LVL_REF_FRAME) != Consts.INTRA_FRAME;
        if (!c.isSegmentFeatureActive(segmentId, Consts.SEG_LVL_REF_FRAME)) 
            isInter = InterModeInfo.readIsInter(miCol, miRow, blSz, decoder, probs, c);
        var txSize = ModeInfo.readTxSize(miCol, miRow, blSz, !skip || !isInter, decoder, probs, c);
        if (!isInter) 
            return InterModeInfo.readIntraSpecificMode(miCol, miRow, blSz, decoder, probs, c, segmentId, skip, txSize);
         else 
            return InterModeInfo.readInterSpecificMode(miCol, miRow, blSz, decoder, probs, c, segmentId, skip, txSize);
    };
    constructor.readInterSpecificMode = function(miCol, miRow, blSz, decoder, probStore, c, segmentId, skip, txSize) {
        var packedRefFrames = InterModeInfo.readRefFrames(miCol, miRow, blSz, segmentId, decoder, probStore, c);
        var lumaMode = Consts.ZEROMV;
        if (!c.isSegmentFeatureActive(segmentId, Consts.SEG_LVL_SKIP)) {
            if (blSz >= Consts.BLOCK_8X8) {
                lumaMode = InterModeInfo.readLumaMode(miCol, miRow, blSz, decoder, probStore, c);
            }
        }
        var interpFilter = c.getInterpFilter();
        if (interpFilter == Consts.SWITCHABLE) {
            interpFilter = InterModeInfo.readInterpFilter(miCol, miRow, blSz, decoder, probStore, c);
        }
        if (blSz < Consts.BLOCK_8X8) {
            if (blSz == Consts.BLOCK_4X4) {
                return InterModeInfo.readMV4x4(miCol, miRow, blSz, decoder, probStore, c, segmentId, skip, txSize, packedRefFrames);
            } else {
                return InterModeInfo.readMvSub8x8(miCol, miRow, blSz, decoder, probStore, c, segmentId, skip, txSize, packedRefFrames);
            }
        } else {
            return InterModeInfo.readMV8x8(miCol, miRow, blSz, decoder, probStore, c, segmentId, skip, txSize, packedRefFrames, lumaMode);
        }
    };
    constructor.readMV8x8 = function(miCol, miRow, blSz, decoder, probStore, c, segmentId, skip, txSize, packedRefFrames, lumaMode) {
        var mvl = InterModeInfo.readSub0(miCol, miRow, blSz, decoder, probStore, c, lumaMode, packedRefFrames);
        InterModeInfo.updateMVLineBuffers(miCol, miRow, blSz, c, mvl);
        InterModeInfo.updateMVLineBuffers4x4(miCol, miRow, blSz, c, mvl, mvl);
        return new InterModeInfo(segmentId, skip, txSize, lumaMode, 0, lumaMode, mvl, 0, 0, 0);
    };
    constructor.readMvSub8x8 = function(miCol, miRow, blSz, decoder, probStore, c, segmentId, skip, txSize, packedRefFrames) {
        var subMode0 = InterModeInfo.readLumaMode(miCol, miRow, blSz, decoder, probStore, c);
        var mvl0 = InterModeInfo.readSub0(miCol, miRow, blSz, decoder, probStore, c, subMode0, packedRefFrames);
        var subMode1 = InterModeInfo.readLumaMode(miCol, miRow, blSz, decoder, probStore, c);
        var blk = blSz == Consts.BLOCK_4X8 ? 1 : 2;
        var mvl1 = InterModeInfo.readSub12(miCol, miRow, blSz, decoder, probStore, c, mvl0, subMode1, blk, packedRefFrames);
        if (blSz == Consts.BLOCK_4X8) {
            InterModeInfo.updateMVLineBuffers4x4(miCol, miRow, blSz, c, mvl1, mvl0);
        } else {
            InterModeInfo.updateMVLineBuffers4x4(miCol, miRow, blSz, c, mvl0, mvl1);
        }
        InterModeInfo.updateMVLineBuffers(miCol, miRow, blSz, c, mvl1);
        var subModes = (subMode0 << 8) | subMode1;
        return new InterModeInfo(segmentId, skip, txSize, 0, subModes, 0, mvl0, mvl1, 0, 0);
    };
    constructor.readMV4x4 = function(miCol, miRow, blSz, decoder, probStore, c, segmentId, skip, txSize, packedRefFrames) {
        var subMode0 = InterModeInfo.readLumaMode(miCol, miRow, blSz, decoder, probStore, c);
        var mvl0 = InterModeInfo.readSub0(miCol, miRow, blSz, decoder, probStore, c, subMode0, packedRefFrames);
        var subMode1 = InterModeInfo.readLumaMode(miCol, miRow, blSz, decoder, probStore, c);
        var mvl1 = InterModeInfo.readSub12(miCol, miRow, blSz, decoder, probStore, c, mvl0, subMode1, 1, packedRefFrames);
        var subMode2 = InterModeInfo.readLumaMode(miCol, miRow, blSz, decoder, probStore, c);
        var mvl2 = InterModeInfo.readSub12(miCol, miRow, blSz, decoder, probStore, c, mvl0, subMode2, 2, packedRefFrames);
        var subMode3 = InterModeInfo.readLumaMode(miCol, miRow, blSz, decoder, probStore, c);
        var mvl3 = InterModeInfo.readMvSub3(miCol, miRow, blSz, decoder, probStore, c, mvl0, mvl1, mvl2, subMode3, packedRefFrames);
        InterModeInfo.updateMVLineBuffers(miCol, miRow, blSz, c, mvl3);
        InterModeInfo.updateMVLineBuffers4x4(miCol, miRow, blSz, c, mvl1, mvl2);
        var subModes = (subMode0 << 24) | (subMode1 << 16) | (subMode2 << 8) | subMode3;
        return new InterModeInfo(segmentId, skip, txSize, -1, subModes, -1, mvl0, mvl1, mvl2, mvl3);
    };
    constructor.readSub0 = function(miCol, miRow, blSz, decoder, probStore, c, lumaMode, packedRefFrames) {
        var ref0 = Packed4BitList.get(packedRefFrames, 0);
        var ref1 = Packed4BitList.get(packedRefFrames, 1);
        var compoundPred = Packed4BitList.get(packedRefFrames, 2) == 1;
        var nearestNearMv00 = InterModeInfo.findBestMv(miCol, miRow, blSz, ref0, 0, c, true);
        var nearestNearMv01 = 0;
        if (compoundPred) 
            nearestNearMv01 = InterModeInfo.findBestMv(miCol, miRow, blSz, ref1, 0, c, true);
        var mv0 = 0, mv1 = 0;
        if (lumaMode == Consts.NEWMV) {
            mv0 = InterModeInfo.readDiffMv(decoder, probStore, c, nearestNearMv00);
            if (compoundPred) 
                mv1 = InterModeInfo.readDiffMv(decoder, probStore, c, nearestNearMv01);
        } else if (lumaMode != Consts.ZEROMV) {
            mv0 = MVList.get(nearestNearMv00, lumaMode - Consts.NEARESTMV);
            mv1 = MVList.get(nearestNearMv01, lumaMode - Consts.NEARESTMV);
        }
        return MVList.create(mv0, mv1);
    };
    constructor.readSub12 = function(miCol, miRow, blSz, decoder, probStore, c, mvl0, subMode1, blk, packedRefFrames) {
        var ref0 = Packed4BitList.get(packedRefFrames, 0);
        var ref1 = Packed4BitList.get(packedRefFrames, 1);
        var compoundPred = Packed4BitList.get(packedRefFrames, 2) == 1;
        var mv10 = 0, mv11 = 0;
        var nearestNearMv00 = InterModeInfo.findBestMv(miCol, miRow, blSz, ref0, 0, c, true);
        var nearestNearMv01 = 0;
        if (compoundPred) 
            nearestNearMv01 = InterModeInfo.findBestMv(miCol, miRow, blSz, ref1, 0, c, true);
        if (subMode1 == Consts.NEWMV) {
            mv10 = InterModeInfo.readDiffMv(decoder, probStore, c, nearestNearMv00);
            if (compoundPred) 
                mv11 = InterModeInfo.readDiffMv(decoder, probStore, c, nearestNearMv01);
        } else if (subMode1 != Consts.ZEROMV) {
            var nearestNearMv10 = InterModeInfo.prepandSubMvBlk12(InterModeInfo.findBestMv(miCol, miRow, blSz, ref0, blk, c, false), MVList.get(mvl0, 0));
            var nearestNearMv11 = 0;
            if (compoundPred) 
                nearestNearMv11 = InterModeInfo.prepandSubMvBlk12(InterModeInfo.findBestMv(miCol, miRow, blSz, ref1, blk, c, false), MVList.get(mvl0, 1));
            mv10 = MVList.get(nearestNearMv10, subMode1 - Consts.NEARESTMV);
            mv11 = MVList.get(nearestNearMv11, subMode1 - Consts.NEARESTMV);
        }
        return MVList.create(mv10, mv11);
    };
    constructor.readMvSub3 = function(miCol, miRow, blSz, decoder, probStore, c, mvl0, mvl1, mvl2, subMode3, packedRefFrames) {
        var ref0 = Packed4BitList.get(packedRefFrames, 0);
        var ref1 = Packed4BitList.get(packedRefFrames, 1);
        var compoundPred = Packed4BitList.get(packedRefFrames, 2) == 1;
        var nearestNearMv00 = InterModeInfo.findBestMv(miCol, miRow, blSz, ref0, 0, c, true);
        var nearestNearMv01 = 0;
        if (compoundPred) 
            nearestNearMv01 = InterModeInfo.findBestMv(miCol, miRow, blSz, ref1, 0, c, true);
        var mv30 = 0, mv31 = 0;
        if (subMode3 == Consts.NEWMV) {
            mv30 = InterModeInfo.readDiffMv(decoder, probStore, c, nearestNearMv00);
            if (compoundPred) 
                mv31 = InterModeInfo.readDiffMv(decoder, probStore, c, nearestNearMv01);
        } else if (subMode3 != Consts.ZEROMV) {
            var nearestNearMv30 = InterModeInfo.prepandSubMvBlk3(InterModeInfo.findBestMv(miCol, miRow, blSz, ref0, 3, c, false), MVList.get(mvl0, 0), MVList.get(mvl1, 0), MVList.get(mvl2, 0));
            var nearestNearMv31 = 0;
            if (compoundPred) 
                nearestNearMv31 = InterModeInfo.prepandSubMvBlk3(InterModeInfo.findBestMv(miCol, miRow, blSz, ref1, 3, c, false), MVList.get(mvl0, 1), MVList.get(mvl1, 1), MVList.get(mvl2, 1));
            mv30 = MVList.get(nearestNearMv30, subMode3 - Consts.NEARESTMV);
            mv31 = MVList.get(nearestNearMv31, subMode3 - Consts.NEARESTMV);
        }
        return MVList.create(mv30, mv31);
    };
    constructor.readRefFrames = function(miCol, miRow, blSz, segmentId, decoder, probStore, c) {
        var ref0 = c.getSegmentFeature(segmentId, Consts.SEG_LVL_REF_FRAME), ref1 = Consts.INTRA_FRAME;
        var compoundPred = false;
        if (!c.isSegmentFeatureActive(segmentId, Consts.SEG_LVL_REF_FRAME)) {
            var refMode = c.getRefMode();
            compoundPred = refMode == Consts.COMPOUND_REF;
            if (refMode == Consts.REFERENCE_MODE_SELECT) 
                compoundPred = InterModeInfo.readCompMode(miCol, miRow, decoder, probStore, c);
            if (compoundPred) {
                var compRef = InterModeInfo.readCompRef(miCol, miRow, blSz, decoder, probStore, c);
                var fixedRef = c.getCompFixedRef();
                if (c.refFrameSignBias(fixedRef) == 0) {
                    ref0 = fixedRef;
                    ref1 = compRef;
                } else {
                    ref0 = compRef;
                    ref1 = fixedRef;
                }
            } else {
                ref0 = InterModeInfo.readSingleRef(miCol, miRow, decoder, probStore, c);
            }
        }
        InterModeInfo.updateRefFrameLineBuffers(miCol, miRow, blSz, c, ref0, ref1, compoundPred);
        return Packed4BitList._3(ref0, ref1, compoundPred ? 1 : 0);
    };
    constructor.updateMVLineBuffers = function(miCol, miRow, blSz, c, mv) {
        var leftMVs = c.getLeftMVs();
        var aboveMVs = c.getAboveMVs();
        var aboveLeftMVs = c.getAboveLeftMVs();
        for (var i = 0; i < Math.max(3, Consts.blW[blSz]); i++) {
            aboveLeftMVs[2][i] = aboveLeftMVs[1][i];
            aboveLeftMVs[1][i] = aboveLeftMVs[0][i];
            aboveLeftMVs[0][i] = aboveMVs[i][miCol + i];
        }
        for (var i = 0; i < Math.max(3, Consts.blH[blSz]); i++) {
            var offTop = (miRow + i) % 8;
            aboveLeftMVs[i][2] = aboveLeftMVs[i][1];
            aboveLeftMVs[i][1] = aboveLeftMVs[i][0];
            aboveLeftMVs[i][0] = leftMVs[i][offTop];
        }
        for (var j = 0; j < Math.max(3, Consts.blH[blSz]); j++) {
            for (var i = 0; i < Consts.blW[blSz]; i++) {
                var offLeft = miCol + i;
                aboveMVs[2][offLeft] = aboveMVs[1][offLeft];
                aboveMVs[1][offLeft] = aboveMVs[0][offLeft];
                aboveMVs[0][offLeft] = mv;
            }
        }
        for (var j = 0; j < Math.max(3, Consts.blW[blSz]); j++) {
            for (var i = 0; i < Consts.blH[blSz]; i++) {
                var offTop = (miRow + i) % 8;
                leftMVs[2][offTop] = leftMVs[1][offTop];
                leftMVs[1][offTop] = leftMVs[0][offTop];
                leftMVs[0][offTop] = mv;
            }
        }
    };
    constructor.updateMVLineBuffers4x4 = function(miCol, miRow, blSz, c, mvLeft, mvAbove) {
        var leftMVs = c.getLeft4x4MVs();
        var aboveMVs = c.getAbove4x4MVs();
        aboveMVs[miCol] = mvAbove;
        leftMVs[miRow % 8] = mvLeft;
    };
    constructor.updateRefFrameLineBuffers = function(miCol, miRow, blSz, c, ref0, ref1, compoundPred) {
        var aboveCompound = c.getAboveCompound();
        var leftCompound = c.getLeftCompound();
        var refs = c.getRefs();
        for (var i = 0; i < Consts.blW[blSz]; i++) 
            aboveCompound[i + miCol] = compoundPred;
        for (var i = 0; i < Consts.blH[blSz]; i++) 
            leftCompound[(miRow + i) % 8] = compoundPred;
        for (var i = 0; i < Consts.blH[blSz]; i++) 
            for (var j = 0; j < Consts.blW[blSz]; j++) {
                refs[j][i][0] = ref0;
                refs[j][i][1] = ref1;
            }
    };
    constructor.readDiffMv = function(decoder, probStore, c, nearNearest) {
        var bestMv = MVList.get(nearNearest, 0);
        var useHp = c.isAllowHpMv() && !InterModeInfo.largeMv(bestMv);
        var joint = decoder.readTree(Consts.TREE_MV_JOINT, probStore.getMvJointProbs());
        var diffMv0 = 0, diffMv1 = 0;
        if (joint == Consts.MV_JOINT_HZVNZ || joint == Consts.MV_JOINT_HNZVNZ) 
            diffMv0 = InterModeInfo.readMvComponent(decoder, probStore, 0, useHp);
        if (joint == Consts.MV_JOINT_HNZVZ || joint == Consts.MV_JOINT_HNZVNZ) 
            diffMv1 = InterModeInfo.readMvComponent(decoder, probStore, 1, useHp);
        return MV.create(MV.x(bestMv) + diffMv0, MV.y(bestMv) + diffMv1, MV.ref(bestMv));
    };
    constructor.readMvComponent = function(decoder, probStore, comp, useHp) {
        var sign = decoder.readBitEq() == 1;
        var mvClass = decoder.readTree(Consts.MV_CLASS_TREE, probStore.getMvClassProbs()[comp]);
        var mag;
        if (mvClass == 0) {
            var mvClass0Bit = decoder.readBit(probStore.getMvClass0bitProbs()[comp]);
            var mvClass0Fr = decoder.readTree(Consts.MV_FR_TREE, probStore.getMvClassFrProbs()[comp][mvClass0Bit]);
            var mvClass0Hp = useHp ? decoder.readBit(probStore.getMvClass0HpProbs()[comp]) : 1;
            mag = ((mvClass0Bit << 3) | (mvClass0Fr << 1) | mvClass0Hp) + 1;
        } else {
            var d = 0;
            for (var i = 0; i < mvClass; i++) {
                var mvBit = decoder.readBit(probStore.getMvBitsProb()[comp][i]);
                d |= mvBit << i;
            }
            mag = Consts.CLASS0_SIZE << (mvClass + 2);
            var mvFr = decoder.readTree(Consts.MV_FR_TREE, probStore.getMvFrProbs()[comp]);
            var mvHp = useHp ? decoder.readBit(probStore.getMvHpProbs()[comp]) : 1;
            mag += ((d << 3) | (mvFr << 1) | mvHp) + 1;
        }
        return sign ? -mag : mag;
    };
    /**
     *  This creates unnecessary nasty complication, unfortunately
     */
    constructor.largeMv = function(mv) {
        return (MV.x(mv) >= 64 || MV.x(mv) <= -64) && (MV.y(mv) >= 64 || MV.y(mv) <= -64);
    };
    /**
     *  Finds near and nearest MVs and returns an MVList
     */
    constructor.findBestMv = function(miCol, miRow, blSz, ref, blk, c, clearHp) {
        var leftMVs = c.getLeftMVs();
        var aboveMVs = c.getAboveMVs();
        var aboveLeftMVs = c.getAboveLeftMVs();
        var left4x4MVs = c.getLeft4x4MVs();
        var above4x4MVs = c.getAbove4x4MVs();
        var list = 0;
        var checkDifferentRef = false;
        var pt0 = Consts.mv_ref_blocks[blSz][0];
        var pt1 = Consts.mv_ref_blocks[blSz][1];
        var mvp0 = InterModeInfo.getMV(leftMVs, aboveMVs, aboveLeftMVs, pt0, miRow, miCol, c);
        var mvp1 = InterModeInfo.getMV(leftMVs, aboveMVs, aboveLeftMVs, pt1, miRow, miCol, c);
        if (blk == 1) {
            mvp0 = mvp0 == -1 ? -1 : left4x4MVs[miRow % 8];
        } else if (blk == 2) {
            mvp1 = mvp1 == -1 ? -1 : above4x4MVs[miCol];
        }
        checkDifferentRef = mvp0 != 0 | mvp1 != 0;
        list = InterModeInfo.processCandidate(ref, list, mvp0);
        list = InterModeInfo.processCandidate(ref, list, mvp1);
        for (var i = 2; i < Consts.mv_ref_blocks[blSz].length && MVList.size(list) < 2; i++) {
            var mvi = InterModeInfo.getMV(leftMVs, aboveMVs, aboveLeftMVs, Consts.mv_ref_blocks[blSz][i], miRow, miCol, c);
            checkDifferentRef |= mvi != 0;
            list = InterModeInfo.processCandidate(ref, list, mvi);
        }
        if (MVList.size(list) < 2 && c.isUsePrevFrameMvs()) {
            var prevFrameMv = c.getPrevFrameMv();
            var prevMv = prevFrameMv[miCol][miRow];
            list = InterModeInfo.processCandidate(ref, list, prevMv);
        }
        if (MVList.size(list) < 2 && checkDifferentRef) {
            for (var i = 0; i < Consts.mv_ref_blocks[blSz].length && MVList.size(list) < 2; i++) {
                var mvp = InterModeInfo.getMV(leftMVs, aboveMVs, aboveLeftMVs, Consts.mv_ref_blocks[blSz][i], miRow, miCol, c);
                list = InterModeInfo.processNECandidate(ref, c, list, mvp);
            }
        }
        if (MVList.size(list) < 2 && c.isUsePrevFrameMvs()) {
            var prevFrameMv = c.getPrevFrameMv();
            var prevMv = prevFrameMv[miCol][miRow];
            list = InterModeInfo.processNECandidate(ref, c, list, prevMv);
        }
        list = InterModeInfo.clampMvs(miCol, miRow, blSz, c, list);
        if (clearHp) {
            list = InterModeInfo.clearHp(c, list);
        }
        return list;
    };
    /**
     *  Clears the last precision bit (HP) making the MV effectively QPel in case
     *  the MV is too large (it's magnitude is greater than 8).
     */
    constructor.clearHp = function(c, list) {
        var mv0 = MVList.get(list, 0);
        if (!c.isAllowHpMv() || InterModeInfo.largeMv(mv0)) {
            mv0 = MV.create(MV.x(mv0) & ~1, MV.y(mv0) & ~1, MV.ref(mv0));
        }
        var mv1 = MVList.get(list, 1);
        if (!c.isAllowHpMv() || InterModeInfo.largeMv(mv1)) {
            mv1 = MV.create(MV.x(mv1) & ~1, MV.y(mv1) & ~1, MV.ref(mv1));
        }
        list = MVList.create(mv0, mv1);
        return list;
    };
    constructor.clampMvs = function(miCol, miRow, blSz, c, list) {
        var mv0 = MVList.get(list, 0);
        var mv1 = MVList.get(list, 1);
        var mv0xCl = InterModeInfo.clampMvCol(miCol, blSz, c, MV.x(mv0));
        var mv0yCl = InterModeInfo.clampMvRow(miRow, blSz, c, MV.y(mv0));
        var mv1xCl = InterModeInfo.clampMvCol(miCol, blSz, c, MV.x(mv1));
        var mv1yCl = InterModeInfo.clampMvRow(miRow, blSz, c, MV.y(mv1));
        return MVList.create(MV.create(mv0xCl, mv0yCl, MV.ref(mv0)), MV.create(mv1xCl, mv1yCl, MV.ref(mv1)));
    };
    constructor.processNECandidate = function(ref, c, list, mvp) {
        var mv0 = MVList.get(mvp, 0);
        var mv1 = MVList.get(mvp, 1);
        var matchMv = MV.x(mv0) == MV.x(mv1) && MV.y(mv0) == MV.y(mv1);
        list = InterModeInfo.processNEComponent(ref, c, list, mv0);
        if (!matchMv) 
            list = InterModeInfo.processNEComponent(ref, c, list, mv1);
        return list;
    };
    constructor.processNEComponent = function(ref, c, list, mv0) {
        var ref0 = MV.ref(mv0);
        if (ref0 != Consts.INTRA_FRAME && ref0 != ref) {
            var q = c.refFrameSignBias(ref0) * c.refFrameSignBias(ref);
            var mv = MV.create(MV.x(mv0) * q, MV.y(mv0), ref);
            list = MVList.addUniq(list, mv);
        }
        return list;
    };
    constructor.processCandidate = function(ref, list, mvp0) {
        var mv00 = MVList.get(mvp0, 0);
        var mv01 = MVList.get(mvp0, 1);
        if (MV.ref(mv00) == ref) {
            list = MVList.addUniq(list, mv00);
        } else if (MV.ref(mv01) == ref) {
            list = MVList.addUniq(list, mv01);
        }
        return list;
    };
    constructor.prepandSubMvBlk12 = function(list, blkMv) {
        var nlist = 0;
        nlist = MVList.add(nlist, blkMv);
        nlist = MVList.addUniq(nlist, MVList.get(list, 0));
        nlist = MVList.addUniq(nlist, MVList.get(list, 0));
        return nlist;
    };
    constructor.prepandSubMvBlk3 = function(list, blk0Mv, blk1Mv, blk2Mv) {
        var nlist = 0;
        nlist = MVList.add(nlist, blk2Mv);
        nlist = MVList.addUniq(nlist, blk1Mv);
        nlist = MVList.addUniq(nlist, blk0Mv);
        nlist = MVList.addUniq(nlist, MVList.get(list, 0));
        nlist = MVList.addUniq(nlist, MVList.get(list, 0));
        return nlist;
    };
    constructor.clampMvRow = function(miRow, blSz, c, mv) {
        var mbToTopEdge = -(miRow << 6);
        var mbToBottomEdge = (c.getMiFrameHeight() - Consts.blH[blSz] - miRow) << 6;
        return InterModeInfo.clip3(mbToTopEdge - 128, mbToBottomEdge + 128, mv);
    };
    constructor.clip3 = function(from, to, v) {
        return v < from ? from : (v > to ? to : v);
    };
    constructor.clampMvCol = function(miCol, blSz, c, mv) {
        var mbToLeftEdge = -(miCol << 6);
        var mbToRightEdge = (c.getMiFrameWidth() - Consts.blW[blSz] - miCol) << 6;
        return InterModeInfo.clip3(mbToLeftEdge - 128, mbToRightEdge + 128, mv);
    };
    constructor.readInterpFilter = function(miCol, miRow, blSz, decoder, probStore, c) {
        var availAbove = miRow > 0;
        var availLeft = miCol > c.getTileStart();
        var refs = c.getRefs();
        var aboveRefFrame0 = refs[miRow - 1][miCol][0];
        var leftRefFrame0 = refs[miRow][miCol - 1][0];
        var leftInterpFilters = c.getLeftInterpFilters();
        var aboveInterpFilters = c.getAboveInterpFilters();
        var ctx;
        var leftInterp = (availLeft && leftRefFrame0 > Consts.INTRA_FRAME) ? leftInterpFilters[miRow % 8] : 3;
        var aboveInterp = (availAbove && aboveRefFrame0 > Consts.INTRA_FRAME) ? aboveInterpFilters[miCol] : 3;
        if (leftInterp == aboveInterp) 
            ctx = leftInterp;
         else if (leftInterp == 3 && aboveInterp != 3) 
            ctx = aboveInterp;
         else if (leftInterp != 3 && aboveInterp == 3) 
            ctx = leftInterp;
         else 
            ctx = 3;
        var probs = probStore.getInterpFilterProbs();
        var ret = decoder.readTree(Consts.TREE_INTERP_FILTER, probs[ctx]);
        for (var i = 0; i < Consts.blW[blSz]; i++) 
            aboveInterpFilters[miCol + i] = ret;
        for (var i = 0; i < Consts.blH[blSz]; i++) 
            leftInterpFilters[(miRow + i) % 8] = ret;
        return ret;
    };
    constructor.readLumaMode = function(miCol, miRow, blSz, decoder, probStore, c) {
        var ind0 = Consts.mv_ref_blocks_sm[blSz][0];
        var ind1 = Consts.mv_ref_blocks_sm[blSz][1];
        var leftModes = c.getLeftLumaModes();
        var aboveModes = c.getAboveLumaModes();
        var mode0 = InterModeInfo.getMode(leftModes, aboveModes, ind0, miRow, miCol, c);
        var mode1 = InterModeInfo.getMode(leftModes, aboveModes, ind1, miRow, miCol, c);
        var ctx;
        if (mode0 == Consts.NEARMV || mode0 == Consts.NEARESTMV) {
            if (mode1 == Consts.NEARMV || mode1 == Consts.NEARESTMV) {
                ctx = Consts.BOTH_PREDICTED;
            } else if (mode1 == Consts.NEWMV) {
                ctx = Consts.NEW_PLUS_NON_INTRA;
            } else if (mode1 == Consts.ZEROMV) {
                ctx = Consts.ZERO_PLUS_PREDICTED;
            } else {
                ctx = Consts.INTRA_PLUS_NON_INTRA;
            }
        } else if (mode0 == Consts.ZEROMV) {
            if (mode1 == Consts.NEARMV || mode1 == Consts.NEARESTMV) {
                ctx = Consts.ZERO_PLUS_PREDICTED;
            } else if (mode1 == Consts.NEWMV) {
                ctx = Consts.NEW_PLUS_NON_INTRA;
            } else if (mode1 == Consts.ZEROMV) {
                ctx = Consts.BOTH_ZERO;
            } else {
                ctx = Consts.INTRA_PLUS_NON_INTRA;
            }
        } else if (mode0 == Consts.NEWMV) {
            if (mode1 == Consts.NEARMV || mode1 == Consts.NEARESTMV) {
                ctx = Consts.NEW_PLUS_NON_INTRA;
            } else if (mode1 == Consts.NEWMV) {
                ctx = Consts.BOTH_NEW;
            } else if (mode1 == Consts.ZEROMV) {
                ctx = Consts.NEW_PLUS_NON_INTRA;
            } else {
                ctx = Consts.NEW_PLUS_NON_INTRA;
            }
        } else {
            ctx = mode1 >= Consts.NEARESTMV ? Consts.INTRA_PLUS_NON_INTRA : Consts.BOTH_INTRA;
        }
        var probs = probStore.getInterModeProbs();
        var ret = Consts.NEARESTMV + decoder.readTree(Consts.TREE_INTER_MODE, probs[ctx]);
        for (var i = 0; i < Consts.blW[blSz]; i++) 
            aboveModes[miCol + i] = ret;
        for (var i = 0; i < Consts.blH[blSz]; i++) 
            leftModes[(miRow + i) % 8] = ret;
        return ret;
    };
    constructor.getMode = function(leftModes, aboveModes, ind0, miRow, miCol, c) {
        switch (ind0) {
            case 0:
                return miCol >= c.getTileStart() ? leftModes[miRow % 8] : -1;
            case 1:
                return miRow > 0 ? aboveModes[miCol] : -1;
            case 2:
                return miCol >= c.getTileStart() && miRow < c.getTileHeight() - 1 ? leftModes[(miRow % 8) + 1] : -1;
            case 3:
                return miRow > 0 && miCol < c.getTileWidth() - 1 ? aboveModes[miCol + 1] : -1;
            case 4:
                return miCol >= c.getTileStart() && miRow < c.getTileHeight() - 3 ? leftModes[(miRow % 8) + 3] : -1;
            case 5:
                return miRow > 0 && miCol < c.getTileWidth() - 3 ? aboveModes[miCol + 3] : -1;
        }
        return -1;
    };
    constructor.getMV = function(leftMV, aboveMV, aboveLeftMV, ind0, miRow, miCol, c) {
        var ts = c.getTileStart();
        var th = c.getTileHeight();
        var tw = c.getTileWidth();
        switch (ind0) {
            case 0:
                return miCol >= ts ? leftMV[0][miRow % 8] : 0;
            case 1:
                return miRow > 0 ? aboveMV[0][miCol] : 0;
            case 2:
                return miCol >= ts && miRow < th - 1 ? leftMV[0][(miRow % 8) + 1] : 0;
            case 3:
                return miRow > 0 && miCol < tw - 1 ? aboveMV[0][miCol + 1] : 0;
            case 4:
                return miCol >= ts && miRow < th - 3 ? leftMV[0][(miRow % 8) + 3] : 0;
            case 5:
                return miRow > 0 && miCol < tw - 3 ? aboveMV[0][miCol + 3] : 0;
            case 6:
                return miCol >= ts && miRow < th - 2 ? leftMV[0][(miRow % 8) + 2] : 0;
            case 7:
                return miRow > 0 && miCol < tw - 2 ? aboveMV[0][miCol + 2] : 0;
            case 8:
                return miCol >= ts && miRow < th - 4 ? leftMV[0][(miRow % 8) + 4] : 0;
            case 9:
                return miRow > 0 && miCol < tw - 4 ? aboveMV[0][miCol + 4] : 0;
            case 10:
                return miCol >= ts && miRow < th - 6 ? leftMV[0][(miRow % 8) + 6] : 0;
            case 11:
                return miCol >= ts && miRow > 0 ? aboveLeftMV[0][0] : 0;
            case 12:
                return miCol >= ts + 1 ? leftMV[1][miRow % 8] : 0;
            case 13:
                return miRow > 1 ? aboveMV[1][miCol] : 0;
            case 14:
                return miCol >= ts + 2 ? leftMV[2][miRow % 8] : 0;
            case 15:
                return miRow > 2 ? aboveMV[2][miCol] : 0;
            case 16:
                return miCol >= ts + 1 && miRow > 0 ? aboveLeftMV[0][1] : 0;
            case 17:
                return miCol >= ts && miRow > 1 ? aboveLeftMV[1][0] : 0;
            case 18:
                return miCol >= ts + 1 && miRow > 1 ? aboveLeftMV[1][1] : 0;
            case 19:
                return miCol >= ts + 2 && miRow > 2 ? aboveLeftMV[2][2] : 0;
        }
        return 0;
    };
    constructor.readCompRef = function(miCol, miRow, blSz, decoder, probStore, c) {
        var compFixedRef = c.getCompFixedRef();
        var fixRefIdx = c.refFrameSignBias(compFixedRef);
        var availAbove = miRow > 0;
        var availLeft = miCol > c.getTileStart();
        var aboveCompound = c.getAboveCompound();
        var leftCompound = c.getLeftCompound();
        var refs = c.getRefs();
        var aboveRefFrame0 = refs[miRow - 1][miCol][0];
        var leftRefFrame0 = refs[miRow][miCol - 1][0];
        var aboveRefFrame1 = refs[miRow - 1][miCol][1];
        var leftRefFrame1 = refs[miRow][miCol - 1][1];
        var aboveIntra = aboveRefFrame0 <= Consts.INTRA_FRAME;
        var leftIntra = leftRefFrame0 <= Consts.INTRA_FRAME;
        var aboveSingle = !aboveCompound[miCol];
        var leftSingle = !leftCompound[miRow % 8];
        var aboveVarRefFrame, leftVarRefFrame;
        if (fixRefIdx == 0) {
            aboveVarRefFrame = aboveRefFrame1;
            leftVarRefFrame = leftRefFrame1;
        } else {
            aboveVarRefFrame = aboveRefFrame0;
            leftVarRefFrame = leftRefFrame0;
        }
        var compVarRef0 = c.getCompVarRef(0);
        var compVarRef1 = c.getCompVarRef(1);
        var ctx;
        if (availAbove && availLeft) {
            if (aboveIntra && leftIntra) {
                ctx = 2;
            } else if (leftIntra) {
                if (aboveSingle) 
                    ctx = 1 + 2 * (aboveRefFrame0 != compVarRef1 ? 1 : 0);
                 else 
                    ctx = 1 + 2 * (aboveVarRefFrame != compVarRef1 ? 1 : 0);
            } else if (aboveIntra) {
                if (leftSingle) 
                    ctx = 1 + 2 * (leftRefFrame0 != compVarRef1 ? 1 : 0);
                 else 
                    ctx = 1 + 2 * (leftVarRefFrame != compVarRef1 ? 1 : 0);
            } else {
                var vrfa = aboveSingle ? aboveRefFrame0 : aboveVarRefFrame;
                var vrfl = leftSingle ? leftRefFrame0 : leftVarRefFrame;
                if (vrfa == vrfl && compVarRef1 == vrfa) {
                    ctx = 0;
                } else if (leftSingle && aboveSingle) {
                    if ((vrfa == compFixedRef && vrfl == compVarRef0) || (vrfl == compFixedRef && vrfa == compVarRef0)) 
                        ctx = 4;
                     else if (vrfa == vrfl) 
                        ctx = 3;
                     else 
                        ctx = 1;
                } else if (leftSingle || aboveSingle) {
                    var vrfc = leftSingle ? vrfa : vrfl;
                    var rfs = aboveSingle ? vrfa : vrfl;
                    if (vrfc == compVarRef1 && rfs != compVarRef1) 
                        ctx = 1;
                     else if (rfs == compVarRef1 && vrfc != compVarRef1) 
                        ctx = 2;
                     else 
                        ctx = 4;
                } else if (vrfa == vrfl) {
                    ctx = 4;
                } else {
                    ctx = 2;
                }
            }
        } else if (availAbove) {
            if (aboveIntra) {
                ctx = 2;
            } else {
                if (aboveSingle) 
                    ctx = 3 * (aboveRefFrame0 != compVarRef1 ? 1 : 0);
                 else 
                    ctx = 4 * (aboveVarRefFrame != compVarRef1 ? 1 : 0);
            }
        } else if (availLeft) {
            if (leftIntra) {
                ctx = 2;
            } else {
                if (leftSingle) 
                    ctx = 3 * (leftRefFrame0 != compVarRef1 ? 1 : 0);
                 else 
                    ctx = 4 * (leftVarRefFrame != compVarRef1 ? 1 : 0);
            }
        } else {
            ctx = 2;
        }
        var probs = probStore.getCompRefProbs();
        return decoder.readBit(probs[ctx]);
    };
    constructor.readSingleRef = function(miCol, miRow, decoder, probStore, c) {
        var singleRefP1 = InterModeInfo.readSingRef(0, miCol, miRow, decoder, probStore, c);
        if (singleRefP1) {
            var singleRefP2 = InterModeInfo.readSingRef(0, miCol, miRow, decoder, probStore, c);
            return singleRefP2 ? Consts.ALTREF_FRAME : Consts.GOLDEN_FRAME;
        } else {
            return Consts.LAST_FRAME;
        }
    };
    constructor.readSingRef = function(bin, miCol, miRow, decoder, probStore, c) {
        var availAbove = miRow > 0;
        var availLeft = miCol > c.getTileStart();
        var aboveCompound = c.getAboveCompound();
        var leftCompound = c.getLeftCompound();
        var refs = c.getRefs();
        var aboveRefFrame0 = refs[miRow - 1][miCol][0];
        var leftRefFrame0 = refs[miRow][miCol - 1][0];
        var aboveRefFrame1 = refs[miRow - 1][miCol][1];
        var leftRefFrame1 = refs[miRow][miCol - 1][1];
        var aboveIntra = aboveRefFrame0 <= Consts.INTRA_FRAME;
        var leftIntra = leftRefFrame0 <= Consts.INTRA_FRAME;
        var aboveSingle = !aboveCompound[miCol];
        var leftSingle = !leftCompound[miRow % 8];
        var ctx;
        if (availAbove && availLeft) {
            if (aboveIntra && leftIntra) {
                ctx = 2;
            } else if (leftIntra) {
                if (aboveSingle) {
                    if (bin == 0) 
                        ctx = 4 * (aboveRefFrame0 == Consts.LAST_FRAME ? 1 : 0);
                     else {
                        if (aboveRefFrame0 == Consts.LAST_FRAME) 
                            ctx = 3;
                         else 
                            ctx = 4 * (aboveRefFrame0 == Consts.GOLDEN_FRAME ? 1 : 0);
                    }
                } else {
                    if (bin == 0) 
                        ctx = 1 + (aboveRefFrame0 == Consts.LAST_FRAME || aboveRefFrame1 == Consts.LAST_FRAME ? 1 : 0);
                     else 
                        ctx = 1 + 2 * (aboveRefFrame0 == Consts.GOLDEN_FRAME || aboveRefFrame1 == Consts.GOLDEN_FRAME ? 1 : 0);
                }
            } else if (aboveIntra) {
                if (leftSingle) {
                    if (bin == 0) 
                        ctx = 4 * (leftRefFrame0 == Consts.LAST_FRAME ? 1 : 0);
                     else {
                        if (leftRefFrame0 == Consts.LAST_FRAME) 
                            ctx = 3;
                         else 
                            ctx = 4 * (leftRefFrame0 == Consts.GOLDEN_FRAME ? 1 : 0);
                    }
                } else {
                    if (bin == 0) 
                        ctx = 1 + (leftRefFrame0 == Consts.LAST_FRAME || leftRefFrame1 == Consts.LAST_FRAME ? 1 : 0);
                     else 
                        ctx = 1 + 2 * (leftRefFrame0 == Consts.GOLDEN_FRAME || leftRefFrame1 == Consts.GOLDEN_FRAME ? 1 : 0);
                }
            } else {
                if (aboveSingle && leftSingle) {
                    if (bin == 0) {
                        ctx = 2 * (aboveRefFrame0 == Consts.LAST_FRAME ? 1 : 0) + 2 * (leftRefFrame0 == Consts.LAST_FRAME ? 1 : 0);
                    } else {
                        if (aboveRefFrame0 == Consts.LAST_FRAME && leftRefFrame0 == Consts.LAST_FRAME) {
                            ctx = 3;
                        } else if (aboveRefFrame0 == Consts.LAST_FRAME) {
                            ctx = 4 * (leftRefFrame0 == Consts.GOLDEN_FRAME ? 1 : 0);
                        } else if (leftRefFrame0 == Consts.LAST_FRAME) {
                            ctx = 4 * (aboveRefFrame0 == Consts.GOLDEN_FRAME ? 1 : 0);
                        } else {
                            ctx = 2 * (aboveRefFrame0 == Consts.GOLDEN_FRAME ? 1 : 0) + 2 * (leftRefFrame0 == Consts.GOLDEN_FRAME ? 1 : 0);
                        }
                    }
                } else if (!aboveSingle && !leftSingle) {
                    if (bin == 0) {
                        ctx = 1 + (aboveRefFrame0 == Consts.LAST_FRAME || aboveRefFrame1 == Consts.LAST_FRAME || leftRefFrame0 == Consts.LAST_FRAME || leftRefFrame1 == Consts.LAST_FRAME ? 1 : 0);
                    } else {
                        if (aboveRefFrame0 == leftRefFrame0 && aboveRefFrame1 == leftRefFrame1) 
                            ctx = 3 * (aboveRefFrame0 == Consts.GOLDEN_FRAME || aboveRefFrame1 == Consts.GOLDEN_FRAME ? 1 : 0);
                         else 
                            ctx = 2;
                    }
                } else {
                    var rfs = aboveSingle ? aboveRefFrame0 : leftRefFrame0;
                    var crf1 = aboveSingle ? leftRefFrame0 : aboveRefFrame0;
                    var crf2 = aboveSingle ? leftRefFrame1 : aboveRefFrame1;
                    if (bin == 0) {
                        if (rfs == Consts.LAST_FRAME) 
                            ctx = 3 + (crf1 == Consts.LAST_FRAME || crf2 == Consts.LAST_FRAME ? 1 : 0);
                         else 
                            ctx = crf1 == Consts.LAST_FRAME || crf2 == Consts.LAST_FRAME ? 1 : 0;
                    } else {
                        if (rfs == Consts.GOLDEN_FRAME) 
                            ctx = 3 + (crf1 == Consts.GOLDEN_FRAME || crf2 == Consts.GOLDEN_FRAME ? 1 : 0);
                         else if (rfs == Consts.ALTREF_FRAME) 
                            ctx = crf1 == Consts.GOLDEN_FRAME || crf2 == Consts.GOLDEN_FRAME ? 1 : 0;
                         else 
                            ctx = 1 + 2 * (crf1 == Consts.GOLDEN_FRAME || crf2 == Consts.GOLDEN_FRAME ? 1 : 0);
                    }
                }
            }
        } else if (availAbove) {
            if (aboveIntra || (bin == 1 && aboveRefFrame0 == Consts.LAST_FRAME && aboveSingle)) {
                ctx = 2;
            } else {
                if (aboveSingle) {
                    if (bin == 0) 
                        ctx = 4 * (aboveRefFrame0 == Consts.LAST_FRAME ? 1 : 0);
                     else 
                        ctx = 4 * (aboveRefFrame0 == Consts.GOLDEN_FRAME ? 1 : 0);
                } else {
                    if (bin == 0) 
                        ctx = 1 + (aboveRefFrame0 == Consts.LAST_FRAME || aboveRefFrame1 == Consts.LAST_FRAME ? 1 : 0);
                     else 
                        ctx = 3 * (aboveRefFrame0 == Consts.GOLDEN_FRAME || aboveRefFrame1 == Consts.GOLDEN_FRAME ? 1 : 0);
                }
            }
        } else if (availLeft) {
            if (leftIntra || (bin == 1 && leftRefFrame0 == Consts.LAST_FRAME && leftSingle)) {
                ctx = 2;
            } else {
                if (leftSingle) {
                    if (bin == 0) 
                        ctx = 4 * (leftRefFrame0 == Consts.LAST_FRAME ? 1 : 0);
                     else 
                        ctx = 4 * (leftRefFrame0 == Consts.GOLDEN_FRAME ? 1 : 0);
                } else {
                    if (bin == 0) 
                        ctx = 1 + (leftRefFrame0 == Consts.LAST_FRAME || leftRefFrame1 == Consts.LAST_FRAME ? 1 : 0);
                     else 
                        ctx = 3 * (leftRefFrame0 == Consts.GOLDEN_FRAME || leftRefFrame1 == Consts.GOLDEN_FRAME ? 1 : 0);
                }
            }
        } else {
            ctx = 2;
        }
        var probs = probStore.getSingleRefProbs();
        return decoder.readBit(probs[ctx][bin]) == 1;
    };
    constructor.readCompMode = function(miCol, miRow, decoder, probStore, c) {
        var availAbove = miRow > 0;
        var availLeft = miCol > c.getTileStart();
        var aboveCompound = c.getAboveCompound();
        var leftCompound = c.getLeftCompound();
        var refs = c.getRefs();
        var aboveRefFrame0 = refs[miRow - 1][miCol][0];
        var leftRefFrame0 = refs[miRow][miCol - 1][0];
        var compFixedRef = c.getCompFixedRef();
        var aboveSingle = !aboveCompound[miCol];
        var leftSingle = !leftCompound[miRow % 8];
        var aboveIntra = aboveRefFrame0 <= Consts.INTRA_FRAME;
        var leftIntra = leftRefFrame0 <= Consts.INTRA_FRAME;
        var ctx;
        if (availAbove && availLeft) {
            if (aboveSingle && leftSingle) 
                ctx = (aboveRefFrame0 == compFixedRef) ^ (leftRefFrame0 == compFixedRef) ? 1 : 0;
             else if (aboveSingle) {
                ctx = 2 + (aboveRefFrame0 == compFixedRef || aboveIntra ? 1 : 0);
            } else if (leftSingle) 
                ctx = 2 + (leftRefFrame0 == compFixedRef || leftIntra ? 1 : 0);
             else 
                ctx = 4;
        } else if (availAbove) {
            if (aboveSingle) 
                ctx = aboveRefFrame0 == compFixedRef ? 1 : 0;
             else 
                ctx = 3;
        } else if (availLeft) {
            if (leftSingle) 
                ctx = leftRefFrame0 == compFixedRef ? 1 : 0;
             else 
                ctx = 3;
        } else {
            ctx = 1;
        }
        var probs = probStore.getCompModeProbs();
        return decoder.readBit(probs[ctx]) == 1;
    };
    constructor.readIntraSpecificMode = function(miCol, miRow, blSz, decoder, probs, c, segmentId, skip, txSize) {
        var yMode;
        var subModes = 0;
        if (blSz >= Consts.BLOCK_8X8) {
            yMode = InterModeInfo.readIntraMode(miCol, miRow, blSz, decoder, probs, c);
        } else {
            subModes = InterModeInfo.readSubIntraMode(miCol, miRow, blSz, decoder, probs, c);
            yMode = subModes & 255;
        }
        var uvMode = InterModeInfo.readUVMode(yMode, decoder, probs, c);
        return new InterModeInfo(segmentId, skip, txSize, yMode, subModes, uvMode, 0, 0, 0, 0);
    };
    constructor.readIntraMode = function(miCol, miRow, blSz, decoder, probStore, c) {
        var probs = probStore.getYModeProbs();
        return decoder.readTree(Consts.TREE_INTRA_MODE, probs[Consts.size_group_lookup[blSz]]);
    };
    constructor.readSubIntraMode = function(miCol, miRow, blSz, decoder, probStore, c) {
        var probs = probStore.getYModeProbs();
        return decoder.readTree(Consts.TREE_INTRA_MODE, probs[0]);
    };
    constructor.readUVMode = function(yMode, decoder, probStore, c) {
        var probs = probStore.getUVModeProbs();
        return decoder.readTree(Consts.TREE_INTRA_MODE, probs[yMode]);
    };
    constructor.readIsInter = function(miCol, miRow, blSz, decoder, probStore, c) {
        var availAbove = miRow > 0;
        var availLeft = miCol > c.getTileStart();
        var refs = c.getRefs();
        var leftIntra = availLeft ? refs[miRow][miCol - 1][0] <= Consts.INTRA_FRAME : true;
        var aboveIntra = availAbove ? refs[miRow - 1][miCol][0] <= Consts.INTRA_FRAME : true;
        var ctx = 0;
        if (availAbove && availLeft) 
            ctx = (leftIntra && aboveIntra) ? 3 : (leftIntra || aboveIntra ? 1 : 0);
         else if (availAbove || availLeft) 
            ctx = 2 * (availAbove ? (aboveIntra ? 1 : 0) : (leftIntra ? 1 : 0));
        var probs = probStore.getIsInterProbs();
        return decoder.readBit(probs[ctx]) == 1;
    };
    constructor.readSegIdPredicted = function(miCol, miRow, blSz, decoder, probs, c) {
        var aboveSegIdPredicted = c.getAboveSegIdPredicted();
        var leftSegIdPredicted = c.getLeftSegIdPredicted();
        var ctx = (aboveSegIdPredicted[miRow] ? 1 : 0) + (leftSegIdPredicted[miCol] ? 1 : 0);
        var prob = probs.getSegmentationPredProb();
        var ret = decoder.readBit(prob[ctx]) == 1;
        for (var i = 0; i < Consts.blH[blSz]; i++) 
            aboveSegIdPredicted[miCol + i] = ret;
        for (var i = 0; i < Consts.blW[blSz]; i++) 
            leftSegIdPredicted[miRow + i] = ret;
        return false;
    };
    constructor.predicSegmentId = function(miCol, miRow, blSz, c) {
        var blWcl = Math.min(c.getTileWidth() - miCol, Consts.blW[blSz]);
        var blHcl = Math.min(c.getTileHeight() - miRow, Consts.blH[blSz]);
        var prevSegmentIds = c.getPrevSegmentIds();
        var seg = 7;
        for (var y = 0; y < blHcl; y++) 
            for (var x = 0; x < blWcl; x++) 
                seg = Math.min(seg, prevSegmentIds[miRow + y][miCol + x]);
        return seg;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var RgbToYuv422p = function() {};
RgbToYuv422p = stjs.extend(RgbToYuv422p, null, [Transform], function(constructor, prototype) {
    prototype.transform = function(img, dst) {
        var y = img.getData()[0];
        var out1 = new Int8Array(3);
        var out2 = new Int8Array(3);
        var dstData = dst.getData();
        var off = 0, offSrc = 0;
        for (var i = 0; i < img.getHeight(); i++) {
            for (var j = 0; j < img.getWidth() >> 1; j++) {
                var offY = off << 1;
                RgbToYuv420p.rgb2yuv(y[offSrc++], y[offSrc++], y[offSrc++], out1);
                dstData[0][offY] = out1[0];
                RgbToYuv420p.rgb2yuv(y[offSrc++], y[offSrc++], y[offSrc++], out2);
                dstData[0][offY + 1] = out2[0];
                dstData[1][off] = (((out1[1] + out2[1] + 1) >> 1) << 24 >> 24);
                dstData[2][off] = (((out1[2] + out2[2] + 1) >> 1) << 24 >> 24);
                ++off;
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var FilterSocket = function() {};
FilterSocket = stjs.extend(FilterSocket, null, [], function(constructor, prototype) {
    prototype.buffers = null;
    prototype.positions = null;
    prototype.delays = null;
    prototype.filters = null;
    prototype.totalInputs = 0;
    prototype.totalOutputs = 0;
    constructor.createFilterSocket = function(_arguments) {
        var fs = new FilterSocket();
        fs.totalInputs = 0;
        fs.totalOutputs = 0;
        for (var i = 0; i < arguments.length; i++) {
            fs.totalInputs += arguments[i].getNInputs();
            fs.totalOutputs += arguments[i].getNOutputs();
        }
        fs.buffers = Array(fs.totalInputs);
        fs.positions = Array(fs.totalInputs);
        fs.delays = new Int32Array(fs.totalInputs);
        for (var i = 0, b = 0; i < arguments.length; i++) {
            for (var j = 0; j < arguments[i].getNInputs(); j++ , b++) {
                fs.delays[b] = arguments[i].getDelay();
            }
        }
        fs.filters = arguments;
        return fs;
    };
    prototype.allocateBuffers = function(bufferSize) {
        for (var i = 0; i < this.totalInputs; i++) {
            this.buffers[i] = FloatBuffer.allocate(bufferSize + this.delays[i] * 2);
            this.buffers[i].position(this.delays[i]);
        }
    };
    constructor.createFilterSocket2 = function(filter, buffers, positions) {
        var fs = new FilterSocket();
        fs.filters = [filter];
        fs.buffers = buffers;
        fs.positions = positions;
        fs.delays = new Int32Array([filter.getDelay()]);
        fs.totalInputs = filter.getNInputs();
        fs.totalOutputs = filter.getNOutputs();
        return fs;
    };
    prototype.filter = function(outputs) {
        if (outputs.length != this.totalOutputs) 
             throw new IllegalArgumentException("Can not output to provided filter socket inputs != outputs (" + outputs.length + "!=" + this.totalOutputs + ")");
        for (var i = 0, ii = 0, oi = 0; i < this.filters.length; ii += this.filters[i].getNInputs() , oi += this.filters[i].getNOutputs() , i++) {
            this.filters[i].filter(Platform.copyOfRangeO(this.buffers, ii, this.filters[i].getNInputs() + ii), Platform.copyOfRangeL(this.positions, ii, this.filters[i].getNInputs() + ii), Platform.copyOfRangeO(outputs, oi, this.filters[i].getNOutputs() + oi));
        }
    };
    prototype.getBuffers = function() {
        return this.buffers;
    };
    prototype.rotate = function() {
        for (var i = 0; i < this.buffers.length; i++) {
            this.positions[i] += this.buffers[i].position();
            Audio.rotate(this.buffers[i]);
        }
    };
    prototype.setBuffers = function(ins, pos) {
        if (ins.length != this.totalInputs) 
             throw new IllegalArgumentException("Number of input buffers provided is less then the number of filter inputs.");
        if (pos.length != this.totalInputs) 
             throw new IllegalArgumentException("Number of input buffer positions provided is less then the number of filter inputs.");
        this.buffers = ins;
        this.positions = pos;
    };
    prototype.getTotalInputs = function() {
        return this.totalInputs;
    };
    prototype.getTotalOutputs = function() {
        return this.totalOutputs;
    };
    prototype.getFilters = function() {
        return this.filters;
    };
    prototype.getPositions = function() {
        return this.positions;
    };
}, {buffers: "Array", positions: "Array", delays: "Int32Array", filters: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Low pass filter based on windowed sinc function
 *  
 *  Simplest possible low pass filter
 *  
 *  BW = 4 / kernelSize
 *  
 *  BW - width of transition band measured in fraction of sampling rate
 *  
 *  So for kernelSize = 20, and sampling rate 48000, BW = 9600 Hz ( pretty huge )
 *  
 *  @author The JCodec project
 *  
 */
var SincLowPassFilter = function(kernelSize, cutoffFreq) {
    ConvolutionFilter.call(this);
    this.kernelSize = kernelSize;
    this.cutoffFreq = cutoffFreq;
};
SincLowPassFilter = stjs.extend(SincLowPassFilter, ConvolutionFilter, [], function(constructor, prototype) {
    prototype.kernelSize = 0;
    prototype.cutoffFreq = 0.0;
    constructor.createSincLowPassFilter = function(cutoffFreq) {
        return new SincLowPassFilter(40, cutoffFreq);
    };
    constructor.createSincLowPassFilter2 = function(cutoffFreq, samplingRate) {
        return new SincLowPassFilter(40, cutoffFreq / samplingRate);
    };
    prototype.buildKernel = function() {
        var kernel = new Float64Array(this.kernelSize);
        var sum = 0;
        for (var i = 0; i < this.kernelSize; i++) {
            var a = i - stjs.trunc(this.kernelSize / 2);
            if (a != 0) 
                kernel[i] = Math.sin(2 * Math.PI * this.cutoffFreq * (i - stjs.trunc(this.kernelSize / 2))) / (i - stjs.trunc(this.kernelSize / 2)) * (0.54 - 0.46 * Math.cos(2 * Math.PI * i / this.kernelSize));
             else 
                kernel[i] = 2 * Math.PI * this.cutoffFreq;
            sum += kernel[i];
        }
        for (var i = 0; i < this.kernelSize; i++) 
            kernel[i] /= sum;
        return kernel;
    };
}, {kernel: "Float64Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  All the IO routines related to bits
 *  
 *  @author The JCodec project
 *  
 */
var BitIO = function() {};
BitIO = stjs.extend(BitIO, null, [], function(constructor, prototype) {
    constructor.InputBits = function() {};
    constructor.InputBits = stjs.extend(constructor.InputBits, null, [], function(constructor, prototype) {
        prototype.getBit = function() {};
    }, {}, {});
    constructor.OutputBits = function() {};
    constructor.OutputBits = stjs.extend(constructor.OutputBits, null, [], function(constructor, prototype) {
        prototype.putBit = function(symbol) {};
        prototype.flush = function() {};
    }, {}, {});
    constructor.inputFromStream = function(is) {
        return new BitIO.StreamInputBits(is);
    };
    constructor.outputFromStream = function(out) {
        return new BitIO.StreamOutputBits(out);
    };
    constructor.inputFromArray = function(bytes) {
        return new BitIO.StreamInputBits(new ByteArrayInputStream(bytes));
    };
    constructor.outputFromArray = function(bytes) {
        return new BitIO.StreamOutputBits(new (stjs.extend(function BitIO$1() {
            BaseOutputStream.call(this);
        }, BaseOutputStream, [], function(constructor, prototype) {
            prototype.ptr = 0;
            prototype.writeByte = function(b) {
                if (this.ptr >= bytes.length) 
                     throw new IOException("Buffer is full");
                bytes[this.ptr++] = (b << 24 >> 24);
            };
        }, {}, {}))());
    };
    constructor.compressBits = function(decompressed) {
        var compressed = new Int8Array((decompressed.length >> 3) + 1);
        var out = BitIO.outputFromArray(compressed);
        try {
            for (var i = 0; i < decompressed.length; i++) {
                var bit = decompressed[i];
                out.putBit(bit);
            }
        }catch (e) {}
        return compressed;
    };
    constructor.decompressBits = function(compressed) {
        var decompressed = new Int32Array(compressed.length << 3);
        var inputFromArray = BitIO.inputFromArray(compressed);
        var read;
        try {
            for (var i = 0; (read = inputFromArray.getBit()) != -1; i++) {
                decompressed[i] = read;
            }
        }catch (e) {}
        return decompressed;
    };
    constructor.StreamInputBits = function(_in) {
        this._in = _in;
        this.bit = 8;
    };
    constructor.StreamInputBits = stjs.extend(constructor.StreamInputBits, null, [BitIO.InputBits], function(constructor, prototype) {
        prototype._in = null;
        prototype.cur = 0;
        prototype.bit = 0;
        prototype.getBit = function() {
            if (this.bit > 7) {
                this.cur = this._in.read();
                if (this.cur == -1) 
                    return -1;
                this.bit = 0;
            }
            return (this.cur >> (7 - this.bit++)) & 1;
        };
    }, {_in: "InputStream"}, {});
    constructor.StreamOutputBits = function(out) {
        this.out = out;
    };
    constructor.StreamOutputBits = stjs.extend(constructor.StreamOutputBits, null, [BitIO.OutputBits], function(constructor, prototype) {
        prototype.out = null;
        prototype.cur = 0;
        prototype.bit = 0;
        prototype.putBit = function(symbol) {
            if (this.bit > 7) {
                this.out.write(this.cur);
                this.cur = 0;
                this.bit = 0;
            }
            this.cur |= (symbol & 1) << (7 - this.bit++);
        };
        prototype.flush = function() {
            if (this.bit > 0) 
                this.out.write(this.cur);
        };
    }, {out: "OutputStream"}, {});
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A funnel that merges channels into multi-channel stream
 *  
 *  @author The JCodec project
 *  
 */
var ChannelMerge = function(format) {
    this.format = format;
};
ChannelMerge = stjs.extend(ChannelMerge, null, [AudioFilter], function(constructor, prototype) {
    prototype.format = null;
    prototype.filter = function(_in, inPos, out) {
        if (_in.length != this.format.getChannels()) {
             throw new IllegalArgumentException("Channel merge must be supplied with " + this.format.getChannels() + " input buffers to hold the channels.");
        }
        if (out.length != 1) {
             throw new IllegalArgumentException("Channel merget invoked on more then one output");
        }
        var out0 = out[0];
        var min = Integer.MAX_VALUE;
        for (var i = 0; i < _in.length; i++) {
            if (_in[i].remaining() < min) 
                min = _in[i].remaining();
        }
        for (var i = 0; i < _in.length; i++) {
            Preconditions.checkState(_in[i].remaining() == min);
        }
        if (out0.remaining() < min * _in.length) 
             throw new IllegalArgumentException("Supplied output buffer is not big enough to hold " + min + " * " + _in.length + " = " + (min * _in.length) + " output samples.");
        for (var i = 0; i < min; i++) {
            for (var j = 0; j < _in.length; j++) 
                out0.put(_in[j].get());
        }
    };
    prototype.getDelay = function() {
        return 0;
    };
    prototype.getNInputs = function() {
        return this.format.getChannels();
    };
    prototype.getNOutputs = function() {
        return 1;
    };
}, {format: "AudioFormat"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  An UL class that wraps UL bytes, introduced to implement custom comparison
 *  rules
 *  
 *  <p>
 *  SMPTE 298-2009
 *  </p>
 *  4.2 SMPTE-Administered Universal Label A fixed-length (16-byte) universal
 *  label, defined by this standard and administered by SMPTE.
 *  
 *  @author The JCodec project
 *  
 */
var UL = function(bytes) {
    Preconditions.checkNotNull(bytes);
    this.bytes = bytes;
};
UL = stjs.extend(UL, null, [], function(constructor, prototype) {
    prototype.bytes = null;
    constructor.newULFromInts = function(_arguments) {
        var bytes = new Int8Array(arguments.length);
        for (var i = 0; i < arguments.length; i++) {
            bytes[i] = (arguments[i] << 24 >> 24);
        }
        return new UL(bytes);
    };
    constructor.newUL = function(ul) {
        Preconditions.checkNotNull(ul);
        var split = ul.split("\\.");
        var b = new Int8Array(split.length);
        for (var i = 0; i < split.length; i++) {
            var parseInt = Integer.parseInt(split[i], 16);
            b[i] = (parseInt << 24 >> 24);
        }
        return new UL(b);
    };
    prototype.hashCode = function() {
        return ((this.bytes[4] & 255) << 24) | ((this.bytes[5] & 255) << 16) | ((this.bytes[6] & 255) << 8) | (this.bytes[7] & 255);
    };
    prototype.equals = function(obj) {
        if (!(stjs.isInstanceOf(obj.constructor, UL))) 
            return false;
        var other = (obj).bytes;
        for (var i = 4; i < Math.min(this.bytes.length, other.length); i++) 
            if (this.bytes[i] != other[i]) 
                return false;
        return true;
    };
    prototype.maskEquals = function(o, mask) {
        if (o == null) 
            return false;
        var other = o.bytes;
        mask >>= 4;
        for (var i = 4; i < Math.min(this.bytes.length, other.length); i++ , mask >>= 1) 
            if ((mask & 1) == 1 && this.bytes[i] != other[i]) 
                return false;
        return true;
    };
    constructor.hex = new Uint16Array(['0'.charCodeAt(0), '1'.charCodeAt(0), '2'.charCodeAt(0), '3'.charCodeAt(0), '4'.charCodeAt(0), '5'.charCodeAt(0), '6'.charCodeAt(0), '7'.charCodeAt(0), '8'.charCodeAt(0), '9'.charCodeAt(0), 'A'.charCodeAt(0), 'B'.charCodeAt(0), 'C'.charCodeAt(0), 'D'.charCodeAt(0), 'E'.charCodeAt(0), 'F'.charCodeAt(0)]);
    prototype.toString = function() {
        if (this.bytes.length == 0) 
            return "";
        var str = new Uint16Array(this.bytes.length * 3 - 1);
        var i = 0;
        var j = 0;
        for (i = 0; i < this.bytes.length - 1; i++) {
            str[j++] = UL.hex[(this.bytes[i] >> 4) & 15];
            str[j++] = UL.hex[this.bytes[i] & 15];
            str[j++] = '.'.charCodeAt(0);
        }
        str[j++] = UL.hex[(this.bytes[i] >> 4) & 15];
        str[j++] = UL.hex[this.bytes[i] & 15];
        return new String(str);
    };
    prototype.get = function(i) {
        return this.bytes[i];
    };
    constructor.read = function(_bb) {
        var umid = new Int8Array(16);
        _bb.getBuf(umid);
        return new UL(umid);
    };
}, {bytes: "Int8Array", hex: "Uint16Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Builds intra prediction for intra 8x8 coded macroblocks
 *  
 *  @author The JCodec project
 *  
 */
var Intra8x8PredictionBuilder = function() {
    this.topBuf = new Int8Array(16);
    this.leftBuf = new Int8Array(8);
    this.genBuf = new Int8Array(24);
};
Intra8x8PredictionBuilder = stjs.extend(Intra8x8PredictionBuilder, null, [], function(constructor, prototype) {
    prototype.topBuf = null;
    prototype.leftBuf = null;
    prototype.genBuf = null;
    prototype.predictWithMode = function(mode, residual, leftAvailable, topAvailable, topLeftAvailable, topRightAvailable, leftRow, topLine, topLeft, mbOffX, blkX, blkY, pixOut) {
        switch (mode) {
            case 0:
                Preconditions.checkState(topAvailable, "");
                this.predictVertical(residual, topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 1:
                Preconditions.checkState(leftAvailable, "");
                this.predictHorizontal(residual, topLeftAvailable, topLeft, leftRow, mbOffX, blkX, blkY, pixOut);
                break;
            case 2:
                this.predictDC(residual, topLeftAvailable, topRightAvailable, leftAvailable, topAvailable, topLeft, leftRow, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 3:
                Preconditions.checkState(topAvailable, "");
                this.predictDiagonalDownLeft(residual, topLeftAvailable, topAvailable, topRightAvailable, topLeft, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 4:
                Preconditions.checkState(topAvailable && leftAvailable && topLeftAvailable, "");
                this.predictDiagonalDownRight(residual, topRightAvailable, topLeft, leftRow, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 5:
                Preconditions.checkState(topAvailable && leftAvailable && topLeftAvailable, "");
                this.predictVerticalRight(residual, topRightAvailable, topLeft, leftRow, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 6:
                Preconditions.checkState(topAvailable && leftAvailable && topLeftAvailable, "");
                this.predictHorizontalDown(residual, topRightAvailable, topLeft, leftRow, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 7:
                Preconditions.checkState(topAvailable, "");
                this.predictVerticalLeft(residual, topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX, blkX, blkY, pixOut);
                break;
            case 8:
                Preconditions.checkState(leftAvailable, "");
                this.predictHorizontalUp(residual, topLeftAvailable, topLeft, leftRow, mbOffX, blkX, blkY, pixOut);
                break;
        }
        var oo1 = mbOffX + blkX;
        var off1 = (blkY << 4) + blkX + 7;
        topLeft[blkY >> 2] = topLine[oo1 + 7];
        for (var i = 0; i < 8; i++) 
            leftRow[blkY + i] = pixOut[off1 + (i << 4)];
        var off2 = (blkY << 4) + blkX + 112;
        for (var i = 0; i < 8; i++) 
            topLine[oo1 + i] = pixOut[off2 + i];
        topLeft[(blkY >> 2) + 1] = leftRow[blkY + 3];
    };
    prototype.interpolateTop = function(topLeftAvailable, topRightAvailable, topLeft, topLine, blkX, blkY, out) {
        var a = topLeftAvailable ? topLeft[blkY >> 2] : topLine[blkX];
        out[0] = (((a + (topLine[blkX] << 1) + topLine[blkX + 1] + 2) >> 2) << 24 >> 24);
        var i;
        for (i = 1; i < 7; i++) 
            out[i] = (((topLine[blkX + i - 1] + (topLine[blkX + i] << 1) + topLine[blkX + i + 1] + 2) >> 2) << 24 >> 24);
        if (topRightAvailable) {
            for (; i < 15; i++) 
                out[i] = (((topLine[blkX + i - 1] + (topLine[blkX + i] << 1) + topLine[blkX + i + 1] + 2) >> 2) << 24 >> 24);
            out[15] = (((topLine[blkX + 14] + (topLine[blkX + 15] << 1) + topLine[blkX + 15] + 2) >> 2) << 24 >> 24);
        } else {
            out[7] = (((topLine[blkX + 6] + (topLine[blkX + 7] << 1) + topLine[blkX + 7] + 2) >> 2) << 24 >> 24);
            for (i = 8; i < 16; i++) 
                out[i] = topLine[blkX + 7];
        }
    };
    prototype.interpolateLeft = function(topLeftAvailable, topLeft, leftRow, blkY, out) {
        var a = topLeftAvailable ? topLeft[blkY >> 2] : leftRow[0];
        out[0] = (((a + (leftRow[blkY] << 1) + leftRow[blkY + 1] + 2) >> 2) << 24 >> 24);
        for (var i = 1; i < 7; i++) 
            out[i] = (((leftRow[blkY + i - 1] + (leftRow[blkY + i] << 1) + leftRow[blkY + i + 1] + 2) >> 2) << 24 >> 24);
        out[7] = (((leftRow[blkY + 6] + (leftRow[blkY + 7] << 1) + leftRow[blkY + 7] + 2) >> 2) << 24 >> 24);
    };
    prototype.interpolateTopLeft = function(topAvailable, leftAvailable, topLeft, topLine, leftRow, mbOffX, blkX, blkY) {
        var a = topLeft[blkY >> 2];
        var b = topAvailable ? topLine[mbOffX + blkX] : a;
        var c = leftAvailable ? leftRow[blkY] : a;
        var aa = a << 1;
        return (aa + b + c + 2) >> 2;
    };
    prototype.copyAdd = function(pred, srcOff, residual, pixOff, rOff, out) {
        out[pixOff] = (MathUtil.clip(residual[rOff] + pred[srcOff], -128, 127) << 24 >> 24);
        out[pixOff + 1] = (MathUtil.clip(residual[rOff + 1] + pred[srcOff + 1], -128, 127) << 24 >> 24);
        out[pixOff + 2] = (MathUtil.clip(residual[rOff + 2] + pred[srcOff + 2], -128, 127) << 24 >> 24);
        out[pixOff + 3] = (MathUtil.clip(residual[rOff + 3] + pred[srcOff + 3], -128, 127) << 24 >> 24);
        out[pixOff + 4] = (MathUtil.clip(residual[rOff + 4] + pred[srcOff + 4], -128, 127) << 24 >> 24);
        out[pixOff + 5] = (MathUtil.clip(residual[rOff + 5] + pred[srcOff + 5], -128, 127) << 24 >> 24);
        out[pixOff + 6] = (MathUtil.clip(residual[rOff + 6] + pred[srcOff + 6], -128, 127) << 24 >> 24);
        out[pixOff + 7] = (MathUtil.clip(residual[rOff + 7] + pred[srcOff + 7], -128, 127) << 24 >> 24);
    };
    prototype.fillAdd = function(residual, pixOff, val, pixOut) {
        var rOff = 0;
        for (var i = 0; i < 8; i++) {
            pixOut[pixOff] = (MathUtil.clip(residual[rOff] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 1] = (MathUtil.clip(residual[rOff + 1] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 2] = (MathUtil.clip(residual[rOff + 2] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 3] = (MathUtil.clip(residual[rOff + 3] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 4] = (MathUtil.clip(residual[rOff + 4] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 5] = (MathUtil.clip(residual[rOff + 5] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 6] = (MathUtil.clip(residual[rOff + 6] + val, -128, 127) << 24 >> 24);
            pixOut[pixOff + 7] = (MathUtil.clip(residual[rOff + 7] + val, -128, 127) << 24 >> 24);
            pixOff += 16;
            rOff += 8;
        }
    };
    prototype.predictVertical = function(residual, topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX, blkX, blkY, pixOut) {
        this.interpolateTop(topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX + blkX, blkY, this.topBuf);
        var pixOff = (blkY << 4) + blkX;
        var rOff = 0;
        for (var i = 0; i < 8; i++) {
            pixOut[pixOff] = (MathUtil.clip(residual[rOff] + this.topBuf[0], -128, 127) << 24 >> 24);
            pixOut[pixOff + 1] = (MathUtil.clip(residual[rOff + 1] + this.topBuf[1], -128, 127) << 24 >> 24);
            pixOut[pixOff + 2] = (MathUtil.clip(residual[rOff + 2] + this.topBuf[2], -128, 127) << 24 >> 24);
            pixOut[pixOff + 3] = (MathUtil.clip(residual[rOff + 3] + this.topBuf[3], -128, 127) << 24 >> 24);
            pixOut[pixOff + 4] = (MathUtil.clip(residual[rOff + 4] + this.topBuf[4], -128, 127) << 24 >> 24);
            pixOut[pixOff + 5] = (MathUtil.clip(residual[rOff + 5] + this.topBuf[5], -128, 127) << 24 >> 24);
            pixOut[pixOff + 6] = (MathUtil.clip(residual[rOff + 6] + this.topBuf[6], -128, 127) << 24 >> 24);
            pixOut[pixOff + 7] = (MathUtil.clip(residual[rOff + 7] + this.topBuf[7], -128, 127) << 24 >> 24);
            pixOff += 16;
            rOff += 8;
        }
    };
    prototype.predictHorizontal = function(residual, topLeftAvailable, topLeft, leftRow, mbOffX, blkX, blkY, pixOut) {
        this.interpolateLeft(topLeftAvailable, topLeft, leftRow, blkY, this.leftBuf);
        var pixOff = (blkY << 4) + blkX;
        var rOff = 0;
        for (var i = 0; i < 8; i++) {
            pixOut[pixOff] = (MathUtil.clip(residual[rOff] + this.leftBuf[i], -128, 127) << 24 >> 24);
            pixOut[pixOff + 1] = (MathUtil.clip(residual[rOff + 1] + this.leftBuf[i], -128, 127) << 24 >> 24);
            pixOut[pixOff + 2] = (MathUtil.clip(residual[rOff + 2] + this.leftBuf[i], -128, 127) << 24 >> 24);
            pixOut[pixOff + 3] = (MathUtil.clip(residual[rOff + 3] + this.leftBuf[i], -128, 127) << 24 >> 24);
            pixOut[pixOff + 4] = (MathUtil.clip(residual[rOff + 4] + this.leftBuf[i], -128, 127) << 24 >> 24);
            pixOut[pixOff + 5] = (MathUtil.clip(residual[rOff + 5] + this.leftBuf[i], -128, 127) << 24 >> 24);
            pixOut[pixOff + 6] = (MathUtil.clip(residual[rOff + 6] + this.leftBuf[i], -128, 127) << 24 >> 24);
            pixOut[pixOff + 7] = (MathUtil.clip(residual[rOff + 7] + this.leftBuf[i], -128, 127) << 24 >> 24);
            pixOff += 16;
            rOff += 8;
        }
    };
    prototype.predictDC = function(residual, topLeftAvailable, topRightAvailable, leftAvailable, topAvailable, topLeft, leftRow, topLine, mbOffX, blkX, blkY, pixOut) {
        if (topAvailable && leftAvailable) {
            this.interpolateTop(topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX + blkX, blkY, this.topBuf);
            this.interpolateLeft(topLeftAvailable, topLeft, leftRow, blkY, this.leftBuf);
            var sum1 = this.topBuf[0] + this.topBuf[1] + this.topBuf[2] + this.topBuf[3];
            var sum2 = this.topBuf[4] + this.topBuf[5] + this.topBuf[6] + this.topBuf[7];
            var sum3 = this.leftBuf[0] + this.leftBuf[1] + this.leftBuf[2] + this.leftBuf[3];
            var sum4 = this.leftBuf[4] + this.leftBuf[5] + this.leftBuf[6] + this.leftBuf[7];
            this.fillAdd(residual, (blkY << 4) + blkX, (sum1 + sum2 + sum3 + sum4 + 8) >> 4, pixOut);
        } else if (leftAvailable) {
            this.interpolateLeft(topLeftAvailable, topLeft, leftRow, blkY, this.leftBuf);
            var sum3 = this.leftBuf[0] + this.leftBuf[1] + this.leftBuf[2] + this.leftBuf[3];
            var sum4 = this.leftBuf[4] + this.leftBuf[5] + this.leftBuf[6] + this.leftBuf[7];
            this.fillAdd(residual, (blkY << 4) + blkX, (sum3 + sum4 + 4) >> 3, pixOut);
        } else if (topAvailable) {
            this.interpolateTop(topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX + blkX, blkY, this.topBuf);
            var sum1 = this.topBuf[0] + this.topBuf[1] + this.topBuf[2] + this.topBuf[3];
            var sum2 = this.topBuf[4] + this.topBuf[5] + this.topBuf[6] + this.topBuf[7];
            this.fillAdd(residual, (blkY << 4) + blkX, (sum1 + sum2 + 4) >> 3, pixOut);
        } else {
            this.fillAdd(residual, (blkY << 4) + blkX, 0, pixOut);
        }
    };
    prototype.predictDiagonalDownLeft = function(residual, topLeftAvailable, topAvailable, topRightAvailable, topLeft, topLine, mbOffX, blkX, blkY, pixOut) {
        this.interpolateTop(topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX + blkX, blkY, this.topBuf);
        this.genBuf[0] = (((this.topBuf[0] + this.topBuf[2] + ((this.topBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[1] = (((this.topBuf[1] + this.topBuf[3] + ((this.topBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[2] = (((this.topBuf[2] + this.topBuf[4] + ((this.topBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[3] = (((this.topBuf[3] + this.topBuf[5] + ((this.topBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[4] = (((this.topBuf[4] + this.topBuf[6] + ((this.topBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[5] = (((this.topBuf[5] + this.topBuf[7] + ((this.topBuf[6]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[6] = (((this.topBuf[6] + this.topBuf[8] + ((this.topBuf[7]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[7] = (((this.topBuf[7] + this.topBuf[9] + ((this.topBuf[8]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[8] = (((this.topBuf[8] + this.topBuf[10] + ((this.topBuf[9]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[9] = (((this.topBuf[9] + this.topBuf[11] + ((this.topBuf[10]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[10] = (((this.topBuf[10] + this.topBuf[12] + ((this.topBuf[11]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[11] = (((this.topBuf[11] + this.topBuf[13] + ((this.topBuf[12]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[12] = (((this.topBuf[12] + this.topBuf[14] + ((this.topBuf[13]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[13] = (((this.topBuf[13] + this.topBuf[15] + ((this.topBuf[14]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[14] = (((this.topBuf[14] + this.topBuf[15] + ((this.topBuf[15]) << 1) + 2) >> 2) << 24 >> 24);
        var off = (blkY << 4) + blkX;
        this.copyAdd(this.genBuf, 0, residual, off, 0, pixOut);
        this.copyAdd(this.genBuf, 1, residual, off + 16, 8, pixOut);
        this.copyAdd(this.genBuf, 2, residual, off + 32, 16, pixOut);
        this.copyAdd(this.genBuf, 3, residual, off + 48, 24, pixOut);
        this.copyAdd(this.genBuf, 4, residual, off + 64, 32, pixOut);
        this.copyAdd(this.genBuf, 5, residual, off + 80, 40, pixOut);
        this.copyAdd(this.genBuf, 6, residual, off + 96, 48, pixOut);
        this.copyAdd(this.genBuf, 7, residual, off + 112, 56, pixOut);
    };
    prototype.predictDiagonalDownRight = function(residual, topRightAvailable, topLeft, leftRow, topLine, mbOffX, blkX, blkY, pixOut) {
        this.interpolateTop(true, topRightAvailable, topLeft, topLine, mbOffX + blkX, blkY, this.topBuf);
        this.interpolateLeft(true, topLeft, leftRow, blkY, this.leftBuf);
        var tl = this.interpolateTopLeft(true, true, topLeft, topLine, leftRow, mbOffX, blkX, blkY);
        this.genBuf[0] = (((this.leftBuf[7] + this.leftBuf[5] + ((this.leftBuf[6]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[1] = (((this.leftBuf[6] + this.leftBuf[4] + ((this.leftBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[2] = (((this.leftBuf[5] + this.leftBuf[3] + ((this.leftBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[3] = (((this.leftBuf[4] + this.leftBuf[2] + ((this.leftBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[4] = (((this.leftBuf[3] + this.leftBuf[1] + ((this.leftBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[5] = (((this.leftBuf[2] + this.leftBuf[0] + ((this.leftBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[6] = (((this.leftBuf[1] + tl + ((this.leftBuf[0]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[7] = (((this.leftBuf[0] + this.topBuf[0] + ((tl) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[8] = (((tl + this.topBuf[1] + ((this.topBuf[0]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[9] = (((this.topBuf[0] + this.topBuf[2] + ((this.topBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[10] = (((this.topBuf[1] + this.topBuf[3] + ((this.topBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[11] = (((this.topBuf[2] + this.topBuf[4] + ((this.topBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[12] = (((this.topBuf[3] + this.topBuf[5] + ((this.topBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[13] = (((this.topBuf[4] + this.topBuf[6] + ((this.topBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[14] = (((this.topBuf[5] + this.topBuf[7] + ((this.topBuf[6]) << 1) + 2) >> 2) << 24 >> 24);
        var off = (blkY << 4) + blkX;
        this.copyAdd(this.genBuf, 7, residual, off, 0, pixOut);
        this.copyAdd(this.genBuf, 6, residual, off + 16, 8, pixOut);
        this.copyAdd(this.genBuf, 5, residual, off + 32, 16, pixOut);
        this.copyAdd(this.genBuf, 4, residual, off + 48, 24, pixOut);
        this.copyAdd(this.genBuf, 3, residual, off + 64, 32, pixOut);
        this.copyAdd(this.genBuf, 2, residual, off + 80, 40, pixOut);
        this.copyAdd(this.genBuf, 1, residual, off + 96, 48, pixOut);
        this.copyAdd(this.genBuf, 0, residual, off + 112, 56, pixOut);
    };
    prototype.predictVerticalRight = function(residual, topRightAvailable, topLeft, leftRow, topLine, mbOffX, blkX, blkY, pixOut) {
        this.interpolateTop(true, topRightAvailable, topLeft, topLine, mbOffX + blkX, blkY, this.topBuf);
        this.interpolateLeft(true, topLeft, leftRow, blkY, this.leftBuf);
        var tl = this.interpolateTopLeft(true, true, topLeft, topLine, leftRow, mbOffX, blkX, blkY);
        this.genBuf[0] = (((this.leftBuf[5] + this.leftBuf[3] + ((this.leftBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[1] = (((this.leftBuf[3] + this.leftBuf[1] + ((this.leftBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[2] = (((this.leftBuf[1] + tl + ((this.leftBuf[0]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[3] = (((tl + this.topBuf[0] + 1) >> 1) << 24 >> 24);
        this.genBuf[4] = (((this.topBuf[0] + this.topBuf[1] + 1) >> 1) << 24 >> 24);
        this.genBuf[5] = (((this.topBuf[1] + this.topBuf[2] + 1) >> 1) << 24 >> 24);
        this.genBuf[6] = (((this.topBuf[2] + this.topBuf[3] + 1) >> 1) << 24 >> 24);
        this.genBuf[7] = (((this.topBuf[3] + this.topBuf[4] + 1) >> 1) << 24 >> 24);
        this.genBuf[8] = (((this.topBuf[4] + this.topBuf[5] + 1) >> 1) << 24 >> 24);
        this.genBuf[9] = (((this.topBuf[5] + this.topBuf[6] + 1) >> 1) << 24 >> 24);
        this.genBuf[10] = (((this.topBuf[6] + this.topBuf[7] + 1) >> 1) << 24 >> 24);
        this.genBuf[11] = (((this.leftBuf[6] + this.leftBuf[4] + ((this.leftBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[12] = (((this.leftBuf[4] + this.leftBuf[2] + ((this.leftBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[13] = (((this.leftBuf[2] + this.leftBuf[0] + ((this.leftBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[14] = (((this.leftBuf[0] + this.topBuf[0] + ((tl) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[15] = (((tl + this.topBuf[1] + ((this.topBuf[0]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[16] = (((this.topBuf[0] + this.topBuf[2] + ((this.topBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[17] = (((this.topBuf[1] + this.topBuf[3] + ((this.topBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[18] = (((this.topBuf[2] + this.topBuf[4] + ((this.topBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[19] = (((this.topBuf[3] + this.topBuf[5] + ((this.topBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[20] = (((this.topBuf[4] + this.topBuf[6] + ((this.topBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[21] = (((this.topBuf[5] + this.topBuf[7] + ((this.topBuf[6]) << 1) + 2) >> 2) << 24 >> 24);
        var off = (blkY << 4) + blkX;
        this.copyAdd(this.genBuf, 3, residual, off, 0, pixOut);
        this.copyAdd(this.genBuf, 14, residual, off + 16, 8, pixOut);
        this.copyAdd(this.genBuf, 2, residual, off + 32, 16, pixOut);
        this.copyAdd(this.genBuf, 13, residual, off + 48, 24, pixOut);
        this.copyAdd(this.genBuf, 1, residual, off + 64, 32, pixOut);
        this.copyAdd(this.genBuf, 12, residual, off + 80, 40, pixOut);
        this.copyAdd(this.genBuf, 0, residual, off + 96, 48, pixOut);
        this.copyAdd(this.genBuf, 11, residual, off + 112, 56, pixOut);
    };
    prototype.predictHorizontalDown = function(residual, topRightAvailable, topLeft, leftRow, topLine, mbOffX, blkX, blkY, pixOut) {
        this.interpolateTop(true, topRightAvailable, topLeft, topLine, mbOffX + blkX, blkY, this.topBuf);
        this.interpolateLeft(true, topLeft, leftRow, blkY, this.leftBuf);
        var tl = this.interpolateTopLeft(true, true, topLeft, topLine, leftRow, mbOffX, blkX, blkY);
        this.genBuf[0] = (((this.leftBuf[7] + this.leftBuf[6] + 1) >> 1) << 24 >> 24);
        this.genBuf[1] = (((this.leftBuf[5] + this.leftBuf[7] + (this.leftBuf[6] << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[2] = (((this.leftBuf[6] + this.leftBuf[5] + 1) >> 1) << 24 >> 24);
        this.genBuf[3] = (((this.leftBuf[4] + this.leftBuf[6] + ((this.leftBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[4] = (((this.leftBuf[5] + this.leftBuf[4] + 1) >> 1) << 24 >> 24);
        this.genBuf[5] = (((this.leftBuf[3] + this.leftBuf[5] + ((this.leftBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[6] = (((this.leftBuf[4] + this.leftBuf[3] + 1) >> 1) << 24 >> 24);
        this.genBuf[7] = (((this.leftBuf[2] + this.leftBuf[4] + ((this.leftBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[8] = (((this.leftBuf[3] + this.leftBuf[2] + 1) >> 1) << 24 >> 24);
        this.genBuf[9] = (((this.leftBuf[1] + this.leftBuf[3] + ((this.leftBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[10] = (((this.leftBuf[2] + this.leftBuf[1] + 1) >> 1) << 24 >> 24);
        this.genBuf[11] = (((this.leftBuf[0] + this.leftBuf[2] + ((this.leftBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[12] = (((this.leftBuf[1] + this.leftBuf[0] + 1) >> 1) << 24 >> 24);
        this.genBuf[13] = (((tl + this.leftBuf[1] + ((this.leftBuf[0]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[14] = (((this.leftBuf[0] + tl + 1) >> 1) << 24 >> 24);
        this.genBuf[15] = (((this.leftBuf[0] + this.topBuf[0] + ((tl) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[16] = (((tl + this.topBuf[1] + ((this.topBuf[0]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[17] = (((this.topBuf[0] + this.topBuf[2] + ((this.topBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[18] = (((this.topBuf[1] + this.topBuf[3] + ((this.topBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[19] = (((this.topBuf[2] + this.topBuf[4] + ((this.topBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[20] = (((this.topBuf[3] + this.topBuf[5] + ((this.topBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[21] = (((this.topBuf[4] + this.topBuf[6] + ((this.topBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        var off = (blkY << 4) + blkX;
        this.copyAdd(this.genBuf, 14, residual, off, 0, pixOut);
        this.copyAdd(this.genBuf, 12, residual, off + 16, 8, pixOut);
        this.copyAdd(this.genBuf, 10, residual, off + 32, 16, pixOut);
        this.copyAdd(this.genBuf, 8, residual, off + 48, 24, pixOut);
        this.copyAdd(this.genBuf, 6, residual, off + 64, 32, pixOut);
        this.copyAdd(this.genBuf, 4, residual, off + 80, 40, pixOut);
        this.copyAdd(this.genBuf, 2, residual, off + 96, 48, pixOut);
        this.copyAdd(this.genBuf, 0, residual, off + 112, 56, pixOut);
    };
    prototype.predictVerticalLeft = function(residual, topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX, blkX, blkY, pixOut) {
        this.interpolateTop(topLeftAvailable, topRightAvailable, topLeft, topLine, mbOffX + blkX, blkY, this.topBuf);
        this.genBuf[0] = (((this.topBuf[0] + this.topBuf[1] + 1) >> 1) << 24 >> 24);
        this.genBuf[1] = (((this.topBuf[1] + this.topBuf[2] + 1) >> 1) << 24 >> 24);
        this.genBuf[2] = (((this.topBuf[2] + this.topBuf[3] + 1) >> 1) << 24 >> 24);
        this.genBuf[3] = (((this.topBuf[3] + this.topBuf[4] + 1) >> 1) << 24 >> 24);
        this.genBuf[4] = (((this.topBuf[4] + this.topBuf[5] + 1) >> 1) << 24 >> 24);
        this.genBuf[5] = (((this.topBuf[5] + this.topBuf[6] + 1) >> 1) << 24 >> 24);
        this.genBuf[6] = (((this.topBuf[6] + this.topBuf[7] + 1) >> 1) << 24 >> 24);
        this.genBuf[7] = (((this.topBuf[7] + this.topBuf[8] + 1) >> 1) << 24 >> 24);
        this.genBuf[8] = (((this.topBuf[8] + this.topBuf[9] + 1) >> 1) << 24 >> 24);
        this.genBuf[9] = (((this.topBuf[9] + this.topBuf[10] + 1) >> 1) << 24 >> 24);
        this.genBuf[10] = (((this.topBuf[10] + this.topBuf[11] + 1) >> 1) << 24 >> 24);
        this.genBuf[11] = (((this.topBuf[0] + this.topBuf[2] + ((this.topBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[12] = (((this.topBuf[1] + this.topBuf[3] + ((this.topBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[13] = (((this.topBuf[2] + this.topBuf[4] + ((this.topBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[14] = (((this.topBuf[3] + this.topBuf[5] + ((this.topBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[15] = (((this.topBuf[4] + this.topBuf[6] + ((this.topBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[16] = (((this.topBuf[5] + this.topBuf[7] + ((this.topBuf[6]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[17] = (((this.topBuf[6] + this.topBuf[8] + ((this.topBuf[7]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[18] = (((this.topBuf[7] + this.topBuf[9] + ((this.topBuf[8]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[19] = (((this.topBuf[8] + this.topBuf[10] + ((this.topBuf[9]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[20] = (((this.topBuf[9] + this.topBuf[11] + ((this.topBuf[10]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[21] = (((this.topBuf[10] + this.topBuf[12] + ((this.topBuf[11]) << 1) + 2) >> 2) << 24 >> 24);
        var off = (blkY << 4) + blkX;
        this.copyAdd(this.genBuf, 0, residual, off, 0, pixOut);
        this.copyAdd(this.genBuf, 11, residual, off + 16, 8, pixOut);
        this.copyAdd(this.genBuf, 1, residual, off + 32, 16, pixOut);
        this.copyAdd(this.genBuf, 12, residual, off + 48, 24, pixOut);
        this.copyAdd(this.genBuf, 2, residual, off + 64, 32, pixOut);
        this.copyAdd(this.genBuf, 13, residual, off + 80, 40, pixOut);
        this.copyAdd(this.genBuf, 3, residual, off + 96, 48, pixOut);
        this.copyAdd(this.genBuf, 14, residual, off + 112, 56, pixOut);
    };
    prototype.predictHorizontalUp = function(residual, topLeftAvailable, topLeft, leftRow, mbOffX, blkX, blkY, pixOut) {
        this.interpolateLeft(topLeftAvailable, topLeft, leftRow, blkY, this.leftBuf);
        this.genBuf[0] = (((this.leftBuf[0] + this.leftBuf[1] + 1) >> 1) << 24 >> 24);
        this.genBuf[1] = (((this.leftBuf[2] + this.leftBuf[0] + ((this.leftBuf[1]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[2] = (((this.leftBuf[1] + this.leftBuf[2] + 1) >> 1) << 24 >> 24);
        this.genBuf[3] = (((this.leftBuf[3] + this.leftBuf[1] + ((this.leftBuf[2]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[4] = (((this.leftBuf[2] + this.leftBuf[3] + 1) >> 1) << 24 >> 24);
        this.genBuf[5] = (((this.leftBuf[4] + this.leftBuf[2] + ((this.leftBuf[3]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[6] = (((this.leftBuf[3] + this.leftBuf[4] + 1) >> 1) << 24 >> 24);
        this.genBuf[7] = (((this.leftBuf[5] + this.leftBuf[3] + ((this.leftBuf[4]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[8] = (((this.leftBuf[4] + this.leftBuf[5] + 1) >> 1) << 24 >> 24);
        this.genBuf[9] = (((this.leftBuf[6] + this.leftBuf[4] + ((this.leftBuf[5]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[10] = (((this.leftBuf[5] + this.leftBuf[6] + 1) >> 1) << 24 >> 24);
        this.genBuf[11] = (((this.leftBuf[7] + this.leftBuf[5] + ((this.leftBuf[6]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[12] = (((this.leftBuf[6] + this.leftBuf[7] + 1) >> 1) << 24 >> 24);
        this.genBuf[13] = (((this.leftBuf[6] + this.leftBuf[7] + ((this.leftBuf[7]) << 1) + 2) >> 2) << 24 >> 24);
        this.genBuf[14] = this.genBuf[15] = this.genBuf[16] = this.genBuf[17] = this.genBuf[18] = this.genBuf[19] = this.genBuf[20] = this.genBuf[21] = this.leftBuf[7];
        var off = (blkY << 4) + blkX;
        this.copyAdd(this.genBuf, 0, residual, off, 0, pixOut);
        this.copyAdd(this.genBuf, 2, residual, off + 16, 8, pixOut);
        this.copyAdd(this.genBuf, 4, residual, off + 32, 16, pixOut);
        this.copyAdd(this.genBuf, 6, residual, off + 48, 24, pixOut);
        this.copyAdd(this.genBuf, 8, residual, off + 64, 32, pixOut);
        this.copyAdd(this.genBuf, 10, residual, off + 80, 40, pixOut);
        this.copyAdd(this.genBuf, 12, residual, off + 96, 48, pixOut);
        this.copyAdd(this.genBuf, 14, residual, off + 112, 56, pixOut);
    };
}, {topBuf: "Int8Array", leftBuf: "Int8Array", genBuf: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var MPEGDemuxer = function() {};
MPEGDemuxer = stjs.extend(MPEGDemuxer, null, [Demuxer], function(constructor, prototype) {
    prototype.getTracks = function() {};
    prototype.getVideoTracks = function() {};
    prototype.getAudioTracks = function() {};
    constructor.MPEGDemuxerTrack = function() {};
    constructor.MPEGDemuxerTrack = stjs.extend(constructor.MPEGDemuxerTrack, null, [DemuxerTrack], function(constructor, prototype) {
        prototype.nextFrameWithBuffer = function(buf) {};
        prototype.getMeta = function() {};
        prototype.getSid = function() {};
        prototype.getPending = function() {};
        prototype.ignore = function() {};
    }, {}, {});
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FileChannelWrapper = function(ch) {
    this.ch = ch;
};
FileChannelWrapper = stjs.extend(FileChannelWrapper, null, [SeekableByteChannel], function(constructor, prototype) {
    prototype.ch = null;
    prototype.read = function(arg0) {
        return this.ch.read(arg0);
    };
    prototype.close = function() {
        this.ch.close();
    };
    prototype.isOpen = function() {
        return this.ch.isOpen();
    };
    prototype.write = function(arg0) {
        return this.ch.write(arg0);
    };
    prototype.position = function() {
        return this.ch.position();
    };
    prototype.setPosition = function(newPosition) {
        this.ch.position(newPosition);
        return this;
    };
    prototype.size = function() {
        return this.ch.size();
    };
    prototype.truncate = function(size) {
        this.ch.truncate(size);
        return this;
    };
}, {ch: "FileChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ChannelLayout = function(code, labels) {
    this.code = code;
    this.labels = labels;
    ChannelLayout._values.add(this);
};
ChannelLayout = stjs.extend(ChannelLayout, null, [], function(constructor, prototype) {
    constructor._values = new ArrayList();
    constructor.kCAFChannelLayoutTag_UseChannelDescriptions = new ChannelLayout((0 << 16) | 0, []);
    constructor.kCAFChannelLayoutTag_UseChannelBitmap = new ChannelLayout((1 << 16) | 0, []);
    constructor.kCAFChannelLayoutTag_Mono = new ChannelLayout((100 << 16) | 1, [Label.Mono]);
    constructor.kCAFChannelLayoutTag_Stereo = new ChannelLayout((101 << 16) | 2, [Label.Left, Label.Right]);
    constructor.kCAFChannelLayoutTag_StereoHeadphones = new ChannelLayout((102 << 16) | 2, [Label.HeadphonesLeft, Label.HeadphonesRight]);
    constructor.kCAFChannelLayoutTag_MatrixStereo = new ChannelLayout((103 << 16) | 2, [Label.LeftTotal, Label.RightTotal]);
    constructor.kCAFChannelLayoutTag_MidSide = new ChannelLayout((104 << 16) | 2, [Label.MS_Mid, Label.MS_Side]);
    constructor.kCAFChannelLayoutTag_XY = new ChannelLayout((105 << 16) | 2, [Label.XY_X, Label.XY_Y]);
    constructor.kCAFChannelLayoutTag_Binaural = new ChannelLayout((106 << 16) | 2, [Label.HeadphonesLeft, Label.HeadphonesRight]);
    constructor.kCAFChannelLayoutTag_Ambisonic_B_Format = new ChannelLayout((107 << 16) | 4, [Label.Ambisonic_W, Label.Ambisonic_X, Label.Ambisonic_Y, Label.Ambisonic_Z]);
    constructor.kCAFChannelLayoutTag_Quadraphonic = new ChannelLayout((108 << 16) | 4, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround]);
    constructor.kCAFChannelLayoutTag_Pentagonal = new ChannelLayout((109 << 16) | 5, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.Center]);
    constructor.kCAFChannelLayoutTag_Hexagonal = new ChannelLayout((110 << 16) | 6, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.Center, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_Octagonal = new ChannelLayout((111 << 16) | 8, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.Center, Label.CenterSurround, Label.LeftCenter, Label.RightCenter]);
    constructor.kCAFChannelLayoutTag_Cube = new ChannelLayout((112 << 16) | 8, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.TopBackLeft, Label.TopBackRight, Label.TopBackCenter, Label.TopCenterSurround]);
    constructor.kCAFChannelLayoutTag_MPEG_3_0_A = new ChannelLayout((113 << 16) | 3, [Label.Left, Label.Right, Label.Center]);
    constructor.kCAFChannelLayoutTag_MPEG_3_0_B = new ChannelLayout((114 << 16) | 3, [Label.Center, Label.Left, Label.Right]);
    constructor.kCAFChannelLayoutTag_MPEG_4_0_A = new ChannelLayout((115 << 16) | 4, [Label.Left, Label.Right, Label.Center, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_MPEG_4_0_B = new ChannelLayout((116 << 16) | 4, [Label.Center, Label.Left, Label.Right, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_MPEG_5_0_A = new ChannelLayout((117 << 16) | 5, [Label.Left, Label.Right, Label.Center, Label.LeftSurround, Label.RightSurround]);
    constructor.kCAFChannelLayoutTag_MPEG_5_0_B = new ChannelLayout((118 << 16) | 5, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.Center]);
    constructor.kCAFChannelLayoutTag_MPEG_5_0_C = new ChannelLayout((119 << 16) | 5, [Label.Left, Label.Center, Label.Right, Label.LeftSurround, Label.RightSurround]);
    constructor.kCAFChannelLayoutTag_MPEG_5_0_D = new ChannelLayout((120 << 16) | 5, [Label.Center, Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround]);
    constructor.kCAFChannelLayoutTag_MPEG_5_1_A = new ChannelLayout((121 << 16) | 6, [Label.Left, Label.Right, Label.Center, Label.LFEScreen, Label.LeftSurround, Label.RightSurround]);
    constructor.kCAFChannelLayoutTag_MPEG_5_1_B = new ChannelLayout((122 << 16) | 6, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.Center, Label.LFEScreen]);
    constructor.kCAFChannelLayoutTag_MPEG_5_1_C = new ChannelLayout((123 << 16) | 6, [Label.Left, Label.Center, Label.Right, Label.LeftSurround, Label.RightSurround, Label.LFEScreen]);
    constructor.kCAFChannelLayoutTag_MPEG_5_1_D = new ChannelLayout((124 << 16) | 6, [Label.Center, Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.LFEScreen]);
    constructor.kCAFChannelLayoutTag_MPEG_6_1_A = new ChannelLayout((125 << 16) | 7, [Label.Left, Label.Right, Label.Center, Label.LFEScreen, Label.LeftSurround, Label.RightSurround, Label.Right]);
    constructor.kCAFChannelLayoutTag_MPEG_7_1_A = new ChannelLayout((126 << 16) | 8, [Label.Left, Label.Right, Label.Center, Label.LFEScreen, Label.LeftSurround, Label.RightSurround, Label.LeftCenter, Label.RightCenter]);
    constructor.kCAFChannelLayoutTag_MPEG_7_1_B = new ChannelLayout((127 << 16) | 8, [Label.Center, Label.LeftCenter, Label.RightCenter, Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.LFEScreen]);
    constructor.kCAFChannelLayoutTag_MPEG_7_1_C = new ChannelLayout((128 << 16) | 8, [Label.Left, Label.Right, Label.Center, Label.LFEScreen, Label.LeftSurround, Label.RightSurround, Label.RearSurroundLeft, Label.RearSurroundRight]);
    constructor.kCAFChannelLayoutTag_Emagic_Default_7_1 = new ChannelLayout((129 << 16) | 8, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.Center, Label.LFEScreen, Label.LeftCenter, Label.RightCenter]);
    constructor.kCAFChannelLayoutTag_SMPTE_DTV = new ChannelLayout((130 << 16) | 8, [Label.Left, Label.Right, Label.Center, Label.LFEScreen, Label.LeftSurround, Label.RightSurround, Label.LeftTotal, Label.RightTotal]);
    constructor.kCAFChannelLayoutTag_ITU_2_1 = new ChannelLayout((131 << 16) | 3, [Label.Left, Label.Right, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_ITU_2_2 = new ChannelLayout((132 << 16) | 4, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround]);
    constructor.kCAFChannelLayoutTag_DVD_4 = new ChannelLayout((133 << 16) | 3, [Label.Left, Label.Right, Label.LFEScreen]);
    constructor.kCAFChannelLayoutTag_DVD_5 = new ChannelLayout((134 << 16) | 4, [Label.Left, Label.Right, Label.LFEScreen, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_DVD_6 = new ChannelLayout((135 << 16) | 5, [Label.Left, Label.Right, Label.LFEScreen, Label.LeftSurround, Label.RightSurround]);
    constructor.kCAFChannelLayoutTag_DVD_10 = new ChannelLayout((136 << 16) | 4, [Label.Left, Label.Right, Label.Center, Label.LFEScreen]);
    constructor.kCAFChannelLayoutTag_DVD_11 = new ChannelLayout((137 << 16) | 5, [Label.Left, Label.Right, Label.Center, Label.LFEScreen, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_DVD_18 = new ChannelLayout((138 << 16) | 5, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.LFEScreen]);
    constructor.kCAFChannelLayoutTag_AudioUnit_6_0 = new ChannelLayout((139 << 16) | 6, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.Center, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_AudioUnit_7_0 = new ChannelLayout((140 << 16) | 7, [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.Center, Label.RearSurroundLeft, Label.RearSurroundRight]);
    constructor.kCAFChannelLayoutTag_AAC_6_0 = new ChannelLayout((141 << 16) | 6, [Label.Center, Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_AAC_6_1 = new ChannelLayout((142 << 16) | 7, [Label.Center, Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.CenterSurround, Label.LFEScreen]);
    constructor.kCAFChannelLayoutTag_AAC_7_0 = new ChannelLayout((143 << 16) | 7, [Label.Center, Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.RearSurroundLeft, Label.RearSurroundRight]);
    constructor.kCAFChannelLayoutTag_AAC_Octagonal = new ChannelLayout((144 << 16) | 8, [Label.Center, Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround, Label.RearSurroundLeft, Label.RearSurroundRight, Label.CenterSurround]);
    constructor.kCAFChannelLayoutTag_TMH_10_2_std = new ChannelLayout((145 << 16) | 16, [Label.Left, Label.Right, Label.Center, Label.Mono, Label.Mono, Label.Mono, Label.LeftSurround, Label.RightSurround, Label.Mono, Label.Mono, Label.Mono, Label.Mono, Label.Mono, Label.CenterSurround, Label.LFEScreen, Label.LFE2]);
    constructor.kCAFChannelLayoutTag_TMH_10_2_full = new ChannelLayout((146 << 16) | 21, [Label.LeftCenter, Label.RightCenter, Label.Mono, Label.Mono, Label.Mono]);
    constructor.kCAFChannelLayoutTag_RESERVED_DO_NOT_USE = new ChannelLayout((147 << 16), Array(0));
    prototype.code = 0;
    prototype.labels = null;
    prototype.getCode = function() {
        return this.code;
    };
    prototype.getLabels = function() {
        return this.labels;
    };
    constructor.values = function() {
        return ChannelLayout._values.toArray(Array(0));
    };
}, {_values: {name: "List", arguments: ["ChannelLayout"]}, kCAFChannelLayoutTag_UseChannelDescriptions: "ChannelLayout", kCAFChannelLayoutTag_UseChannelBitmap: "ChannelLayout", kCAFChannelLayoutTag_Mono: "ChannelLayout", kCAFChannelLayoutTag_Stereo: "ChannelLayout", kCAFChannelLayoutTag_StereoHeadphones: "ChannelLayout", kCAFChannelLayoutTag_MatrixStereo: "ChannelLayout", kCAFChannelLayoutTag_MidSide: "ChannelLayout", kCAFChannelLayoutTag_XY: "ChannelLayout", kCAFChannelLayoutTag_Binaural: "ChannelLayout", kCAFChannelLayoutTag_Ambisonic_B_Format: "ChannelLayout", kCAFChannelLayoutTag_Quadraphonic: "ChannelLayout", kCAFChannelLayoutTag_Pentagonal: "ChannelLayout", kCAFChannelLayoutTag_Hexagonal: "ChannelLayout", kCAFChannelLayoutTag_Octagonal: "ChannelLayout", kCAFChannelLayoutTag_Cube: "ChannelLayout", kCAFChannelLayoutTag_MPEG_3_0_A: "ChannelLayout", kCAFChannelLayoutTag_MPEG_3_0_B: "ChannelLayout", kCAFChannelLayoutTag_MPEG_4_0_A: "ChannelLayout", kCAFChannelLayoutTag_MPEG_4_0_B: "ChannelLayout", kCAFChannelLayoutTag_MPEG_5_0_A: "ChannelLayout", kCAFChannelLayoutTag_MPEG_5_0_B: "ChannelLayout", kCAFChannelLayoutTag_MPEG_5_0_C: "ChannelLayout", kCAFChannelLayoutTag_MPEG_5_0_D: "ChannelLayout", kCAFChannelLayoutTag_MPEG_5_1_A: "ChannelLayout", kCAFChannelLayoutTag_MPEG_5_1_B: "ChannelLayout", kCAFChannelLayoutTag_MPEG_5_1_C: "ChannelLayout", kCAFChannelLayoutTag_MPEG_5_1_D: "ChannelLayout", kCAFChannelLayoutTag_MPEG_6_1_A: "ChannelLayout", kCAFChannelLayoutTag_MPEG_7_1_A: "ChannelLayout", kCAFChannelLayoutTag_MPEG_7_1_B: "ChannelLayout", kCAFChannelLayoutTag_MPEG_7_1_C: "ChannelLayout", kCAFChannelLayoutTag_Emagic_Default_7_1: "ChannelLayout", kCAFChannelLayoutTag_SMPTE_DTV: "ChannelLayout", kCAFChannelLayoutTag_ITU_2_1: "ChannelLayout", kCAFChannelLayoutTag_ITU_2_2: "ChannelLayout", kCAFChannelLayoutTag_DVD_4: "ChannelLayout", kCAFChannelLayoutTag_DVD_5: "ChannelLayout", kCAFChannelLayoutTag_DVD_6: "ChannelLayout", kCAFChannelLayoutTag_DVD_10: "ChannelLayout", kCAFChannelLayoutTag_DVD_11: "ChannelLayout", kCAFChannelLayoutTag_DVD_18: "ChannelLayout", kCAFChannelLayoutTag_AudioUnit_6_0: "ChannelLayout", kCAFChannelLayoutTag_AudioUnit_7_0: "ChannelLayout", kCAFChannelLayoutTag_AAC_6_0: "ChannelLayout", kCAFChannelLayoutTag_AAC_6_1: "ChannelLayout", kCAFChannelLayoutTag_AAC_7_0: "ChannelLayout", kCAFChannelLayoutTag_AAC_Octagonal: "ChannelLayout", kCAFChannelLayoutTag_TMH_10_2_std: "ChannelLayout", kCAFChannelLayoutTag_TMH_10_2_full: "ChannelLayout", kCAFChannelLayoutTag_RESERVED_DO_NOT_USE: "ChannelLayout", labels: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEG4Interpolator = function() {};
MPEG4Interpolator = stjs.extend(MPEG4Interpolator, null, [], function(constructor, prototype) {
    constructor.qpi = new Int8Array(16 * 17);
    constructor.fulpel8x8 = function(dst, dstOff, dstStride, src, srcCol, srcRow, srcWidth, srcHeight, srcStride) {
        if (srcCol < 0 || srcRow < 0 || srcCol > srcWidth - 8 || srcRow > srcHeight - 8) {
            for (var j = 0; j < 8; j++ , dstOff += dstStride) {
                for (var i = 0; i < 8; i++) {
                    var y = MathUtil.clip(srcRow + j, 0, srcHeight - 1);
                    var x = MathUtil.clip(srcCol + i, 0, srcWidth - 1);
                    dst[dstOff + i] = src[srcStride * y + x];
                }
            }
        } else {
            var srcOffset = srcRow * srcStride + srcCol;
            for (var j = 0; j < 8; j++ , dstOff += dstStride , srcOffset += srcStride) {
                for (var i = 0; i < 8; i++) {
                    dst[dstOff + i] = src[srcOffset + i];
                }
            }
        }
    };
    constructor.fulpel16x16 = function(dst, src, srcCol, srcRow, srcWidth, srcHeight, srcStride) {
        if (srcCol < 0 || srcRow < 0 || srcCol > srcWidth - 16 || srcRow > srcHeight - 16) {
            for (var j = 0; j < 16; j++) {
                for (var i = 0; i < 16; i++) {
                    var y = MathUtil.clip(srcRow + j, 0, srcHeight - 1);
                    var x = MathUtil.clip(srcCol + i, 0, srcWidth - 1);
                    dst[(j << 4) + i] = src[srcStride * y + x];
                }
            }
        } else {
            var srcOffset = srcRow * srcStride + srcCol;
            for (var j = 0; j < 16; j++) {
                for (var i = 0; i < 16; i++) {
                    dst[(j << 4) + i] = src[srcOffset + (j * srcStride + i)];
                }
            }
        }
    };
    constructor.interpolate16x16QP = function(dst, ref, x, y, w, h, dx, dy, refs, rounding) {
        var xRef = x * 4 + dx;
        var yRef = y * 4 + dy;
        var location = (dx & 3) | ((dy & 3) << 2);
        var xFull = stjs.trunc(xRef / 4);
        if (xRef < 0 && (xRef & 3) != 0) {
            xFull--;
        }
        var yFull = stjs.trunc(yRef / 4);
        if (yRef < 0 && (yRef & 3) != 0) {
            yFull--;
        }
        switch (location) {
            case 0:
                MPEG4Interpolator.fulpel16x16(dst, ref, xFull, yFull, w, h, refs);
                break;
            case 1:
                MPEG4Interpolator.horzMiddle16(dst, ref, xFull, yFull, w, h, 16, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff(dst, ref, xFull, yFull, w, h, 16, refs, rounding ? 1 : 0);
                break;
            case 2:
                MPEG4Interpolator.horzMiddle16(dst, ref, xFull, yFull, w, h, 16, refs, rounding ? 1 : 0);
                break;
            case 3:
                MPEG4Interpolator.horzMiddle16(dst, ref, xFull, yFull, w, h, 16, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff(dst, ref, xFull + 1, yFull, w, h, 16, refs, rounding ? 1 : 0);
                break;
            case 4:
                MPEG4Interpolator.vertMiddle16(dst, ref, xFull, yFull, w, h, 16, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff(dst, ref, xFull, yFull, w, h, 16, refs, rounding ? 1 : 0);
                break;
            case 5:
                MPEG4Interpolator.horzMiddle16(MPEG4Interpolator.qpi, ref, xFull, yFull, w, h, 17, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff(MPEG4Interpolator.qpi, ref, xFull, yFull, w, h, 17, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle16Safe(dst, MPEG4Interpolator.qpi, 0, 16, 16, rounding ? 1 : 0);
                MPEG4Interpolator.qOffSafe(dst, MPEG4Interpolator.qpi, 0, 16, 16, rounding ? 1 : 0);
                break;
            case 6:
                MPEG4Interpolator.horzMiddle16(MPEG4Interpolator.qpi, ref, xFull, yFull, w, h, 17, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle16Safe(dst, MPEG4Interpolator.qpi, 0, 16, 16, rounding ? 1 : 0);
                MPEG4Interpolator.qOffSafe(dst, MPEG4Interpolator.qpi, 0, 16, 16, rounding ? 1 : 0);
                break;
            case 7:
                MPEG4Interpolator.horzMiddle16(MPEG4Interpolator.qpi, ref, xFull, yFull, w, h, 17, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff(MPEG4Interpolator.qpi, ref, xFull + 1, yFull, w, h, 17, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle16Safe(dst, MPEG4Interpolator.qpi, 0, 16, 16, rounding ? 1 : 0);
                MPEG4Interpolator.qOffSafe(dst, MPEG4Interpolator.qpi, 0, 16, 16, rounding ? 1 : 0);
                break;
            case 8:
                MPEG4Interpolator.vertMiddle16(dst, ref, xFull, yFull, w, h, 16, refs, rounding ? 1 : 0);
                break;
            case 9:
                MPEG4Interpolator.horzMiddle16(MPEG4Interpolator.qpi, ref, xFull, yFull, w, h, 17, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff(MPEG4Interpolator.qpi, ref, xFull, yFull, w, h, 17, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle16Safe(dst, MPEG4Interpolator.qpi, 0, 16, 16, rounding ? 1 : 0);
                break;
            case 10:
                MPEG4Interpolator.horzMiddle16(MPEG4Interpolator.qpi, ref, xFull, yFull, w, h, 17, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle16Safe(dst, MPEG4Interpolator.qpi, 0, 16, 16, rounding ? 1 : 0);
                break;
            case 11:
                MPEG4Interpolator.horzMiddle16(MPEG4Interpolator.qpi, ref, xFull, yFull, w, h, 17, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff(MPEG4Interpolator.qpi, ref, xFull + 1, yFull, w, h, 17, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle16Safe(dst, MPEG4Interpolator.qpi, 0, 16, 16, rounding ? 1 : 0);
                break;
            case 12:
                MPEG4Interpolator.vertMiddle16(dst, ref, xFull, yFull, w, h, 16, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff(dst, ref, xFull, yFull + 1, w, h, 16, refs, rounding ? 1 : 0);
                break;
            case 13:
                MPEG4Interpolator.horzMiddle16(MPEG4Interpolator.qpi, ref, xFull, yFull, w, h, 17, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff(MPEG4Interpolator.qpi, ref, xFull, yFull, w, h, 17, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle16Safe(dst, MPEG4Interpolator.qpi, 0, 16, 16, rounding ? 1 : 0);
                MPEG4Interpolator.qOffSafe(dst, MPEG4Interpolator.qpi, 16, 16, 16, rounding ? 1 : 0);
                break;
            case 14:
                MPEG4Interpolator.horzMiddle16(MPEG4Interpolator.qpi, ref, xFull, yFull, w, h, 17, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle16Safe(dst, MPEG4Interpolator.qpi, 0, 16, 16, rounding ? 1 : 0);
                MPEG4Interpolator.qOffSafe(dst, MPEG4Interpolator.qpi, 16, 16, 16, rounding ? 1 : 0);
                break;
            case 15:
                MPEG4Interpolator.horzMiddle16(MPEG4Interpolator.qpi, ref, xFull, yFull, w, h, 17, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff(MPEG4Interpolator.qpi, ref, xFull + 1, yFull, w, h, 17, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle16Safe(dst, MPEG4Interpolator.qpi, 0, 16, 16, rounding ? 1 : 0);
                MPEG4Interpolator.qOffSafe(dst, MPEG4Interpolator.qpi, 16, 16, 16, rounding ? 1 : 0);
                break;
        }
    };
    constructor.qOffSafe = function(dst, src, srcOffset, height, srcStride, round) {
        for (var row = 0, dstOff = 0; row < height; row++ , srcOffset += srcStride) {
            for (var col = 0; col < 16; col++ , dstOff++) {
                dst[dstOff] = (((dst[dstOff] + src[srcOffset + col] + 1) >> 1) << 24 >> 24);
            }
        }
    };
    constructor.qOff = function(dst, src, x, y, w, h, height, srcStride, round) {
        if (x < 0 || y < 0 || x > w - 16 || y > h - height) {
            for (var row = 0, dstOff = 0; row < height; row++) {
                var o0 = MathUtil.clip(y + row, 0, h - 1) * srcStride;
                for (var col = 0; col < 16; col++ , dstOff++) {
                    var srcOffset = o0 + MathUtil.clip(x + col, 0, w - 1);
                    dst[dstOff] = (((dst[dstOff] + src[srcOffset] + 1) >> 1) << 24 >> 24);
                }
            }
        } else {
            MPEG4Interpolator.qOffSafe(dst, src, y * srcStride + x, height, srcStride, round);
        }
    };
    constructor.qOff8x8Safe = function(dst, dstOff, src, srcOffset, height, srcStride, round) {
        for (var row = 0; row < height; row++ , srcOffset += srcStride , dstOff += 8) {
            for (var col = 0; col < 8; col++ , dstOff++) {
                dst[dstOff] = (((dst[dstOff] + src[srcOffset + col] + 1) >> 1) << 24 >> 24);
            }
        }
    };
    constructor.qOff8x8 = function(dst, dstOff, src, x, y, w, h, height, srcStride, round) {
        if (x < 0 || y < 0 || x > w - 8 || y > h - height) {
            for (var row = 0; row < height; row++ , dstOff += 8) {
                var o0 = MathUtil.clip(y + row, 0, h - 1) * srcStride;
                for (var col = 0; col < 8; col++ , dstOff++) {
                    var srcOffset = o0 + MathUtil.clip(x + col, 0, w - 1);
                    dst[dstOff] = (((dst[dstOff] + src[srcOffset] + 1) >> 1) << 24 >> 24);
                }
            }
        } else {
            MPEG4Interpolator.qOff8x8Safe(dst, dstOff, src, y * srcStride + x, height, srcStride, round);
        }
    };
    constructor.interpolate8x8QP = function(dst, dstO, ref, x, y, w, h, dx, dy, refs, rounding) {
        var xRef = x * 4 + dx;
        var yRef = y * 4 + dy;
        var quads = (dx & 3) | ((dy & 3) << 2);
        var xInt = stjs.trunc(xRef / 4);
        if (xRef < 0 && (xRef % 4) != 0) {
            xInt--;
        }
        var yInt = stjs.trunc(yRef / 4);
        if (yRef < 0 && (yRef % 4) != 0) {
            yInt--;
        }
        switch (quads) {
            case 0:
                MPEG4Interpolator.fulpel8x8(dst, dstO, 16, ref, xInt, yInt, w, h, refs);
                break;
            case 1:
                MPEG4Interpolator.horzMiddle8(dst, dstO, ref, xInt, yInt, w, h, 8, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff8x8(dst, dstO, ref, xInt, yInt, w, h, 8, refs, rounding ? 1 : 0);
                break;
            case 2:
                MPEG4Interpolator.horzMiddle8(dst, dstO, ref, xInt, yInt, w, h, 8, refs, rounding ? 1 : 0);
                break;
            case 3:
                MPEG4Interpolator.horzMiddle8(dst, dstO, ref, xInt, yInt, w, h, 8, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff8x8(dst, dstO, ref, xInt + 1, yInt, w, h, 8, refs, rounding ? 1 : 0);
                break;
            case 4:
                MPEG4Interpolator.vertMiddle8(dst, dstO, ref, xInt, yInt, w, h, 8, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff8x8(dst, dstO, ref, xInt, yInt, w, h, 8, refs, rounding ? 1 : 0);
                break;
            case 5:
                MPEG4Interpolator.horzMiddle8(MPEG4Interpolator.qpi, 0, ref, xInt, yInt, w, h, 9, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff8x8(MPEG4Interpolator.qpi, 0, ref, xInt, yInt, w, h, 9, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle8Safe(dst, dstO, MPEG4Interpolator.qpi, 0, 8, 16, rounding ? 1 : 0);
                MPEG4Interpolator.qOff8x8Safe(dst, dstO, MPEG4Interpolator.qpi, 0, 8, 16, rounding ? 1 : 0);
                break;
            case 6:
                MPEG4Interpolator.horzMiddle8(MPEG4Interpolator.qpi, 0, ref, xInt, yInt, w, h, 9, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle8Safe(dst, dstO, MPEG4Interpolator.qpi, 0, 8, 16, rounding ? 1 : 0);
                MPEG4Interpolator.qOff8x8Safe(dst, dstO, MPEG4Interpolator.qpi, 0, 8, 16, rounding ? 1 : 0);
                break;
            case 7:
                MPEG4Interpolator.horzMiddle8(MPEG4Interpolator.qpi, 0, ref, xInt, yInt, w, h, 9, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff8x8(MPEG4Interpolator.qpi, 0, ref, xInt + 1, yInt, w, h, 9, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle8Safe(dst, dstO, MPEG4Interpolator.qpi, 0, 8, 16, rounding ? 1 : 0);
                MPEG4Interpolator.qOff8x8Safe(dst, dstO, MPEG4Interpolator.qpi, 0, 8, 16, rounding ? 1 : 0);
                break;
            case 8:
                MPEG4Interpolator.vertMiddle8(dst, dstO, ref, xInt, yInt, w, h, 8, refs, rounding ? 1 : 0);
                break;
            case 9:
                MPEG4Interpolator.horzMiddle8(MPEG4Interpolator.qpi, 0, ref, xInt, yInt, w, h, 9, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff8x8(MPEG4Interpolator.qpi, 0, ref, xInt, yInt, w, h, 9, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle8Safe(dst, dstO, MPEG4Interpolator.qpi, 0, 8, 16, rounding ? 1 : 0);
                break;
            case 10:
                MPEG4Interpolator.horzMiddle8(MPEG4Interpolator.qpi, 0, ref, xInt, yInt, w, h, 9, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle8Safe(dst, dstO, MPEG4Interpolator.qpi, 0, 8, 16, rounding ? 1 : 0);
                break;
            case 11:
                MPEG4Interpolator.horzMiddle8(MPEG4Interpolator.qpi, 0, ref, xInt, yInt, w, h, 9, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff8x8(MPEG4Interpolator.qpi, 0, ref, xInt + 1, yInt, w, h, 9, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle8Safe(dst, dstO, MPEG4Interpolator.qpi, 0, 8, 16, rounding ? 1 : 0);
                break;
            case 12:
                MPEG4Interpolator.vertMiddle8(dst, dstO, ref, xInt, yInt, w, h, 8, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff8x8(dst, dstO, ref, xInt, yInt + 1, w, h, 8, refs, rounding ? 1 : 0);
                break;
            case 13:
                MPEG4Interpolator.horzMiddle8(MPEG4Interpolator.qpi, 0, ref, xInt, yInt, w, h, 9, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff8x8(MPEG4Interpolator.qpi, 0, ref, xInt, yInt, w, h, 9, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle8Safe(dst, dstO, MPEG4Interpolator.qpi, 0, 8, 16, rounding ? 1 : 0);
                MPEG4Interpolator.qOff8x8Safe(dst, dstO, MPEG4Interpolator.qpi, 16, 8, 16, rounding ? 1 : 0);
                break;
            case 14:
                MPEG4Interpolator.horzMiddle8(MPEG4Interpolator.qpi, 0, ref, xInt, yInt, w, h, 9, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle8Safe(dst, dstO, MPEG4Interpolator.qpi, 0, 8, 16, rounding ? 1 : 0);
                MPEG4Interpolator.qOff8x8Safe(dst, dstO, MPEG4Interpolator.qpi, 16, 8, 16, rounding ? 1 : 0);
                break;
            case 15:
                MPEG4Interpolator.horzMiddle8(MPEG4Interpolator.qpi, 0, ref, xInt, yInt, w, h, 9, refs, rounding ? 1 : 0);
                MPEG4Interpolator.qOff8x8(MPEG4Interpolator.qpi, 0, ref, xInt + 1, yInt, w, h, 9, refs, rounding ? 1 : 0);
                MPEG4Interpolator.vertMiddle8Safe(dst, dstO, MPEG4Interpolator.qpi, 0, 8, 16, rounding ? 1 : 0);
                MPEG4Interpolator.qOff8x8Safe(dst, dstO, MPEG4Interpolator.qpi, 16, 8, 16, rounding ? 1 : 0);
                break;
        }
    };
    constructor.horzMiddle8 = function(dst, dstOffset, src, x, y, w, h, height, srcStride, rounding) {
        if (x < 0 || y < 0 || x > w - 9 || y > h - height) {
            for (var row = 0; row < height; row++) {
                for (var i = 0; i < 4; ++i) {
                    var sum0 = 0;
                    var sum1 = 0;
                    var o0 = MathUtil.clip(y + row, 0, h - 1) * srcStride;
                    for (var k = 0; k < 5 + i; ++k) {
                        var o1 = MathUtil.clip(x + k, 0, w - 1);
                        var o2 = MathUtil.clip(x + 8 - k, 0, w - 1);
                        sum0 += MPEG4Consts.FILTER_TAB[i][k] * src[o0 + o1];
                        sum1 += MPEG4Consts.FILTER_TAB[i][k] * src[o0 + o2];
                    }
                    dst[dstOffset + i] = (MathUtil.clip((sum0 + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                    dst[dstOffset + 7 - i] = (MathUtil.clip((sum1 + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                }
                dstOffset += 16;
            }
        } else {
            var srcOffset = y * srcStride + x;
            for (var row = 0; row < height; row++) {
                for (var i = 0; i < 4; ++i) {
                    var sum0 = 0;
                    var sum1 = 0;
                    for (var k = 0; k < 5 + i; ++k) {
                        sum0 += MPEG4Consts.FILTER_TAB[i][k] * src[srcOffset + k];
                        sum1 += MPEG4Consts.FILTER_TAB[i][k] * src[srcOffset + 8 - k];
                    }
                    dst[dstOffset + i] = (MathUtil.clip((sum0 + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                    dst[dstOffset + 7 - i] = (MathUtil.clip((sum1 + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                }
                srcOffset += srcStride;
                dstOffset += 16;
            }
        }
    };
    constructor.horzMiddle16 = function(dst, src, x, y, w, h, height, srcStride, rounding) {
        if (x < 0 || y < 0 || x > w - 17 || y > h - height) {
            var dstOffset = 0;
            for (var row = 0; row < height; row++) {
                var o0 = MathUtil.clip(y + row, 0, h - 1) * srcStride;
                for (var i = 0; i < 4; ++i) {
                    var sum0 = 0;
                    var sum1 = 0;
                    for (var k = 0; k < 5 + i; ++k) {
                        var srcOffset0 = o0 + MathUtil.clip(x + k, 0, w - 1);
                        var srcOffset1 = o0 + MathUtil.clip(x + 16 - k, 0, w - 1);
                        sum0 += MPEG4Consts.FILTER_TAB[i][k] * src[srcOffset0];
                        sum1 += MPEG4Consts.FILTER_TAB[i][k] * src[srcOffset1];
                    }
                    dst[dstOffset + i] = (MathUtil.clip((sum0 + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                    dst[dstOffset + 15 - i] = (MathUtil.clip((sum1 + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                }
                for (var i = 0; i < 8; ++i) {
                    var sum = 0;
                    for (var k = 0; k < 8; ++k) {
                        var srcOffset = o0 + MathUtil.clip(x + k + i + 1, 0, w - 1);
                        sum += MPEG4Consts.FILTER_TAB[3][k] * src[srcOffset];
                    }
                    dst[dstOffset + i + 4] = (MathUtil.clip((sum + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                }
                dstOffset += 16;
            }
        } else {
            var srcOffset = y * srcStride + x;
            var dstOffset = 0;
            for (var row = 0; row < height; row++) {
                for (var i = 0; i < 4; ++i) {
                    var sum0 = 0;
                    var sum1 = 0;
                    for (var k = 0; k < 5 + i; ++k) {
                        sum0 += MPEG4Consts.FILTER_TAB[i][k] * src[srcOffset + k];
                        sum1 += MPEG4Consts.FILTER_TAB[i][k] * src[srcOffset + 16 - k];
                    }
                    dst[dstOffset + i] = (MathUtil.clip((sum0 + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                    dst[dstOffset + 15 - i] = (MathUtil.clip((sum1 + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                }
                for (var i = 0; i < 8; ++i) {
                    var sum = 0;
                    for (var k = 0; k < 8; ++k) {
                        sum += MPEG4Consts.FILTER_TAB[3][k] * src[srcOffset + k + i + 1];
                    }
                    dst[dstOffset + i + 4] = (MathUtil.clip((sum + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                }
                srcOffset += srcStride;
                dstOffset += 16;
            }
        }
    };
    constructor.vertMiddle16Safe = function(dst, src, srcOffset, width, srcStride, rounding) {
        var dstOffset = 0;
        for (var col = 0; col < width; col++) {
            var dstStart = dstOffset, dstEnd = dstOffset + 240;
            for (var i = 0; i < 4; ++i , dstStart += 16 , dstEnd -= 16) {
                var sum0 = 0;
                var sum1 = 0;
                var ss = srcOffset;
                var es = srcOffset + (srcStride << 4);
                for (var k = 0; k < 5 + i; ++k) {
                    sum0 += MPEG4Consts.FILTER_TAB[i][k] * src[ss];
                    sum1 += MPEG4Consts.FILTER_TAB[i][k] * src[es];
                    ss += srcStride;
                    es -= srcStride;
                }
                dst[dstStart] = (MathUtil.clip((sum0 + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                dst[dstEnd] = (MathUtil.clip((sum1 + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
            }
            dstStart = dstOffset + 64;
            var srcCoeff0Pos = srcOffset + srcStride;
            for (var i = 0; i < 8; ++i , dstStart += 16 , srcCoeff0Pos += srcStride) {
                var sum = 0;
                var srcPos = srcCoeff0Pos;
                for (var k = 0; k < 8; ++k , srcPos += srcStride) {
                    sum += MPEG4Consts.FILTER_TAB[3][k] * src[srcPos];
                }
                dst[dstStart] = (MathUtil.clip((sum + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
            }
            srcOffset++;
            dstOffset++;
        }
    };
    constructor.vertMiddle16 = function(dst, src, x, y, w, h, width, srcStride, rounding) {
        if (x < 0 || y < 0 || x > w - width || y > h - 17) {
            var dstOffset = 0;
            for (var col = 0; col < width; col++) {
                var dstStart = dstOffset, dstEnd = dstOffset + 240;
                for (var i = 0; i < 4; ++i , dstStart += 16 , dstEnd -= 16) {
                    var sum0 = 0;
                    var sum1 = 0;
                    for (var k = 0; k < 5 + i; ++k) {
                        var ss = MathUtil.clip(y + k, 0, h - 1) * srcStride + MathUtil.clip(x + col, 0, w - 1);
                        var es = MathUtil.clip(y - k + 16, 0, h - 1) * srcStride + MathUtil.clip(x + col, 0, w - 1);
                        sum0 += MPEG4Consts.FILTER_TAB[i][k] * src[ss];
                        sum1 += MPEG4Consts.FILTER_TAB[i][k] * src[es];
                    }
                    dst[dstStart] = (MathUtil.clip((sum0 + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                    dst[dstEnd] = (MathUtil.clip((sum1 + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                }
                dstStart = dstOffset + 64;
                for (var i = 0; i < 8; ++i , dstStart += 16) {
                    var sum = 0;
                    for (var k = 0; k < 8; ++k) {
                        var srcPos = MathUtil.clip(y + i + k + 1, 0, h - 1) * srcStride + MathUtil.clip(x + col, 0, w - 1);
                        sum += MPEG4Consts.FILTER_TAB[3][k] * src[srcPos];
                    }
                    dst[dstStart] = (MathUtil.clip((sum + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                }
                dstOffset++;
            }
        } else {
            MPEG4Interpolator.vertMiddle16Safe(dst, src, y * srcStride + x, width, srcStride, rounding);
        }
    };
    constructor.vertMiddle8Safe = function(dst, dstOffset, src, srcOffset, width, srcStride, rounding) {
        for (var col = 0; col < width; col++) {
            for (var i = 0; i < 4; ++i) {
                var sum0 = 0;
                var sum1 = 0;
                var os = srcOffset;
                var of = srcOffset + (srcStride << 3);
                for (var k = 0; k < 5 + i; ++k) {
                    sum0 += MPEG4Consts.FILTER_TAB[i][k] * src[os];
                    sum1 += MPEG4Consts.FILTER_TAB[i][k] * src[of];
                    os += srcStride;
                    of -= srcStride;
                }
                dst[dstOffset + i * 16] = (MathUtil.clip((sum0 + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                dst[dstOffset + (7 - i) * 16] = (MathUtil.clip((sum1 + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
            }
            srcOffset++;
            dstOffset++;
        }
    };
    constructor.vertMiddle8 = function(dst, dstOffset, src, x, y, w, h, width, srcStride, rounding) {
        if (x < 0 || y < 0 || x > w - width || y > h - 9) {
            for (var col = 0; col < width; col++) {
                for (var i = 0; i < 4; ++i) {
                    var sum0 = 0;
                    var sum1 = 0;
                    for (var k = 0; k < 5 + i; ++k) {
                        var os = MathUtil.clip(y + k, 0, h - 1) * srcStride + MathUtil.clip(x + col, 0, w - 1);
                        var of = MathUtil.clip(y + 8 - k, 0, h - 1) * srcStride + MathUtil.clip(x + col, 0, w - 1);
                        sum0 += MPEG4Consts.FILTER_TAB[i][k] * src[os];
                        sum1 += MPEG4Consts.FILTER_TAB[i][k] * src[of];
                    }
                    dst[dstOffset + i * 16] = (MathUtil.clip((sum0 + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                    dst[dstOffset + (7 - i) * 16] = (MathUtil.clip((sum1 + 16 - rounding) >> 5, -128, 127) << 24 >> 24);
                }
                dstOffset++;
            }
        } else {
            MPEG4Interpolator.vertMiddle8Safe(dst, dstOffset, src, y * srcStride + x, width, srcStride, rounding);
        }
    };
    constructor.interpolate16x16Planar = function(dst, refn, x, y, w, h, dx, dy, stride, rounding) {
        MPEG4Interpolator.interpolate8x8Planar(dst, 0, 16, refn, x, y, w, h, dx, dy, stride, rounding);
        MPEG4Interpolator.interpolate8x8Planar(dst, 8, 16, refn, x + 8, y, w, h, dx, dy, stride, rounding);
        MPEG4Interpolator.interpolate8x8Planar(dst, 128, 16, refn, x, y + 8, w, h, dx, dy, stride, rounding);
        MPEG4Interpolator.interpolate8x8Planar(dst, 136, 16, refn, x + 8, y + 8, w, h, dx, dy, stride, rounding);
    };
    constructor.interpolate8x8Planar = function(dst, dstOff, dstStride, refn, x, y, w, h, dx, dy, stride, rounding) {
        var x_ = x + (dx >> 1);
        var y_ = y + (dy >> 1);
        switch (((dx & 1) << 1) + (dy & 1)) {
            case 0:
                MPEG4Interpolator.fulpel8x8(dst, dstOff, dstStride, refn, x_, y_, w, h, stride);
                break;
            case 1:
                MPEG4Interpolator.interpolate8PlanarVer(dst, dstOff, dstStride, refn, x_, y_, w, h, stride, rounding);
                break;
            case 2:
                MPEG4Interpolator.interpolate8x8PlanarHor(dst, dstOff, dstStride, refn, x_, y_, w, h, stride, rounding);
                break;
            default:
                MPEG4Interpolator.interpolate8x8PlanarBoth(dst, dstOff, dstStride, refn, x_, y_, w, h, stride, rounding);
                break;
        }
    };
    constructor.interpolate8x8PlanarHor = function(dst, dstOffset, dstStride, src, x, y, w, h, stride, rounding) {
        var rnd = rounding ? 0 : 1;
        if (x < 0 || y < 0 || x > w - 9 || y > h - 8) {
            for (var j = 0, d = dstOffset; j < 8; j++ , d += dstStride) {
                for (var i = 0; i < 8; i++) {
                    var srcOffset0 = MathUtil.clip(y + j, 0, h - 1) * stride + MathUtil.clip(x + i, 0, w - 1);
                    var srcOffset1 = MathUtil.clip(y + j, 0, h - 1) * stride + MathUtil.clip(x + i + 1, 0, w - 1);
                    dst[d + i] = (((src[srcOffset0] + src[srcOffset1] + rnd) >> 1) << 24 >> 24);
                }
            }
        } else {
            var srcOffset = y * stride + x;
            for (var j = 0, d = dstOffset; j < 8 * stride; j += stride , d += dstStride) {
                for (var i = 0; i < 8; i++) 
                    dst[d + i] = (((src[srcOffset + j + i] + src[srcOffset + j + i + 1] + rnd) >> 1) << 24 >> 24);
            }
        }
    };
    constructor.interpolate8PlanarVer = function(dst, dstOff, dstStride, src, x, y, w, h, stride, rounding) {
        var rnd = rounding ? 0 : 1;
        if (x < 0 || y < 0 || x > w - 8 || y > h - 9) {
            for (var j = 0, d = dstOff; j < 8; j++ , d += dstStride) {
                for (var i = 0; i < 8; i++) {
                    var srcOffset0 = MathUtil.clip(y + j, 0, h - 1) * stride + MathUtil.clip(x + i, 0, w - 1);
                    var srcOffset1 = MathUtil.clip(y + j + 1, 0, h - 1) * stride + MathUtil.clip(x + i, 0, w - 1);
                    dst[d + i] = (((src[srcOffset0] + src[srcOffset1] + rnd) >> 1) << 24 >> 24);
                }
            }
        } else {
            var srcOffset = y * stride + x;
            for (var j = 0, d = dstOff; j < 8 * stride; j += stride , d += dstStride) {
                for (var i = 0; i < 8; i++) 
                    dst[d + i] = (((src[srcOffset + j + i] + src[srcOffset + j + stride + i] + rnd) >> 1) << 24 >> 24);
            }
        }
    };
    constructor.interpolate8x8PlanarBoth = function(dst, dstOff, dstStride, src, x, y, w, h, stride, rounding) {
        var rnd = rounding ? 1 : 2;
        if (x < 0 || y < 0 || x > w - 9 || y > h - 9) {
            for (var j = 0, d = dstOff; j < 8; j++ , d += dstStride) {
                for (var i = 0; i < 8; i++) {
                    var srcOffset0 = MathUtil.clip(y + j, 0, h - 1) * stride + MathUtil.clip(x + i, 0, w - 1);
                    var srcOffset1 = MathUtil.clip(y + j, 0, h - 1) * stride + MathUtil.clip(x + i + 1, 0, w - 1);
                    var srcOffset2 = MathUtil.clip(y + j + 1, 0, h - 1) * stride + MathUtil.clip(x + i, 0, w - 1);
                    var srcOffset3 = MathUtil.clip(y + j + 1, 0, h - 1) * stride + MathUtil.clip(x + i + 1, 0, w - 1);
                    dst[d + i] = (((src[srcOffset0] + src[srcOffset1] + src[srcOffset2] + src[srcOffset3] + rnd) >> 2) << 24 >> 24);
                }
            }
        } else {
            var srcOffset = y * stride + x;
            for (var j = 0, d = dstOff; j < 8 * stride; j += stride , d += dstStride) {
                for (var i = 0; i < 8; i++) 
                    dst[d + i] = (((src[srcOffset + j + i] + src[srcOffset + j + i + 1] + src[srcOffset + j + stride + i] + src[srcOffset + j + stride + i + 1] + rnd) >> 2) << 24 >> 24);
            }
        }
    };
}, {qpi: "Int8Array"}, {});
/**
 *  Resamples image interpolating points using Lanczos sinc over sine windowed
 *  filter.
 *  
 *  @author Stanislav Vitvitskiy
 */
var LanczosResampler = function(from, to) {
    BaseResampler.call(this, from, to);
    this.scaleFactorX = to.getWidth() / from.getWidth();
    this.scaleFactorY = to.getHeight() / from.getHeight();
    this.tapsXs = Array.apply(null, Array(this.precision)).map(function() {
        return new Int16Array(this._nTaps);
    });
    this.tapsYs = Array.apply(null, Array(this.precision)).map(function() {
        return new Int16Array(this._nTaps);
    });
    LanczosResampler.buildTaps(this._nTaps, this.precision, this.scaleFactorX, this.tapsXs);
    LanczosResampler.buildTaps(this._nTaps, this.precision, this.scaleFactorY, this.tapsYs);
};
LanczosResampler = stjs.extend(LanczosResampler, BaseResampler, [], function(constructor, prototype) {
    prototype._nTaps = 6;
    prototype.precision = 256;
    prototype.tapsXs = null;
    prototype.tapsYs = null;
    prototype.scaleFactorX = 0.0;
    prototype.scaleFactorY = 0.0;
    constructor.sinc = function(x) {
        return x == 0 ? 1.0 : (Math.sin(x) / x);
    };
    constructor.buildTaps = function(nTaps, precision, scaleFactor, tapsOut) {
        var taps = new Float64Array(nTaps);
        for (var i = 0; i < precision; i++) {
            var o = (i) / precision;
            for (var j = stjs.trunc(-nTaps / 2) + 1, t = 0; j < stjs.trunc(nTaps / 2) + 1; j++ , t++) {
                var x = -o + j;
                var sinc_val = scaleFactor * LanczosResampler.sinc(scaleFactor * x * Math.PI);
                var wnd_val = Math.sin((x * Math.PI) / (nTaps - 1) + Math.PI / 2);
                taps[t] = sinc_val * wnd_val;
            }
            BaseResampler.normalizeAndGenerateFixedPrecision(taps, 7, tapsOut[i]);
        }
    };
    prototype.getTapsX = function(dstX) {
        var oi = stjs.trunc(((dstX * this.precision) / this.scaleFactorX));
        var sub_pel = oi % this.precision;
        return this.tapsXs[sub_pel];
    };
    prototype.getTapsY = function(dstY) {
        var oy = stjs.trunc(((dstY * this.precision) / this.scaleFactorY));
        var sub_pel = oy % this.precision;
        return this.tapsYs[sub_pel];
    };
    prototype.nTaps = function() {
        return this._nTaps;
    };
}, {tapsXs: "Array", tapsYs: "Array", tempBuffers: {name: "ThreadLocal", arguments: ["Int32Array"]}, toSize: "Size", fromSize: "Size"}, {});
/**
 *  Resamples image interpolating points using bicubic filter.
 *  
 *  The difference from Lanczoc resampler is that a separate set of taps are
 *  generated for each destination point position.
 *  
 *  @author Stanislav Vitvitskiy
 */
var BicubicResampler = function(from, to) {
    BaseResampler.call(this, from, to);
    this.horizontalTaps = BicubicResampler.buildFilterTaps(to.getWidth(), from.getWidth());
    this.verticalTaps = BicubicResampler.buildFilterTaps(to.getHeight(), from.getHeight());
};
BicubicResampler = stjs.extend(BicubicResampler, BaseResampler, [], function(constructor, prototype) {
    prototype.horizontalTaps = null;
    prototype.verticalTaps = null;
    constructor.alpha = 0.6;
    constructor.buildFilterTaps = function(to, from) {
        var taps = new Float64Array(4);
        var tapsOut = Array.apply(null, Array(to)).map(function() {
            return new Int16Array(4);
        });
        var ratio = from / to;
        var toByFrom = to / from;
        var srcPos = 0;
        for (var i = 0; i < to; i++) {
            var fraction = srcPos - stjs.trunc(srcPos);
            for (var t = -1; t < 3; t++) {
                var d = t - fraction;
                if (to < from) {
                    d *= toByFrom;
                }
                var x = Math.abs(d);
                var xx = x * x;
                var xxx = xx * x;
                if (d >= -1 && d <= 1) {
                    taps[t + 1] = (2 - BicubicResampler.alpha) * xxx + (-3 + BicubicResampler.alpha) * xx + 1;
                } else if (d < -2 || d > 2) {
                    taps[t + 1] = 0;
                } else {
                    taps[t + 1] = -BicubicResampler.alpha * xxx + 5 * BicubicResampler.alpha * xx - 8 * BicubicResampler.alpha * x + 4 * BicubicResampler.alpha;
                }
            }
            BaseResampler.normalizeAndGenerateFixedPrecision(taps, 7, tapsOut[i]);
            srcPos += ratio;
        }
        return tapsOut;
    };
    prototype.getTapsX = function(dstX) {
        return this.horizontalTaps[dstX];
    };
    prototype.getTapsY = function(dstY) {
        return this.verticalTaps[dstY];
    };
    prototype.nTaps = function() {
        return 4;
    };
}, {horizontalTaps: "Array", verticalTaps: "Array", tempBuffers: {name: "ThreadLocal", arguments: ["Int32Array"]}, toSize: "Size", fromSize: "Size"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VideoDecoder = function() {};
VideoDecoder = stjs.extend(VideoDecoder, null, [], function(constructor, prototype) {
    prototype.byteBuffer = null;
    /**
     *  Decodes a video frame to an uncompressed picture in codec native
     *  colorspace
     *  
     *  @param data
     *             Compressed frame data
     *  @throws IOException
     */
    prototype.decodeFrame = function(data, buffer) {};
    prototype.getCodecMeta = function(data) {};
    prototype.getSameSizeBuffer = function(buffer) {
        if (this.byteBuffer == null || this.byteBuffer.length != buffer.length || this.byteBuffer[0].length != buffer[0].length) 
            this.byteBuffer = ArrayUtil.create2D(buffer[0].length, buffer.length);
        return this.byteBuffer;
    };
    /**
     *  Returns a downscaled version of this decoder
     *  @param ratio
     *  @return
     */
    prototype.downscaled = function(ratio) {
        if (ratio == 1) 
            return this;
        return null;
    };
}, {byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Debug = function() {};
Debug = stjs.extend(Debug, null, [], function(constructor, prototype) {
    constructor.print8x8i = function(output) {
        var i = 0;
        for (var x = 0; x < 8; x++) {
            for (var y = 0; y < 8; y++) {
                System.out.printf("%3d, ", output[i]);
                i++;
            }
            System.out.println();
        }
    };
    constructor.print8x8s = function(output) {
        var i = 0;
        for (var x = 0; x < 8; x++) {
            for (var y = 0; y < 8; y++) {
                System.out.printf("%3d, ", output[i]);
                i++;
            }
            System.out.println();
        }
    };
    constructor.print8x8sb = function(output) {
        for (var x = 0; x < 8; x++) {
            for (var y = 0; y < 8; y++) {
                System.out.printf("%3d, ", output.get());
            }
            System.out.println();
        }
    };
    constructor.prints = function(table) {
        var i = 0;
        for (var x = 0; x < 8; x++) {
            for (var y = 0; y < 8; y++) {
                System.out.printf("%3d, ", table[i]);
                i++;
            }
            System.out.println();
        }
    };
    constructor.trace = function(_arguments) {
        if (Debug.debug && arguments.length > 0) {
            var format = arguments[0];
            ArrayUtil.shiftLeft1(arguments);
            System.out.printf(format + ": %d\n", arguments);
        }
    };
    constructor.debug = false;
    constructor.printInt = function(i) {
        if (Debug.debug) 
            System.out.print(i);
    };
    constructor.print = function(string) {
        if (Debug.debug) 
            System.out.print(string);
    };
    constructor.println = function(string) {
        if (Debug.debug) 
            System.out.println(string);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Integer DCT 4x4 base implementation
 *  
 *  @author The JCodec project
 *  
 */
var CoeffTransformer = function() {};
CoeffTransformer = stjs.extend(CoeffTransformer, null, [], function(constructor, prototype) {
    constructor.zigzag4x4 = new Int32Array([0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15]);
    constructor.invZigzag4x4 = new Int32Array(16);
    constructor.dequantCoef = [new Int32Array([10, 13, 10, 13, 13, 16, 13, 16, 10, 13, 10, 13, 13, 16, 13, 16]), new Int32Array([11, 14, 11, 14, 14, 18, 14, 18, 11, 14, 11, 14, 14, 18, 14, 18]), new Int32Array([13, 16, 13, 16, 16, 20, 16, 20, 13, 16, 13, 16, 16, 20, 16, 20]), new Int32Array([14, 18, 14, 18, 18, 23, 18, 23, 14, 18, 14, 18, 18, 23, 18, 23]), new Int32Array([16, 20, 16, 20, 20, 25, 20, 25, 16, 20, 16, 20, 20, 25, 20, 25]), new Int32Array([18, 23, 18, 23, 23, 29, 23, 29, 18, 23, 18, 23, 23, 29, 23, 29])];
    constructor.dequantCoef8x8 = Array.apply(null, Array(6)).map(function() {
        return new Int32Array(64);
    });
    constructor.initDequantCoeff8x8 = [new Int32Array([20, 18, 32, 19, 25, 24]), new Int32Array([22, 19, 35, 21, 28, 26]), new Int32Array([26, 23, 42, 24, 33, 31]), new Int32Array([28, 25, 45, 26, 35, 33]), new Int32Array([32, 28, 51, 30, 40, 38]), new Int32Array([36, 32, 58, 34, 46, 43])];
    constructor.zigzag8x8 = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
    constructor.invZigzag8x8 = new Int32Array(64);
    constructor.quantCoeff = [new Int32Array([13107, 8066, 13107, 8066, 8066, 5243, 8066, 5243, 13107, 8066, 13107, 8066, 8066, 5243, 8066, 5243]), new Int32Array([11916, 7490, 11916, 7490, 7490, 4660, 7490, 4660, 11916, 7490, 11916, 7490, 7490, 4660, 7490, 4660]), new Int32Array([10082, 6554, 10082, 6554, 6554, 4194, 6554, 4194, 10082, 6554, 10082, 6554, 6554, 4194, 6554, 4194]), new Int32Array([9362, 5825, 9362, 5825, 5825, 3647, 5825, 3647, 9362, 5825, 9362, 5825, 5825, 3647, 5825, 3647]), new Int32Array([8192, 5243, 8192, 5243, 5243, 3355, 5243, 3355, 8192, 5243, 8192, 5243, 5243, 3355, 5243, 3355]), new Int32Array([7282, 4559, 7282, 4559, 4559, 2893, 4559, 2893, 7282, 4559, 7282, 4559, 4559, 2893, 4559, 2893])];
    /**
     *  Inverce integer DCT transform for 4x4 block
     *  
     *  @param block
     *  @return
     */
    constructor.idct4x4 = function(block) {
        CoeffTransformer._idct4x4(block, block);
    };
    constructor._idct4x4 = function(block, out) {
        for (var i = 0; i < 16; i += 4) {
            var e0 = block[i] + block[i + 2];
            var e1 = block[i] - block[i + 2];
            var e2 = (block[i + 1] >> 1) - block[i + 3];
            var e3 = block[i + 1] + (block[i + 3] >> 1);
            out[i] = e0 + e3;
            out[i + 1] = e1 + e2;
            out[i + 2] = e1 - e2;
            out[i + 3] = e0 - e3;
        }
        for (var i = 0; i < 4; i++) {
            var g0 = out[i] + out[i + 8];
            var g1 = out[i] - out[i + 8];
            var g2 = (out[i + 4] >> 1) - out[i + 12];
            var g3 = out[i + 4] + (out[i + 12] >> 1);
            out[i] = g0 + g3;
            out[i + 4] = g1 + g2;
            out[i + 8] = g1 - g2;
            out[i + 12] = g0 - g3;
        }
        for (var i = 0; i < 16; i++) {
            out[i] = (out[i] + 32) >> 6;
        }
    };
    constructor.fdct4x4 = function(block) {
        for (var i = 0; i < 16; i += 4) {
            var t0 = block[i] + block[i + 3];
            var t1 = block[i + 1] + block[i + 2];
            var t2 = block[i + 1] - block[i + 2];
            var t3 = block[i] - block[i + 3];
            block[i] = t0 + t1;
            block[i + 1] = (t3 << 1) + t2;
            block[i + 2] = t0 - t1;
            block[i + 3] = t3 - (t2 << 1);
        }
        for (var i = 0; i < 4; i++) {
            var t0 = block[i] + block[i + 12];
            var t1 = block[i + 4] + block[i + 8];
            var t2 = block[i + 4] - block[i + 8];
            var t3 = block[i] - block[i + 12];
            block[i] = t0 + t1;
            block[i + 4] = t2 + (t3 << 1);
            block[i + 8] = t0 - t1;
            block[i + 12] = t3 - (t2 << 1);
        }
    };
    /**
     *  Inverse Hadamard transform
     *  
     *  @param scaled
     */
    constructor.invDC4x4 = function(scaled) {
        for (var i = 0; i < 16; i += 4) {
            var e0 = scaled[i] + scaled[i + 2];
            var e1 = scaled[i] - scaled[i + 2];
            var e2 = scaled[i + 1] - scaled[i + 3];
            var e3 = scaled[i + 1] + scaled[i + 3];
            scaled[i] = e0 + e3;
            scaled[i + 1] = e1 + e2;
            scaled[i + 2] = e1 - e2;
            scaled[i + 3] = e0 - e3;
        }
        for (var i = 0; i < 4; i++) {
            var g0 = scaled[i] + scaled[i + 8];
            var g1 = scaled[i] - scaled[i + 8];
            var g2 = scaled[i + 4] - scaled[i + 12];
            var g3 = scaled[i + 4] + scaled[i + 12];
            scaled[i] = g0 + g3;
            scaled[i + 4] = g1 + g2;
            scaled[i + 8] = g1 - g2;
            scaled[i + 12] = g0 - g3;
        }
    };
    /**
     *  Forward Hadamard transform
     *  
     *  @param scaled
     */
    constructor.fvdDC4x4 = function(scaled) {
        for (var i = 0; i < 16; i += 4) {
            var t0 = scaled[i] + scaled[i + 3];
            var t1 = scaled[i + 1] + scaled[i + 2];
            var t2 = scaled[i + 1] - scaled[i + 2];
            var t3 = scaled[i] - scaled[i + 3];
            scaled[i] = t0 + t1;
            scaled[i + 1] = t3 + t2;
            scaled[i + 2] = t0 - t1;
            scaled[i + 3] = t3 - t2;
        }
        for (var i = 0; i < 4; i++) {
            var t0 = scaled[i] + scaled[i + 12];
            var t1 = scaled[i + 4] + scaled[i + 8];
            var t2 = scaled[i + 4] - scaled[i + 8];
            var t3 = scaled[i] - scaled[i + 12];
            scaled[i] = (t0 + t1) >> 1;
            scaled[i + 4] = (t2 + t3) >> 1;
            scaled[i + 8] = (t0 - t1) >> 1;
            scaled[i + 12] = (t3 - t2) >> 1;
        }
    };
    constructor.dequantizeAC = function(coeffs, qp, scalingList) {
        var group = qp % 6;
        if (scalingList == null) {
            var qbits = stjs.trunc(qp / 6);
            for (var i = 0; i < 16; i++) 
                coeffs[i] = (coeffs[i] * CoeffTransformer.dequantCoef[group][i]) << qbits;
        } else {
            if (qp >= 24) {
                var qbits = stjs.trunc(qp / 6) - 4;
                for (var i = 0; i < 16; i++) 
                    coeffs[i] = (coeffs[i] * CoeffTransformer.dequantCoef[group][i] * scalingList[CoeffTransformer.invZigzag4x4[i]]) << qbits;
            } else {
                var qbits = 4 - stjs.trunc(qp / 6);
                var addition = 1 << (3 - stjs.trunc(qp / 6));
                for (var i = 0; i < 16; i++) 
                    coeffs[i] = (coeffs[i] * scalingList[CoeffTransformer.invZigzag4x4[i]] * CoeffTransformer.dequantCoef[group][i] + addition) >> qbits;
            }
        }
    };
    constructor.quantizeAC = function(coeffs, qp) {
        var level = stjs.trunc(qp / 6);
        var offset = qp % 6;
        var addition = 682 << (stjs.trunc(qp / 6) + 4);
        var qbits = 15 + level;
        if (qp < 10) {
            for (var i = 0; i < 16; i++) {
                var sign = (coeffs[i] >> 31);
                coeffs[i] = (Math.min((((coeffs[i] ^ sign) - sign) * CoeffTransformer.quantCoeff[offset][i] + addition) >> qbits, 2063) ^ sign) - sign;
            }
        } else {
            for (var i = 0; i < 16; i++) {
                var sign = (coeffs[i] >> 31);
                coeffs[i] = (((((coeffs[i] ^ sign) - sign) * CoeffTransformer.quantCoeff[offset][i] + addition) >> qbits) ^ sign) - sign;
            }
        }
    };
    constructor.dequantizeDC4x4 = function(coeffs, qp, scalingList) {
        var group = qp % 6;
        if (qp >= 36) {
            var qbits = stjs.trunc(qp / 6) - 6;
            if (scalingList == null) {
                for (var i = 0; i < 16; i++) 
                    coeffs[i] = (coeffs[i] * (CoeffTransformer.dequantCoef[group][0] << 4)) << qbits;
            } else {
                for (var i = 0; i < 16; i++) 
                    coeffs[i] = (coeffs[i] * CoeffTransformer.dequantCoef[group][0] * scalingList[0]) << qbits;
            }
        } else {
            var qbits = 6 - stjs.trunc(qp / 6);
            var addition = 1 << (5 - stjs.trunc(qp / 6));
            if (scalingList == null) {
                for (var i = 0; i < 16; i++) 
                    coeffs[i] = (coeffs[i] * (CoeffTransformer.dequantCoef[group][0] << 4) + addition) >> qbits;
            } else {
                for (var i = 0; i < 16; i++) 
                    coeffs[i] = (coeffs[i] * CoeffTransformer.dequantCoef[group][0] * scalingList[0] + addition) >> qbits;
            }
        }
    };
    constructor.quantizeDC4x4 = function(coeffs, qp) {
        var level = stjs.trunc(qp / 6);
        var offset = qp % 6;
        var addition = 682 << (stjs.trunc(qp / 6) + 5);
        var qbits = 16 + level;
        if (qp < 10) {
            for (var i = 0; i < 16; i++) {
                var sign = (coeffs[i] >> 31);
                coeffs[i] = (Math.min((((coeffs[i] ^ sign) - sign) * CoeffTransformer.quantCoeff[offset][0] + addition) >> qbits, 2063) ^ sign) - sign;
            }
        } else {
            for (var i = 0; i < 16; i++) {
                var sign = (coeffs[i] >> 31);
                coeffs[i] = (((((coeffs[i] ^ sign) - sign) * CoeffTransformer.quantCoeff[offset][0] + addition) >> qbits) ^ sign) - sign;
            }
        }
    };
    /**
     *  Inverse Hadamard 2x2
     *  
     *  @param block
     */
    constructor.invDC2x2 = function(block) {
        var t0, t1, t2, t3;
        t0 = block[0] + block[1];
        t1 = block[0] - block[1];
        t2 = block[2] + block[3];
        t3 = block[2] - block[3];
        block[0] = (t0 + t2);
        block[1] = (t1 + t3);
        block[2] = (t0 - t2);
        block[3] = (t1 - t3);
    };
    /**
     *  Forward Hadamard 2x2
     *  
     *  @param dc2
     */
    constructor.fvdDC2x2 = function(block) {
        CoeffTransformer.invDC2x2(block);
    };
    constructor.dequantizeDC2x2 = function(transformed, qp, scalingList) {
        var group = qp % 6;
        if (scalingList == null) {
            var shift = stjs.trunc(qp / 6);
            for (var i = 0; i < 4; i++) {
                transformed[i] = ((transformed[i] * CoeffTransformer.dequantCoef[group][0]) << shift) >> 1;
            }
        } else {
            if (qp >= 24) {
                var qbits = stjs.trunc(qp / 6) - 4;
                for (var i = 0; i < 4; i++) {
                    transformed[i] = ((transformed[i] * CoeffTransformer.dequantCoef[group][0] * scalingList[0]) << qbits) >> 1;
                }
            } else {
                var qbits = 4 - stjs.trunc(qp / 6);
                var addition = 1 << (3 - stjs.trunc(qp / 6));
                for (var i = 0; i < 4; i++) {
                    transformed[i] = ((transformed[i] * CoeffTransformer.dequantCoef[group][0] * scalingList[0] + addition) >> qbits) >> 1;
                }
            }
        }
    };
    constructor.quantizeDC2x2 = function(coeffs, qp) {
        var level = stjs.trunc(qp / 6);
        var offset = qp % 6;
        var addition = 682 << (stjs.trunc(qp / 6) + 5);
        var qbits = 16 + level;
        if (qp < 4) {
            for (var i = 0; i < 4; i++) {
                var sign = (coeffs[i] >> 31);
                coeffs[i] = (Math.min((((coeffs[i] ^ sign) - sign) * CoeffTransformer.quantCoeff[offset][0] + addition) >> qbits, 2063) ^ sign) - sign;
            }
        } else {
            for (var i = 0; i < 4; i++) {
                var sign = (coeffs[i] >> 31);
                coeffs[i] = (((((coeffs[i] ^ sign) - sign) * CoeffTransformer.quantCoeff[offset][0] + addition) >> qbits) ^ sign) - sign;
            }
        }
    };
    constructor.reorderDC4x4 = function(dc) {
        ArrayUtil.swap(dc, 2, 4);
        ArrayUtil.swap(dc, 3, 5);
        ArrayUtil.swap(dc, 10, 12);
        ArrayUtil.swap(dc, 11, 13);
    };
    constructor.fvdDC4x2 = function(dc) {};
    constructor.quantizeDC4x2 = function(dc, qp) {};
    constructor.invDC4x2 = function(dc) {};
    constructor.dequantizeDC4x2 = function(dc, qp) {};
    /**
     *  Coefficients are <<4 on exit
     *  
     *  @param coeffs
     *  @param qp
     */
    constructor.dequantizeAC8x8 = function(coeffs, qp, scalingList) {
        var group = qp % 6;
        if (qp >= 36) {
            var qbits = stjs.trunc(qp / 6) - 6;
            if (scalingList == null) {
                for (var i = 0; i < 64; i++) 
                    coeffs[i] = (coeffs[i] * (CoeffTransformer.dequantCoef8x8[group][i]) << 4) << qbits;
            } else {
                for (var i = 0; i < 64; i++) 
                    coeffs[i] = (coeffs[i] * CoeffTransformer.dequantCoef8x8[group][i] * scalingList[CoeffTransformer.invZigzag8x8[i]]) << qbits;
            }
        } else {
            var qbits = 6 - stjs.trunc(qp / 6);
            var addition = 1 << (5 - stjs.trunc(qp / 6));
            if (scalingList == null) {
                for (var i = 0; i < 64; i++) 
                    coeffs[i] = (coeffs[i] * (CoeffTransformer.dequantCoef8x8[group][i] << 4) + addition) >> qbits;
            } else {
                for (var i = 0; i < 64; i++) 
                    coeffs[i] = (coeffs[i] * CoeffTransformer.dequantCoef8x8[group][i] * scalingList[CoeffTransformer.invZigzag8x8[i]] + addition) >> qbits;
            }
        }
    };
    constructor.idct8x8 = function(ac) {
        var off = 0;
        for (var row = 0; row < 8; row++) {
            var e0 = ac[off] + ac[off + 4];
            var e1 = -ac[off + 3] + ac[off + 5] - ac[off + 7] - (ac[off + 7] >> 1);
            var e2 = ac[off] - ac[off + 4];
            var e3 = ac[off + 1] + ac[off + 7] - ac[off + 3] - (ac[off + 3] >> 1);
            var e4 = (ac[off + 2] >> 1) - ac[off + 6];
            var e5 = -ac[off + 1] + ac[off + 7] + ac[off + 5] + (ac[off + 5] >> 1);
            var e6 = ac[off + 2] + (ac[off + 6] >> 1);
            var e7 = ac[off + 3] + ac[off + 5] + ac[off + 1] + (ac[off + 1] >> 1);
            var f0 = e0 + e6;
            var f1 = e1 + (e7 >> 2);
            var f2 = e2 + e4;
            var f3 = e3 + (e5 >> 2);
            var f4 = e2 - e4;
            var f5 = (e3 >> 2) - e5;
            var f6 = e0 - e6;
            var f7 = e7 - (e1 >> 2);
            ac[off] = f0 + f7;
            ac[off + 1] = f2 + f5;
            ac[off + 2] = f4 + f3;
            ac[off + 3] = f6 + f1;
            ac[off + 4] = f6 - f1;
            ac[off + 5] = f4 - f3;
            ac[off + 6] = f2 - f5;
            ac[off + 7] = f0 - f7;
            off += 8;
        }
        for (var col = 0; col < 8; col++) {
            var e0 = ac[col] + ac[col + 32];
            var e1 = -ac[col + 24] + ac[col + 40] - ac[col + 56] - (ac[col + 56] >> 1);
            var e2 = ac[col] - ac[col + 32];
            var e3 = ac[col + 8] + ac[col + 56] - ac[col + 24] - (ac[col + 24] >> 1);
            var e4 = (ac[col + 16] >> 1) - ac[col + 48];
            var e5 = -ac[col + 8] + ac[col + 56] + ac[col + 40] + (ac[col + 40] >> 1);
            var e6 = ac[col + 16] + (ac[col + 48] >> 1);
            var e7 = ac[col + 24] + ac[col + 40] + ac[col + 8] + (ac[col + 8] >> 1);
            var f0 = e0 + e6;
            var f1 = e1 + (e7 >> 2);
            var f2 = e2 + e4;
            var f3 = e3 + (e5 >> 2);
            var f4 = e2 - e4;
            var f5 = (e3 >> 2) - e5;
            var f6 = e0 - e6;
            var f7 = e7 - (e1 >> 2);
            ac[col] = f0 + f7;
            ac[col + 8] = f2 + f5;
            ac[col + 16] = f4 + f3;
            ac[col + 24] = f6 + f1;
            ac[col + 32] = f6 - f1;
            ac[col + 40] = f4 - f3;
            ac[col + 48] = f2 - f5;
            ac[col + 56] = f0 - f7;
        }
        for (var i = 0; i < 64; i++) {
            ac[i] = (ac[i] + 32) >> 6;
        }
    };
}, {zigzag4x4: "Int32Array", invZigzag4x4: "Int32Array", dequantCoef: "Array", dequantCoef8x8: "Array", initDequantCoeff8x8: "Array", zigzag8x8: "Int32Array", invZigzag8x8: "Int32Array", quantCoeff: "Array"}, {});
(function() {
    for (var i = 0; i < 16; i++) 
        CoeffTransformer.invZigzag4x4[CoeffTransformer.zigzag4x4[i]] = i;
    for (var i = 0; i < 64; i++) 
        CoeffTransformer.invZigzag8x8[CoeffTransformer.zigzag8x8[i]] = i;
})();
(function() {
    for (var g = 0; g < 6; g++) {
        Arrays.fill(CoeffTransformer.dequantCoef8x8[g], CoeffTransformer.initDequantCoeff8x8[g][5]);
        for (var i = 0; i < 8; i += 4) 
            for (var j = 0; j < 8; j += 4) 
                CoeffTransformer.dequantCoef8x8[g][(i << 3) + j] = CoeffTransformer.initDequantCoeff8x8[g][0];
        for (var i = 1; i < 8; i += 2) 
            for (var j = 1; j < 8; j += 2) 
                CoeffTransformer.dequantCoef8x8[g][(i << 3) + j] = CoeffTransformer.initDequantCoeff8x8[g][1];
        for (var i = 2; i < 8; i += 4) 
            for (var j = 2; j < 8; j += 4) 
                CoeffTransformer.dequantCoef8x8[g][(i << 3) + j] = CoeffTransformer.initDequantCoeff8x8[g][2];
        for (var i = 0; i < 8; i += 4) 
            for (var j = 1; j < 8; j += 2) 
                CoeffTransformer.dequantCoef8x8[g][(i << 3) + j] = CoeffTransformer.initDequantCoeff8x8[g][3];
        for (var i = 1; i < 8; i += 2) 
            for (var j = 0; j < 8; j += 4) 
                CoeffTransformer.dequantCoef8x8[g][(i << 3) + j] = CoeffTransformer.initDequantCoeff8x8[g][3];
        for (var i = 0; i < 8; i += 4) 
            for (var j = 2; j < 8; j += 4) 
                CoeffTransformer.dequantCoef8x8[g][(i << 3) + j] = CoeffTransformer.initDequantCoeff8x8[g][4];
        for (var i = 2; i < 8; i += 4) 
            for (var j = 0; j < 8; j += 4) 
                CoeffTransformer.dequantCoef8x8[g][(i << 3) + j] = CoeffTransformer.initDequantCoeff8x8[g][4];
    }
})();
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var PSFilterbank = function(numTimeSlotsRate) {
    this.resolution20 = new Int32Array(3);
    this.resolution34 = new Int32Array(5);
    var i;
    this.resolution34[0] = 12;
    this.resolution34[1] = 8;
    this.resolution34[2] = 4;
    this.resolution34[3] = 4;
    this.resolution34[4] = 4;
    this.resolution20[0] = 8;
    this.resolution20[1] = 2;
    this.resolution20[2] = 2;
    this.frame_len = numTimeSlotsRate;
    this.work = Array.apply(null, Array((this.frame_len + 12))).map(function() {
        return new Float32Array(2);
    });
    this.buffer = Array.apply(null, Array(5)).map(function() {
        return Array.apply(null, Array(2)).map(function() {
            return new Float32Array(2);
        });
    });
    this.temp = Array.apply(null, Array(this.frame_len)).map(function() {
        return Array.apply(null, Array(12)).map(function() {
            return new Float32Array(2);
        });
    });
};
PSFilterbank = stjs.extend(PSFilterbank, null, [PSTables], function(constructor, prototype) {
    prototype.frame_len = 0;
    prototype.resolution20 = null;
    prototype.resolution34 = null;
    prototype.work = null;
    prototype.buffer = null;
    prototype.temp = null;
    prototype.hybrid_analysis = function(X, X_hybrid, use34, numTimeSlotsRate) {
        var k, n, band;
        var offset = 0;
        var qmf_bands = (use34) ? 5 : 3;
        var resolution = (use34) ? this.resolution34 : this.resolution20;
        for (band = 0; band < qmf_bands; band++) {
            for (var i = 0; i < 12; i++) {
                this.work[i][0] = this.buffer[band][i][0];
                this.work[i][1] = this.buffer[band][i][1];
            }
            for (n = 0; n < this.frame_len; n++) {
                this.work[12 + n][0] = X[n + 6][band][0];
                this.work[12 + n][0] = X[n + 6][band][0];
            }
            for (var i = 0; i < 12; i++) {
                this.buffer[band][i][0] = this.work[this.frame_len + i][0];
                this.buffer[band][i][1] = this.work[this.frame_len + i][1];
            }
            switch (resolution[band]) {
                case 2:
                    PSFilterbank.channel_filter2(this.frame_len, PSTables.p2_13_20, this.work, this.temp);
                    break;
                case 4:
                    PSFilterbank.channel_filter4(this.frame_len, PSTables.p4_13_34, this.work, this.temp);
                    break;
                case 8:
                    this.channel_filter8(this.frame_len, (use34) ? PSTables.p8_13_34 : PSTables.p8_13_20, this.work, this.temp);
                    break;
                case 12:
                    this.channel_filter12(this.frame_len, PSTables.p12_13_34, this.work, this.temp);
                    break;
            }
            for (n = 0; n < this.frame_len; n++) {
                for (k = 0; k < resolution[band]; k++) {
                    X_hybrid[n][offset + k][0] = this.temp[n][k][0];
                    X_hybrid[n][offset + k][1] = this.temp[n][k][1];
                }
            }
            offset += resolution[band];
        }
        if (!use34) {
            for (n = 0; n < numTimeSlotsRate; n++) {
                X_hybrid[n][3][0] += X_hybrid[n][4][0];
                X_hybrid[n][3][1] += X_hybrid[n][4][1];
                X_hybrid[n][4][0] = 0;
                X_hybrid[n][4][1] = 0;
                X_hybrid[n][2][0] += X_hybrid[n][5][0];
                X_hybrid[n][2][1] += X_hybrid[n][5][1];
                X_hybrid[n][5][0] = 0;
                X_hybrid[n][5][1] = 0;
            }
        }
    };
    constructor.channel_filter2 = function(frame_len, filter, buffer, X_hybrid) {
        var i;
        for (i = 0; i < frame_len; i++) {
            var r0 = (filter[0] * (buffer[0 + i][0] + buffer[12 + i][0]));
            var r1 = (filter[1] * (buffer[1 + i][0] + buffer[11 + i][0]));
            var r2 = (filter[2] * (buffer[2 + i][0] + buffer[10 + i][0]));
            var r3 = (filter[3] * (buffer[3 + i][0] + buffer[9 + i][0]));
            var r4 = (filter[4] * (buffer[4 + i][0] + buffer[8 + i][0]));
            var r5 = (filter[5] * (buffer[5 + i][0] + buffer[7 + i][0]));
            var r6 = (filter[6] * buffer[6 + i][0]);
            var i0 = (filter[0] * (buffer[0 + i][1] + buffer[12 + i][1]));
            var i1 = (filter[1] * (buffer[1 + i][1] + buffer[11 + i][1]));
            var i2 = (filter[2] * (buffer[2 + i][1] + buffer[10 + i][1]));
            var i3 = (filter[3] * (buffer[3 + i][1] + buffer[9 + i][1]));
            var i4 = (filter[4] * (buffer[4 + i][1] + buffer[8 + i][1]));
            var i5 = (filter[5] * (buffer[5 + i][1] + buffer[7 + i][1]));
            var i6 = (filter[6] * buffer[6 + i][1]);
            X_hybrid[i][0][0] = r0 + r1 + r2 + r3 + r4 + r5 + r6;
            X_hybrid[i][0][1] = i0 + i1 + i2 + i3 + i4 + i5 + i6;
            X_hybrid[i][1][0] = r0 - r1 + r2 - r3 + r4 - r5 + r6;
            X_hybrid[i][1][1] = i0 - i1 + i2 - i3 + i4 - i5 + i6;
        }
    };
    constructor.channel_filter4 = function(frame_len, filter, buffer, X_hybrid) {
        var i;
        var input_re1 = new Float32Array(2), input_re2 = new Float32Array(2);
        var input_im1 = new Float32Array(2), input_im2 = new Float32Array(2);
        for (i = 0; i < frame_len; i++) {
            input_re1[0] = -(filter[2] * (buffer[i + 2][0] + buffer[i + 10][0])) + (filter[6] * buffer[i + 6][0]);
            input_re1[1] = (-0.70710677 * ((filter[1] * (buffer[i + 1][0] + buffer[i + 11][0])) + (filter[3] * (buffer[i + 3][0] + buffer[i + 9][0])) - (filter[5] * (buffer[i + 5][0] + buffer[i + 7][0]))));
            input_im1[0] = (filter[0] * (buffer[i + 0][1] - buffer[i + 12][1])) - (filter[4] * (buffer[i + 4][1] - buffer[i + 8][1]));
            input_im1[1] = (0.70710677 * ((filter[1] * (buffer[i + 1][1] - buffer[i + 11][1])) - (filter[3] * (buffer[i + 3][1] - buffer[i + 9][1])) - (filter[5] * (buffer[i + 5][1] - buffer[i + 7][1]))));
            input_re2[0] = (filter[0] * (buffer[i + 0][0] - buffer[i + 12][0])) - (filter[4] * (buffer[i + 4][0] - buffer[i + 8][0]));
            input_re2[1] = (0.70710677 * ((filter[1] * (buffer[i + 1][0] - buffer[i + 11][0])) - (filter[3] * (buffer[i + 3][0] - buffer[i + 9][0])) - (filter[5] * (buffer[i + 5][0] - buffer[i + 7][0]))));
            input_im2[0] = -(filter[2] * (buffer[i + 2][1] + buffer[i + 10][1])) + (filter[6] * buffer[i + 6][1]);
            input_im2[1] = (-0.70710677 * ((filter[1] * (buffer[i + 1][1] + buffer[i + 11][1])) + (filter[3] * (buffer[i + 3][1] + buffer[i + 9][1])) - (filter[5] * (buffer[i + 5][1] + buffer[i + 7][1]))));
            X_hybrid[i][0][0] = input_re1[0] + input_re1[1] + input_im1[0] + input_im1[1];
            X_hybrid[i][0][1] = -input_re2[0] - input_re2[1] + input_im2[0] + input_im2[1];
            X_hybrid[i][1][0] = input_re1[0] - input_re1[1] - input_im1[0] + input_im1[1];
            X_hybrid[i][1][1] = input_re2[0] - input_re2[1] + input_im2[0] - input_im2[1];
            X_hybrid[i][2][0] = input_re1[0] - input_re1[1] + input_im1[0] - input_im1[1];
            X_hybrid[i][2][1] = -input_re2[0] + input_re2[1] + input_im2[0] - input_im2[1];
            X_hybrid[i][3][0] = input_re1[0] + input_re1[1] - input_im1[0] - input_im1[1];
            X_hybrid[i][3][1] = input_re2[0] + input_re2[1] + input_im2[0] + input_im2[1];
        }
    };
    constructor.DCT3_4_unscaled = function(y, x) {
        var f0, f1, f2, f3, f4, f5, f6, f7, f8;
        f0 = (x[2] * 0.70710677);
        f1 = x[0] - f0;
        f2 = x[0] + f0;
        f3 = x[1] + x[3];
        f4 = (x[1] * 1.306563);
        f5 = (f3 * (-0.9238795));
        f6 = (x[3] * (-0.5411961));
        f7 = f4 + f5;
        f8 = f6 - f5;
        y[3] = f2 - f8;
        y[0] = f2 + f8;
        y[2] = f1 - f7;
        y[1] = f1 + f7;
    };
    prototype.channel_filter8 = function(frame_len, filter, buffer, X_hybrid) {
        var i, n;
        var input_re1 = new Float32Array(4), input_re2 = new Float32Array(4);
        var input_im1 = new Float32Array(4), input_im2 = new Float32Array(4);
        var x = new Float32Array(4);
        for (i = 0; i < frame_len; i++) {
            input_re1[0] = (filter[6] * buffer[6 + i][0]);
            input_re1[1] = (filter[5] * (buffer[5 + i][0] + buffer[7 + i][0]));
            input_re1[2] = -(filter[0] * (buffer[0 + i][0] + buffer[12 + i][0])) + (filter[4] * (buffer[4 + i][0] + buffer[8 + i][0]));
            input_re1[3] = -(filter[1] * (buffer[1 + i][0] + buffer[11 + i][0])) + (filter[3] * (buffer[3 + i][0] + buffer[9 + i][0]));
            input_im1[0] = (filter[5] * (buffer[7 + i][1] - buffer[5 + i][1]));
            input_im1[1] = (filter[0] * (buffer[12 + i][1] - buffer[0 + i][1])) + (filter[4] * (buffer[8 + i][1] - buffer[4 + i][1]));
            input_im1[2] = (filter[1] * (buffer[11 + i][1] - buffer[1 + i][1])) + (filter[3] * (buffer[9 + i][1] - buffer[3 + i][1]));
            input_im1[3] = (filter[2] * (buffer[10 + i][1] - buffer[2 + i][1]));
            for (n = 0; n < 4; n++) {
                x[n] = input_re1[n] - input_im1[3 - n];
            }
            PSFilterbank.DCT3_4_unscaled(x, x);
            X_hybrid[i][7][0] = x[0];
            X_hybrid[i][5][0] = x[2];
            X_hybrid[i][3][0] = x[3];
            X_hybrid[i][1][0] = x[1];
            for (n = 0; n < 4; n++) {
                x[n] = input_re1[n] + input_im1[3 - n];
            }
            PSFilterbank.DCT3_4_unscaled(x, x);
            X_hybrid[i][6][0] = x[1];
            X_hybrid[i][4][0] = x[3];
            X_hybrid[i][2][0] = x[2];
            X_hybrid[i][0][0] = x[0];
            input_im2[0] = (filter[6] * buffer[6 + i][1]);
            input_im2[1] = (filter[5] * (buffer[5 + i][1] + buffer[7 + i][1]));
            input_im2[2] = -(filter[0] * (buffer[0 + i][1] + buffer[12 + i][1])) + (filter[4] * (buffer[4 + i][1] + buffer[8 + i][1]));
            input_im2[3] = -(filter[1] * (buffer[1 + i][1] + buffer[11 + i][1])) + (filter[3] * (buffer[3 + i][1] + buffer[9 + i][1]));
            input_re2[0] = (filter[5] * (buffer[7 + i][0] - buffer[5 + i][0]));
            input_re2[1] = (filter[0] * (buffer[12 + i][0] - buffer[0 + i][0])) + (filter[4] * (buffer[8 + i][0] - buffer[4 + i][0]));
            input_re2[2] = (filter[1] * (buffer[11 + i][0] - buffer[1 + i][0])) + (filter[3] * (buffer[9 + i][0] - buffer[3 + i][0]));
            input_re2[3] = (filter[2] * (buffer[10 + i][0] - buffer[2 + i][0]));
            for (n = 0; n < 4; n++) {
                x[n] = input_im2[n] + input_re2[3 - n];
            }
            PSFilterbank.DCT3_4_unscaled(x, x);
            X_hybrid[i][7][1] = x[0];
            X_hybrid[i][5][1] = x[2];
            X_hybrid[i][3][1] = x[3];
            X_hybrid[i][1][1] = x[1];
            for (n = 0; n < 4; n++) {
                x[n] = input_im2[n] - input_re2[3 - n];
            }
            PSFilterbank.DCT3_4_unscaled(x, x);
            X_hybrid[i][6][1] = x[1];
            X_hybrid[i][4][1] = x[3];
            X_hybrid[i][2][1] = x[2];
            X_hybrid[i][0][1] = x[0];
        }
    };
    prototype.DCT3_6_unscaled = function(y, x) {
        var f0, f1, f2, f3, f4, f5, f6, f7;
        f0 = (x[3] * 0.70710677);
        f1 = x[0] + f0;
        f2 = x[0] - f0;
        f3 = ((x[1] - x[5]) * 0.70710677);
        f4 = (x[2] * 0.8660254) + (x[4] * 0.5);
        f5 = f4 - x[4];
        f6 = (x[1] * 0.9659258) + (x[5] * 0.25881904);
        f7 = f6 - f3;
        y[0] = f1 + f6 + f4;
        y[1] = f2 + f3 - x[4];
        y[2] = f7 + f2 - f5;
        y[3] = f1 - f7 - f5;
        y[4] = f1 - f3 - x[4];
        y[5] = f2 - f6 + f4;
    };
    prototype.channel_filter12 = function(frame_len, filter, buffer, X_hybrid) {
        var i, n;
        var input_re1 = new Float32Array(6), input_re2 = new Float32Array(6);
        var input_im1 = new Float32Array(6), input_im2 = new Float32Array(6);
        var out_re1 = new Float32Array(6), out_re2 = new Float32Array(6);
        var out_im1 = new Float32Array(6), out_im2 = new Float32Array(6);
        for (i = 0; i < frame_len; i++) {
            for (n = 0; n < 6; n++) {
                if (n == 0) {
                    input_re1[0] = (buffer[6 + i][0] * filter[6]);
                    input_re2[0] = (buffer[6 + i][1] * filter[6]);
                } else {
                    input_re1[6 - n] = ((buffer[n + i][0] + buffer[12 - n + i][0]) * filter[n]);
                    input_re2[6 - n] = ((buffer[n + i][1] + buffer[12 - n + i][1]) * filter[n]);
                }
                input_im2[n] = ((buffer[n + i][0] - buffer[12 - n + i][0]) * filter[n]);
                input_im1[n] = ((buffer[n + i][1] - buffer[12 - n + i][1]) * filter[n]);
            }
            this.DCT3_6_unscaled(out_re1, input_re1);
            this.DCT3_6_unscaled(out_re2, input_re2);
            this.DCT3_6_unscaled(out_im1, input_im1);
            this.DCT3_6_unscaled(out_im2, input_im2);
            for (n = 0; n < 6; n += 2) {
                X_hybrid[i][n][0] = out_re1[n] - out_im1[n];
                X_hybrid[i][n][1] = out_re2[n] + out_im2[n];
                X_hybrid[i][n + 1][0] = out_re1[n + 1] + out_im1[n + 1];
                X_hybrid[i][n + 1][1] = out_re2[n + 1] - out_im2[n + 1];
                X_hybrid[i][10 - n][0] = out_re1[n + 1] - out_im1[n + 1];
                X_hybrid[i][10 - n][1] = out_re2[n + 1] + out_im2[n + 1];
                X_hybrid[i][11 - n][0] = out_re1[n] + out_im1[n];
                X_hybrid[i][11 - n][1] = out_re2[n] - out_im2[n];
            }
        }
    };
    prototype.hybrid_synthesis = function(X, X_hybrid, use34, numTimeSlotsRate) {
        var k, n, band;
        var offset = 0;
        var qmf_bands = (use34) ? 5 : 3;
        var resolution = (use34) ? this.resolution34 : this.resolution20;
        for (band = 0; band < qmf_bands; band++) {
            for (n = 0; n < this.frame_len; n++) {
                X[n][band][0] = 0;
                X[n][band][1] = 0;
                for (k = 0; k < resolution[band]; k++) {
                    X[n][band][0] += X_hybrid[n][offset + k][0];
                    X[n][band][1] += X_hybrid[n][offset + k][1];
                }
            }
            offset += resolution[band];
        }
    };
}, {resolution20: "Int32Array", resolution34: "Int32Array", work: "Array", buffer: "Array", temp: "Array", nr_iid_par_tab: "Int32Array", nr_icc_par_tab: "Int32Array", nr_ipdopd_par_tab: "Int32Array", num_env_tab: "Array", filter_a: "Float32Array", group_border20: "Int32Array", group_border34: "Int32Array", map_group2bk20: "Int32Array", map_group2bk34: "Int32Array", delay_length_d: "Int32Array", p8_13_20: "Float32Array", p2_13_20: "Float32Array", p12_13_34: "Float32Array", p8_13_34: "Float32Array", p4_13_34: "Float32Array", Phi_Fract_Qmf: "Array", Phi_Fract_SubQmf20: "Array", Phi_Fract_SubQmf34: "Array", Q_Fract_allpass_Qmf: "Array", Q_Fract_allpass_SubQmf20: "Array", Q_Fract_allpass_SubQmf34: "Array", cos_alphas: "Float32Array", sin_alphas: "Float32Array", cos_betas_normal: "Array", sin_betas_normal: "Array", cos_betas_fine: "Array", sin_betas_fine: "Array", sincos_alphas_B_normal: "Array", sincos_alphas_B_fine: "Array", cos_gammas_normal: "Array", cos_gammas_fine: "Array", sin_gammas_normal: "Array", sin_gammas_fine: "Array", sf_iid_normal: "Float32Array", sf_iid_fine: "Float32Array", ipdopd_cos_tab: "Float32Array", ipdopd_sin_tab: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author Alex Zhukov
 */
var IntDCT = function() {
    DCT.call(this);
};
IntDCT = stjs.extend(IntDCT, DCT, [], function(constructor, prototype) {
    constructor.INSTANCE = new IntDCT();
    constructor.DCTSIZE = 8;
    constructor.PASS1_BITS = 2;
    constructor.MAXJSAMPLE = 255;
    constructor.CENTERJSAMPLE = 128;
    /**
     * 2 bits wider than legal samples 
     */
    constructor.RANGE_MASK = (IntDCT.MAXJSAMPLE * 4 + 3);
    prototype.decode = function(orig) {
        var inptr = IntBuffer.wrap(orig);
        var workspace = IntBuffer.allocate(64);
        var outptr = IntBuffer.allocate(64);
        this.doDecode(inptr, workspace, outptr);
        return outptr.array();
    };
    prototype.doDecode = function(inptr, workspace, outptr) {
        IntDCT.pass1(inptr, workspace.duplicate());
        IntDCT.pass2(outptr, workspace.duplicate());
        return outptr;
    };
    /**
     *  Pass 2: process rows from work array, store into output array.
     *  
     *  Note that we must descale the results by a factor of 8 == 23, and also
     *  undo the PASS1_BITS scaling.
     */
    constructor.pass2 = function(outptr, wsptr) {
        for (var ctr = 0; ctr < IntDCT.DCTSIZE; ctr++) {
            var z2 = wsptr.get(2);
            var z3 = wsptr.get(6);
            var z1 = IntDCT.MULTIPLY(z2 + z3, IntDCT.FIX_0_541196100);
            var tmp2 = z1 + IntDCT.MULTIPLY(z3, -IntDCT.FIX_1_847759065);
            var tmp3 = z1 + IntDCT.MULTIPLY(z2, IntDCT.FIX_0_765366865);
            var tmp0 = (stjs.trunc(wsptr.get(0)) + stjs.trunc(wsptr.get(4))) << IntDCT.CONST_BITS;
            var tmp1 = (stjs.trunc(wsptr.get(0)) - stjs.trunc(wsptr.get(4))) << IntDCT.CONST_BITS;
            var tmp10 = tmp0 + tmp3;
            var tmp13 = tmp0 - tmp3;
            var tmp11 = tmp1 + tmp2;
            var tmp12 = tmp1 - tmp2;
            tmp0 = stjs.trunc(wsptr.get(7));
            tmp1 = stjs.trunc(wsptr.get(5));
            tmp2 = stjs.trunc(wsptr.get(3));
            tmp3 = stjs.trunc(wsptr.get(1));
            z1 = tmp0 + tmp3;
            z2 = tmp1 + tmp2;
            z3 = tmp0 + tmp2;
            var z4 = tmp1 + tmp3;
            var z5 = IntDCT.MULTIPLY(z3 + z4, IntDCT.FIX_1_175875602);
            tmp0 = IntDCT.MULTIPLY(tmp0, IntDCT.FIX_0_298631336);
            tmp1 = IntDCT.MULTIPLY(tmp1, IntDCT.FIX_2_053119869);
            tmp2 = IntDCT.MULTIPLY(tmp2, IntDCT.FIX_3_072711026);
            tmp3 = IntDCT.MULTIPLY(tmp3, IntDCT.FIX_1_501321110);
            z1 = IntDCT.MULTIPLY(z1, -IntDCT.FIX_0_899976223);
            z2 = IntDCT.MULTIPLY(z2, -IntDCT.FIX_2_562915447);
            z3 = IntDCT.MULTIPLY(z3, -IntDCT.FIX_1_961570560);
            z4 = IntDCT.MULTIPLY(z4, -IntDCT.FIX_0_390180644);
            z3 += z5;
            z4 += z5;
            tmp0 += z1 + z3;
            tmp1 += z2 + z4;
            tmp2 += z2 + z3;
            tmp3 += z1 + z4;
            var D = IntDCT.CONST_BITS + IntDCT.PASS1_BITS + 3;
            outptr.put(IntDCT.range_limit(IntDCT.DESCALE(tmp10 + tmp3, D) & IntDCT.RANGE_MASK));
            outptr.put(IntDCT.range_limit(IntDCT.DESCALE(tmp11 + tmp2, D) & IntDCT.RANGE_MASK));
            outptr.put(IntDCT.range_limit(IntDCT.DESCALE(tmp12 + tmp1, D) & IntDCT.RANGE_MASK));
            outptr.put(IntDCT.range_limit(IntDCT.DESCALE(tmp13 + tmp0, D) & IntDCT.RANGE_MASK));
            outptr.put(IntDCT.range_limit(IntDCT.DESCALE(tmp13 - tmp0, D) & IntDCT.RANGE_MASK));
            outptr.put(IntDCT.range_limit(IntDCT.DESCALE(tmp12 - tmp1, D) & IntDCT.RANGE_MASK));
            outptr.put(IntDCT.range_limit(IntDCT.DESCALE(tmp11 - tmp2, D) & IntDCT.RANGE_MASK));
            outptr.put(IntDCT.range_limit(IntDCT.DESCALE(tmp10 - tmp3, D) & IntDCT.RANGE_MASK));
            wsptr = IntDCT.doAdvance(wsptr, IntDCT.DCTSIZE);
        }
    };
    constructor.range_limit = function(i) {
        return IntDCT.idct_sample_range_limit.get(i + 256);
    };
    constructor.sample_range_limit = IntBuffer.allocate((5 * (IntDCT.MAXJSAMPLE + 1) + IntDCT.CENTERJSAMPLE));
    constructor.idct_sample_range_limit = IntBuffer.allocate(IntDCT.sample_range_limit.capacity() - 128);
    constructor.prepare_range_limit_table = function() {
        IntDCT.sample_range_limit.position(256);
        for (var i = 0; i < 128; i++) {
            IntDCT.sample_range_limit.put(i);
        }
        for (var i = -128; i < 0; i++) {
            IntDCT.sample_range_limit.put(i);
        }
        for (var i = 0; i < 256 + 128; i++) {
            IntDCT.sample_range_limit.put(-1);
        }
        for (var i = 0; i < 256 + 128; i++) {
            IntDCT.sample_range_limit.put(0);
        }
        for (var i = 0; i < 128; i++) {
            IntDCT.sample_range_limit.put(i);
        }
        for (var i = 0; i < IntDCT.idct_sample_range_limit.capacity(); i++) {
            IntDCT.idct_sample_range_limit.put(IntDCT.sample_range_limit.get(i + 128) & 255);
        }
    };
    constructor.shortcut = function(inptr, wsptr) {
        if (inptr.get(IntDCT.DCTSIZE * 1) == 0 && inptr.get(IntDCT.DCTSIZE * 2) == 0 && inptr.get(IntDCT.DCTSIZE * 3) == 0 && inptr.get(IntDCT.DCTSIZE * 4) == 0 && inptr.get(IntDCT.DCTSIZE * 5) == 0 && inptr.get(IntDCT.DCTSIZE * 6) == 0 && inptr.get(IntDCT.DCTSIZE * 7) == 0) {
            var dcval = inptr.get(IntDCT.DCTSIZE * 0) << IntDCT.PASS1_BITS;
            wsptr.put(IntDCT.DCTSIZE * 0, dcval);
            wsptr.put(IntDCT.DCTSIZE * 1, dcval);
            wsptr.put(IntDCT.DCTSIZE * 2, dcval);
            wsptr.put(IntDCT.DCTSIZE * 3, dcval);
            wsptr.put(IntDCT.DCTSIZE * 4, dcval);
            wsptr.put(IntDCT.DCTSIZE * 5, dcval);
            wsptr.put(IntDCT.DCTSIZE * 6, dcval);
            wsptr.put(IntDCT.DCTSIZE * 7, dcval);
            inptr = IntDCT.advance(inptr);
            wsptr = IntDCT.advance(wsptr);
            return true;
        }
        return false;
    };
    /**
     *  Pass 1: process columns from input, store into work array.
     *  
     *  Note results are scaled up by sqrt(8) compared to a true IDCT;
     *  furthermore, we scale the results by 2xPASS1_BITS.
     */
    constructor.pass1 = function(inptr, wsptr) {
        for (var ctr = IntDCT.DCTSIZE; ctr > 0; ctr--) {
            var z2 = inptr.get(IntDCT.DCTSIZE * 2);
            var z3 = inptr.get(IntDCT.DCTSIZE * 6);
            var z1 = IntDCT.MULTIPLY(z2 + z3, IntDCT.FIX_0_541196100);
            var tmp2 = z1 + IntDCT.MULTIPLY(z3, -IntDCT.FIX_1_847759065);
            var tmp3 = z1 + IntDCT.MULTIPLY(z2, IntDCT.FIX_0_765366865);
            z2 = inptr.get(IntDCT.DCTSIZE * 0);
            z3 = inptr.get(IntDCT.DCTSIZE * 4);
            var tmp0 = (z2 + z3) << IntDCT.CONST_BITS;
            var tmp1 = (z2 - z3) << IntDCT.CONST_BITS;
            var tmp10 = tmp0 + tmp3;
            var tmp13 = tmp0 - tmp3;
            var tmp11 = tmp1 + tmp2;
            var tmp12 = tmp1 - tmp2;
            tmp0 = inptr.get(IntDCT.DCTSIZE * 7);
            tmp1 = inptr.get(IntDCT.DCTSIZE * 5);
            tmp2 = inptr.get(IntDCT.DCTSIZE * 3);
            tmp3 = inptr.get(IntDCT.DCTSIZE * 1);
            z1 = tmp0 + tmp3;
            z2 = tmp1 + tmp2;
            z3 = tmp0 + tmp2;
            var z4 = tmp1 + tmp3;
            var z5 = IntDCT.MULTIPLY(z3 + z4, IntDCT.FIX_1_175875602);
            tmp0 = IntDCT.MULTIPLY(tmp0, IntDCT.FIX_0_298631336);
            tmp1 = IntDCT.MULTIPLY(tmp1, IntDCT.FIX_2_053119869);
            tmp2 = IntDCT.MULTIPLY(tmp2, IntDCT.FIX_3_072711026);
            tmp3 = IntDCT.MULTIPLY(tmp3, IntDCT.FIX_1_501321110);
            z1 = IntDCT.MULTIPLY(z1, -IntDCT.FIX_0_899976223);
            z2 = IntDCT.MULTIPLY(z2, -IntDCT.FIX_2_562915447);
            z3 = IntDCT.MULTIPLY(z3, -IntDCT.FIX_1_961570560);
            z4 = IntDCT.MULTIPLY(z4, -IntDCT.FIX_0_390180644);
            z3 += z5;
            z4 += z5;
            tmp0 += z1 + z3;
            tmp1 += z2 + z4;
            tmp2 += z2 + z3;
            tmp3 += z1 + z4;
            var D = IntDCT.CONST_BITS - IntDCT.PASS1_BITS;
            wsptr.put(IntDCT.DCTSIZE * 0, IntDCT.DESCALE(tmp10 + tmp3, D));
            wsptr.put(IntDCT.DCTSIZE * 7, IntDCT.DESCALE(tmp10 - tmp3, D));
            wsptr.put(IntDCT.DCTSIZE * 1, IntDCT.DESCALE(tmp11 + tmp2, D));
            wsptr.put(IntDCT.DCTSIZE * 6, IntDCT.DESCALE(tmp11 - tmp2, D));
            wsptr.put(IntDCT.DCTSIZE * 2, IntDCT.DESCALE(tmp12 + tmp1, D));
            wsptr.put(IntDCT.DCTSIZE * 5, IntDCT.DESCALE(tmp12 - tmp1, D));
            wsptr.put(IntDCT.DCTSIZE * 3, IntDCT.DESCALE(tmp13 + tmp0, D));
            wsptr.put(IntDCT.DCTSIZE * 4, IntDCT.DESCALE(tmp13 - tmp0, D));
            inptr = IntDCT.advance(inptr);
            wsptr = IntDCT.advance(wsptr);
        }
    };
    /**
     *  advance pointers to next column
     */
    constructor.advance = function(ptr) {
        return IntDCT.doAdvance(ptr, 1);
    };
    constructor.doAdvance = function(ptr, size) {
        ptr.position(ptr.position() + size);
        return ptr.slice();
    };
    constructor.DESCALE = function(x, n) {
        return IntDCT.RIGHT_SHIFT((x) + (1 << ((n) - 1)), n);
    };
    constructor.RIGHT_SHIFT = function(x, shft) {
        return x >> shft;
    };
    constructor.MULTIPLY = function(i, j) {
        return i * j;
    };
    constructor.FIX = function(x) {
        return (stjs.trunc(((x) * (1 << IntDCT.CONST_BITS) + 0.5)));
    };
    constructor.FIX_0_298631336 = IntDCT.FIX(0.298631336);
    constructor.FIX_0_390180644 = IntDCT.FIX(0.390180644);
    constructor.FIX_0_541196100 = IntDCT.FIX(0.5411961);
    constructor.FIX_0_765366865 = IntDCT.FIX(0.765366865);
    constructor.FIX_0_899976223 = IntDCT.FIX(0.899976223);
    constructor.FIX_1_175875602 = IntDCT.FIX(1.175875602);
    constructor.FIX_1_501321110 = IntDCT.FIX(1.50132111);
    constructor.FIX_1_847759065 = IntDCT.FIX(1.847759065);
    constructor.FIX_1_961570560 = IntDCT.FIX(1.96157056);
    constructor.FIX_2_053119869 = IntDCT.FIX(2.053119869);
    constructor.FIX_2_562915447 = IntDCT.FIX(2.562915447);
    constructor.FIX_3_072711026 = IntDCT.FIX(3.072711026);
    constructor.CONST_BITS = 13;
    constructor.ONE_HALF = (1 << (IntDCT.CONST_BITS - 1));
}, {INSTANCE: "IntDCT", sample_range_limit: "IntBuffer", idct_sample_range_limit: "IntBuffer"}, {});
(function() {
    IntDCT.prepare_range_limit_table();
})();
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var SlowDCT = function() {
    DCT.call(this);
};
SlowDCT = stjs.extend(SlowDCT, DCT, [], function(constructor, prototype) {
    constructor.INSTANCE = new SlowDCT();
    /**
     * r - Reciprocal 
     */
    constructor.rSqrt2 = 1 / Math.sqrt(2);
    prototype.encode = function(orig) {
        var result = new Int16Array(64);
        for (var u = 0; u < 8; u++) {
            for (var v = 0; v < 8; v++) {
                var sum = 0;
                for (var i = 0; i < 8; i++) {
                    for (var j = 0; j < 8; j++) {
                        sum += orig[i * 8 + j] * Math.cos((Math.PI / 8) * (i + 0.5) * u) * Math.cos((Math.PI / 8) * (j + 0.5) * v);
                    }
                }
                result[u * 8 + v] = stjs.trunc(sum);
            }
        }
        result[0] = stjs.trunc((result[0] / 8));
        var sqrt2 = Math.sqrt(2);
        for (var i = 1; i < 8; i++) {
            result[i] = stjs.trunc((result[0] * sqrt2 / 8));
            result[i * 8] = stjs.trunc((result[0] * sqrt2 / 8));
            for (var j = 1; j < 8; j++) {
                result[i * 8 + j] = stjs.trunc((result[0] / 4));
            }
        }
        return result;
    };
    prototype.decode = function(orig) {
        var res = new Int32Array(64);
        var i = 0;
        for (var y = 0; y < 8; y++) {
            for (var x = 0; x < 8; x++) {
                var sum = 0;
                var pixOffset = 0;
                for (var u = 0; u < 8; u++) {
                    var cu = (u == 0) ? SlowDCT.rSqrt2 : 1;
                    for (var v = 0; v < 8; v++) {
                        var cv = (v == 0) ? SlowDCT.rSqrt2 : 1;
                        var svu = orig[pixOffset];
                        var c1 = ((2 * x + 1) * v * Math.PI) / 16.0;
                        var c2 = ((2 * y + 1) * u * Math.PI) / 16.0;
                        sum += cu * cv * svu * Math.cos(c1) * Math.cos(c2);
                        pixOffset++;
                    }
                }
                sum *= 0.25;
                sum = Math.round(sum + 128);
                var isum = (stjs.trunc(sum));
                res[i++] = ImageConvert.icrop(isum);
            }
        }
        return res;
    };
}, {INSTANCE: "SlowDCT"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var HFGeneration = function() {};
HFGeneration = stjs.extend(HFGeneration, null, [], function(constructor, prototype) {
    constructor.goalSbTab = new Int32Array([21, 23, 32, 43, 46, 64, 85, 93, 128, 0, 0, 0]);
    constructor.acorr_coef = function() {
        this.r01 = new Float32Array(2);
        this.r02 = new Float32Array(2);
        this.r11 = new Float32Array(2);
        this.r12 = new Float32Array(2);
        this.r22 = new Float32Array(2);
    };
    constructor.acorr_coef = stjs.extend(constructor.acorr_coef, null, [], function(constructor, prototype) {
        prototype.r01 = null;
        prototype.r02 = null;
        prototype.r11 = null;
        prototype.r12 = null;
        prototype.r22 = null;
        prototype.det = 0.0;
    }, {r01: "Float32Array", r02: "Float32Array", r11: "Float32Array", r12: "Float32Array", r22: "Float32Array"}, {});
    constructor.hf_generation = function(sbr, Xlow, Xhigh, ch) {
        var l, i, x;
        var alpha_0 = Array.apply(null, Array(64)).map(function() {
            return new Float32Array(2);
        }), alpha_1 = Array.apply(null, Array(64)).map(function() {
            return new Float32Array(2);
        });
        var offset = sbr.tHFAdj;
        var first = sbr.t_E[ch][0];
        var last = sbr.t_E[ch][sbr.L_E[ch]];
        HFGeneration.calc_chirp_factors(sbr, ch);
        if ((ch == 0) && (sbr.Reset)) 
            HFGeneration.patch_construction(sbr);
        for (i = 0; i < sbr.noPatches; i++) {
            for (x = 0; x < sbr.patchNoSubbands[i]; x++) {
                var a0_r, a0_i, a1_r, a1_i;
                var bw, bw2;
                var q, p, k, g;
                k = sbr.kx + x;
                for (q = 0; q < i; q++) {
                    k += sbr.patchNoSubbands[q];
                }
                p = sbr.patchStartSubband[i] + x;
                g = sbr.table_map_k_to_g[k];
                bw = sbr.bwArray[ch][g];
                bw2 = bw * bw;
                if (bw2 > 0) {
                    var temp1_r, temp2_r, temp3_r;
                    var temp1_i, temp2_i, temp3_i;
                    HFGeneration.calc_prediction_coef(sbr, Xlow, alpha_0, alpha_1, p);
                    a0_r = (alpha_0[p][0] * bw);
                    a1_r = (alpha_1[p][0] * bw2);
                    a0_i = (alpha_0[p][1] * bw);
                    a1_i = (alpha_1[p][1] * bw2);
                    temp2_r = (Xlow[first - 2 + offset][p][0]);
                    temp3_r = (Xlow[first - 1 + offset][p][0]);
                    temp2_i = (Xlow[first - 2 + offset][p][1]);
                    temp3_i = (Xlow[first - 1 + offset][p][1]);
                    for (l = first; l < last; l++) {
                        temp1_r = temp2_r;
                        temp2_r = temp3_r;
                        temp3_r = (Xlow[l + offset][p][0]);
                        temp1_i = temp2_i;
                        temp2_i = temp3_i;
                        temp3_i = (Xlow[l + offset][p][1]);
                        Xhigh[l + offset][k][0] = temp3_r + ((a0_r * temp2_r) - (a0_i * temp2_i) + (a1_r * temp1_r) - (a1_i * temp1_i));
                        Xhigh[l + offset][k][1] = temp3_i + ((a0_i * temp2_r) + (a0_r * temp2_i) + (a1_i * temp1_r) + (a1_r * temp1_i));
                    }
                } else {
                    for (l = first; l < last; l++) {
                        Xhigh[l + offset][k][0] = Xlow[l + offset][p][0];
                        Xhigh[l + offset][k][1] = Xlow[l + offset][p][1];
                    }
                }
            }
        }
        if (sbr.Reset) {
            FBT.limiter_frequency_table(sbr);
        }
    };
    constructor.auto_correlation = function(sbr, ac, buffer, bd, len) {
        var r01r = 0, r01i = 0, r02r = 0, r02i = 0, r11r = 0;
        var temp1_r, temp1_i, temp2_r, temp2_i, temp3_r, temp3_i, temp4_r, temp4_i, temp5_r, temp5_i;
        var rel = 1.0 / (1 + 1.0E-6);
        var j;
        var offset = sbr.tHFAdj;
        temp2_r = buffer[offset - 2][bd][0];
        temp2_i = buffer[offset - 2][bd][1];
        temp3_r = buffer[offset - 1][bd][0];
        temp3_i = buffer[offset - 1][bd][1];
        temp4_r = temp2_r;
        temp4_i = temp2_i;
        temp5_r = temp3_r;
        temp5_i = temp3_i;
        for (j = offset; j < len + offset; j++) {
            temp1_r = temp2_r;
            temp1_i = temp2_i;
            temp2_r = temp3_r;
            temp2_i = temp3_i;
            temp3_r = buffer[j][bd][0];
            temp3_i = buffer[j][bd][1];
            r01r += temp3_r * temp2_r + temp3_i * temp2_i;
            r01i += temp3_i * temp2_r - temp3_r * temp2_i;
            r02r += temp3_r * temp1_r + temp3_i * temp1_i;
            r02i += temp3_i * temp1_r - temp3_r * temp1_i;
            r11r += temp2_r * temp2_r + temp2_i * temp2_i;
        }
        ac.r12[0] = r01r - (temp3_r * temp2_r + temp3_i * temp2_i) + (temp5_r * temp4_r + temp5_i * temp4_i);
        ac.r12[1] = r01i - (temp3_i * temp2_r - temp3_r * temp2_i) + (temp5_i * temp4_r - temp5_r * temp4_i);
        ac.r22[0] = r11r - (temp2_r * temp2_r + temp2_i * temp2_i) + (temp4_r * temp4_r + temp4_i * temp4_i);
        ac.r01[0] = r01r;
        ac.r01[1] = r01i;
        ac.r02[0] = r02r;
        ac.r02[1] = r02i;
        ac.r11[0] = r11r;
        ac.det = (ac.r11[0] * ac.r22[0]) - (rel * ((ac.r12[0] * ac.r12[0]) + (ac.r12[1] * ac.r12[1])));
    };
    constructor.calc_prediction_coef = function(sbr, Xlow, alpha_0, alpha_1, k) {
        var tmp;
        var ac = new HFGeneration.acorr_coef();
        HFGeneration.auto_correlation(sbr, ac, Xlow, k, sbr.numTimeSlotsRate + 6);
        if (ac.det == 0) {
            alpha_1[k][0] = 0;
            alpha_1[k][1] = 0;
        } else {
            tmp = 1.0 / ac.det;
            alpha_1[k][0] = ((ac.r01[0] * ac.r12[0]) - (ac.r01[1] * ac.r12[1]) - (ac.r02[0] * ac.r11[0])) * tmp;
            alpha_1[k][1] = ((ac.r01[1] * ac.r12[0]) + (ac.r01[0] * ac.r12[1]) - (ac.r02[1] * ac.r11[0])) * tmp;
        }
        if (ac.r11[0] == 0) {
            alpha_0[k][0] = 0;
            alpha_0[k][1] = 0;
        } else {
            tmp = 1.0 / ac.r11[0];
            alpha_0[k][0] = -(ac.r01[0] + (alpha_1[k][0] * ac.r12[0]) + (alpha_1[k][1] * ac.r12[1])) * tmp;
            alpha_0[k][1] = -(ac.r01[1] + (alpha_1[k][1] * ac.r12[0]) - (alpha_1[k][0] * ac.r12[1])) * tmp;
        }
        if (((alpha_0[k][0] * alpha_0[k][0]) + (alpha_0[k][1] * alpha_0[k][1]) >= 16.0) || ((alpha_1[k][0] * alpha_1[k][0]) + (alpha_1[k][1] * alpha_1[k][1]) >= 16.0)) {
            alpha_0[k][0] = 0;
            alpha_0[k][1] = 0;
            alpha_1[k][0] = 0;
            alpha_1[k][1] = 0;
        }
    };
    constructor.mapNewBw = function(invf_mode, invf_mode_prev) {
        switch (invf_mode) {
            case 1:
                if (invf_mode_prev == 0) 
                    return 0.6;
                 else 
                    return 0.75;
            case 2:
                return 0.9;
            case 3:
                return 0.98;
            default:
                if (invf_mode_prev == 1) 
                    return 0.6;
                 else 
                    return 0.0;
        }
    };
    constructor.calc_chirp_factors = function(sbr, ch) {
        var i;
        for (i = 0; i < sbr.N_Q; i++) {
            sbr.bwArray[ch][i] = HFGeneration.mapNewBw(sbr.bs_invf_mode[ch][i], sbr.bs_invf_mode_prev[ch][i]);
            if (sbr.bwArray[ch][i] < sbr.bwArray_prev[ch][i]) 
                sbr.bwArray[ch][i] = (sbr.bwArray[ch][i] * 0.75) + (sbr.bwArray_prev[ch][i] * 0.25);
             else 
                sbr.bwArray[ch][i] = (sbr.bwArray[ch][i] * 0.90625) + (sbr.bwArray_prev[ch][i] * 0.09375);
            if (sbr.bwArray[ch][i] < 0.015625) 
                sbr.bwArray[ch][i] = 0.0;
            if (sbr.bwArray[ch][i] >= 0.99609375) 
                sbr.bwArray[ch][i] = 0.99609375;
            sbr.bwArray_prev[ch][i] = sbr.bwArray[ch][i];
            sbr.bs_invf_mode_prev[ch][i] = sbr.bs_invf_mode[ch][i];
        }
    };
    constructor.patch_construction = function(sbr) {
        var i, k;
        var odd, sb;
        var msb = sbr.k0;
        var usb = sbr.kx;
        var goalSb = HFGeneration.goalSbTab[sbr.sample_rate.getIndex()];
        sbr.noPatches = 0;
        if (goalSb < (sbr.kx + sbr.M)) {
            for (i = 0 , k = 0; sbr.f_master[i] < goalSb; i++) {
                k = i + 1;
            }
        } else {
            k = sbr.N_master;
        }
        if (sbr.N_master == 0) {
            sbr.noPatches = 0;
            sbr.patchNoSubbands[0] = 0;
            sbr.patchStartSubband[0] = 0;
            return;
        }
        do {
            var j = k + 1;
            do {
                j--;
                sb = sbr.f_master[j];
                odd = (sb - 2 + sbr.k0) % 2;
            } while (sb > (sbr.k0 - 1 + msb - odd));
            sbr.patchNoSubbands[sbr.noPatches] = Math.max(sb - usb, 0);
            sbr.patchStartSubband[sbr.noPatches] = sbr.k0 - odd - sbr.patchNoSubbands[sbr.noPatches];
            if (sbr.patchNoSubbands[sbr.noPatches] > 0) {
                usb = sb;
                msb = sb;
                sbr.noPatches++;
            } else {
                msb = sbr.kx;
            }
            if (sbr.f_master[k] - sb < 3) 
                k = sbr.N_master;
        } while (sb != (sbr.kx + sbr.M));
        if ((sbr.patchNoSubbands[sbr.noPatches - 1] < 3) && (sbr.noPatches > 1)) {
            sbr.noPatches--;
        }
        sbr.noPatches = Math.min(sbr.noPatches, 5);
    };
}, {goalSbTab: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AutoFileChannelWrapper = function(file) {
    this.file = file;
    this.curTime = System.currentTimeMillis();
    AutoPool.getInstance().add(this);
    this.ensureOpen();
};
AutoFileChannelWrapper = stjs.extend(AutoFileChannelWrapper, null, [SeekableByteChannel, AutoResource], function(constructor, prototype) {
    constructor.THRESHOLD = 5000;
    prototype.ch = null;
    prototype.file = null;
    prototype.savedPos = 0;
    prototype.curTime = 0;
    prototype.accessTime = 0;
    prototype.ensureOpen = function() {
        this.accessTime = this.curTime;
        if (this.ch == null || !this.ch.isOpen()) {
            this.ch = new FileInputStream(this.file).getChannel();
            this.ch.position(this.savedPos);
        }
    };
    prototype.read = function(arg0) {
        this.ensureOpen();
        var r = this.ch.read(arg0);
        this.savedPos = this.ch.position();
        return r;
    };
    prototype.close = function() {
        if (this.ch != null && this.ch.isOpen()) {
            this.savedPos = this.ch.position();
            this.ch.close();
            this.ch = null;
        }
    };
    prototype.isOpen = function() {
        return this.ch != null && this.ch.isOpen();
    };
    prototype.write = function(arg0) {
        this.ensureOpen();
        var w = this.ch.write(arg0);
        this.savedPos = this.ch.position();
        return w;
    };
    prototype.position = function() {
        this.ensureOpen();
        return this.ch.position();
    };
    prototype.setPosition = function(newPosition) {
        this.ensureOpen();
        this.ch.position(newPosition);
        this.savedPos = newPosition;
        return this;
    };
    prototype.size = function() {
        this.ensureOpen();
        return this.ch.size();
    };
    prototype.truncate = function(size) {
        this.ensureOpen();
        this.ch.truncate(size);
        this.savedPos = this.ch.position();
        return this;
    };
    prototype.setCurTime = function(curTime) {
        this.curTime = curTime;
        if (this.ch != null && this.ch.isOpen() && curTime - this.accessTime > AutoFileChannelWrapper.THRESHOLD) {
            try {
                this.close();
            }catch (e) {
                 throw new RuntimeException(e);
            }
        }
    };
}, {ch: "FileChannel", file: "File"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Encoded stream packet
 *  
 *  @author The JCodec project
 *  
 */
var Packet = function(data, pts, timescale, duration, frameNo, frameType, tapeTimecode, displayOrder) {
    this.data = data;
    this.pts = pts;
    this.timescale = timescale;
    this.duration = duration;
    this.frameNo = frameNo;
    this.frameType = frameType;
    this.tapeTimecode = tapeTimecode;
    this.displayOrder = displayOrder;
};
Packet = stjs.extend(Packet, null, [], function(constructor, prototype) {
    constructor.FrameType = stjs.enumeration("KEY", "INTER", "UNKNOWN");
    prototype.data = null;
    prototype.pts = 0;
    prototype.timescale = 0;
    prototype.duration = 0;
    prototype.frameNo = 0;
    prototype.frameType = null;
    prototype.tapeTimecode = null;
    prototype.displayOrder = 0;
    constructor.createPacket = function(data, pts, timescale, duration, frameNo, frameType, tapeTimecode) {
        return new Packet(data, pts, timescale, duration, frameNo, frameType, tapeTimecode, 0);
    };
    constructor.createPacketWithData = function(other, data) {
        return new Packet(data, other.pts, other.timescale, other.duration, other.frameNo, other.frameType, other.tapeTimecode, other.displayOrder);
    };
    prototype.getData = function() {
        return this.data.duplicate();
    };
    prototype.getPts = function() {
        return this.pts;
    };
    prototype.getTimescale = function() {
        return this.timescale;
    };
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getFrameNo = function() {
        return this.frameNo;
    };
    prototype.setTimescale = function(timescale) {
        this.timescale = timescale;
    };
    prototype.getTapeTimecode = function() {
        return this.tapeTimecode;
    };
    prototype.setTapeTimecode = function(tapeTimecode) {
        this.tapeTimecode = tapeTimecode;
    };
    prototype.getDisplayOrder = function() {
        return this.displayOrder;
    };
    prototype.setDisplayOrder = function(displayOrder) {
        this.displayOrder = displayOrder;
    };
    prototype.getFrameType = function() {
        return this.frameType;
    };
    prototype.setFrameType = function(frameType) {
        this.frameType = frameType;
    };
    prototype.getPtsR = function() {
        return RationalLarge.R(this.pts, this.timescale);
    };
    prototype.getPtsD = function() {
        return (this.pts) / this.timescale;
    };
    prototype.getDurationD = function() {
        return (this.duration) / this.timescale;
    };
    prototype.setData = function(data) {
        this.data = data;
    };
    prototype.setPts = function(pts) {
        this.pts = pts;
    };
    constructor.FRAME_ASC = new (stjs.extend(function Packet$1() {}, null, [Comparator], function(constructor, prototype) {
        prototype.compare = function(o1, o2) {
            if (o1 == null && o2 == null) 
                return 0;
            if (o1 == null) 
                return -1;
            if (o2 == null) 
                return 1;
            return o1.frameNo < o2.frameNo ? -1 : (o1.frameNo == o2.frameNo ? 0 : 1);
        };
    }, {}, {}))();
    prototype.setDuration = function(duration) {
        this.duration = duration;
    };
    prototype.isKeyFrame = function() {
        return this.frameType == Packet.FrameType.KEY;
    };
}, {data: "ByteBuffer", frameType: {name: "Enum", arguments: ["Packet.FrameType"]}, tapeTimecode: "TapeTimecode", FRAME_ASC: {name: "Comparator", arguments: ["Packet"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Rational = function(num, den) {
    this.num = num;
    this.den = den;
};
Rational = stjs.extend(Rational, null, [], function(constructor, prototype) {
    constructor.ONE = new Rational(1, 1);
    constructor.HALF = new Rational(1, 2);
    constructor.ZERO = new Rational(0, 1);
    prototype.num = 0;
    prototype.den = 0;
    constructor.R = function(num, den) {
        return new Rational(num, den);
    };
    constructor.R1 = function(num) {
        return Rational.R(num, 1);
    };
    prototype.getNum = function() {
        return this.num;
    };
    prototype.getDen = function() {
        return this.den;
    };
    constructor.parseRational = function(string) {
        return Rational.parse(string);
    };
    constructor.parse = function(string) {
        var idx = string.indexOf(":");
        if (idx < 0) {
            idx = string.indexOf("/");
        }
        if (idx > 0) {
            var num = string.substring(0, idx);
            var den = string.substring(idx + 1);
            return new Rational(Integer.parseInt(num), Integer.parseInt(den));
        }
        return Rational.R(Integer.parseInt(string), 1);
    };
    prototype.hashCode = function() {
        var prime = 31;
        var result = 1;
        result = prime * result + this.den;
        result = prime * result + this.num;
        return result;
    };
    prototype.equals = function(obj) {
        if (this == obj) 
            return true;
        if (obj == null) 
            return false;
        if (this.getClass() != obj.getClass()) 
            return false;
        var other = obj;
        if (this.den != other.den) 
            return false;
        if (this.num != other.num) 
            return false;
        return true;
    };
    prototype.multiplyS = function(val) {
        return (((stjs.trunc((stjs.trunc(this.num) * val) / this.den))) | 0);
    };
    prototype.divideS = function(val) {
        return (((stjs.trunc((stjs.trunc(this.den) * val) / this.num))) | 0);
    };
    prototype.divideByS = function(val) {
        return stjs.trunc(this.num / (this.den * val));
    };
    prototype.multiplyLong = function(val) {
        return stjs.trunc((this.num * val) / this.den);
    };
    prototype.divideLong = function(val) {
        return stjs.trunc((this.den * val) / this.num);
    };
    prototype.flip = function() {
        return new Rational(this.den, this.num);
    };
    prototype.smallerThen = function(sec) {
        return this.num * sec.den < sec.num * this.den;
    };
    prototype.greaterThen = function(sec) {
        return this.num * sec.den > sec.num * this.den;
    };
    prototype.smallerOrEqualTo = function(sec) {
        return this.num * sec.den <= sec.num * this.den;
    };
    prototype.greaterOrEqualTo = function(sec) {
        return this.num * sec.den >= sec.num * this.den;
    };
    prototype.equalsRational = function(other) {
        return this.num * other.den == other.num * this.den;
    };
    prototype.plus = function(other) {
        return Rational.reduce(this.num * other.den + other.num * this.den, this.den * other.den);
    };
    prototype.plusLarge = function(other) {
        return RationalLarge.reduceLong(this.num * other.den + other.num * this.den, this.den * other.den);
    };
    prototype.minus = function(other) {
        return Rational.reduce(this.num * other.den - other.num * this.den, this.den * other.den);
    };
    prototype.minusLarge = function(other) {
        return RationalLarge.reduceLong(this.num * other.den - other.num * this.den, this.den * other.den);
    };
    prototype.plusInt = function(scalar) {
        return new Rational(this.num + scalar * this.den, this.den);
    };
    prototype.minusInt = function(scalar) {
        return new Rational(this.num - scalar * this.den, this.den);
    };
    prototype.multiplyInt = function(scalar) {
        return new Rational(this.num * scalar, this.den);
    };
    prototype.divideInt = function(scalar) {
        return new Rational(this.den * scalar, this.num);
    };
    prototype.divideByInt = function(scalar) {
        return new Rational(this.num, this.den * scalar);
    };
    prototype.multiply = function(other) {
        return Rational.reduce(this.num * other.num, this.den * other.den);
    };
    prototype.multiplyLarge = function(other) {
        return RationalLarge.reduceLong(this.num * other.num, this.den * other.den);
    };
    prototype.divide = function(other) {
        return Rational.reduce(other.num * this.den, other.den * this.num);
    };
    prototype.divideLarge = function(other) {
        return RationalLarge.reduceLong(other.num * this.den, other.den * this.num);
    };
    prototype.divideBy = function(other) {
        return Rational.reduce(this.num * other.den, this.den * other.num);
    };
    prototype.divideByLarge = function(other) {
        return RationalLarge.reduceLong(this.num * other.den, this.den * other.num);
    };
    prototype.scalar = function() {
        return this.num / this.den;
    };
    prototype.scalarClip = function() {
        return stjs.trunc(this.num / this.den);
    };
    constructor.reduce = function(num, den) {
        var gcd = MathUtil.gcd(num, den);
        return new Rational(stjs.trunc(num / gcd), stjs.trunc(den / gcd));
    };
    constructor.reduceRational = function(r) {
        return Rational.reduce(r.getNum(), r.getDen());
    };
    prototype.toString = function() {
        return this.num + "/" + this.den;
    };
    prototype.toDouble = function() {
        return this.num / this.den;
    };
}, {ONE: "Rational", HALF: "Rational", ZERO: "Rational"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PictureDisplayExtension = function() {};
PictureDisplayExtension = stjs.extend(PictureDisplayExtension, null, [MPEGHeader], function(constructor, prototype) {
    prototype.frame_centre_offsets = null;
    constructor.Picture_Display_Extension = 7;
    constructor.read = function(bits, se, pce) {
        var pde = new PictureDisplayExtension();
        pde.frame_centre_offsets = Array(PictureDisplayExtension.numberOfFrameCentreOffsets(se, pce));
        for (var i = 0; i < pde.frame_centre_offsets.length; i++) {
            var frame_centre_horizontal_offset = bits.readNBit(16);
            bits.read1Bit();
            var frame_centre_vertical_offset = bits.readNBit(16);
            bits.read1Bit();
            pde.frame_centre_offsets[i] = new Point(frame_centre_horizontal_offset, frame_centre_vertical_offset);
        }
        return pde;
    };
    constructor.numberOfFrameCentreOffsets = function(se, pce) {
        if (se == null || pce == null) 
             throw new IllegalArgumentException("PictureDisplayExtension requires SequenceExtension and PictureCodingExtension to be present");
        if (se.progressive_sequence == 1) {
            if (pce.repeat_first_field == 1) {
                if (pce.top_field_first == 1) 
                    return 3;
                 else 
                    return 2;
            } else {
                return 1;
            }
        } else {
            if (pce.picture_structure != PictureCodingExtension.Frame) {
                return 1;
            } else {
                if (pce.repeat_first_field == 1) 
                    return 3;
                 else 
                    return 2;
            }
        }
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(PictureDisplayExtension.Picture_Display_Extension, 4);
        for (var i = 0; i < this.frame_centre_offsets.length; i++) {
            var point = this.frame_centre_offsets[i];
            bw.writeNBit(point.getX(), 16);
            bw.writeNBit(point.getY(), 16);
        }
        bw.flush();
    };
}, {frame_centre_offsets: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var MDCT = function(length) {
    this.N = length;
    this.N2 = length >> 1;
    this.N4 = length >> 2;
    this.N8 = length >> 3;
    switch (length) {
        case 2048:
            this.sincos = MDCTTables.MDCT_TABLE_2048;
            break;
        case 256:
            this.sincos = MDCTTables.MDCT_TABLE_128;
            break;
        case 1920:
            this.sincos = MDCTTables.MDCT_TABLE_1920;
            break;
        case 240:
            this.sincos = MDCTTables.MDCT_TABLE_240;
        default:
             throw new AACException("unsupported MDCT length: " + length);
    }
    this.fft = new FFT(this.N4);
    this.buf = Array.apply(null, Array(this.N4)).map(function() {
        return new Float32Array(2);
    });
    this.tmp = new Float32Array(2);
};
MDCT = stjs.extend(MDCT, null, [MDCTTables], function(constructor, prototype) {
    prototype.N = 0;
    prototype.N2 = 0;
    prototype.N4 = 0;
    prototype.N8 = 0;
    prototype.sincos = null;
    prototype.fft = null;
    prototype.buf = null;
    prototype.tmp = null;
    prototype.process = function(_in, inOff, out, outOff) {
        var k;
        for (k = 0; k < this.N4; k++) {
            this.buf[k][1] = (_in[inOff + 2 * k] * this.sincos[k][0]) + (_in[inOff + this.N2 - 1 - 2 * k] * this.sincos[k][1]);
            this.buf[k][0] = (_in[inOff + this.N2 - 1 - 2 * k] * this.sincos[k][0]) - (_in[inOff + 2 * k] * this.sincos[k][1]);
        }
        this.fft.process(this.buf, false);
        for (k = 0; k < this.N4; k++) {
            this.tmp[0] = this.buf[k][0];
            this.tmp[1] = this.buf[k][1];
            this.buf[k][1] = (this.tmp[1] * this.sincos[k][0]) + (this.tmp[0] * this.sincos[k][1]);
            this.buf[k][0] = (this.tmp[0] * this.sincos[k][0]) - (this.tmp[1] * this.sincos[k][1]);
        }
        for (k = 0; k < this.N8; k += 2) {
            out[outOff + 2 * k] = this.buf[this.N8 + k][1];
            out[outOff + 2 + 2 * k] = this.buf[this.N8 + 1 + k][1];
            out[outOff + 1 + 2 * k] = -this.buf[this.N8 - 1 - k][0];
            out[outOff + 3 + 2 * k] = -this.buf[this.N8 - 2 - k][0];
            out[outOff + this.N4 + 2 * k] = this.buf[k][0];
            out[outOff + this.N4 + 2 + 2 * k] = this.buf[1 + k][0];
            out[outOff + this.N4 + 1 + 2 * k] = -this.buf[this.N4 - 1 - k][1];
            out[outOff + this.N4 + 3 + 2 * k] = -this.buf[this.N4 - 2 - k][1];
            out[outOff + this.N2 + 2 * k] = this.buf[this.N8 + k][0];
            out[outOff + this.N2 + 2 + 2 * k] = this.buf[this.N8 + 1 + k][0];
            out[outOff + this.N2 + 1 + 2 * k] = -this.buf[this.N8 - 1 - k][1];
            out[outOff + this.N2 + 3 + 2 * k] = -this.buf[this.N8 - 2 - k][1];
            out[outOff + this.N2 + this.N4 + 2 * k] = -this.buf[k][1];
            out[outOff + this.N2 + this.N4 + 2 + 2 * k] = -this.buf[1 + k][1];
            out[outOff + this.N2 + this.N4 + 1 + 2 * k] = this.buf[this.N4 - 1 - k][0];
            out[outOff + this.N2 + this.N4 + 3 + 2 * k] = this.buf[this.N4 - 2 - k][0];
        }
    };
    prototype.processForward = function(_in, out) {
        var n, k;
        for (k = 0; k < this.N8; k++) {
            n = k << 1;
            this.tmp[0] = _in[this.N - this.N4 - 1 - n] + _in[this.N - this.N4 + n];
            this.tmp[1] = _in[this.N4 + n] - _in[this.N4 - 1 - n];
            this.buf[k][0] = (this.tmp[0] * this.sincos[k][0]) + (this.tmp[1] * this.sincos[k][1]);
            this.buf[k][1] = (this.tmp[1] * this.sincos[k][0]) - (this.tmp[0] * this.sincos[k][1]);
            this.buf[k][0] *= this.N;
            this.buf[k][1] *= this.N;
            this.tmp[0] = _in[this.N2 - 1 - n] - _in[n];
            this.tmp[1] = _in[this.N2 + n] + _in[this.N - 1 - n];
            this.buf[k + this.N8][0] = (this.tmp[0] * this.sincos[k + this.N8][0]) + (this.tmp[1] * this.sincos[k + this.N8][1]);
            this.buf[k + this.N8][1] = (this.tmp[1] * this.sincos[k + this.N8][0]) - (this.tmp[0] * this.sincos[k + this.N8][1]);
            this.buf[k + this.N8][0] *= this.N;
            this.buf[k + this.N8][1] *= this.N;
        }
        this.fft.process(this.buf, true);
        for (k = 0; k < this.N4; k++) {
            n = k << 1;
            this.tmp[0] = (this.buf[k][0] * this.sincos[k][0]) + (this.buf[k][1] * this.sincos[k][1]);
            this.tmp[1] = (this.buf[k][1] * this.sincos[k][0]) - (this.buf[k][0] * this.sincos[k][1]);
            out[n] = -this.tmp[0];
            out[this.N2 - 1 - n] = this.tmp[1];
            out[this.N2 + n] = -this.tmp[1];
            out[this.N - 1 - n] = this.tmp[0];
        }
    };
}, {sincos: "Array", fft: "FFT", buf: "Array", tmp: "Float32Array", MDCT_TABLE_2048: "Array", MDCT_TABLE_128: "Array", MDCT_TABLE_1920: "Array", MDCT_TABLE_240: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  The data is -128 shifted, so 0 is represented by -128 and 255 is represented
 *  by +127
 *  
 *  @author The JCodec project
 *  
 */
var Picture = function(width, height, data, lowBits, color, lowBitsNum, crop) {
    this.width = width;
    this.height = height;
    this.data = data;
    this.lowBits = lowBits;
    this.color = color;
    this.lowBitsNum = lowBitsNum;
    this.crop = crop;
    if (color != null) {
        for (var i = 0; i < color.nComp; i++) {
            var mask = 255 >> (8 - color.compWidth[i]);
            if ((width & mask) != 0) 
                 throw new IllegalArgumentException("Component " + i + " width should be a multiple of " + (1 << color.compWidth[i]) + " for colorspace: " + color);
            if (crop != null && (crop.getWidth() & mask) != 0) 
                 throw new IllegalArgumentException("Component " + i + " cropped width should be a multiple of " + (1 << color.compWidth[i]) + " for colorspace: " + color);
            mask = 255 >> (8 - color.compHeight[i]);
            if ((height & mask) != 0) 
                 throw new IllegalArgumentException("Component " + i + " height should be a multiple of " + (1 << color.compHeight[i]) + " for colorspace: " + color);
            if (crop != null && (crop.getHeight() & mask) != 0) 
                 throw new IllegalArgumentException("Component " + i + " cropped height should be a multiple of " + (1 << color.compHeight[i]) + " for colorspace: " + color);
        }
    }
};
Picture = stjs.extend(Picture, null, [], function(constructor, prototype) {
    prototype.color = null;
    prototype.width = 0;
    prototype.height = 0;
    prototype.data = null;
    prototype.lowBits = null;
    prototype.lowBitsNum = 0;
    prototype.crop = null;
    constructor.createPicture = function(width, height, data, color) {
        return new Picture(width, height, data, null, color, 0, new Rect(0, 0, width, height));
    };
    constructor.createPictureHiBD = function(width, height, data, lowBits, color, lowBitsNum) {
        return new Picture(width, height, data, lowBits, color, lowBitsNum, new Rect(0, 0, width, height));
    };
    constructor.copyPicture = function(other) {
        return new Picture(other.width, other.height, other.data, other.lowBits, other.color, 0, other.crop);
    };
    constructor.create = function(width, height, colorSpace) {
        return Picture.createCropped(width, height, colorSpace, null);
    };
    constructor.createCropped = function(width, height, colorSpace, crop) {
        var planeSizes = new Int32Array(ColorSpace.MAX_PLANES);
        for (var i = 0; i < colorSpace.nComp; i++) {
            planeSizes[colorSpace.compPlane[i]] += (width >> colorSpace.compWidth[i]) * (height >> colorSpace.compHeight[i]);
        }
        var nPlanes = 0;
        for (var i = 0; i < ColorSpace.MAX_PLANES; i++) 
            nPlanes += planeSizes[i] != 0 ? 1 : 0;
        var data = Array(nPlanes);
        for (var i = 0, plane = 0; i < ColorSpace.MAX_PLANES; i++) {
            if (planeSizes[i] != 0) {
                data[plane++] = new Int8Array(planeSizes[i]);
            }
        }
        return new Picture(width, height, data, null, colorSpace, 0, crop);
    };
    constructor.createCroppedHiBD = function(width, height, lowBitsNum, colorSpace, crop) {
        var result = Picture.createCropped(width, height, colorSpace, crop);
        if (lowBitsNum <= 0) 
            return result;
        var data = result.getData();
        var nPlanes = data.length;
        var lowBits = Array(nPlanes);
        for (var i = 0, plane = 0; i < nPlanes; i++) {
            lowBits[plane++] = new Int8Array(data[i].length);
        }
        result.setLowBits(lowBits);
        result.setLowBitsNum(lowBitsNum);
        return result;
    };
    prototype.setLowBitsNum = function(lowBitsNum) {
        this.lowBitsNum = lowBitsNum;
    };
    prototype.setLowBits = function(lowBits) {
        this.lowBits = lowBits;
    };
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.getPlaneData = function(plane) {
        return this.data[plane];
    };
    prototype.getColor = function() {
        return this.color;
    };
    prototype.getData = function() {
        return this.data;
    };
    prototype.getLowBits = function() {
        return this.lowBits;
    };
    prototype.getCrop = function() {
        return this.crop;
    };
    prototype.getPlaneWidth = function(plane) {
        return this.width >> this.color.compWidth[plane];
    };
    prototype.getPlaneHeight = function(plane) {
        return this.height >> this.color.compHeight[plane];
    };
    prototype.compatible = function(src) {
        return src.color == this.color && src.width == this.width && src.height == this.height;
    };
    prototype.createCompatible = function() {
        return Picture.create(this.width, this.height, this.color);
    };
    prototype.copyFrom = function(src) {
        if (!this.compatible(src)) 
             throw new IllegalArgumentException("Can not copy to incompatible picture");
        for (var plane = 0; plane < this.color.nComp; plane++) {
            if (this.data[plane] == null) 
                continue;
            System.arraycopy(src.data[plane], 0, this.data[plane], 0, (this.width >> this.color.compWidth[plane]) * (this.height >> this.color.compHeight[plane]));
        }
    };
    /**
     *  Creates a cropped clone of this picture.
     *  
     *  @return
     */
    prototype.cloneCropped = function() {
        if (this.cropNeeded()) {
            return this.cropped();
        } else {
            var clone = this.createCompatible();
            clone.copyFrom(this);
            return clone;
        }
    };
    prototype.cropped = function() {
        if (!this.cropNeeded()) 
            return this;
        var result = Picture.create(this.crop.getWidth(), this.crop.getHeight(), this.color);
        if (this.color.planar) {
            for (var plane = 0; plane < this.data.length; plane++) {
                if (this.data[plane] == null) 
                    continue;
                this.cropSub(this.data[plane], this.crop.getX() >> this.color.compWidth[plane], this.crop.getY() >> this.color.compHeight[plane], this.crop.getWidth() >> this.color.compWidth[plane], this.crop.getHeight() >> this.color.compHeight[plane], this.width >> this.color.compWidth[plane], this.crop.getWidth() >> this.color.compWidth[plane], result.data[plane]);
            }
        } else {
            this.cropSub(this.data[0], this.crop.getX(), this.crop.getY(), this.crop.getWidth(), this.crop.getHeight(), this.width * this.color.nComp, this.crop.getWidth() * this.color.nComp, result.data[0]);
        }
        return result;
    };
    prototype.cropNeeded = function() {
        return this.crop != null && (this.crop.getX() != 0 || this.crop.getY() != 0 || this.crop.getWidth() != this.width || this.crop.getHeight() != this.height);
    };
    prototype.cropSub = function(src, x, y, w, h, srcStride, dstStride, tgt) {
        var srcOff = y * srcStride + x, dstOff = 0;
        for (var i = 0; i < h; i++) {
            for (var j = 0; j < dstStride; j++) 
                tgt[dstOff + j] = src[srcOff + j];
            srcOff += srcStride;
            dstOff += dstStride;
        }
    };
    prototype.setCrop = function(crop) {
        this.crop = crop;
    };
    prototype.getCroppedWidth = function() {
        return this.crop == null ? this.width : this.crop.getWidth();
    };
    prototype.getCroppedHeight = function() {
        return this.crop == null ? this.height : this.crop.getHeight();
    };
    prototype.getLowBitsNum = function() {
        return this.lowBitsNum;
    };
    constructor.fromPictureHiBD = function(pic) {
        var lowBitsNum = pic.getBitDepth() - 8;
        var lowBitsRound = (1 << lowBitsNum) >> 1;
        var result = Picture.createCroppedHiBD(pic.getWidth(), pic.getHeight(), lowBitsNum, pic.getColor(), pic.getCrop());
        for (var i = 0; i < Math.min(pic.getData().length, result.getData().length); i++) {
            for (var j = 0; j < Math.min(pic.getData()[i].length, result.getData()[i].length); j++) {
                var val = pic.getData()[i][j];
                var round = MathUtil.clip((val + lowBitsRound) >> lowBitsNum, 0, 255);
                result.getData()[i][j] = ((round - 128) << 24 >> 24);
            }
        }
        var lowBits = result.getLowBits();
        if (lowBits != null) {
            for (var i = 0; i < Math.min(pic.getData().length, result.getData().length); i++) {
                for (var j = 0; j < Math.min(pic.getData()[i].length, result.getData()[i].length); j++) {
                    var val = pic.getData()[i][j];
                    var round = MathUtil.clip((val + lowBitsRound) >> lowBitsNum, 0, 255);
                    lowBits[i][j] = ((val - (round << 2)) << 24 >> 24);
                }
            }
        }
        return result;
    };
    prototype.toPictureHiBD = function() {
        var create = PictureHiBD.doCreate(this.width, this.height, this.color, this.lowBitsNum + 8, this.crop);
        return this.toPictureHiBDInternal(create);
    };
    prototype.toPictureHiBDWithBuffer = function(buffer) {
        var create = new PictureHiBD(this.width, this.height, buffer, this.color, this.lowBitsNum + 8, this.crop);
        return this.toPictureHiBDInternal(create);
    };
    prototype.toPictureHiBDInternal = function(pic) {
        var dstData = pic.getData();
        for (var i = 0; i < this.data.length; i++) {
            var planeSize = this.getPlaneWidth(i) * this.getPlaneHeight(i);
            for (var j = 0; j < planeSize; j++) {
                dstData[i][j] = (this.data[i][j] + 128) << this.lowBitsNum;
            }
        }
        if (this.lowBits != null) {
            for (var i = 0; i < this.lowBits.length; i++) {
                var planeSize = this.getPlaneWidth(i) * this.getPlaneHeight(i);
                for (var j = 0; j < planeSize; j++) {
                    dstData[i][j] += this.lowBits[i][j];
                }
            }
        }
        return pic;
    };
    prototype.fill = function(val) {
        for (var i = 0; i < this.data.length; i++) {
            Arrays.fill(this.data[i], (val << 24 >> 24));
        }
    };
    prototype.equals = function(obj) {
        if (obj == null || !(stjs.isInstanceOf(obj.constructor, Picture))) 
            return false;
        var other = obj;
        if (other.getCroppedWidth() != this.getCroppedWidth() || other.getCroppedHeight() != this.getCroppedHeight() || other.getColor() != this.color) 
            return false;
        for (var i = 0; i < this.getData().length; i++) 
            if (!this.planeEquals(other, i)) 
                return false;
        return true;
    };
    prototype.planeEquals = function(other, plane) {
        var cw = this.color.compWidth[plane];
        var ch = this.color.compHeight[plane];
        var offA = other.getCrop() == null ? 0 : ((other.getCrop().getX() >> cw) + (other.getCrop().getY() >> ch) * (other.getWidth() >> cw));
        var offB = this.crop == null ? 0 : ((this.crop.getX() >> cw) + (this.crop.getY() >> ch) * (this.width >> cw));
        var planeData = other.getPlaneData(plane);
        for (var i = 0; i < this.getCroppedHeight() >> ch; i++ , offA += (other.getWidth() >> cw) , offB += (this.width >> cw)) {
            for (var j = 0; j < this.getCroppedWidth() >> cw; j++) {
                if (planeData[offA + j] != this.data[plane][offB + j]) 
                    return false;
            }
        }
        return true;
    };
    prototype.getStartX = function() {
        return this.crop == null ? 0 : this.crop.getX();
    };
    prototype.getStartY = function() {
        return this.crop == null ? 0 : this.crop.getY();
    };
    prototype.isHiBD = function() {
        return this.lowBits != null;
    };
    prototype.getSize = function() {
        return new Size(this.width, this.height);
    };
}, {color: "ColorSpace", data: "Array", lowBits: "Array", crop: "Rect"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ColorUtilHiBD = function() {};
ColorUtilHiBD = stjs.extend(ColorUtilHiBD, null, [], function(constructor, prototype) {
    constructor.map = new HashMap();
    constructor.getTransform = function(from, to) {
        var map2 = ColorUtilHiBD.map.get(from);
        return map2 == null ? null : map2.get(to);
    };
    constructor.Idential = function() {};
    constructor.Idential = stjs.extend(constructor.Idential, null, [TransformHiBD], function(constructor, prototype) {
        prototype.transform = function(src, dst) {
            for (var i = 0; i < 3; i++) 
                System.arraycopy(src.getPlaneData(i), 0, dst.getPlaneData(i), 0, Math.min(src.getPlaneWidth(i) * src.getPlaneHeight(i), dst.getPlaneWidth(i) * dst.getPlaneHeight(i)));
        };
    }, {}, {});
}, {map: {name: "Map", arguments: ["ColorSpace", {name: "Map", arguments: ["ColorSpace", "TransformHiBD"]}]}}, {});
(function() {
    var rgb = new HashMap();
    rgb.put(ColorSpace.RGB, new ColorUtilHiBD.Idential());
    rgb.put(ColorSpace.YUV420, new RgbToYuv420pHiBD(0, 0));
    rgb.put(ColorSpace.YUV420J, new RgbToYuv420jHiBD());
    rgb.put(ColorSpace.YUV422, new RgbToYuv422pHiBD(0, 0));
    rgb.put(ColorSpace.YUV422_10, new RgbToYuv422pHiBD(2, 0));
    ColorUtilHiBD.map.put(ColorSpace.RGB, rgb);
    var yuv420 = new HashMap();
    yuv420.put(ColorSpace.YUV420, new ColorUtilHiBD.Idential());
    yuv420.put(ColorSpace.RGB, new Yuv420pToRgbHiBD(0, 0));
    yuv420.put(ColorSpace.YUV422, new Yuv420pToYuv422pHiBD(0, 0));
    yuv420.put(ColorSpace.YUV422_10, new Yuv420pToYuv422pHiBD(0, 2));
    ColorUtilHiBD.map.put(ColorSpace.YUV420, yuv420);
    var yuv422 = new HashMap();
    yuv422.put(ColorSpace.YUV422, new ColorUtilHiBD.Idential());
    yuv422.put(ColorSpace.RGB, new Yuv422pToRgbHiBD(0, 0));
    yuv422.put(ColorSpace.YUV420, new Yuv422pToYuv420pHiBD(0, 0));
    yuv422.put(ColorSpace.YUV420J, new Yuv422pToYuv420jHiBD(0, 0));
    ColorUtilHiBD.map.put(ColorSpace.YUV422, yuv422);
    var yuv422_10 = new HashMap();
    yuv422_10.put(ColorSpace.YUV422_10, new ColorUtilHiBD.Idential());
    yuv422_10.put(ColorSpace.RGB, new Yuv422pToRgbHiBD(2, 0));
    yuv422_10.put(ColorSpace.YUV420, new Yuv422pToYuv420pHiBD(0, 2));
    yuv422_10.put(ColorSpace.YUV420J, new Yuv422pToYuv420jHiBD(0, 2));
    ColorUtilHiBD.map.put(ColorSpace.YUV422_10, yuv422_10);
    var yuv444 = new HashMap();
    yuv444.put(ColorSpace.YUV444, new ColorUtilHiBD.Idential());
    yuv444.put(ColorSpace.RGB, new Yuv444pToRgb(0, 0));
    yuv444.put(ColorSpace.YUV420, new Yuv444pToYuv420pHiBD(0, 0));
    ColorUtilHiBD.map.put(ColorSpace.YUV444, yuv444);
    var yuv444_10 = new HashMap();
    yuv444_10.put(ColorSpace.YUV444_10, new ColorUtilHiBD.Idential());
    yuv444_10.put(ColorSpace.RGB, new Yuv444pToRgb(2, 0));
    yuv444_10.put(ColorSpace.YUV420, new Yuv444pToYuv420pHiBD(0, 2));
    ColorUtilHiBD.map.put(ColorSpace.YUV444_10, yuv444_10);
    var yuv420j = new HashMap();
    yuv420j.put(ColorSpace.YUV420J, new ColorUtilHiBD.Idential());
    yuv420j.put(ColorSpace.RGB, new Yuv420jToRgbHiBD());
    yuv420j.put(ColorSpace.YUV420, new Yuv420jToYuv420HiBD());
    ColorUtilHiBD.map.put(ColorSpace.YUV420J, yuv420j);
    var yuv422j = new HashMap();
    yuv422j.put(ColorSpace.YUV422J, new ColorUtilHiBD.Idential());
    yuv422j.put(ColorSpace.RGB, new Yuv422jToRgbHiBD());
    yuv422j.put(ColorSpace.YUV420, new Yuv422jToYuv420pHiBD());
    yuv422j.put(ColorSpace.YUV420J, new Yuv422pToYuv420pHiBD(0, 0));
    ColorUtilHiBD.map.put(ColorSpace.YUV422J, yuv422j);
    var yuv444j = new HashMap();
    yuv444j.put(ColorSpace.YUV444J, new ColorUtilHiBD.Idential());
    yuv444j.put(ColorSpace.RGB, new Yuv444jToRgbHiBD());
    yuv444j.put(ColorSpace.YUV420, new Yuv444jToYuv420pHiBD());
    yuv444j.put(ColorSpace.YUV420J, new Yuv444pToYuv420pHiBD(0, 0));
    ColorUtilHiBD.map.put(ColorSpace.YUV444J, yuv444j);
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var EbmlVoid = function(id) {
    EbmlBase.call(this, id);
};
EbmlVoid = stjs.extend(EbmlVoid, EbmlBase, [], function(constructor, prototype) {
    prototype.getData = function() {
        return null;
    };
    prototype.skip = function(is) {
        is.setPosition(this.dataOffset + this.dataLen);
    };
}, {parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlMaster = function(id) {
    EbmlBase.call(this, id);
    this.children = new ArrayList();
    this.id = id;
};
EbmlMaster = stjs.extend(EbmlMaster, EbmlBase, [], function(constructor, prototype) {
    prototype.usedSize = 0;
    prototype.children = null;
    constructor.CLUSTER_ID = new Int8Array([31, (67 << 24 >> 24), (182 << 24 >> 24), (117 << 24 >> 24)]);
    prototype.add = function(elem) {
        if (elem == null) 
            return;
        elem.parent = this;
        this.children.add(elem);
    };
    prototype.getData = function() {
        var size = this.getDataLen();
        if (size > Integer.MAX_VALUE) 
            System.out.println("EbmlMaster.getData: id.length " + this.id.length + "  EbmlUtil.ebmlLength(" + size + "): " + EbmlUtil.ebmlLength(size) + " size: " + size);
        var bb = ByteBuffer.allocate((((this.id.length + EbmlUtil.ebmlLength(size) + size)) | 0));
        bb.putArr(this.id);
        bb.putArr(EbmlUtil.ebmlEncode(size));
        for (var i = 0; i < this.children.size(); i++) 
            bb.putBuf(this.children.get(i).getData());
        bb.flip();
        return bb;
    };
    prototype.getDataLen = function() {
        if (this.children == null || this.children.isEmpty()) 
            return this.dataLen;
        var dataLength = 0;
        for (var iterator$e = this.children.iterator(); iterator$e.hasNext(); ) {
            var e = iterator$e.next();
            dataLength += e.size();
        }
        return dataLength;
    };
    prototype.size = function() {
        var size = this.getDataLen();
        size += EbmlUtil.ebmlLength(size);
        size += this.id.length;
        return size;
    };
}, {children: {name: "ArrayList", arguments: ["EbmlBase"]}, CLUSTER_ID: "Int8Array", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlBin = function(id) {
    EbmlBase.call(this, id);
};
EbmlBin = stjs.extend(EbmlBin, EbmlBase, [], function(constructor, prototype) {
    prototype.data = null;
    prototype.dataRead = false;
    prototype.readChannel = function(is) {
        var bb = ByteBuffer.allocate(stjs.trunc(this.dataLen));
        is.read(bb);
        bb.flip();
        this.read(bb);
    };
    prototype.read = function(source) {
        this.data = source.slice();
        this.data.setLimit(stjs.trunc(this.dataLen));
        this.dataRead = true;
    };
    prototype.skip = function(source) {
        if (!this.dataRead) {
            source.setPosition((((this.dataOffset + this.dataLen)) | 0));
            this.dataRead = true;
        }
    };
    prototype.size = function() {
        if (this.data == null || this.data.limit() == 0) 
            return EbmlBase.prototype.size.call(this);
        var totalSize = this.data.limit();
        totalSize += EbmlUtil.ebmlLength(this.data.limit());
        totalSize += this.id.length;
        return totalSize;
    };
    prototype.setBuf = function(data) {
        this.data = data.slice();
        this.dataLen = this.data.limit();
    };
    prototype.getData = function() {
        var sizeSize = EbmlUtil.ebmlLength(this.data.limit());
        var size = EbmlUtil.ebmlEncodeLen(this.data.limit(), sizeSize);
        var bb = ByteBuffer.allocate(this.id.length + sizeSize + this.data.limit());
        bb.putArr(this.id);
        bb.putArr(size);
        bb.putBuf(this.data);
        bb.flip();
        this.data.flip();
        return bb;
    };
}, {data: "ByteBuffer", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  POC ( Picture Order Count ) manager
 *  
 *  Picture Order Count is used to represent an order of picture in a GOP ( Group
 *  of Pictures ) this is needed to correctly reorder and B-framed GOPs. POC is
 *  also used when building lists of reference pictures ( see 8.2.4.2 ).
 *  
 *  There are 3 possible ways of assigning POC to decoded pictures:
 *  
 *  - Explicit, i.e. POC is directly specified in a slice header in form <POC
 *  Pred> + <POC Dec>. <POC Pred> is a significant part of POC ( see 8.2.1.1 ). -
 *  Frame based type 1 ( see 8.2.1.2 ). - Frame based type 2 ( see 8.2.1.3 ).
 *  
 *  @author The JCodec project
 *  
 */
var POCManager = function() {};
POCManager = stjs.extend(POCManager, null, [], function(constructor, prototype) {
    prototype.prevPOCMsb = 0;
    prototype.prevPOCLsb = 0;
    prototype.calcPOC = function(firstSliceHeader, firstNu) {
        switch (firstSliceHeader.sps.picOrderCntType) {
            case 0:
                return this.calcPOC0(firstSliceHeader, firstNu);
            case 1:
                return this.calcPOC1(firstSliceHeader, firstNu);
            case 2:
                return this.calcPOC2(firstSliceHeader, firstNu);
            default:
                 throw new RuntimeException("POC no!!!");
        }
    };
    prototype.calcPOC2 = function(firstSliceHeader, firstNu) {
        return firstSliceHeader.frameNum << 1;
    };
    prototype.calcPOC1 = function(firstSliceHeader, firstNu) {
        return firstSliceHeader.frameNum << 1;
    };
    prototype.calcPOC0 = function(firstSliceHeader, firstNu) {
        if (firstNu.type == NALUnitType.IDR_SLICE) {
            this.prevPOCMsb = this.prevPOCLsb = 0;
        }
        var maxPOCLsbDiv2 = 1 << (firstSliceHeader.sps.log2MaxPicOrderCntLsbMinus4 + 3), maxPOCLsb = maxPOCLsbDiv2 << 1;
        var POCLsb = firstSliceHeader.picOrderCntLsb;
        var POCMsb, POC;
        if ((POCLsb < this.prevPOCLsb) && ((this.prevPOCLsb - POCLsb) >= maxPOCLsbDiv2)) 
            POCMsb = this.prevPOCMsb + maxPOCLsb;
         else if ((POCLsb > this.prevPOCLsb) && ((POCLsb - this.prevPOCLsb) > maxPOCLsbDiv2)) 
            POCMsb = this.prevPOCMsb - maxPOCLsb;
         else 
            POCMsb = this.prevPOCMsb;
        POC = POCMsb + POCLsb;
        if (firstNu.nal_ref_idc > 0) {
            if (this.hasMMCO5(firstSliceHeader, firstNu)) {
                this.prevPOCMsb = 0;
                this.prevPOCLsb = POC;
            } else {
                this.prevPOCMsb = POCMsb;
                this.prevPOCLsb = POCLsb;
            }
        }
        return POC;
    };
    prototype.hasMMCO5 = function(firstSliceHeader, firstNu) {
        if (firstNu.type != NALUnitType.IDR_SLICE && firstSliceHeader.refPicMarkingNonIDR != null) {
            var instructions = firstSliceHeader.refPicMarkingNonIDR.getInstructions();
            for (var i = 0; i < instructions.length; i++) {
                var instruction = instructions[i];
                if (instruction.getType() == RefPicMarking.InstrType.CLEAR) 
                    return true;
            }
        }
        return false;
    };
}, {}, {});
/**
 *  
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PPMEncoder = function() {};
PPMEncoder = stjs.extend(PPMEncoder, null, [], function(constructor, prototype) {
    prototype.encodeFrame = function(picture) {
        if (picture.getColor() != ColorSpace.RGB) 
             throw new IllegalArgumentException("Only RGB image can be stored in PPM");
        var buffer = ByteBuffer.allocate(picture.getWidth() * picture.getHeight() * 3 + 200);
        buffer.putArr(JCodecUtil2.asciiString("P6 " + picture.getWidth() + " " + picture.getHeight() + " 255\n"));
        var data = picture.getData();
        for (var i = 0; i < picture.getWidth() * picture.getHeight() * 3; i += 3) {
            buffer.put(((data[0][i + 2] + 128) << 24 >> 24));
            buffer.put(((data[0][i + 1] + 128) << 24 >> 24));
            buffer.put(((data[0][i] + 128) << 24 >> 24));
        }
        buffer.flip();
        return buffer;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  prefix VLC reader builder
 *  
 *  @author The JCodec project
 *  
 */
var VLCBuilder = function() {
    this.forward = new IntIntMap();
    this.inverse = new IntIntMap();
    this.codes = IntArrayList.createIntArrayList();
    this.codesSizes = IntArrayList.createIntArrayList();
};
VLCBuilder = stjs.extend(VLCBuilder, null, [], function(constructor, prototype) {
    constructor.createVLCBuilder = function(codes, lens, vals) {
        var b = new VLCBuilder();
        for (var i = 0; i < codes.length; i++) {
            b.setInt(codes[i], lens[i], vals[i]);
        }
        return b;
    };
    prototype.forward = null;
    prototype.inverse = null;
    prototype.codes = null;
    prototype.codesSizes = null;
    prototype.set = function(val, code) {
        this.setInt(Integer.parseInt(code, 2), code.length, val);
        return this;
    };
    prototype.setInt = function(code, len, val) {
        this.codes.add(code << (32 - len));
        this.codesSizes.add(len);
        this.forward.put(val, this.codes.size() - 1);
        this.inverse.put(this.codes.size() - 1, val);
        return this;
    };
    prototype.getVLC = function() {
        var self = this;
        return new (stjs.extend(function VLCBuilder$1(x0, x1) {
            VLC.call(this, x0, x1);
        }, VLC, [], function(constructor, prototype) {
            prototype.readVLC = function(_in) {
                return self.inverse.get(VLC.prototype.readVLC.call(this, _in));
            };
            prototype.readVLC16 = function(_in) {
                return self.inverse.get(VLC.prototype.readVLC16.call(this, _in));
            };
            prototype.writeVLC = function(out, code) {
                VLC.prototype.writeVLC.call(this, out, self.forward.get(code));
            };
        }, {codes: "Int32Array", codeSizes: "Int32Array", values: "Int32Array", valueSizes: "Int32Array"}, {}))(this.codes.toArray(), this.codesSizes.toArray());
    };
}, {forward: "IntIntMap", inverse: "IntIntMap", codes: "IntArrayList", codesSizes: "IntArrayList"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var CodedBlock = function(mode, r) {
    this.mode = mode;
    this.residual = r;
};
CodedBlock = stjs.extend(CodedBlock, null, [], function(constructor, prototype) {
    constructor.EMPTY_ARR = Array(0);
    prototype.mode = null;
    prototype.residual = null;
    prototype.getMode = function() {
        return this.mode;
    };
    prototype.getResidual = function() {
        return this.residual;
    };
    constructor.read = function(miCol, miRow, blSz, decoder, probs, c) {
        var mode;
        if (c.isKeyIntraFrame()) 
            mode = ModeInfo.read(miCol, miRow, blSz, decoder, probs, c);
         else 
            mode = InterModeInfo.readInter(miCol, miRow, blSz, decoder, probs, c);
        var r = Residual.read(miCol, miRow, blSz, decoder, probs, c, mode);
        return new CodedBlock(mode, r);
    };
}, {EMPTY_ARR: "Array", mode: "ModeInfo", residual: "Residual"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ColorUtil = function() {};
ColorUtil = stjs.extend(ColorUtil, null, [], function(constructor, prototype) {
    constructor.map = new HashMap();
    constructor.getTransform = function(from, to) {
        var map2 = ColorUtil.map.get(from);
        return map2 == null ? null : map2.get(to);
    };
    constructor.Idential = function() {};
    constructor.Idential = stjs.extend(constructor.Idential, null, [Transform], function(constructor, prototype) {
        prototype.transform = function(src, dst) {
            for (var i = 0; i < Math.min(src.getData().length, dst.getData().length); i++) 
                System.arraycopy(src.getPlaneData(i), 0, dst.getPlaneData(i), 0, Math.min(src.getPlaneData(i).length, dst.getPlaneData(i).length));
            var srcLowBits = src.getLowBits();
            var dstLowBits = dst.getLowBits();
            if (srcLowBits != null && dstLowBits != null) {
                for (var i = 0; i < Math.min(src.getData().length, dst.getData().length); i++) 
                    System.arraycopy(srcLowBits[i], 0, dstLowBits[i], 0, Math.min(src.getPlaneData(i).length, dst.getPlaneData(i).length));
            }
        };
    }, {}, {});
}, {map: {name: "Map", arguments: ["ColorSpace", {name: "Map", arguments: ["ColorSpace", "Transform"]}]}}, {});
(function() {
    var rgb = new HashMap();
    rgb.put(ColorSpace.RGB, new ColorUtil.Idential());
    rgb.put(ColorSpace.YUV420J, new RgbToYuv420j());
    rgb.put(ColorSpace.YUV420, new RgbToYuv420p());
    rgb.put(ColorSpace.YUV422, new RgbToYuv422p());
    ColorUtil.map.put(ColorSpace.RGB, rgb);
    var yuv420 = new HashMap();
    yuv420.put(ColorSpace.YUV420, new ColorUtil.Idential());
    yuv420.put(ColorSpace.YUV422, new Yuv420pToYuv422p());
    yuv420.put(ColorSpace.RGB, new Yuv420pToRgb());
    yuv420.put(ColorSpace.YUV420J, new ColorUtil.Idential());
    ColorUtil.map.put(ColorSpace.YUV420, yuv420);
    var yuv422 = new HashMap();
    yuv422.put(ColorSpace.YUV422, new ColorUtil.Idential());
    yuv422.put(ColorSpace.YUV420, new Yuv422pToYuv420p());
    yuv422.put(ColorSpace.YUV420J, new Yuv422pToYuv420p());
    yuv422.put(ColorSpace.RGB, new Yuv422pToRgb());
    ColorUtil.map.put(ColorSpace.YUV422, yuv422);
    var yuv444 = new HashMap();
    yuv444.put(ColorSpace.YUV444, new ColorUtil.Idential());
    ColorUtil.map.put(ColorSpace.YUV444, yuv444);
    var yuv444j = new HashMap();
    yuv444j.put(ColorSpace.YUV444J, new ColorUtil.Idential());
    yuv444j.put(ColorSpace.YUV420J, new Yuv444jToYuv420j());
    ColorUtil.map.put(ColorSpace.YUV444J, yuv444j);
    var yuv420j = new HashMap();
    yuv420j.put(ColorSpace.YUV420J, new ColorUtil.Idential());
    yuv420j.put(ColorSpace.YUV422, new Yuv420pToYuv422p());
    yuv420j.put(ColorSpace.RGB, new Yuv420jToRgb());
    yuv420j.put(ColorSpace.YUV420, new ColorUtil.Idential());
    ColorUtil.map.put(ColorSpace.YUV420J, yuv420j);
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Audio filter graph
 *  
 *  Represents a combination of filters as on 'uber' filter
 *  
 *  @author The JCodec project
 *  
 */
var FilterGraph = function(sockets) {
    this.sockets = sockets;
};
FilterGraph = stjs.extend(FilterGraph, null, [AudioFilter], function(constructor, prototype) {
    constructor.addLevel = function(first) {
        return new FilterGraph.Factory(first);
    };
    constructor.Factory = function(firstFilter) {
        this.sockets = new ArrayList();
        if (firstFilter.getDelay() != 0) {
            this.sockets.add(FilterSocket.createFilterSocket(new Audio.DummyFilter(firstFilter.getNInputs())));
            this.addLevel(firstFilter);
        } else 
            this.sockets.add(FilterSocket.createFilterSocket(firstFilter));
    };
    constructor.Factory = stjs.extend(constructor.Factory, null, [], function(constructor, prototype) {
        prototype.sockets = null;
        /**
         *  Adds filters to the next level in the graph
         *  
         *  The filters are added to from the left to the right, i.e.
         *  <pre>
         *            L0
         *      L1 L1 L1 L1 L1 L1
         *      L2 L2 -->
         *  </pre>     
         *  As a consequence if the filters in this level contain less inputs then
         *  there are outputs in a previous level the graph will throw exception
         *  because the configuration it's misconfigured.
         *  
         *  @param filters
         *  @return
         */
        prototype.addLevel = function(_arguments) {
            var socket = FilterSocket.createFilterSocket(arguments);
            socket.allocateBuffers(4096);
            this.sockets.add(socket);
            return this;
        };
        /**
         *  Adds n of this filter as the next level in a graph
         *  
         *  @param filter
         *  @param n
         *  @return
         */
        prototype.addLevels = function(filter, n) {
            var filters = Array(n);
            Arrays.fill(filters, filter);
            return this.addLevel(filters);
        };
        /**
         *  Adds a level to the graph and tries to fill it with as many of the
         *  current filter as will be needed to take all the outputs of the
         *  previous level
         *  
         *  @param filter
         *  @return
         */
        prototype.addLevelSpan = function(filter) {
            var prevLevelOuts = this.sockets.get(this.sockets.size() - 1).getTotalOutputs();
            if ((prevLevelOuts % filter.getNInputs()) != 0) 
                 throw new IllegalArgumentException("Can't fill " + prevLevelOuts + " with multiple of " + filter.getNInputs());
            return this.addLevels(filter, stjs.trunc(prevLevelOuts / filter.getNInputs()));
        };
        prototype.create = function() {
            return new FilterGraph(this.sockets.toArray(Array(0)));
        };
    }, {sockets: {name: "List", arguments: ["FilterSocket"]}}, {});
    prototype.sockets = null;
    prototype.filter = function(ins, pos, outs) {
        this.sockets[0].setBuffers(ins, pos);
        for (var i = 0; i < this.sockets.length; i++) {
            var curOut = i < this.sockets.length - 1 ? this.sockets[i + 1].getBuffers() : outs;
            this.sockets[i].filter(curOut);
            if (i > 0) {
                this.sockets[i].rotate();
            }
            if (i < this.sockets.length - 1) {
                for (var index$b = 0, arr$b = curOut; index$b < arr$b.length; index$b++) {
                    var b = arr$b[index$b];
                    b.flip();
                }
            }
        }
    };
    prototype.getDelay = function() {
        return this.sockets[0].getFilters()[0].getDelay();
    };
    prototype.getNInputs = function() {
        return this.sockets[0].getTotalInputs();
    };
    prototype.getNOutputs = function() {
        return this.sockets[this.sockets.length - 1].getTotalOutputs();
    };
}, {sockets: "Array"}, {});
var MXFCodec = function(ul, codec) {
    this.ul = ul;
    this.codec = codec;
};
MXFCodec = stjs.extend(MXFCodec, null, [], function(constructor, prototype) {
    prototype.ul = null;
    prototype.codec = null;
    constructor.mxfCodec = function(ul, codec) {
        return new MXFCodec(UL.newUL(ul), codec);
    };
    prototype.getUl = function() {
        return this.ul;
    };
    prototype.getCodec = function() {
        return this.codec;
    };
    constructor.MPEG2_XDCAM = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.03.04.01.02.02.01.04.03", Codec.MPEG2);
    constructor.MPEG2_ML = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.03.04.01.02.02.01.01.11", Codec.MPEG2);
    constructor.MPEG2_D10_PAL = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.01.04.01.02.02.01.02.01.01", Codec.MPEG2);
    constructor.MPEG2_HL = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.03.04.01.02.02.01.03.03", Codec.MPEG2);
    constructor.MPEG2_HL_422_I = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.03.04.01.02.02.01.04.02", Codec.MPEG2);
    constructor.MPEG4_XDCAM_PROXY = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.03.04.01.02.02.01.20.02.03", Codec.MPEG4);
    constructor.DV_25_PAL = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.01.04.01.02.02.02.01.02", Codec.DV);
    constructor.JPEG2000 = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.07.04.01.02.02.03.01.01", Codec.J2K);
    constructor.VC1 = MXFCodec.mxfCodec("06.0e.2b.34.04.01.01.0A.04.01.02.02.04", Codec.VC1);
    constructor.RAW = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.01.04.01.02.01.7F", null);
    constructor.RAW_422 = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.0A.04.01.02.01.01.02.01", null);
    constructor.VC3_DNXHD = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.01.04.01.02.02.03.02", Codec.VC3);
    constructor.VC3_DNXHD_2 = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.01.04.01.02.02.71", Codec.VC3);
    constructor.VC3_DNXHD_AVID = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.01.0E.04.02.01.02.04.01", Codec.VC3);
    constructor.AVC_INTRA = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.0A.04.01.02.02.01.32", Codec.H264);
    constructor.AVC_SPSPPS = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.0A.04.01.02.02.01.31.11.01", Codec.H264);
    constructor.V210 = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.0A.04.01.02.01.01.02.02", Codec.V210);
    constructor.PRORES_AVID = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.01.0E.04.02.01.02.11", Codec.PRORES);
    constructor.PRORES = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.0D.04.01.02.02.03.06", Codec.PRORES);
    constructor.PCM_S16LE_1 = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.01.04.02.02.01", null);
    constructor.PCM_S16LE_3 = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.01.04.02.02.01.01", null);
    constructor.PCM_S16LE_2 = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.01.04.02.02.01.7F", null);
    constructor.PCM_S16BE = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.07.04.02.02.01.7E", null);
    constructor.PCM_ALAW = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.04.04.02.02.02.03.01.01", Codec.ALAW);
    constructor.AC3 = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.01.04.02.02.02.03.02.01", Codec.AC3);
    constructor.MP2 = MXFCodec.mxfCodec("06.0E.2B.34.04.01.01.01.04.02.02.02.03.02.05", Codec.MP3);
    constructor.UNKNOWN = new MXFCodec(new UL(new Int8Array(0)), null);
    constructor.values = function() {
        return [MXFCodec.MPEG2_XDCAM, MXFCodec.MPEG2_ML, MXFCodec.MPEG2_D10_PAL, MXFCodec.MPEG2_HL, MXFCodec.MPEG2_HL_422_I, MXFCodec.MPEG4_XDCAM_PROXY, MXFCodec.DV_25_PAL, MXFCodec.JPEG2000, MXFCodec.VC1, MXFCodec.RAW, MXFCodec.RAW_422, MXFCodec.VC3_DNXHD, MXFCodec.VC3_DNXHD_2, MXFCodec.VC3_DNXHD_AVID, MXFCodec.AVC_INTRA, MXFCodec.AVC_SPSPPS, MXFCodec.V210, MXFCodec.PRORES_AVID, MXFCodec.PRORES, MXFCodec.PCM_S16LE_1, MXFCodec.PCM_S16LE_3, MXFCodec.PCM_S16LE_2, MXFCodec.PCM_S16BE, MXFCodec.PCM_ALAW, MXFCodec.AC3, MXFCodec.MP2];
    };
}, {ul: "UL", codec: "Codec", MPEG2_XDCAM: "MXFCodec", MPEG2_ML: "MXFCodec", MPEG2_D10_PAL: "MXFCodec", MPEG2_HL: "MXFCodec", MPEG2_HL_422_I: "MXFCodec", MPEG4_XDCAM_PROXY: "MXFCodec", DV_25_PAL: "MXFCodec", JPEG2000: "MXFCodec", VC1: "MXFCodec", RAW: "MXFCodec", RAW_422: "MXFCodec", VC3_DNXHD: "MXFCodec", VC3_DNXHD_2: "MXFCodec", VC3_DNXHD_AVID: "MXFCodec", AVC_INTRA: "MXFCodec", AVC_SPSPPS: "MXFCodec", V210: "MXFCodec", PRORES_AVID: "MXFCodec", PRORES: "MXFCodec", PCM_S16LE_1: "MXFCodec", PCM_S16LE_3: "MXFCodec", PCM_S16LE_2: "MXFCodec", PCM_S16BE: "MXFCodec", PCM_ALAW: "MXFCodec", AC3: "MXFCodec", MP2: "MXFCodec", UNKNOWN: "MXFCodec"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEG4Renderer = function() {};
MPEG4Renderer = stjs.extend(MPEG4Renderer, null, [], function(constructor, prototype) {
    constructor.checkMV = function(mv, xHigh, xLow, yHigh, yLow) {
        if (mv.x > xHigh) {
            mv.x = xHigh;
        } else if (mv.x < xLow) {
            mv.x = xLow;
        }
        if (mv.y > yHigh) {
            mv.y = yHigh;
        } else if (mv.y < yLow) {
            mv.y = yLow;
        }
    };
    constructor.validateVector = function(mvs, ctx, xPos, yPos) {
        var shift = 5 + (ctx.quarterPel ? 1 : 0);
        var xHigh = (ctx.mbWidth - xPos) << shift;
        var xLow = (-xPos - 1) << shift;
        var yHigh = (ctx.mbHeight - yPos) << shift;
        var yLow = (-yPos - 1) << shift;
        MPEG4Renderer.checkMV(mvs[0], xHigh, xLow, yHigh, yLow);
        MPEG4Renderer.checkMV(mvs[1], xHigh, xLow, yHigh, yLow);
        MPEG4Renderer.checkMV(mvs[2], xHigh, xLow, yHigh, yLow);
        MPEG4Renderer.checkMV(mvs[3], xHigh, xLow, yHigh, yLow);
    };
    constructor.renderIntra = function(mb, ctx) {
        MPEG4DCT.idctPut(mb.pred, mb.block, ctx.interlacing && mb.fieldDCT);
    };
    constructor.renderInter = function(ctx, refs, mb, fcode, ref, bvop) {
        if (mb.coded) {
            if (mb.mcsel) {
                 throw new RuntimeException("GMC");
            } else if (mb.mode == MPEG4Consts.MODE_INTER || mb.mode == MPEG4Consts.MODE_INTER_Q || mb.mode == MPEG4Consts.MODE_INTER4V) {
                if (!mb.fieldPred) {
                    MPEG4Renderer.renderMBInter(ctx, refs, mb, ref, bvop);
                } else {
                     throw new RuntimeException("interlaced");
                }
            } else {
                MPEG4Renderer.renderIntra(mb, ctx);
            }
        } else {
            MPEG4Renderer.renderMBInter(ctx, refs, mb, ref, bvop);
        }
    };
    constructor.renderMBInter = function(ctx, refs, mb, ref, bvop) {
        var uv_dx, uv_dy;
        var mv = Array(4);
        for (var i = 0; i < 4; i++) {
            mv[i] = new Macroblock.Vector(mb.mvs[i].x, mb.mvs[i].y);
        }
        MPEG4Renderer.validateVector(mv, ctx, mb.x, mb.y);
        var mbX = mb.x << 4;
        var mbY = mb.y << 4;
        var codedW = ctx.mbWidth << 4;
        var codedH = ctx.mbHeight << 4;
        var codedWcr = ctx.mbWidth << 3;
        var codedHcr = ctx.mbHeight << 3;
        if (mb.mode != MPEG4Consts.MODE_INTER4V || bvop) {
            var backward = refs[ref];
            uv_dx = MPEG4Renderer.calcChromaMv(ctx, mv[0].x);
            uv_dy = MPEG4Renderer.calcChromaMv(ctx, mv[0].y);
            if (ctx.quarterPel) {
                MPEG4Interpolator.interpolate16x16QP(mb.pred[0], backward.getPlaneData(0), mbX, mbY, codedW, codedH, mv[0].x, mv[0].y, backward.getWidth(), ctx.rounding);
            } else {
                MPEG4Interpolator.interpolate16x16Planar(mb.pred[0], backward.getPlaneData(0), mbX, mbY, codedW, codedH, mv[0].x, mv[0].y, backward.getWidth(), ctx.rounding);
            }
        } else {
            uv_dx = MPEG4Renderer.calcChromaMvAvg(ctx, mv, true);
            uv_dy = MPEG4Renderer.calcChromaMvAvg(ctx, mv, false);
            var backward = refs[0];
            var lumaPlane = backward.getPlaneData(0);
            var lumaStride = backward.getWidth();
            if (ctx.quarterPel) {
                MPEG4Interpolator.interpolate8x8QP(mb.pred[0], 0, lumaPlane, mbX, mbY, codedW, codedH, mv[0].x, mv[0].y, lumaStride, ctx.rounding);
                MPEG4Interpolator.interpolate8x8QP(mb.pred[0], 8, lumaPlane, mbX + 8, mbY, codedW, codedH, mv[1].x, mv[1].y, lumaStride, ctx.rounding);
                MPEG4Interpolator.interpolate8x8QP(mb.pred[0], 128, lumaPlane, mbX, mbY + 8, codedW, codedH, mv[2].x, mv[2].y, lumaStride, ctx.rounding);
                MPEG4Interpolator.interpolate8x8QP(mb.pred[0], 136, lumaPlane, mbX + 8, mbY + 8, codedW, codedH, mv[3].x, mv[3].y, lumaStride, ctx.rounding);
            } else {
                MPEG4Interpolator.interpolate8x8Planar(mb.pred[0], 0, 16, lumaPlane, mbX, mbY, codedW, codedH, mv[0].x, mv[0].y, lumaStride, ctx.rounding);
                MPEG4Interpolator.interpolate8x8Planar(mb.pred[0], 8, 16, lumaPlane, mbX + 8, mbY, codedW, codedH, mv[1].x, mv[1].y, lumaStride, ctx.rounding);
                MPEG4Interpolator.interpolate8x8Planar(mb.pred[0], 128, 16, lumaPlane, mbX, mbY + 8, codedW, codedH, mv[2].x, mv[2].y, lumaStride, ctx.rounding);
                MPEG4Interpolator.interpolate8x8Planar(mb.pred[0], 136, 16, lumaPlane, mbX + 8, mbY + 8, codedW, codedH, mv[3].x, mv[3].y, lumaStride, ctx.rounding);
            }
        }
        MPEG4Interpolator.interpolate8x8Planar(mb.pred[1], 0, 8, refs[ref].getPlaneData(1), 8 * mb.x, 8 * mb.y, codedWcr, codedHcr, uv_dx, uv_dy, refs[ref].getPlaneWidth(1), ctx.rounding);
        MPEG4Interpolator.interpolate8x8Planar(mb.pred[2], 0, 8, refs[ref].getPlaneData(2), 8 * mb.x, 8 * mb.y, codedWcr, codedHcr, uv_dx, uv_dy, refs[ref].getPlaneWidth(2), ctx.rounding);
        if (mb.cbp != 0) {
            for (var i = 0; i < 6; i++) {
                var block = mb.block[i];
                if ((mb.cbp & (1 << (5 - i))) != 0) {
                    MPEG4DCT.idctAdd(mb.pred, block, i, ctx.interlacing && mb.fieldDCT);
                }
            }
        }
    };
    constructor.calcChromaMv = function(ctx, ret) {
        if (ctx.quarterPel) {
            if (ctx.bsVersion <= MPEG4Consts.ALT_CHROMA_ROUNDING) {
                ret = (ret >> 1) | (ret & 1);
            } else {
                ret = stjs.trunc(ret / (2));
            }
        }
        return (ret >> 1) + MPEG4Consts.ROUNDTAB_79[ret & 3];
    };
    constructor.calcChromaMvAvg = function(ctx, mv, x) {
        var ret;
        if (ctx.quarterPel) {
            if (ctx.bsVersion <= MPEG4Consts.ALT_CHROMA_ROUNDING) {
                ret = 0;
                for (var z = 0; z < 4; z++) {
                    if (x) 
                        ret += ((mv[z].x >> 1) | (mv[z].x & 1));
                     else 
                        ret += ((mv[z].y >> 1) | (mv[z].y & 1));
                }
            } else {
                if (x) 
                    ret = (stjs.trunc(mv[0].x / 2)) + (stjs.trunc(mv[1].x / 2)) + (stjs.trunc(mv[2].x / 2)) + (stjs.trunc(mv[3].x / 2));
                 else 
                    ret = (stjs.trunc(mv[0].y / 2)) + (stjs.trunc(mv[1].y / 2)) + (stjs.trunc(mv[2].y / 2)) + (stjs.trunc(mv[3].y / 2));
            }
        } else {
            if (x) 
                ret = mv[0].x + mv[1].x + mv[2].x + mv[3].x;
             else 
                ret = mv[0].y + mv[1].y + mv[2].y + mv[3].y;
        }
        ret = (ret >> 3) + MPEG4Consts.ROUNDTAB_76[ret & 15];
        return ret;
    };
    constructor.sanitize = function(value, quarterPel, fcode) {
        var length = 1 << (fcode + 4);
        if (value < -length) 
            return -length;
         else if (value >= length) 
            return length - 1;
         else 
            return value;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Scales image to a different size.
 *  
 *  @author The JCodec project
 *  
 */
var ScaleFilter = function(width, height) {
    this.width = width;
    this.height = height;
};
ScaleFilter = stjs.extend(ScaleFilter, null, [Filter], function(constructor, prototype) {
    prototype.resampler = null;
    prototype.currentColor = null;
    prototype.currentSize = null;
    prototype.targetSize = null;
    prototype.width = 0;
    prototype.height = 0;
    prototype.getTarget = function() {
        return new Size(this.width, this.height);
    };
    prototype.filter = function(picture, store) {
        var pictureSize = picture.getSize();
        if (this.resampler == null || this.currentColor != picture.getColor() || !pictureSize.equals(this.currentSize)) {
            this.currentColor = picture.getColor();
            this.currentSize = picture.getSize();
            this.targetSize = new Size(this.width & this.currentColor.getWidthMask(), this.height & this.currentColor.getHeightMask());
            this.resampler = new LanczosResampler(this.currentSize, this.targetSize);
        }
        var dest = store.getPicture(this.targetSize.getWidth(), this.targetSize.getHeight(), this.currentColor);
        this.resampler.resample(picture, dest.getPicture());
        return dest;
    };
    prototype.getInputColor = function() {
        return ColorSpace.ANY_PLANAR;
    };
    prototype.getOutputColor = function() {
        return ColorSpace.SAME;
    };
}, {resampler: "BaseResampler", currentColor: "ColorSpace", currentSize: "Size", targetSize: "Size"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A class responsible for outputting exp-Golomb values into binary stream
 *  
 *  @author The JCodec project
 *  
 */
var CAVLCWriter = function() {};
CAVLCWriter = stjs.extend(CAVLCWriter, null, [], function(constructor, prototype) {
    constructor.writeUtrace = function(out, value, n, message) {
        out.writeNBit(value, n);
        Debug.trace(message, value);
    };
    constructor.writeUE = function(out, value) {
        var bits = 0;
        var cumul = 0;
        for (var i = 0; i < 15; i++) {
            if (value < cumul + (1 << i)) {
                bits = i;
                break;
            }
            cumul += (1 << i);
        }
        out.writeNBit(0, bits);
        out.write1Bit(1);
        out.writeNBit(value - cumul, bits);
    };
    constructor.writeSE = function(out, value) {
        CAVLCWriter.writeUE(out, MathUtil.golomb(value));
    };
    constructor.writeUEtrace = function(out, value, message) {
        CAVLCWriter.writeUE(out, value);
        Debug.trace(message, value);
    };
    constructor.writeSEtrace = function(out, value, message) {
        CAVLCWriter.writeUE(out, MathUtil.golomb(value));
        Debug.trace(message, value);
    };
    constructor.writeTE = function(out, value, max) {
        if (max > 1) 
            CAVLCWriter.writeUE(out, value);
         else 
            out.write1Bit(~value & 1);
    };
    constructor.writeBool = function(out, value, message) {
        out.write1Bit(value ? 1 : 0);
        Debug.trace(message, value ? 1 : 0);
    };
    constructor.writeU = function(out, i, n) {
        out.writeNBit(i, n);
    };
    constructor.writeNBit = function(out, value, n, message) {
        for (var i = 0; i < n; i++) {
            out.write1Bit((((value >> (n - i - 1))) | 0) & 1);
        }
        Debug.trace(message, value);
    };
    constructor.writeTrailingBits = function(out) {
        out.write1Bit(1);
        out.flush();
    };
    constructor.writeSliceTrailingBits = function() {
         throw new NotImplementedException("todo");
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var CAVLCReader = function() {};
CAVLCReader = stjs.extend(CAVLCReader, null, [], function(constructor, prototype) {
    constructor.readNBit = function(bits, n, message) {
        var val = bits.readNBit(n);
        Debug.trace(message, val);
        return val;
    };
    constructor.readUE = function(bits) {
        var cnt = 0;
         while (bits.read1Bit() == 0 && cnt < 32)
            cnt++;
        var res = 0;
        if (cnt > 0) {
            var val = bits.readNBit(cnt);
            res = ((((1 << cnt) - 1 + val)) | 0);
        }
        return res;
    };
    constructor.readUEtrace = function(bits, message) {
        var res = CAVLCReader.readUE(bits);
        Debug.trace(message, res);
        return res;
    };
    constructor.readSE = function(bits, message) {
        var val = CAVLCReader.readUE(bits);
        val = H264Utils2.golomb2Signed(val);
        Debug.trace(message, val);
        return val;
    };
    constructor.readBool = function(bits, message) {
        var res = bits.read1Bit() == 0 ? false : true;
        Debug.trace(message, res ? 1 : 0);
        return res;
    };
    constructor.readU = function(bits, i, string) {
        return stjs.trunc(CAVLCReader.readNBit(bits, i, string));
    };
    constructor.readTE = function(bits, max) {
        if (max > 1) 
            return CAVLCReader.readUE(bits);
        return ~bits.read1Bit() & 1;
    };
    constructor.readME = function(bits, string) {
        return CAVLCReader.readUEtrace(bits, string);
    };
    constructor.readZeroBitCount = function(bits, message) {
        var count = 0;
         while (bits.read1Bit() == 0 && count < 32)
            count++;
        if (Debug.debug) 
            Debug.trace(message, String.valueOf(count));
        return count;
    };
    constructor.moreRBSPData = function(bits) {
        return !(bits.remaining() < 32 && bits.checkNBit(1) == 1 && (bits.checkNBit(24) << 9) == 0);
    };
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var PS = function(sr, numTimeSlotsRate) {
    this.border_position = new Int32Array(PSConstants.MAX_PS_ENVELOPES + 1);
    this.iid_dt = new Int8Array(PSConstants.MAX_PS_ENVELOPES);
    this.icc_dt = new Int8Array(PSConstants.MAX_PS_ENVELOPES);
    this.ipd_dt = new Int8Array(PSConstants.MAX_PS_ENVELOPES);
    this.opd_dt = new Int8Array(PSConstants.MAX_PS_ENVELOPES);
    this.iid_index_prev = new Int32Array(34);
    this.icc_index_prev = new Int32Array(34);
    this.ipd_index_prev = new Int32Array(17);
    this.opd_index_prev = new Int32Array(17);
    this.iid_index = Array.apply(null, Array(PSConstants.MAX_PS_ENVELOPES)).map(function() {
        return new Int32Array(34);
    });
    this.icc_index = Array.apply(null, Array(PSConstants.MAX_PS_ENVELOPES)).map(function() {
        return new Int32Array(34);
    });
    this.ipd_index = Array.apply(null, Array(PSConstants.MAX_PS_ENVELOPES)).map(function() {
        return new Int32Array(17);
    });
    this.opd_index = Array.apply(null, Array(PSConstants.MAX_PS_ENVELOPES)).map(function() {
        return new Int32Array(17);
    });
    this.ipd_index_1 = new Int32Array(17);
    this.opd_index_1 = new Int32Array(17);
    this.ipd_index_2 = new Int32Array(17);
    this.opd_index_2 = new Int32Array(17);
    this.delay_buf_index_ser = new Int32Array(PSConstants.NO_ALLPASS_LINKS);
    this.num_sample_delay_ser = new Int32Array(PSConstants.NO_ALLPASS_LINKS);
    this.delay_D = new Int32Array(64);
    this.delay_buf_index_delay = new Int32Array(64);
    this.delay_Qmf = Array.apply(null, Array(14)).map(function() {
        return Array.apply(null, Array(64)).map(function() {
            return new Float32Array(2);
        });
    });
    this.delay_SubQmf = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(32)).map(function() {
            return new Float32Array(2);
        });
    });
    this.delay_Qmf_ser = Array.apply(null, Array(PSConstants.NO_ALLPASS_LINKS)).map(function() {
        return Array.apply(null, Array(5)).map(function() {
            return Array.apply(null, Array(64)).map(function() {
                return new Float32Array(2);
            });
        });
    });
    this.delay_SubQmf_ser = Array.apply(null, Array(PSConstants.NO_ALLPASS_LINKS)).map(function() {
        return Array.apply(null, Array(5)).map(function() {
            return Array.apply(null, Array(32)).map(function() {
                return new Float32Array(2);
            });
        });
    });
    this.P_PeakDecayNrg = new Float32Array(34);
    this.P_prev = new Float32Array(34);
    this.P_SmoothPeakDecayDiffNrg_prev = new Float32Array(34);
    this.h11_prev = Array.apply(null, Array(50)).map(function() {
        return new Float32Array(2);
    });
    this.h12_prev = Array.apply(null, Array(50)).map(function() {
        return new Float32Array(2);
    });
    this.h21_prev = Array.apply(null, Array(50)).map(function() {
        return new Float32Array(2);
    });
    this.h22_prev = Array.apply(null, Array(50)).map(function() {
        return new Float32Array(2);
    });
    this.ipd_prev = Array.apply(null, Array(20)).map(function() {
        return Array.apply(null, Array(2)).map(function() {
            return new Float32Array(2);
        });
    });
    this.opd_prev = Array.apply(null, Array(20)).map(function() {
        return Array.apply(null, Array(2)).map(function() {
            return new Float32Array(2);
        });
    });
    var i;
    var short_delay_band;
    this.hyb = new PSFilterbank(numTimeSlotsRate);
    this.numTimeSlotsRate = numTimeSlotsRate;
    this.ps_data_available = 0;
    this.saved_delay = 0;
    for (i = 0; i < 64; i++) {
        this.delay_buf_index_delay[i] = 0;
    }
    for (i = 0; i < PSConstants.NO_ALLPASS_LINKS; i++) {
        this.delay_buf_index_ser[i] = 0;
        this.num_sample_delay_ser[i] = PSTables.delay_length_d[i];
    }
    short_delay_band = 35;
    this.nr_allpass_bands = 22;
    this.alpha_decay = 0.7659283;
    this.alpha_smooth = 0.25;
    for (i = 0; i < short_delay_band; i++) {
        this.delay_D[i] = 14;
    }
    for (i = short_delay_band; i < 64; i++) {
        this.delay_D[i] = 1;
    }
    for (i = 0; i < 50; i++) {
        this.h11_prev[i][0] = 1;
        this.h12_prev[i][1] = 1;
        this.h11_prev[i][0] = 1;
        this.h12_prev[i][1] = 1;
    }
    this.phase_hist = 0;
    for (i = 0; i < 20; i++) {
        this.ipd_prev[i][0][0] = 0;
        this.ipd_prev[i][0][1] = 0;
        this.ipd_prev[i][1][0] = 0;
        this.ipd_prev[i][1][1] = 0;
        this.opd_prev[i][0][0] = 0;
        this.opd_prev[i][0][1] = 0;
        this.opd_prev[i][1][0] = 0;
        this.opd_prev[i][1][1] = 0;
    }
};
PS = stjs.extend(PS, null, [PSConstants, PSTables, PSHuffmanTables], function(constructor, prototype) {
    prototype.enable_iid = false;
    prototype.enable_icc = false;
    prototype.enable_ext = false;
    prototype.iid_mode = 0;
    prototype.icc_mode = 0;
    prototype.nr_iid_par = 0;
    prototype.nr_ipdopd_par = 0;
    prototype.nr_icc_par = 0;
    prototype.frame_class = 0;
    prototype.num_env = 0;
    prototype.border_position = null;
    prototype.iid_dt = null;
    prototype.icc_dt = null;
    prototype.enable_ipdopd = false;
    prototype.ipd_mode = 0;
    prototype.ipd_dt = null;
    prototype.opd_dt = null;
    prototype.iid_index_prev = null;
    prototype.icc_index_prev = null;
    prototype.ipd_index_prev = null;
    prototype.opd_index_prev = null;
    prototype.iid_index = null;
    prototype.icc_index = null;
    prototype.ipd_index = null;
    prototype.opd_index = null;
    prototype.ipd_index_1 = null;
    prototype.opd_index_1 = null;
    prototype.ipd_index_2 = null;
    prototype.opd_index_2 = null;
    prototype.ps_data_available = 0;
    prototype.header_read = false;
    prototype.hyb = null;
    prototype.use34hybrid_bands = false;
    prototype.numTimeSlotsRate = 0;
    prototype.num_groups = 0;
    prototype.num_hybrid_groups = 0;
    prototype.nr_par_bands = 0;
    prototype.nr_allpass_bands = 0;
    prototype.decay_cutoff = 0;
    prototype.group_border = null;
    prototype.map_group2bk = null;
    prototype.saved_delay = 0;
    prototype.delay_buf_index_ser = null;
    prototype.num_sample_delay_ser = null;
    prototype.delay_D = null;
    prototype.delay_buf_index_delay = null;
    prototype.delay_Qmf = null;
    prototype.delay_SubQmf = null;
    prototype.delay_Qmf_ser = null;
    prototype.delay_SubQmf_ser = null;
    prototype.alpha_decay = 0.0;
    prototype.alpha_smooth = 0.0;
    prototype.P_PeakDecayNrg = null;
    prototype.P_prev = null;
    prototype.P_SmoothPeakDecayDiffNrg_prev = null;
    prototype.h11_prev = null;
    prototype.h12_prev = null;
    prototype.h21_prev = null;
    prototype.h22_prev = null;
    prototype.phase_hist = 0;
    prototype.ipd_prev = null;
    prototype.opd_prev = null;
    prototype.decode = function(ld) {
        var tmp, n;
        var bits = ld.getPosition();
        if (ld.readBool()) {
            this.header_read = true;
            this.use34hybrid_bands = false;
            this.enable_iid = ld.readBool();
            if (this.enable_iid) {
                this.iid_mode = ld.readBits(3);
                this.nr_iid_par = PSTables.nr_iid_par_tab[this.iid_mode];
                this.nr_ipdopd_par = PSTables.nr_ipdopd_par_tab[this.iid_mode];
                if (this.iid_mode == 2 || this.iid_mode == 5) 
                    this.use34hybrid_bands = true;
                this.ipd_mode = this.iid_mode;
            }
            this.enable_icc = ld.readBool();
            if (this.enable_icc) {
                this.icc_mode = ld.readBits(3);
                this.nr_icc_par = PSTables.nr_icc_par_tab[this.icc_mode];
                if (this.icc_mode == 2 || this.icc_mode == 5) 
                    this.use34hybrid_bands = true;
            }
            this.enable_ext = ld.readBool();
        }
        if (this.header_read == false) {
            this.ps_data_available = 0;
            return 1;
        }
        this.frame_class = ld.readBit();
        tmp = ld.readBits(2);
        this.num_env = PSTables.num_env_tab[this.frame_class][tmp];
        if (this.frame_class != 0) {
            for (n = 1; n < this.num_env + 1; n++) {
                this.border_position[n] = ld.readBits(5) + 1;
            }
        }
        if (this.enable_iid) {
            for (n = 0; n < this.num_env; n++) {
                this.iid_dt[n] = ld.readBool();
                if (this.iid_mode < 3) {
                    this.huff_data(ld, this.iid_dt[n], this.nr_iid_par, PSHuffmanTables.t_huff_iid_def, PSHuffmanTables.f_huff_iid_def, this.iid_index[n]);
                } else {
                    this.huff_data(ld, this.iid_dt[n], this.nr_iid_par, PSHuffmanTables.t_huff_iid_fine, PSHuffmanTables.f_huff_iid_fine, this.iid_index[n]);
                }
            }
        }
        if (this.enable_icc) {
            for (n = 0; n < this.num_env; n++) {
                this.icc_dt[n] = ld.readBool();
                this.huff_data(ld, this.icc_dt[n], this.nr_icc_par, PSHuffmanTables.t_huff_icc, PSHuffmanTables.f_huff_icc, this.icc_index[n]);
            }
        }
        if (this.enable_ext) {
            var num_bits_left;
            var cnt = ld.readBits(4);
            if (cnt == 15) {
                cnt += ld.readBits(8);
            }
            num_bits_left = 8 * cnt;
             while (num_bits_left > 7){
                var ps_extension_id = ld.readBits(2);
                num_bits_left -= 2;
                num_bits_left -= this.ps_extension(ld, ps_extension_id, num_bits_left);
            }
            ld.skipBits(num_bits_left);
        }
        var bits2 = (((ld.getPosition() - bits)) | 0);
        this.ps_data_available = 1;
        return bits2;
    };
    prototype.ps_extension = function(ld, ps_extension_id, num_bits_left) {
        var n;
        var bits = ld.getPosition();
        if (ps_extension_id == 0) {
            this.enable_ipdopd = ld.readBool();
            if (this.enable_ipdopd) {
                for (n = 0; n < this.num_env; n++) {
                    this.ipd_dt[n] = ld.readBool();
                    this.huff_data(ld, this.ipd_dt[n], this.nr_ipdopd_par, PSHuffmanTables.t_huff_ipd, PSHuffmanTables.f_huff_ipd, this.ipd_index[n]);
                    this.opd_dt[n] = ld.readBool();
                    this.huff_data(ld, this.opd_dt[n], this.nr_ipdopd_par, PSHuffmanTables.t_huff_opd, PSHuffmanTables.f_huff_opd, this.opd_index[n]);
                }
            }
            ld.readBit();
        }
        var bits2 = (((ld.getPosition() - bits)) | 0);
        return bits2;
    };
    prototype.huff_data = function(ld, dt, nr_par, t_huff, f_huff, par) {
        var n;
        if (dt) {
            for (n = 0; n < nr_par; n++) {
                par[n] = this.ps_huff_dec(ld, t_huff);
            }
        } else {
            par[0] = this.ps_huff_dec(ld, f_huff);
            for (n = 1; n < nr_par; n++) {
                par[n] = this.ps_huff_dec(ld, f_huff);
            }
        }
    };
    prototype.ps_huff_dec = function(ld, t_huff) {
        var bit;
        var index = 0;
         while (index >= 0){
            bit = ld.readBit();
            index = t_huff[index][bit];
        }
        return index + 31;
    };
    prototype.delta_clip = function(i, min, max) {
        if (i < min) 
            return min;
         else if (i > max) 
            return max;
         else 
            return i;
    };
    prototype.delta_decode = function(enable, index, index_prev, dt_flag, nr_par, stride, min_index, max_index) {
        var i;
        if (enable) {
            if (!dt_flag) {
                index[0] = 0 + index[0];
                index[0] = this.delta_clip(index[0], min_index, max_index);
                for (i = 1; i < nr_par; i++) {
                    index[i] = index[i - 1] + index[i];
                    index[i] = this.delta_clip(index[i], min_index, max_index);
                }
            } else {
                for (i = 0; i < nr_par; i++) {
                    index[i] = index_prev[i * stride] + index[i];
                    index[i] = this.delta_clip(index[i], min_index, max_index);
                }
            }
        } else {
            for (i = 0; i < nr_par; i++) {
                index[i] = 0;
            }
        }
        if (stride == 2) {
            for (i = (nr_par << 1) - 1; i > 0; i--) {
                index[i] = index[i >> 1];
            }
        }
    };
    prototype.delta_modulo_decode = function(enable, index, index_prev, dt_flag, nr_par, stride, and_modulo) {
        var i;
        if (enable) {
            if (!dt_flag) {
                index[0] = 0 + index[0];
                index[0] &= and_modulo;
                for (i = 1; i < nr_par; i++) {
                    index[i] = index[i - 1] + index[i];
                    index[i] &= and_modulo;
                }
            } else {
                for (i = 0; i < nr_par; i++) {
                    index[i] = index_prev[i * stride] + index[i];
                    index[i] &= and_modulo;
                }
            }
        } else {
            for (i = 0; i < nr_par; i++) {
                index[i] = 0;
            }
        }
        if (stride == 2) {
            index[0] = 0;
            for (i = (nr_par << 1) - 1; i > 0; i--) {
                index[i] = index[i >> 1];
            }
        }
    };
    prototype.map20indexto34 = function(index, bins) {
        index[1] = stjs.trunc((index[0] + index[1]) / 2);
        index[2] = index[1];
        index[3] = index[2];
        index[4] = stjs.trunc((index[2] + index[3]) / 2);
        index[5] = index[3];
        index[6] = index[4];
        index[7] = index[4];
        index[8] = index[5];
        index[9] = index[5];
        index[10] = index[6];
        index[11] = index[7];
        index[12] = index[8];
        index[13] = index[8];
        index[14] = index[9];
        index[15] = index[9];
        index[16] = index[10];
        if (bins == 34) {
            index[17] = index[11];
            index[18] = index[12];
            index[19] = index[13];
            index[20] = index[14];
            index[21] = index[14];
            index[22] = index[15];
            index[23] = index[15];
            index[24] = index[16];
            index[25] = index[16];
            index[26] = index[17];
            index[27] = index[17];
            index[28] = index[18];
            index[29] = index[18];
            index[30] = index[18];
            index[31] = index[18];
            index[32] = index[19];
            index[33] = index[19];
        }
    };
    prototype.ps_data_decode = function() {
        var env, bin;
        if (this.ps_data_available == 0) {
            this.num_env = 0;
        }
        for (env = 0; env < this.num_env; env++) {
            var iid_index_prev;
            var icc_index_prev;
            var ipd_index_prev;
            var opd_index_prev;
            var num_iid_steps = (this.iid_mode < 3) ? 7 : 15;
            if (env == 0) {
                iid_index_prev = this.iid_index_prev;
                icc_index_prev = this.icc_index_prev;
                ipd_index_prev = this.ipd_index_prev;
                opd_index_prev = this.opd_index_prev;
            } else {
                iid_index_prev = this.iid_index[env - 1];
                icc_index_prev = this.icc_index[env - 1];
                ipd_index_prev = this.ipd_index[env - 1];
                opd_index_prev = this.opd_index[env - 1];
            }
            this.delta_decode(this.enable_iid, this.iid_index[env], iid_index_prev, this.iid_dt[env], this.nr_iid_par, (this.iid_mode == 0 || this.iid_mode == 3) ? 2 : 1, -num_iid_steps, num_iid_steps);
            this.delta_decode(this.enable_icc, this.icc_index[env], icc_index_prev, this.icc_dt[env], this.nr_icc_par, (this.icc_mode == 0 || this.icc_mode == 3) ? 2 : 1, 0, 7);
            this.delta_modulo_decode(this.enable_ipdopd, this.ipd_index[env], ipd_index_prev, this.ipd_dt[env], this.nr_ipdopd_par, 1, 7);
            this.delta_modulo_decode(this.enable_ipdopd, this.opd_index[env], opd_index_prev, this.opd_dt[env], this.nr_ipdopd_par, 1, 7);
        }
        if (this.num_env == 0) {
            this.num_env = 1;
            if (this.enable_iid) {
                for (bin = 0; bin < 34; bin++) {
                    this.iid_index[0][bin] = this.iid_index_prev[bin];
                }
            } else {
                for (bin = 0; bin < 34; bin++) {
                    this.iid_index[0][bin] = 0;
                }
            }
            if (this.enable_icc) {
                for (bin = 0; bin < 34; bin++) {
                    this.icc_index[0][bin] = this.icc_index_prev[bin];
                }
            } else {
                for (bin = 0; bin < 34; bin++) {
                    this.icc_index[0][bin] = 0;
                }
            }
            if (this.enable_ipdopd) {
                for (bin = 0; bin < 17; bin++) {
                    this.ipd_index[0][bin] = this.ipd_index_prev[bin];
                    this.opd_index[0][bin] = this.opd_index_prev[bin];
                }
            } else {
                for (bin = 0; bin < 17; bin++) {
                    this.ipd_index[0][bin] = 0;
                    this.opd_index[0][bin] = 0;
                }
            }
        }
        for (bin = 0; bin < 34; bin++) {
            this.iid_index_prev[bin] = this.iid_index[this.num_env - 1][bin];
        }
        for (bin = 0; bin < 34; bin++) {
            this.icc_index_prev[bin] = this.icc_index[this.num_env - 1][bin];
        }
        for (bin = 0; bin < 17; bin++) {
            this.ipd_index_prev[bin] = this.ipd_index[this.num_env - 1][bin];
            this.opd_index_prev[bin] = this.opd_index[this.num_env - 1][bin];
        }
        this.ps_data_available = 0;
        if (this.frame_class == 0) {
            this.border_position[0] = 0;
            for (env = 1; env < this.num_env; env++) {
                this.border_position[env] = stjs.trunc((env * this.numTimeSlotsRate) / this.num_env);
            }
            this.border_position[this.num_env] = this.numTimeSlotsRate;
        } else {
            this.border_position[0] = 0;
            if (this.border_position[this.num_env] < this.numTimeSlotsRate) {
                for (bin = 0; bin < 34; bin++) {
                    this.iid_index[this.num_env][bin] = this.iid_index[this.num_env - 1][bin];
                    this.icc_index[this.num_env][bin] = this.icc_index[this.num_env - 1][bin];
                }
                for (bin = 0; bin < 17; bin++) {
                    this.ipd_index[this.num_env][bin] = this.ipd_index[this.num_env - 1][bin];
                    this.opd_index[this.num_env][bin] = this.opd_index[this.num_env - 1][bin];
                }
                this.num_env++;
                this.border_position[this.num_env] = this.numTimeSlotsRate;
            }
            for (env = 1; env < this.num_env; env++) {
                var thr = this.numTimeSlotsRate - (this.num_env - env);
                if (this.border_position[env] > thr) {
                    this.border_position[env] = thr;
                } else {
                    thr = this.border_position[env - 1] + 1;
                    if (this.border_position[env] < thr) {
                        this.border_position[env] = thr;
                    }
                }
            }
        }
        if (this.use34hybrid_bands) {
            for (env = 0; env < this.num_env; env++) {
                if (this.iid_mode != 2 && this.iid_mode != 5) 
                    this.map20indexto34(this.iid_index[env], 34);
                if (this.icc_mode != 2 && this.icc_mode != 5) 
                    this.map20indexto34(this.icc_index[env], 34);
                if (this.ipd_mode != 2 && this.ipd_mode != 5) {
                    this.map20indexto34(this.ipd_index[env], 17);
                    this.map20indexto34(this.opd_index[env], 17);
                }
            }
        }
    };
    prototype.ps_decorrelate = function(X_left, X_right, X_hybrid_left, X_hybrid_right) {
        var gr, n, m, bk;
        var temp_delay = 0;
        var sb, maxsb;
        var temp_delay_ser = new Int32Array(PSConstants.NO_ALLPASS_LINKS);
        var P_SmoothPeakDecayDiffNrg, nrg;
        var P = Array.apply(null, Array(32)).map(function() {
            return new Float32Array(34);
        });
        var G_TransientRatio = Array.apply(null, Array(32)).map(function() {
            return new Float32Array(34);
        });
        var inputLeft = new Float32Array(2);
        var Phi_Fract_SubQmf;
        if (this.use34hybrid_bands) {
            Phi_Fract_SubQmf = PSTables.Phi_Fract_SubQmf34;
        } else {
            Phi_Fract_SubQmf = PSTables.Phi_Fract_SubQmf20;
        }
        for (n = 0; n < 32; n++) {
            for (bk = 0; bk < 34; bk++) {
                P[n][bk] = 0;
            }
        }
        for (gr = 0; gr < this.num_groups; gr++) {
            bk = (~PSConstants.NEGATE_IPD_MASK) & this.map_group2bk[gr];
            maxsb = (gr < this.num_hybrid_groups) ? this.group_border[gr] + 1 : this.group_border[gr + 1];
            for (sb = this.group_border[gr]; sb < maxsb; sb++) {
                for (n = this.border_position[0]; n < this.border_position[this.num_env]; n++) {
                    if (gr < this.num_hybrid_groups) {
                        inputLeft[0] = X_hybrid_left[n][sb][0];
                        inputLeft[1] = X_hybrid_left[n][sb][1];
                    } else {
                        inputLeft[0] = X_left[n][sb][0];
                        inputLeft[1] = X_left[n][sb][1];
                    }
                    P[n][bk] += (inputLeft[0] * inputLeft[0]) + (inputLeft[1] * inputLeft[1]);
                }
            }
        }
        for (bk = 0; bk < this.nr_par_bands; bk++) {
            for (n = this.border_position[0]; n < this.border_position[this.num_env]; n++) {
                var gamma = 1.5;
                this.P_PeakDecayNrg[bk] = (this.P_PeakDecayNrg[bk] * this.alpha_decay);
                if (this.P_PeakDecayNrg[bk] < P[n][bk]) 
                    this.P_PeakDecayNrg[bk] = P[n][bk];
                P_SmoothPeakDecayDiffNrg = this.P_SmoothPeakDecayDiffNrg_prev[bk];
                P_SmoothPeakDecayDiffNrg += ((this.P_PeakDecayNrg[bk] - P[n][bk] - this.P_SmoothPeakDecayDiffNrg_prev[bk]) * this.alpha_smooth);
                this.P_SmoothPeakDecayDiffNrg_prev[bk] = P_SmoothPeakDecayDiffNrg;
                nrg = this.P_prev[bk];
                nrg += ((P[n][bk] - this.P_prev[bk]) * this.alpha_smooth);
                this.P_prev[bk] = nrg;
                if ((P_SmoothPeakDecayDiffNrg * gamma) <= nrg) {
                    G_TransientRatio[n][bk] = 1.0;
                } else {
                    G_TransientRatio[n][bk] = (nrg / (P_SmoothPeakDecayDiffNrg * gamma));
                }
            }
        }
        for (gr = 0; gr < this.num_groups; gr++) {
            if (gr < this.num_hybrid_groups) 
                maxsb = this.group_border[gr] + 1;
             else 
                maxsb = this.group_border[gr + 1];
            for (sb = this.group_border[gr]; sb < maxsb; sb++) {
                var g_DecaySlope;
                var g_DecaySlope_filt = new Float32Array(PSConstants.NO_ALLPASS_LINKS);
                if (gr < this.num_hybrid_groups || sb <= this.decay_cutoff) {
                    g_DecaySlope = 1.0;
                } else {
                    var decay = this.decay_cutoff - sb;
                    if (decay <= -20) {
                        g_DecaySlope = 0;
                    } else {
                        g_DecaySlope = 1.0 + PSConstants.DECAY_SLOPE * decay;
                    }
                }
                for (m = 0; m < PSConstants.NO_ALLPASS_LINKS; m++) {
                    g_DecaySlope_filt[m] = g_DecaySlope * PSTables.filter_a[m];
                }
                temp_delay = this.saved_delay;
                for (n = 0; n < PSConstants.NO_ALLPASS_LINKS; n++) {
                    temp_delay_ser[n] = this.delay_buf_index_ser[n];
                }
                for (n = this.border_position[0]; n < this.border_position[this.num_env]; n++) {
                    var tmp = new Float32Array(2), tmp0 = new Float32Array(2), R0 = new Float32Array(2);
                    if (gr < this.num_hybrid_groups) {
                        inputLeft[0] = X_hybrid_left[n][sb][0];
                        inputLeft[1] = X_hybrid_left[n][sb][1];
                    } else {
                        inputLeft[0] = X_left[n][sb][0];
                        inputLeft[1] = X_left[n][sb][1];
                    }
                    if (sb > this.nr_allpass_bands && gr >= this.num_hybrid_groups) {
                        tmp[0] = this.delay_Qmf[this.delay_buf_index_delay[sb]][sb][0];
                        tmp[1] = this.delay_Qmf[this.delay_buf_index_delay[sb]][sb][1];
                        R0[0] = tmp[0];
                        R0[1] = tmp[1];
                        this.delay_Qmf[this.delay_buf_index_delay[sb]][sb][0] = inputLeft[0];
                        this.delay_Qmf[this.delay_buf_index_delay[sb]][sb][1] = inputLeft[1];
                    } else {
                        var Phi_Fract = new Float32Array(2);
                        if (gr < this.num_hybrid_groups) {
                            tmp0[0] = this.delay_SubQmf[temp_delay][sb][0];
                            tmp0[1] = this.delay_SubQmf[temp_delay][sb][1];
                            this.delay_SubQmf[temp_delay][sb][0] = inputLeft[0];
                            this.delay_SubQmf[temp_delay][sb][1] = inputLeft[1];
                            Phi_Fract[0] = Phi_Fract_SubQmf[sb][0];
                            Phi_Fract[1] = Phi_Fract_SubQmf[sb][1];
                        } else {
                            tmp0[0] = this.delay_Qmf[temp_delay][sb][0];
                            tmp0[1] = this.delay_Qmf[temp_delay][sb][1];
                            this.delay_Qmf[temp_delay][sb][0] = inputLeft[0];
                            this.delay_Qmf[temp_delay][sb][1] = inputLeft[1];
                            Phi_Fract[0] = PSTables.Phi_Fract_Qmf[sb][0];
                            Phi_Fract[1] = PSTables.Phi_Fract_Qmf[sb][1];
                        }
                        tmp[0] = (tmp[0] * Phi_Fract[0]) + (tmp0[1] * Phi_Fract[1]);
                        tmp[1] = (tmp0[1] * Phi_Fract[0]) - (tmp0[0] * Phi_Fract[1]);
                        R0[0] = tmp[0];
                        R0[1] = tmp[1];
                        for (m = 0; m < PSConstants.NO_ALLPASS_LINKS; m++) {
                            var Q_Fract_allpass = new Float32Array(2), tmp2 = new Float32Array(2);
                            if (gr < this.num_hybrid_groups) {
                                tmp0[0] = this.delay_SubQmf_ser[m][temp_delay_ser[m]][sb][0];
                                tmp0[1] = this.delay_SubQmf_ser[m][temp_delay_ser[m]][sb][1];
                                if (this.use34hybrid_bands) {
                                    Q_Fract_allpass[0] = PSTables.Q_Fract_allpass_SubQmf34[sb][m][0];
                                    Q_Fract_allpass[1] = PSTables.Q_Fract_allpass_SubQmf34[sb][m][1];
                                } else {
                                    Q_Fract_allpass[0] = PSTables.Q_Fract_allpass_SubQmf20[sb][m][0];
                                    Q_Fract_allpass[1] = PSTables.Q_Fract_allpass_SubQmf20[sb][m][1];
                                }
                            } else {
                                tmp0[0] = this.delay_Qmf_ser[m][temp_delay_ser[m]][sb][0];
                                tmp0[1] = this.delay_Qmf_ser[m][temp_delay_ser[m]][sb][1];
                                Q_Fract_allpass[0] = PSTables.Q_Fract_allpass_Qmf[sb][m][0];
                                Q_Fract_allpass[1] = PSTables.Q_Fract_allpass_Qmf[sb][m][1];
                            }
                            tmp[0] = (tmp0[0] * Q_Fract_allpass[0]) + (tmp0[1] * Q_Fract_allpass[1]);
                            tmp[1] = (tmp0[1] * Q_Fract_allpass[0]) - (tmp0[0] * Q_Fract_allpass[1]);
                            tmp[0] += -(g_DecaySlope_filt[m] * R0[0]);
                            tmp[1] += -(g_DecaySlope_filt[m] * R0[1]);
                            tmp2[0] = R0[0] + (g_DecaySlope_filt[m] * tmp[0]);
                            tmp2[1] = R0[1] + (g_DecaySlope_filt[m] * tmp[1]);
                            if (gr < this.num_hybrid_groups) {
                                this.delay_SubQmf_ser[m][temp_delay_ser[m]][sb][0] = tmp2[0];
                                this.delay_SubQmf_ser[m][temp_delay_ser[m]][sb][1] = tmp2[1];
                            } else {
                                this.delay_Qmf_ser[m][temp_delay_ser[m]][sb][0] = tmp2[0];
                                this.delay_Qmf_ser[m][temp_delay_ser[m]][sb][1] = tmp2[1];
                            }
                            R0[0] = tmp[0];
                            R0[1] = tmp[1];
                        }
                    }
                    bk = (~PSConstants.NEGATE_IPD_MASK) & this.map_group2bk[gr];
                    R0[0] = (G_TransientRatio[n][bk] * R0[0]);
                    R0[1] = (G_TransientRatio[n][bk] * R0[1]);
                    if (gr < this.num_hybrid_groups) {
                        X_hybrid_right[n][sb][0] = R0[0];
                        X_hybrid_right[n][sb][1] = R0[1];
                    } else {
                        X_right[n][sb][0] = R0[0];
                        X_right[n][sb][1] = R0[1];
                    }
                    if (++temp_delay >= 2) {
                        temp_delay = 0;
                    }
                    if (sb > this.nr_allpass_bands && gr >= this.num_hybrid_groups) {
                        if (++this.delay_buf_index_delay[sb] >= this.delay_D[sb]) {
                            this.delay_buf_index_delay[sb] = 0;
                        }
                    }
                    for (m = 0; m < PSConstants.NO_ALLPASS_LINKS; m++) {
                        if (++temp_delay_ser[m] >= this.num_sample_delay_ser[m]) {
                            temp_delay_ser[m] = 0;
                        }
                    }
                }
            }
        }
        this.saved_delay = temp_delay;
        for (m = 0; m < PSConstants.NO_ALLPASS_LINKS; m++) {
            this.delay_buf_index_ser[m] = temp_delay_ser[m];
        }
    };
    prototype.magnitude_c = function(c) {
        return Math.sqrt(c[0] * c[0] + c[1] * c[1]);
    };
    prototype.ps_mix_phase = function(X_left, X_right, X_hybrid_left, X_hybrid_right) {
        var n;
        var gr;
        var bk = 0;
        var sb, maxsb;
        var env;
        var nr_ipdopd_par;
        var h11 = new Float32Array(2), h12 = new Float32Array(2), h21 = new Float32Array(2), h22 = new Float32Array(2);
        var H11 = new Float32Array(2), H12 = new Float32Array(2), H21 = new Float32Array(2), H22 = new Float32Array(2);
        var deltaH11 = new Float32Array(2), deltaH12 = new Float32Array(2), deltaH21 = new Float32Array(2), deltaH22 = new Float32Array(2);
        var tempLeft = new Float32Array(2);
        var tempRight = new Float32Array(2);
        var phaseLeft = new Float32Array(2);
        var phaseRight = new Float32Array(2);
        var L;
        var sf_iid;
        var no_iid_steps;
        if (this.iid_mode >= 3) {
            no_iid_steps = 15;
            sf_iid = PSTables.sf_iid_fine;
        } else {
            no_iid_steps = 7;
            sf_iid = PSTables.sf_iid_normal;
        }
        if (this.ipd_mode == 0 || this.ipd_mode == 3) {
            nr_ipdopd_par = 11;
        } else {
            nr_ipdopd_par = this.nr_ipdopd_par;
        }
        for (gr = 0; gr < this.num_groups; gr++) {
            bk = (~PSConstants.NEGATE_IPD_MASK) & this.map_group2bk[gr];
            maxsb = (gr < this.num_hybrid_groups) ? this.group_border[gr] + 1 : this.group_border[gr + 1];
            for (env = 0; env < this.num_env; env++) {
                if (this.icc_mode < 3) {
                    var c_1, c_2;
                    var cosa, sina;
                    var cosb, sinb;
                    var ab1, ab2;
                    var ab3, ab4;
                    c_1 = sf_iid[no_iid_steps + this.iid_index[env][bk]];
                    c_2 = sf_iid[no_iid_steps - this.iid_index[env][bk]];
                    cosa = PSTables.cos_alphas[this.icc_index[env][bk]];
                    sina = PSTables.sin_alphas[this.icc_index[env][bk]];
                    if (this.iid_mode >= 3) {
                        if (this.iid_index[env][bk] < 0) {
                            cosb = PSTables.cos_betas_fine[-this.iid_index[env][bk]][this.icc_index[env][bk]];
                            sinb = -PSTables.sin_betas_fine[-this.iid_index[env][bk]][this.icc_index[env][bk]];
                        } else {
                            cosb = PSTables.cos_betas_fine[this.iid_index[env][bk]][this.icc_index[env][bk]];
                            sinb = PSTables.sin_betas_fine[this.iid_index[env][bk]][this.icc_index[env][bk]];
                        }
                    } else {
                        if (this.iid_index[env][bk] < 0) {
                            cosb = PSTables.cos_betas_normal[-this.iid_index[env][bk]][this.icc_index[env][bk]];
                            sinb = -PSTables.sin_betas_normal[-this.iid_index[env][bk]][this.icc_index[env][bk]];
                        } else {
                            cosb = PSTables.cos_betas_normal[this.iid_index[env][bk]][this.icc_index[env][bk]];
                            sinb = PSTables.sin_betas_normal[this.iid_index[env][bk]][this.icc_index[env][bk]];
                        }
                    }
                    ab1 = (cosb * cosa);
                    ab2 = (sinb * sina);
                    ab3 = (sinb * cosa);
                    ab4 = (cosb * sina);
                    h11[0] = (c_2 * (ab1 - ab2));
                    h12[0] = (c_1 * (ab1 + ab2));
                    h21[0] = (c_2 * (ab3 + ab4));
                    h22[0] = (c_1 * (ab3 - ab4));
                } else {
                    var sina, cosa;
                    var cosg, sing;
                    if (this.iid_mode >= 3) {
                        var abs_iid = Math.abs(this.iid_index[env][bk]);
                        cosa = PSTables.sincos_alphas_B_fine[no_iid_steps + this.iid_index[env][bk]][this.icc_index[env][bk]];
                        sina = PSTables.sincos_alphas_B_fine[30 - (no_iid_steps + this.iid_index[env][bk])][this.icc_index[env][bk]];
                        cosg = PSTables.cos_gammas_fine[abs_iid][this.icc_index[env][bk]];
                        sing = PSTables.sin_gammas_fine[abs_iid][this.icc_index[env][bk]];
                    } else {
                        var abs_iid = Math.abs(this.iid_index[env][bk]);
                        cosa = PSTables.sincos_alphas_B_normal[no_iid_steps + this.iid_index[env][bk]][this.icc_index[env][bk]];
                        sina = PSTables.sincos_alphas_B_normal[14 - (no_iid_steps + this.iid_index[env][bk])][this.icc_index[env][bk]];
                        cosg = PSTables.cos_gammas_normal[abs_iid][this.icc_index[env][bk]];
                        sing = PSTables.sin_gammas_normal[abs_iid][this.icc_index[env][bk]];
                    }
                    h11[0] = (PSConstants.COEF_SQRT2 * (cosa * cosg));
                    h12[0] = (PSConstants.COEF_SQRT2 * (sina * cosg));
                    h21[0] = (PSConstants.COEF_SQRT2 * (-cosa * sing));
                    h22[0] = (PSConstants.COEF_SQRT2 * (sina * sing));
                }
                if ((this.enable_ipdopd) && (bk < nr_ipdopd_par)) {
                    var xy, pq, xypq;
                    var i = this.phase_hist;
                    tempLeft[0] = (this.ipd_prev[bk][i][0] * 0.25);
                    tempLeft[1] = (this.ipd_prev[bk][i][1] * 0.25);
                    tempRight[0] = (this.opd_prev[bk][i][0] * 0.25);
                    tempRight[1] = (this.opd_prev[bk][i][1] * 0.25);
                    this.ipd_prev[bk][i][0] = PSTables.ipdopd_cos_tab[Math.abs(this.ipd_index[env][bk])];
                    this.ipd_prev[bk][i][1] = PSTables.ipdopd_sin_tab[Math.abs(this.ipd_index[env][bk])];
                    this.opd_prev[bk][i][0] = PSTables.ipdopd_cos_tab[Math.abs(this.opd_index[env][bk])];
                    this.opd_prev[bk][i][1] = PSTables.ipdopd_sin_tab[Math.abs(this.opd_index[env][bk])];
                    tempLeft[0] += this.ipd_prev[bk][i][0];
                    tempLeft[1] += this.ipd_prev[bk][i][1];
                    tempRight[0] += this.opd_prev[bk][i][0];
                    tempRight[1] += this.opd_prev[bk][i][1];
                    if (i == 0) {
                        i = 2;
                    }
                    i--;
                    tempLeft[0] += (this.ipd_prev[bk][i][0] * 0.5);
                    tempLeft[1] += (this.ipd_prev[bk][i][1] * 0.5);
                    tempRight[0] += (this.opd_prev[bk][i][0] * 0.5);
                    tempRight[1] += (this.opd_prev[bk][i][1] * 0.5);
                    xy = this.magnitude_c(tempRight);
                    pq = this.magnitude_c(tempLeft);
                    if (xy != 0) {
                        phaseLeft[0] = (tempRight[0] / xy);
                        phaseLeft[1] = (tempRight[1] / xy);
                    } else {
                        phaseLeft[0] = 0;
                        phaseLeft[1] = 0;
                    }
                    xypq = (xy * pq);
                    if (xypq != 0) {
                        var tmp1 = (tempRight[0] * tempLeft[0]) + (tempRight[1] * tempLeft[1]);
                        var tmp2 = (tempRight[1] * tempLeft[0]) - (tempRight[0] * tempLeft[1]);
                        phaseRight[0] = (tmp1 / xypq);
                        phaseRight[1] = (tmp2 / xypq);
                    } else {
                        phaseRight[0] = 0;
                        phaseRight[1] = 0;
                    }
                    h11[1] = (h11[0] * phaseLeft[1]);
                    h12[1] = (h12[0] * phaseRight[1]);
                    h21[1] = (h21[0] * phaseLeft[1]);
                    h22[1] = (h22[0] * phaseRight[1]);
                    h11[0] = (h11[0] * phaseLeft[0]);
                    h12[0] = (h12[0] * phaseRight[0]);
                    h21[0] = (h21[0] * phaseLeft[0]);
                    h22[0] = (h22[0] * phaseRight[0]);
                }
                L = (this.border_position[env + 1] - this.border_position[env]);
                deltaH11[0] = (h11[0] - this.h11_prev[gr][0]) / L;
                deltaH12[0] = (h12[0] - this.h12_prev[gr][0]) / L;
                deltaH21[0] = (h21[0] - this.h21_prev[gr][0]) / L;
                deltaH22[0] = (h22[0] - this.h22_prev[gr][0]) / L;
                H11[0] = this.h11_prev[gr][0];
                H12[0] = this.h12_prev[gr][0];
                H21[0] = this.h21_prev[gr][0];
                H22[0] = this.h22_prev[gr][0];
                this.h11_prev[gr][0] = h11[0];
                this.h12_prev[gr][0] = h12[0];
                this.h21_prev[gr][0] = h21[0];
                this.h22_prev[gr][0] = h22[0];
                if ((this.enable_ipdopd) && (bk < nr_ipdopd_par)) {
                    deltaH11[1] = (h11[1] - this.h11_prev[gr][1]) / L;
                    deltaH12[1] = (h12[1] - this.h12_prev[gr][1]) / L;
                    deltaH21[1] = (h21[1] - this.h21_prev[gr][1]) / L;
                    deltaH22[1] = (h22[1] - this.h22_prev[gr][1]) / L;
                    H11[1] = this.h11_prev[gr][1];
                    H12[1] = this.h12_prev[gr][1];
                    H21[1] = this.h21_prev[gr][1];
                    H22[1] = this.h22_prev[gr][1];
                    if ((PSConstants.NEGATE_IPD_MASK & this.map_group2bk[gr]) != 0) {
                        deltaH11[1] = -deltaH11[1];
                        deltaH12[1] = -deltaH12[1];
                        deltaH21[1] = -deltaH21[1];
                        deltaH22[1] = -deltaH22[1];
                        H11[1] = -H11[1];
                        H12[1] = -H12[1];
                        H21[1] = -H21[1];
                        H22[1] = -H22[1];
                    }
                    this.h11_prev[gr][1] = h11[1];
                    this.h12_prev[gr][1] = h12[1];
                    this.h21_prev[gr][1] = h21[1];
                    this.h22_prev[gr][1] = h22[1];
                }
                for (n = this.border_position[env]; n < this.border_position[env + 1]; n++) {
                    H11[0] += deltaH11[0];
                    H12[0] += deltaH12[0];
                    H21[0] += deltaH21[0];
                    H22[0] += deltaH22[0];
                    if ((this.enable_ipdopd) && (bk < nr_ipdopd_par)) {
                        H11[1] += deltaH11[1];
                        H12[1] += deltaH12[1];
                        H21[1] += deltaH21[1];
                        H22[1] += deltaH22[1];
                    }
                    for (sb = this.group_border[gr]; sb < maxsb; sb++) {
                        var inLeft = new Float32Array(2), inRight = new Float32Array(2);
                        if (gr < this.num_hybrid_groups) {
                            inLeft[0] = X_hybrid_left[n][sb][0];
                            inLeft[1] = X_hybrid_left[n][sb][1];
                            inRight[0] = X_hybrid_right[n][sb][0];
                            inRight[1] = X_hybrid_right[n][sb][1];
                        } else {
                            inLeft[0] = X_left[n][sb][0];
                            inLeft[1] = X_left[n][sb][1];
                            inRight[0] = X_right[n][sb][0];
                            inRight[1] = X_right[n][sb][1];
                        }
                        tempLeft[0] = (H11[0] * inLeft[0]) + (H21[0] * inRight[0]);
                        tempLeft[1] = (H11[0] * inLeft[1]) + (H21[0] * inRight[1]);
                        tempRight[0] = (H12[0] * inLeft[0]) + (H22[0] * inRight[0]);
                        tempRight[1] = (H12[0] * inLeft[1]) + (H22[0] * inRight[1]);
                        if ((this.enable_ipdopd) && (bk < nr_ipdopd_par)) {
                            tempLeft[0] -= (H11[1] * inLeft[1]) + (H21[1] * inRight[1]);
                            tempLeft[1] += (H11[1] * inLeft[0]) + (H21[1] * inRight[0]);
                            tempRight[0] -= (H12[1] * inLeft[1]) + (H22[1] * inRight[1]);
                            tempRight[1] += (H12[1] * inLeft[0]) + (H22[1] * inRight[0]);
                        }
                        if (gr < this.num_hybrid_groups) {
                            X_hybrid_left[n][sb][0] = tempLeft[0];
                            X_hybrid_left[n][sb][1] = tempLeft[1];
                            X_hybrid_right[n][sb][0] = tempRight[0];
                            X_hybrid_right[n][sb][1] = tempRight[1];
                        } else {
                            X_left[n][sb][0] = tempLeft[0];
                            X_left[n][sb][1] = tempLeft[1];
                            X_right[n][sb][0] = tempRight[0];
                            X_right[n][sb][1] = tempRight[1];
                        }
                    }
                }
                this.phase_hist++;
                if (this.phase_hist == 2) {
                    this.phase_hist = 0;
                }
            }
        }
    };
    prototype.process = function(X_left, X_right) {
        var X_hybrid_left = Array.apply(null, Array(32)).map(function() {
            return Array.apply(null, Array(32)).map(function() {
                return new Float32Array(2);
            });
        });
        var X_hybrid_right = Array.apply(null, Array(32)).map(function() {
            return Array.apply(null, Array(32)).map(function() {
                return new Float32Array(2);
            });
        });
        this.ps_data_decode();
        if (this.use34hybrid_bands) {
            this.group_border = PSTables.group_border34;
            this.map_group2bk = PSTables.map_group2bk34;
            this.num_groups = 32 + 18;
            this.num_hybrid_groups = 32;
            this.nr_par_bands = 34;
            this.decay_cutoff = 5;
        } else {
            this.group_border = PSTables.group_border20;
            this.map_group2bk = PSTables.map_group2bk20;
            this.num_groups = 10 + 12;
            this.num_hybrid_groups = 10;
            this.nr_par_bands = 20;
            this.decay_cutoff = 3;
        }
        this.hyb.hybrid_analysis(X_left, X_hybrid_left, this.use34hybrid_bands, this.numTimeSlotsRate);
        this.ps_decorrelate(X_left, X_right, X_hybrid_left, X_hybrid_right);
        this.ps_mix_phase(X_left, X_right, X_hybrid_left, X_hybrid_right);
        this.hyb.hybrid_synthesis(X_left, X_hybrid_left, this.use34hybrid_bands, this.numTimeSlotsRate);
        this.hyb.hybrid_synthesis(X_right, X_hybrid_right, this.use34hybrid_bands, this.numTimeSlotsRate);
        return 0;
    };
}, {border_position: "Int32Array", iid_dt: "Int8Array", icc_dt: "Int8Array", ipd_dt: "Int8Array", opd_dt: "Int8Array", iid_index_prev: "Int32Array", icc_index_prev: "Int32Array", ipd_index_prev: "Int32Array", opd_index_prev: "Int32Array", iid_index: "Array", icc_index: "Array", ipd_index: "Array", opd_index: "Array", ipd_index_1: "Int32Array", opd_index_1: "Int32Array", ipd_index_2: "Int32Array", opd_index_2: "Int32Array", hyb: "PSFilterbank", group_border: "Int32Array", map_group2bk: "Int32Array", delay_buf_index_ser: "Int32Array", num_sample_delay_ser: "Int32Array", delay_D: "Int32Array", delay_buf_index_delay: "Int32Array", delay_Qmf: "Array", delay_SubQmf: "Array", delay_Qmf_ser: "Array", delay_SubQmf_ser: "Array", P_PeakDecayNrg: "Float32Array", P_prev: "Float32Array", P_SmoothPeakDecayDiffNrg_prev: "Float32Array", h11_prev: "Array", h12_prev: "Array", h21_prev: "Array", h22_prev: "Array", ipd_prev: "Array", opd_prev: "Array", nr_iid_par_tab: "Int32Array", nr_icc_par_tab: "Int32Array", nr_ipdopd_par_tab: "Int32Array", num_env_tab: "Array", filter_a: "Float32Array", group_border20: "Int32Array", group_border34: "Int32Array", map_group2bk20: "Int32Array", map_group2bk34: "Int32Array", delay_length_d: "Int32Array", p8_13_20: "Float32Array", p2_13_20: "Float32Array", p12_13_34: "Float32Array", p8_13_34: "Float32Array", p4_13_34: "Float32Array", Phi_Fract_Qmf: "Array", Phi_Fract_SubQmf20: "Array", Phi_Fract_SubQmf34: "Array", Q_Fract_allpass_Qmf: "Array", Q_Fract_allpass_SubQmf20: "Array", Q_Fract_allpass_SubQmf34: "Array", cos_alphas: "Float32Array", sin_alphas: "Float32Array", cos_betas_normal: "Array", sin_betas_normal: "Array", cos_betas_fine: "Array", sin_betas_fine: "Array", sincos_alphas_B_normal: "Array", sincos_alphas_B_fine: "Array", cos_gammas_normal: "Array", cos_gammas_fine: "Array", sin_gammas_normal: "Array", sin_gammas_fine: "Array", sf_iid_normal: "Float32Array", sf_iid_fine: "Float32Array", ipdopd_cos_tab: "Float32Array", ipdopd_sin_tab: "Float32Array", f_huff_iid_def: "Array", t_huff_iid_def: "Array", f_huff_iid_fine: "Array", t_huff_iid_fine: "Array", f_huff_icc: "Array", t_huff_icc: "Array", f_huff_ipd: "Array", t_huff_ipd: "Array", f_huff_opd: "Array", t_huff_opd: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var NIOUtils = function() {};
NIOUtils = stjs.extend(NIOUtils, null, [], function(constructor, prototype) {
    constructor.search = function(buffer, n, param) {
        var result = buffer.duplicate();
        var step = 0, rem = buffer.position();
         while (buffer.hasRemaining()){
            var b = buffer.get();
            if (b == param[step]) {
                ++step;
                if (step == param.length) {
                    if (n == 0) {
                        buffer.setPosition(rem);
                        result.setLimit(buffer.position());
                        break;
                    }
                    n--;
                    step = 0;
                }
            } else {
                if (step != 0) {
                    step = 0;
                    ++rem;
                    buffer.setPosition(rem);
                } else 
                    rem = buffer.position();
            }
        }
        return result;
    };
    constructor.read = function(buffer, count) {
        var slice = buffer.duplicate();
        var limit = buffer.position() + count;
        slice.setLimit(limit);
        buffer.setPosition(limit);
        return slice;
    };
    constructor.fetchFromFile = function(file) {
        return NIOUtils.fetchFromFileL(file, ((file.length()) | 0));
    };
    constructor.fetchFromChannel = function(ch, size) {
        var buf = ByteBuffer.allocate(size);
        NIOUtils.readFromChannel(ch, buf);
        buf.flip();
        return buf;
    };
    constructor.fetchAllFromChannel = function(ch) {
        var buffers = new ArrayList();
        var buf;
        do {
            buf = NIOUtils.fetchFromChannel(ch, 1 << 20);
            buffers.add(buf);
        } while (buf.hasRemaining());
        return NIOUtils.combineBuffers(buffers);
    };
    /**
     *  Reads size amount of bytes from ch into a new ByteBuffer allocated from a
     *  buffer buf
     *  
     *  @param buf
     *  @param ch
     *  @param size
     *  @return
     *  @throws IOException
     */
    constructor.fetchFrom = function(buf, ch, size) {
        var result = buf.duplicate();
        result.setLimit(size);
        NIOUtils.readFromChannel(ch, result);
        result.flip();
        return result;
    };
    constructor.fetchFromFileL = function(file, length) {
        var is = null;
        try {
            is = new FileInputStream(file).getChannel();
            return NIOUtils.fetchFromChannel(is, length);
        } finally {
            NIOUtils.closeQuietly(is);
        }
    };
    constructor.writeTo = function(buffer, file) {
        var out = null;
        try {
            out = new FileOutputStream(file).getChannel();
            out.write(buffer);
        } finally {
            NIOUtils.closeQuietly(out);
        }
    };
    constructor.toArray = function(buffer) {
        var result = new Int8Array(buffer.remaining());
        buffer.duplicate().getBuf(result);
        return result;
    };
    constructor.toArrayL = function(buffer, count) {
        var result = new Int8Array(Math.min(buffer.remaining(), count));
        buffer.duplicate().getBuf(result);
        return result;
    };
    constructor.readL = function(channel, buffer, length) {
        var fork = buffer.duplicate();
        fork.setLimit(Math.min(fork.position() + length, fork.limit()));
         while (channel.read(fork) != -1 && fork.hasRemaining())
            ;
        buffer.setPosition(fork.position());
        return buffer.position() == 0 ? -1 : buffer.position();
    };
    constructor.readFromChannel = function(channel, buffer) {
        var rem = buffer.position();
         while (channel.read(buffer) != -1 && buffer.hasRemaining())
            ;
        return buffer.position() - rem;
    };
    constructor.write = function(to, from) {
        if (from.hasArray()) {
            to.put3(from.array(), from.arrayOffset() + from.position(), Math.min(to.remaining(), from.remaining()));
        } else {
            to.putArr(NIOUtils.toArrayL(from, to.remaining()));
        }
    };
    constructor.writeL = function(to, from, count) {
        if (from.hasArray()) {
            to.put3(from.array(), from.arrayOffset() + from.position(), Math.min(from.remaining(), count));
        } else {
            to.putArr(NIOUtils.toArrayL(from, count));
        }
    };
    constructor.fill = function(buffer, val) {
         while (buffer.hasRemaining())
            buffer.put(val);
    };
    constructor.map = function(fileName) {
        return NIOUtils.mapFile(new File(fileName));
    };
    constructor.mapFile = function(file) {
        var is = new FileInputStream(file);
        var map = is.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, file.length());
        is.close();
        return map;
    };
    constructor.skip = function(buffer, count) {
        var toSkip = Math.min(buffer.remaining(), count);
        buffer.setPosition(buffer.position() + toSkip);
        return toSkip;
    };
    constructor.from = function(buffer, offset) {
        var dup = buffer.duplicate();
        dup.setPosition(dup.position() + offset);
        return dup;
    };
    constructor.combineBuffers = function(picture) {
        var size = 0;
        for (var iterator$byteBuffer = picture.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            size += byteBuffer.remaining();
        }
        var result = ByteBuffer.allocate(size);
        for (var iterator$byteBuffer = picture.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            NIOUtils.write(result, byteBuffer);
        }
        result.flip();
        return result;
    };
    constructor.combineBuffersInto = function(dup, buffers) {
         throw new RuntimeException("Stan");
    };
    constructor.readString = function(buffer, len) {
        return Platform.stringFromBytes(NIOUtils.toArray(NIOUtils.read(buffer, len)));
    };
    constructor.readPascalStringL = function(buffer, maxLen) {
        var sub = NIOUtils.read(buffer, maxLen + 1);
        return Platform.stringFromBytes(NIOUtils.toArray(NIOUtils.read(sub, Math.min(sub.get() & 255, maxLen))));
    };
    constructor.writePascalStringL = function(buffer, string, maxLen) {
        buffer.put((string.length << 24 >> 24));
        buffer.putArr(NIOUtils.asciiString(string));
        NIOUtils.skip(buffer, maxLen - string.length);
    };
    constructor.asciiString = function(fourcc) {
        return Platform.getBytes(fourcc);
    };
    constructor.writePascalString = function(buffer, name) {
        buffer.put((name.length << 24 >> 24));
        buffer.putArr(NIOUtils.asciiString(name));
    };
    constructor.readPascalString = function(buffer) {
        return NIOUtils.readString(buffer, buffer.get() & 255);
    };
    constructor.readNullTermString = function(buffer) {
        return NIOUtils.readNullTermStringCharset(buffer, Platform.UTF_8);
    };
    constructor.readNullTermStringCharset = function(buffer, charset) {
        var fork = buffer.duplicate();
         while (buffer.hasRemaining() && buffer.get() != 0)
            ;
        if (buffer.hasRemaining()) 
            fork.setLimit(buffer.position() - 1);
        return Platform.stringFromCharset(NIOUtils.toArray(fork), charset);
    };
    constructor.readBuf = function(buffer) {
        var result = buffer.duplicate();
        buffer.setPosition(buffer.limit());
        return result;
    };
    constructor.copy = function(_in, out, amount) {
        var buf = ByteBuffer.allocate(65536);
        var read;
        do {
            buf.setPosition(0);
            buf.setLimit(((Math.min(amount, buf.capacity())) | 0));
            read = _in.read(buf);
            if (read != -1) {
                buf.flip();
                out.write(buf);
                amount -= read;
            }
        } while (read != -1 && amount > 0);
    };
    constructor.closeQuietly = function(channel) {
        if (channel == null) 
            return;
        try {
            channel.close();
        }catch (e) {}
    };
    constructor.readByte = function(channel) {
        var buf = ByteBuffer.allocate(1);
        channel.read(buf);
        buf.flip();
        return buf.get();
    };
    constructor.readNByte = function(channel, n) {
        var result = new Int8Array(n);
        channel.read(ByteBuffer.wrap(result));
        return result;
    };
    constructor.readInt = function(channel) {
        var buf = ByteBuffer.allocate(4);
        channel.read(buf);
        buf.flip();
        return buf.getInt();
    };
    constructor.readIntOrder = function(channel, order) {
        var buf = ByteBuffer.allocate(4).order(order);
        channel.read(buf);
        buf.flip();
        return buf.getInt();
    };
    constructor.writeByte = function(channel, value) {
        channel.write(ByteBuffer.allocate(1).put(value).flip());
    };
    constructor.writeIntOrder = function(channel, value, order) {
        var order2 = ByteBuffer.allocate(4).order(order);
        channel.write(order2.putInt(value).flip());
    };
    constructor.writeIntLE = function(channel, value) {
        var allocate = ByteBuffer.allocate(4);
        allocate.order(ByteOrder.LITTLE_ENDIAN);
        channel.write(allocate.putInt(value).flip());
    };
    constructor.writeInt = function(channel, value) {
        channel.write(ByteBuffer.allocate(4).putInt(value).flip());
    };
    constructor.writeLong = function(channel, value) {
        channel.write(ByteBuffer.allocate(8).putLong(value).flip());
    };
    constructor.readableChannel = function(file) {
        return new FileChannelWrapper(new FileInputStream(file).getChannel());
    };
    constructor.writableChannel = function(file) {
        return new FileChannelWrapper(new FileOutputStream(file).getChannel());
    };
    constructor.rwChannel = function(file) {
        return new FileChannelWrapper(new RandomAccessFile(file, "rw").getChannel());
    };
    constructor.readableFileChannel = function(file) {
        return new FileChannelWrapper(new FileInputStream(file).getChannel());
    };
    constructor.writableFileChannel = function(file) {
        return new FileChannelWrapper(new FileOutputStream(file).getChannel());
    };
    constructor.rwFileChannel = function(file) {
        return new FileChannelWrapper(new RandomAccessFile(file, "rw").getChannel());
    };
    constructor.autoChannel = function(file) {
        return new AutoFileChannelWrapper(file);
    };
    constructor.duplicate = function(bb) {
        var out = ByteBuffer.allocate(bb.remaining());
        out.putBuf(bb.duplicate());
        out.flip();
        return out;
    };
    constructor.find = function(catalog, key) {
        var keyA = NIOUtils.toArray(key);
        for (var i = 0; i < catalog.size(); i++) {
            if (Platform.arrayEqualsByte(NIOUtils.toArray(catalog.get(i)), keyA)) 
                return i;
        }
        return -1;
    };
    constructor.FileReaderListener = function() {};
    constructor.FileReaderListener = stjs.extend(constructor.FileReaderListener, null, [], function(constructor, prototype) {
        prototype.progress = function(percentDone) {};
    }, {}, {});
    constructor.FileReader = function() {};
    constructor.FileReader = stjs.extend(constructor.FileReader, null, [], function(constructor, prototype) {
        prototype.oldPd = 0;
        prototype.data = function(data, filePos) {};
        prototype.done = function() {};
        prototype.readChannel = function(ch, bufferSize, listener) {
            var buf = ByteBuffer.allocate(bufferSize);
            var size = ch.size();
            for (var pos = ch.position(); ch.read(buf) != -1; pos = ch.position()) {
                buf.flip();
                this.data(buf, pos);
                buf.flip();
                if (listener != null) {
                    var newPd = (((stjs.trunc(100 * pos / size))) | 0);
                    if (newPd != this.oldPd) 
                        listener.progress(newPd);
                    this.oldPd = newPd;
                }
            }
            this.done();
        };
        prototype.readFile = function(source, bufferSize, listener) {
            var ch = null;
            try {
                ch = NIOUtils.readableChannel(source);
                this.readChannel(ch, bufferSize, listener);
            } finally {
                NIOUtils.closeQuietly(ch);
            }
        };
    }, {}, {});
    constructor.getRel = function(bb, rel) {
        return bb.getAt(bb.position() + rel);
    };
    constructor.cloneBuffer = function(pesBuffer) {
        var res = ByteBuffer.allocate(pesBuffer.remaining());
        res.putBuf(pesBuffer.duplicate());
        res.clear();
        return res;
    };
    constructor.clone = function(byteBuffer) {
        var result = ByteBuffer.allocate(byteBuffer.remaining());
        result.putBuf(byteBuffer.duplicate());
        result.flip();
        return result;
    };
    constructor.asByteBuffer = function(_arguments) {
        return ByteBuffer.wrap(arguments);
    };
    constructor.asByteBufferInt = function(_arguments) {
        return NIOUtils.asByteBuffer(ArrayUtil.toByteArray(arguments));
    };
    constructor.relocateLeftover = function(bb) {
        var pos;
        for (pos = 0; bb.hasRemaining(); pos++) {
            bb.putAt(pos, bb.get());
        }
        bb.setPosition(pos);
        bb.setLimit(bb.capacity());
    };
}, {}, {});
var MPEGPacket = function(data, pts, timescale, duration, frameNo, keyFrame, tapeTimecode) {
    Packet.call(this, data, pts, timescale, duration, frameNo, keyFrame, tapeTimecode, 0);
};
MPEGPacket = stjs.extend(MPEGPacket, Packet, [], function(constructor, prototype) {
    prototype.offset = 0;
    prototype.seq = null;
    prototype.gop = 0;
    prototype.timecode = 0;
    prototype.getOffset = function() {
        return this.offset;
    };
    prototype.getSeq = function() {
        return this.seq;
    };
    prototype.getGOP = function() {
        return this.gop;
    };
    prototype.getTimecode = function() {
        return this.timecode;
    };
}, {seq: "ByteBuffer", data: "ByteBuffer", frameType: {name: "Enum", arguments: ["Packet.FrameType"]}, tapeTimecode: "TapeTimecode", FRAME_ASC: {name: "Comparator", arguments: ["Packet"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var MP4Packet = function(data, pts, timescale, duration, frameNo, iframe, tapeTimecode, displayOrder, mediaPts, entryNo, fileOff, size, psync) {
    Packet.call(this, data, pts, timescale, duration, frameNo, iframe, tapeTimecode, displayOrder);
    this.mediaPts = mediaPts;
    this.entryNo = entryNo;
    this.fileOff = fileOff;
    this.size = size;
    this.psync = psync;
};
MP4Packet = stjs.extend(MP4Packet, Packet, [], function(constructor, prototype) {
    constructor.createMP4PacketWithTimecode = function(other, timecode) {
        return MP4Packet.createMP4Packet(other.data, other.pts, other.timescale, other.duration, other.frameNo, other.frameType, timecode, other.displayOrder, other.mediaPts, other.entryNo);
    };
    constructor.createMP4PacketWithData = function(other, frm) {
        return MP4Packet.createMP4Packet(frm, other.pts, other.timescale, other.duration, other.frameNo, other.frameType, other.tapeTimecode, other.displayOrder, other.mediaPts, other.entryNo);
    };
    constructor.createMP4Packet = function(data, pts, timescale, duration, frameNo, iframe, tapeTimecode, displayOrder, mediaPts, entryNo) {
        return new MP4Packet(data, pts, timescale, duration, frameNo, iframe, tapeTimecode, displayOrder, mediaPts, entryNo, 0, 0, false);
    };
    prototype.mediaPts = 0;
    prototype.entryNo = 0;
    prototype.fileOff = 0;
    prototype.size = 0;
    prototype.psync = false;
    /**
     *  Zero-offset sample entry index
     *  
     *  @return
     */
    prototype.getEntryNo = function() {
        return this.entryNo;
    };
    prototype.getMediaPts = function() {
        return this.mediaPts;
    };
    prototype.getFileOff = function() {
        return this.fileOff;
    };
    prototype.getSize = function() {
        return this.size;
    };
    prototype.isPsync = function() {
        return this.psync;
    };
}, {data: "ByteBuffer", frameType: {name: "Enum", arguments: ["Packet.FrameType"]}, tapeTimecode: "TapeTimecode", FRAME_ASC: {name: "Comparator", arguments: ["Packet"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Picture extension with frame number, makes it easier to debug reordering
 *  
 *  @author The JCodec project
 *  
 */
var Frame = function(width, height, data, color, crop, frameNo, frameType, mvs, refsUsed, poc) {
    Picture.call(this, width, height, data, null, color, 0, crop);
    this.frameNo = frameNo;
    this.mvs = mvs;
    this.refsUsed = refsUsed;
    this.poc = poc;
    this.shortTerm = true;
};
Frame = stjs.extend(Frame, Picture, [], function(constructor, prototype) {
    prototype.frameNo = 0;
    prototype.frameType = null;
    prototype.mvs = null;
    prototype.refsUsed = null;
    prototype.shortTerm = false;
    prototype.poc = 0;
    constructor.createFrame = function(pic) {
        var comp = pic.createCompatible();
        return new Frame(comp.getWidth(), comp.getHeight(), comp.getData(), comp.getColor(), pic.getCrop(), pic.frameNo, pic.frameType, pic.mvs, pic.refsUsed, pic.poc);
    };
    prototype.cropped = function() {
        var cropped = Picture.prototype.cropped.call(this);
        return new Frame(cropped.getWidth(), cropped.getHeight(), cropped.getData(), cropped.getColor(), null, this.frameNo, this.frameType, this.mvs, this.refsUsed, this.poc);
    };
    prototype.copyFromFrame = function(src) {
        Picture.prototype.copyFrom.call(this, src);
        this.frameNo = src.frameNo;
        this.mvs = src.mvs;
        this.shortTerm = src.shortTerm;
        this.refsUsed = src.refsUsed;
        this.poc = src.poc;
    };
    /**
     *  Creates a cropped clone of this picture.
     *  
     *  @return
     */
    prototype.cloneCropped = function() {
        if (this.cropNeeded()) {
            return this.cropped();
        } else {
            var clone = Frame.createFrame(this);
            clone.copyFrom(this);
            return clone;
        }
    };
    prototype.getFrameNo = function() {
        return this.frameNo;
    };
    prototype.getMvs = function() {
        return this.mvs;
    };
    prototype.isShortTerm = function() {
        return this.shortTerm;
    };
    prototype.setShortTerm = function(shortTerm) {
        this.shortTerm = shortTerm;
    };
    prototype.getPOC = function() {
        return this.poc;
    };
    constructor.POCAsc = new (stjs.extend(function Frame$1() {}, null, [Comparator], function(constructor, prototype) {
        prototype.compare = function(o1, o2) {
            if (o1 == null && o2 == null) 
                return 0;
             else if (o1 == null) 
                return 1;
             else if (o2 == null) 
                return -1;
             else 
                return o1.poc > o2.poc ? 1 : (o1.poc == o2.poc ? 0 : -1);
        };
    }, {}, {}))();
    constructor.POCDesc = new (stjs.extend(function Frame$2() {}, null, [Comparator], function(constructor, prototype) {
        prototype.compare = function(o1, o2) {
            if (o1 == null && o2 == null) 
                return 0;
             else if (o1 == null) 
                return 1;
             else if (o2 == null) 
                return -1;
             else 
                return o1.poc < o2.poc ? 1 : (o1.poc == o2.poc ? 0 : -1);
        };
    }, {}, {}))();
    prototype.getRefsUsed = function() {
        return this.refsUsed;
    };
    prototype.getFrameType = function() {
        return this.frameType;
    };
}, {frameType: "SliceType", mvs: "H264Utils.MvList2D", refsUsed: "Array", POCAsc: {name: "Comparator", arguments: ["Frame"]}, POCDesc: {name: "Comparator", arguments: ["Frame"]}, color: "ColorSpace", data: "Array", lowBits: "Array", crop: "Rect"}, {});
var PixelStoreImpl = function() {
    this.buffers = new ArrayList();
};
PixelStoreImpl = stjs.extend(PixelStoreImpl, null, [PixelStore], function(constructor, prototype) {
    prototype.buffers = null;
    prototype.getPicture = function(width, height, color) {
        for (var iterator$picture = this.buffers.iterator(); iterator$picture.hasNext(); ) {
            var picture = iterator$picture.next();
            if (picture.getWidth() == width && picture.getHeight() == height && picture.getColor() == color) {
                this.buffers.remove(picture);
                return new PixelStore.LoanerPicture(picture, 1);
            }
        }
        return new PixelStore.LoanerPicture(Picture.create(width, height, color), 1);
    };
    prototype.putBack = function(frame) {
        frame.decRefCnt();
        if (frame.unused()) {
            var pixels = frame.getPicture();
            pixels.setCrop(null);
            this.buffers.add(pixels);
        }
    };
    prototype.retake = function(frame) {
        frame.incRefCnt();
    };
}, {buffers: {name: "List", arguments: ["Picture"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  High level frame grabber helper.
 *  
 *  @author The JCodec project
 *  
 */
var GenericAdaptor = function(detect) {
    this.decoder = detect;
};
GenericAdaptor = stjs.extend(GenericAdaptor, null, [ContainerAdaptor], function(constructor, prototype) {
    prototype.decoder = null;
    prototype.decodeFrame = function(packet, data) {
        return this.decoder.decodeFrame(packet.getData(), data);
    };
    prototype.canSeek = function(data) {
        return true;
    };
    prototype.getMediaInfo = function() {
        return new MediaInfo(new Size(0, 0));
    };
    prototype.allocatePicture = function() {
        return Picture.create(1920, 1088, ColorSpace.YUV444).getData();
    };
}, {decoder: "VideoDecoder"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var EncodedMB = function() {
    this.pixels = Picture.create(16, 16, ColorSpace.YUV420J);
    this.nc = new Int32Array(16);
    this.mx = new Int32Array(16);
    this.my = new Int32Array(16);
};
EncodedMB = stjs.extend(EncodedMB, null, [], function(constructor, prototype) {
    prototype.pixels = null;
    prototype.type = null;
    prototype.qp = 0;
    prototype.nc = null;
    prototype.mx = null;
    prototype.my = null;
    prototype.getPixels = function() {
        return this.pixels;
    };
    prototype.getType = function() {
        return this.type;
    };
    prototype.setType = function(type) {
        this.type = type;
    };
    prototype.getQp = function() {
        return this.qp;
    };
    prototype.setQp = function(qp) {
        this.qp = qp;
    };
    prototype.getNc = function() {
        return this.nc;
    };
    prototype.getMx = function() {
        return this.mx;
    };
    prototype.getMy = function() {
        return this.my;
    };
}, {pixels: "Picture", type: "MBType", nc: "Int32Array", mx: "Int32Array", my: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VP8Encoder = function(rc) {
    VideoEncoder.call(this);
    this.rc = rc;
    this.tmp = new Int32Array(16);
};
VP8Encoder = stjs.extend(VP8Encoder, VideoEncoder, [], function(constructor, prototype) {
    prototype.bitstream = null;
    prototype.leftRow = null;
    prototype.topLine = null;
    prototype.quantizer = null;
    prototype.tmp = null;
    prototype.rc = null;
    prototype.headerBuffer = null;
    prototype.dataBuffer = null;
    constructor.createVP8Encoder = function(qp) {
        return new VP8Encoder(new NopRateControl(qp));
    };
    prototype.encodeFrame = function(pic, _buf) {
        var out = _buf.duplicate();
        var mbWidth = ((pic.getWidth() + 15) >> 4);
        var mbHeight = ((pic.getHeight() + 15) >> 4);
        this.prepareBuffers(mbWidth, mbHeight);
        this.bitstream = new VPXBitstream(VPXConst.tokenDefaultBinProbs, mbWidth);
        this.leftRow = [new Int8Array(16), new Int8Array(8), new Int8Array(8)];
        this.topLine = [new Int8Array(mbWidth << 4), new Int8Array(mbWidth << 3), new Int8Array(mbWidth << 3)];
        this.initValue(this.leftRow, (1 << 24 >> 24));
        this.initValue(this.topLine, (-1 << 24 >> 24));
        this.quantizer = new VPXQuantizer();
        var outMB = Picture.create(16, 16, ColorSpace.YUV420);
        var segmentQps = this.rc.getSegmentQps();
        var boolEnc = new VPXBooleanEncoder(this.dataBuffer);
        var segmentMap = new Int32Array(mbWidth * mbHeight);
        for (var mbY = 0, mbAddr = 0; mbY < mbHeight; mbY++) {
            this.initValue(this.leftRow, (1 << 24 >> 24));
            for (var mbX = 0; mbX < mbWidth; mbX++ , mbAddr++) {
                var before = boolEnc.position();
                var segment = this.rc.getSegment();
                segmentMap[mbAddr] = segment;
                this.luma(pic, mbX, mbY, boolEnc, segmentQps[segment], outMB);
                this.chroma(pic, mbX, mbY, boolEnc, segmentQps[segment], outMB);
                this.rc.report(boolEnc.position() - before);
                this.collectPredictors(outMB, mbX);
            }
        }
        boolEnc.stop();
        this.dataBuffer.flip();
        boolEnc = new VPXBooleanEncoder(this.headerBuffer);
        var probs = this.calcSegmentProbs(segmentMap);
        this.writeHeader2(boolEnc, segmentQps, probs);
        for (var mbY = 0, mbAddr = 0; mbY < mbHeight; mbY++) {
            for (var mbX = 0; mbX < mbWidth; mbX++ , mbAddr++) {
                this.writeSegmetId(boolEnc, segmentMap[mbAddr], probs);
                boolEnc.writeBit(145, 1);
                boolEnc.writeBit(156, 0);
                boolEnc.writeBit(163, 0);
                boolEnc.writeBit(142, 0);
            }
        }
        boolEnc.stop();
        this.headerBuffer.flip();
        out.order(ByteOrder.LITTLE_ENDIAN);
        this.writeHeader(out, pic.getWidth(), pic.getHeight(), this.headerBuffer.remaining());
        out.putBuf(this.headerBuffer);
        out.putBuf(this.dataBuffer);
        out.flip();
        return new VideoEncoder.EncodedFrame(out, true);
    };
    prototype.prepareBuffers = function(mbWidth, mbHeight) {
        var dataBufSize = (mbHeight * mbHeight) << 10;
        var headerBufSize = 256 + mbWidth * mbHeight;
        if (this.headerBuffer == null || this.headerBuffer.capacity() < headerBufSize) 
            this.headerBuffer = ByteBuffer.allocate(headerBufSize);
         else 
            this.headerBuffer.clear();
        if (this.dataBuffer == null || this.dataBuffer.capacity() < dataBufSize) 
            this.dataBuffer = ByteBuffer.allocate(dataBufSize);
         else 
            this.dataBuffer.clear();
    };
    prototype.writeSegmetId = function(boolEnc, id, probs) {
        var bit1 = (id >> 1) & 1;
        boolEnc.writeBit(probs[0], bit1);
        boolEnc.writeBit(probs[1 + bit1], id & 1);
    };
    prototype.calcSegmentProbs = function(segmentMap) {
        var result = new Int32Array(3);
        for (var i = 0; i < segmentMap.length; i++) {
            switch (segmentMap[i]) {
                case 0:
                    result[0]++;
                    result[1]++;
                    break;
                case 1:
                    result[0]++;
                    break;
                case 2:
                    result[2]++;
            }
        }
        for (var i = 0; i < 3; i++) 
            result[i] = MathUtil.clip(stjs.trunc((result[i] << 8) / segmentMap.length), 1, 255);
        return result;
    };
    prototype.initValue = function(leftRow2, val) {
        Arrays.fill(leftRow2[0], val);
        Arrays.fill(leftRow2[1], val);
        Arrays.fill(leftRow2[2], val);
    };
    prototype.writeHeader2 = function(boolEnc, segmentQps, probs) {
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 1);
        boolEnc.writeBit(128, 1);
        boolEnc.writeBit(128, 1);
        boolEnc.writeBit(128, 1);
        for (var i = 0; i < segmentQps.length; i++) {
            boolEnc.writeBit(128, 1);
            this.writeInt(boolEnc, segmentQps[i], 7);
            boolEnc.writeBit(128, 0);
        }
        for (var i = segmentQps.length; i < 4; i++) 
            boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        for (var i = 0; i < 3; i++) {
            boolEnc.writeBit(128, 1);
            this.writeInt(boolEnc, probs[i], 8);
        }
        boolEnc.writeBit(128, 0);
        this.writeInt(boolEnc, 1, 6);
        this.writeInt(boolEnc, 0, 3);
        boolEnc.writeBit(128, 0);
        this.writeInt(boolEnc, 0, 2);
        this.writeInt(boolEnc, segmentQps[0], 7);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        boolEnc.writeBit(128, 0);
        var probFlags = VPXConst.tokenProbUpdateFlagProbs;
        for (var i = 0; i < probFlags.length; i++) {
            for (var j = 0; j < probFlags[i].length; j++) {
                for (var k = 0; k < probFlags[i][j].length; k++) {
                    for (var l = 0; l < probFlags[i][j][k].length; l++) 
                        boolEnc.writeBit(probFlags[i][j][k][l], 0);
                }
            }
        }
        boolEnc.writeBit(128, 0);
    };
    prototype.writeInt = function(boolEnc, data, bits) {
        var bit;
        for (bit = bits - 1; bit >= 0; bit--) 
            boolEnc.writeBit(128, (1 & (data >> bit)));
    };
    prototype.writeHeader = function(out, width, height, firstPart) {
        var version = 0, type = 0, showFrame = 1;
        var header = (firstPart << 5) | (showFrame << 4) | (version << 1) | type;
        out.put(((header & 255) << 24 >> 24));
        out.put((((header >> 8) & 255) << 24 >> 24));
        out.put((((header >> 16) & 255) << 24 >> 24));
        out.put((157 << 24 >> 24));
        out.put((1 << 24 >> 24));
        out.put((42 << 24 >> 24));
        out.putShort(((width) << 16 >> 16));
        out.putShort(((height) << 16 >> 16));
    };
    prototype.collectPredictors = function(outMB, mbX) {
        System.arraycopy(outMB.getPlaneData(0), 240, this.topLine[0], mbX << 4, 16);
        System.arraycopy(outMB.getPlaneData(1), 56, this.topLine[1], mbX << 3, 8);
        System.arraycopy(outMB.getPlaneData(2), 56, this.topLine[2], mbX << 3, 8);
        this.copyCol(outMB.getPlaneData(0), 15, 16, this.leftRow[0]);
        this.copyCol(outMB.getPlaneData(1), 7, 8, this.leftRow[1]);
        this.copyCol(outMB.getPlaneData(2), 7, 8, this.leftRow[2]);
    };
    prototype.copyCol = function(planeData, off, stride, out) {
        for (var i = 0; i < out.length; i++) {
            out[i] = planeData[off];
            off += stride;
        }
    };
    prototype.luma = function(pic, mbX, mbY, out, qp, outMB) {
        var x = mbX << 4;
        var y = mbY << 4;
        var ac = this.transform(pic, 0, qp, x, y);
        var dc = this.extractDC(ac);
        this.writeLumaDC(mbX, mbY, out, qp, dc);
        this.writeLumaAC(mbX, mbY, out, ac, qp);
        this.restorePlaneLuma(dc, ac, qp);
        this.putLuma(outMB.getPlaneData(0), this.lumaDCPred(x, y), ac, 4);
    };
    prototype.writeLumaAC = function(mbX, mbY, out, ac, qp) {
        for (var i = 0; i < 16; i++) {
            this.quantizer.quantizeY(ac[i], qp);
            this.bitstream.encodeCoeffsDCT15(out, this.zigzag(ac[i], this.tmp), mbX, i & 3, i >> 2);
        }
    };
    prototype.writeLumaDC = function(mbX, mbY, out, qp, dc) {
        VPXDCT.walsh4x4(dc);
        this.quantizer.quantizeY2(dc, qp);
        this.bitstream.encodeCoeffsWHT(out, this.zigzag(dc, this.tmp), mbX);
    };
    prototype.writeChroma = function(comp, mbX, mbY, boolEnc, ac, qp) {
        for (var i = 0; i < 4; i++) {
            this.quantizer.quantizeUV(ac[i], qp);
            this.bitstream.encodeCoeffsDCTUV(boolEnc, this.zigzag(ac[i], this.tmp), comp, mbX, i & 1, i >> 1);
        }
    };
    prototype.zigzag = function(zz, tmp2) {
        for (var i = 0; i < 16; i++) 
            tmp2[i] = zz[VPXConst.zigzag[i]];
        return tmp2;
    };
    prototype.chroma = function(pic, mbX, mbY, boolEnc, qp, outMB) {
        var x = mbX << 3;
        var y = mbY << 3;
        var chromaPred1 = this.chromaPredBlk(1, x, y);
        var chromaPred2 = this.chromaPredBlk(2, x, y);
        var ac1 = this.transformChroma(pic, 1, qp, x, y, outMB, chromaPred1);
        var ac2 = this.transformChroma(pic, 2, qp, x, y, outMB, chromaPred2);
        this.writeChroma(1, mbX, mbY, boolEnc, ac1, qp);
        this.writeChroma(2, mbX, mbY, boolEnc, ac2, qp);
        this.restorePlaneChroma(ac1, qp);
        this.putChroma(outMB.getData()[1], 1, x, y, ac1, chromaPred1);
        this.restorePlaneChroma(ac2, qp);
        this.putChroma(outMB.getData()[2], 2, x, y, ac2, chromaPred2);
    };
    prototype.transformChroma = function(pic, comp, qp, x, y, outMB, chromaPred) {
        var ac = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(16);
        });
        for (var blk = 0; blk < ac.length; blk++) {
            var blkOffX = (blk & 1) << 2;
            var blkOffY = (blk >> 1) << 2;
            this.takeSubtract(pic.getPlaneData(comp), pic.getPlaneWidth(comp), pic.getPlaneHeight(comp), x + blkOffX, y + blkOffY, ac[blk], chromaPred);
            VPXDCT.fdct4x4(ac[blk]);
        }
        return ac;
    };
    prototype.putChroma = function(mb, comp, x, y, ac, chromaPred) {
        for (var blk = 0; blk < 4; blk++) 
            this.putBlk(mb, chromaPred, ac[blk], 3, (blk & 1) << 2, (blk >> 1) << 2);
    };
    prototype.chromaPredOne = function(pix, x) {
        return (((pix[x] + pix[x + 1] + pix[x + 2] + pix[x + 3] + pix[x + 4] + pix[x + 5] + pix[x + 6] + pix[x + 7] + 4) >> 3) << 24 >> 24);
    };
    prototype.chromaPredTwo = function(pix1, pix2, x, y) {
        return (((pix1[x] + pix1[x + 1] + pix1[x + 2] + pix1[x + 3] + pix1[x + 4] + pix1[x + 5] + pix1[x + 6] + pix1[x + 7] + pix2[y] + pix2[y + 1] + pix2[y + 2] + pix2[y + 3] + pix2[y + 4] + pix2[y + 5] + pix2[y + 6] + pix2[y + 7] + 8) >> 4) << 24 >> 24);
    };
    prototype.chromaPredBlk = function(comp, x, y) {
        var predY = y & 7;
        if (x != 0 && y != 0) 
            return this.chromaPredTwo(this.leftRow[comp], this.topLine[comp], predY, x);
         else if (x != 0) 
            return this.chromaPredOne(this.leftRow[comp], predY);
         else if (y != 0) 
            return this.chromaPredOne(this.topLine[comp], x);
         else 
            return 0;
    };
    prototype.putLuma = function(planeData, pred, ac, log2stride) {
        for (var blk = 0; blk < ac.length; blk++) {
            var blkOffX = (blk & 3) << 2;
            var blkOffY = blk & ~3;
            this.putBlk(planeData, pred, ac[blk], log2stride, blkOffX, blkOffY);
        }
    };
    prototype.putBlk = function(planeData, pred, block, log2stride, blkX, blkY) {
        var stride = 1 << log2stride;
        for (var line = 0, srcOff = 0, dstOff = (blkY << log2stride) + blkX; line < 4; line++) {
            planeData[dstOff] = ((MathUtil.clip(block[srcOff] + pred, -128, 127)) << 24 >> 24);
            planeData[dstOff + 1] = ((MathUtil.clip(block[srcOff + 1] + pred, -128, 127)) << 24 >> 24);
            planeData[dstOff + 2] = ((MathUtil.clip(block[srcOff + 2] + pred, -128, 127)) << 24 >> 24);
            planeData[dstOff + 3] = ((MathUtil.clip(block[srcOff + 3] + pred, -128, 127)) << 24 >> 24);
            srcOff += 4;
            dstOff += stride;
        }
    };
    prototype.restorePlaneChroma = function(ac, qp) {
        for (var i = 0; i < 4; i++) {
            this.quantizer.dequantizeUV(ac[i], qp);
            VPXDCT.idct4x4(ac[i]);
        }
    };
    prototype.restorePlaneLuma = function(dc, ac, qp) {
        this.quantizer.dequantizeY2(dc, qp);
        VPXDCT.iwalsh4x4(dc);
        for (var i = 0; i < 16; i++) {
            this.quantizer.dequantizeY(ac[i], qp);
            ac[i][0] = dc[i];
            VPXDCT.idct4x4(ac[i]);
        }
    };
    prototype.extractDC = function(ac) {
        var dc = new Int32Array(ac.length);
        for (var i = 0; i < ac.length; i++) {
            dc[i] = ac[i][0];
        }
        return dc;
    };
    prototype.lumaDCPred = function(x, y) {
        if (x == 0 && y == 0) 
            return 0;
        if (y == 0) 
            return (((ArrayUtil.sumByte(this.leftRow[0]) + 8) >> 4) << 24 >> 24);
        if (x == 0) 
            return (((ArrayUtil.sumByte3(this.topLine[0], x, 16) + 8) >> 4) << 24 >> 24);
        return (((ArrayUtil.sumByte(this.leftRow[0]) + ArrayUtil.sumByte3(this.topLine[0], x, 16) + 16) >> 5) << 24 >> 24);
    };
    prototype.transform = function(pic, comp, qp, x, y) {
        var dcc = this.lumaDCPred(x, y);
        var ac = Array.apply(null, Array(16)).map(function() {
            return new Int32Array(16);
        });
        for (var i = 0; i < ac.length; i++) {
            var coeff = ac[i];
            var blkOffX = (i & 3) << 2;
            var blkOffY = i & ~3;
            this.takeSubtract(pic.getPlaneData(comp), pic.getPlaneWidth(comp), pic.getPlaneHeight(comp), x + blkOffX, y + blkOffY, coeff, dcc);
            VPXDCT.fdct4x4(coeff);
        }
        return ac;
    };
    prototype.takeSubtract = function(planeData, planeWidth, planeHeight, x, y, coeff, dc) {
        if (x + 4 < planeWidth && y + 4 < planeHeight) 
            this.takeSubtractSafe(planeData, planeWidth, planeHeight, x, y, coeff, dc);
         else 
            this.takeSubtractUnsafe(planeData, planeWidth, planeHeight, x, y, coeff, dc);
    };
    prototype.takeSubtractSafe = function(planeData, planeWidth, planeHeight, x, y, coeff, dc) {
        for (var i = 0, srcOff = y * planeWidth + x, dstOff = 0; i < 4; i++ , srcOff += planeWidth , dstOff += 4) {
            coeff[dstOff] = planeData[srcOff] - dc;
            coeff[dstOff + 1] = planeData[srcOff + 1] - dc;
            coeff[dstOff + 2] = planeData[srcOff + 2] - dc;
            coeff[dstOff + 3] = planeData[srcOff + 3] - dc;
        }
    };
    prototype.takeSubtractUnsafe = function(planeData, planeWidth, planeHeight, x, y, coeff, dc) {
        var outOff = 0;
        var i;
        for (i = y; i < Math.min(y + 4, planeHeight); i++) {
            var off = i * planeWidth + Math.min(x, planeWidth);
            var j;
            for (j = x; j < Math.min(x + 4, planeWidth); j++) 
                coeff[outOff++] = planeData[off++] - dc;
            --off;
            for (; j < x + 4; j++) 
                coeff[outOff++] = planeData[off] - dc;
        }
        for (; i < y + 4; i++) {
            var off = planeHeight * planeWidth - planeWidth + Math.min(x, planeWidth);
            var j;
            for (j = x; j < Math.min(x + 4, planeWidth); j++) 
                coeff[outOff++] = planeData[off++] - dc;
            --off;
            for (; j < x + 4; j++) 
                coeff[outOff++] = planeData[off] - dc;
        }
    };
    prototype.getSupportedColorSpaces = function() {
        return [ColorSpace.YUV420J];
    };
    prototype.estimateBufferSize = function(frame) {
        return stjs.trunc(frame.getWidth() * frame.getHeight() / 2);
    };
}, {bitstream: "VPXBitstream", leftRow: "Array", topLine: "Array", quantizer: "VPXQuantizer", tmp: "Int32Array", rc: "RateControl", headerBuffer: "ByteBuffer", dataBuffer: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  The decoder for yuv 10 bit 422
 *  
 *  x|x|9876543210(cr0)|9876543210(y0) |9876543210(cb0)
 *  x|x|9876543210(y2) |9876543210(cb1)|9876543210(y1)
 *  x|x|9876543210(cb2)|9876543210(y3) |9876543210(cr1)
 *  x|x|9876543210(y5) |9876543210(cr2)|9876543210(y4) 
 *  
 *  @author The JCodec project
 *  
 */
var V210Decoder = function(width, height) {
    this.width = width;
    this.height = height;
};
V210Decoder = stjs.extend(V210Decoder, null, [], function(constructor, prototype) {
    prototype.width = 0;
    prototype.height = 0;
    prototype.decode = function(data) {
        var littleEndian = ByteBuffer.wrap(data).order(ByteOrder.LITTLE_ENDIAN);
        var dat = littleEndian.asIntBuffer();
        var y = ByteBuffer.wrap(new Int8Array(this.width * this.height));
        var cb = ByteBuffer.wrap(new Int8Array(stjs.trunc(this.width * this.height / 2)));
        var cr = ByteBuffer.wrap(new Int8Array(stjs.trunc(this.width * this.height / 2)));
         while (dat.hasRemaining()){
            var i = dat.get();
            cr.put(this.to8Bit(i >> 20));
            y.put(this.to8Bit((i >> 10) & 1023));
            cb.put(this.to8Bit(i & 1023));
            i = dat.get();
            y.put(this.to8Bit(i & 1023));
            y.put(this.to8Bit(i >> 20));
            cb.put(this.to8Bit((i >> 10) & 1023));
            i = dat.get();
            cb.put(this.to8Bit(i >> 20));
            y.put(this.to8Bit((i >> 10) & 1023));
            cr.put(this.to8Bit(i & 1023));
            i = dat.get();
            y.put(this.to8Bit(i & 1023));
            y.put(this.to8Bit(i >> 20));
            cr.put(this.to8Bit((i >> 10) & 1023));
        }
        return Picture.createPicture(this.width, this.height, [y.array(), cb.array(), cr.array()], ColorSpace.YUV422);
    };
    prototype.to8Bit = function(i) {
        return ((((i + 2) >> 2) - 128) << 24 >> 24);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var RAWVideoDecoder = function(width, height) {
    VideoDecoder.call(this);
    this.width = width;
    this.height = height;
};
RAWVideoDecoder = stjs.extend(RAWVideoDecoder, VideoDecoder, [], function(constructor, prototype) {
    prototype.width = 0;
    prototype.height = 0;
    prototype.decodeFrame = function(data, buffer) {
        var create = Picture.createPicture(this.width, this.height, buffer, ColorSpace.YUV420);
        var pix = data.duplicate();
        this.copy(pix, create.getPlaneData(0), this.width * this.height);
        this.copy(pix, create.getPlaneData(1), stjs.trunc(this.width * this.height / 4));
        this.copy(pix, create.getPlaneData(2), stjs.trunc(this.width * this.height / 4));
        return create;
    };
    prototype.copy = function(b, ii, size) {
        for (var i = 0; b.hasRemaining() && i < size; i++) {
            ii[i] = (((b.get() & 255) - 128) << 24 >> 24);
        }
    };
    prototype.getCodecMeta = function(data) {
        return VideoCodecMeta.createSimpleVideoCodecMeta(new Size(this.width, this.height), ColorSpace.YUV420);
    };
}, {byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var MkvSegment = function(id) {
    EbmlMaster.call(this, id);
};
MkvSegment = stjs.extend(MkvSegment, EbmlMaster, [], function(constructor, prototype) {
    prototype.headerSize = 0;
    constructor.SEGMENT_ID = new Int8Array([24, 83, (128 << 24 >> 24), 103]);
    constructor.createMkvSegment = function() {
        return new MkvSegment(MkvSegment.SEGMENT_ID);
    };
    prototype.getHeader = function() {
        var headerSize = this.getHeaderSize();
        if (headerSize > Integer.MAX_VALUE) 
            System.out.println("MkvSegment.getHeader: id.length " + this.id.length + "  Element.getEbmlSize(" + this.dataLen + "): " + EbmlUtil.ebmlLength(this.dataLen) + " size: " + this.dataLen);
        var bb = ByteBuffer.allocate(((headerSize) | 0));
        bb.putArr(this.id);
        bb.putArr(EbmlUtil.ebmlEncode(this.getDataLen()));
        if (this.children != null && !this.children.isEmpty()) {
            for (var iterator$e = this.children.iterator(); iterator$e.hasNext(); ) {
                var e = iterator$e.next();
                if (Platform.arrayEqualsByte(EbmlMaster.CLUSTER_ID, e.type.id)) 
                    continue;
                bb.putBuf(e.getData());
            }
        }
        bb.flip();
        return bb;
    };
    prototype.getHeaderSize = function() {
        var returnValue = this.id.length;
        returnValue += EbmlUtil.ebmlLength(this.getDataLen());
        if (this.children != null && !this.children.isEmpty()) {
            for (var iterator$e = this.children.iterator(); iterator$e.hasNext(); ) {
                var e = iterator$e.next();
                if (Platform.arrayEqualsByte(EbmlMaster.CLUSTER_ID, e.type.id)) 
                    continue;
                returnValue += e.size();
            }
        }
        return returnValue;
    };
}, {SEGMENT_ID: "Int8Array", children: {name: "ArrayList", arguments: ["EbmlBase"]}, CLUSTER_ID: "Int8Array", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlSint = function(id) {
    EbmlBin.call(this, id);
};
EbmlSint = stjs.extend(EbmlSint, EbmlBin, [], function(constructor, prototype) {
    prototype.setLong = function(value) {
        this.data = ByteBuffer.wrap(EbmlSint.convertToBytes(value));
    };
    prototype.getLong = function() {
        if ((this.data.limit() - this.data.position()) == 8) 
            return this.data.duplicate().getLong();
        var b = this.data.array();
        var l = 0;
        for (var i = b.length - 1; i >= 0; i--) 
            l |= (b[i] & 255) << (8 * (b.length - 1 - i));
        return l;
    };
    constructor.ebmlSignedLength = function(val) {
        if (val <= 64 && val >= (-63)) {
            return 1;
        } else if (val <= 8192 && val >= (-8191)) {
            return 2;
        } else if (val <= 1048576 && val >= (-1048575)) {
            return 3;
        } else if (val <= 134217728 && val >= (-134217727)) {
            return 4;
        } else if (val <= 17179869184 && val >= -17179869183) {
            return 5;
        } else if (val <= 2199023255552 && val >= -2199023255551) {
            return 6;
        } else if (val <= 281474976710656 && val >= -281474976710655) {
            return 7;
        } else {
            return 8;
        }
    };
    constructor.signedComplement = [0, 63, 8191, 1048575, 134217727, 17179869183, 2199023255551, 281474976710655, 36028797018963967];
    constructor.convertToBytes = function(val) {
        var num = EbmlSint.ebmlSignedLength(val);
        val += EbmlSint.signedComplement[num];
        return EbmlUtil.ebmlEncodeLen(val, num);
    };
}, {signedComplement: "Array", data: "ByteBuffer", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlFloat = function(id) {
    EbmlBin.call(this, id);
};
EbmlFloat = stjs.extend(EbmlFloat, EbmlBin, [], function(constructor, prototype) {
    prototype.setDouble = function(value) {
        if (value < Float.MAX_VALUE) {
            var bb = ByteBuffer.allocate(4);
            bb.putFloat(value);
            bb.flip();
            this.data = bb;
        } else if (value < Double.MAX_VALUE) {
            var bb = ByteBuffer.allocate(8);
            bb.putDouble(value);
            bb.flip();
            this.data = bb;
        }
    };
    prototype.getDouble = function() {
        if (this.data.limit() == 4) 
            return this.data.duplicate().getFloat();
        return this.data.duplicate().getDouble();
    };
}, {data: "ByteBuffer", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlUint = function(id) {
    EbmlBin.call(this, id);
};
EbmlUint = stjs.extend(EbmlUint, EbmlBin, [], function(constructor, prototype) {
    constructor.createEbmlUint = function(id, value) {
        var e = new EbmlUint(id);
        e.setUint(value);
        return e;
    };
    prototype.setUint = function(value) {
        this.data = ByteBuffer.wrap(EbmlUint.longToBytes(value));
        this.dataLen = this.data.limit();
    };
    prototype.getUint = function() {
        var l = 0;
        var tmp = 0;
        for (var i = 0; i < this.data.limit(); i++) {
            tmp = (stjs.trunc(this.data.getAt(this.data.limit() - 1 - i))) << 56;
            tmp >>>= (56 - (i * 8));
            l |= tmp;
        }
        return l;
    };
    constructor.longToBytes = function(value) {
        var b = new Int8Array(EbmlUint.calculatePayloadSize(value));
        for (var i = b.length - 1; i >= 0; i--) {
            b[i] = ((value >>> (8 * (b.length - i - 1))) << 24 >> 24);
        }
        return b;
    };
    constructor.calculatePayloadSize = function(value) {
        if (value == 0) 
            return 1;
        var mask = -72057594037927936;
        var i = 0;
         while ((value & (mask >>> 8 * i)) == 0 && i < 8)
            i++;
        return 8 - i;
    };
}, {data: "ByteBuffer", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlString = function(id) {
    EbmlBin.call(this, id);
};
EbmlString = stjs.extend(EbmlString, EbmlBin, [], function(constructor, prototype) {
    prototype.charset = "UTF-8";
    constructor.createEbmlString = function(id, value) {
        var e = new EbmlString(id);
        e.setString(value);
        return e;
    };
    prototype.getString = function() {
        try {
            return new String(this.data.array(), this.charset);
        }catch (ex) {
            ex.printStackTrace();
            return "";
        }
    };
    prototype.setString = function(value) {
        try {
            this.data = ByteBuffer.wrap(value.getBytes(this.charset));
        }catch (ex) {
            ex.printStackTrace();
        }
    };
}, {data: "ByteBuffer", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlUlong = function(id) {
    EbmlBin.call(this, id);
    this.data = ByteBuffer.allocate(8);
};
EbmlUlong = stjs.extend(EbmlUlong, EbmlBin, [], function(constructor, prototype) {
    constructor.createEbmlUlong = function(id, value) {
        var e = new EbmlUlong(id);
        e.setUlong(value);
        return e;
    };
    prototype.setUlong = function(value) {
        this.data.putLong(value);
        this.data.flip();
    };
    prototype.getUlong = function() {
        return this.data.duplicate().getLong();
    };
}, {data: "ByteBuffer", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Constants for MPEG1 layer 2 and 3
 *  
 *  @author The JCodec project
 */
var MpaConst = function() {};
MpaConst = stjs.extend(MpaConst, null, [], function(constructor, prototype) {
    constructor.MPEG2_LSF = 0;
    constructor.MPEG1 = 1;
    constructor.MPEG25_LSF = 2;
    constructor.STEREO = 0;
    constructor.JOINT_STEREO = 1;
    constructor.DUAL_CHANNEL = 2;
    constructor.SINGLE_CHANNEL = 3;
    constructor.SAMPLE_FREQ_48K = 1;
    constructor.SAMPLE_FREQ_32K = 2;
    constructor.frequencies = [new Int32Array([22050, 24000, 16000, 1]), new Int32Array([44100, 48000, 32000, 1]), new Int32Array([11025, 12000, 8000, 1])];
    constructor.bitrates = [[new Int32Array([0, 32000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 144000, 160000, 176000, 192000, 224000, 256000, 0]), new Int32Array([0, 8000, 16000, 24000, 32000, 40000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 144000, 160000, 0]), new Int32Array([0, 8000, 16000, 24000, 32000, 40000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 144000, 160000, 0])], [new Int32Array([0, 32000, 64000, 96000, 128000, 160000, 192000, 224000, 256000, 288000, 320000, 352000, 384000, 416000, 448000, 0]), new Int32Array([0, 32000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 160000, 192000, 224000, 256000, 320000, 384000, 0]), new Int32Array([0, 32000, 40000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 160000, 192000, 224000, 256000, 320000, 0])], [new Int32Array([0, 32000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 144000, 160000, 176000, 192000, 224000, 256000, 0]), new Int32Array([0, 8000, 16000, 24000, 32000, 40000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 144000, 160000, 0]), new Int32Array([0, 8000, 16000, 24000, 32000, 40000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 144000, 160000, 0])]];
    constructor.sfbLong = [new Int32Array([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576]), new Int32Array([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 114, 136, 162, 194, 232, 278, 330, 394, 464, 540, 576]), new Int32Array([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576]), new Int32Array([0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 52, 62, 74, 90, 110, 134, 162, 196, 238, 288, 342, 418, 576]), new Int32Array([0, 4, 8, 12, 16, 20, 24, 30, 36, 42, 50, 60, 72, 88, 106, 128, 156, 190, 230, 276, 330, 384, 576]), new Int32Array([0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 54, 66, 82, 102, 126, 156, 194, 240, 296, 364, 448, 550, 576]), new Int32Array([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576]), new Int32Array([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576]), new Int32Array([0, 12, 24, 36, 48, 60, 72, 88, 108, 132, 160, 192, 232, 280, 336, 400, 476, 566, 568, 570, 572, 574, 576])];
    constructor.sfbShort = [new Int32Array([0, 4, 8, 12, 18, 24, 32, 42, 56, 74, 100, 132, 174, 192]), new Int32Array([0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 136, 180, 192]), new Int32Array([0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 134, 174, 192]), new Int32Array([0, 4, 8, 12, 16, 22, 30, 40, 52, 66, 84, 106, 136, 192]), new Int32Array([0, 4, 8, 12, 16, 22, 28, 38, 50, 64, 80, 100, 126, 192]), new Int32Array([0, 4, 8, 12, 16, 22, 30, 42, 58, 78, 104, 138, 180, 192]), new Int32Array([0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 134, 174, 192]), new Int32Array([0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 134, 174, 192]), new Int32Array([0, 8, 16, 24, 36, 52, 72, 96, 124, 160, 162, 164, 166, 192])];
    constructor.scaleFactorLen = [new Int32Array([0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4]), new Int32Array([0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3])];
    constructor.pretab = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 3, 3, 3, 2, 0]);
    constructor.quantizerTab = new Float32Array([1.0, 0.70710677, 0.5, 0.35355338, 0.25, 0.17677669, 0.125, 0.088388346, 0.0625, 0.044194173, 0.03125, 0.022097087, 0.015625, 0.011048543, 0.0078125, 0.0055242716, 0.00390625, 0.0027621358, 0.001953125, 0.0013810679, 9.765625E-4, 6.9053395E-4, 4.8828125E-4, 3.4526698E-4, 2.4414062E-4, 1.7263349E-4, 1.2207031E-4, 8.6316744E-5, 6.1035156E-5, 4.3158372E-5, 3.0517578E-5, 2.1579186E-5, 1.5258789E-5, 1.0789593E-5, 7.6293945E-6, 5.3947965E-6, 3.8146973E-6, 2.6973983E-6, 1.9073486E-6, 1.3486991E-6, 9.536743E-7, 6.7434956E-7, 4.7683716E-7, 3.3717478E-7, 2.3841858E-7, 1.6858739E-7, 1.1920929E-7, 8.4293696E-8, 5.9604645E-8, 4.2146848E-8, 2.9802322E-8, 2.1073424E-8, 1.4901161E-8, 1.0536712E-8, 7.4505806E-9, 5.268356E-9, 3.7252903E-9, 2.634178E-9, 1.8626451E-9, 1.317089E-9, 9.313226E-10, 6.585445E-10, 4.656613E-10, 3.2927225E-10]);
    constructor.create_t_43 = function() {
        var t43 = new Float32Array(8192);
        var d43 = (4.0 / 3.0);
        for (var i = 0; i < 8192; i++) {
            t43[i] = Math.pow(i, d43);
        }
        return t43;
    };
    constructor.power43Tab = MpaConst.create_t_43();
    constructor.intensityOffset = [new Float32Array([1.0, 0.8408964, 0.70710677, 0.59460354, 0.5, 0.4204482, 0.35355338, 0.29730177, 0.25, 0.2102241, 0.17677669, 0.14865088, 0.125, 0.10511205, 0.088388346, 0.07432544, 0.0625, 0.052556027, 0.044194173, 0.03716272, 0.03125, 0.026278013, 0.022097087, 0.01858136, 0.015625, 0.013139007, 0.011048543, 0.00929068, 0.0078125, 0.0065695033, 0.0055242716, 0.00464534]), new Float32Array([1.0, 0.70710677, 0.5, 0.35355338, 0.25, 0.17677669, 0.125, 0.088388346, 0.0625, 0.044194173, 0.03125, 0.022097087, 0.015625, 0.011048543, 0.0078125, 0.0055242716, 0.00390625, 0.0027621358, 0.001953125, 0.0013810679, 9.765625E-4, 6.9053395E-4, 4.8828125E-4, 3.4526698E-4, 2.4414062E-4, 1.7263349E-4, 1.2207031E-4, 8.6316744E-5, 6.1035156E-5, 4.3158372E-5, 3.0517578E-5, 2.1579186E-5])];
    constructor.TAN12 = new Float32Array([0.0, 0.2679492, 0.57735026, 1.0, 1.7320508, 3.732051, 9.9999998E10, -3.732051, -1.7320508, -1.0, -0.57735026, -0.2679492, 0.0, 0.2679492, 0.57735026, 1.0]);
    constructor.ll0 = new Int32Array([0, 6, 11, 16, 21]);
    constructor.ss0 = new Int32Array([0, 6, 12]);
    constructor.Sftable = function(thel, thes) {
        this.l = thel;
        this.s = thes;
    };
    constructor.Sftable = stjs.extend(constructor.Sftable, null, [], function(constructor, prototype) {
        prototype.l = null;
        prototype.s = null;
    }, {l: "Int32Array", s: "Int32Array"}, {});
    constructor.sftable = new MpaConst.Sftable(MpaConst.ll0, MpaConst.ss0);
    constructor.cs = new Float32Array([0.8574929, 0.881742, 0.94962865, 0.9833146, 0.9955178, 0.9991606, 0.9998992, 0.99999315]);
    constructor.ca = new Float32Array([-0.51449573, -0.47173196, -0.31337744, -0.1819132, -0.09457419, -0.040965583, -0.014198569, -0.0036999746]);
    constructor.win = [new Float32Array([-0.016141215, -0.05360318, -0.100707136, -0.16280818, -0.5, -0.38388735, -0.6206114, -1.1659756, -3.8720753, -4.225629, -1.519529, -0.97416484, -0.73744076, -1.2071068, -0.5163616, -0.45426053, -0.40715656, -0.3696946, -0.3387627, -0.31242222, -0.28939587, -0.26880082, -0.5, -0.23251417, -0.21596715, -0.20004979, -0.18449493, -0.16905846, -0.15350361, -0.13758625, -0.12103922, -0.20710678, -0.084752575, -0.06415752, -0.041131172, -0.014790705]), new Float32Array([-0.016141215, -0.05360318, -0.100707136, -0.16280818, -0.5, -0.38388735, -0.6206114, -1.1659756, -3.8720753, -4.225629, -1.519529, -0.97416484, -0.73744076, -1.2071068, -0.5163616, -0.45426053, -0.40715656, -0.3696946, -0.33908543, -0.3151181, -0.29642227, -0.28184548, -0.5411961, -0.2621323, -0.25387916, -0.2329629, -0.19852729, -0.15233535, -0.0964964, -0.03342383, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]), new Float32Array([-0.0483008, -0.15715657, -0.28325045, -0.42953748, -1.2071068, -0.8242648, -1.1451749, -1.769529, -4.5470223, -3.489053, -0.7329629, -0.15076515, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]), new Float32Array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.15076514, -0.7329629, -3.489053, -4.5470223, -1.769529, -1.1451749, -0.8313774, -1.306563, -0.54142016, -0.46528974, -0.4106699, -0.3700468, -0.3387627, -0.31242222, -0.28939587, -0.26880082, -0.5, -0.23251417, -0.21596715, -0.20004979, -0.18449493, -0.16905846, -0.15350361, -0.13758625, -0.12103922, -0.20710678, -0.084752575, -0.06415752, -0.041131172, -0.014790705])];
    constructor.numberOfScaleFactors = [[new Int32Array([6, 5, 5, 5]), new Int32Array([9, 9, 9, 9]), new Int32Array([6, 9, 9, 9])], [new Int32Array([6, 5, 7, 3]), new Int32Array([9, 9, 12, 6]), new Int32Array([6, 9, 12, 6])], [new Int32Array([11, 10, 0, 0]), new Int32Array([18, 18, 0, 0]), new Int32Array([15, 18, 0, 0])], [new Int32Array([7, 7, 7, 0]), new Int32Array([12, 12, 12, 0]), new Int32Array([6, 15, 12, 0])], [new Int32Array([6, 6, 6, 3]), new Int32Array([12, 9, 9, 6]), new Int32Array([6, 12, 9, 6])], [new Int32Array([8, 8, 5, 0]), new Int32Array([15, 12, 9, 0]), new Int32Array([6, 18, 9, 0])]];
    constructor.dp = new Float32Array([0.0, -4.42505E-4, 0.003250122, -0.007003784, 0.031082153, -0.07862854, 0.10031128, -0.57203674, 1.144989, 0.57203674, 0.10031128, 0.07862854, 0.031082153, 0.007003784, 0.003250122, 4.42505E-4, -1.5259E-5, -4.73022E-4, 0.003326416, -0.007919312, 0.030517578, -0.08418274, 0.090927124, -0.6002197, 1.1442871, 0.54382324, 0.1088562, 0.07305908, 0.03147888, 0.006118774, 0.003173828, 3.96729E-4, -1.5259E-5, -5.34058E-4, 0.003387451, -0.008865356, 0.029785156, -0.08970642, 0.08068848, -0.6282959, 1.1422119, 0.51560974, 0.11657715, 0.06752014, 0.03173828, 0.0052948, 0.003082275, 3.66211E-4, -1.5259E-5, -5.79834E-4, 0.003433228, -0.009841919, 0.028884888, -0.09516907, 0.06959534, -0.6562195, 1.1387634, 0.48747253, 0.12347412, 0.06199646, 0.031845093, 0.004486084, 0.002990723, 3.20435E-4, -1.5259E-5, -6.2561E-4, 0.003463745, -0.010848999, 0.027801514, -0.10054016, 0.057617188, -0.6839142, 1.1339264, 0.45947266, 0.12957764, 0.056533813, 0.031814575, 0.003723145, 0.00289917, 2.89917E-4, -1.5259E-5, -6.86646E-4, 0.003479004, -0.011886597, 0.026535034, -0.1058197, 0.044784546, -0.71131897, 1.1277466, 0.43165588, 0.1348877, 0.051132202, 0.031661987, 0.003005981, 0.002792358, 2.59399E-4, -1.5259E-5, -7.47681E-4, 0.003479004, -0.012939453, 0.02508545, -0.110946655, 0.031082153, -0.7383728, 1.120224, 0.40408325, 0.13945007, 0.045837402, 0.03138733, 0.002334595, 0.002685547, 2.44141E-4, -3.0518E-5, -8.08716E-4, 0.003463745, -0.014022827, 0.023422241, -0.11592102, 0.01651001, -0.7650299, 1.1113739, 0.37680054, 0.14326477, 0.040634155, 0.03100586, 0.001693726, 0.002578735, 2.13623E-4, -3.0518E-5, -8.8501E-4, 0.003417969, -0.01512146, 0.021575928, -0.12069702, 0.001068115, -0.791214, 1.1012115, 0.34986877, 0.1463623, 0.03555298, 0.030532837, 0.001098633, 0.002456665, 1.98364E-4, -3.0518E-5, -9.61304E-4, 0.003372192, -0.016235352, 0.01953125, -0.1252594, -0.015228271, -0.816864, 1.0897827, 0.32331848, 0.1487732, 0.03060913, 0.029937744, 5.49316E-4, 0.002349854, 1.67847E-4, -3.0518E-5, -0.001037598, 0.00328064, -0.017349243, 0.01725769, -0.12956238, -0.03237915, -0.84194946, 1.0771179, 0.2972107, 0.15049744, 0.025817871, 0.029281616, 3.0518E-5, 0.002243042, 1.52588E-4, -4.5776E-5, -0.001113892, 0.003173828, -0.018463135, 0.014801025, -0.1335907, -0.050354004, -0.8663635, 1.0632172, 0.2715912, 0.15159607, 0.0211792, 0.028533936, -4.42505E-4, 0.002120972, 1.37329E-4, -4.5776E-5, -0.001205444, 0.003051758, -0.019577026, 0.012115479, -0.13729858, -0.06916809, -0.89009094, 1.0481567, 0.24650574, 0.15206909, 0.016708374, 0.02772522, -8.69751E-4, 0.00201416, 1.2207E-4, -6.1035E-5, -0.001296997, 0.002883911, -0.020690918, 0.009231567, -0.14067078, -0.088775635, -0.9130554, 1.0319366, 0.22198486, 0.15196228, 0.012420654, 0.02684021, -0.001266479, 0.001907349, 1.06812E-4, -6.1035E-5, -0.00138855, 0.002700806, -0.02178955, 0.006134033, -0.14367676, -0.10916138, -0.9351959, 1.0146179, 0.19805908, 0.15130615, 0.00831604, 0.025909424, -0.001617432, 0.001785278, 1.06812E-4, -7.6294E-5, -0.001480103, 0.002487183, -0.022857666, 0.002822876, -0.1462555, -0.13031006, -0.95648193, 0.99624634, 0.17478943, 0.15011597, 0.004394531, 0.024932861, -0.001937866, 0.001693726, 9.1553E-5, -7.6294E-5, -0.001586914, 0.002227783, -0.023910522, -6.86646E-4, -0.14842224, -0.15220642, -0.9768524, 0.9768524, 0.15220642, 0.14842224, 6.86646E-4, 0.023910522, -0.002227783, 0.001586914, 7.6294E-5, -9.1553E-5, -0.001693726, 0.001937866, -0.024932861, -0.004394531, -0.15011597, -0.17478943, -0.99624634, 0.95648193, 0.13031006, 0.1462555, -0.002822876, 0.022857666, -0.002487183, 0.001480103, 7.6294E-5, -1.06812E-4, -0.001785278, 0.001617432, -0.025909424, -0.00831604, -0.15130615, -0.19805908, -1.0146179, 0.9351959, 0.10916138, 0.14367676, -0.006134033, 0.02178955, -0.002700806, 0.00138855, 6.1035E-5, -1.06812E-4, -0.001907349, 0.001266479, -0.02684021, -0.012420654, -0.15196228, -0.22198486, -1.0319366, 0.9130554, 0.088775635, 0.14067078, -0.009231567, 0.020690918, -0.002883911, 0.001296997, 6.1035E-5, -1.2207E-4, -0.00201416, 8.69751E-4, -0.02772522, -0.016708374, -0.15206909, -0.24650574, -1.0481567, 0.89009094, 0.06916809, 0.13729858, -0.012115479, 0.019577026, -0.003051758, 0.001205444, 4.5776E-5, -1.37329E-4, -0.002120972, 4.42505E-4, -0.028533936, -0.0211792, -0.15159607, -0.2715912, -1.0632172, 0.8663635, 0.050354004, 0.1335907, -0.014801025, 0.018463135, -0.003173828, 0.001113892, 4.5776E-5, -1.52588E-4, -0.002243042, -3.0518E-5, -0.029281616, -0.025817871, -0.15049744, -0.2972107, -1.0771179, 0.84194946, 0.03237915, 0.12956238, -0.01725769, 0.017349243, -0.00328064, 0.001037598, 3.0518E-5, -1.67847E-4, -0.002349854, -5.49316E-4, -0.029937744, -0.03060913, -0.1487732, -0.32331848, -1.0897827, 0.816864, 0.015228271, 0.1252594, -0.01953125, 0.016235352, -0.003372192, 9.61304E-4, 3.0518E-5, -1.98364E-4, -0.002456665, -0.001098633, -0.030532837, -0.03555298, -0.1463623, -0.34986877, -1.1012115, 0.791214, -0.001068115, 0.12069702, -0.021575928, 0.01512146, -0.003417969, 8.8501E-4, 3.0518E-5, -2.13623E-4, -0.002578735, -0.001693726, -0.03100586, -0.040634155, -0.14326477, -0.37680054, -1.1113739, 0.7650299, -0.01651001, 0.11592102, -0.023422241, 0.014022827, -0.003463745, 8.08716E-4, 3.0518E-5, -2.44141E-4, -0.002685547, -0.002334595, -0.03138733, -0.045837402, -0.13945007, -0.40408325, -1.120224, 0.7383728, -0.031082153, 0.110946655, -0.02508545, 0.012939453, -0.003479004, 7.47681E-4, 1.5259E-5, -2.59399E-4, -0.002792358, -0.003005981, -0.031661987, -0.051132202, -0.1348877, -0.43165588, -1.1277466, 0.71131897, -0.044784546, 0.1058197, -0.026535034, 0.011886597, -0.003479004, 6.86646E-4, 1.5259E-5, -2.89917E-4, -0.00289917, -0.003723145, -0.031814575, -0.056533813, -0.12957764, -0.45947266, -1.1339264, 0.6839142, -0.057617188, 0.10054016, -0.027801514, 0.010848999, -0.003463745, 6.2561E-4, 1.5259E-5, -3.20435E-4, -0.002990723, -0.004486084, -0.031845093, -0.06199646, -0.12347412, -0.48747253, -1.1387634, 0.6562195, -0.06959534, 0.09516907, -0.028884888, 0.009841919, -0.003433228, 5.79834E-4, 1.5259E-5, -3.66211E-4, -0.003082275, -0.0052948, -0.03173828, -0.06752014, -0.11657715, -0.51560974, -1.1422119, 0.6282959, -0.08068848, 0.08970642, -0.029785156, 0.008865356, -0.003387451, 5.34058E-4, 1.5259E-5, -3.96729E-4, -0.003173828, -0.006118774, -0.03147888, -0.07305908, -0.1088562, -0.54382324, -1.1442871, 0.6002197, -0.090927124, 0.08418274, -0.030517578, 0.007919312, -0.003326416, 4.73022E-4, 1.5259E-5]);
    constructor.grouping5Bits = new Float32Array([-2.0 / 3.0, -2.0 / 3.0, -2.0 / 3.0, 0.0, -2.0 / 3.0, -2.0 / 3.0, 2.0 / 3.0, -2.0 / 3.0, -2.0 / 3.0, -2.0 / 3.0, 0.0, -2.0 / 3.0, 0.0, 0.0, -2.0 / 3.0, 2.0 / 3.0, 0.0, -2.0 / 3.0, -2.0 / 3.0, 2.0 / 3.0, -2.0 / 3.0, 0.0, 2.0 / 3.0, -2.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0, -2.0 / 3.0, -2.0 / 3.0, -2.0 / 3.0, 0.0, 0.0, -2.0 / 3.0, 0.0, 2.0 / 3.0, -2.0 / 3.0, 0.0, -2.0 / 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.0 / 3.0, 0.0, 0.0, -2.0 / 3.0, 2.0 / 3.0, 0.0, 0.0, 2.0 / 3.0, 0.0, 2.0 / 3.0, 2.0 / 3.0, 0.0, -2.0 / 3.0, -2.0 / 3.0, 2.0 / 3.0, 0.0, -2.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0, -2.0 / 3.0, 2.0 / 3.0, -2.0 / 3.0, 0.0, 2.0 / 3.0, 0.0, 0.0, 2.0 / 3.0, 2.0 / 3.0, 0.0, 2.0 / 3.0, -2.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0, 0.0, 2.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0]);
    constructor.grouping7Bits = new Float32Array([-0.8, -0.8, -0.8, -0.4, -0.8, -0.8, 0.0, -0.8, -0.8, 0.4, -0.8, -0.8, 0.8, -0.8, -0.8, -0.8, -0.4, -0.8, -0.4, -0.4, -0.8, 0.0, -0.4, -0.8, 0.4, -0.4, -0.8, 0.8, -0.4, -0.8, -0.8, 0.0, -0.8, -0.4, 0.0, -0.8, 0.0, 0.0, -0.8, 0.4, 0.0, -0.8, 0.8, 0.0, -0.8, -0.8, 0.4, -0.8, -0.4, 0.4, -0.8, 0.0, 0.4, -0.8, 0.4, 0.4, -0.8, 0.8, 0.4, -0.8, -0.8, 0.8, -0.8, -0.4, 0.8, -0.8, 0.0, 0.8, -0.8, 0.4, 0.8, -0.8, 0.8, 0.8, -0.8, -0.8, -0.8, -0.4, -0.4, -0.8, -0.4, 0.0, -0.8, -0.4, 0.4, -0.8, -0.4, 0.8, -0.8, -0.4, -0.8, -0.4, -0.4, -0.4, -0.4, -0.4, 0.0, -0.4, -0.4, 0.4, -0.4, -0.4, 0.8, -0.4, -0.4, -0.8, 0.0, -0.4, -0.4, 0.0, -0.4, 0.0, 0.0, -0.4, 0.4, 0.0, -0.4, 0.8, 0.0, -0.4, -0.8, 0.4, -0.4, -0.4, 0.4, -0.4, 0.0, 0.4, -0.4, 0.4, 0.4, -0.4, 0.8, 0.4, -0.4, -0.8, 0.8, -0.4, -0.4, 0.8, -0.4, 0.0, 0.8, -0.4, 0.4, 0.8, -0.4, 0.8, 0.8, -0.4, -0.8, -0.8, 0.0, -0.4, -0.8, 0.0, 0.0, -0.8, 0.0, 0.4, -0.8, 0.0, 0.8, -0.8, 0.0, -0.8, -0.4, 0.0, -0.4, -0.4, 0.0, 0.0, -0.4, 0.0, 0.4, -0.4, 0.0, 0.8, -0.4, 0.0, -0.8, 0.0, 0.0, -0.4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.4, 0.0, 0.0, 0.8, 0.0, 0.0, -0.8, 0.4, 0.0, -0.4, 0.4, 0.0, 0.0, 0.4, 0.0, 0.4, 0.4, 0.0, 0.8, 0.4, 0.0, -0.8, 0.8, 0.0, -0.4, 0.8, 0.0, 0.0, 0.8, 0.0, 0.4, 0.8, 0.0, 0.8, 0.8, 0.0, -0.8, -0.8, 0.4, -0.4, -0.8, 0.4, 0.0, -0.8, 0.4, 0.4, -0.8, 0.4, 0.8, -0.8, 0.4, -0.8, -0.4, 0.4, -0.4, -0.4, 0.4, 0.0, -0.4, 0.4, 0.4, -0.4, 0.4, 0.8, -0.4, 0.4, -0.8, 0.0, 0.4, -0.4, 0.0, 0.4, 0.0, 0.0, 0.4, 0.4, 0.0, 0.4, 0.8, 0.0, 0.4, -0.8, 0.4, 0.4, -0.4, 0.4, 0.4, 0.0, 0.4, 0.4, 0.4, 0.4, 0.4, 0.8, 0.4, 0.4, -0.8, 0.8, 0.4, -0.4, 0.8, 0.4, 0.0, 0.8, 0.4, 0.4, 0.8, 0.4, 0.8, 0.8, 0.4, -0.8, -0.8, 0.8, -0.4, -0.8, 0.8, 0.0, -0.8, 0.8, 0.4, -0.8, 0.8, 0.8, -0.8, 0.8, -0.8, -0.4, 0.8, -0.4, -0.4, 0.8, 0.0, -0.4, 0.8, 0.4, -0.4, 0.8, 0.8, -0.4, 0.8, -0.8, 0.0, 0.8, -0.4, 0.0, 0.8, 0.0, 0.0, 0.8, 0.4, 0.0, 0.8, 0.8, 0.0, 0.8, -0.8, 0.4, 0.8, -0.4, 0.4, 0.8, 0.0, 0.4, 0.8, 0.4, 0.4, 0.8, 0.8, 0.4, 0.8, -0.8, 0.8, 0.8, -0.4, 0.8, 0.8, 0.0, 0.8, 0.8, 0.4, 0.8, 0.8, 0.8, 0.8, 0.8]);
    constructor.grouping10Bits = new Float32Array([-8.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, 0.0, -8.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, 0.0, -6.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, 0.0, -4.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, 0.0, -2.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, 0.0, -8.0 / 9.0, -6.0 / 9.0, 0.0, -8.0 / 9.0, -4.0 / 9.0, 0.0, -8.0 / 9.0, -2.0 / 9.0, 0.0, -8.0 / 9.0, 0.0, 0.0, -8.0 / 9.0, 2.0 / 9.0, 0.0, -8.0 / 9.0, 4.0 / 9.0, 0.0, -8.0 / 9.0, 6.0 / 9.0, 0.0, -8.0 / 9.0, 8.0 / 9.0, 0.0, -8.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, 0.0, 2.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, 0.0, 4.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, 0.0, 6.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, 0.0, 8.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, 0.0, -8.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, 0.0, -6.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, 0.0, -4.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, 0.0, -2.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, 0.0, -6.0 / 9.0, -6.0 / 9.0, 0.0, -6.0 / 9.0, -4.0 / 9.0, 0.0, -6.0 / 9.0, -2.0 / 9.0, 0.0, -6.0 / 9.0, 0.0, 0.0, -6.0 / 9.0, 2.0 / 9.0, 0.0, -6.0 / 9.0, 4.0 / 9.0, 0.0, -6.0 / 9.0, 6.0 / 9.0, 0.0, -6.0 / 9.0, 8.0 / 9.0, 0.0, -6.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, 0.0, 2.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, 0.0, 4.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, 0.0, 6.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, 0.0, 8.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, 0.0, -8.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, 0.0, -6.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, 0.0, -4.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, 0.0, -2.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, 0.0, -4.0 / 9.0, -6.0 / 9.0, 0.0, -4.0 / 9.0, -4.0 / 9.0, 0.0, -4.0 / 9.0, -2.0 / 9.0, 0.0, -4.0 / 9.0, 0.0, 0.0, -4.0 / 9.0, 2.0 / 9.0, 0.0, -4.0 / 9.0, 4.0 / 9.0, 0.0, -4.0 / 9.0, 6.0 / 9.0, 0.0, -4.0 / 9.0, 8.0 / 9.0, 0.0, -4.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, 0.0, 2.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, 0.0, 4.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, 0.0, 6.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, 0.0, 8.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, 0.0, -8.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, 0.0, -6.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, 0.0, -4.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, 0.0, -2.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, 0.0, -2.0 / 9.0, -6.0 / 9.0, 0.0, -2.0 / 9.0, -4.0 / 9.0, 0.0, -2.0 / 9.0, -2.0 / 9.0, 0.0, -2.0 / 9.0, 0.0, 0.0, -2.0 / 9.0, 2.0 / 9.0, 0.0, -2.0 / 9.0, 4.0 / 9.0, 0.0, -2.0 / 9.0, 6.0 / 9.0, 0.0, -2.0 / 9.0, 8.0 / 9.0, 0.0, -2.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, 0.0, 2.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, 0.0, 4.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, 0.0, 6.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, 0.0, 8.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, 0.0, -6.0 / 9.0, -8.0 / 9.0, 0.0, -4.0 / 9.0, -8.0 / 9.0, 0.0, -2.0 / 9.0, -8.0 / 9.0, 0.0, 0.0, -8.0 / 9.0, 0.0, 2.0 / 9.0, -8.0 / 9.0, 0.0, 4.0 / 9.0, -8.0 / 9.0, 0.0, 6.0 / 9.0, -8.0 / 9.0, 0.0, 8.0 / 9.0, -8.0 / 9.0, 0.0, -8.0 / 9.0, -6.0 / 9.0, 0.0, -6.0 / 9.0, -6.0 / 9.0, 0.0, -4.0 / 9.0, -6.0 / 9.0, 0.0, -2.0 / 9.0, -6.0 / 9.0, 0.0, 0.0, -6.0 / 9.0, 0.0, 2.0 / 9.0, -6.0 / 9.0, 0.0, 4.0 / 9.0, -6.0 / 9.0, 0.0, 6.0 / 9.0, -6.0 / 9.0, 0.0, 8.0 / 9.0, -6.0 / 9.0, 0.0, -8.0 / 9.0, -4.0 / 9.0, 0.0, -6.0 / 9.0, -4.0 / 9.0, 0.0, -4.0 / 9.0, -4.0 / 9.0, 0.0, -2.0 / 9.0, -4.0 / 9.0, 0.0, 0.0, -4.0 / 9.0, 0.0, 2.0 / 9.0, -4.0 / 9.0, 0.0, 4.0 / 9.0, -4.0 / 9.0, 0.0, 6.0 / 9.0, -4.0 / 9.0, 0.0, 8.0 / 9.0, -4.0 / 9.0, 0.0, -8.0 / 9.0, -2.0 / 9.0, 0.0, -6.0 / 9.0, -2.0 / 9.0, 0.0, -4.0 / 9.0, -2.0 / 9.0, 0.0, -2.0 / 9.0, -2.0 / 9.0, 0.0, 0.0, -2.0 / 9.0, 0.0, 2.0 / 9.0, -2.0 / 9.0, 0.0, 4.0 / 9.0, -2.0 / 9.0, 0.0, 6.0 / 9.0, -2.0 / 9.0, 0.0, 8.0 / 9.0, -2.0 / 9.0, 0.0, -8.0 / 9.0, 0.0, 0.0, -6.0 / 9.0, 0.0, 0.0, -4.0 / 9.0, 0.0, 0.0, -2.0 / 9.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.0 / 9.0, 0.0, 0.0, 4.0 / 9.0, 0.0, 0.0, 6.0 / 9.0, 0.0, 0.0, 8.0 / 9.0, 0.0, 0.0, -8.0 / 9.0, 2.0 / 9.0, 0.0, -6.0 / 9.0, 2.0 / 9.0, 0.0, -4.0 / 9.0, 2.0 / 9.0, 0.0, -2.0 / 9.0, 2.0 / 9.0, 0.0, 0.0, 2.0 / 9.0, 0.0, 2.0 / 9.0, 2.0 / 9.0, 0.0, 4.0 / 9.0, 2.0 / 9.0, 0.0, 6.0 / 9.0, 2.0 / 9.0, 0.0, 8.0 / 9.0, 2.0 / 9.0, 0.0, -8.0 / 9.0, 4.0 / 9.0, 0.0, -6.0 / 9.0, 4.0 / 9.0, 0.0, -4.0 / 9.0, 4.0 / 9.0, 0.0, -2.0 / 9.0, 4.0 / 9.0, 0.0, 0.0, 4.0 / 9.0, 0.0, 2.0 / 9.0, 4.0 / 9.0, 0.0, 4.0 / 9.0, 4.0 / 9.0, 0.0, 6.0 / 9.0, 4.0 / 9.0, 0.0, 8.0 / 9.0, 4.0 / 9.0, 0.0, -8.0 / 9.0, 6.0 / 9.0, 0.0, -6.0 / 9.0, 6.0 / 9.0, 0.0, -4.0 / 9.0, 6.0 / 9.0, 0.0, -2.0 / 9.0, 6.0 / 9.0, 0.0, 0.0, 6.0 / 9.0, 0.0, 2.0 / 9.0, 6.0 / 9.0, 0.0, 4.0 / 9.0, 6.0 / 9.0, 0.0, 6.0 / 9.0, 6.0 / 9.0, 0.0, 8.0 / 9.0, 6.0 / 9.0, 0.0, -8.0 / 9.0, 8.0 / 9.0, 0.0, -6.0 / 9.0, 8.0 / 9.0, 0.0, -4.0 / 9.0, 8.0 / 9.0, 0.0, -2.0 / 9.0, 8.0 / 9.0, 0.0, 0.0, 8.0 / 9.0, 0.0, 2.0 / 9.0, 8.0 / 9.0, 0.0, 4.0 / 9.0, 8.0 / 9.0, 0.0, 6.0 / 9.0, 8.0 / 9.0, 0.0, 8.0 / 9.0, 8.0 / 9.0, 0.0, -8.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, 0.0, -8.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, 0.0, -6.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, 0.0, -4.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, 0.0, -2.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, 0.0, 2.0 / 9.0, -6.0 / 9.0, 0.0, 2.0 / 9.0, -4.0 / 9.0, 0.0, 2.0 / 9.0, -2.0 / 9.0, 0.0, 2.0 / 9.0, 0.0, 0.0, 2.0 / 9.0, 2.0 / 9.0, 0.0, 2.0 / 9.0, 4.0 / 9.0, 0.0, 2.0 / 9.0, 6.0 / 9.0, 0.0, 2.0 / 9.0, 8.0 / 9.0, 0.0, 2.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, 0.0, 2.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, 0.0, 4.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, 0.0, 6.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, 0.0, 8.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, 0.0, -8.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, 0.0, -6.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, 0.0, -4.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, 0.0, -2.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, 0.0, 4.0 / 9.0, -6.0 / 9.0, 0.0, 4.0 / 9.0, -4.0 / 9.0, 0.0, 4.0 / 9.0, -2.0 / 9.0, 0.0, 4.0 / 9.0, 0.0, 0.0, 4.0 / 9.0, 2.0 / 9.0, 0.0, 4.0 / 9.0, 4.0 / 9.0, 0.0, 4.0 / 9.0, 6.0 / 9.0, 0.0, 4.0 / 9.0, 8.0 / 9.0, 0.0, 4.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, 0.0, 2.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, 0.0, 4.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, 0.0, 6.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, 0.0, 8.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, 0.0, -8.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, 0.0, -6.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, 0.0, -4.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, 0.0, -2.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, 0.0, 6.0 / 9.0, -6.0 / 9.0, 0.0, 6.0 / 9.0, -4.0 / 9.0, 0.0, 6.0 / 9.0, -2.0 / 9.0, 0.0, 6.0 / 9.0, 0.0, 0.0, 6.0 / 9.0, 2.0 / 9.0, 0.0, 6.0 / 9.0, 4.0 / 9.0, 0.0, 6.0 / 9.0, 6.0 / 9.0, 0.0, 6.0 / 9.0, 8.0 / 9.0, 0.0, 6.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, 0.0, 2.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, 0.0, 4.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, 0.0, 6.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, 0.0, 8.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, 0.0, -8.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, 0.0, -6.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, 0.0, -4.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, 0.0, -2.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, 0.0, 8.0 / 9.0, -6.0 / 9.0, 0.0, 8.0 / 9.0, -4.0 / 9.0, 0.0, 8.0 / 9.0, -2.0 / 9.0, 0.0, 8.0 / 9.0, 0.0, 0.0, 8.0 / 9.0, 2.0 / 9.0, 0.0, 8.0 / 9.0, 4.0 / 9.0, 0.0, 8.0 / 9.0, 6.0 / 9.0, 0.0, 8.0 / 9.0, 8.0 / 9.0, 0.0, 8.0 / 9.0, -8.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, 0.0, 2.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, 0.0, 4.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, 0.0, 6.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, -8.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, -6.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, -4.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, -2.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, 0.0, 8.0 / 9.0, 8.0 / 9.0, 2.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, 6.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0, 8.0 / 9.0]);
    constructor.tableAb1CodeLength = new Int32Array([0, 5, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]);
    constructor.tableAb1Groupingtables = [null, MpaConst.grouping5Bits, null, null, null, null, null, null, null, null, null, null, null, null, null, null];
    constructor.tableAb1Factor = new Float32Array([0.0, 1.0 / 2.0, 1.0 / 4.0, 1.0 / 8.0, 1.0 / 16.0, 1.0 / 32.0, 1.0 / 64.0, 1.0 / 128.0, 1.0 / 256.0, 1.0 / 512.0, 1.0 / 1024.0, 1.0 / 2048.0, 1.0 / 4096.0, 1.0 / 8192.0, 1.0 / 16384.0, 1.0 / 32768.0]);
    constructor.tableAb1C = new Float32Array([0.0, 1.3333334, 1.1428572, 1.0666667, 1.032258, 1.0158731, 1.007874, 1.0039216, 1.0019569, 1.0009775, 1.0004885, 1.0002443, 1.0001221, 1.000061, 1.0000305, 1.0000153]);
    constructor.tableAb1D = new Float32Array([0.0, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 0.001953125, 9.765625E-4, 4.8828125E-4, 2.4414062E-4, 1.2207031E-4, 6.103516E-5, 3.051758E-5]);
    constructor.tableAb234Groupingtables = [null, MpaConst.grouping5Bits, MpaConst.grouping7Bits, null, MpaConst.grouping10Bits, null, null, null, null, null, null, null, null, null, null, null];
    constructor.tableAb2CodeLength = new Int32Array([0, 5, 7, 3, 10, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 16]);
    constructor.tableAb2Factor = new Float32Array([0.0, 1.0 / 2.0, 1.0 / 4.0, 1.0 / 4.0, 1.0 / 8.0, 1.0 / 8.0, 1.0 / 16.0, 1.0 / 32.0, 1.0 / 64.0, 1.0 / 128.0, 1.0 / 256.0, 1.0 / 512.0, 1.0 / 1024.0, 1.0 / 2048.0, 1.0 / 4096.0, 1.0 / 32768.0]);
    constructor.table_ab2_c = new Float32Array([0.0, 1.3333334, 1.6, 1.1428572, 1.7777778, 1.0666667, 1.032258, 1.0158731, 1.007874, 1.0039216, 1.0019569, 1.0009775, 1.0004885, 1.0002443, 1.0001221, 1.0000153]);
    constructor.table_ab2_d = new Float32Array([0.0, 0.5, 0.5, 0.25, 0.5, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 0.001953125, 9.765625E-4, 4.8828125E-4, 2.4414062E-4, 3.051758E-5]);
    constructor.tableAb3CodeLength = new Int32Array([0, 5, 7, 3, 10, 4, 5, 16]);
    constructor.tableAb3Factor = new Float32Array([0.0, 1.0 / 2.0, 1.0 / 4.0, 1.0 / 4.0, 1.0 / 8.0, 1.0 / 8.0, 1.0 / 16.0, 1.0 / 32768.0]);
    constructor.tableAb3C = new Float32Array([0.0, 1.3333334, 1.6, 1.1428572, 1.7777778, 1.0666667, 1.032258, 1.0000153]);
    constructor.tableAb3D = new Float32Array([0.0, 0.5, 0.5, 0.25, 0.5, 0.125, 0.0625, 3.051758E-5]);
    constructor.tableAb4CodeLength = new Int32Array([0, 5, 7, 16]);
    constructor.tableAb4Factor = new Float32Array([0.0, 1.0 / 2.0, 1.0 / 4.0, 1.0 / 32768.0]);
    constructor.tableAb4C = new Float32Array([0.0, 1.3333334, 1.6, 1.0000153]);
    constructor.tableAb4D = new Float32Array([0.0, 0.5, 0.5, 3.051758E-5]);
    constructor.tableCdCodelength = new Int32Array([0, 5, 7, 10, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
    constructor.tableCdGroupingtables = [null, MpaConst.grouping5Bits, MpaConst.grouping7Bits, MpaConst.grouping10Bits, null, null, null, null, null, null, null, null, null, null, null, null];
    constructor.tableCdFactor = new Float32Array([0.0, 1.0 / 2.0, 1.0 / 4.0, 1.0 / 8.0, 1.0 / 8.0, 1.0 / 16.0, 1.0 / 32.0, 1.0 / 64.0, 1.0 / 128.0, 1.0 / 256.0, 1.0 / 512.0, 1.0 / 1024.0, 1.0 / 2048.0, 1.0 / 4096.0, 1.0 / 8192.0, 1.0 / 16384.0]);
    constructor.tableCdC = new Float32Array([0.0, 1.3333334, 1.6, 1.7777778, 1.0666667, 1.032258, 1.0158731, 1.007874, 1.0039216, 1.0019569, 1.0009775, 1.0004885, 1.0002443, 1.0001221, 1.000061, 1.0000305]);
    constructor.tableCdD = new Float32Array([0.0, 0.5, 0.5, 0.5, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 0.001953125, 9.765625E-4, 4.8828125E-4, 2.4414062E-4, 1.2207031E-4, 6.103516E-5]);
    constructor.tab1 = VLCBuilder.createVLCBuilder(new Int32Array([1, 1, 1, 0]), new Int32Array([1, 2, 3, 3]), new Int32Array([0, 16, 1, 17])).getVLC();
    constructor.tab2 = VLCBuilder.createVLCBuilder(new Int32Array([1, 3, 2, 1, 3, 2, 1, 1, 0]), new Int32Array([1, 3, 3, 3, 5, 5, 5, 6, 6]), new Int32Array([0, 16, 1, 17, 32, 33, 18, 2, 34])).getVLC();
    constructor.tab3 = VLCBuilder.createVLCBuilder(new Int32Array([3, 2, 1, 1, 3, 2, 1, 1, 0]), new Int32Array([2, 2, 2, 3, 5, 5, 5, 6, 6]), new Int32Array([0, 1, 17, 16, 32, 33, 18, 2, 34])).getVLC();
    constructor.tab5 = VLCBuilder.createVLCBuilder(new Int32Array([1, 3, 2, 1, 7, 6, 5, 4, 7, 6, 5, 4, 1, 1, 1, 0]), new Int32Array([1, 3, 3, 3, 6, 6, 6, 6, 7, 7, 7, 7, 6, 7, 8, 8]), new Int32Array([0, 16, 1, 17, 32, 2, 33, 18, 34, 48, 3, 19, 49, 50, 35, 51])).getVLC();
    constructor.tab6 = VLCBuilder.createVLCBuilder(new Int32Array([7, 6, 2, 3, 5, 4, 3, 5, 4, 3, 2, 3, 2, 1, 1, 0]), new Int32Array([3, 3, 2, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7]), new Int32Array([0, 16, 17, 1, 32, 33, 18, 2, 34, 49, 19, 48, 50, 35, 3, 51])).getVLC();
    constructor.tab7 = VLCBuilder.createVLCBuilder(new Int32Array([1, 3, 2, 3, 11, 10, 4, 7, 13, 12, 11, 10, 19, 18, 17, 16, 7, 6, 5, 9, 8, 15, 14, 6, 11, 10, 4, 3, 5, 4, 3, 2, 3, 2, 1, 0]), new Int32Array([1, 3, 3, 4, 6, 6, 5, 6, 7, 7, 7, 7, 8, 8, 8, 8, 7, 7, 7, 8, 8, 9, 9, 8, 9, 9, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10]), new Int32Array([0, 16, 1, 17, 32, 2, 33, 18, 34, 48, 49, 19, 3, 50, 35, 4, 64, 65, 20, 66, 36, 51, 67, 80, 52, 5, 81, 21, 82, 37, 68, 53, 83, 84, 69, 85])).getVLC();
    constructor.tab8 = VLCBuilder.createVLCBuilder(new Int32Array([3, 5, 4, 1, 3, 2, 7, 6, 5, 19, 18, 17, 16, 15, 14, 13, 12, 5, 9, 8, 7, 13, 12, 11, 10, 4, 3, 5, 4, 3, 5, 4, 1, 1, 1, 0]), new Int32Array([2, 3, 3, 2, 4, 4, 6, 6, 6, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 9, 9, 9, 9, 8, 8, 9, 9, 9, 10, 10, 9, 10, 11, 11]), new Int32Array([0, 16, 1, 17, 33, 18, 32, 2, 34, 48, 3, 49, 19, 50, 35, 64, 4, 65, 20, 66, 36, 51, 80, 67, 52, 81, 21, 5, 82, 37, 68, 53, 83, 69, 84, 85])).getVLC();
    constructor.tab9 = VLCBuilder.createVLCBuilder(new Int32Array([7, 6, 5, 4, 7, 6, 5, 9, 8, 15, 14, 6, 5, 9, 8, 7, 6, 11, 10, 9, 8, 15, 14, 6, 5, 4, 7, 6, 5, 4, 7, 6, 2, 1, 1, 0]), new Int32Array([3, 3, 3, 3, 4, 4, 4, 5, 5, 6, 6, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 7, 7, 7, 8, 8, 8, 8, 9, 9, 8, 8, 9, 9]), new Int32Array([0, 16, 1, 17, 32, 33, 18, 2, 34, 48, 3, 49, 19, 50, 35, 65, 20, 64, 51, 66, 36, 4, 80, 67, 52, 81, 21, 82, 37, 68, 5, 84, 83, 53, 69, 85])).getVLC();
    constructor.tab10 = VLCBuilder.createVLCBuilder(new Int32Array([1, 3, 2, 3, 11, 10, 9, 8, 15, 14, 13, 12, 23, 22, 21, 20, 19, 18, 35, 34, 33, 32, 31, 30, 14, 13, 12, 47, 46, 22, 21, 41, 40, 19, 18, 8, 7, 27, 26, 12, 23, 22, 10, 9, 17, 16, 7, 6, 11, 21, 20, 9, 8, 7, 6, 5, 4, 3, 5, 4, 3, 2, 1, 0]), new Int32Array([1, 3, 3, 4, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 8, 8, 8, 10, 10, 9, 9, 10, 10, 9, 9, 8, 8, 10, 10, 9, 10, 10, 9, 9, 10, 10, 9, 9, 10, 11, 11, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11]), new Int32Array([0, 16, 1, 17, 32, 2, 33, 18, 34, 48, 49, 19, 3, 50, 35, 64, 65, 20, 4, 51, 66, 36, 80, 5, 96, 97, 22, 67, 52, 81, 21, 82, 37, 38, 54, 113, 23, 68, 83, 6, 53, 69, 98, 112, 7, 100, 114, 39, 99, 84, 85, 70, 115, 55, 101, 86, 116, 71, 102, 117, 87, 118, 103, 119])).getVLC();
    constructor.tab11 = VLCBuilder.createVLCBuilder(new Int32Array([3, 5, 4, 3, 11, 10, 4, 7, 13, 25, 24, 11, 10, 19, 18, 35, 34, 33, 32, 31, 30, 59, 58, 28, 27, 26, 12, 11, 21, 20, 9, 17, 33, 32, 31, 30, 14, 13, 12, 11, 10, 4, 15, 14, 6, 5, 19, 18, 17, 16, 7, 6, 5, 9, 8, 15, 14, 6, 5, 4, 3, 2, 1, 0]), new Int32Array([2, 3, 3, 3, 5, 5, 4, 5, 6, 7, 7, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 8, 8, 8, 7, 7, 8, 8, 7, 8, 9, 9, 9, 9, 8, 8, 8, 8, 8, 7, 9, 9, 8, 8, 10, 10, 10, 10, 9, 9, 9, 10, 10, 11, 11, 10, 10, 10, 10, 10, 10, 10]), new Int32Array([0, 16, 1, 17, 32, 2, 18, 33, 34, 48, 3, 49, 19, 50, 35, 64, 4, 65, 20, 66, 36, 51, 67, 80, 52, 81, 97, 22, 6, 38, 98, 21, 5, 82, 37, 68, 96, 99, 54, 112, 23, 113, 7, 100, 114, 39, 83, 53, 84, 69, 70, 115, 55, 101, 86, 85, 87, 116, 71, 102, 117, 118, 103, 119])).getVLC();
    constructor.tab12 = VLCBuilder.createVLCBuilder(new Int32Array([7, 6, 5, 9, 17, 16, 7, 6, 11, 10, 9, 17, 33, 32, 15, 14, 13, 12, 23, 22, 21, 41, 40, 19, 18, 17, 16, 31, 30, 29, 28, 27, 26, 12, 11, 10, 39, 38, 18, 17, 16, 15, 14, 27, 26, 12, 11, 10, 9, 8, 7, 13, 12, 5, 4, 7, 6, 5, 4, 3, 2, 1, 1, 0]), new Int32Array([3, 3, 3, 4, 5, 5, 4, 4, 5, 5, 5, 6, 7, 7, 6, 6, 6, 6, 7, 7, 7, 8, 8, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 7, 7, 7, 9, 9, 8, 8, 8, 8, 8, 9, 9, 8, 8, 8, 8, 8, 8, 9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10]), new Int32Array([16, 1, 17, 0, 32, 2, 33, 18, 34, 49, 19, 48, 3, 64, 50, 35, 65, 51, 20, 66, 36, 4, 80, 67, 52, 81, 21, 82, 37, 83, 53, 96, 22, 97, 98, 38, 5, 6, 68, 84, 69, 99, 54, 112, 7, 113, 23, 100, 70, 114, 39, 85, 115, 55, 86, 101, 116, 71, 102, 117, 87, 118, 103, 119])).getVLC();
    constructor.tab13 = VLCBuilder.createVLCBuilder(new Int32Array([1, 3, 5, 4, 15, 14, 13, 12, 23, 22, 21, 20, 19, 37, 36, 35, 34, 16, 31, 61, 60, 59, 58, 57, 56, 27, 26, 51, 50, 49, 97, 96, 47, 46, 45, 44, 43, 42, 20, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 34, 33, 65, 64, 31, 30, 29, 115, 114, 56, 55, 54, 53, 52, 25, 24, 95, 94, 93, 92, 91, 90, 44, 43, 85, 84, 41, 40, 79, 78, 77, 76, 37, 73, 72, 35, 69, 68, 33, 32, 31, 30, 59, 58, 57, 56, 55, 54, 53, 52, 25, 24, 23, 91, 90, 44, 87, 86, 42, 83, 82, 40, 79, 78, 38, 37, 73, 72, 71, 70, 34, 67, 66, 32, 31, 61, 60, 29, 28, 27, 26, 51, 50, 49, 48, 47, 46, 45, 44, 21, 41, 81, 80, 39, 77, 76, 75, 74, 36, 35, 34, 33, 65, 64, 31, 30, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 23, 22, 43, 42, 20, 39, 38, 37, 36, 35, 34, 16, 15, 14, 55, 54, 26, 25, 49, 48, 23, 45, 44, 21, 41, 40, 19, 37, 36, 17, 16, 31, 30, 14, 27, 53, 52, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 29, 28, 27, 26, 12, 11, 43, 42, 20, 39, 38, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 17, 16, 7, 6, 23, 22, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 1, 1, 1, 0]), new Int32Array([1, 3, 4, 4, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 7, 8, 9, 9, 9, 9, 9, 9, 8, 8, 9, 9, 9, 10, 10, 9, 9, 9, 9, 9, 9, 8, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 10, 10, 9, 9, 9, 11, 11, 10, 10, 10, 10, 10, 9, 9, 11, 11, 11, 11, 11, 11, 10, 10, 11, 11, 10, 10, 11, 11, 11, 11, 10, 11, 11, 10, 11, 11, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 10, 10, 10, 12, 12, 11, 12, 12, 11, 12, 12, 11, 12, 12, 11, 11, 12, 12, 12, 12, 11, 12, 12, 11, 11, 12, 12, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 13, 13, 12, 13, 13, 13, 13, 12, 12, 12, 12, 13, 13, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 12, 13, 13, 12, 13, 13, 13, 13, 13, 13, 12, 12, 12, 14, 14, 13, 13, 14, 14, 13, 14, 14, 13, 14, 14, 13, 14, 14, 13, 13, 14, 14, 13, 14, 15, 15, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 14, 14, 16, 16, 15, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 15, 15, 17, 17, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 18, 19, 19]), new Int32Array([0, 16, 1, 17, 32, 2, 33, 18, 34, 48, 3, 49, 19, 50, 35, 64, 4, 65, 20, 51, 66, 36, 80, 67, 52, 81, 21, 5, 82, 37, 68, 83, 96, 6, 97, 22, 128, 8, 129, 53, 98, 38, 84, 69, 99, 54, 112, 7, 85, 113, 23, 39, 55, 24, 130, 40, 100, 70, 114, 132, 72, 144, 9, 145, 25, 115, 101, 86, 116, 71, 102, 131, 56, 117, 87, 146, 41, 103, 133, 88, 57, 147, 73, 134, 160, 104, 10, 161, 26, 162, 42, 149, 89, 163, 58, 74, 150, 176, 11, 177, 27, 178, 118, 119, 148, 135, 120, 164, 105, 165, 43, 90, 136, 179, 59, 121, 166, 106, 180, 192, 12, 152, 193, 28, 137, 181, 91, 194, 44, 60, 182, 107, 196, 76, 168, 138, 208, 13, 209, 75, 151, 167, 195, 122, 153, 197, 92, 183, 29, 210, 45, 123, 211, 61, 198, 108, 169, 154, 212, 184, 139, 77, 199, 124, 213, 93, 224, 225, 30, 14, 46, 226, 227, 109, 140, 228, 229, 186, 240, 241, 31, 170, 155, 185, 62, 214, 200, 78, 215, 125, 171, 94, 201, 15, 156, 110, 242, 47, 216, 141, 63, 243, 230, 202, 244, 79, 187, 172, 231, 245, 217, 157, 95, 232, 111, 246, 203, 188, 173, 218, 247, 126, 127, 142, 158, 174, 204, 248, 143, 219, 189, 234, 249, 159, 235, 190, 205, 250, 221, 236, 233, 175, 220, 206, 251, 191, 222, 207, 238, 223, 239, 255, 237, 253, 252, 254])).getVLC();
    constructor.tab15 = VLCBuilder.createVLCBuilder(new Int32Array([7, 13, 12, 5, 19, 18, 17, 16, 15, 29, 28, 27, 53, 52, 25, 24, 47, 46, 22, 43, 42, 41, 40, 39, 77, 76, 37, 36, 35, 34, 67, 66, 32, 63, 125, 124, 61, 60, 59, 58, 57, 56, 55, 109, 108, 53, 52, 51, 50, 49, 48, 95, 94, 93, 92, 91, 90, 89, 88, 43, 42, 41, 40, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 34, 67, 66, 65, 64, 63, 62, 123, 122, 60, 59, 58, 57, 56, 55, 109, 108, 53, 52, 51, 50, 49, 48, 47, 93, 92, 91, 90, 89, 88, 87, 86, 42, 83, 82, 40, 79, 78, 77, 76, 37, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 30, 119, 118, 58, 57, 56, 55, 54, 107, 106, 52, 51, 50, 49, 48, 47, 46, 91, 90, 44, 43, 42, 41, 81, 80, 39, 38, 75, 74, 73, 72, 71, 70, 34, 67, 66, 65, 64, 63, 62, 123, 122, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 71, 70, 34, 33, 32, 31, 30, 29, 28, 27, 53, 52, 25, 24, 23, 22, 21, 20, 39, 38, 37, 36, 17, 16, 63, 62, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 15, 14, 6, 11, 10, 9, 8, 7, 6, 2, 3, 2, 1, 0]), new Int32Array([3, 4, 4, 3, 5, 5, 5, 5, 5, 6, 6, 6, 7, 7, 6, 6, 7, 7, 6, 7, 7, 7, 7, 7, 8, 8, 7, 7, 7, 7, 8, 8, 7, 8, 9, 9, 8, 8, 8, 8, 8, 8, 8, 9, 9, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 10, 10, 9, 9, 9, 9, 9, 9, 10, 10, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 9, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 11, 11, 10, 10, 10, 10, 10, 11, 11, 10, 10, 10, 10, 10, 10, 10, 11, 11, 10, 10, 10, 10, 11, 11, 10, 10, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 12, 12, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 11, 11, 13, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 12, 13, 13, 13, 13, 13, 13, 12, 13, 13, 13, 13]), new Int32Array([0, 16, 1, 17, 32, 2, 33, 18, 34, 48, 49, 19, 3, 64, 50, 35, 4, 20, 65, 51, 66, 36, 67, 52, 80, 5, 81, 21, 82, 37, 68, 83, 97, 53, 96, 6, 22, 98, 38, 84, 69, 99, 54, 112, 7, 113, 85, 23, 100, 114, 39, 70, 115, 55, 101, 86, 128, 8, 116, 129, 24, 130, 40, 71, 102, 131, 56, 117, 87, 132, 72, 144, 25, 145, 146, 118, 103, 41, 133, 88, 9, 119, 147, 57, 148, 73, 134, 104, 160, 10, 161, 26, 162, 42, 149, 89, 163, 58, 135, 120, 164, 74, 150, 105, 176, 177, 27, 165, 178, 90, 43, 136, 151, 179, 121, 59, 106, 180, 75, 193, 152, 137, 28, 181, 91, 44, 194, 11, 192, 166, 167, 122, 195, 60, 12, 153, 182, 107, 196, 76, 168, 138, 197, 208, 92, 209, 183, 123, 29, 13, 45, 210, 211, 61, 198, 108, 169, 154, 184, 212, 139, 77, 199, 124, 213, 93, 224, 14, 225, 30, 226, 170, 46, 185, 155, 227, 214, 109, 62, 200, 140, 228, 78, 215, 125, 229, 186, 171, 94, 201, 156, 241, 31, 240, 110, 242, 47, 230, 216, 243, 63, 244, 79, 141, 217, 187, 202, 172, 231, 126, 245, 157, 95, 232, 142, 246, 203, 15, 174, 111, 188, 218, 173, 247, 127, 233, 158, 204, 248, 143, 219, 189, 234, 249, 159, 220, 205, 235, 190, 250, 175, 221, 236, 206, 251, 191, 237, 222, 252, 207, 253, 238, 223, 254, 239, 255])).getVLC();
    constructor.tab16 = VLCBuilder.createVLCBuilder(new Int32Array([1, 3, 5, 4, 15, 14, 13, 12, 23, 45, 44, 21, 20, 39, 38, 75, 74, 36, 35, 69, 68, 67, 66, 65, 64, 63, 62, 30, 59, 58, 115, 114, 56, 111, 110, 54, 53, 52, 103, 102, 101, 100, 99, 98, 48, 47, 93, 185, 184, 91, 90, 179, 178, 88, 87, 173, 172, 85, 84, 83, 165, 164, 81, 161, 160, 159, 158, 157, 156, 155, 154, 76, 75, 149, 148, 73, 72, 143, 142, 141, 140, 139, 138, 68, 67, 133, 265, 264, 131, 261, 260, 129, 257, 256, 127, 253, 252, 125, 249, 248, 247, 246, 245, 244, 243, 242, 120, 119, 118, 117, 233, 232, 115, 229, 228, 227, 226, 225, 224, 223, 222, 110, 219, 218, 217, 216, 107, 427, 426, 212, 211, 210, 209, 208, 207, 206, 102, 407, 406, 202, 201, 401, 400, 199, 397, 396, 395, 394, 393, 392, 195, 389, 388, 387, 386, 385, 384, 383, 382, 381, 380, 379, 378, 377, 376, 187, 747, 746, 372, 743, 742, 370, 369, 737, 736, 735, 734, 366, 365, 364, 727, 726, 362, 723, 722, 721, 720, 359, 358, 715, 714, 713, 712, 711, 710, 709, 708, 707, 706, 352, 10, 9, 17, 16, 7, 223, 445, 889, 888, 443, 885, 884, 883, 882, 440, 439, 877, 876, 437, 436, 871, 870, 434, 1735, 1734, 866, 865, 3459, 3458, 1728, 26, 12, 11, 10, 9, 17, 16, 3, 11, 10, 9, 8, 7, 13, 12, 11, 10, 4, 7, 6, 5, 4, 3, 2, 1, 0]), new Int32Array([1, 3, 4, 4, 6, 6, 6, 6, 7, 8, 8, 7, 7, 8, 8, 9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 10, 10, 9, 10, 10, 9, 9, 9, 10, 10, 10, 10, 10, 10, 9, 9, 10, 11, 11, 10, 10, 11, 11, 10, 10, 11, 11, 10, 10, 10, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 11, 10, 10, 11, 11, 10, 10, 11, 11, 11, 11, 11, 11, 10, 10, 11, 12, 12, 11, 12, 12, 11, 12, 12, 11, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11, 11, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 11, 13, 13, 12, 12, 12, 12, 12, 12, 12, 11, 13, 13, 12, 12, 13, 13, 12, 13, 13, 13, 13, 13, 13, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 12, 14, 14, 13, 14, 14, 13, 13, 14, 14, 14, 14, 13, 13, 13, 14, 14, 13, 14, 14, 14, 14, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 13, 8, 8, 9, 9, 8, 13, 14, 15, 15, 14, 15, 15, 15, 15, 14, 14, 15, 15, 14, 14, 15, 15, 14, 16, 16, 15, 15, 17, 17, 16, 10, 9, 9, 9, 9, 10, 10, 8, 10, 10, 10, 10, 10, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 11]), new Int32Array([0, 16, 1, 17, 32, 2, 33, 18, 34, 48, 3, 49, 19, 50, 35, 64, 4, 65, 20, 51, 66, 36, 80, 67, 52, 5, 21, 81, 82, 37, 68, 53, 83, 96, 6, 97, 22, 98, 38, 84, 69, 99, 54, 112, 113, 23, 7, 85, 100, 114, 39, 70, 101, 115, 55, 86, 8, 128, 129, 24, 116, 71, 130, 40, 102, 131, 56, 117, 132, 72, 144, 145, 25, 9, 118, 146, 41, 133, 88, 147, 57, 160, 10, 26, 162, 103, 87, 73, 148, 119, 134, 161, 104, 149, 42, 89, 58, 163, 135, 120, 164, 74, 150, 105, 176, 11, 177, 27, 178, 43, 165, 90, 179, 166, 106, 180, 75, 12, 193, 181, 194, 44, 167, 195, 107, 196, 29, 136, 151, 59, 209, 210, 45, 211, 30, 46, 226, 121, 152, 192, 28, 137, 91, 60, 122, 182, 76, 153, 168, 138, 13, 197, 92, 61, 198, 108, 154, 139, 77, 199, 124, 213, 93, 224, 14, 227, 208, 183, 123, 169, 184, 212, 225, 170, 185, 155, 214, 109, 62, 200, 140, 228, 78, 215, 229, 186, 171, 156, 230, 110, 216, 141, 187, 231, 157, 232, 142, 203, 188, 158, 241, 31, 15, 47, 242, 189, 94, 125, 201, 202, 172, 126, 218, 173, 204, 174, 219, 220, 205, 190, 235, 237, 238, 217, 234, 233, 222, 221, 236, 206, 63, 240, 243, 244, 79, 245, 95, 255, 246, 111, 247, 127, 143, 248, 249, 159, 250, 175, 251, 191, 252, 207, 253, 223, 254, 239])).getVLC();
    constructor.tab24 = VLCBuilder.createVLCBuilder(new Int32Array([15, 14, 13, 12, 47, 46, 22, 21, 41, 81, 80, 39, 38, 75, 74, 147, 146, 72, 71, 70, 69, 68, 135, 134, 66, 263, 262, 130, 129, 128, 127, 126, 125, 249, 248, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 221, 220, 109, 435, 434, 216, 215, 214, 427, 426, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 202, 201, 200, 199, 198, 197, 196, 195, 194, 193, 192, 191, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 177, 353, 352, 175, 174, 347, 346, 345, 344, 171, 341, 340, 169, 168, 335, 669, 668, 333, 332, 331, 330, 164, 327, 653, 652, 325, 649, 648, 323, 322, 321, 320, 319, 318, 317, 316, 315, 314, 313, 312, 311, 621, 620, 309, 308, 307, 306, 305, 304, 303, 302, 301, 300, 299, 298, 297, 296, 295, 294, 293, 292, 291, 290, 289, 288, 287, 286, 285, 284, 283, 282, 281, 280, 279, 278, 277, 276, 275, 274, 273, 272, 271, 541, 540, 269, 268, 267, 266, 531, 530, 264, 263, 262, 261, 521, 520, 259, 517, 1033, 1032, 515, 514, 513, 512, 3, 383, 382, 381, 380, 379, 378, 377, 376, 375, 374, 373, 372, 371, 370, 369, 368, 367, 366, 365, 364, 363, 362, 361, 360, 359, 358, 357, 356, 88, 43, 42, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 17, 16, 7, 6, 11, 10, 4, 7, 6, 5, 4, 3, 2, 1, 0]), new Int32Array([4, 4, 4, 4, 6, 6, 5, 5, 6, 7, 7, 6, 6, 7, 7, 8, 8, 7, 7, 7, 7, 7, 8, 8, 7, 9, 9, 8, 8, 8, 8, 8, 8, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 8, 10, 10, 9, 9, 9, 10, 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 9, 9, 10, 10, 10, 10, 9, 10, 10, 9, 9, 10, 11, 11, 10, 10, 10, 10, 9, 10, 11, 11, 10, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 10, 10, 10, 10, 11, 11, 10, 10, 10, 10, 11, 11, 10, 11, 12, 12, 11, 11, 11, 11, 4, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 9, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 7, 7, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8]), new Int32Array([0, 16, 1, 17, 32, 2, 33, 18, 34, 48, 3, 49, 19, 50, 35, 64, 4, 65, 20, 51, 66, 36, 67, 52, 81, 80, 5, 21, 82, 37, 68, 83, 53, 96, 6, 97, 22, 98, 38, 84, 69, 99, 54, 113, 85, 100, 70, 114, 39, 55, 115, 112, 7, 23, 101, 86, 128, 8, 129, 116, 71, 24, 130, 40, 102, 131, 56, 117, 87, 132, 72, 145, 25, 146, 118, 103, 41, 133, 88, 147, 57, 148, 73, 119, 134, 104, 161, 162, 42, 149, 89, 163, 58, 135, 120, 74, 164, 150, 105, 177, 27, 165, 178, 90, 43, 136, 179, 144, 9, 160, 151, 121, 166, 106, 180, 26, 10, 176, 59, 11, 192, 75, 193, 152, 137, 28, 181, 91, 194, 44, 167, 122, 195, 60, 12, 208, 182, 107, 196, 76, 153, 168, 138, 197, 92, 209, 183, 123, 29, 210, 45, 211, 61, 198, 108, 169, 154, 212, 184, 139, 77, 199, 124, 213, 93, 225, 30, 226, 170, 185, 155, 227, 214, 109, 62, 46, 78, 200, 140, 228, 215, 125, 171, 229, 186, 94, 201, 156, 110, 230, 13, 224, 14, 216, 141, 187, 202, 255, 172, 231, 126, 217, 157, 232, 142, 203, 188, 218, 173, 233, 158, 204, 219, 189, 234, 174, 220, 205, 235, 190, 221, 236, 206, 237, 222, 238, 15, 240, 31, 241, 242, 47, 243, 63, 244, 79, 245, 95, 246, 111, 247, 127, 143, 248, 249, 159, 175, 250, 251, 191, 252, 207, 253, 223, 254, 239])).getVLC();
    constructor.bigValVlc = [null, MpaConst.tab1, MpaConst.tab2, MpaConst.tab3, null, MpaConst.tab5, MpaConst.tab6, MpaConst.tab7, MpaConst.tab8, MpaConst.tab9, MpaConst.tab10, MpaConst.tab11, MpaConst.tab12, MpaConst.tab13, null, MpaConst.tab15, MpaConst.tab16, MpaConst.tab16, MpaConst.tab16, MpaConst.tab16, MpaConst.tab16, MpaConst.tab16, MpaConst.tab16, MpaConst.tab16, MpaConst.tab24, MpaConst.tab24, MpaConst.tab24, MpaConst.tab24, MpaConst.tab24, MpaConst.tab24, MpaConst.tab24, MpaConst.tab24];
    constructor.bigValMaxval = new Int32Array([0, 2, 3, 3, 0, 4, 4, 6, 6, 6, 8, 8, 8, 16, 0, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]);
    constructor.bigValEscBits = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 8, 10, 13, 4, 5, 6, 7, 8, 9, 11, 13]);
    constructor.cnt1A = VLCBuilder.createVLCBuilder(new Int32Array([1, 7, 6, 5, 4, 7, 6, 5, 4, 3, 5, 4, 3, 2, 1, 0]), new Int32Array([1, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6]), new Int32Array([0, 8, 4, 1, 2, 12, 10, 3, 6, 9, 5, 7, 14, 13, 15, 11])).getVLC();
    constructor.cnt1B = VLCBuilder.createVLCBuilder(new Int32Array([15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), new Int32Array([4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]), new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])).getVLC();
}, {frequencies: "Array", bitrates: "Array", sfbLong: "Array", sfbShort: "Array", scaleFactorLen: "Array", pretab: "Int32Array", quantizerTab: "Float32Array", power43Tab: "Float32Array", intensityOffset: "Array", TAN12: "Float32Array", ll0: "Int32Array", ss0: "Int32Array", sftable: "MpaConst.Sftable", cs: "Float32Array", ca: "Float32Array", win: "Array", numberOfScaleFactors: "Array", dp: "Float32Array", grouping5Bits: "Float32Array", grouping7Bits: "Float32Array", grouping10Bits: "Float32Array", tableAb1CodeLength: "Int32Array", tableAb1Groupingtables: "Array", tableAb1Factor: "Float32Array", tableAb1C: "Float32Array", tableAb1D: "Float32Array", tableAb234Groupingtables: "Array", tableAb2CodeLength: "Int32Array", tableAb2Factor: "Float32Array", table_ab2_c: "Float32Array", table_ab2_d: "Float32Array", tableAb3CodeLength: "Int32Array", tableAb3Factor: "Float32Array", tableAb3C: "Float32Array", tableAb3D: "Float32Array", tableAb4CodeLength: "Int32Array", tableAb4Factor: "Float32Array", tableAb4C: "Float32Array", tableAb4D: "Float32Array", tableCdCodelength: "Int32Array", tableCdGroupingtables: "Array", tableCdFactor: "Float32Array", tableCdC: "Float32Array", tableCdD: "Float32Array", tab1: "VLC", tab2: "VLC", tab3: "VLC", tab5: "VLC", tab6: "VLC", tab7: "VLC", tab8: "VLC", tab9: "VLC", tab10: "VLC", tab11: "VLC", tab12: "VLC", tab13: "VLC", tab15: "VLC", tab16: "VLC", tab24: "VLC", bigValVlc: "Array", bigValMaxval: "Int32Array", bigValEscBits: "Int32Array", cnt1A: "VLC", cnt1B: "VLC"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var H264Const = function() {};
H264Const = stjs.extend(H264Const, null, [], function(constructor, prototype) {
    constructor.CoeffToken = Array(10);
    constructor.coeffTokenChromaDCY420 = null;
    constructor.coeffTokenChromaDCY422 = null;
    constructor.run = null;
    constructor.totalZeros16 = [new VLCBuilder().set(0, "1").set(1, "011").set(2, "010").set(3, "0011").set(4, "0010").set(5, "00011").set(6, "00010").set(7, "000011").set(8, "000010").set(9, "0000011").set(10, "0000010").set(11, "00000011").set(12, "00000010").set(13, "000000011").set(14, "000000010").set(15, "000000001").getVLC(), new VLCBuilder().set(0, "111").set(1, "110").set(2, "101").set(3, "100").set(4, "011").set(5, "0101").set(6, "0100").set(7, "0011").set(8, "0010").set(9, "00011").set(10, "00010").set(11, "000011").set(12, "000010").set(13, "000001").set(14, "000000").getVLC(), new VLCBuilder().set(0, "0101").set(1, "111").set(2, "110").set(3, "101").set(4, "0100").set(5, "0011").set(6, "100").set(7, "011").set(8, "0010").set(9, "00011").set(10, "00010").set(11, "000001").set(12, "00001").set(13, "000000").getVLC(), new VLCBuilder().set(0, "00011").set(1, "111").set(2, "0101").set(3, "0100").set(4, "110").set(5, "101").set(6, "100").set(7, "0011").set(8, "011").set(9, "0010").set(10, "00010").set(11, "00001").set(12, "00000").getVLC(), new VLCBuilder().set(0, "0101").set(1, "0100").set(2, "0011").set(3, "111").set(4, "110").set(5, "101").set(6, "100").set(7, "011").set(8, "0010").set(9, "00001").set(10, "0001").set(11, "00000").getVLC(), new VLCBuilder().set(0, "000001").set(1, "00001").set(2, "111").set(3, "110").set(4, "101").set(5, "100").set(6, "011").set(7, "010").set(8, "0001").set(9, "001").set(10, "000000").getVLC(), new VLCBuilder().set(0, "000001").set(1, "00001").set(2, "101").set(3, "100").set(4, "011").set(5, "11").set(6, "010").set(7, "0001").set(8, "001").set(9, "000000").getVLC(), new VLCBuilder().set(0, "000001").set(1, "0001").set(2, "00001").set(3, "011").set(4, "11").set(5, "10").set(6, "010").set(7, "001").set(8, "000000").getVLC(), new VLCBuilder().set(0, "000001").set(1, "000000").set(2, "0001").set(3, "11").set(4, "10").set(5, "001").set(6, "01").set(7, "00001").getVLC(), new VLCBuilder().set(0, "00001").set(1, "00000").set(2, "001").set(3, "11").set(4, "10").set(5, "01").set(6, "0001").getVLC(), new VLCBuilder().set(0, "0000").set(1, "0001").set(2, "001").set(3, "010").set(4, "1").set(5, "011").getVLC(), new VLCBuilder().set(0, "0000").set(1, "0001").set(2, "01").set(3, "1").set(4, "001").getVLC(), new VLCBuilder().set(0, "000").set(1, "001").set(2, "1").set(3, "01").getVLC(), new VLCBuilder().set(0, "00").set(1, "01").set(2, "1").getVLC(), new VLCBuilder().set(0, "0").set(1, "1").getVLC()];
    constructor.totalZeros4 = [new VLCBuilder().set(0, "1").set(1, "01").set(2, "001").set(3, "000").getVLC(), new VLCBuilder().set(0, "1").set(1, "01").set(2, "00").getVLC(), new VLCBuilder().set(0, "1").set(1, "0").getVLC()];
    constructor.totalZeros8 = [new VLCBuilder().set(0, "1").set(1, "010").set(2, "011").set(3, "0010").set(4, "0011").set(5, "0001").set(6, "00001").set(7, "00000").getVLC(), new VLCBuilder().set(0, "000").set(1, "01").set(2, "001").set(3, "100").set(4, "101").set(5, "110").set(6, "111").getVLC(), new VLCBuilder().set(0, "000").set(1, "001").set(2, "01").set(3, "10").set(4, "110").set(5, "111").getVLC(), new VLCBuilder().set(0, "110").set(1, "00").set(2, "01").set(3, "10").set(4, "111").getVLC(), new VLCBuilder().set(0, "00").set(1, "01").set(2, "10").set(3, "11").getVLC(), new VLCBuilder().set(0, "00").set(1, "01").set(2, "1").getVLC(), new VLCBuilder().set(0, "0").set(1, "1").getVLC()];
    constructor.PartPred = stjs.enumeration("L0", "L1", "Bi", "Direct");
    constructor.bPredModes = [null, [H264Const.PartPred.L0], [H264Const.PartPred.L1], [H264Const.PartPred.Bi], [H264Const.PartPred.L0, H264Const.PartPred.L0], [H264Const.PartPred.L0, H264Const.PartPred.L0], [H264Const.PartPred.L1, H264Const.PartPred.L1], [H264Const.PartPred.L1, H264Const.PartPred.L1], [H264Const.PartPred.L0, H264Const.PartPred.L1], [H264Const.PartPred.L0, H264Const.PartPred.L1], [H264Const.PartPred.L1, H264Const.PartPred.L0], [H264Const.PartPred.L1, H264Const.PartPred.L0], [H264Const.PartPred.L0, H264Const.PartPred.Bi], [H264Const.PartPred.L0, H264Const.PartPred.Bi], [H264Const.PartPred.L1, H264Const.PartPred.Bi], [H264Const.PartPred.L1, H264Const.PartPred.Bi], [H264Const.PartPred.Bi, H264Const.PartPred.L0], [H264Const.PartPred.Bi, H264Const.PartPred.L0], [H264Const.PartPred.Bi, H264Const.PartPred.L1], [H264Const.PartPred.Bi, H264Const.PartPred.L1], [H264Const.PartPred.Bi, H264Const.PartPred.Bi], [H264Const.PartPred.Bi, H264Const.PartPred.Bi]];
    constructor.bMbTypes = [MBType.B_Direct_16x16, MBType.B_L0_16x16, MBType.B_L1_16x16, MBType.B_Bi_16x16, MBType.B_L0_L0_16x8, MBType.B_L0_L0_8x16, MBType.B_L1_L1_16x8, MBType.B_L1_L1_8x16, MBType.B_L0_L1_16x8, MBType.B_L0_L1_8x16, MBType.B_L1_L0_16x8, MBType.B_L1_L0_8x16, MBType.B_L0_Bi_16x8, MBType.B_L0_Bi_8x16, MBType.B_L1_Bi_16x8, MBType.B_L1_Bi_8x16, MBType.B_Bi_L0_16x8, MBType.B_Bi_L0_8x16, MBType.B_Bi_L1_16x8, MBType.B_Bi_L1_8x16, MBType.B_Bi_Bi_16x8, MBType.B_Bi_Bi_8x16, MBType.B_8x8];
    constructor.bPartW = new Int32Array([0, 16, 16, 16, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8]);
    constructor.bPartH = new Int32Array([0, 16, 16, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16, 8, 16]);
    constructor.BLK_X = new Int32Array([0, 4, 0, 4, 8, 12, 8, 12, 0, 4, 0, 4, 8, 12, 8, 12]);
    constructor.BLK_Y = new Int32Array([0, 0, 4, 4, 0, 0, 4, 4, 8, 8, 12, 12, 8, 8, 12, 12]);
    constructor.BLK_8x8_X = new Int32Array([0, 8, 0, 8]);
    constructor.BLK_8x8_Y = new Int32Array([0, 0, 8, 8]);
    constructor.BLK_INV_MAP = new Int32Array([0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15]);
    constructor.MB_BLK_OFF_LEFT = new Int32Array([0, 1, 0, 1, 2, 3, 2, 3, 0, 1, 0, 1, 2, 3, 2, 3]);
    constructor.MB_BLK_OFF_TOP = new Int32Array([0, 0, 1, 1, 0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 3, 3]);
    constructor.QP_SCALE_CR = new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 29, 30, 31, 32, 32, 33, 34, 34, 35, 35, 36, 36, 37, 37, 37, 38, 38, 38, 39, 39, 39, 39]);
    constructor.NO_PIC = Picture.createPicture(0, 0, null, null);
    constructor.BLK_8x8_MB_OFF_LUMA = new Int32Array([0, 8, 128, 136]);
    constructor.BLK_8x8_MB_OFF_CHROMA = new Int32Array([0, 4, 32, 36]);
    constructor.BLK_4x4_MB_OFF_LUMA = new Int32Array([0, 4, 8, 12, 64, 68, 72, 76, 128, 132, 136, 140, 192, 196, 200, 204]);
    constructor.BLK_8x8_IND = new Int32Array([0, 0, 1, 1, 0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 3, 3]);
    constructor.BLK8x8_BLOCKS = [new Int32Array([0, 1, 4, 5]), new Int32Array([2, 3, 6, 7]), new Int32Array([8, 9, 12, 13]), new Int32Array([10, 11, 14, 15])];
    constructor.ARRAY = [new Int32Array([0]), new Int32Array([1]), new Int32Array([2]), new Int32Array([3])];
    constructor.CODED_BLOCK_PATTERN_INTRA_COLOR = new Int32Array([47, 31, 15, 0, 23, 27, 29, 30, 7, 11, 13, 14, 39, 43, 45, 46, 16, 3, 5, 10, 12, 19, 21, 26, 28, 35, 37, 42, 44, 1, 2, 4, 8, 17, 18, 20, 24, 6, 9, 22, 25, 32, 33, 34, 36, 40, 38, 41]);
    constructor.coded_block_pattern_intra_monochrome = new Int32Array([15, 0, 7, 11, 13, 14, 3, 5, 10, 12, 1, 2, 4, 8, 6, 9]);
    constructor.CODED_BLOCK_PATTERN_INTER_COLOR = new Int32Array([0, 16, 1, 2, 4, 8, 32, 3, 5, 10, 12, 15, 47, 7, 11, 13, 14, 6, 9, 31, 35, 37, 42, 44, 33, 34, 36, 40, 39, 43, 45, 46, 17, 18, 20, 24, 19, 21, 26, 28, 23, 27, 29, 30, 22, 25, 38, 41]);
    constructor.inverse = function(arr) {
        var inv = new Int32Array(arr.length);
        for (var i = 0; i < inv.length; i++) {
            inv[arr[i]] = i;
        }
        return inv;
    };
    constructor.CODED_BLOCK_PATTERN_INTER_COLOR_INV = H264Const.inverse(H264Const.CODED_BLOCK_PATTERN_INTER_COLOR);
    constructor.coded_block_pattern_inter_monochrome = new Int32Array([0, 1, 2, 4, 8, 3, 5, 10, 12, 15, 7, 11, 13, 14, 6, 9]);
    constructor.sig_coeff_map_8x8 = new Int32Array([0, 1, 2, 3, 4, 5, 5, 4, 4, 3, 3, 4, 4, 4, 5, 5, 4, 4, 4, 4, 3, 3, 6, 7, 7, 7, 8, 9, 10, 9, 8, 7, 7, 6, 11, 12, 13, 11, 6, 7, 8, 9, 14, 10, 9, 8, 6, 11, 12, 13, 11, 6, 9, 14, 10, 9, 11, 12, 13, 11, 14, 10, 12]);
    constructor.sig_coeff_map_8x8_mbaff = new Int32Array([0, 1, 1, 2, 2, 3, 3, 4, 5, 6, 7, 7, 7, 8, 4, 5, 6, 9, 10, 10, 8, 11, 12, 11, 9, 9, 10, 10, 8, 11, 12, 11, 9, 9, 10, 10, 8, 11, 12, 11, 9, 9, 10, 10, 8, 13, 13, 9, 9, 10, 10, 8, 13, 13, 9, 9, 10, 10, 14, 14, 14, 14, 14]);
    constructor.last_sig_coeff_map_8x8 = new Int32Array([0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8]);
    constructor.identityMapping16 = new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
    constructor.identityMapping4 = new Int32Array([0, 1, 2, 3]);
    constructor.bPartPredModes = [H264Const.PartPred.Direct, H264Const.PartPred.L0, H264Const.PartPred.L1, H264Const.PartPred.Bi, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L1, H264Const.PartPred.L1, H264Const.PartPred.Bi, H264Const.PartPred.Bi, H264Const.PartPred.L0, H264Const.PartPred.L1, H264Const.PartPred.Bi];
    constructor.bSubMbTypes = new Int32Array([0, 0, 0, 0, 1, 2, 1, 2, 1, 2, 3, 3, 3]);
    constructor.LUMA_4x4_BLOCK_LUT = new Int32Array(256);
    constructor.LUMA_4x4_POS_LUT = new Int32Array(256);
    constructor.LUMA_8x8_BLOCK_LUT = new Int32Array(256);
    constructor.LUMA_8x8_POS_LUT = new Int32Array(256);
    constructor.CHROMA_BLOCK_LUT = new Int32Array(64);
    constructor.CHROMA_POS_LUT = new Int32Array(64);
    constructor.COMP_BLOCK_4x4_LUT = [H264Const.LUMA_4x4_BLOCK_LUT, H264Const.CHROMA_BLOCK_LUT, H264Const.CHROMA_BLOCK_LUT];
    constructor.COMP_POS_4x4_LUT = [H264Const.LUMA_4x4_POS_LUT, H264Const.CHROMA_POS_LUT, H264Const.CHROMA_POS_LUT];
    constructor.COMP_BLOCK_8x8_LUT = [H264Const.LUMA_8x8_BLOCK_LUT, H264Const.CHROMA_BLOCK_LUT, H264Const.CHROMA_BLOCK_LUT];
    constructor.COMP_POS_8x8_LUT = [H264Const.LUMA_8x8_POS_LUT, H264Const.CHROMA_POS_LUT, H264Const.CHROMA_POS_LUT];
    constructor.putBlk = function(_in, blkX, blkY, blkW, blkH, stride, out) {
        for (var line = 0, srcOff = 0, dstOff = blkY * stride + blkX; line < blkH; line++) {
            for (var i = 0; i < blkW; i++) 
                out[dstOff + i] = _in[srcOff + i];
            srcOff += blkW;
            dstOff += stride;
        }
    };
    constructor.buildPixSplitMap4x4 = function() {
        var result = [new Int32Array([0, 1, 2, 3, 16, 17, 18, 19, 32, 33, 34, 35, 48, 49, 50, 51]), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16), new Int32Array(16)];
        for (var blkY = 0, blk = 0, off = 0; blkY < 4; ++blkY) {
            for (var blkX = 0; blkX < 4; ++blkX , ++blk , off += 4) {
                for (var i = 0; i < 16; i++) 
                    result[blk][i] = result[0][i] + off;
            }
            off += 48;
        }
        return result;
    };
    constructor.buildPixSplitMap2x2 = function() {
        var result = [new Int32Array([0, 1, 2, 3, 8, 9, 10, 11, 16, 17, 18, 19, 24, 25, 26, 27]), new Int32Array(16), new Int32Array(16), new Int32Array(16)];
        for (var blkY = 0, blk = 0, off = 0; blkY < 2; ++blkY) {
            for (var blkX = 0; blkX < 2; ++blkX , ++blk , off += 4) {
                for (var i = 0; i < 16; i++) 
                    result[blk][i] = result[0][i] + off;
            }
            off += 24;
        }
        return result;
    };
    constructor.usesList = function(pred, l) {
        return pred == H264Const.PartPred.Bi ? true : (pred == H264Const.PartPred.L0 && l == 0 || pred == H264Const.PartPred.L1 && l == 1);
    };
    constructor.coeffToken = function(totalCoeff, trailingOnes) {
        return (totalCoeff << 4) | trailingOnes;
    };
    constructor.PIX_MAP_SPLIT_4x4 = H264Const.buildPixSplitMap4x4();
    constructor.PIX_MAP_SPLIT_2x2 = H264Const.buildPixSplitMap2x2();
    constructor.PROFILE_CAVLC_INTRA = 44;
    constructor.PROFILE_BASELINE = 66;
    constructor.PROFILE_MAIN = 77;
    constructor.PROFILE_EXTENDED = 88;
    constructor.PROFILE_HIGH = 100;
    constructor.PROFILE_HIGH_10 = 110;
    constructor.PROFILE_HIGH_422 = 122;
    constructor.PROFILE_HIGH_444 = 244;
    constructor.defaultScalingList4x4Intra = new Int32Array([6, 13, 13, 20, 20, 20, 28, 28, 28, 28, 32, 32, 32, 37, 37, 42]);
    constructor.defaultScalingList4x4Inter = new Int32Array([10, 14, 14, 20, 20, 20, 24, 24, 24, 24, 27, 27, 27, 30, 30, 34]);
    constructor.defaultScalingList8x8Intra = new Int32Array([6, 10, 10, 13, 11, 13, 16, 16, 16, 16, 18, 18, 18, 18, 18, 23, 23, 23, 23, 23, 23, 25, 25, 25, 25, 25, 25, 25, 27, 27, 27, 27, 27, 27, 27, 27, 29, 29, 29, 29, 29, 29, 29, 31, 31, 31, 31, 31, 31, 33, 33, 33, 33, 33, 36, 36, 36, 36, 38, 38, 38, 40, 40, 42]);
    constructor.defaultScalingList8x8Inter = new Int32Array([9, 13, 13, 15, 13, 15, 17, 17, 17, 17, 19, 19, 19, 19, 19, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 30, 30, 30, 30, 32, 32, 32, 33, 33, 35]);
}, {CoeffToken: "Array", coeffTokenChromaDCY420: "VLC", coeffTokenChromaDCY422: "VLC", run: "Array", totalZeros16: "Array", totalZeros4: "Array", totalZeros8: "Array", bPredModes: "Array", bMbTypes: "Array", bPartW: "Int32Array", bPartH: "Int32Array", BLK_X: "Int32Array", BLK_Y: "Int32Array", BLK_8x8_X: "Int32Array", BLK_8x8_Y: "Int32Array", BLK_INV_MAP: "Int32Array", MB_BLK_OFF_LEFT: "Int32Array", MB_BLK_OFF_TOP: "Int32Array", QP_SCALE_CR: "Int32Array", NO_PIC: "Picture", BLK_8x8_MB_OFF_LUMA: "Int32Array", BLK_8x8_MB_OFF_CHROMA: "Int32Array", BLK_4x4_MB_OFF_LUMA: "Int32Array", BLK_8x8_IND: "Int32Array", BLK8x8_BLOCKS: "Array", ARRAY: "Array", CODED_BLOCK_PATTERN_INTRA_COLOR: "Int32Array", coded_block_pattern_intra_monochrome: "Int32Array", CODED_BLOCK_PATTERN_INTER_COLOR: "Int32Array", CODED_BLOCK_PATTERN_INTER_COLOR_INV: "Int32Array", coded_block_pattern_inter_monochrome: "Int32Array", sig_coeff_map_8x8: "Int32Array", sig_coeff_map_8x8_mbaff: "Int32Array", last_sig_coeff_map_8x8: "Int32Array", identityMapping16: "Int32Array", identityMapping4: "Int32Array", bPartPredModes: "Array", bSubMbTypes: "Int32Array", LUMA_4x4_BLOCK_LUT: "Int32Array", LUMA_4x4_POS_LUT: "Int32Array", LUMA_8x8_BLOCK_LUT: "Int32Array", LUMA_8x8_POS_LUT: "Int32Array", CHROMA_BLOCK_LUT: "Int32Array", CHROMA_POS_LUT: "Int32Array", COMP_BLOCK_4x4_LUT: "Array", COMP_POS_4x4_LUT: "Array", COMP_BLOCK_8x8_LUT: "Array", COMP_POS_8x8_LUT: "Array", PIX_MAP_SPLIT_4x4: "Array", PIX_MAP_SPLIT_2x2: "Array", defaultScalingList4x4Intra: "Int32Array", defaultScalingList4x4Inter: "Int32Array", defaultScalingList8x8Intra: "Int32Array", defaultScalingList8x8Inter: "Int32Array"}, {});
(function() {
    var vbl = new VLCBuilder();
    vbl.set((0 << 4) | 0, "1");
    vbl.set(H264Const.coeffToken(1, 0), "000101");
    vbl.set(H264Const.coeffToken(1, 1), "01");
    vbl.set(H264Const.coeffToken(2, 0), "00000111");
    vbl.set(H264Const.coeffToken(2, 1), "000100");
    vbl.set(H264Const.coeffToken(2, 2), "001");
    vbl.set(H264Const.coeffToken(3, 0), "000000111");
    vbl.set(H264Const.coeffToken(3, 1), "00000110");
    vbl.set(H264Const.coeffToken(3, 2), "0000101");
    vbl.set(H264Const.coeffToken(3, 3), "00011");
    vbl.set(H264Const.coeffToken(4, 0), "0000000111");
    vbl.set(H264Const.coeffToken(4, 1), "000000110");
    vbl.set(H264Const.coeffToken(4, 2), "00000101");
    vbl.set(H264Const.coeffToken(4, 3), "000011");
    vbl.set(H264Const.coeffToken(5, 0), "00000000111");
    vbl.set(H264Const.coeffToken(5, 1), "0000000110");
    vbl.set(H264Const.coeffToken(5, 2), "000000101");
    vbl.set(H264Const.coeffToken(5, 3), "0000100");
    vbl.set(H264Const.coeffToken(6, 0), "0000000001111");
    vbl.set(H264Const.coeffToken(6, 1), "00000000110");
    vbl.set(H264Const.coeffToken(6, 2), "0000000101");
    vbl.set(H264Const.coeffToken(6, 3), "00000100");
    vbl.set(H264Const.coeffToken(7, 0), "0000000001011");
    vbl.set(H264Const.coeffToken(7, 1), "0000000001110");
    vbl.set(H264Const.coeffToken(7, 2), "00000000101");
    vbl.set(H264Const.coeffToken(7, 3), "000000100");
    vbl.set(H264Const.coeffToken(8, 0), "0000000001000");
    vbl.set(H264Const.coeffToken(8, 1), "0000000001010");
    vbl.set(H264Const.coeffToken(8, 2), "0000000001101");
    vbl.set(H264Const.coeffToken(8, 3), "0000000100");
    vbl.set(H264Const.coeffToken(9, 0), "00000000001111");
    vbl.set(H264Const.coeffToken(9, 1), "00000000001110");
    vbl.set(H264Const.coeffToken(9, 2), "0000000001001");
    vbl.set(H264Const.coeffToken(9, 3), "00000000100");
    vbl.set(H264Const.coeffToken(10, 0), "00000000001011");
    vbl.set(H264Const.coeffToken(10, 1), "00000000001010");
    vbl.set(H264Const.coeffToken(10, 2), "00000000001101");
    vbl.set(H264Const.coeffToken(10, 3), "0000000001100");
    vbl.set(H264Const.coeffToken(11, 0), "000000000001111");
    vbl.set(H264Const.coeffToken(11, 1), "000000000001110");
    vbl.set(H264Const.coeffToken(11, 2), "00000000001001");
    vbl.set(H264Const.coeffToken(11, 3), "00000000001100");
    vbl.set(H264Const.coeffToken(12, 0), "000000000001011");
    vbl.set(H264Const.coeffToken(12, 1), "000000000001010");
    vbl.set(H264Const.coeffToken(12, 2), "000000000001101");
    vbl.set(H264Const.coeffToken(12, 3), "00000000001000");
    vbl.set(H264Const.coeffToken(13, 0), "0000000000001111");
    vbl.set(H264Const.coeffToken(13, 1), "000000000000001");
    vbl.set(H264Const.coeffToken(13, 2), "000000000001001");
    vbl.set(H264Const.coeffToken(13, 3), "000000000001100");
    vbl.set(H264Const.coeffToken(14, 0), "0000000000001011");
    vbl.set(H264Const.coeffToken(14, 1), "0000000000001110");
    vbl.set(H264Const.coeffToken(14, 2), "0000000000001101");
    vbl.set(H264Const.coeffToken(14, 3), "000000000001000");
    vbl.set(H264Const.coeffToken(15, 0), "0000000000000111");
    vbl.set(H264Const.coeffToken(15, 1), "0000000000001010");
    vbl.set(H264Const.coeffToken(15, 2), "0000000000001001");
    vbl.set(H264Const.coeffToken(15, 3), "0000000000001100");
    vbl.set(H264Const.coeffToken(16, 0), "0000000000000100");
    vbl.set(H264Const.coeffToken(16, 1), "0000000000000110");
    vbl.set(H264Const.coeffToken(16, 2), "0000000000000101");
    vbl.set(H264Const.coeffToken(16, 3), "0000000000001000");
    H264Const.CoeffToken[0] = H264Const.CoeffToken[1] = vbl.getVLC();
})();
(function() {
    var vbl = new VLCBuilder();
    vbl.set(H264Const.coeffToken(0, 0), "11");
    vbl.set(H264Const.coeffToken(1, 0), "001011");
    vbl.set(H264Const.coeffToken(1, 1), "10");
    vbl.set(H264Const.coeffToken(2, 0), "000111");
    vbl.set(H264Const.coeffToken(2, 1), "00111");
    vbl.set(H264Const.coeffToken(2, 2), "011");
    vbl.set(H264Const.coeffToken(3, 0), "0000111");
    vbl.set(H264Const.coeffToken(3, 1), "001010");
    vbl.set(H264Const.coeffToken(3, 2), "001001");
    vbl.set(H264Const.coeffToken(3, 3), "0101");
    vbl.set(H264Const.coeffToken(4, 0), "00000111");
    vbl.set(H264Const.coeffToken(4, 1), "000110");
    vbl.set(H264Const.coeffToken(4, 2), "000101");
    vbl.set(H264Const.coeffToken(4, 3), "0100");
    vbl.set(H264Const.coeffToken(5, 0), "00000100");
    vbl.set(H264Const.coeffToken(5, 1), "0000110");
    vbl.set(H264Const.coeffToken(5, 2), "0000101");
    vbl.set(H264Const.coeffToken(5, 3), "00110");
    vbl.set(H264Const.coeffToken(6, 0), "000000111");
    vbl.set(H264Const.coeffToken(6, 1), "00000110");
    vbl.set(H264Const.coeffToken(6, 2), "00000101");
    vbl.set(H264Const.coeffToken(6, 3), "001000");
    vbl.set(H264Const.coeffToken(7, 0), "00000001111");
    vbl.set(H264Const.coeffToken(7, 1), "000000110");
    vbl.set(H264Const.coeffToken(7, 2), "000000101");
    vbl.set(H264Const.coeffToken(7, 3), "000100");
    vbl.set(H264Const.coeffToken(8, 0), "00000001011");
    vbl.set(H264Const.coeffToken(8, 1), "00000001110");
    vbl.set(H264Const.coeffToken(8, 2), "00000001101");
    vbl.set(H264Const.coeffToken(8, 3), "0000100");
    vbl.set(H264Const.coeffToken(9, 0), "000000001111");
    vbl.set(H264Const.coeffToken(9, 1), "00000001010");
    vbl.set(H264Const.coeffToken(9, 2), "00000001001");
    vbl.set(H264Const.coeffToken(9, 3), "000000100");
    vbl.set(H264Const.coeffToken(10, 0), "000000001011");
    vbl.set(H264Const.coeffToken(10, 1), "000000001110");
    vbl.set(H264Const.coeffToken(10, 2), "000000001101");
    vbl.set(H264Const.coeffToken(10, 3), "00000001100");
    vbl.set(H264Const.coeffToken(11, 0), "000000001000");
    vbl.set(H264Const.coeffToken(11, 1), "000000001010");
    vbl.set(H264Const.coeffToken(11, 2), "000000001001");
    vbl.set(H264Const.coeffToken(11, 3), "00000001000");
    vbl.set(H264Const.coeffToken(12, 0), "0000000001111");
    vbl.set(H264Const.coeffToken(12, 1), "0000000001110");
    vbl.set(H264Const.coeffToken(12, 2), "0000000001101");
    vbl.set(H264Const.coeffToken(12, 3), "000000001100");
    vbl.set(H264Const.coeffToken(13, 0), "0000000001011");
    vbl.set(H264Const.coeffToken(13, 1), "0000000001010");
    vbl.set(H264Const.coeffToken(13, 2), "0000000001001");
    vbl.set(H264Const.coeffToken(13, 3), "0000000001100");
    vbl.set(H264Const.coeffToken(14, 0), "0000000000111");
    vbl.set(H264Const.coeffToken(14, 1), "00000000001011");
    vbl.set(H264Const.coeffToken(14, 2), "0000000000110");
    vbl.set(H264Const.coeffToken(14, 3), "0000000001000");
    vbl.set(H264Const.coeffToken(15, 0), "00000000001001");
    vbl.set(H264Const.coeffToken(15, 1), "00000000001000");
    vbl.set(H264Const.coeffToken(15, 2), "00000000001010");
    vbl.set(H264Const.coeffToken(15, 3), "0000000000001");
    vbl.set(H264Const.coeffToken(16, 0), "00000000000111");
    vbl.set(H264Const.coeffToken(16, 1), "00000000000110");
    vbl.set(H264Const.coeffToken(16, 2), "00000000000101");
    vbl.set(H264Const.coeffToken(16, 3), "00000000000100");
    H264Const.CoeffToken[2] = H264Const.CoeffToken[3] = vbl.getVLC();
})();
(function() {
    var vbl = new VLCBuilder();
    vbl.set(H264Const.coeffToken(0, 0), "1111");
    vbl.set(H264Const.coeffToken(1, 0), "001111");
    vbl.set(H264Const.coeffToken(1, 1), "1110");
    vbl.set(H264Const.coeffToken(2, 0), "001011");
    vbl.set(H264Const.coeffToken(2, 1), "01111");
    vbl.set(H264Const.coeffToken(2, 2), "1101");
    vbl.set(H264Const.coeffToken(3, 0), "001000");
    vbl.set(H264Const.coeffToken(3, 1), "01100");
    vbl.set(H264Const.coeffToken(3, 2), "01110");
    vbl.set(H264Const.coeffToken(3, 3), "1100");
    vbl.set(H264Const.coeffToken(4, 0), "0001111");
    vbl.set(H264Const.coeffToken(4, 1), "01010");
    vbl.set(H264Const.coeffToken(4, 2), "01011");
    vbl.set(H264Const.coeffToken(4, 3), "1011");
    vbl.set(H264Const.coeffToken(5, 0), "0001011");
    vbl.set(H264Const.coeffToken(5, 1), "01000");
    vbl.set(H264Const.coeffToken(5, 2), "01001");
    vbl.set(H264Const.coeffToken(5, 3), "1010");
    vbl.set(H264Const.coeffToken(6, 0), "0001001");
    vbl.set(H264Const.coeffToken(6, 1), "001110");
    vbl.set(H264Const.coeffToken(6, 2), "001101");
    vbl.set(H264Const.coeffToken(6, 3), "1001");
    vbl.set(H264Const.coeffToken(7, 0), "0001000");
    vbl.set(H264Const.coeffToken(7, 1), "001010");
    vbl.set(H264Const.coeffToken(7, 2), "001001");
    vbl.set(H264Const.coeffToken(7, 3), "1000");
    vbl.set(H264Const.coeffToken(8, 0), "00001111");
    vbl.set(H264Const.coeffToken(8, 1), "0001110");
    vbl.set(H264Const.coeffToken(8, 2), "0001101");
    vbl.set(H264Const.coeffToken(8, 3), "01101");
    vbl.set(H264Const.coeffToken(9, 0), "00001011");
    vbl.set(H264Const.coeffToken(9, 1), "00001110");
    vbl.set(H264Const.coeffToken(9, 2), "0001010");
    vbl.set(H264Const.coeffToken(9, 3), "001100");
    vbl.set(H264Const.coeffToken(10, 0), "000001111");
    vbl.set(H264Const.coeffToken(10, 1), "00001010");
    vbl.set(H264Const.coeffToken(10, 2), "00001101");
    vbl.set(H264Const.coeffToken(10, 3), "0001100");
    vbl.set(H264Const.coeffToken(11, 0), "000001011");
    vbl.set(H264Const.coeffToken(11, 1), "000001110");
    vbl.set(H264Const.coeffToken(11, 2), "00001001");
    vbl.set(H264Const.coeffToken(11, 3), "00001100");
    vbl.set(H264Const.coeffToken(12, 0), "000001000");
    vbl.set(H264Const.coeffToken(12, 1), "000001010");
    vbl.set(H264Const.coeffToken(12, 2), "000001101");
    vbl.set(H264Const.coeffToken(12, 3), "00001000");
    vbl.set(H264Const.coeffToken(13, 0), "0000001101");
    vbl.set(H264Const.coeffToken(13, 1), "000000111");
    vbl.set(H264Const.coeffToken(13, 2), "000001001");
    vbl.set(H264Const.coeffToken(13, 3), "000001100");
    vbl.set(H264Const.coeffToken(14, 0), "0000001001");
    vbl.set(H264Const.coeffToken(14, 1), "0000001100");
    vbl.set(H264Const.coeffToken(14, 2), "0000001011");
    vbl.set(H264Const.coeffToken(14, 3), "0000001010");
    vbl.set(H264Const.coeffToken(15, 0), "0000000101");
    vbl.set(H264Const.coeffToken(15, 1), "0000001000");
    vbl.set(H264Const.coeffToken(15, 2), "0000000111");
    vbl.set(H264Const.coeffToken(15, 3), "0000000110");
    vbl.set(H264Const.coeffToken(16, 0), "0000000001");
    vbl.set(H264Const.coeffToken(16, 1), "0000000100");
    vbl.set(H264Const.coeffToken(16, 2), "0000000011");
    vbl.set(H264Const.coeffToken(16, 3), "0000000010");
    H264Const.CoeffToken[4] = H264Const.CoeffToken[5] = H264Const.CoeffToken[6] = H264Const.CoeffToken[7] = vbl.getVLC();
})();
(function() {
    var vbl = new VLCBuilder();
    vbl.set(H264Const.coeffToken(0, 0), "000011");
    vbl.set(H264Const.coeffToken(1, 0), "000000");
    vbl.set(H264Const.coeffToken(1, 1), "000001");
    vbl.set(H264Const.coeffToken(2, 0), "000100");
    vbl.set(H264Const.coeffToken(2, 1), "000101");
    vbl.set(H264Const.coeffToken(2, 2), "000110");
    vbl.set(H264Const.coeffToken(3, 0), "001000");
    vbl.set(H264Const.coeffToken(3, 1), "001001");
    vbl.set(H264Const.coeffToken(3, 2), "001010");
    vbl.set(H264Const.coeffToken(3, 3), "001011");
    vbl.set(H264Const.coeffToken(4, 0), "001100");
    vbl.set(H264Const.coeffToken(4, 1), "001101");
    vbl.set(H264Const.coeffToken(4, 2), "001110");
    vbl.set(H264Const.coeffToken(4, 3), "001111");
    vbl.set(H264Const.coeffToken(5, 0), "010000");
    vbl.set(H264Const.coeffToken(5, 1), "010001");
    vbl.set(H264Const.coeffToken(5, 2), "010010");
    vbl.set(H264Const.coeffToken(5, 3), "010011");
    vbl.set(H264Const.coeffToken(6, 0), "010100");
    vbl.set(H264Const.coeffToken(6, 1), "010101");
    vbl.set(H264Const.coeffToken(6, 2), "010110");
    vbl.set(H264Const.coeffToken(6, 3), "010111");
    vbl.set(H264Const.coeffToken(7, 0), "011000");
    vbl.set(H264Const.coeffToken(7, 1), "011001");
    vbl.set(H264Const.coeffToken(7, 2), "011010");
    vbl.set(H264Const.coeffToken(7, 3), "011011");
    vbl.set(H264Const.coeffToken(8, 0), "011100");
    vbl.set(H264Const.coeffToken(8, 1), "011101");
    vbl.set(H264Const.coeffToken(8, 2), "011110");
    vbl.set(H264Const.coeffToken(8, 3), "011111");
    vbl.set(H264Const.coeffToken(9, 0), "100000");
    vbl.set(H264Const.coeffToken(9, 1), "100001");
    vbl.set(H264Const.coeffToken(9, 2), "100010");
    vbl.set(H264Const.coeffToken(9, 3), "100011");
    vbl.set(H264Const.coeffToken(10, 0), "100100");
    vbl.set(H264Const.coeffToken(10, 1), "100101");
    vbl.set(H264Const.coeffToken(10, 2), "100110");
    vbl.set(H264Const.coeffToken(10, 3), "100111");
    vbl.set(H264Const.coeffToken(11, 0), "101000");
    vbl.set(H264Const.coeffToken(11, 1), "101001");
    vbl.set(H264Const.coeffToken(11, 2), "101010");
    vbl.set(H264Const.coeffToken(11, 3), "101011");
    vbl.set(H264Const.coeffToken(12, 0), "101100");
    vbl.set(H264Const.coeffToken(12, 1), "101101");
    vbl.set(H264Const.coeffToken(12, 2), "101110");
    vbl.set(H264Const.coeffToken(12, 3), "101111");
    vbl.set(H264Const.coeffToken(13, 0), "110000");
    vbl.set(H264Const.coeffToken(13, 1), "110001");
    vbl.set(H264Const.coeffToken(13, 2), "110010");
    vbl.set(H264Const.coeffToken(13, 3), "110011");
    vbl.set(H264Const.coeffToken(14, 0), "110100");
    vbl.set(H264Const.coeffToken(14, 1), "110101");
    vbl.set(H264Const.coeffToken(14, 2), "110110");
    vbl.set(H264Const.coeffToken(14, 3), "110111");
    vbl.set(H264Const.coeffToken(15, 0), "111000");
    vbl.set(H264Const.coeffToken(15, 1), "111001");
    vbl.set(H264Const.coeffToken(15, 2), "111010");
    vbl.set(H264Const.coeffToken(15, 3), "111011");
    vbl.set(H264Const.coeffToken(16, 0), "111100");
    vbl.set(H264Const.coeffToken(16, 1), "111101");
    vbl.set(H264Const.coeffToken(16, 2), "111110");
    vbl.set(H264Const.coeffToken(16, 3), "111111");
    H264Const.CoeffToken[8] = vbl.getVLC();
})();
(function() {
    var vbl = new VLCBuilder();
    vbl.set(H264Const.coeffToken(0, 0), "01");
    vbl.set(H264Const.coeffToken(1, 0), "000111");
    vbl.set(H264Const.coeffToken(1, 1), "1");
    vbl.set(H264Const.coeffToken(2, 0), "000100");
    vbl.set(H264Const.coeffToken(2, 1), "000110");
    vbl.set(H264Const.coeffToken(2, 2), "001");
    vbl.set(H264Const.coeffToken(3, 0), "000011");
    vbl.set(H264Const.coeffToken(3, 1), "0000011");
    vbl.set(H264Const.coeffToken(3, 2), "0000010");
    vbl.set(H264Const.coeffToken(3, 3), "000101");
    vbl.set(H264Const.coeffToken(4, 0), "000010");
    vbl.set(H264Const.coeffToken(4, 1), "00000011");
    vbl.set(H264Const.coeffToken(4, 2), "00000010");
    vbl.set(H264Const.coeffToken(4, 3), "0000000");
    H264Const.coeffTokenChromaDCY420 = vbl.getVLC();
})();
(function() {
    var vbl = new VLCBuilder();
    vbl.set(H264Const.coeffToken(0, 0), "1");
    vbl.set(H264Const.coeffToken(1, 0), "0001111");
    vbl.set(H264Const.coeffToken(1, 1), "01");
    vbl.set(H264Const.coeffToken(2, 0), "0001110");
    vbl.set(H264Const.coeffToken(2, 1), "0001101");
    vbl.set(H264Const.coeffToken(2, 2), "001");
    vbl.set(H264Const.coeffToken(3, 0), "000000111");
    vbl.set(H264Const.coeffToken(3, 1), "0001100");
    vbl.set(H264Const.coeffToken(3, 2), "0001011");
    vbl.set(H264Const.coeffToken(3, 3), "00001");
    vbl.set(H264Const.coeffToken(4, 0), "000000110");
    vbl.set(H264Const.coeffToken(4, 1), "000000101");
    vbl.set(H264Const.coeffToken(4, 2), "0001010");
    vbl.set(H264Const.coeffToken(4, 3), "000001");
    vbl.set(H264Const.coeffToken(5, 0), "0000000111");
    vbl.set(H264Const.coeffToken(5, 1), "0000000110");
    vbl.set(H264Const.coeffToken(5, 2), "000000100");
    vbl.set(H264Const.coeffToken(5, 3), "0001001");
    vbl.set(H264Const.coeffToken(6, 0), "00000000111");
    vbl.set(H264Const.coeffToken(6, 1), "00000000110");
    vbl.set(H264Const.coeffToken(6, 2), "0000000101");
    vbl.set(H264Const.coeffToken(6, 3), "0001000");
    vbl.set(H264Const.coeffToken(7, 0), "000000000111");
    vbl.set(H264Const.coeffToken(7, 1), "000000000110");
    vbl.set(H264Const.coeffToken(7, 2), "00000000101");
    vbl.set(H264Const.coeffToken(7, 3), "0000000100");
    vbl.set(H264Const.coeffToken(8, 0), "0000000000111");
    vbl.set(H264Const.coeffToken(8, 1), "000000000101");
    vbl.set(H264Const.coeffToken(8, 2), "000000000100");
    vbl.set(H264Const.coeffToken(8, 3), "00000000100");
    H264Const.coeffTokenChromaDCY422 = vbl.getVLC();
})();
(function() {
    H264Const.run = [new VLCBuilder().set(0, "1").set(1, "0").getVLC(), new VLCBuilder().set(0, "1").set(1, "01").set(2, "00").getVLC(), new VLCBuilder().set(0, "11").set(1, "10").set(2, "01").set(3, "00").getVLC(), new VLCBuilder().set(0, "11").set(1, "10").set(2, "01").set(3, "001").set(4, "000").getVLC(), new VLCBuilder().set(0, "11").set(1, "10").set(2, "011").set(3, "010").set(4, "001").set(5, "000").getVLC(), new VLCBuilder().set(0, "11").set(1, "000").set(2, "001").set(3, "011").set(4, "010").set(5, "101").set(6, "100").getVLC(), new VLCBuilder().set(0, "111").set(1, "110").set(2, "101").set(3, "100").set(4, "011").set(5, "010").set(6, "001").set(7, "0001").set(8, "00001").set(9, "000001").set(10, "0000001").set(11, "00000001").set(12, "000000001").set(13, "0000000001").set(14, "00000000001").getVLC()];
})();
(function() {
    var tmp = new Int32Array(16);
    for (var blk = 0; blk < 16; blk++) {
        for (var i = 0; i < 16; i++) {
            tmp[i] = i;
        }
        H264Const.putBlk(tmp, H264Const.BLK_X[blk], H264Const.BLK_Y[blk], 4, 4, 16, H264Const.LUMA_4x4_POS_LUT);
        Arrays.fill(tmp, blk);
        H264Const.putBlk(tmp, H264Const.BLK_X[blk], H264Const.BLK_Y[blk], 4, 4, 16, H264Const.LUMA_4x4_BLOCK_LUT);
    }
    for (var blk = 0; blk < 4; blk++) {
        for (var i = 0; i < 16; i++) {
            tmp[i] = i;
        }
        H264Const.putBlk(tmp, H264Const.BLK_X[blk], H264Const.BLK_Y[blk], 4, 4, 8, H264Const.CHROMA_POS_LUT);
        Arrays.fill(tmp, blk);
        H264Const.putBlk(tmp, H264Const.BLK_X[blk], H264Const.BLK_Y[blk], 4, 4, 8, H264Const.CHROMA_BLOCK_LUT);
    }
    tmp = new Int32Array(64);
    for (var blk = 0; blk < 4; blk++) {
        for (var i = 0; i < 64; i++) {
            tmp[i] = i;
        }
        H264Const.putBlk(tmp, H264Const.BLK_8x8_X[blk], H264Const.BLK_8x8_Y[blk], 8, 8, 16, H264Const.LUMA_8x8_POS_LUT);
        Arrays.fill(tmp, blk);
        H264Const.putBlk(tmp, H264Const.BLK_8x8_X[blk], H264Const.BLK_8x8_Y[blk], 8, 8, 16, H264Const.LUMA_8x8_BLOCK_LUT);
    }
})();
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var JpegConst = function() {};
JpegConst = stjs.extend(JpegConst, null, [], function(constructor, prototype) {
    constructor.naturalOrder = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
    constructor.YDC_DEFAULT = null;
    constructor.YAC_DEFAULT = null;
    constructor.CDC_DEFAULT = null;
    constructor.CAC_DEFAULT = null;
    constructor.names = Array(256);
    constructor.markerToString = function(marker) {
        return JpegConst.names[marker];
    };
    /**
     * Start Of Frame - Baseline DCT 
     */
    constructor.SOF0 = 192;
    /**
     * Start Of Frame - Extended sequential DCT 
     */
    constructor.SOF1 = 193;
    /**
     * Start Of Frame - Progressive DCT 
     */
    constructor.SOF2 = 194;
    /**
     * Start Of Frame - Lossless (sequential) 
     */
    constructor.SOF3 = 195;
    /**
     * Huffman table specification - Define Huffman table(s) 
     */
    constructor.DHT = 196;
    /**
     * Define quantization table(s) 
     */
    constructor.DQT = 219;
    /**
     * Start of scan 
     */
    constructor.SOS = 218;
    /**
     * End of image - standalone marker 
     */
    constructor.EOI = 217;
    /**
     * Start of image - standalone marker 
     */
    constructor.SOI = 216;
    /**
     * Reserved for application segments 
     */
    constructor.APP0 = 224;
    /**
     * Reserved for application segments 
     */
    constructor.APP1 = 225;
    /**
     * Reserved for application segments 
     */
    constructor.APP2 = 226;
    /**
     * Reserved for application segments 
     */
    constructor.APP3 = 227;
    /**
     * Reserved for application segments 
     */
    constructor.APP4 = 228;
    /**
     * Reserved for application segments 
     */
    constructor.APP5 = 229;
    /**
     * Reserved for application segments 
     */
    constructor.APP6 = 230;
    /**
     * Reserved for application segments 
     */
    constructor.APP7 = 231;
    /**
     * Reserved for application segments 
     */
    constructor.APP8 = 232;
    /**
     * Reserved for application segments 
     */
    constructor.APP9 = 233;
    /**
     * Reserved for application segments 
     */
    constructor.APPA = 234;
    /**
     * Reserved for application segments 
     */
    constructor.APPB = 235;
    /**
     * Reserved for application segments 
     */
    constructor.APPC = 236;
    /**
     * Reserved for application segments 
     */
    constructor.APPD = 237;
    /**
     * Reserved for application segments 
     */
    constructor.APPE = 238;
    /**
     * Reserved for application segments 
     */
    constructor.APPF = 239;
    /**
     * Restart with modulo 8 count 0 
     */
    constructor.RST0 = 208;
    /**
     * Restart with modulo 8 count 1 
     */
    constructor.RST1 = 209;
    /**
     * Restart with modulo 8 count 2 
     */
    constructor.RST2 = 210;
    /**
     * Restart with modulo 8 count 3 
     */
    constructor.RST3 = 211;
    /**
     * Restart with modulo 8 count 4 
     */
    constructor.RST4 = 212;
    /**
     * Restart with modulo 8 count 5 
     */
    constructor.RST5 = 213;
    /**
     * Restart with modulo 8 count 6 
     */
    constructor.RST6 = 214;
    /**
     * Restart with modulo 8 count 7 
     */
    constructor.RST7 = 215;
    constructor.COM = 254;
    /**
     * Define restart interval marker 
     */
    constructor.DRI = 221;
    constructor.DEFAULT_QUANT_LUMA = new Int32Array([16, 11, 12, 14, 12, 10, 16, 14, 13, 14, 18, 17, 16, 19, 24, 40, 26, 24, 22, 22, 24, 49, 36, 37, 29, 40, 58, 51, 61, 60, 57, 51, 56, 55, 64, 72, 92, 78, 64, 68, 87, 69, 55, 56, 80, 109, 81, 87, 95, 62, 103, 104, 103, 98, 77, 113, 121, 112, 100, 120, 92, 101, 103, 99]);
    constructor.DEFAULT_QUANT_CHROMA = new Int32Array([17, 18, 18, 24, 21, 24, 47, 26, 26, 47, 99, 66, 56, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99]);
}, {naturalOrder: "Int32Array", YDC_DEFAULT: "VLC", YAC_DEFAULT: "VLC", CDC_DEFAULT: "VLC", CAC_DEFAULT: "VLC", names: "Array", DEFAULT_QUANT_LUMA: "Int32Array", DEFAULT_QUANT_CHROMA: "Int32Array"}, {});
(function() {
    var bldr1 = new VLCBuilder();
    bldr1.set(0, "00");
    bldr1.set(1, "010");
    bldr1.set(2, "011");
    bldr1.set(3, "100");
    bldr1.set(4, "101");
    bldr1.set(5, "110");
    bldr1.set(6, "1110");
    bldr1.set(7, "11110");
    bldr1.set(8, "111110");
    bldr1.set(9, "1111110");
    bldr1.set(10, "11111110");
    bldr1.set(11, "111111110");
    JpegConst.YDC_DEFAULT = bldr1.getVLC();
    var bldr2 = new VLCBuilder();
    bldr2.set(0, "00");
    bldr2.set(1, "01");
    bldr2.set(2, "10");
    bldr2.set(3, "110");
    bldr2.set(4, "1110");
    bldr2.set(5, "11110");
    bldr2.set(6, "111110");
    bldr2.set(7, "1111110");
    bldr2.set(8, "11111110");
    bldr2.set(9, "111111110");
    bldr2.set(10, "1111111110");
    bldr2.set(11, "11111111110");
    JpegConst.CDC_DEFAULT = bldr2.getVLC();
    var bldr3 = new VLCBuilder();
    bldr3.set(0, "1010");
    bldr3.set(1, "00");
    bldr3.set(2, "01");
    bldr3.set(3, "100");
    bldr3.set(4, "1011");
    bldr3.set(5, "11010");
    bldr3.set(6, "1111000");
    bldr3.set(7, "11111000");
    bldr3.set(8, "1111110110");
    bldr3.set(9, "1111111110000010");
    bldr3.set(10, "1111111110000011");
    bldr3.set(17, "1100");
    bldr3.set(18, "11011");
    bldr3.set(19, "1111001");
    bldr3.set(20, "111110110");
    bldr3.set(21, "11111110110");
    bldr3.set(22, "1111111110000100");
    bldr3.set(23, "1111111110000101");
    bldr3.set(24, "1111111110000110");
    bldr3.set(25, "1111111110000111");
    bldr3.set(26, "1111111110001000");
    bldr3.set(33, "11100");
    bldr3.set(34, "11111001");
    bldr3.set(35, "1111110111");
    bldr3.set(36, "111111110100");
    bldr3.set(37, "1111111110001001");
    bldr3.set(38, "1111111110001010");
    bldr3.set(39, "1111111110001011");
    bldr3.set(40, "1111111110001100");
    bldr3.set(41, "1111111110001101");
    bldr3.set(42, "1111111110001110");
    bldr3.set(49, "111010");
    bldr3.set(50, "111110111");
    bldr3.set(51, "111111110101");
    bldr3.set(52, "1111111110001111");
    bldr3.set(53, "1111111110010000");
    bldr3.set(54, "1111111110010001");
    bldr3.set(55, "1111111110010010");
    bldr3.set(56, "1111111110010011");
    bldr3.set(57, "1111111110010100");
    bldr3.set(58, "1111111110010101");
    bldr3.set(65, "111011");
    bldr3.set(66, "1111111000");
    bldr3.set(67, "1111111110010110");
    bldr3.set(68, "1111111110010111");
    bldr3.set(69, "1111111110011000");
    bldr3.set(70, "1111111110011001");
    bldr3.set(71, "1111111110011010");
    bldr3.set(72, "1111111110011011");
    bldr3.set(73, "1111111110011100");
    bldr3.set(74, "1111111110011101");
    bldr3.set(81, "1111010");
    bldr3.set(82, "11111110111");
    bldr3.set(83, "1111111110011110");
    bldr3.set(84, "1111111110011111");
    bldr3.set(85, "1111111110100000");
    bldr3.set(86, "1111111110100001");
    bldr3.set(87, "1111111110100010");
    bldr3.set(88, "1111111110100011");
    bldr3.set(89, "1111111110100100");
    bldr3.set(90, "1111111110100101");
    bldr3.set(97, "1111011");
    bldr3.set(98, "111111110110");
    bldr3.set(99, "1111111110100110");
    bldr3.set(100, "1111111110100111");
    bldr3.set(101, "1111111110101000");
    bldr3.set(102, "1111111110101001");
    bldr3.set(103, "1111111110101010");
    bldr3.set(104, "1111111110101011");
    bldr3.set(105, "1111111110101100");
    bldr3.set(106, "1111111110101101");
    bldr3.set(113, "11111010");
    bldr3.set(114, "111111110111");
    bldr3.set(115, "1111111110101110");
    bldr3.set(116, "1111111110101111");
    bldr3.set(117, "1111111110110000");
    bldr3.set(118, "1111111110110001");
    bldr3.set(119, "1111111110110010");
    bldr3.set(120, "1111111110110011");
    bldr3.set(121, "1111111110110100");
    bldr3.set(122, "1111111110110101");
    bldr3.set(129, "111111000");
    bldr3.set(130, "111111111000000");
    bldr3.set(131, "1111111110110110");
    bldr3.set(132, "1111111110110111");
    bldr3.set(133, "1111111110111000");
    bldr3.set(134, "1111111110111001");
    bldr3.set(135, "1111111110111010");
    bldr3.set(136, "1111111110111011");
    bldr3.set(137, "1111111110111100");
    bldr3.set(138, "1111111110111101");
    bldr3.set(145, "111111001");
    bldr3.set(146, "1111111110111110");
    bldr3.set(147, "1111111110111111");
    bldr3.set(148, "1111111111000000");
    bldr3.set(149, "1111111111000001");
    bldr3.set(150, "1111111111000010");
    bldr3.set(151, "1111111111000011");
    bldr3.set(152, "1111111111000100");
    bldr3.set(153, "1111111111000101");
    bldr3.set(154, "1111111111000110");
    bldr3.set(161, "111111010");
    bldr3.set(162, "1111111111000111");
    bldr3.set(163, "1111111111001000");
    bldr3.set(164, "1111111111001001");
    bldr3.set(165, "1111111111001010");
    bldr3.set(166, "1111111111001011");
    bldr3.set(167, "1111111111001100");
    bldr3.set(168, "1111111111001101");
    bldr3.set(169, "1111111111001110");
    bldr3.set(170, "1111111111001111");
    bldr3.set(177, "1111111001");
    bldr3.set(178, "1111111111010000");
    bldr3.set(179, "1111111111010001");
    bldr3.set(180, "1111111111010010");
    bldr3.set(181, "1111111111010011");
    bldr3.set(182, "1111111111010100");
    bldr3.set(183, "1111111111010101");
    bldr3.set(184, "1111111111010110");
    bldr3.set(185, "1111111111010111");
    bldr3.set(186, "1111111111011000");
    bldr3.set(193, "1111111010");
    bldr3.set(194, "1111111111011001");
    bldr3.set(195, "1111111111011010");
    bldr3.set(196, "1111111111011011");
    bldr3.set(197, "1111111111011100");
    bldr3.set(198, "1111111111011101");
    bldr3.set(199, "1111111111011110");
    bldr3.set(200, "1111111111011111");
    bldr3.set(201, "1111111111100000");
    bldr3.set(202, "1111111111100001");
    bldr3.set(209, "11111111000");
    bldr3.set(210, "1111111111100010");
    bldr3.set(211, "1111111111100011");
    bldr3.set(212, "1111111111100100");
    bldr3.set(213, "1111111111100101");
    bldr3.set(214, "1111111111100110");
    bldr3.set(215, "1111111111100111");
    bldr3.set(216, "1111111111101000");
    bldr3.set(217, "1111111111101001");
    bldr3.set(218, "1111111111101010");
    bldr3.set(225, "1111111111101011");
    bldr3.set(226, "1111111111101100");
    bldr3.set(227, "1111111111101101");
    bldr3.set(228, "1111111111101110");
    bldr3.set(229, "1111111111101111");
    bldr3.set(230, "1111111111110000");
    bldr3.set(231, "1111111111110001");
    bldr3.set(232, "1111111111110010");
    bldr3.set(233, "1111111111110011");
    bldr3.set(234, "1111111111110100");
    bldr3.set(240, "11111111001");
    bldr3.set(241, "1111111111110101");
    bldr3.set(242, "1111111111110110");
    bldr3.set(243, "1111111111110111");
    bldr3.set(244, "1111111111111000");
    bldr3.set(245, "1111111111111001");
    bldr3.set(246, "1111111111111010");
    bldr3.set(247, "1111111111111011");
    bldr3.set(248, "1111111111111100");
    bldr3.set(249, "1111111111111101");
    bldr3.set(250, "1111111111111110");
    JpegConst.YAC_DEFAULT = bldr3.getVLC();
    var bldr4 = new VLCBuilder();
    bldr4.set(0, "00");
    bldr4.set(1, "01");
    bldr4.set(2, "100");
    bldr4.set(3, "1010");
    bldr4.set(4, "11000");
    bldr4.set(5, "11001");
    bldr4.set(6, "111000");
    bldr4.set(7, "1111000");
    bldr4.set(8, "111110100");
    bldr4.set(9, "1111110110");
    bldr4.set(10, "111111110100");
    bldr4.set(17, "1011");
    bldr4.set(18, "111001");
    bldr4.set(19, "11110110");
    bldr4.set(20, "111110101");
    bldr4.set(21, "11111110110");
    bldr4.set(22, "111111110101");
    bldr4.set(23, "1111111110001000");
    bldr4.set(24, "1111111110001001");
    bldr4.set(25, "1111111110001010");
    bldr4.set(26, "1111111110001011");
    bldr4.set(33, "11010");
    bldr4.set(34, "11110111");
    bldr4.set(35, "1111110111");
    bldr4.set(36, "111111110110");
    bldr4.set(37, "111111111000010");
    bldr4.set(38, "1111111110001100");
    bldr4.set(39, "1111111110001101");
    bldr4.set(40, "1111111110001110");
    bldr4.set(41, "1111111110001111");
    bldr4.set(42, "1111111110010000");
    bldr4.set(49, "11011");
    bldr4.set(50, "11111000");
    bldr4.set(51, "1111111000");
    bldr4.set(52, "111111110111");
    bldr4.set(53, "1111111110010001");
    bldr4.set(54, "1111111110010010");
    bldr4.set(55, "1111111110010011");
    bldr4.set(56, "1111111110010100");
    bldr4.set(57, "1111111110010101");
    bldr4.set(58, "1111111110010110");
    bldr4.set(65, "111010");
    bldr4.set(66, "111110110");
    bldr4.set(67, "1111111110010111");
    bldr4.set(68, "1111111110011000");
    bldr4.set(69, "1111111110011001");
    bldr4.set(70, "1111111110011010");
    bldr4.set(71, "1111111110011011");
    bldr4.set(72, "1111111110011100");
    bldr4.set(73, "1111111110011101");
    bldr4.set(74, "1111111110011110");
    bldr4.set(81, "111011");
    bldr4.set(82, "1111111001");
    bldr4.set(83, "1111111110011111");
    bldr4.set(84, "1111111110100000");
    bldr4.set(85, "1111111110100001");
    bldr4.set(86, "1111111110100010");
    bldr4.set(87, "1111111110100011");
    bldr4.set(88, "1111111110100100");
    bldr4.set(89, "1111111110100101");
    bldr4.set(90, "1111111110100110");
    bldr4.set(97, "1111001");
    bldr4.set(98, "11111110111");
    bldr4.set(99, "1111111110100111");
    bldr4.set(100, "1111111110101000");
    bldr4.set(101, "1111111110101001");
    bldr4.set(102, "1111111110101010");
    bldr4.set(103, "1111111110101011");
    bldr4.set(104, "1111111110101100");
    bldr4.set(105, "1111111110101101");
    bldr4.set(106, "1111111110101110");
    bldr4.set(113, "1111010");
    bldr4.set(114, "11111111000");
    bldr4.set(115, "1111111110101111");
    bldr4.set(116, "1111111110110000");
    bldr4.set(117, "1111111110110001");
    bldr4.set(118, "1111111110110010");
    bldr4.set(119, "1111111110110011");
    bldr4.set(120, "1111111110110100");
    bldr4.set(121, "1111111110110101");
    bldr4.set(122, "1111111110110110");
    bldr4.set(129, "11111001");
    bldr4.set(130, "1111111110110111");
    bldr4.set(131, "1111111110111000");
    bldr4.set(132, "1111111110111001");
    bldr4.set(133, "1111111110111010");
    bldr4.set(134, "1111111110111011");
    bldr4.set(135, "1111111110111100");
    bldr4.set(136, "1111111110111101");
    bldr4.set(137, "1111111110111110");
    bldr4.set(138, "1111111110111111");
    bldr4.set(145, "111110111");
    bldr4.set(146, "1111111111000000");
    bldr4.set(147, "1111111111000001");
    bldr4.set(148, "1111111111000010");
    bldr4.set(149, "1111111111000011");
    bldr4.set(150, "1111111111000100");
    bldr4.set(151, "1111111111000101");
    bldr4.set(152, "1111111111000110");
    bldr4.set(153, "1111111111000111");
    bldr4.set(154, "1111111111001000");
    bldr4.set(161, "111111000");
    bldr4.set(162, "1111111111001001");
    bldr4.set(163, "1111111111001010");
    bldr4.set(164, "1111111111001011");
    bldr4.set(165, "1111111111001100");
    bldr4.set(166, "1111111111001101");
    bldr4.set(167, "1111111111001110");
    bldr4.set(168, "1111111111001111");
    bldr4.set(169, "1111111111010000");
    bldr4.set(170, "1111111111010001");
    bldr4.set(177, "111111001");
    bldr4.set(178, "1111111111010010");
    bldr4.set(179, "1111111111010011");
    bldr4.set(180, "1111111111010100");
    bldr4.set(181, "1111111111010101");
    bldr4.set(182, "1111111111010110");
    bldr4.set(183, "1111111111010111");
    bldr4.set(184, "1111111111011000");
    bldr4.set(185, "1111111111011001");
    bldr4.set(186, "1111111111011010");
    bldr4.set(193, "111111010");
    bldr4.set(194, "1111111111011011");
    bldr4.set(195, "1111111111011100");
    bldr4.set(196, "1111111111011101");
    bldr4.set(197, "1111111111011110");
    bldr4.set(198, "1111111111011111");
    bldr4.set(199, "1111111111100000");
    bldr4.set(200, "1111111111100001");
    bldr4.set(201, "1111111111100010");
    bldr4.set(202, "1111111111100011");
    bldr4.set(209, "11111111001");
    bldr4.set(210, "1111111111100100");
    bldr4.set(211, "1111111111100101");
    bldr4.set(212, "1111111111100110");
    bldr4.set(213, "1111111111100111");
    bldr4.set(214, "1111111111101000");
    bldr4.set(215, "1111111111101001");
    bldr4.set(216, "1111111111101010");
    bldr4.set(217, "1111111111101011");
    bldr4.set(218, "1111111111101100");
    bldr4.set(225, "11111111100000");
    bldr4.set(226, "1111111111101101");
    bldr4.set(227, "1111111111101110");
    bldr4.set(228, "1111111111101111");
    bldr4.set(229, "1111111111110000");
    bldr4.set(230, "1111111111110001");
    bldr4.set(231, "1111111111110010");
    bldr4.set(232, "1111111111110011");
    bldr4.set(233, "1111111111110100");
    bldr4.set(234, "1111111111110101");
    bldr4.set(240, "1111111010");
    bldr4.set(241, "111111111000011");
    bldr4.set(242, "1111111111110110");
    bldr4.set(243, "1111111111110111");
    bldr4.set(244, "1111111111111000");
    bldr4.set(245, "1111111111111001");
    bldr4.set(246, "1111111111111010");
    bldr4.set(247, "1111111111111011");
    bldr4.set(248, "1111111111111100");
    bldr4.set(249, "1111111111111101");
    bldr4.set(250, "1111111111111110");
    JpegConst.CAC_DEFAULT = bldr4.getVLC();
})();
(function() {
    for (var i = 0; i < JpegConst.names.length; i++) {
        JpegConst.names[i] = "(0x" + Integer.toHexString(i) + ")";
    }
    JpegConst.names[192] = "SOF0";
    JpegConst.names[193] = "SOF1";
    JpegConst.names[194] = "SOF2";
    JpegConst.names[195] = "SOF3";
    JpegConst.names[196] = "DHT";
    JpegConst.names[219] = "DQT";
    JpegConst.names[218] = "SOS";
    JpegConst.names[217] = "EOI";
    JpegConst.names[216] = "SOI";
    JpegConst.names[224] = "APP0";
    JpegConst.names[225] = "APP1";
    JpegConst.names[226] = "APP2";
    JpegConst.names[227] = "APP3";
    JpegConst.names[228] = "APP4";
    JpegConst.names[229] = "APP5";
    JpegConst.names[230] = "APP6";
    JpegConst.names[231] = "APP7";
    JpegConst.names[232] = "APP8";
    JpegConst.names[233] = "APP9";
    JpegConst.names[234] = "APPA";
    JpegConst.names[235] = "APPB";
    JpegConst.names[236] = "APPC";
    JpegConst.names[237] = "APPD";
    JpegConst.names[238] = "APPE";
    JpegConst.names[239] = "APPF";
    JpegConst.names[208] = "RST0";
    JpegConst.names[209] = "RST1";
    JpegConst.names[210] = "RST2";
    JpegConst.names[211] = "RST3";
    JpegConst.names[212] = "RST4";
    JpegConst.names[213] = "RST5";
    JpegConst.names[214] = "RST6";
    JpegConst.names[215] = "RST7";
    JpegConst.names[221] = "DRI";
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEGConst = function() {};
MPEGConst = stjs.extend(MPEGConst, null, [], function(constructor, prototype) {
    constructor.PICTURE_START_CODE = 0;
    constructor.SLICE_START_CODE_FIRST = 1;
    constructor.SLICE_START_CODE_LAST = 175;
    constructor.USER_DATA_START_CODE = 178;
    constructor.SEQUENCE_HEADER_CODE = 179;
    constructor.SEQUENCE_ERROR_CODE = 180;
    constructor.EXTENSION_START_CODE = 181;
    constructor.SEQUENCE_END_CODE = 183;
    constructor.GROUP_START_CODE = 184;
    constructor.vlcAddressIncrement = null;
    constructor.vlcMBTypeI = null;
    constructor.mbTypeValI = null;
    constructor.vlcMBTypeP = null;
    constructor.mbTypeValP = null;
    constructor.vlcMBTypeB = null;
    constructor.mbTypeValB = null;
    constructor.vlcMBTypeISpat = null;
    constructor.mbTypeValISpat = null;
    constructor.vlcMBTypePSpat = null;
    constructor.mbTypeValPSpat = null;
    constructor.vlcMBTypeBSpat = null;
    constructor.mbTypeValBSpat = null;
    constructor.vlcMBTypeSNR = null;
    constructor.mbTypeValSNR = null;
    constructor.vlcCBP = null;
    constructor.vlcMotionCode = null;
    constructor.vlcDualPrime = null;
    constructor.vlcDCSizeLuma = null;
    constructor.vlcDCSizeChroma = null;
    constructor.vlcCoeff0 = null;
    constructor.vlcCoeff1 = null;
    constructor.MBType = function(macroblock_quant, macroblock_motion_forward, macroblock_motion_backward, macroblock_pattern, macroblock_intra, spatial_temporal_weight_code_flag, permitted_spatial_temporal_weight_classes) {
        this.macroblock_quant = macroblock_quant;
        this.macroblock_motion_forward = macroblock_motion_forward;
        this.macroblock_motion_backward = macroblock_motion_backward;
        this.macroblock_pattern = macroblock_pattern;
        this.macroblock_intra = macroblock_intra;
        this.spatial_temporal_weight_code_flag = spatial_temporal_weight_code_flag;
        this.permitted_spatial_temporal_weight_classes = permitted_spatial_temporal_weight_classes;
    };
    constructor.MBType = stjs.extend(constructor.MBType, null, [], function(constructor, prototype) {
        prototype.macroblock_quant = 0;
        prototype.macroblock_motion_forward = 0;
        prototype.macroblock_motion_backward = 0;
        prototype.macroblock_pattern = 0;
        prototype.macroblock_intra = 0;
        prototype.spatial_temporal_weight_code_flag = 0;
        prototype.permitted_spatial_temporal_weight_classes = 0;
    }, {}, {});
    constructor.CODE_ESCAPE = 2049;
    constructor.CODE_END = 2048;
    constructor.qScaleTab1 = new Int32Array([0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62]);
    constructor.qScaleTab2 = new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 18, 20, 22, 24, 28, 32, 36, 40, 44, 48, 52, 56, 64, 72, 80, 88, 96, 104, 112]);
    constructor.defaultQMatIntra = new Int32Array([8, 16, 19, 22, 26, 27, 29, 34, 16, 16, 22, 24, 27, 29, 34, 37, 19, 22, 26, 27, 29, 34, 34, 38, 22, 22, 26, 27, 29, 34, 37, 40, 22, 26, 27, 29, 32, 35, 40, 48, 26, 27, 29, 32, 35, 40, 48, 58, 26, 27, 29, 34, 38, 46, 56, 69, 27, 29, 35, 38, 46, 56, 69, 83]);
    constructor.defaultQMatInter = new Int32Array([16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]);
    constructor.scan = [new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), new Int32Array([0, 8, 16, 24, 1, 9, 2, 10, 17, 25, 32, 40, 48, 56, 57, 49, 41, 33, 26, 18, 3, 11, 4, 12, 19, 27, 34, 42, 50, 58, 35, 43, 51, 59, 20, 28, 5, 13, 6, 14, 21, 29, 36, 44, 52, 60, 37, 45, 53, 61, 22, 30, 7, 15, 23, 31, 38, 46, 54, 62, 39, 47, 55, 63])];
    constructor.BLOCK_TO_CC = new Int32Array([0, 0, 0, 0, 1, 2, 1, 2, 1, 2, 1, 2]);
    constructor.BLOCK_POS_X = new Int32Array([0, 8, 0, 8, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 8, 8, 8, 8]);
    constructor.BLOCK_POS_Y = new Int32Array([0, 0, 8, 8, 0, 0, 8, 8, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]);
    constructor.STEP_Y = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);
    constructor.SQUEEZE_X = new Int32Array([0, 1, 1, 0]);
    constructor.SQUEEZE_Y = new Int32Array([0, 1, 0, 0]);
    constructor.IntraCoded = 1;
    constructor.PredictiveCoded = 2;
    constructor.BiPredictiveCoded = 3;
}, {vlcAddressIncrement: "VLC", vlcMBTypeI: "VLC", mbTypeValI: "Array", vlcMBTypeP: "VLC", mbTypeValP: "Array", vlcMBTypeB: "VLC", mbTypeValB: "Array", vlcMBTypeISpat: "VLC", mbTypeValISpat: "Array", vlcMBTypePSpat: "VLC", mbTypeValPSpat: "Array", vlcMBTypeBSpat: "VLC", mbTypeValBSpat: "Array", vlcMBTypeSNR: "VLC", mbTypeValSNR: "Array", vlcCBP: "VLC", vlcMotionCode: "VLC", vlcDualPrime: "VLC", vlcDCSizeLuma: "VLC", vlcDCSizeChroma: "VLC", vlcCoeff0: "VLC", vlcCoeff1: "VLC", qScaleTab1: "Int32Array", qScaleTab2: "Int32Array", defaultQMatIntra: "Int32Array", defaultQMatInter: "Int32Array", scan: "Array", BLOCK_TO_CC: "Int32Array", BLOCK_POS_X: "Int32Array", BLOCK_POS_Y: "Int32Array", STEP_Y: "Int32Array", SQUEEZE_X: "Int32Array", SQUEEZE_Y: "Int32Array"}, {});
(function() {
    MPEGConst.vlcAddressIncrement = VLC.createVLC("1", "011", "010", "0011", "0010", "00011", "00010", "0000111", "0000110", "00001011", "00001010", "00001001", "00001000", "00000111", "00000110", "0000010111", "0000010110", "0000010101", "0000010100", "0000010011", "0000010010", "00000100011", "00000100010", "00000100001", "00000100000", "00000011111", "00000011110", "00000011101", "00000011100", "00000011011", "00000011010", "00000011001", "00000011000");
    MPEGConst.vlcMBTypeI = VLC.createVLC("1", "01");
    MPEGConst.mbTypeValI = [new MPEGConst.MBType(0, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(1, 0, 0, 0, 1, 0, 0)];
    MPEGConst.vlcMBTypeP = VLC.createVLC("1", "01", "001", "00011", "00010", "00001", "000001");
    MPEGConst.mbTypeValP = [new MPEGConst.MBType(0, 1, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 1, 0, 0, 0, 0, 0), new MPEGConst.MBType(0, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(1, 1, 0, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 0, 1, 0, 0)];
    MPEGConst.vlcMBTypeB = VLC.createVLC("10", "11", "010", "011", "0010", "0011", "00011", "00010", "000011", "000010", "000001");
    MPEGConst.mbTypeValB = [new MPEGConst.MBType(0, 1, 1, 0, 0, 0, 0), new MPEGConst.MBType(0, 1, 1, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 1, 0, 0, 0, 0), new MPEGConst.MBType(0, 0, 1, 1, 0, 0, 0), new MPEGConst.MBType(0, 1, 0, 0, 0, 0, 0), new MPEGConst.MBType(0, 1, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(1, 1, 1, 1, 0, 0, 0), new MPEGConst.MBType(1, 1, 0, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 1, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 0, 1, 0, 0)];
    MPEGConst.vlcMBTypeISpat = VLC.createVLC("1", "01", "0011", "0010", "0001");
    MPEGConst.mbTypeValISpat = [new MPEGConst.MBType(0, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(1, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(0, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(1, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(0, 0, 0, 0, 0, 0, 0)];
    MPEGConst.vlcMBTypePSpat = VLC.createVLC("10", "011", "0000100", "000111", "0010", "0000111", "0011", "010", "000100", "0000110", "11", "000101", "000110", "0000101", "0000010", "0000011");
    MPEGConst.mbTypeValPSpat = [new MPEGConst.MBType(0, 1, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 1, 0, 1, 0, 1, 0), new MPEGConst.MBType(0, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 0, 1, 0, 1, 0), new MPEGConst.MBType(0, 1, 0, 0, 0, 0, 0), new MPEGConst.MBType(0, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(0, 1, 0, 0, 0, 1, 0), new MPEGConst.MBType(1, 1, 0, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(1, 1, 0, 1, 0, 1, 0), new MPEGConst.MBType(1, 0, 0, 1, 0, 1, 0), new MPEGConst.MBType(0, 0, 0, 0, 0, 1, 0), new MPEGConst.MBType(0, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 0, 0, 0, 0, 0)];
    MPEGConst.vlcMBTypeBSpat = VLC.createVLC("10", "11", "010", "011", "0010", "0011", "000110", "000111", "000100", "000101", "0000110", "0000111", "0000100", "0000101", "00000100", "00000101", "000001100", "000001110", "000001101", "000001111");
    MPEGConst.mbTypeValBSpat = [new MPEGConst.MBType(0, 1, 1, 0, 0, 0, 0), new MPEGConst.MBType(0, 1, 1, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 1, 0, 0, 0, 0), new MPEGConst.MBType(0, 0, 1, 1, 0, 0, 0), new MPEGConst.MBType(0, 1, 0, 0, 0, 0, 0), new MPEGConst.MBType(0, 1, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 1, 0, 0, 1, 0), new MPEGConst.MBType(0, 0, 1, 1, 0, 1, 0), new MPEGConst.MBType(0, 1, 0, 0, 0, 1, 0), new MPEGConst.MBType(0, 1, 0, 1, 0, 1, 0), new MPEGConst.MBType(0, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(1, 1, 1, 1, 0, 0, 0), new MPEGConst.MBType(1, 1, 0, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 1, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 0, 1, 0, 0), new MPEGConst.MBType(1, 1, 0, 1, 0, 1, 0), new MPEGConst.MBType(1, 0, 1, 1, 0, 1, 0), new MPEGConst.MBType(0, 0, 0, 0, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 0, 1, 0, 0, 0)];
    MPEGConst.vlcMBTypeSNR = VLC.createVLC("1", "01", "001");
    MPEGConst.mbTypeValSNR = [new MPEGConst.MBType(0, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(1, 0, 0, 1, 0, 0, 0), new MPEGConst.MBType(0, 0, 0, 0, 0, 0, 0)];
    MPEGConst.vlcCBP = VLC.createVLC("000000001", "01011", "01001", "001101", "1101", "0010111", "0010011", "00011111", "1100", "0010110", "0010010", "00011110", "10011", "00011011", "00010111", "00010011", "1011", "0010101", "0010001", "00011101", "10001", "00011001", "00010101", "00010001", "001111", "00001111", "00001101", "000000011", "01111", "00001011", "00000111", "000000111", "1010", "0010100", "0010000", "00011100", "001110", "00001110", "00001100", "000000010", "10000", "00011000", "00010100", "00010000", "01110", "00001010", "00000110", "000000110", "10010", "00011010", "00010110", "00010010", "01101", "00001001", "00000101", "000000101", "01100", "00001000", "00000100", "000000100", "111", "01010", "01000", "001100");
    MPEGConst.vlcMotionCode = VLC.createVLC("1", "01", "001", "0001", "000011", "0000101", "0000100", "0000011", "000001011", "000001010", "000001001", "0000010001", "0000010000", "0000001111", "0000001110", "0000001101", "0000001100");
    MPEGConst.vlcDualPrime = VLC.createVLC("11", "0", "10");
    MPEGConst.vlcDCSizeLuma = VLC.createVLC("100", "00", "01", "101", "110", "1110", "11110", "111110", "1111110", "11111110", "111111110", "111111111");
    MPEGConst.vlcDCSizeChroma = VLC.createVLC("00", "01", "10", "110", "1110", "11110", "111110", "1111110", "11111110", "111111110", "1111111110", "1111111111");
    var vlcCoeffBldr = new VLCBuilder();
    vlcCoeffBldr.set(MPEGConst.CODE_ESCAPE, "000001");
    vlcCoeffBldr.set(MPEGConst.CODE_END, "10");
    vlcCoeffBldr.set((0 << 6) | 1, "11");
    vlcCoeffBldr.set((1 << 6) | 1, "011");
    vlcCoeffBldr.set((0 << 6) | 2, "0100");
    vlcCoeffBldr.set((2 << 6) | 1, "0101");
    vlcCoeffBldr.set((0 << 6) | 3, "00101");
    vlcCoeffBldr.set((3 << 6) | 1, "00111");
    vlcCoeffBldr.set((4 << 6) | 1, "00110");
    vlcCoeffBldr.set((1 << 6) | 2, "000110");
    vlcCoeffBldr.set((5 << 6) | 1, "000111");
    vlcCoeffBldr.set((6 << 6) | 1, "000101");
    vlcCoeffBldr.set((7 << 6) | 1, "000100");
    vlcCoeffBldr.set((0 << 6) | 4, "0000110");
    vlcCoeffBldr.set((2 << 6) | 2, "0000100");
    vlcCoeffBldr.set((8 << 6) | 1, "0000111");
    vlcCoeffBldr.set((9 << 6) | 1, "0000101");
    vlcCoeffBldr.set((0 << 6) | 5, "00100110");
    vlcCoeffBldr.set((0 << 6) | 6, "00100001");
    vlcCoeffBldr.set((1 << 6) | 3, "00100101");
    vlcCoeffBldr.set((3 << 6) | 2, "00100100");
    vlcCoeffBldr.set((10 << 6) | 1, "00100111");
    vlcCoeffBldr.set((11 << 6) | 1, "00100011");
    vlcCoeffBldr.set((12 << 6) | 1, "00100010");
    vlcCoeffBldr.set((13 << 6) | 1, "00100000");
    vlcCoeffBldr.set((0 << 6) | 7, "0000001010");
    vlcCoeffBldr.set((1 << 6) | 4, "0000001100");
    vlcCoeffBldr.set((2 << 6) | 3, "0000001011");
    vlcCoeffBldr.set((4 << 6) | 2, "0000001111");
    vlcCoeffBldr.set((5 << 6) | 2, "0000001001");
    vlcCoeffBldr.set((14 << 6) | 1, "0000001110");
    vlcCoeffBldr.set((15 << 6) | 1, "0000001101");
    vlcCoeffBldr.set((16 << 6) | 1, "0000001000");
    vlcCoeffBldr.set((0 << 6) | 8, "000000011101");
    vlcCoeffBldr.set((0 << 6) | 9, "000000011000");
    vlcCoeffBldr.set((0 << 6) | 10, "000000010011");
    vlcCoeffBldr.set((0 << 6) | 11, "000000010000");
    vlcCoeffBldr.set((1 << 6) | 5, "000000011011");
    vlcCoeffBldr.set((2 << 6) | 4, "000000010100");
    vlcCoeffBldr.set((3 << 6) | 3, "000000011100");
    vlcCoeffBldr.set((4 << 6) | 3, "000000010010");
    vlcCoeffBldr.set((6 << 6) | 2, "000000011110");
    vlcCoeffBldr.set((7 << 6) | 2, "000000010101");
    vlcCoeffBldr.set((8 << 6) | 2, "000000010001");
    vlcCoeffBldr.set((17 << 6) | 1, "000000011111");
    vlcCoeffBldr.set((18 << 6) | 1, "000000011010");
    vlcCoeffBldr.set((19 << 6) | 1, "000000011001");
    vlcCoeffBldr.set((20 << 6) | 1, "000000010111");
    vlcCoeffBldr.set((21 << 6) | 1, "000000010110");
    vlcCoeffBldr.set((0 << 6) | 12, "0000000011010");
    vlcCoeffBldr.set((0 << 6) | 13, "0000000011001");
    vlcCoeffBldr.set((0 << 6) | 14, "0000000011000");
    vlcCoeffBldr.set((0 << 6) | 15, "0000000010111");
    vlcCoeffBldr.set((1 << 6) | 6, "0000000010110");
    vlcCoeffBldr.set((1 << 6) | 7, "0000000010101");
    vlcCoeffBldr.set((2 << 6) | 5, "0000000010100");
    vlcCoeffBldr.set((3 << 6) | 4, "0000000010011");
    vlcCoeffBldr.set((5 << 6) | 3, "0000000010010");
    vlcCoeffBldr.set((9 << 6) | 2, "0000000010001");
    vlcCoeffBldr.set((10 << 6) | 2, "0000000010000");
    vlcCoeffBldr.set((22 << 6) | 1, "0000000011111");
    vlcCoeffBldr.set((23 << 6) | 1, "0000000011110");
    vlcCoeffBldr.set((24 << 6) | 1, "0000000011101");
    vlcCoeffBldr.set((25 << 6) | 1, "0000000011100");
    vlcCoeffBldr.set((26 << 6) | 1, "0000000011011");
    vlcCoeffBldr.set((0 << 6) | 16, "00000000011111");
    vlcCoeffBldr.set((0 << 6) | 17, "00000000011110");
    vlcCoeffBldr.set((0 << 6) | 18, "00000000011101");
    vlcCoeffBldr.set((0 << 6) | 19, "00000000011100");
    vlcCoeffBldr.set((0 << 6) | 20, "00000000011011");
    vlcCoeffBldr.set((0 << 6) | 21, "00000000011010");
    vlcCoeffBldr.set((0 << 6) | 22, "00000000011001");
    vlcCoeffBldr.set((0 << 6) | 23, "00000000011000");
    vlcCoeffBldr.set((0 << 6) | 24, "00000000010111");
    vlcCoeffBldr.set((0 << 6) | 25, "00000000010110");
    vlcCoeffBldr.set((0 << 6) | 26, "00000000010101");
    vlcCoeffBldr.set((0 << 6) | 27, "00000000010100");
    vlcCoeffBldr.set((0 << 6) | 28, "00000000010011");
    vlcCoeffBldr.set((0 << 6) | 29, "00000000010010");
    vlcCoeffBldr.set((0 << 6) | 30, "00000000010001");
    vlcCoeffBldr.set((0 << 6) | 31, "00000000010000");
    vlcCoeffBldr.set((0 << 6) | 32, "000000000011000");
    vlcCoeffBldr.set((0 << 6) | 33, "000000000010111");
    vlcCoeffBldr.set((0 << 6) | 34, "000000000010110");
    vlcCoeffBldr.set((0 << 6) | 35, "000000000010101");
    vlcCoeffBldr.set((0 << 6) | 36, "000000000010100");
    vlcCoeffBldr.set((0 << 6) | 37, "000000000010011");
    vlcCoeffBldr.set((0 << 6) | 38, "000000000010010");
    vlcCoeffBldr.set((0 << 6) | 39, "000000000010001");
    vlcCoeffBldr.set((0 << 6) | 40, "000000000010000");
    vlcCoeffBldr.set((1 << 6) | 8, "000000000011111");
    vlcCoeffBldr.set((1 << 6) | 9, "000000000011110");
    vlcCoeffBldr.set((1 << 6) | 10, "000000000011101");
    vlcCoeffBldr.set((1 << 6) | 11, "000000000011100");
    vlcCoeffBldr.set((1 << 6) | 12, "000000000011011");
    vlcCoeffBldr.set((1 << 6) | 13, "000000000011010");
    vlcCoeffBldr.set((1 << 6) | 14, "000000000011001");
    vlcCoeffBldr.set((1 << 6) | 15, "0000000000010011");
    vlcCoeffBldr.set((1 << 6) | 16, "0000000000010010");
    vlcCoeffBldr.set((1 << 6) | 17, "0000000000010001");
    vlcCoeffBldr.set((1 << 6) | 18, "0000000000010000");
    vlcCoeffBldr.set((6 << 6) | 3, "0000000000010100");
    vlcCoeffBldr.set((11 << 6) | 2, "0000000000011010");
    vlcCoeffBldr.set((12 << 6) | 2, "0000000000011001");
    vlcCoeffBldr.set((13 << 6) | 2, "0000000000011000");
    vlcCoeffBldr.set((14 << 6) | 2, "0000000000010111");
    vlcCoeffBldr.set((15 << 6) | 2, "0000000000010110");
    vlcCoeffBldr.set((16 << 6) | 2, "0000000000010101");
    vlcCoeffBldr.set((27 << 6) | 1, "0000000000011111");
    vlcCoeffBldr.set((28 << 6) | 1, "0000000000011110");
    vlcCoeffBldr.set((29 << 6) | 1, "0000000000011101");
    vlcCoeffBldr.set((30 << 6) | 1, "0000000000011100");
    vlcCoeffBldr.set((31 << 6) | 1, "0000000000011011");
    MPEGConst.vlcCoeff0 = vlcCoeffBldr.getVLC();
    vlcCoeffBldr = new VLCBuilder();
    vlcCoeffBldr.set(MPEGConst.CODE_ESCAPE, "000001");
    vlcCoeffBldr.set(MPEGConst.CODE_END, "0110");
    vlcCoeffBldr.set((0 << 6) | 1, "10");
    vlcCoeffBldr.set((1 << 6) | 1, "010");
    vlcCoeffBldr.set((0 << 6) | 2, "110");
    vlcCoeffBldr.set((2 << 6) | 1, "00101");
    vlcCoeffBldr.set((0 << 6) | 3, "0111");
    vlcCoeffBldr.set((3 << 6) | 1, "00111");
    vlcCoeffBldr.set((4 << 6) | 1, "000110");
    vlcCoeffBldr.set((1 << 6) | 2, "00110");
    vlcCoeffBldr.set((5 << 6) | 1, "000111");
    vlcCoeffBldr.set((6 << 6) | 1, "0000110");
    vlcCoeffBldr.set((7 << 6) | 1, "0000100");
    vlcCoeffBldr.set((0 << 6) | 4, "11100");
    vlcCoeffBldr.set((2 << 6) | 2, "0000111");
    vlcCoeffBldr.set((8 << 6) | 1, "0000101");
    vlcCoeffBldr.set((9 << 6) | 1, "1111000");
    vlcCoeffBldr.set((0 << 6) | 5, "11101");
    vlcCoeffBldr.set((0 << 6) | 6, "000101");
    vlcCoeffBldr.set((1 << 6) | 3, "1111001");
    vlcCoeffBldr.set((3 << 6) | 2, "00100110");
    vlcCoeffBldr.set((10 << 6) | 1, "1111010");
    vlcCoeffBldr.set((11 << 6) | 1, "00100001");
    vlcCoeffBldr.set((12 << 6) | 1, "00100101");
    vlcCoeffBldr.set((13 << 6) | 1, "00100100");
    vlcCoeffBldr.set((0 << 6) | 7, "000100");
    vlcCoeffBldr.set((1 << 6) | 4, "00100111");
    vlcCoeffBldr.set((2 << 6) | 3, "11111100");
    vlcCoeffBldr.set((4 << 6) | 2, "11111101");
    vlcCoeffBldr.set((5 << 6) | 2, "000000100");
    vlcCoeffBldr.set((14 << 6) | 1, "000000101");
    vlcCoeffBldr.set((15 << 6) | 1, "000000111");
    vlcCoeffBldr.set((16 << 6) | 1, "0000001101");
    vlcCoeffBldr.set((0 << 6) | 8, "1111011");
    vlcCoeffBldr.set((0 << 6) | 9, "1111100");
    vlcCoeffBldr.set((0 << 6) | 10, "00100011");
    vlcCoeffBldr.set((0 << 6) | 11, "00100010");
    vlcCoeffBldr.set((1 << 6) | 5, "00100000");
    vlcCoeffBldr.set((2 << 6) | 4, "0000001100");
    vlcCoeffBldr.set((3 << 6) | 3, "000000011100");
    vlcCoeffBldr.set((4 << 6) | 3, "000000010010");
    vlcCoeffBldr.set((6 << 6) | 2, "000000011110");
    vlcCoeffBldr.set((7 << 6) | 2, "000000010101");
    vlcCoeffBldr.set((8 << 6) | 2, "000000010001");
    vlcCoeffBldr.set((17 << 6) | 1, "000000011111");
    vlcCoeffBldr.set((18 << 6) | 1, "000000011010");
    vlcCoeffBldr.set((19 << 6) | 1, "000000011001");
    vlcCoeffBldr.set((20 << 6) | 1, "000000010111");
    vlcCoeffBldr.set((21 << 6) | 1, "000000010110");
    vlcCoeffBldr.set((0 << 6) | 12, "11111010");
    vlcCoeffBldr.set((0 << 6) | 13, "11111011");
    vlcCoeffBldr.set((0 << 6) | 14, "11111110");
    vlcCoeffBldr.set((0 << 6) | 15, "11111111");
    vlcCoeffBldr.set((1 << 6) | 6, "0000000010110");
    vlcCoeffBldr.set((1 << 6) | 7, "0000000010101");
    vlcCoeffBldr.set((2 << 6) | 5, "0000000010100");
    vlcCoeffBldr.set((3 << 6) | 4, "0000000010011");
    vlcCoeffBldr.set((5 << 6) | 3, "0000000010010");
    vlcCoeffBldr.set((9 << 6) | 2, "0000000010001");
    vlcCoeffBldr.set((10 << 6) | 2, "0000000010000");
    vlcCoeffBldr.set((22 << 6) | 1, "0000000011111");
    vlcCoeffBldr.set((23 << 6) | 1, "0000000011110");
    vlcCoeffBldr.set((24 << 6) | 1, "0000000011101");
    vlcCoeffBldr.set((25 << 6) | 1, "0000000011100");
    vlcCoeffBldr.set((26 << 6) | 1, "0000000011011");
    vlcCoeffBldr.set((0 << 6) | 16, "00000000011111");
    vlcCoeffBldr.set((0 << 6) | 17, "00000000011110");
    vlcCoeffBldr.set((0 << 6) | 18, "00000000011101");
    vlcCoeffBldr.set((0 << 6) | 19, "00000000011100");
    vlcCoeffBldr.set((0 << 6) | 20, "00000000011011");
    vlcCoeffBldr.set((0 << 6) | 21, "00000000011010");
    vlcCoeffBldr.set((0 << 6) | 22, "00000000011001");
    vlcCoeffBldr.set((0 << 6) | 23, "00000000011000");
    vlcCoeffBldr.set((0 << 6) | 24, "00000000010111");
    vlcCoeffBldr.set((0 << 6) | 25, "00000000010110");
    vlcCoeffBldr.set((0 << 6) | 26, "00000000010101");
    vlcCoeffBldr.set((0 << 6) | 27, "00000000010100");
    vlcCoeffBldr.set((0 << 6) | 28, "00000000010011");
    vlcCoeffBldr.set((0 << 6) | 29, "00000000010010");
    vlcCoeffBldr.set((0 << 6) | 30, "00000000010001");
    vlcCoeffBldr.set((0 << 6) | 31, "00000000010000");
    vlcCoeffBldr.set((0 << 6) | 32, "000000000011000");
    vlcCoeffBldr.set((0 << 6) | 33, "000000000010111");
    vlcCoeffBldr.set((0 << 6) | 34, "000000000010110");
    vlcCoeffBldr.set((0 << 6) | 35, "000000000010101");
    vlcCoeffBldr.set((0 << 6) | 36, "000000000010100");
    vlcCoeffBldr.set((0 << 6) | 37, "000000000010011");
    vlcCoeffBldr.set((0 << 6) | 38, "000000000010010");
    vlcCoeffBldr.set((0 << 6) | 39, "000000000010001");
    vlcCoeffBldr.set((0 << 6) | 40, "000000000010000");
    vlcCoeffBldr.set((1 << 6) | 8, "000000000011111");
    vlcCoeffBldr.set((1 << 6) | 9, "000000000011110");
    vlcCoeffBldr.set((1 << 6) | 10, "000000000011101");
    vlcCoeffBldr.set((1 << 6) | 11, "000000000011100");
    vlcCoeffBldr.set((1 << 6) | 12, "000000000011011");
    vlcCoeffBldr.set((1 << 6) | 13, "000000000011010");
    vlcCoeffBldr.set((1 << 6) | 14, "000000000011001");
    vlcCoeffBldr.set((1 << 6) | 15, "0000000000010011");
    vlcCoeffBldr.set((1 << 6) | 16, "0000000000010010");
    vlcCoeffBldr.set((1 << 6) | 17, "0000000000010001");
    vlcCoeffBldr.set((1 << 6) | 18, "0000000000010000");
    vlcCoeffBldr.set((6 << 6) | 3, "0000000000010100");
    vlcCoeffBldr.set((11 << 6) | 2, "0000000000011010");
    vlcCoeffBldr.set((12 << 6) | 2, "0000000000011001");
    vlcCoeffBldr.set((13 << 6) | 2, "0000000000011000");
    vlcCoeffBldr.set((14 << 6) | 2, "0000000000010111");
    vlcCoeffBldr.set((15 << 6) | 2, "0000000000010110");
    vlcCoeffBldr.set((16 << 6) | 2, "0000000000010101");
    vlcCoeffBldr.set((27 << 6) | 1, "0000000000011111");
    vlcCoeffBldr.set((28 << 6) | 1, "0000000000011110");
    vlcCoeffBldr.set((29 << 6) | 1, "0000000000011101");
    vlcCoeffBldr.set((30 << 6) | 1, "0000000000011100");
    vlcCoeffBldr.set((31 << 6) | 1, "0000000000011011");
    MPEGConst.vlcCoeff1 = vlcCoeffBldr.getVLC();
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var CodedSuperBlock = function(codedBlocks) {
    this.codedBlocks = codedBlocks;
};
CodedSuperBlock = stjs.extend(CodedSuperBlock, null, [], function(constructor, prototype) {
    prototype.codedBlocks = null;
    prototype.getCodedBlocks = function() {
        return this.codedBlocks;
    };
    constructor.read = function(miCol, miRow, decoder, probStore, c) {
        var blocks = new ArrayList();
        CodedSuperBlock.readCodedBlocks(miCol, miRow, 3, decoder, probStore, c, blocks);
        return new CodedSuperBlock(blocks.toArray(CodedBlock.EMPTY_ARR));
    };
    constructor.readCodedBlocks = function(miCol, miRow, logBlkSize, decoder, probStore, c, blocks) {
        var part = CodedSuperBlock.readPartition(miCol, miRow, logBlkSize, decoder, probStore, c);
        var nextBlkSize = (1 << logBlkSize) >> 1;
        if (part == Consts.PARTITION_NONE) {
            var blk = CodedBlock.read(miCol, miRow, Consts.blSizeLookup[logBlkSize][logBlkSize], decoder, probStore, c);
            blocks.add(blk);
            CodedSuperBlock.saveAboveSizes(miCol, logBlkSize, c);
            CodedSuperBlock.saveLeftSizes(miRow, logBlkSize, c);
        } else if (part == Consts.PARTITION_HORZ) {
            var blk = CodedBlock.read(miCol, miRow, Consts.blSizeLookup[logBlkSize][logBlkSize], decoder, probStore, c);
            blocks.add(blk);
            CodedSuperBlock.saveAboveSizes(miCol, nextBlkSize, c);
            if (miCol + nextBlkSize < c.getTileWidth()) {
                blk = CodedBlock.read(miCol + nextBlkSize, miRow, Consts.blSizeLookup[logBlkSize][logBlkSize], decoder, probStore, c);
                blocks.add(blk);
                CodedSuperBlock.saveAboveSizes(miCol + nextBlkSize, nextBlkSize, c);
            }
            CodedSuperBlock.saveLeftSizes(miRow, logBlkSize, c);
        } else if (part == Consts.PARTITION_VERT) {
            var blk = CodedBlock.read(miCol, miRow, Consts.blSizeLookup[logBlkSize][logBlkSize], decoder, probStore, c);
            blocks.add(blk);
            CodedSuperBlock.saveLeftSizes(miRow, nextBlkSize, c);
            if (miRow + nextBlkSize < c.getTileHeight()) {
                blk = CodedBlock.read(miCol, miRow + nextBlkSize, Consts.blSizeLookup[logBlkSize][logBlkSize], decoder, probStore, c);
                blocks.add(blk);
                CodedSuperBlock.saveAboveSizes(miCol, logBlkSize, c);
            }
            CodedSuperBlock.saveLeftSizes(miRow + nextBlkSize, nextBlkSize, c);
        } else {
            if (nextBlkSize > Consts.SZ_8x8) {
                CodedSuperBlock.readCodedBlocks(miCol, miRow, logBlkSize - 1, decoder, probStore, c, blocks);
                if (miCol + nextBlkSize < c.getTileWidth()) 
                    CodedSuperBlock.readCodedBlocks(miCol + nextBlkSize, miRow, logBlkSize - 1, decoder, probStore, c, blocks);
                if (miRow + nextBlkSize < c.getTileHeight()) 
                    CodedSuperBlock.readCodedBlocks(miCol, miRow + nextBlkSize, logBlkSize - 1, decoder, probStore, c, blocks);
                if (miCol + nextBlkSize < c.getTileWidth() && miRow + nextBlkSize < c.getTileHeight()) 
                    CodedSuperBlock.readCodedBlocks(miCol + nextBlkSize, miRow + nextBlkSize, logBlkSize - 1, decoder, probStore, c, blocks);
            } else {
                var blk = CodedBlock.read(miCol, miRow, Consts.blSizeLookup[logBlkSize][logBlkSize], decoder, probStore, c);
                blocks.add(blk);
                CodedSuperBlock.saveAboveSizes(miCol, nextBlkSize, c);
                CodedSuperBlock.saveLeftSizes(miRow, nextBlkSize, c);
                if (miCol + nextBlkSize < c.getTileWidth()) {
                    blk = CodedBlock.read(miCol + nextBlkSize, miRow, Consts.blSizeLookup[logBlkSize][logBlkSize], decoder, probStore, c);
                    blocks.add(blk);
                    CodedSuperBlock.saveAboveSizes(miCol + nextBlkSize, nextBlkSize, c);
                }
                if (miRow + nextBlkSize < c.getTileHeight()) {
                    blk = CodedBlock.read(miCol, miRow + nextBlkSize, Consts.blSizeLookup[logBlkSize][logBlkSize], decoder, probStore, c);
                    blocks.add(blk);
                    CodedSuperBlock.saveLeftSizes(miRow + nextBlkSize, nextBlkSize, c);
                }
                if (miCol + nextBlkSize < c.getTileWidth() && miRow + nextBlkSize < c.getTileHeight()) {
                    blk = CodedBlock.read(miCol + nextBlkSize, miRow + nextBlkSize, Consts.blSizeLookup[logBlkSize][logBlkSize], decoder, probStore, c);
                    blocks.add(blk);
                }
            }
        }
    };
    constructor.saveLeftSizes = function(miRow, logBlkSize, c) {
        var miBlkSize = 1 << logBlkSize;
        var leftSizes = c.getLeftPartitionSizes();
        for (var i = 0; i < miBlkSize; i++) 
            leftSizes[(miRow % 8) + i] = logBlkSize;
    };
    constructor.saveAboveSizes = function(miCol, logBlkSize, c) {
        var miBlkSize = 1 << logBlkSize;
        var aboveSizes = c.getAbovePartitionSizes();
        for (var i = 0; i < miBlkSize; i++) 
            aboveSizes[miCol + i] = logBlkSize;
    };
    constructor.readPartition = function(miCol, miRow, blkSize, decoder, probStore, c) {
        var ctx = CodedSuperBlock.calcPartitionContext(miCol, miRow, blkSize, c);
        var probs = probStore.getPartitionProbs(ctx);
        var halfBlk = (1 << blkSize) >> 1;
        var rightEdge = miCol + halfBlk < c.getTileWidth();
        var bottomEdge = miRow + halfBlk < c.getTileHeight();
        if (rightEdge && bottomEdge) {
            return Consts.PARTITION_SPLIT;
        } else if (rightEdge) {
            return decoder.readBit(probs[0]) == 1 ? Consts.PARTITION_VERT : Consts.PARTITION_NONE;
        } else if (bottomEdge) {
            return decoder.readBit(probs[1]) == 1 ? Consts.PARTITION_HORZ : Consts.PARTITION_NONE;
        } else {
            return decoder.readTree(Consts.TREE_PARTITION, probs);
        }
    };
    constructor.calcPartitionContext = function(miCol, miRow, blkSize, c) {
        var left = false, above = false;
        var miBlkSize = 1 << blkSize;
        var aboveSizes = c.getAbovePartitionSizes();
        for (var i = 0; i < miBlkSize; i++) 
            above |= aboveSizes[miCol + i] <= blkSize;
        var leftSizes = c.getLeftPartitionSizes();
        for (var i = 0; i < miBlkSize; i++) 
            left |= leftSizes[(miRow % 8) + i] <= blkSize;
        return blkSize * 4 + (above ? 2 : 0) + (left ? 1 : 0);
    };
}, {codedBlocks: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEG4BiRenderer = function() {};
MPEG4BiRenderer = stjs.extend(MPEG4BiRenderer, null, [], function(constructor, prototype) {
    constructor.renderBi = function(ctx, refs, fcodeForward, fcodeBackward, mb) {
        switch (mb.mode) {
            case MPEG4Consts.MODE_DIRECT:
            case MPEG4Consts.MODE_DIRECT_NONE_MV:
                MPEG4BiRenderer.renderBiDir(ctx, refs, mb, true);
                break;
            case MPEG4Consts.MODE_INTERPOLATE:
                MPEG4BiRenderer.renderBiDir(ctx, refs, mb, false);
                break;
            case MPEG4Consts.MODE_BACKWARD:
                MPEG4Renderer.renderInter(ctx, refs, mb, fcodeBackward, 0, true);
                break;
            case MPEG4Consts.MODE_FORWARD:
                MPEG4Renderer.renderInter(ctx, refs, mb, fcodeForward, 1, true);
                break;
            default:
        }
    };
    constructor.renderBiDir = function(ctx, refs, mb, direct) {
        var cbp = mb.cbp;
        MPEG4Renderer.validateVector(mb.mvs, ctx, mb.x, mb.y);
        MPEG4Renderer.validateVector(mb.bmvs, ctx, mb.x, mb.y);
        MPEG4BiRenderer.renderOneDir(ctx, mb, direct, refs[1], mb.mvs, 0);
        MPEG4BiRenderer.renderOneDir(ctx, mb, direct, refs[0], mb.bmvs, 3);
        MPEG4BiRenderer.mergePred(mb);
        if (cbp != 0) {
            for (var i = 0; i < 6; i++) {
                var block = mb.block[i];
                if ((mb.cbp & (1 << (5 - i))) != 0) {
                    MPEG4DCT.idctAdd(mb.pred, block, i, ctx.interlacing && mb.fieldDCT);
                }
            }
        }
    };
    constructor.mergePred = function(mb) {
        for (var i = 0; i < 256; i++) {
            mb.pred[0][i] = (((mb.pred[0][i] + mb.pred[3][i] + 1) >> 1) << 24 >> 24);
        }
        for (var pl = 1; pl < 3; pl++) {
            for (var i = 0; i < 64; i++) {
                mb.pred[pl][i] = (((mb.pred[pl][i] + mb.pred[pl + 3][i] + 1) >> 1) << 24 >> 24);
            }
        }
    };
    constructor.renderOneDir = function(ctx, mb, direct, forward, mvs, pred) {
        var mbX = 16 * mb.x;
        var mbY = 16 * mb.y;
        var codedW = ctx.mbWidth << 4;
        var codedH = ctx.mbHeight << 4;
        var codedWcr = ctx.mbWidth << 3;
        var codedHcr = ctx.mbHeight << 3;
        if (ctx.quarterPel) {
            if (!direct) {
                MPEG4Interpolator.interpolate16x16QP(mb.pred[pred], forward.getPlaneData(0), mbX, mbY, codedW, codedH, mvs[0].x, mvs[0].y, forward.getWidth(), false);
            } else {
                MPEG4Interpolator.interpolate8x8QP(mb.pred[pred], 0, forward.getPlaneData(0), mbX, mbY, codedW, codedH, mvs[0].x, mvs[0].y, forward.getWidth(), false);
                MPEG4Interpolator.interpolate8x8QP(mb.pred[pred], 8, forward.getPlaneData(0), mbX + 8, mbY, codedW, codedH, mvs[1].x, mvs[1].y, forward.getWidth(), false);
                MPEG4Interpolator.interpolate8x8QP(mb.pred[pred], 128, forward.getPlaneData(0), mbX, mbY + 8, codedW, codedH, mvs[2].x, mvs[2].y, forward.getWidth(), false);
                MPEG4Interpolator.interpolate8x8QP(mb.pred[pred], 136, forward.getPlaneData(0), mbX + 8, mbY + 8, codedW, codedH, mvs[3].x, mvs[3].y, forward.getWidth(), false);
            }
        } else {
            MPEG4Interpolator.interpolate8x8Planar(mb.pred[pred], 0, 16, forward.getPlaneData(0), mbX, mbY, codedW, codedH, mvs[0].x, mvs[0].y, forward.getWidth(), false);
            MPEG4Interpolator.interpolate8x8Planar(mb.pred[pred], 8, 16, forward.getPlaneData(0), mbX + 8, mbY, codedW, codedH, mvs[1].x, mvs[1].y, forward.getWidth(), false);
            MPEG4Interpolator.interpolate8x8Planar(mb.pred[pred], 128, 16, forward.getPlaneData(0), mbX, mbY + 8, codedW, codedH, mvs[2].x, mvs[2].y, forward.getWidth(), false);
            MPEG4Interpolator.interpolate8x8Planar(mb.pred[pred], 136, 16, forward.getPlaneData(0), mbX + 8, mbY + 8, codedW, codedH, mvs[3].x, mvs[3].y, forward.getWidth(), false);
        }
        var mx_chr, my_chr;
        if (!direct) {
            mx_chr = MPEG4Renderer.calcChromaMv(ctx, mvs[0].x);
            my_chr = MPEG4Renderer.calcChromaMv(ctx, mvs[0].y);
        } else {
            mx_chr = MPEG4Renderer.calcChromaMvAvg(ctx, mvs, true);
            my_chr = MPEG4Renderer.calcChromaMvAvg(ctx, mvs, false);
        }
        MPEG4Interpolator.interpolate8x8Planar(mb.pred[pred + 1], 0, 8, forward.getPlaneData(1), 8 * mb.x, 8 * mb.y, codedWcr, codedHcr, mx_chr, my_chr, forward.getPlaneWidth(1), false);
        MPEG4Interpolator.interpolate8x8Planar(mb.pred[pred + 2], 0, 8, forward.getPlaneData(2), 8 * mb.x, 8 * mb.y, codedWcr, codedHcr, mx_chr, my_chr, forward.getPlaneWidth(2), false);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Supplementary Enhanced Information entity of H264 bitstream
 *  
 *  capable to serialize and deserialize with CAVLC bitstream
 *  
 *  @author The JCodec project
 *  
 */
var SEI = function(messages) {
    this.messages = messages;
};
SEI = stjs.extend(SEI, null, [], function(constructor, prototype) {
    constructor.SEIMessage = function(payloadType2, payloadSize2, payload2) {
        this.payload = payload2;
        this.payloadType = payloadType2;
        this.payloadSize = payloadSize2;
    };
    constructor.SEIMessage = stjs.extend(constructor.SEIMessage, null, [], function(constructor, prototype) {
        prototype.payloadType = 0;
        prototype.payloadSize = 0;
        prototype.payload = null;
    }, {payload: "Int8Array"}, {});
    prototype.messages = null;
    constructor.read = function(is) {
        var messages = new ArrayList();
        var msg;
        do {
            msg = SEI.sei_message(is);
            if (msg != null) 
                messages.add(msg);
        } while (msg != null);
        return new SEI(messages.toArray([]));
    };
    constructor.sei_message = function(is) {
        var payloadType = 0;
        var b = 0;
         while (is.hasRemaining() && (b = (is.get() & 255)) == 255){
            payloadType += 255;
        }
        if (!is.hasRemaining()) 
            return null;
        payloadType += b;
        var payloadSize = 0;
         while (is.hasRemaining() && (b = (is.get() & 255)) == 255){
            payloadSize += 255;
        }
        if (!is.hasRemaining()) 
            return null;
        payloadSize += b;
        var payload = SEI.sei_payload(payloadType, payloadSize, is);
        if (payload.length != payloadSize) 
            return null;
        return new SEI.SEIMessage(payloadType, payloadSize, payload);
    };
    constructor.sei_payload = function(payloadType, payloadSize, is) {
        var res = new Int8Array(payloadSize);
        is.getBuf(res);
        return res;
    };
    prototype.write = function(out) {
        var writer = new BitWriter(out);
        CAVLCWriter.writeTrailingBits(writer);
    };
}, {messages: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A writer for slice header data structure
 *  
 *  @author The JCodec project
 *  
 */
var SliceHeaderWriter = function() {};
SliceHeaderWriter = stjs.extend(SliceHeaderWriter, null, [], function(constructor, prototype) {
    constructor.write = function(sliceHeader, idrSlice, nalRefIdc, writer) {
        var sps = sliceHeader.sps;
        var pps = sliceHeader.pps;
        CAVLCWriter.writeUEtrace(writer, sliceHeader.firstMbInSlice, "SH: first_mb_in_slice");
        CAVLCWriter.writeUEtrace(writer, sliceHeader.sliceType.ordinal() + (sliceHeader.sliceTypeRestr ? 5 : 0), "SH: slice_type");
        CAVLCWriter.writeUEtrace(writer, sliceHeader.picParameterSetId, "SH: pic_parameter_set_id");
        if (sliceHeader.frameNum > (1 << (sps.log2MaxFrameNumMinus4 + 4))) {
             throw new IllegalArgumentException("frame_num > " + (1 << (sps.log2MaxFrameNumMinus4 + 4)));
        }
        CAVLCWriter.writeUtrace(writer, sliceHeader.frameNum, sps.log2MaxFrameNumMinus4 + 4, "SH: frame_num");
        if (!sps.frameMbsOnlyFlag) {
            CAVLCWriter.writeBool(writer, sliceHeader.fieldPicFlag, "SH: field_pic_flag");
            if (sliceHeader.fieldPicFlag) {
                CAVLCWriter.writeBool(writer, sliceHeader.bottomFieldFlag, "SH: bottom_field_flag");
            }
        }
        if (idrSlice) {
            CAVLCWriter.writeUEtrace(writer, sliceHeader.idrPicId, "SH: idr_pic_id");
        }
        if (sps.picOrderCntType == 0) {
            if (sliceHeader.picOrderCntLsb > (1 << (sps.log2MaxPicOrderCntLsbMinus4 + 4))) {
                 throw new IllegalArgumentException("pic_order_cnt_lsb > " + (1 << (sps.log2MaxPicOrderCntLsbMinus4 + 4)));
            }
            CAVLCWriter.writeU(writer, sliceHeader.picOrderCntLsb, sps.log2MaxPicOrderCntLsbMinus4 + 4);
            if (pps.picOrderPresentFlag && !sps.fieldPicFlag) {
                CAVLCWriter.writeSEtrace(writer, sliceHeader.deltaPicOrderCntBottom, "SH: delta_pic_order_cnt_bottom");
            }
        }
        if (sps.picOrderCntType == 1 && !sps.deltaPicOrderAlwaysZeroFlag) {
            CAVLCWriter.writeSEtrace(writer, sliceHeader.deltaPicOrderCnt[0], "SH: delta_pic_order_cnt");
            if (pps.picOrderPresentFlag && !sps.fieldPicFlag) 
                CAVLCWriter.writeSEtrace(writer, sliceHeader.deltaPicOrderCnt[1], "SH: delta_pic_order_cnt");
        }
        if (pps.redundantPicCntPresentFlag) {
            CAVLCWriter.writeUEtrace(writer, sliceHeader.redundantPicCnt, "SH: redundant_pic_cnt");
        }
        if (sliceHeader.sliceType == SliceType.B) {
            CAVLCWriter.writeBool(writer, sliceHeader.directSpatialMvPredFlag, "SH: direct_spatial_mv_pred_flag");
        }
        if (sliceHeader.sliceType == SliceType.P || sliceHeader.sliceType == SliceType.SP || sliceHeader.sliceType == SliceType.B) {
            CAVLCWriter.writeBool(writer, sliceHeader.numRefIdxActiveOverrideFlag, "SH: num_ref_idx_active_override_flag");
            if (sliceHeader.numRefIdxActiveOverrideFlag) {
                CAVLCWriter.writeUEtrace(writer, sliceHeader.numRefIdxActiveMinus1[0], "SH: num_ref_idx_l0_active_minus1");
                if (sliceHeader.sliceType == SliceType.B) {
                    CAVLCWriter.writeUEtrace(writer, sliceHeader.numRefIdxActiveMinus1[1], "SH: num_ref_idx_l1_active_minus1");
                }
            }
        }
        SliceHeaderWriter.writeRefPicListReordering(sliceHeader, writer);
        if ((pps.weightedPredFlag && (sliceHeader.sliceType == SliceType.P || sliceHeader.sliceType == SliceType.SP)) || (pps.weightedBipredIdc == 1 && sliceHeader.sliceType == SliceType.B)) 
            SliceHeaderWriter.writePredWeightTable(sliceHeader, writer);
        if (nalRefIdc != 0) 
            SliceHeaderWriter.writeDecRefPicMarking(sliceHeader, idrSlice, writer);
        if (pps.entropyCodingModeFlag && sliceHeader.sliceType.isInter()) {
            CAVLCWriter.writeUEtrace(writer, sliceHeader.cabacInitIdc, "SH: cabac_init_idc");
        }
        CAVLCWriter.writeSEtrace(writer, sliceHeader.sliceQpDelta, "SH: slice_qp_delta");
        if (sliceHeader.sliceType == SliceType.SP || sliceHeader.sliceType == SliceType.SI) {
            if (sliceHeader.sliceType == SliceType.SP) {
                CAVLCWriter.writeBool(writer, sliceHeader.spForSwitchFlag, "SH: sp_for_switch_flag");
            }
            CAVLCWriter.writeSEtrace(writer, sliceHeader.sliceQsDelta, "SH: slice_qs_delta");
        }
        if (pps.deblockingFilterControlPresentFlag) {
            CAVLCWriter.writeUEtrace(writer, sliceHeader.disableDeblockingFilterIdc, "SH: disable_deblocking_filter_idc");
            if (sliceHeader.disableDeblockingFilterIdc != 1) {
                CAVLCWriter.writeSEtrace(writer, sliceHeader.sliceAlphaC0OffsetDiv2, "SH: slice_alpha_c0_offset_div2");
                CAVLCWriter.writeSEtrace(writer, sliceHeader.sliceBetaOffsetDiv2, "SH: slice_beta_offset_div2");
            }
        }
        if (pps.numSliceGroupsMinus1 > 0 && pps.sliceGroupMapType >= 3 && pps.sliceGroupMapType <= 5) {
            var len = stjs.trunc((sps.picHeightInMapUnitsMinus1 + 1) * (sps.picWidthInMbsMinus1 + 1) / (pps.sliceGroupChangeRateMinus1 + 1));
            if (((sps.picHeightInMapUnitsMinus1 + 1) * (sps.picWidthInMbsMinus1 + 1)) % (pps.sliceGroupChangeRateMinus1 + 1) > 0) 
                len += 1;
            len = SliceHeaderWriter.CeilLog2(len + 1);
            CAVLCWriter.writeU(writer, sliceHeader.sliceGroupChangeCycle, len);
        }
    };
    constructor.CeilLog2 = function(uiVal) {
        var uiTmp = uiVal - 1;
        var uiRet = 0;
         while (uiTmp != 0){
            uiTmp >>= 1;
            uiRet++;
        }
        return uiRet;
    };
    constructor.writeDecRefPicMarking = function(sliceHeader, idrSlice, writer) {
        if (idrSlice) {
            var drpmidr = sliceHeader.refPicMarkingIDR;
            CAVLCWriter.writeBool(writer, drpmidr.isDiscardDecodedPics(), "SH: no_output_of_prior_pics_flag");
            CAVLCWriter.writeBool(writer, drpmidr.isUseForlongTerm(), "SH: long_term_reference_flag");
        } else {
            CAVLCWriter.writeBool(writer, sliceHeader.refPicMarkingNonIDR != null, "SH: adaptive_ref_pic_marking_mode_flag");
            if (sliceHeader.refPicMarkingNonIDR != null) {
                var drpmidr = sliceHeader.refPicMarkingNonIDR;
                var instructions = drpmidr.getInstructions();
                for (var i = 0; i < instructions.length; i++) {
                    var mmop = instructions[i];
                    switch (mmop.getType()) {
                        case RefPicMarking.InstrType.REMOVE_SHORT:
                            CAVLCWriter.writeUEtrace(writer, 1, "SH: memory_management_control_operation");
                            CAVLCWriter.writeUEtrace(writer, mmop.getArg1() - 1, "SH: difference_of_pic_nums_minus1");
                            break;
                        case RefPicMarking.InstrType.REMOVE_LONG:
                            CAVLCWriter.writeUEtrace(writer, 2, "SH: memory_management_control_operation");
                            CAVLCWriter.writeUEtrace(writer, mmop.getArg1(), "SH: long_term_pic_num");
                            break;
                        case RefPicMarking.InstrType.CONVERT_INTO_LONG:
                            CAVLCWriter.writeUEtrace(writer, 3, "SH: memory_management_control_operation");
                            CAVLCWriter.writeUEtrace(writer, mmop.getArg1() - 1, "SH: difference_of_pic_nums_minus1");
                            CAVLCWriter.writeUEtrace(writer, mmop.getArg2(), "SH: long_term_frame_idx");
                            break;
                        case RefPicMarking.InstrType.TRUNK_LONG:
                            CAVLCWriter.writeUEtrace(writer, 4, "SH: memory_management_control_operation");
                            CAVLCWriter.writeUEtrace(writer, mmop.getArg1() + 1, "SH: max_long_term_frame_idx_plus1");
                            break;
                        case RefPicMarking.InstrType.CLEAR:
                            CAVLCWriter.writeUEtrace(writer, 5, "SH: memory_management_control_operation");
                            break;
                        case RefPicMarking.InstrType.MARK_LONG:
                            CAVLCWriter.writeUEtrace(writer, 6, "SH: memory_management_control_operation");
                            CAVLCWriter.writeUEtrace(writer, mmop.getArg1(), "SH: long_term_frame_idx");
                            break;
                    }
                }
                CAVLCWriter.writeUEtrace(writer, 0, "SH: memory_management_control_operation");
            }
        }
    };
    constructor.writePredWeightTable = function(sliceHeader, writer) {
        var sps = sliceHeader.sps;
        CAVLCWriter.writeUEtrace(writer, sliceHeader.predWeightTable.lumaLog2WeightDenom, "SH: luma_log2_weight_denom");
        if (sps.chromaFormatIdc != ColorSpace.MONO) {
            CAVLCWriter.writeUEtrace(writer, sliceHeader.predWeightTable.chromaLog2WeightDenom, "SH: chroma_log2_weight_denom");
        }
        SliceHeaderWriter.writeOffsetWeight(sliceHeader, writer, 0);
        if (sliceHeader.sliceType == SliceType.B) {
            SliceHeaderWriter.writeOffsetWeight(sliceHeader, writer, 1);
        }
    };
    constructor.writeOffsetWeight = function(sliceHeader, writer, list) {
        var sps = sliceHeader.sps;
        var defaultLW = 1 << sliceHeader.predWeightTable.lumaLog2WeightDenom;
        var defaultCW = 1 << sliceHeader.predWeightTable.chromaLog2WeightDenom;
        for (var i = 0; i < sliceHeader.predWeightTable.lumaWeight[list].length; i++) {
            var flagLuma = sliceHeader.predWeightTable.lumaWeight[list][i] != defaultLW || sliceHeader.predWeightTable.lumaOffset[list][i] != 0;
            CAVLCWriter.writeBool(writer, flagLuma, "SH: luma_weight_l0_flag");
            if (flagLuma) {
                CAVLCWriter.writeSEtrace(writer, sliceHeader.predWeightTable.lumaWeight[list][i], "SH: luma_weight_l" + list);
                CAVLCWriter.writeSEtrace(writer, sliceHeader.predWeightTable.lumaOffset[list][i], "SH: luma_offset_l" + list);
            }
            if (sps.chromaFormatIdc != ColorSpace.MONO) {
                var flagChroma = sliceHeader.predWeightTable.chromaWeight[list][0][i] != defaultCW || sliceHeader.predWeightTable.chromaOffset[list][0][i] != 0 || sliceHeader.predWeightTable.chromaWeight[list][1][i] != defaultCW || sliceHeader.predWeightTable.chromaOffset[list][1][i] != 0;
                CAVLCWriter.writeBool(writer, flagChroma, "SH: chroma_weight_l0_flag");
                if (flagChroma) 
                    for (var j = 0; j < 2; j++) {
                        CAVLCWriter.writeSEtrace(writer, sliceHeader.predWeightTable.chromaWeight[list][j][i], "SH: chroma_weight_l" + list);
                        CAVLCWriter.writeSEtrace(writer, sliceHeader.predWeightTable.chromaOffset[list][j][i], "SH: chroma_offset_l" + list);
                    }
            }
        }
    };
    constructor.writeRefPicListReordering = function(sliceHeader, writer) {
        if (sliceHeader.sliceType.isInter()) {
            var l0ReorderingPresent = sliceHeader.refPicReordering != null && sliceHeader.refPicReordering[0] != null;
            CAVLCWriter.writeBool(writer, l0ReorderingPresent, "SH: ref_pic_list_reordering_flag_l0");
            if (l0ReorderingPresent) 
                SliceHeaderWriter.writeReorderingList(sliceHeader.refPicReordering[0], writer);
        }
        if (sliceHeader.sliceType == SliceType.B) {
            var l1ReorderingPresent = sliceHeader.refPicReordering != null && sliceHeader.refPicReordering[1] != null;
            CAVLCWriter.writeBool(writer, l1ReorderingPresent, "SH: ref_pic_list_reordering_flag_l1");
            if (l1ReorderingPresent) 
                SliceHeaderWriter.writeReorderingList(sliceHeader.refPicReordering[1], writer);
        }
    };
    constructor.writeReorderingList = function(reordering, writer) {
        if (reordering == null) 
            return;
        for (var i = 0; i < reordering[0].length; i++) {
            CAVLCWriter.writeUEtrace(writer, reordering[0][i], "SH: reordering_of_pic_nums_idc");
            CAVLCWriter.writeUEtrace(writer, reordering[1][i], "SH: abs_diff_pic_num_minus1");
        }
        CAVLCWriter.writeUEtrace(writer, 3, "SH: reordering_of_pic_nums_idc");
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Sequence Parameter Set Extension entity of H264 bitstream
 *  
 *  Capable to serialize / deserialize itself with CAVLC bit stream
 *  
 *  @author The JCodec project
 *  
 */
var SeqParameterSetExt = function() {};
SeqParameterSetExt = stjs.extend(SeqParameterSetExt, null, [], function(constructor, prototype) {
    prototype.seq_parameter_set_id = 0;
    prototype.aux_format_idc = 0;
    prototype.bit_depth_aux_minus8 = 0;
    prototype.alpha_incr_flag = false;
    prototype.additional_extension_flag = false;
    prototype.alpha_opaque_value = 0;
    prototype.alpha_transparent_value = 0;
    constructor.read = function(is) {
        var _in = BitReader.createBitReader(is);
        var spse = new SeqParameterSetExt();
        spse.seq_parameter_set_id = CAVLCReader.readUEtrace(_in, "SPSE: seq_parameter_set_id");
        spse.aux_format_idc = CAVLCReader.readUEtrace(_in, "SPSE: aux_format_idc");
        if (spse.aux_format_idc != 0) {
            spse.bit_depth_aux_minus8 = CAVLCReader.readUEtrace(_in, "SPSE: bit_depth_aux_minus8");
            spse.alpha_incr_flag = CAVLCReader.readBool(_in, "SPSE: alpha_incr_flag");
            spse.alpha_opaque_value = CAVLCReader.readU(_in, spse.bit_depth_aux_minus8 + 9, "SPSE: alpha_opaque_value");
            spse.alpha_transparent_value = CAVLCReader.readU(_in, spse.bit_depth_aux_minus8 + 9, "SPSE: alpha_transparent_value");
        }
        spse.additional_extension_flag = CAVLCReader.readBool(_in, "SPSE: additional_extension_flag");
        return spse;
    };
    prototype.write = function(out) {
        var writer = new BitWriter(out);
        CAVLCWriter.writeTrailingBits(writer);
    };
}, {}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 * 
 *  @author in-somnia
 */
var SBR = function(smallFrames, stereo, sample_rate, downSampledSBR) {
    this.amp_res = new Int8Array(2);
    this.N_L = new Int32Array(4);
    this.n = new Int32Array(2);
    this.f_master = new Int32Array(64);
    this.f_table_res = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(64);
    });
    this.f_table_noise = new Int32Array(64);
    this.f_table_lim = Array.apply(null, Array(4)).map(function() {
        return new Int32Array(64);
    });
    this.table_map_k_to_g = new Int32Array(64);
    this.abs_bord_lead = new Int32Array(2);
    this.abs_bord_trail = new Int32Array(2);
    this.n_rel_lead = new Int32Array(2);
    this.n_rel_trail = new Int32Array(2);
    this.L_E = new Int32Array(2);
    this.L_E_prev = new Int32Array(2);
    this.L_Q = new Int32Array(2);
    this.t_E = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(SBRConstants.MAX_L_E + 1);
    });
    this.t_Q = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(3);
    });
    this.f = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(SBRConstants.MAX_L_E + 1);
    });
    this.f_prev = new Int32Array(2);
    this.G_temp_prev = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(5)).map(function() {
            return new Float32Array(64);
        });
    });
    this.Q_temp_prev = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(5)).map(function() {
            return new Float32Array(64);
        });
    });
    this.GQ_ringbuf_index = new Int32Array(2);
    this.E = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(64)).map(function() {
            return new Int32Array(SBRConstants.MAX_L_E);
        });
    });
    this.E_prev = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(64);
    });
    this.E_orig = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(64)).map(function() {
            return new Float32Array(SBRConstants.MAX_L_E);
        });
    });
    this.E_curr = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(64)).map(function() {
            return new Float32Array(SBRConstants.MAX_L_E);
        });
    });
    this.Q = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(64)).map(function() {
            return new Int32Array(2);
        });
    });
    this.Q_div = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(64)).map(function() {
            return new Float32Array(2);
        });
    });
    this.Q_div2 = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(64)).map(function() {
            return new Float32Array(2);
        });
    });
    this.Q_prev = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(64);
    });
    this.l_A = new Int32Array(2);
    this.l_A_prev = new Int32Array(2);
    this.bs_invf_mode = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(SBRConstants.MAX_L_E);
    });
    this.bs_invf_mode_prev = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(SBRConstants.MAX_L_E);
    });
    this.bwArray = Array.apply(null, Array(2)).map(function() {
        return new Float32Array(64);
    });
    this.bwArray_prev = Array.apply(null, Array(2)).map(function() {
        return new Float32Array(64);
    });
    this.patchNoSubbands = new Int32Array(64);
    this.patchStartSubband = new Int32Array(64);
    this.bs_add_harmonic = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(64);
    });
    this.bs_add_harmonic_prev = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(64);
    });
    this.index_noise_prev = new Int32Array(2);
    this.psi_is_prev = new Int32Array(2);
    this.prevEnvIsShort = new Int32Array(2);
    this.qmfa = Array(2);
    this.qmfs = Array(2);
    this.Xsbr = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(SBRConstants.MAX_NTSRHFG)).map(function() {
            return Array.apply(null, Array(64)).map(function() {
                return new Float32Array(2);
            });
        });
    });
    this.bs_add_harmonic_flag = new Int8Array(2);
    this.bs_add_harmonic_flag_prev = new Int8Array(2);
    this.bs_frame_class = new Int32Array(2);
    this.bs_rel_bord = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(9);
    });
    this.bs_rel_bord_0 = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(9);
    });
    this.bs_rel_bord_1 = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(9);
    });
    this.bs_pointer = new Int32Array(2);
    this.bs_abs_bord_0 = new Int32Array(2);
    this.bs_abs_bord_1 = new Int32Array(2);
    this.bs_num_rel_0 = new Int32Array(2);
    this.bs_num_rel_1 = new Int32Array(2);
    this.bs_df_env = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(9);
    });
    this.bs_df_noise = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(3);
    });
    this.downSampledSBR = downSampledSBR;
    this.stereo = stereo;
    this.sample_rate = sample_rate;
    this.bs_freq_scale = 2;
    this.bs_alter_scale = true;
    this.bs_noise_bands = 2;
    this.bs_limiter_bands = 2;
    this.bs_limiter_gains = 2;
    this.bs_interpol_freq = true;
    this.bs_smoothing_mode = true;
    this.bs_start_freq = 5;
    this.bs_amp_res = true;
    this.bs_samplerate_mode = 1;
    this.prevEnvIsShort[0] = -1;
    this.prevEnvIsShort[1] = -1;
    this.header_count = 0;
    this.Reset = true;
    this.tHFGen = SBRConstants.T_HFGEN;
    this.tHFAdj = SBRConstants.T_HFADJ;
    this.bsco = 0;
    this.bsco_prev = 0;
    this.M_prev = 0;
    this.bs_start_freq_prev = -1;
    if (smallFrames) {
        this.numTimeSlotsRate = SBRConstants.RATE * SBRConstants.NO_TIME_SLOTS_960;
        this.numTimeSlots = SBRConstants.NO_TIME_SLOTS_960;
    } else {
        this.numTimeSlotsRate = SBRConstants.RATE * SBRConstants.NO_TIME_SLOTS;
        this.numTimeSlots = SBRConstants.NO_TIME_SLOTS;
    }
    this.GQ_ringbuf_index[0] = 0;
    this.GQ_ringbuf_index[1] = 0;
    if (stereo) {
        var j;
        this.qmfa[0] = new AnalysisFilterbank(32);
        this.qmfa[1] = new AnalysisFilterbank(32);
        this.qmfs[0] = new SynthesisFilterbank((downSampledSBR) ? 32 : 64);
        this.qmfs[1] = new SynthesisFilterbank((downSampledSBR) ? 32 : 64);
    } else {
        this.qmfa[0] = new AnalysisFilterbank(32);
        this.qmfs[0] = new SynthesisFilterbank((downSampledSBR) ? 32 : 64);
        this.qmfs[1] = null;
    }
};
SBR = stjs.extend(SBR, null, [SBRConstants, SyntaxConstants, HuffmanTables], function(constructor, prototype) {
    prototype.downSampledSBR = false;
    prototype.sample_rate = null;
    prototype.maxAACLine = 0;
    prototype.rate = 0;
    prototype.just_seeked = false;
    prototype.ret = 0;
    prototype.amp_res = null;
    prototype.k0 = 0;
    prototype.kx = 0;
    prototype.M = 0;
    prototype.N_master = 0;
    prototype.N_high = 0;
    prototype.N_low = 0;
    prototype.N_Q = 0;
    prototype.N_L = null;
    prototype.n = null;
    prototype.f_master = null;
    prototype.f_table_res = null;
    prototype.f_table_noise = null;
    prototype.f_table_lim = null;
    prototype.table_map_k_to_g = null;
    prototype.abs_bord_lead = null;
    prototype.abs_bord_trail = null;
    prototype.n_rel_lead = null;
    prototype.n_rel_trail = null;
    prototype.L_E = null;
    prototype.L_E_prev = null;
    prototype.L_Q = null;
    prototype.t_E = null;
    prototype.t_Q = null;
    prototype.f = null;
    prototype.f_prev = null;
    prototype.G_temp_prev = null;
    prototype.Q_temp_prev = null;
    prototype.GQ_ringbuf_index = null;
    prototype.E = null;
    prototype.E_prev = null;
    prototype.E_orig = null;
    prototype.E_curr = null;
    prototype.Q = null;
    prototype.Q_div = null;
    prototype.Q_div2 = null;
    prototype.Q_prev = null;
    prototype.l_A = null;
    prototype.l_A_prev = null;
    prototype.bs_invf_mode = null;
    prototype.bs_invf_mode_prev = null;
    prototype.bwArray = null;
    prototype.bwArray_prev = null;
    prototype.noPatches = 0;
    prototype.patchNoSubbands = null;
    prototype.patchStartSubband = null;
    prototype.bs_add_harmonic = null;
    prototype.bs_add_harmonic_prev = null;
    prototype.index_noise_prev = null;
    prototype.psi_is_prev = null;
    prototype.bs_start_freq_prev = 0;
    prototype.bs_stop_freq_prev = 0;
    prototype.bs_xover_band_prev = 0;
    prototype.bs_freq_scale_prev = 0;
    prototype.bs_alter_scale_prev = false;
    prototype.bs_noise_bands_prev = 0;
    prototype.prevEnvIsShort = null;
    prototype.kx_prev = 0;
    prototype.bsco = 0;
    prototype.bsco_prev = 0;
    prototype.M_prev = 0;
    prototype.Reset = false;
    prototype.frame = 0;
    prototype.header_count = 0;
    prototype.stereo = false;
    prototype.qmfa = null;
    prototype.qmfs = null;
    prototype.Xsbr = null;
    prototype.numTimeSlotsRate = 0;
    prototype.numTimeSlots = 0;
    prototype.tHFGen = 0;
    prototype.tHFAdj = 0;
    prototype.ps = null;
    prototype.ps_used = false;
    prototype.psResetFlag = false;
    prototype.bs_header_flag = false;
    prototype.bs_crc_flag = 0;
    prototype.bs_sbr_crc_bits = 0;
    prototype.bs_protocol_version = 0;
    prototype.bs_amp_res = false;
    prototype.bs_start_freq = 0;
    prototype.bs_stop_freq = 0;
    prototype.bs_xover_band = 0;
    prototype.bs_freq_scale = 0;
    prototype.bs_alter_scale = false;
    prototype.bs_noise_bands = 0;
    prototype.bs_limiter_bands = 0;
    prototype.bs_limiter_gains = 0;
    prototype.bs_interpol_freq = false;
    prototype.bs_smoothing_mode = false;
    prototype.bs_samplerate_mode = 0;
    prototype.bs_add_harmonic_flag = null;
    prototype.bs_add_harmonic_flag_prev = null;
    prototype.bs_extended_data = false;
    prototype.bs_extension_id = 0;
    prototype.bs_extension_data = 0;
    prototype.bs_coupling = false;
    prototype.bs_frame_class = null;
    prototype.bs_rel_bord = null;
    prototype.bs_rel_bord_0 = null;
    prototype.bs_rel_bord_1 = null;
    prototype.bs_pointer = null;
    prototype.bs_abs_bord_0 = null;
    prototype.bs_abs_bord_1 = null;
    prototype.bs_num_rel_0 = null;
    prototype.bs_num_rel_1 = null;
    prototype.bs_df_env = null;
    prototype.bs_df_noise = null;
    prototype.sbrReset = function() {
        var j;
        if (this.qmfa[0] != null) 
            this.qmfa[0].reset();
        if (this.qmfa[1] != null) 
            this.qmfa[1].reset();
        if (this.qmfs[0] != null) 
            this.qmfs[0].reset();
        if (this.qmfs[1] != null) 
            this.qmfs[1].reset();
        for (j = 0; j < 5; j++) {
            if (this.G_temp_prev[0][j] != null) 
                Arrays.fill(this.G_temp_prev[0][j], 0);
            if (this.G_temp_prev[1][j] != null) 
                Arrays.fill(this.G_temp_prev[1][j], 0);
            if (this.Q_temp_prev[0][j] != null) 
                Arrays.fill(this.Q_temp_prev[0][j], 0);
            if (this.Q_temp_prev[1][j] != null) 
                Arrays.fill(this.Q_temp_prev[1][j], 0);
        }
        for (var i = 0; i < 40; i++) {
            for (var k = 0; k < 64; k++) {
                this.Xsbr[0][i][j][0] = 0;
                this.Xsbr[0][i][j][1] = 0;
                this.Xsbr[1][i][j][0] = 0;
                this.Xsbr[1][i][j][1] = 0;
            }
        }
        this.GQ_ringbuf_index[0] = 0;
        this.GQ_ringbuf_index[1] = 0;
        this.header_count = 0;
        this.Reset = true;
        this.L_E_prev[0] = 0;
        this.L_E_prev[1] = 0;
        this.bs_freq_scale = 2;
        this.bs_alter_scale = true;
        this.bs_noise_bands = 2;
        this.bs_limiter_bands = 2;
        this.bs_limiter_gains = 2;
        this.bs_interpol_freq = true;
        this.bs_smoothing_mode = true;
        this.bs_start_freq = 5;
        this.bs_amp_res = true;
        this.bs_samplerate_mode = 1;
        this.prevEnvIsShort[0] = -1;
        this.prevEnvIsShort[1] = -1;
        this.bsco = 0;
        this.bsco_prev = 0;
        this.M_prev = 0;
        this.bs_start_freq_prev = -1;
        this.f_prev[0] = 0;
        this.f_prev[1] = 0;
        for (j = 0; j < SBRConstants.MAX_M; j++) {
            this.E_prev[0][j] = 0;
            this.Q_prev[0][j] = 0;
            this.E_prev[1][j] = 0;
            this.Q_prev[1][j] = 0;
            this.bs_add_harmonic_prev[0][j] = 0;
            this.bs_add_harmonic_prev[1][j] = 0;
        }
        this.bs_add_harmonic_flag_prev[0] = false;
        this.bs_add_harmonic_flag_prev[1] = false;
    };
    prototype.sbr_reset = function() {
        if ((this.bs_start_freq != this.bs_start_freq_prev) || (this.bs_stop_freq != this.bs_stop_freq_prev) || (this.bs_freq_scale != this.bs_freq_scale_prev) || (this.bs_alter_scale != this.bs_alter_scale_prev) || (this.bs_xover_band != this.bs_xover_band_prev) || (this.bs_noise_bands != this.bs_noise_bands_prev)) {
            this.Reset = true;
        } else {
            this.Reset = false;
        }
        this.bs_start_freq_prev = this.bs_start_freq;
        this.bs_stop_freq_prev = this.bs_stop_freq;
        this.bs_freq_scale_prev = this.bs_freq_scale;
        this.bs_alter_scale_prev = this.bs_alter_scale;
        this.bs_xover_band_prev = this.bs_xover_band;
        this.bs_noise_bands_prev = this.bs_noise_bands;
    };
    prototype.calc_sbr_tables = function(start_freq, stop_freq, samplerate_mode, freq_scale, alter_scale, xover_band) {
        var result = 0;
        var k2;
        this.k0 = FBT.qmf_start_channel(start_freq, samplerate_mode, this.sample_rate);
        k2 = FBT.qmf_stop_channel(stop_freq, this.sample_rate, this.k0);
        if (this.sample_rate.getFrequency() >= 48000) {
            if ((k2 - this.k0) > 32) 
                result += 1;
        } else if (this.sample_rate.getFrequency() <= 32000) {
            if ((k2 - this.k0) > 48) 
                result += 1;
        } else {
            if ((k2 - this.k0) > 45) 
                result += 1;
        }
        if (freq_scale == 0) {
            result += FBT.master_frequency_table_fs0(this, this.k0, k2, alter_scale);
        } else {
            result += FBT.master_frequency_table(this, this.k0, k2, freq_scale, alter_scale);
        }
        result += FBT.derived_frequency_table(this, xover_band, k2);
        result = (result > 0) ? 1 : 0;
        return result;
    };
    prototype.decode = function(ld, cnt) {
        var result = 0;
        var num_align_bits = 0;
        var num_sbr_bits1 = ld.getPosition();
        var num_sbr_bits2;
        var saved_start_freq, saved_samplerate_mode;
        var saved_stop_freq, saved_freq_scale;
        var saved_xover_band;
        var saved_alter_scale;
        var bs_extension_type = ld.readBits(4);
        if (bs_extension_type == SBRConstants.EXT_SBR_DATA_CRC) {
            this.bs_sbr_crc_bits = ld.readBits(10);
        }
        saved_start_freq = this.bs_start_freq;
        saved_samplerate_mode = this.bs_samplerate_mode;
        saved_stop_freq = this.bs_stop_freq;
        saved_freq_scale = this.bs_freq_scale;
        saved_alter_scale = this.bs_alter_scale;
        saved_xover_band = this.bs_xover_band;
        this.bs_header_flag = ld.readBool();
        if (this.bs_header_flag) 
            this.sbr_header(ld);
        this.sbr_reset();
        if (this.header_count != 0) {
            if (this.Reset || (this.bs_header_flag && this.just_seeked)) {
                var rt = this.calc_sbr_tables(this.bs_start_freq, this.bs_stop_freq, this.bs_samplerate_mode, this.bs_freq_scale, this.bs_alter_scale, this.bs_xover_band);
                if (rt > 0) {
                    this.calc_sbr_tables(saved_start_freq, saved_stop_freq, saved_samplerate_mode, saved_freq_scale, saved_alter_scale, saved_xover_band);
                }
            }
            if (result == 0) {
                result = this.sbr_data(ld);
                if ((result > 0) && (this.Reset || (this.bs_header_flag && this.just_seeked))) {
                    this.calc_sbr_tables(saved_start_freq, saved_stop_freq, saved_samplerate_mode, saved_freq_scale, saved_alter_scale, saved_xover_band);
                }
            }
        } else {
            result = 1;
        }
        num_sbr_bits2 = (((ld.getPosition() - num_sbr_bits1)) | 0);
        if (8 * cnt < num_sbr_bits2) {
             throw new AACException("frame overread");
        }
        {
            num_align_bits = 8 * cnt - num_sbr_bits2;
             while (num_align_bits > 7){
                ld.readBits(8);
                num_align_bits -= 8;
            }
            ld.readBits(num_align_bits);
        }return result;
    };
    prototype.sbr_header = function(ld) {
        var bs_header_extra_1, bs_header_extra_2;
        this.header_count++;
        this.bs_amp_res = ld.readBool();
        this.bs_start_freq = ld.readBits(4);
        this.bs_stop_freq = ld.readBits(4);
        this.bs_xover_band = ld.readBits(3);
        ld.readBits(2);
        bs_header_extra_1 = ld.readBool();
        bs_header_extra_2 = ld.readBool();
        if (bs_header_extra_1) {
            this.bs_freq_scale = ld.readBits(2);
            this.bs_alter_scale = ld.readBool();
            this.bs_noise_bands = ld.readBits(2);
        } else {
            this.bs_freq_scale = 2;
            this.bs_alter_scale = true;
            this.bs_noise_bands = 2;
        }
        if (bs_header_extra_2) {
            this.bs_limiter_bands = ld.readBits(2);
            this.bs_limiter_gains = ld.readBits(2);
            this.bs_interpol_freq = ld.readBool();
            this.bs_smoothing_mode = ld.readBool();
        } else {
            this.bs_limiter_bands = 2;
            this.bs_limiter_gains = 2;
            this.bs_interpol_freq = true;
            this.bs_smoothing_mode = true;
        }
    };
    prototype.sbr_data = function(ld) {
        var result;
        this.rate = (this.bs_samplerate_mode != 0) ? 2 : 1;
        if (this.stereo) {
            if ((result = this.sbr_channel_pair_element(ld)) > 0) 
                return result;
        } else {
            if ((result = this.sbr_single_channel_element(ld)) > 0) 
                return result;
        }
        return 0;
    };
    prototype.sbr_single_channel_element = function(ld) {
        var result;
        if (ld.readBool()) {
            ld.readBits(4);
        }
        if ((result = this.sbr_grid(ld, 0)) > 0) 
            return result;
        this.sbr_dtdf(ld, 0);
        this.invf_mode(ld, 0);
        this.sbr_envelope(ld, 0);
        this.sbr_noise(ld, 0);
        NoiseEnvelope.dequantChannel(this, 0);
        Arrays.fillRange(this.bs_add_harmonic[0], 0, 64, 0);
        Arrays.fillRange(this.bs_add_harmonic[1], 0, 64, 0);
        this.bs_add_harmonic_flag[0] = ld.readBool();
        if (this.bs_add_harmonic_flag[0]) 
            this.sinusoidal_coding(ld, 0);
        this.bs_extended_data = ld.readBool();
        if (this.bs_extended_data) {
            var nr_bits_left;
            var ps_ext_read = 0;
            var cnt = ld.readBits(4);
            if (cnt == 15) {
                cnt += ld.readBits(8);
            }
            nr_bits_left = 8 * cnt;
             while (nr_bits_left > 7){
                var tmp_nr_bits = 0;
                this.bs_extension_id = ld.readBits(2);
                tmp_nr_bits += 2;
                if (this.bs_extension_id == SBRConstants.EXTENSION_ID_PS) {
                    if (ps_ext_read == 0) {
                        ps_ext_read = 1;
                    } else {
                        this.bs_extension_id = 3;
                    }
                }
                tmp_nr_bits += this.sbr_extension(ld, this.bs_extension_id, nr_bits_left);
                if (tmp_nr_bits > nr_bits_left) 
                    return 1;
                nr_bits_left -= tmp_nr_bits;
            }
            if (nr_bits_left > 0) {
                ld.readBits(nr_bits_left);
            }
        }
        return 0;
    };
    prototype.sbr_channel_pair_element = function(ld) {
        var n, result;
        if (ld.readBool()) {
            ld.readBits(4);
            ld.readBits(4);
        }
        this.bs_coupling = ld.readBool();
        if (this.bs_coupling) {
            if ((result = this.sbr_grid(ld, 0)) > 0) 
                return result;
            this.bs_frame_class[1] = this.bs_frame_class[0];
            this.L_E[1] = this.L_E[0];
            this.L_Q[1] = this.L_Q[0];
            this.bs_pointer[1] = this.bs_pointer[0];
            for (n = 0; n <= this.L_E[0]; n++) {
                this.t_E[1][n] = this.t_E[0][n];
                this.f[1][n] = this.f[0][n];
            }
            for (n = 0; n <= this.L_Q[0]; n++) {
                this.t_Q[1][n] = this.t_Q[0][n];
            }
            this.sbr_dtdf(ld, 0);
            this.sbr_dtdf(ld, 1);
            this.invf_mode(ld, 0);
            for (n = 0; n < this.N_Q; n++) {
                this.bs_invf_mode[1][n] = this.bs_invf_mode[0][n];
            }
            this.sbr_envelope(ld, 0);
            this.sbr_noise(ld, 0);
            this.sbr_envelope(ld, 1);
            this.sbr_noise(ld, 1);
            Arrays.fillRange(this.bs_add_harmonic[0], 0, 64, 0);
            Arrays.fillRange(this.bs_add_harmonic[1], 0, 64, 0);
            this.bs_add_harmonic_flag[0] = ld.readBool();
            if (this.bs_add_harmonic_flag[0]) 
                this.sinusoidal_coding(ld, 0);
            this.bs_add_harmonic_flag[1] = ld.readBool();
            if (this.bs_add_harmonic_flag[1]) 
                this.sinusoidal_coding(ld, 1);
        } else {
            var saved_t_E = new Int32Array(6), saved_t_Q = new Int32Array(3);
            var saved_L_E = this.L_E[0];
            var saved_L_Q = this.L_Q[0];
            var saved_frame_class = this.bs_frame_class[0];
            for (n = 0; n < saved_L_E; n++) {
                saved_t_E[n] = this.t_E[0][n];
            }
            for (n = 0; n < saved_L_Q; n++) {
                saved_t_Q[n] = this.t_Q[0][n];
            }
            if ((result = this.sbr_grid(ld, 0)) > 0) 
                return result;
            if ((result = this.sbr_grid(ld, 1)) > 0) {
                this.bs_frame_class[0] = saved_frame_class;
                this.L_E[0] = saved_L_E;
                this.L_Q[0] = saved_L_Q;
                for (n = 0; n < 6; n++) {
                    this.t_E[0][n] = saved_t_E[n];
                }
                for (n = 0; n < 3; n++) {
                    this.t_Q[0][n] = saved_t_Q[n];
                }
                return result;
            }
            this.sbr_dtdf(ld, 0);
            this.sbr_dtdf(ld, 1);
            this.invf_mode(ld, 0);
            this.invf_mode(ld, 1);
            this.sbr_envelope(ld, 0);
            this.sbr_envelope(ld, 1);
            this.sbr_noise(ld, 0);
            this.sbr_noise(ld, 1);
            Arrays.fillRange(this.bs_add_harmonic[0], 0, 64, 0);
            Arrays.fillRange(this.bs_add_harmonic[1], 0, 64, 0);
            this.bs_add_harmonic_flag[0] = ld.readBool();
            if (this.bs_add_harmonic_flag[0]) 
                this.sinusoidal_coding(ld, 0);
            this.bs_add_harmonic_flag[1] = ld.readBool();
            if (this.bs_add_harmonic_flag[1]) 
                this.sinusoidal_coding(ld, 1);
        }
        NoiseEnvelope.dequantChannel(this, 0);
        NoiseEnvelope.dequantChannel(this, 1);
        if (this.bs_coupling) 
            NoiseEnvelope.unmap(this);
        this.bs_extended_data = ld.readBool();
        if (this.bs_extended_data) {
            var nr_bits_left;
            var cnt = ld.readBits(4);
            if (cnt == 15) {
                cnt += ld.readBits(8);
            }
            nr_bits_left = 8 * cnt;
             while (nr_bits_left > 7){
                var tmp_nr_bits = 0;
                this.bs_extension_id = ld.readBits(2);
                tmp_nr_bits += 2;
                tmp_nr_bits += this.sbr_extension(ld, this.bs_extension_id, nr_bits_left);
                if (tmp_nr_bits > nr_bits_left) 
                    return 1;
                nr_bits_left -= tmp_nr_bits;
            }
            if (nr_bits_left > 0) {
                ld.readBits(nr_bits_left);
            }
        }
        return 0;
    };
    prototype.sbr_log2 = function(val) {
        var log2tab = new Int32Array([0, 0, 1, 2, 2, 3, 3, 3, 3, 4]);
        if (val < 10 && val >= 0) 
            return log2tab[val];
         else 
            return 0;
    };
    prototype.sbr_grid = function(ld, ch) {
        var i, env, rel, result;
        var bs_abs_bord, bs_abs_bord_1;
        var bs_num_env = 0;
        var saved_L_E = this.L_E[ch];
        var saved_L_Q = this.L_Q[ch];
        var saved_frame_class = this.bs_frame_class[ch];
        this.bs_frame_class[ch] = ld.readBits(2);
        switch (this.bs_frame_class[ch]) {
            case SBRConstants.FIXFIX:
                i = ld.readBits(2);
                bs_num_env = Math.min(1 << i, 5);
                i = ld.readBit();
                for (env = 0; env < bs_num_env; env++) {
                    this.f[ch][env] = i;
                }
                this.abs_bord_lead[ch] = 0;
                this.abs_bord_trail[ch] = this.numTimeSlots;
                this.n_rel_lead[ch] = bs_num_env - 1;
                this.n_rel_trail[ch] = 0;
                break;
            case SBRConstants.FIXVAR:
                bs_abs_bord = ld.readBits(2) + this.numTimeSlots;
                bs_num_env = ld.readBits(2) + 1;
                for (rel = 0; rel < bs_num_env - 1; rel++) {
                    this.bs_rel_bord[ch][rel] = 2 * ld.readBits(2) + 2;
                }
                i = this.sbr_log2(bs_num_env + 1);
                this.bs_pointer[ch] = ld.readBits(i);
                for (env = 0; env < bs_num_env; env++) {
                    this.f[ch][bs_num_env - env - 1] = ld.readBit();
                }
                this.abs_bord_lead[ch] = 0;
                this.abs_bord_trail[ch] = bs_abs_bord;
                this.n_rel_lead[ch] = 0;
                this.n_rel_trail[ch] = bs_num_env - 1;
                break;
            case SBRConstants.VARFIX:
                bs_abs_bord = ld.readBits(2);
                bs_num_env = ld.readBits(2) + 1;
                for (rel = 0; rel < bs_num_env - 1; rel++) {
                    this.bs_rel_bord[ch][rel] = 2 * ld.readBits(2) + 2;
                }
                i = this.sbr_log2(bs_num_env + 1);
                this.bs_pointer[ch] = ld.readBits(i);
                for (env = 0; env < bs_num_env; env++) {
                    this.f[ch][env] = ld.readBit();
                }
                this.abs_bord_lead[ch] = bs_abs_bord;
                this.abs_bord_trail[ch] = this.numTimeSlots;
                this.n_rel_lead[ch] = bs_num_env - 1;
                this.n_rel_trail[ch] = 0;
                break;
            case SBRConstants.VARVAR:
                bs_abs_bord = ld.readBits(2);
                bs_abs_bord_1 = ld.readBits(2) + this.numTimeSlots;
                this.bs_num_rel_0[ch] = ld.readBits(2);
                this.bs_num_rel_1[ch] = ld.readBits(2);
                bs_num_env = Math.min(5, this.bs_num_rel_0[ch] + this.bs_num_rel_1[ch] + 1);
                for (rel = 0; rel < this.bs_num_rel_0[ch]; rel++) {
                    this.bs_rel_bord_0[ch][rel] = 2 * ld.readBits(2) + 2;
                }
                for (rel = 0; rel < this.bs_num_rel_1[ch]; rel++) {
                    this.bs_rel_bord_1[ch][rel] = 2 * ld.readBits(2) + 2;
                }
                i = this.sbr_log2(this.bs_num_rel_0[ch] + this.bs_num_rel_1[ch] + 2);
                this.bs_pointer[ch] = ld.readBits(i);
                for (env = 0; env < bs_num_env; env++) {
                    this.f[ch][env] = ld.readBit();
                }
                this.abs_bord_lead[ch] = bs_abs_bord;
                this.abs_bord_trail[ch] = bs_abs_bord_1;
                this.n_rel_lead[ch] = this.bs_num_rel_0[ch];
                this.n_rel_trail[ch] = this.bs_num_rel_1[ch];
                break;
        }
        if (this.bs_frame_class[ch] == SBRConstants.VARVAR) 
            this.L_E[ch] = Math.min(bs_num_env, 5);
         else 
            this.L_E[ch] = Math.min(bs_num_env, 4);
        if (this.L_E[ch] <= 0) 
            return 1;
        if (this.L_E[ch] > 1) 
            this.L_Q[ch] = 2;
         else 
            this.L_Q[ch] = 1;
        if ((result = TFGrid.envelope_time_border_vector(this, ch)) > 0) {
            this.bs_frame_class[ch] = saved_frame_class;
            this.L_E[ch] = saved_L_E;
            this.L_Q[ch] = saved_L_Q;
            return result;
        }
        TFGrid.noise_floor_time_border_vector(this, ch);
        return 0;
    };
    prototype.sbr_dtdf = function(ld, ch) {
        var i;
        for (i = 0; i < this.L_E[ch]; i++) {
            this.bs_df_env[ch][i] = ld.readBit();
        }
        for (i = 0; i < this.L_Q[ch]; i++) {
            this.bs_df_noise[ch][i] = ld.readBit();
        }
    };
    prototype.invf_mode = function(ld, ch) {
        var n;
        for (n = 0; n < this.N_Q; n++) {
            this.bs_invf_mode[ch][n] = ld.readBits(2);
        }
    };
    prototype.sbr_extension = function(ld, bs_extension_id, num_bits_left) {
        var ret;
        switch (bs_extension_id) {
            case SBRConstants.EXTENSION_ID_PS:
                if (this.ps == null) {
                    this.ps = new PS(this.sample_rate, this.numTimeSlotsRate);
                }
                if (this.psResetFlag) {
                    this.ps.header_read = false;
                }
                ret = this.ps.decode(ld);
                if (!this.ps_used && this.ps.header_read) {
                    this.ps_used = true;
                }
                if (this.ps.header_read) {
                    this.psResetFlag = false;
                }
                return ret;
            default:
                this.bs_extension_data = ld.readBits(6);
                return 6;
        }
    };
    prototype.sinusoidal_coding = function(ld, ch) {
        var n;
        for (n = 0; n < this.N_high; n++) {
            this.bs_add_harmonic[ch][n] = ld.readBit();
        }
    };
    prototype.sbr_envelope = function(ld, ch) {
        var env, band;
        var delta = 0;
        var t_huff, f_huff;
        if ((this.L_E[ch] == 1) && (this.bs_frame_class[ch] == SBRConstants.FIXFIX)) 
            this.amp_res[ch] = false;
         else 
            this.amp_res[ch] = this.bs_amp_res;
        if ((this.bs_coupling) && (ch == 1)) {
            delta = 1;
            if (this.amp_res[ch]) {
                t_huff = HuffmanTables.T_HUFFMAN_ENV_BAL_3_0DB;
                f_huff = HuffmanTables.F_HUFFMAN_ENV_BAL_3_0DB;
            } else {
                t_huff = HuffmanTables.T_HUFFMAN_ENV_BAL_1_5DB;
                f_huff = HuffmanTables.F_HUFFMAN_ENV_BAL_1_5DB;
            }
        } else {
            delta = 0;
            if (this.amp_res[ch]) {
                t_huff = HuffmanTables.T_HUFFMAN_ENV_3_0DB;
                f_huff = HuffmanTables.F_HUFFMAN_ENV_3_0DB;
            } else {
                t_huff = HuffmanTables.T_HUFFMAN_ENV_1_5DB;
                f_huff = HuffmanTables.F_HUFFMAN_ENV_1_5DB;
            }
        }
        for (env = 0; env < this.L_E[ch]; env++) {
            if (this.bs_df_env[ch][env] == 0) {
                if (this.bs_coupling && (ch == 1)) {
                    if (this.amp_res[ch]) {
                        this.E[ch][0][env] = ld.readBits(5) << delta;
                    } else {
                        this.E[ch][0][env] = ld.readBits(6) << delta;
                    }
                } else {
                    if (this.amp_res[ch]) {
                        this.E[ch][0][env] = ld.readBits(6) << delta;
                    } else {
                        this.E[ch][0][env] = ld.readBits(7) << delta;
                    }
                }
                for (band = 1; band < this.n[this.f[ch][env]]; band++) {
                    this.E[ch][band][env] = (this.decodeHuffman(ld, f_huff) << delta);
                }
            } else {
                for (band = 0; band < this.n[this.f[ch][env]]; band++) {
                    this.E[ch][band][env] = (this.decodeHuffman(ld, t_huff) << delta);
                }
            }
        }
        NoiseEnvelope.extract_envelope_data(this, ch);
    };
    prototype.sbr_noise = function(ld, ch) {
        var noise, band;
        var delta = 0;
        var t_huff, f_huff;
        if (this.bs_coupling && (ch == 1)) {
            delta = 1;
            t_huff = HuffmanTables.T_HUFFMAN_NOISE_BAL_3_0DB;
            f_huff = HuffmanTables.F_HUFFMAN_ENV_BAL_3_0DB;
        } else {
            delta = 0;
            t_huff = HuffmanTables.T_HUFFMAN_NOISE_3_0DB;
            f_huff = HuffmanTables.F_HUFFMAN_ENV_3_0DB;
        }
        for (noise = 0; noise < this.L_Q[ch]; noise++) {
            if (this.bs_df_noise[ch][noise] == 0) {
                if (this.bs_coupling && (ch == 1)) {
                    this.Q[ch][0][noise] = ld.readBits(5) << delta;
                } else {
                    this.Q[ch][0][noise] = ld.readBits(5) << delta;
                }
                for (band = 1; band < this.N_Q; band++) {
                    this.Q[ch][band][noise] = (this.decodeHuffman(ld, f_huff) << delta);
                }
            } else {
                for (band = 0; band < this.N_Q; band++) {
                    this.Q[ch][band][noise] = (this.decodeHuffman(ld, t_huff) << delta);
                }
            }
        }
        NoiseEnvelope.extract_noise_floor_data(this, ch);
    };
    prototype.decodeHuffman = function(ld, t_huff) {
        var bit;
        var index = 0;
         while (index >= 0){
            bit = ld.readBit();
            index = t_huff[index][bit];
        }
        return index + 64;
    };
    prototype.sbr_save_prev_data = function(ch) {
        var i;
        this.kx_prev = this.kx;
        this.M_prev = this.M;
        this.bsco_prev = this.bsco;
        this.L_E_prev[ch] = this.L_E[ch];
        if (this.L_E[ch] <= 0) 
            return 19;
        this.f_prev[ch] = this.f[ch][this.L_E[ch] - 1];
        for (i = 0; i < SBRConstants.MAX_M; i++) {
            this.E_prev[ch][i] = this.E[ch][i][this.L_E[ch] - 1];
            this.Q_prev[ch][i] = this.Q[ch][i][this.L_Q[ch] - 1];
        }
        for (i = 0; i < SBRConstants.MAX_M; i++) {
            this.bs_add_harmonic_prev[ch][i] = this.bs_add_harmonic[ch][i];
        }
        this.bs_add_harmonic_flag_prev[ch] = this.bs_add_harmonic_flag[ch];
        if (this.l_A[ch] == this.L_E[ch]) 
            this.prevEnvIsShort[ch] = 0;
         else 
            this.prevEnvIsShort[ch] = -1;
        return 0;
    };
    prototype.sbr_save_matrix = function(ch) {
        var i;
        for (i = 0; i < this.tHFGen; i++) {
            for (var j = 0; j < 64; j++) {
                this.Xsbr[ch][i][j][0] = this.Xsbr[ch][i + this.numTimeSlotsRate][j][0];
                this.Xsbr[ch][i][j][1] = this.Xsbr[ch][i + this.numTimeSlotsRate][j][1];
            }
        }
        for (i = this.tHFGen; i < SBRConstants.MAX_NTSRHFG; i++) {
            for (var j = 0; j < 64; j++) {
                this.Xsbr[ch][i][j][0] = 0;
                this.Xsbr[ch][i][j][1] = 0;
            }
        }
    };
    prototype.sbr_process_channel = function(channel_buf, X, ch, dont_process) {
        var k, l;
        var ret = 0;
        this.bsco = 0;
        if (dont_process) 
            this.qmfa[ch].sbr_qmf_analysis_32(this, channel_buf, this.Xsbr[ch], this.tHFGen, 32);
         else 
            this.qmfa[ch].sbr_qmf_analysis_32(this, channel_buf, this.Xsbr[ch], this.tHFGen, this.kx);
        if (!dont_process) {
            HFGeneration.hf_generation(this, this.Xsbr[ch], this.Xsbr[ch], ch);
            ret = HFAdjustment.hf_adjustment(this, this.Xsbr[ch], ch);
            if (ret > 0) {
                dont_process = true;
            }
        }
        if (this.just_seeked || dont_process) {
            for (l = 0; l < this.numTimeSlotsRate; l++) {
                for (k = 0; k < 32; k++) {
                    X[l][k][0] = this.Xsbr[ch][l + this.tHFAdj][k][0];
                    X[l][k][1] = this.Xsbr[ch][l + this.tHFAdj][k][1];
                }
                for (k = 32; k < 64; k++) {
                    X[l][k][0] = 0;
                    X[l][k][1] = 0;
                }
            }
        } else {
            for (l = 0; l < this.numTimeSlotsRate; l++) {
                var kx_band, M_band, bsco_band;
                if (l < this.t_E[ch][0]) {
                    kx_band = this.kx_prev;
                    M_band = this.M_prev;
                    bsco_band = this.bsco_prev;
                } else {
                    kx_band = this.kx;
                    M_band = this.M;
                    bsco_band = this.bsco;
                }
                for (k = 0; k < kx_band + bsco_band; k++) {
                    X[l][k][0] = this.Xsbr[ch][l + this.tHFAdj][k][0];
                    X[l][k][1] = this.Xsbr[ch][l + this.tHFAdj][k][1];
                }
                for (k = kx_band + bsco_band; k < kx_band + M_band; k++) {
                    X[l][k][0] = this.Xsbr[ch][l + this.tHFAdj][k][0];
                    X[l][k][1] = this.Xsbr[ch][l + this.tHFAdj][k][1];
                }
                for (k = Math.max(kx_band + bsco_band, kx_band + M_band); k < 64; k++) {
                    X[l][k][0] = 0;
                    X[l][k][1] = 0;
                }
            }
        }
        return ret;
    };
    prototype._process = function(left_chan, right_chan, just_seeked) {
        var dont_process = false;
        var ret = 0;
        var X = Array.apply(null, Array(SBRConstants.MAX_NTSR)).map(function() {
            return Array.apply(null, Array(64)).map(function() {
                return new Float32Array(2);
            });
        });
        if (!this.stereo) 
            return 21;
        if (this.ret != 0 || (this.header_count == 0)) {
            dont_process = true;
            if (this.ret != 0 && this.Reset) 
                this.bs_start_freq_prev = -1;
        }
        if (just_seeked) {
            this.just_seeked = true;
        } else {
            this.just_seeked = false;
        }
        this.ret += this.sbr_process_channel(left_chan, X, 0, dont_process);
        if (this.downSampledSBR) {
            this.qmfs[0].sbr_qmf_synthesis_32(this, X, left_chan);
        } else {
            this.qmfs[0].sbr_qmf_synthesis_64(this, X, left_chan);
        }
        this.ret += this.sbr_process_channel(right_chan, X, 1, dont_process);
        if (this.downSampledSBR) {
            this.qmfs[1].sbr_qmf_synthesis_32(this, X, right_chan);
        } else {
            this.qmfs[1].sbr_qmf_synthesis_64(this, X, right_chan);
        }
        if (this.bs_header_flag) 
            this.just_seeked = false;
        if (this.header_count != 0 && this.ret == 0) {
            ret = this.sbr_save_prev_data(0);
            if (ret != 0) 
                return ret;
            ret = this.sbr_save_prev_data(1);
            if (ret != 0) 
                return ret;
        }
        this.sbr_save_matrix(0);
        this.sbr_save_matrix(1);
        this.frame++;
        return 0;
    };
    prototype.process = function(channel, just_seeked) {
        var dont_process = false;
        var ret = 0;
        var X = Array.apply(null, Array(SBRConstants.MAX_NTSR)).map(function() {
            return Array.apply(null, Array(64)).map(function() {
                return new Float32Array(2);
            });
        });
        if (this.stereo) 
            return 21;
        if (this.ret != 0 || (this.header_count == 0)) {
            dont_process = true;
            if (this.ret != 0 && this.Reset) 
                this.bs_start_freq_prev = -1;
        }
        if (just_seeked) {
            this.just_seeked = true;
        } else {
            this.just_seeked = false;
        }
        this.ret += this.sbr_process_channel(channel, X, 0, dont_process);
        if (this.downSampledSBR) {
            this.qmfs[0].sbr_qmf_synthesis_32(this, X, channel);
        } else {
            this.qmfs[0].sbr_qmf_synthesis_64(this, X, channel);
        }
        if (this.bs_header_flag) 
            this.just_seeked = false;
        if (this.header_count != 0 && this.ret == 0) {
            ret = this.sbr_save_prev_data(0);
            if (ret != 0) 
                return ret;
        }
        this.sbr_save_matrix(0);
        this.frame++;
        return 0;
    };
    prototype.processPS = function(left_channel, right_channel, just_seeked) {
        var l, k;
        var dont_process = false;
        var ret = 0;
        var X_left = Array.apply(null, Array(38)).map(function() {
            return Array.apply(null, Array(64)).map(function() {
                return new Float32Array(2);
            });
        });
        var X_right = Array.apply(null, Array(38)).map(function() {
            return Array.apply(null, Array(64)).map(function() {
                return new Float32Array(2);
            });
        });
        if (this.stereo) 
            return 21;
        if (this.ret != 0 || (this.header_count == 0)) {
            dont_process = true;
            if (this.ret != 0 && this.Reset) 
                this.bs_start_freq_prev = -1;
        }
        if (just_seeked) {
            this.just_seeked = true;
        } else {
            this.just_seeked = false;
        }
        if (this.qmfs[1] == null) {
            this.qmfs[1] = new SynthesisFilterbank((this.downSampledSBR) ? 32 : 64);
        }
        this.ret += this.sbr_process_channel(left_channel, X_left, 0, dont_process);
        for (l = this.numTimeSlotsRate; l < this.numTimeSlotsRate + 6; l++) {
            for (k = 0; k < 5; k++) {
                X_left[l][k][0] = this.Xsbr[0][this.tHFAdj + l][k][0];
                X_left[l][k][1] = this.Xsbr[0][this.tHFAdj + l][k][1];
            }
        }
        this.ps.process(X_left, X_right);
        if (this.downSampledSBR) {
            this.qmfs[0].sbr_qmf_synthesis_32(this, X_left, left_channel);
            this.qmfs[1].sbr_qmf_synthesis_32(this, X_right, right_channel);
        } else {
            this.qmfs[0].sbr_qmf_synthesis_64(this, X_left, left_channel);
            this.qmfs[1].sbr_qmf_synthesis_64(this, X_right, right_channel);
        }
        if (this.bs_header_flag) 
            this.just_seeked = false;
        if (this.header_count != 0 && this.ret == 0) {
            ret = this.sbr_save_prev_data(0);
            if (ret != 0) 
                return ret;
        }
        this.sbr_save_matrix(0);
        this.frame++;
        return 0;
    };
    prototype.isPSUsed = function() {
        return this.ps_used;
    };
}, {sample_rate: "SampleFrequency", amp_res: "Int8Array", N_L: "Int32Array", n: "Int32Array", f_master: "Int32Array", f_table_res: "Array", f_table_noise: "Int32Array", f_table_lim: "Array", table_map_k_to_g: "Int32Array", abs_bord_lead: "Int32Array", abs_bord_trail: "Int32Array", n_rel_lead: "Int32Array", n_rel_trail: "Int32Array", L_E: "Int32Array", L_E_prev: "Int32Array", L_Q: "Int32Array", t_E: "Array", t_Q: "Array", f: "Array", f_prev: "Int32Array", G_temp_prev: "Array", Q_temp_prev: "Array", GQ_ringbuf_index: "Int32Array", E: "Array", E_prev: "Array", E_orig: "Array", E_curr: "Array", Q: "Array", Q_div: "Array", Q_div2: "Array", Q_prev: "Array", l_A: "Int32Array", l_A_prev: "Int32Array", bs_invf_mode: "Array", bs_invf_mode_prev: "Array", bwArray: "Array", bwArray_prev: "Array", patchNoSubbands: "Int32Array", patchStartSubband: "Int32Array", bs_add_harmonic: "Array", bs_add_harmonic_prev: "Array", index_noise_prev: "Int32Array", psi_is_prev: "Int32Array", prevEnvIsShort: "Int32Array", qmfa: "Array", qmfs: "Array", Xsbr: "Array", ps: "PS", bs_add_harmonic_flag: "Int8Array", bs_add_harmonic_flag_prev: "Int8Array", bs_frame_class: "Int32Array", bs_rel_bord: "Array", bs_rel_bord_0: "Array", bs_rel_bord_1: "Array", bs_pointer: "Int32Array", bs_abs_bord_0: "Int32Array", bs_abs_bord_1: "Int32Array", bs_num_rel_0: "Int32Array", bs_num_rel_1: "Int32Array", bs_df_env: "Array", bs_df_noise: "Array", startMinTable: "Int32Array", offsetIndexTable: "Int32Array", OFFSET: "Array", T_HUFFMAN_ENV_1_5DB: "Array", F_HUFFMAN_ENV_1_5DB: "Array", T_HUFFMAN_ENV_BAL_1_5DB: "Array", F_HUFFMAN_ENV_BAL_1_5DB: "Array", T_HUFFMAN_ENV_3_0DB: "Array", F_HUFFMAN_ENV_3_0DB: "Array", T_HUFFMAN_ENV_BAL_3_0DB: "Array", F_HUFFMAN_ENV_BAL_3_0DB: "Array", T_HUFFMAN_NOISE_3_0DB: "Array", T_HUFFMAN_NOISE_BAL_3_0DB: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var RunLength = function() {
    this.counts = IntArrayList.createIntArrayList();
};
RunLength = stjs.extend(RunLength, null, [], function(constructor, prototype) {
    prototype.counts = null;
    prototype.estimateSize = function() {
        var counts = this.getCounts();
        var recCount = 0;
        for (var i = 0; i < counts.length; i++ , recCount++) {
            var count = counts[i];
             while (count >= 256){
                ++recCount;
                count -= 256;
            }
        }
        return recCount * this.recSize() + 4;
    };
    prototype.recSize = function() {};
    prototype.finish = function() {};
    prototype.getCounts = function() {
        this.finish();
        return this.counts.toArray();
    };
    constructor.Integer = function() {
        RunLength.call(this);
        this.lastValue = RunLength.Integer.MIN_VALUE;
        this.values = IntArrayList.createIntArrayList();
    };
    constructor.Integer = stjs.extend(constructor.Integer, RunLength, [], function(constructor, prototype) {
        constructor.MIN_VALUE = Integer.MIN_VALUE;
        prototype.lastValue = 0;
        prototype.count = 0;
        prototype.values = null;
        prototype.add = function(value) {
            if (this.lastValue == RunLength.Integer.MIN_VALUE || this.lastValue != value) {
                if (this.lastValue != RunLength.Integer.MIN_VALUE) {
                    this.values.add(this.lastValue);
                    this.counts.add(this.count);
                    this.count = 0;
                }
                this.lastValue = value;
            }
            ++this.count;
        };
        prototype.getValues = function() {
            this.finish();
            return this.values.toArray();
        };
        prototype.finish = function() {
            if (this.lastValue != RunLength.Integer.MIN_VALUE) {
                this.values.add(this.lastValue);
                this.counts.add(this.count);
                this.lastValue = RunLength.Integer.MIN_VALUE;
                this.count = 0;
            }
        };
        prototype.serialize = function(bb) {
            var dup = bb.duplicate();
            var counts = this.getCounts();
            var values = this.getValues();
            NIOUtils.skip(bb, 4);
            var recCount = 0;
            for (var i = 0; i < counts.length; i++ , recCount++) {
                var count = counts[i];
                 while (count >= 256){
                    bb.put((255 << 24 >> 24));
                    bb.putInt(values[i]);
                    ++recCount;
                    count -= 256;
                }
                bb.put(((count - 1) << 24 >> 24));
                bb.putInt(values[i]);
            }
            dup.putInt(recCount);
        };
        constructor.parse = function(bb) {
            var rl = new RunLength.Integer();
            var recCount = bb.getInt();
            for (var i = 0; i < recCount; i++) {
                var count = (bb.get() & 255) + 1;
                var value = bb.getInt();
                rl.counts.add(count);
                rl.values.add(value);
            }
            return rl;
        };
        prototype.recSize = function() {
            return 5;
        };
        prototype.flattern = function() {
            var counts = this.getCounts();
            var total = 0;
            for (var i = 0; i < counts.length; i++) {
                total += counts[i];
            }
            var values = this.getValues();
            var result = new Int32Array(total);
            for (var i = 0, ind = 0; i < counts.length; i++) {
                for (var j = 0; j < counts[i]; j++ , ind++) 
                    result[ind] = values[i];
            }
            return result;
        };
    }, {values: "IntArrayList", counts: "IntArrayList"}, {});
    constructor.Long = function() {
        RunLength.call(this);
        this.lastValue = RunLength.Long.MIN_VALUE;
        this.values = LongArrayList.createLongArrayList();
    };
    constructor.Long = stjs.extend(constructor.Long, RunLength, [], function(constructor, prototype) {
        constructor.MIN_VALUE = Long.MIN_VALUE;
        prototype.lastValue = 0;
        prototype.count = 0;
        prototype.values = null;
        prototype.add = function(value) {
            if (this.lastValue == RunLength.Long.MIN_VALUE || this.lastValue != value) {
                if (this.lastValue != RunLength.Long.MIN_VALUE) {
                    this.values.add(this.lastValue);
                    this.counts.add(this.count);
                    this.count = 0;
                }
                this.lastValue = value;
            }
            ++this.count;
        };
        prototype.getCounts = function() {
            this.finish();
            return this.counts.toArray();
        };
        prototype.getValues = function() {
            this.finish();
            return this.values.toArray();
        };
        prototype.finish = function() {
            if (this.lastValue != RunLength.Long.MIN_VALUE) {
                this.values.add(this.lastValue);
                this.counts.add(this.count);
                this.lastValue = RunLength.Long.MIN_VALUE;
                this.count = 0;
            }
        };
        prototype.serialize = function(bb) {
            var dup = bb.duplicate();
            var counts = this.getCounts();
            var values = this.getValues();
            NIOUtils.skip(bb, 4);
            var recCount = 0;
            for (var i = 0; i < counts.length; i++ , recCount++) {
                var count = counts[i];
                 while (count >= 256){
                    bb.put((255 << 24 >> 24));
                    bb.putLong(values[i]);
                    ++recCount;
                    count -= 256;
                }
                bb.put(((count - 1) << 24 >> 24));
                bb.putLong(values[i]);
            }
            dup.putInt(recCount);
        };
        constructor.parse = function(bb) {
            var rl = new RunLength.Long();
            var recCount = bb.getInt();
            for (var i = 0; i < recCount; i++) {
                var count = (bb.get() & 255) + 1;
                var value = bb.getLong();
                rl.counts.add(count);
                rl.values.add(value);
            }
            return rl;
        };
        prototype.recSize = function() {
            return 9;
        };
        prototype.flattern = function() {
            var counts = this.getCounts();
            var total = 0;
            for (var i = 0; i < counts.length; i++) {
                total += counts[i];
            }
            var values = this.getValues();
            var result = Array(total);
            for (var i = 0, ind = 0; i < counts.length; i++) {
                for (var j = 0; j < counts[i]; j++ , ind++) 
                    result[ind] = values[i];
            }
            return result;
        };
    }, {values: "LongArrayList", counts: "IntArrayList"}, {});
}, {counts: "IntArrayList"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  PCM DVD decoder
 *  
 *  @author The JCodec project
 *  
 */
var PCMDVDDecoder = function() {};
PCMDVDDecoder = stjs.extend(PCMDVDDecoder, null, [AudioDecoder], function(constructor, prototype) {
    constructor.lpcm_freq_tab = new Int32Array([48000, 96000, 44100, 32000]);
    prototype.decodeFrame = function(_frame, _dst) {
        var dst = _dst.duplicate();
        var frame = _frame.duplicate();
        frame.order(ByteOrder.BIG_ENDIAN);
        dst.order(ByteOrder.LITTLE_ENDIAN);
        var dvdaudioSubstreamType = frame.get() & 255;
        NIOUtils.skip(frame, 3);
        if ((dvdaudioSubstreamType & 224) == 160) {} else if ((dvdaudioSubstreamType & 224) == 128) {
            if ((dvdaudioSubstreamType & 248) == 136) 
                 throw new RuntimeException("CODEC_ID_DTS");
             else 
                 throw new RuntimeException("CODEC_ID_AC3");
        } else 
             throw new RuntimeException("MPEG DVD unknown coded");
        var b0 = frame.get() & 255;
        var b1 = frame.get() & 255;
        var b2 = frame.get() & 255;
        var freq = (b1 >> 4) & 3;
        var sampleRate = PCMDVDDecoder.lpcm_freq_tab[freq];
        var channelCount = 1 + (b1 & 7);
        var sampleSizeInBits = 16 + ((b1 >> 6) & 3) * 4;
        var nFrames = stjs.trunc(frame.remaining() / (channelCount * (sampleSizeInBits >> 3)));
        switch (sampleSizeInBits) {
            case 20:
                for (var n = 0; n < (nFrames >> 1); n++) {
                    for (var c = 0; c < channelCount; c++) {
                        var s0 = frame.getShort();
                        dst.putShort(s0);
                        var s1 = frame.getShort();
                        dst.putShort(s1);
                    }
                    NIOUtils.skip(frame, channelCount);
                }
                break;
            case 24:
                for (var n = 0; n < (nFrames >> 1); n++) {
                    for (var c = 0; c < channelCount; c++) {
                        var s0 = frame.getShort();
                        dst.putShort(s0);
                        var s1 = frame.getShort();
                        dst.putShort(s1);
                    }
                    NIOUtils.skip(frame, channelCount << 1);
                }
                break;
        }
        dst.flip();
        return new AudioBuffer(dst, new AudioFormat(sampleRate, sampleSizeInBits, channelCount, true, false), nFrames);
    };
    prototype.getCodecMeta = function(_frame) {
        var frame = _frame.duplicate();
        frame.order(ByteOrder.BIG_ENDIAN);
        var dvdaudioSubstreamType = frame.get() & 255;
        NIOUtils.skip(frame, 3);
        if ((dvdaudioSubstreamType & 224) == 160) {} else if ((dvdaudioSubstreamType & 224) == 128) {
            if ((dvdaudioSubstreamType & 248) == 136) 
                 throw new RuntimeException("CODEC_ID_DTS");
             else 
                 throw new RuntimeException("CODEC_ID_AC3");
        } else 
             throw new RuntimeException("MPEG DVD unknown coded");
        var b0 = frame.get() & 255;
        var b1 = frame.get() & 255;
        var b2 = frame.get() & 255;
        var freq = (b1 >> 4) & 3;
        var sampleRate = PCMDVDDecoder.lpcm_freq_tab[freq];
        var channelCount = 1 + (b1 & 7);
        var sampleSizeInBits = 16 + ((b1 >> 6) & 3) * 4;
        return AudioCodecMeta.fromAudioFormat(new AudioFormat(sampleRate, sampleSizeInBits, channelCount, true, false));
    };
}, {lpcm_freq_tab: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Demuxer for MPEG Program Stream format
 *  
 *  @author The JCodec project
 *  
 */
var MPSUtils = function() {};
MPSUtils = stjs.extend(MPSUtils, null, [], function(constructor, prototype) {
    constructor.VIDEO_MIN = 480;
    constructor.VIDEO_MAX = 495;
    constructor.AUDIO_MIN = 448;
    constructor.AUDIO_MAX = 479;
    constructor.PACK = 442;
    constructor.SYSTEM = 443;
    constructor.PSM = 444;
    constructor.PRIVATE_1 = 445;
    constructor.PRIVATE_2 = 447;
    constructor.mediaStream = function(streamId) {
        return (streamId >= MPSUtils.$(MPSUtils.AUDIO_MIN) && streamId <= MPSUtils.$(MPSUtils.VIDEO_MAX) || streamId == MPSUtils.$(MPSUtils.PRIVATE_1) || streamId == MPSUtils.$(MPSUtils.PRIVATE_2));
    };
    constructor.mediaMarker = function(marker) {
        return (marker >= MPSUtils.AUDIO_MIN && marker <= MPSUtils.VIDEO_MAX || marker == MPSUtils.PRIVATE_1 || marker == MPSUtils.PRIVATE_2);
    };
    constructor.psMarker = function(marker) {
        return marker >= MPSUtils.PRIVATE_1 && marker <= MPSUtils.VIDEO_MAX;
    };
    constructor.videoMarker = function(marker) {
        return marker >= MPSUtils.VIDEO_MIN && marker <= MPSUtils.VIDEO_MAX;
    };
    constructor.videoStream = function(streamId) {
        return streamId >= MPSUtils.$(MPSUtils.VIDEO_MIN) && streamId <= MPSUtils.$(MPSUtils.VIDEO_MAX);
    };
    constructor.audioStream = function(streamId) {
        return streamId >= MPSUtils.$(MPSUtils.AUDIO_MIN) && streamId <= MPSUtils.$(MPSUtils.AUDIO_MAX) || streamId == MPSUtils.$(MPSUtils.PRIVATE_1) || streamId == MPSUtils.$(MPSUtils.PRIVATE_2);
    };
    constructor.$ = function(marker) {
        return marker & 255;
    };
    constructor.PESReader = function() {
        this.pesBuffer = ByteBuffer.allocate(1 << 21);
    };
    constructor.PESReader = stjs.extend(constructor.PESReader, null, [], function(constructor, prototype) {
        prototype.marker = -1;
        prototype.lenFieldLeft = 0;
        prototype.pesLen = 0;
        prototype.pesFileStart = -1;
        prototype.stream = 0;
        prototype._pes = false;
        prototype.pesLeft = 0;
        prototype.pesBuffer = null;
        prototype.pes = function(pesBuffer, start, pesLen, stream) {};
        prototype.analyseBuffer = function(buf, pos) {
            var init = buf.position();
             while (buf.hasRemaining()){
                if (this.pesLeft > 0) {
                    var toRead = Math.min(buf.remaining(), this.pesLeft);
                    this.pesBuffer.putBuf(NIOUtils.read(buf, toRead));
                    this.pesLeft -= toRead;
                    if (this.pesLeft == 0) {
                        var filePos = pos + buf.position() - init;
                        this.pes1(this.pesBuffer, this.pesFileStart, (((filePos - this.pesFileStart)) | 0), this.stream);
                        this.pesFileStart = -1;
                        this._pes = false;
                        this.stream = -1;
                    }
                    continue;
                }
                var bt = buf.get() & 255;
                if (this._pes) 
                    this.pesBuffer.put(((this.marker >>> 24) << 24 >> 24));
                this.marker = (this.marker << 8) | bt;
                if (this.marker >= MPSUtils.SYSTEM && this.marker <= MPSUtils.VIDEO_MAX) {
                    var filePos = pos + buf.position() - init - 4;
                    if (this._pes) 
                        this.pes1(this.pesBuffer, this.pesFileStart, (((filePos - this.pesFileStart)) | 0), this.stream);
                    this.pesFileStart = filePos;
                    this._pes = true;
                    this.stream = this.marker & 255;
                    this.lenFieldLeft = 2;
                    this.pesLen = 0;
                } else if (this.marker >= 441 && this.marker <= 511) {
                    if (this._pes) {
                        var filePos = pos + buf.position() - init - 4;
                        this.pes1(this.pesBuffer, this.pesFileStart, (((filePos - this.pesFileStart)) | 0), this.stream);
                    }
                    this.pesFileStart = -1;
                    this._pes = false;
                    this.stream = -1;
                } else if (this.lenFieldLeft > 0) {
                    this.pesLen = (this.pesLen << 8) | bt;
                    this.lenFieldLeft--;
                    if (this.lenFieldLeft == 0) {
                        this.pesLeft = this.pesLen;
                        if (this.pesLen != 0) {
                            this.flushMarker();
                            this.marker = -1;
                        }
                    }
                }
            }
        };
        prototype.flushMarker = function() {
            this.pesBuffer.put(((this.marker >>> 24) << 24 >> 24));
            this.pesBuffer.put((((this.marker >>> 16) & 255) << 24 >> 24));
            this.pesBuffer.put((((this.marker >>> 8) & 255) << 24 >> 24));
            this.pesBuffer.put(((this.marker & 255) << 24 >> 24));
        };
        prototype.pes1 = function(pesBuffer, start, pesLen, stream) {
            pesBuffer.flip();
            this.pes(pesBuffer, start, pesLen, stream);
            pesBuffer.clear();
        };
        prototype.finishRead = function() {
            if (this.pesLeft <= 4) {
                this.flushMarker();
                this.pes1(this.pesBuffer, this.pesFileStart, this.pesBuffer.position(), this.stream);
            }
        };
    }, {pesBuffer: "ByteBuffer"}, {});
    constructor.readPESHeader = function(iss, pos) {
        var streamId = iss.getInt() & 255;
        var len = iss.getShort() & 65535;
        if (streamId != 191) {
            var b0 = iss.get() & 255;
            if ((b0 & 192) == 128) 
                return MPSUtils.mpeg2Pes(b0, len, streamId, iss, pos);
             else 
                return MPSUtils.mpeg1Pes(b0, len, streamId, iss, pos);
        }
        return new PESPacket(null, -1, streamId, len, pos, -1);
    };
    constructor.mpeg1Pes = function(b0, len, streamId, is, pos) {
        var c = b0;
         while (c == 255){
            c = is.get() & 255;
        }
        if ((c & 192) == 64) {
            is.get();
            c = is.get() & 255;
        }
        var pts = -1, dts = -1;
        if ((c & 240) == 32) {
            pts = MPSUtils._readTs(is, c);
        } else if ((c & 240) == 48) {
            pts = MPSUtils._readTs(is, c);
            dts = MPSUtils.readTs(is);
        } else {
            if (c != 15) 
                 throw new RuntimeException("Invalid data");
        }
        return new PESPacket(null, pts, streamId, len, pos, dts);
    };
    constructor._readTs = function(is, c) {
        return ((stjs.trunc(c) & 14) << 29) | ((is.get() & 255) << 22) | (((is.get() & 255) >> 1) << 15) | ((is.get() & 255) << 7) | ((is.get() & 255) >> 1);
    };
    constructor.mpeg2Pes = function(b0, len, streamId, is, pos) {
        var flags1 = b0;
        var flags2 = is.get() & 255;
        var header_len = is.get() & 255;
        var pts = -1, dts = -1;
        if ((flags2 & 192) == 128) {
            pts = MPSUtils.readTs(is);
            NIOUtils.skip(is, header_len - 5);
        } else if ((flags2 & 192) == 192) {
            pts = MPSUtils.readTs(is);
            dts = MPSUtils.readTs(is);
            NIOUtils.skip(is, header_len - 10);
        } else 
            NIOUtils.skip(is, header_len);
        return new PESPacket(null, pts, streamId, len, pos, dts);
    };
    constructor.readTs = function(is) {
        return ((stjs.trunc(is.get()) & 14) << 29) | ((is.get() & 255) << 22) | (((is.get() & 255) >> 1) << 15) | ((is.get() & 255) << 7) | ((is.get() & 255) >> 1);
    };
    constructor.writeTs = function(is, ts) {
        is.put((((ts >> 29) << 1) << 24 >> 24));
        is.put(((ts >> 22) << 24 >> 24));
        is.put((((ts >> 15) << 1) << 24 >> 24));
        is.put(((ts >> 7) << 24 >> 24));
        is.put(((ts >> 1) << 24 >> 24));
    };
    constructor.MPEGMediaDescriptor = function() {};
    constructor.MPEGMediaDescriptor = stjs.extend(constructor.MPEGMediaDescriptor, null, [], function(constructor, prototype) {
        prototype.tag = 0;
        prototype.len = 0;
        prototype.parse = function(buf) {
            this.tag = buf.get() & 255;
            this.len = buf.get() & 255;
        };
        prototype.getTag = function() {
            return this.tag;
        };
        prototype.getLen = function() {
            return this.len;
        };
    }, {}, {});
    constructor.VideoStreamDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
        this.frameRates = [null, new Rational(24000, 1001), new Rational(24, 1), new Rational(25, 1), new Rational(30000, 1001), new Rational(30, 1), new Rational(50, 1), new Rational(60000, 1001), new Rational(60, 1), null, null, null, null, null, null, null];
    };
    constructor.VideoStreamDescriptor = stjs.extend(constructor.VideoStreamDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.multipleFrameRate = 0;
        prototype.frameRateCode = 0;
        prototype.mpeg1Only = false;
        prototype.constrainedParameter = 0;
        prototype.stillPicture = 0;
        prototype.profileAndLevel = 0;
        prototype.chromaFormat = 0;
        prototype.frameRateExtension = 0;
        prototype.frameRates = null;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
            var b0 = buf.get() & 255;
            this.multipleFrameRate = (b0 >> 7) & 1;
            this.frameRateCode = (b0 >> 3) & 15;
            this.mpeg1Only = ((b0 >> 2) & 1) == 0;
            this.constrainedParameter = (b0 >> 1) & 1;
            this.stillPicture = b0 & 1;
            if (!this.mpeg1Only) {
                this.profileAndLevel = buf.get() & 255;
                var b1 = buf.get() & 255;
                this.chromaFormat = b1 >> 6;
                this.frameRateExtension = (b1 >> 5) & 1;
            }
        };
        prototype.getFrameRate = function() {
            return this.frameRates[this.frameRateCode];
        };
        prototype.getMultipleFrameRate = function() {
            return this.multipleFrameRate;
        };
        prototype.getFrameRateCode = function() {
            return this.frameRateCode;
        };
        prototype.isMpeg1Only = function() {
            return this.mpeg1Only;
        };
        prototype.getConstrainedParameter = function() {
            return this.constrainedParameter;
        };
        prototype.getStillPicture = function() {
            return this.stillPicture;
        };
        prototype.getProfileAndLevel = function() {
            return this.profileAndLevel;
        };
        prototype.getChromaFormat = function() {
            return this.chromaFormat;
        };
        prototype.getFrameRateExtension = function() {
            return this.frameRateExtension;
        };
    }, {frameRates: "Array"}, {});
    constructor.AudioStreamDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
    };
    constructor.AudioStreamDescriptor = stjs.extend(constructor.AudioStreamDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.variableRateAudioIndicator = 0;
        prototype.freeFormatFlag = 0;
        prototype.id = 0;
        prototype.layer = 0;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
            var b0 = buf.get() & 255;
            this.freeFormatFlag = (b0 >> 7) & 1;
            this.id = (b0 >> 6) & 1;
            this.layer = (b0 >> 5) & 3;
            this.variableRateAudioIndicator = (b0 >> 3) & 1;
        };
        prototype.getVariableRateAudioIndicator = function() {
            return this.variableRateAudioIndicator;
        };
        prototype.getFreeFormatFlag = function() {
            return this.freeFormatFlag;
        };
        prototype.getId = function() {
            return this.id;
        };
        prototype.getLayer = function() {
            return this.layer;
        };
    }, {}, {});
    constructor.ISO639LanguageDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
        this.languageCodes = IntArrayList.createIntArrayList();
    };
    constructor.ISO639LanguageDescriptor = stjs.extend(constructor.ISO639LanguageDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.languageCodes = null;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
             while (buf.remaining() >= 4){
                this.languageCodes.add(buf.getInt());
            }
        };
        prototype.getLanguageCodes = function() {
            return this.languageCodes;
        };
    }, {languageCodes: "IntArrayList"}, {});
    constructor.Mpeg4VideoDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
    };
    constructor.Mpeg4VideoDescriptor = stjs.extend(constructor.Mpeg4VideoDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.profileLevel = 0;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
            this.profileLevel = buf.get() & 255;
        };
    }, {}, {});
    constructor.Mpeg4AudioDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
    };
    constructor.Mpeg4AudioDescriptor = stjs.extend(constructor.Mpeg4AudioDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.profileLevel = 0;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
            this.profileLevel = buf.get() & 255;
        };
        prototype.getProfileLevel = function() {
            return this.profileLevel;
        };
    }, {}, {});
    constructor.AVCVideoDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
    };
    constructor.AVCVideoDescriptor = stjs.extend(constructor.AVCVideoDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.profileIdc = 0;
        prototype.flags = 0;
        prototype.level = 0;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
            this.profileIdc = buf.get() & 255;
            this.flags = buf.get() & 255;
            this.level = buf.get() & 255;
        };
        prototype.getProfileIdc = function() {
            return this.profileIdc;
        };
        prototype.getFlags = function() {
            return this.flags;
        };
        prototype.getLevel = function() {
            return this.level;
        };
    }, {}, {});
    constructor.AACAudioDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
    };
    constructor.AACAudioDescriptor = stjs.extend(constructor.AACAudioDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.profile = 0;
        prototype.channel = 0;
        prototype.flags = 0;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
            this.profile = buf.get() & 255;
            this.channel = buf.get() & 255;
            this.flags = buf.get() & 255;
        };
        prototype.getProfile = function() {
            return this.profile;
        };
        prototype.getChannel = function() {
            return this.channel;
        };
        prototype.getFlags = function() {
            return this.flags;
        };
    }, {}, {});
    constructor.DataStreamAlignmentDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
    };
    constructor.DataStreamAlignmentDescriptor = stjs.extend(constructor.DataStreamAlignmentDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.alignmentType = 0;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
            this.alignmentType = buf.get() & 255;
        };
        prototype.getAlignmentType = function() {
            return this.alignmentType;
        };
    }, {}, {});
    constructor.RegistrationDescriptor = function() {
        MPSUtils.MPEGMediaDescriptor.call(this);
        this.additionalFormatIdentifiers = IntArrayList.createIntArrayList();
    };
    constructor.RegistrationDescriptor = stjs.extend(constructor.RegistrationDescriptor, MPSUtils.MPEGMediaDescriptor, [], function(constructor, prototype) {
        prototype.formatIdentifier = 0;
        prototype.additionalFormatIdentifiers = null;
        prototype.parse = function(buf) {
            MPSUtils.MPEGMediaDescriptor.prototype.parse.call(this, buf);
            this.formatIdentifier = buf.getInt();
             while (buf.hasRemaining()){
                this.additionalFormatIdentifiers.add(buf.get() & 255);
            }
        };
        prototype.getFormatIdentifier = function() {
            return this.formatIdentifier;
        };
        prototype.getAdditionalFormatIdentifiers = function() {
            return this.additionalFormatIdentifiers;
        };
    }, {additionalFormatIdentifiers: "IntArrayList"}, {});
    constructor.dMapping = Array(256);
    constructor.parseDescriptors = function(bb) {
        var result = new ArrayList();
         while (bb.remaining() >= 2){
            var dup = bb.duplicate();
            var tag = dup.get() & 255;
            var len = dup.get() & 255;
            var descriptorBuffer = NIOUtils.read(bb, len + 2);
            if (MPSUtils.dMapping[tag] != null) 
                try {
                    var descriptor = MPSUtils.dMapping[tag].newInstance();
                    descriptor.parse(descriptorBuffer);
                    result.add(descriptor);
                }catch (e) {
                     throw new RuntimeException(e);
                }
        }
        return result;
    };
}, {dMapping: "Array"}, {});
(function() {
    MPSUtils.dMapping[2] = MPSUtils.VideoStreamDescriptor;
    MPSUtils.dMapping[3] = MPSUtils.AudioStreamDescriptor;
    MPSUtils.dMapping[6] = MPSUtils.DataStreamAlignmentDescriptor;
    MPSUtils.dMapping[5] = MPSUtils.RegistrationDescriptor;
    MPSUtils.dMapping[10] = MPSUtils.ISO639LanguageDescriptor;
    MPSUtils.dMapping[27] = MPSUtils.Mpeg4VideoDescriptor;
    MPSUtils.dMapping[28] = MPSUtils.Mpeg4AudioDescriptor;
    MPSUtils.dMapping[40] = MPSUtils.AVCVideoDescriptor;
    MPSUtils.dMapping[43] = MPSUtils.AACAudioDescriptor;
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  FLV ( Flash Media Video ) muxer
 *  
 *  @author Stan Vitvitskyy
 *  
 */
var FLVWriter = function(out) {
    this.out = out;
    this.writeBuf = ByteBuffer.allocate(FLVWriter.WRITE_BUFFER_SIZE);
    FLVWriter.writeHeader(this.writeBuf);
};
FLVWriter = stjs.extend(FLVWriter, null, [], function(constructor, prototype) {
    constructor.WRITE_BUFFER_SIZE = 1048576;
    prototype.startOfLastPacket = 9;
    prototype.out = null;
    prototype.writeBuf = null;
    /**
     *  Add a packet to the underlying file
     *  
     *  @param pkt
     *  @throws IOException
     */
    prototype.addPacket = function(pkt) {
        if (!this.writePacket(this.writeBuf, pkt)) {
            this.writeBuf.flip();
            this.startOfLastPacket -= this.out.write(this.writeBuf);
            this.writeBuf.clear();
            if (!this.writePacket(this.writeBuf, pkt)) 
                 throw new RuntimeException("Unexpected");
        }
    };
    /**
     *  Finish muxing and write the remaining data
     *  
     *  @throws IOException
     */
    prototype.finish = function() {
        this.writeBuf.flip();
        this.out.write(this.writeBuf);
    };
    prototype.writePacket = function(writeBuf, pkt) {
        var pktType = pkt.getType() == FLVTag.Type.VIDEO ? 9 : (pkt.getType() == FLVTag.Type.SCRIPT ? 18 : 8);
        var dataLen = pkt.getData().remaining();
        if (writeBuf.remaining() < 15 + dataLen) 
            return false;
        writeBuf.putInt(writeBuf.position() - this.startOfLastPacket);
        this.startOfLastPacket = writeBuf.position();
        writeBuf.put((pktType << 24 >> 24));
        writeBuf.putShort((((dataLen >> 8)) << 16 >> 16));
        writeBuf.put(((dataLen & 255) << 24 >> 24));
        writeBuf.putShort(((((pkt.getPts() >> 8) & 65535)) << 16 >> 16));
        writeBuf.put(((pkt.getPts() & 255) << 24 >> 24));
        writeBuf.put((((pkt.getPts() >> 24) & 255) << 24 >> 24));
        writeBuf.putShort(((0) << 16 >> 16));
        writeBuf.put((0 << 24 >> 24));
        NIOUtils.write(writeBuf, pkt.getData().duplicate());
        return true;
    };
    constructor.writeHeader = function(writeBuf) {
        writeBuf.put(('F'.charCodeAt(0) << 24 >> 24));
        writeBuf.put(('L'.charCodeAt(0) << 24 >> 24));
        writeBuf.put(('V'.charCodeAt(0) << 24 >> 24));
        writeBuf.put((1 << 24 >> 24));
        writeBuf.put((5 << 24 >> 24));
        writeBuf.putInt(9);
    };
}, {out: "SeekableByteChannel", writeBuf: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IOUtils = function() {};
IOUtils = stjs.extend(IOUtils, null, [], function(constructor, prototype) {
    constructor.DEFAULT_BUFFER_SIZE = 4096;
    constructor.closeQuietly = function(c) {
        if (c == null) 
            return;
        try {
            c.close();
        }catch (e) {}
    };
    constructor.toByteArray = function(input) {
        var output = new ByteArrayOutputStream();
        IOUtils.copy(input, output);
        return output.toByteArray();
    };
    constructor.copy = function(input, output) {
        var buffer = new Int8Array(IOUtils.DEFAULT_BUFFER_SIZE);
        var count = 0;
        var n = 0;
         while (-1 != (n = input.read(buffer))){
            output.write(buffer, 0, n);
            count += n;
        }
        return count;
    };
    constructor.copyDumb = function(input, output) {
        var count = 0;
        var n = 0;
         while (-1 != (n = input.read())){
            output.write(n);
            count++;
        }
        return count;
    };
    constructor.readFileToByteArray = function(file) {
        return NIOUtils.toArray(NIOUtils.fetchFromFile(file));
    };
    constructor.readToString = function(is) {
        return Platform.stringFromBytes(IOUtils.toByteArray(is));
    };
    constructor.writeStringToFile = function(file, str) {
        NIOUtils.writeTo(ByteBuffer.wrap(str.getBytes()), file);
    };
    constructor.forceMkdir = function(directory) {
        if (directory.exists()) {
            if (!directory.isDirectory()) {
                var message = "File " + directory + " exists and is not a directory. Unable to create directory.";
                 throw new IOException(message);
            }
        } else {
            if (!directory.mkdirs()) {
                if (!directory.isDirectory()) {
                    var message = "Unable to create directory " + directory;
                     throw new IOException(message);
                }
            }
        }
    };
    constructor.copyFile = function(src, dst) {
        var _in = null;
        var out = null;
        try {
            _in = NIOUtils.readableChannel(src);
            out = NIOUtils.writableChannel(dst);
            NIOUtils.copy(_in, out, Long.MAX_VALUE);
        } finally {
            NIOUtils.closeQuietly(_in);
            NIOUtils.closeQuietly(out);
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Simplistic PNG encoder, doesn't support anything.
 *  
 *  @author Stanislav Vitvitskyy
 *  
 */
var PNGEncoder = function() {
    VideoEncoder.call(this);
};
PNGEncoder = stjs.extend(PNGEncoder, VideoEncoder, [], function(constructor, prototype) {
    constructor.PNGSIG = -8552249625308161526;
    constructor.TAG_IHDR = 1229472850;
    constructor.TAG_IDAT = 1229209940;
    constructor.TAG_IEND = 1229278788;
    constructor.IHDR = function() {};
    constructor.IHDR = stjs.extend(constructor.IHDR, null, [], function(constructor, prototype) {
        prototype.width = 0;
        prototype.height = 0;
        prototype.bitDepth = 0;
        prototype.colorType = 0;
        prototype.compressionType = 0;
        prototype.filterType = 0;
        prototype.interlaceType = 0;
        prototype.write = function(data) {
            data.putInt(this.width);
            data.putInt(this.height);
            data.put(this.bitDepth);
            data.put(this.colorType);
            data.put(this.compressionType);
            data.put(this.filterType);
            data.put(this.interlaceType);
        };
    }, {}, {});
    constructor.crc32 = function(from, to) {
        from.setLimit(to.position());
        var crc32 = new CRC32();
        crc32.updateB(NIOUtils.toArray(from));
        return ((crc32.getValue()) | 0);
    };
    constructor.PNG_COLOR_MASK_COLOR = 2;
    prototype.encodeFrame = function(pic, out) {
        var _out = out.duplicate();
        _out.putLong(PNGEncoder.PNGSIG);
        var ihdr = new PNGEncoder.IHDR();
        ihdr.width = pic.getCroppedWidth();
        ihdr.height = pic.getCroppedHeight();
        ihdr.bitDepth = 8;
        ihdr.colorType = PNGEncoder.PNG_COLOR_MASK_COLOR;
        _out.putInt(13);
        var crcFrom = _out.duplicate();
        _out.putInt(PNGEncoder.TAG_IHDR);
        ihdr.write(_out);
        _out.putInt(PNGEncoder.crc32(crcFrom, _out));
        var deflater = new Deflater();
        var rowData = new Int8Array(pic.getCroppedWidth() * 3 + 1);
        var pix = pic.getPlaneData(0);
        var buffer = new Int8Array(1 << 15);
        var ptr = 0, len = buffer.length;
        var lineStep = (pic.getWidth() - pic.getCroppedWidth()) * 3;
        for (var row = 0, bptr = 0; row < pic.getCroppedHeight() + 1; row++) {
            var count;
             while ((count = deflater.deflate3(buffer, ptr, len)) > 0){
                ptr += count;
                len -= count;
                if (len == 0) {
                    _out.putInt(ptr);
                    crcFrom = _out.duplicate();
                    _out.putInt(PNGEncoder.TAG_IDAT);
                    _out.put3(buffer, 0, ptr);
                    _out.putInt(PNGEncoder.crc32(crcFrom, _out));
                    ptr = 0;
                    len = buffer.length;
                }
            }
            if (row >= pic.getCroppedHeight()) 
                break;
            rowData[0] = 0;
            for (var i = 1; i <= pic.getCroppedWidth() * 3; i += 3 , bptr += 3) {
                rowData[i] = ((pix[bptr] + 128) << 24 >> 24);
                rowData[i + 1] = ((pix[bptr + 1] + 128) << 24 >> 24);
                rowData[i + 2] = ((pix[bptr + 2] + 128) << 24 >> 24);
            }
            bptr += lineStep;
            deflater.setInput(rowData);
            if (row >= pic.getCroppedHeight() - 1) 
                deflater.finish();
        }
        if (ptr > 0) {
            _out.putInt(ptr);
            crcFrom = _out.duplicate();
            _out.putInt(PNGEncoder.TAG_IDAT);
            _out.put3(buffer, 0, ptr);
            _out.putInt(PNGEncoder.crc32(crcFrom, _out));
        }
        _out.putInt(0);
        _out.putInt(PNGEncoder.TAG_IEND);
        _out.putInt(-1371381630);
        _out.flip();
        return new VideoEncoder.EncodedFrame(_out, true);
    };
    prototype.getSupportedColorSpaces = function() {
        return [ColorSpace.RGB];
    };
    prototype.estimateBufferSize = function(frame) {
        return frame.getCroppedWidth() * frame.getCroppedHeight() * 4;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var BER = function() {};
BER = stjs.extend(BER, null, [], function(constructor, prototype) {
    constructor.ASN_LONG_LEN = (128 << 24 >> 24);
    constructor.decodeLength = function(is) {
        var length = 0;
        var lengthbyte = NIOUtils.readByte(is) & 255;
        if ((lengthbyte & BER.ASN_LONG_LEN) > 0) {
            lengthbyte &= ~BER.ASN_LONG_LEN;
            if (lengthbyte == 0) 
                 throw new IOException("Indefinite lengths are not supported");
            if (lengthbyte > 8) 
                 throw new IOException("Data length > 4 bytes are not supported!");
            var bb = NIOUtils.readNByte(is, lengthbyte);
            for (var i = 0; i < lengthbyte; i++) 
                length = (length << 8) | (bb[i] & 255);
            if (length < 0) 
                 throw new IOException("mxflib does not support data lengths > 2^63");
        } else {
            length = lengthbyte & 255;
        }
        return length;
    };
    constructor.decodeLengthBuf = function(buffer) {
        var length = 0;
        var lengthbyte = buffer.get() & 255;
        if ((lengthbyte & BER.ASN_LONG_LEN) > 0) {
            lengthbyte &= ~BER.ASN_LONG_LEN;
            if (lengthbyte == 0) 
                 throw new RuntimeException("Indefinite lengths are not supported");
            if (lengthbyte > 8) 
                 throw new RuntimeException("Data length > 8 bytes are not supported!");
            for (var i = 0; i < lengthbyte; i++) 
                length = (length << 8) | (buffer.get() & 255);
            if (length < 0) 
                 throw new RuntimeException("mxflib does not support data lengths > 2^63");
        } else {
            length = lengthbyte & 255;
        }
        return length;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var DeltaEntries = function(posTabIdx, slice, elementDelta) {
    this.posTabIdx = posTabIdx;
    this.slice = slice;
    this.elementData = elementDelta;
};
DeltaEntries = stjs.extend(DeltaEntries, null, [], function(constructor, prototype) {
    prototype.posTabIdx = null;
    prototype.slice = null;
    prototype.elementData = null;
    constructor.read = function(bb) {
        bb.order(ByteOrder.BIG_ENDIAN);
        var n = bb.getInt();
        var len = bb.getInt();
        var posTabIdx = new Int8Array(n);
        var slice = new Int8Array(n);
        var elementDelta = new Int32Array(n);
        for (var i = 0; i < n; i++) {
            posTabIdx[i] = bb.get();
            slice[i] = bb.get();
            elementDelta[i] = bb.getInt();
            NIOUtils.skip(bb, len - 6);
        }
        return new DeltaEntries(posTabIdx, slice, elementDelta);
    };
}, {posTabIdx: "Int8Array", slice: "Int8Array", elementData: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Implements a seekable byte channel that wraps a byte buffer
 *  
 *  @author The JCodec project
 *  
 */
var ByteBufferSeekableByteChannel = function(backing, contentLength) {
    this.backing = backing;
    this.contentLength = contentLength;
    this.open = true;
};
ByteBufferSeekableByteChannel = stjs.extend(ByteBufferSeekableByteChannel, null, [SeekableByteChannel], function(constructor, prototype) {
    prototype.backing = null;
    prototype.open = false;
    prototype.contentLength = 0;
    constructor.writeToByteBuffer = function(buf) {
        return new ByteBufferSeekableByteChannel(buf, 0);
    };
    constructor.readFromByteBuffer = function(buf) {
        return new ByteBufferSeekableByteChannel(buf, buf.remaining());
    };
    prototype.isOpen = function() {
        return this.open;
    };
    prototype.close = function() {
        this.open = false;
    };
    prototype.read = function(dst) {
        if (!this.backing.hasRemaining() || this.contentLength <= 0) {
            return -1;
        }
        var toRead = Math.min(this.backing.remaining(), dst.remaining());
        toRead = Math.min(toRead, this.contentLength);
        dst.putBuf(NIOUtils.read(this.backing, toRead));
        this.contentLength = Math.max(this.contentLength, this.backing.position());
        return toRead;
    };
    prototype.write = function(src) {
        var toWrite = Math.min(this.backing.remaining(), src.remaining());
        this.backing.putBuf(NIOUtils.read(src, toWrite));
        this.contentLength = Math.max(this.contentLength, this.backing.position());
        return toWrite;
    };
    prototype.position = function() {
        return this.backing.position();
    };
    prototype.setPosition = function(newPosition) {
        this.backing.setPosition(((newPosition) | 0));
        this.contentLength = Math.max(this.contentLength, this.backing.position());
        return this;
    };
    prototype.size = function() {
        return this.contentLength;
    };
    prototype.truncate = function(size) {
        this.contentLength = ((size) | 0);
        return this;
    };
    prototype.getContents = function() {
        var contents = this.backing.duplicate();
        contents.setPosition(0);
        contents.setLimit(this.contentLength);
        return contents;
    };
}, {backing: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IVFMuxer = function(ch) {
    this.ch = ch;
};
IVFMuxer = stjs.extend(IVFMuxer, null, [Muxer, MuxerTrack], function(constructor, prototype) {
    prototype.ch = null;
    prototype.nFrames = 0;
    prototype.dim = null;
    prototype.frameRate = 0;
    prototype.headerWritten = false;
    prototype.addFrame = function(pkt) {
        if (!this.headerWritten) {
            this.frameRate = pkt.getTimescale();
            this.writeHeader();
            this.headerWritten = true;
        }
        var fh = ByteBuffer.allocate(12);
        fh.order(ByteOrder.LITTLE_ENDIAN);
        var frame = pkt.getData();
        fh.putInt(frame.remaining());
        fh.putLong(this.nFrames);
        fh.clear();
        this.ch.write(fh);
        this.ch.write(frame);
        this.nFrames++;
    };
    prototype.close = function() {
        this.ch.setPosition(24);
        NIOUtils.writeIntLE(this.ch, this.nFrames);
    };
    prototype.addVideoTrack = function(codec, meta) {
        if (this.dim != null) 
             throw new RuntimeException("IVF can not have multiple video tracks.");
        this.dim = meta.getSize();
        return this;
    };
    prototype.writeHeader = function() {
        var ivf = ByteBuffer.allocate(32);
        ivf.order(ByteOrder.LITTLE_ENDIAN);
        ivf.put(('D'.charCodeAt(0) << 24 >> 24));
        ivf.put(('K'.charCodeAt(0) << 24 >> 24));
        ivf.put(('I'.charCodeAt(0) << 24 >> 24));
        ivf.put(('F'.charCodeAt(0) << 24 >> 24));
        ivf.putShort(((0) << 16 >> 16));
        ivf.putShort(((32) << 16 >> 16));
        ivf.putInt(808996950);
        ivf.putShort(((this.dim.getWidth()) << 16 >> 16));
        ivf.putShort(((this.dim.getHeight()) << 16 >> 16));
        ivf.putInt(this.frameRate);
        ivf.putInt(1);
        ivf.putInt(1);
        ivf.clear();
        this.ch.write(ivf);
    };
    prototype.addAudioTrack = function(codec, meta) {
         throw new RuntimeException("Video-only container");
    };
    prototype.finish = function() {};
}, {ch: "SeekableByteChannel", dim: "Size"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var NALUnitWriter = function(to) {
    this.to = to;
};
NALUnitWriter = stjs.extend(NALUnitWriter, null, [], function(constructor, prototype) {
    prototype.to = null;
    constructor._MARKER = ByteBuffer.allocate(4);
    prototype.writeUnit = function(nal, data) {
        var emprev = ByteBuffer.allocate(data.remaining() + 1024);
        NIOUtils.write(emprev, NALUnitWriter._MARKER);
        nal.write(emprev);
        this.emprev(emprev, data);
        emprev.flip();
        this.to.write(emprev);
    };
    prototype.emprev = function(emprev, data) {
        var dd = data.duplicate();
        var prev1 = 1, prev2 = 1;
         while (dd.hasRemaining()){
            var b = dd.get();
            if (prev1 == 0 && prev2 == 0 && ((b & 3) == b)) {
                prev2 = prev1;
                prev1 = 3;
                emprev.put((3 << 24 >> 24));
            }
            prev2 = prev1;
            prev1 = b;
            emprev.put(stjs.trunc(b));
        }
    };
}, {to: "WritableByteChannel", _MARKER: "ByteBuffer"}, {});
(function() {
    NALUnitWriter._MARKER.putInt(1);
    NALUnitWriter._MARKER.flip();
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Descriptor = function(tag, size) {
    this._tag = tag;
    this.size = size;
};
Descriptor = stjs.extend(Descriptor, null, [], function(constructor, prototype) {
    prototype._tag = 0;
    prototype.size = 0;
    prototype.write = function(out) {
        var fork = out.duplicate();
        NIOUtils.skip(out, 5);
        this.doWrite(out);
        var length = out.position() - fork.position() - 5;
        fork.put((this._tag << 24 >> 24));
        JCodecUtil2.writeBER32(fork, length);
    };
    prototype.doWrite = function(out) {};
    prototype.getTag = function() {
        return this._tag;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var DecodingContext = function() {
    this.refFrameWidth = new Int32Array(Consts.MAX_REF_FRAMES);
    this.refFrameHeight = new Int32Array(Consts.MAX_REF_FRAMES);
    this.refFrameIdx = new Int32Array(3);
    this._refFrameSignBias = new Int32Array(3);
    this.loopFilterRefDeltas = new Int32Array(4);
    this.loopFilterModeDeltas = new Int32Array(2);
    this.segmentationTreeProbs = new Int32Array(7);
    this.segmentationPredProb = new Int32Array(3);
    this.featureEnabled = Array.apply(null, Array(Consts.MAX_SEGMENTS)).map(function() {
        return new Int32Array(Consts.SEG_LVL_MAX);
    });
    this.featureData = Array.apply(null, Array(Consts.MAX_SEGMENTS)).map(function() {
        return new Int32Array(Consts.SEG_LVL_MAX);
    });
    this.txProbs8x8 = Array.apply(null, Array(Consts.TX_SIZE_CONTEXTS)).map(function() {
        return new Int32Array(Consts.TX_SIZES - 3);
    });
    this.txProbs16x16 = Array.apply(null, Array(Consts.TX_SIZE_CONTEXTS)).map(function() {
        return new Int32Array(Consts.TX_SIZES - 2);
    });
    this.txProbs32x32 = Array.apply(null, Array(Consts.TX_SIZE_CONTEXTS)).map(function() {
        return new Int32Array(Consts.TX_SIZES - 1);
    });
    this.skipProb = new Int32Array(Consts.SKIP_CONTEXTS);
    this.interModeProbs = Array.apply(null, Array(Consts.INTER_MODE_CONTEXTS)).map(function() {
        return new Int32Array(Consts.INTER_MODES - 1);
    });
    this.interpFilterProbs = Array.apply(null, Array(Consts.INTERP_FILTER_CONTEXTS)).map(function() {
        return new Int32Array(Consts.SWITCHABLE_FILTERS - 1);
    });
    this.isInterProb = new Int32Array(Consts.IS_INTER_CONTEXTS);
    this.compModeProb = new Int32Array(Consts.COMP_MODE_CONTEXTS);
    this.singleRefProb = Array.apply(null, Array(Consts.REF_CONTEXTS)).map(function() {
        return new Int32Array(2);
    });
    this.compRefProb = new Int32Array(Consts.REF_CONTEXTS);
    this.yModeProbs = Array.apply(null, Array(Consts.BLOCK_SIZE_GROUPS)).map(function() {
        return new Int32Array(Consts.INTRA_MODES - 1);
    });
    this.partitionProbs = Array.apply(null, Array(Consts.PARTITION_CONTEXTS)).map(function() {
        return new Int32Array(Consts.PARTITION_TYPES - 1);
    });
    this.mvJointProbs = new Int32Array(Consts.MV_JOINTS - 1);
    this.mvSignProb = new Int32Array(2);
    this.mvClassProbs = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(Consts.MV_CLASSES - 1);
    });
    this.mvClass0BitProb = new Int32Array(2);
    this.mvBitsProb = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(Consts.MV_OFFSET_BITS);
    });
    this.mvClass0FrProbs = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(Consts.CLASS0_SIZE)).map(function() {
            return new Int32Array(Consts.MV_FR_SIZE - 1);
        });
    });
    this.mvFrProbs = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(Consts.MV_FR_SIZE - 1);
    });
    this.mvClass0HpProb = new Int32Array(2);
    this.mvHpProb = new Int32Array(2);
};
DecodingContext = stjs.extend(DecodingContext, null, [], function(constructor, prototype) {
    prototype.profile = 0;
    prototype.showExistingFrame = 0;
    prototype.frameToShowMapIdx = 0;
    prototype.frameType = 0;
    prototype.showFrame = 0;
    prototype.errorResilientMode = 0;
    prototype.refreshFrameFlags = 0;
    prototype.frameIsIntra = 0;
    prototype.intraOnly = 0;
    prototype.resetFrameContext = 0;
    prototype.subsamplingX = 0;
    prototype.colorSpace = 0;
    prototype.subsamplingY = 0;
    prototype.bitDepth = 0;
    prototype.frameWidth = 0;
    prototype.frameHeight = 0;
    prototype.renderWidth = 0;
    prototype.renderHeight = 0;
    prototype.refFrameWidth = null;
    prototype.refFrameHeight = null;
    prototype.refFrameIdx = null;
    prototype._refFrameSignBias = null;
    prototype.allowHighPrecisionMv = 0;
    prototype.interpolationFilter = 0;
    prototype.frameParallelDecodingMode = 0;
    prototype.refreshFrameContext = 0;
    prototype.frameContextIdx = 0;
    prototype.loopFilterRefDeltas = null;
    prototype.loopFilterModeDeltas = null;
    prototype.baseQIdx = 0;
    prototype.deltaQYDc = 0;
    prototype.deltaQUvDc = 0;
    prototype.deltaQUvAc = 0;
    prototype.lossless = false;
    prototype.segmentationEnabled = 0;
    prototype.segmentationTreeProbs = null;
    prototype.segmentationPredProb = null;
    prototype.featureEnabled = null;
    prototype.featureData = null;
    prototype.miCols = 0;
    prototype.miRows = 0;
    prototype.sb64Cols = 0;
    prototype.sb64Rows = 0;
    prototype.tileRowsLog2 = 0;
    prototype.tileColsLog2 = 0;
    prototype.txMode = 0;
    prototype.compFixedRef = 0;
    prototype.compVarRef0 = 0;
    prototype.compVarRef1 = 0;
    prototype.txProbs8x8 = null;
    prototype.txProbs16x16 = null;
    prototype.txProbs32x32 = null;
    prototype.referenceMode = 0;
    prototype.coefProbs = null;
    prototype.skipProb = null;
    prototype.interModeProbs = null;
    prototype.interpFilterProbs = null;
    prototype.isInterProb = null;
    prototype.compModeProb = null;
    prototype.singleRefProb = null;
    prototype.compRefProb = null;
    prototype.yModeProbs = null;
    prototype.partitionProbs = null;
    prototype.mvJointProbs = null;
    prototype.mvSignProb = null;
    prototype.mvClassProbs = null;
    prototype.mvClass0BitProb = null;
    prototype.mvBitsProb = null;
    prototype.mvClass0FrProbs = null;
    prototype.mvFrProbs = null;
    prototype.mvClass0HpProb = null;
    prototype.mvHpProb = null;
    /**
     *  Reads VP9 frame headers and creates the decoding context
     *  
     *  @param bb
     *             ByteBuffer with the encoded frame, after the call to this
     *             function the header portion of this buffer will be read and
     *             the byte buffer will be pointing at the first compressed frame
     *             byte after the headers.
     *  @return Initialized DecodingContext object that can be used for decoding
     *          the compressed VP9 frame.
     */
    constructor.createFromHeaders = function(bb) {
        var dc = new DecodingContext();
        dc.readHeaders(bb);
        return dc;
    };
    prototype.isKeyIntraFrame = function() {
        return false;
    };
    prototype.isSegmentationEnabled = function() {
        return false;
    };
    prototype.isUpdateSegmentMap = function() {
        return false;
    };
    prototype.isSegmentFeatureActive = function(segmentId, segLvlSkip) {
        return false;
    };
    prototype.isSegmentMapConditionalUpdate = function() {
        return false;
    };
    prototype.getSegmentFeature = function(segmentId, segLvlRefFrame) {
        return 0;
    };
    prototype.getCompFixedRef = function() {
        return 0;
    };
    prototype.refFrameSignBias = function(fixedRef) {
        return 0;
    };
    prototype.getInterpFilter = function() {
        return 0;
    };
    prototype.getRefMode = function() {
        return 0;
    };
    prototype.getLeftMVs = function() {
        return null;
    };
    prototype.getAboveMVs = function() {
        return null;
    };
    prototype.getAboveLeftMVs = function() {
        return null;
    };
    prototype.getLeft4x4MVs = function() {
        return null;
    };
    prototype.getAbove4x4MVs = function() {
        return null;
    };
    prototype.getAboveCompound = function() {
        return null;
    };
    prototype.getLeftCompound = function() {
        return null;
    };
    prototype.getRefs = function() {
        return null;
    };
    prototype.isAllowHpMv = function() {
        return false;
    };
    prototype.isUsePrevFrameMvs = function() {
        return false;
    };
    prototype.getPrevFrameMv = function() {
        return null;
    };
    prototype.getMiFrameHeight = function() {
        return 0;
    };
    prototype.getMiFrameWidth = function() {
        return 0;
    };
    prototype.getTileStart = function() {
        return 0;
    };
    prototype.getLeftInterpFilters = function() {
        return null;
    };
    prototype.getAboveInterpFilters = function() {
        return null;
    };
    prototype.getLeftLumaModes = function() {
        return null;
    };
    prototype.getAboveLumaModes = function() {
        return null;
    };
    prototype.getTileHeight = function() {
        return 0;
    };
    prototype.getTileWidth = function() {
        return 0;
    };
    prototype.getCompVarRef = function(i) {
        return 0;
    };
    prototype.getAboveIntraModes = function() {
        return null;
    };
    prototype.getLeftIntraModes = function() {
        return null;
    };
    prototype.getTxMode = function() {
        return 0;
    };
    prototype.getTxSizes = function() {
        return null;
    };
    prototype.getSkippedBlockes = function() {
        return null;
    };
    prototype.getAboveSegIdPredicted = function() {
        return null;
    };
    prototype.getLeftSegIdPredicted = function() {
        return null;
    };
    prototype.getPrevSegmentIds = function() {
        return null;
    };
    prototype.getSubX = function() {
        return 0;
    };
    prototype.getSubY = function() {
        return 0;
    };
    prototype.getScan = function(plane, txSz, blockIdx) {
        return null;
    };
    prototype.getTxType = function(plane, txSz, blockIdx) {
        return 0;
    };
    prototype.getBitDepth = function() {
        return 0;
    };
    prototype.getAboveNonzeroContext = function() {
        return null;
    };
    prototype.getLeftNonzeroContext = function() {
        return null;
    };
    prototype.getTokenCache = function() {
        return null;
    };
    prototype.getLeftPartitionSizes = function() {
        return null;
    };
    prototype.getAbovePartitionSizes = function() {
        return null;
    };
    prototype.readHeaders = function(bb) {
        var br = BitReader.createBitReader(bb);
        var frame_marker = br.readNBit(2);
        this.profile = br.read1Bit() | (br.read1Bit() << 1);
        if (this.profile == 3) 
            br.read1Bit();
        this.showExistingFrame = br.read1Bit();
        if (this.showExistingFrame == 1) {
            this.frameToShowMapIdx = br.readNBit(3);
        }
        this.frameType = br.read1Bit();
        this.showFrame = br.read1Bit();
        this.errorResilientMode = br.read1Bit();
        if (this.frameType == Consts.KEY_FRAME) {
            DecodingContext.frame_sync_code(br);
            this.readColorConfig(br);
            this.readFrameSize(br);
            this.readRenderSize(br);
            this.refreshFrameFlags = 255;
            this.frameIsIntra = 1;
        } else {
            this.intraOnly = 0;
            if (this.showFrame == 0) {
                this.intraOnly = br.read1Bit();
            }
            this.resetFrameContext = 0;
            if (this.errorResilientMode == 0) {
                this.resetFrameContext = br.readNBit(2);
            }
            if (this.intraOnly == 1) {
                DecodingContext.frame_sync_code(br);
                if (this.profile > 0) {
                    this.readColorConfig(br);
                } else {
                    this.colorSpace = Consts.CS_BT_601;
                    this.subsamplingX = 1;
                    this.subsamplingY = 1;
                    this.bitDepth = 8;
                }
                this.refreshFrameFlags = br.readNBit(8);
                this.readFrameSize(br);
                this.readRenderSize(br);
            } else {
                var refreshFrameFlags = br.readNBit(8);
                for (var i = 0; i < 3; i++) {
                    this.refFrameIdx[i] = br.readNBit(3);
                    this._refFrameSignBias[Consts.LAST_FRAME + i] = br.read1Bit();
                }
                this.readFrameSizeWithRefs(br);
                this.allowHighPrecisionMv = br.read1Bit();
                this.readInterpolationFilter(br);
            }
        }
        this.refreshFrameContext = 0;
        if (this.errorResilientMode == 0) {
            this.refreshFrameContext = br.read1Bit();
            this.frameParallelDecodingMode = br.read1Bit();
        }
        this.frameContextIdx = br.readNBit(2);
        this.readLoopFilterParams(br);
        this.readQuantizationParams(br);
        this.readSegmentationParams(br);
        this.readTileInfo(br);
        var headerSizeInBytes = br.readNBit(16);
        br.terminate();
        var compressedHeader = NIOUtils.read(bb, headerSizeInBytes);
        var boolDec = new VPXBooleanDecoder(compressedHeader, 0);
        this.readCompressedHeader(boolDec);
    };
    prototype.computeImageSize = function() {
        this.miCols = (this.frameWidth + 7) >> 3;
        this.miRows = (this.frameHeight + 7) >> 3;
        this.sb64Cols = (this.miCols + 7) >> 3;
        this.sb64Rows = (this.miRows + 7) >> 3;
    };
    prototype.calc_min_log2_tile_cols = function() {
        var minLog2 = 0;
         while ((Consts.MAX_TILE_WIDTH_B64 << minLog2) < this.sb64Cols)
            minLog2++;
        return minLog2;
    };
    prototype.calc_max_log2_tile_cols = function() {
        var maxLog2 = 1;
         while ((this.sb64Cols >> maxLog2) >= Consts.MIN_TILE_WIDTH_B64)
            maxLog2++;
        return maxLog2 - 1;
    };
    prototype.readTileInfo = function(br) {
        var minLog2TileCols = this.calc_min_log2_tile_cols();
        var maxLog2TileCols = this.calc_max_log2_tile_cols();
        this.tileColsLog2 = minLog2TileCols;
         while (this.tileColsLog2 < maxLog2TileCols){
            var increment_tile_cols_log2 = br.read1Bit();
            if (increment_tile_cols_log2 == 1) 
                this.tileColsLog2++;
             else 
                break;
        }
        this.tileRowsLog2 = br.read1Bit();
        if (this.tileRowsLog2 == 1) {
            var increment_tile_rows_log2 = br.read1Bit();
            this.tileRowsLog2 += increment_tile_rows_log2;
        }
    };
    constructor.readProb = function(br) {
        if (br.read1Bit() == 1) {
            return br.readNBit(8);
        } else {
            return 255;
        }
    };
    prototype.readSegmentationParams = function(br) {
        this.segmentationEnabled = br.read1Bit();
        if (this.segmentationEnabled == 1) {
            if (br.read1Bit() == 1) {
                for (var i = 0; i < 7; i++) 
                    this.segmentationTreeProbs[i] = DecodingContext.readProb(br);
                var segmentationTemporalUpdate = br.read1Bit();
                for (var i = 0; i < 3; i++) 
                    this.segmentationPredProb[i] = segmentationTemporalUpdate == 1 ? DecodingContext.readProb(br) : 255;
            }
            if (br.read1Bit() == 1) {
                var segmentationAbsOrDeltaUpdate = br.read1Bit();
                for (var i = 0; i < Consts.MAX_SEGMENTS; i++) {
                    for (var j = 0; j < Consts.SEG_LVL_MAX; j++) {
                        if (br.read1Bit() == 1) {
                            this.featureEnabled[i][j] = 1;
                            var bits_to_read = Consts.SEGMENTATION_FEATURE_BITS[j];
                            var value = br.readNBit(bits_to_read);
                            if (Consts.SEGMENTATION_FEATURE_SIGNED[j] == 1) {
                                if (br.read1Bit() == 1) 
                                    value *= -1;
                            }
                            this.featureData[i][j] = value;
                        }
                    }
                }
            }
        }
    };
    constructor.readDeltaQ = function(br) {
        var delta_coded = br.read1Bit();
        if (delta_coded == 1) {
            return br.readNBitSigned(5);
        } else {
            return 0;
        }
    };
    prototype.readQuantizationParams = function(br) {
        this.baseQIdx = br.readNBit(8);
        this.deltaQYDc = DecodingContext.readDeltaQ(br);
        this.deltaQUvDc = DecodingContext.readDeltaQ(br);
        this.deltaQUvAc = DecodingContext.readDeltaQ(br);
        this.lossless = this.baseQIdx == 0 && this.deltaQYDc == 0 && this.deltaQUvDc == 0 && this.deltaQUvAc == 0;
    };
    prototype.readLoopFilterParams = function(br) {
        var loopFilterLevel = br.readNBit(6);
        var loopFilterSharpness = br.readNBit(3);
        if (br.read1Bit() == 1) {
            if (br.read1Bit() == 1) {
                for (var i = 0; i < 4; i++) {
                    if (br.read1Bit() == 1) 
                        this.loopFilterRefDeltas[i] = br.readNBit(6);
                }
                for (var i = 0; i < 2; i++) {
                    if (br.read1Bit() == 1) 
                        this.loopFilterModeDeltas[i] = br.readNBit(6);
                }
            }
        }
    };
    prototype.readInterpolationFilter = function(br) {
        this.interpolationFilter = Consts.SWITCHABLE;
        if (br.read1Bit() == 0) {
            this.interpolationFilter = Consts.LITERAL_TO_FILTER_TYPE[br.readNBit(2)];
        }
    };
    prototype.readFrameSizeWithRefs = function(br) {
        var i;
        for (i = 0; i < 3; i++) {
            if (br.read1Bit() == 1) {
                this.frameWidth = this.refFrameWidth[this.refFrameIdx[i]];
                this.frameHeight = this.refFrameHeight[this.refFrameIdx[i]];
                break;
            }
        }
        if (i == 3) {
            this.readFrameSize(br);
        } else {
            this.computeImageSize();
        }
        this.readRenderSize(br);
    };
    prototype.readRenderSize = function(br) {
        if (br.read1Bit() == 1) {
            this.renderWidth = br.readNBit(16) + 1;
            this.renderHeight = br.readNBit(16) + 1;
        } else {
            this.renderWidth = this.frameWidth;
            this.renderHeight = this.frameHeight;
        }
    };
    prototype.readFrameSize = function(br) {
        this.frameWidth = br.readNBit(16) + 1;
        this.frameHeight = br.readNBit(16) + 1;
        this.computeImageSize();
    };
    prototype.readColorConfig = function(br) {
        if (this.profile >= 2) {
            var ten_or_twelve_bit = br.read1Bit();
            this.bitDepth = ten_or_twelve_bit == 1 ? 12 : 10;
        } else {
            this.bitDepth = 8;
        }
        var colorSpace = br.readNBit(3);
        if (colorSpace != Consts.CS_RGB) {
            var color_range = br.read1Bit();
            if (this.profile == 1 || this.profile == 3) {
                this.subsamplingX = br.read1Bit();
                this.subsamplingY = br.read1Bit();
                var reserved_zero = br.read1Bit();
            } else {
                this.subsamplingX = 1;
                this.subsamplingY = 1;
            }
        } else {
            var colorRange = 1;
            if (this.profile == 1 || this.profile == 3) {
                this.subsamplingX = 0;
                this.subsamplingY = 0;
                var reserved_zero = br.read1Bit();
            }
        }
    };
    constructor.frame_sync_code = function(br) {
        var code = br.readNBit(24);
    };
    prototype.readCompressedHeader = function(boolDec) {
        var maxTxSize = Consts.tx_mode_to_biggest_tx_size[this.txMode];
        this.coefProbs = Array.apply(null, Array(maxTxSize + 1)).map(function() {
            return Array.apply(null, Array(2)).map(function() {
                return Array.apply(null, Array(2)).map(function() {
                    return Array.apply(null, Array(6)).map(function() {
                        return Array.apply(null, Array(6)).map(function() {
                            return new Int32Array(3);
                        });
                    });
                });
            });
        });
        this.readTxMode(boolDec);
        if (this.txMode == Consts.TX_MODE_SELECT) {
            this.readTxModeProbs(boolDec);
        }
        this.readCoefProbs(boolDec);
        this.readSkipProb(boolDec);
        if (this.frameIsIntra == 0) {
            this.readInterModeProbs(boolDec);
            if (this.interpolationFilter == Consts.SWITCHABLE) 
                this.readInterpFilterProbs(boolDec);
            this.readIsInterProbs(boolDec);
            this.frameReferenceMode(boolDec);
            this.frameReferenceModeProbs(boolDec);
            this.readYModeProbs(boolDec);
            this.readPartitionProbs(boolDec);
            this.mvProbs(boolDec);
        }
    };
    prototype.readTxMode = function(boolDec) {
        if (this.lossless) {
            this.txMode = Consts.ONLY_4X4;
        } else {
            var txMode = boolDec.decodeInt(2);
            if (txMode == Consts.ALLOW_32X32) {
                txMode += boolDec.decodeInt(1);
            }
        }
    };
    prototype.readTxModeProbs = function(boolDec) {
        for (var i = 0; i < Consts.TX_SIZE_CONTEXTS; i++) 
            for (var j = 0; j < Consts.TX_SIZES - 3; j++) 
                this.txProbs8x8[i][j] = this.diffUpdateProb(boolDec, this.txProbs8x8[i][j]);
        for (var i = 0; i < Consts.TX_SIZE_CONTEXTS; i++) 
            for (var j = 0; j < Consts.TX_SIZES - 2; j++) 
                this.txProbs16x16[i][j] = this.diffUpdateProb(boolDec, this.txProbs16x16[i][j]);
        for (var i = 0; i < Consts.TX_SIZE_CONTEXTS; i++) 
            for (var j = 0; j < Consts.TX_SIZES - 1; j++) 
                this.txProbs32x32[i][j] = this.diffUpdateProb(boolDec, this.txProbs32x32[i][j]);
    };
    prototype.diffUpdateProb = function(boolDec, prob) {
        var update_prob = boolDec.readBit(252);
        if (update_prob == 1) {
            var deltaProb = this.decodeTermSubexp(boolDec);
            prob = this.invRemapProb(deltaProb, prob);
        }
        return prob;
    };
    prototype.decodeTermSubexp = function(boolDec) {
        var bit = boolDec.readBitEq();
        if (bit == 0) {
            return boolDec.decodeInt(4);
        }
        bit = boolDec.readBitEq();
        if (bit == 0) {
            return boolDec.decodeInt(4) + 16;
        }
        bit = boolDec.readBitEq();
        if (bit == 0) {
            return boolDec.decodeInt(5) + 32;
        }
        var v = boolDec.decodeInt(7);
        if (v < 65) 
            return v + 64;
        bit = boolDec.readBitEq();
        return (v << 1) - 1 + bit;
    };
    prototype.invRemapProb = function(deltaProb, prob) {
        var m = prob;
        var v = deltaProb;
        v = Consts.INV_REMAP_TABLE[v];
        m--;
        if ((m << 1) <= 255) 
            m = 1 + this.invRecenterNonneg(v, m);
         else 
            m = 255 - this.invRecenterNonneg(v, 255 - 1 - m);
        return m;
    };
    prototype.invRecenterNonneg = function(v, m) {
        if (v > 2 * m) 
            return v;
        if ((v & 1) != 0) 
            return m - ((v + 1) >> 1);
        return m + (v >> 1);
    };
    prototype.readCoefProbs = function(boolDec) {
        var maxTxSize = Consts.tx_mode_to_biggest_tx_size[this.txMode];
        for (var txSz = Consts.TX_4X4; txSz <= maxTxSize; txSz++) {
            var update_probs = boolDec.readBitEq();
            if (update_probs == 1) 
                for (var i = 0; i < 2; i++) 
                    for (var j = 0; j < 2; j++) 
                        for (var k = 0; k < 6; k++) {
                            var maxL = (k == 0) ? 3 : 6;
                            for (var l = 0; l < maxL; l++) 
                                for (var m = 0; m < 3; m++) 
                                    this.coefProbs[txSz][i][j][k][l][m] = this.diffUpdateProb(boolDec, this.coefProbs[txSz][i][j][k][l][m]);
                        }
        }
    };
    prototype.readSkipProb = function(boolDec) {
        for (var i = 0; i < Consts.SKIP_CONTEXTS; i++) 
            this.skipProb[i] = this.diffUpdateProb(boolDec, this.skipProb[i]);
    };
    prototype.readInterModeProbs = function(boolDec) {
        for (var i = 0; i < Consts.INTER_MODE_CONTEXTS; i++) 
            for (var j = 0; j < Consts.INTER_MODES - 1; j++) 
                this.interModeProbs[i][j] = this.diffUpdateProb(boolDec, this.interModeProbs[i][j]);
    };
    prototype.readInterpFilterProbs = function(boolDec) {
        for (var j = 0; j < Consts.INTERP_FILTER_CONTEXTS; j++) 
            for (var i = 0; i < Consts.SWITCHABLE_FILTERS - 1; i++) 
                this.interpFilterProbs[j][i] = this.diffUpdateProb(boolDec, this.interpFilterProbs[j][i]);
    };
    prototype.readIsInterProbs = function(boolDec) {
        for (var i = 0; i < Consts.IS_INTER_CONTEXTS; i++) 
            this.isInterProb[i] = this.diffUpdateProb(boolDec, this.isInterProb[i]);
    };
    prototype.frameReferenceMode = function(boolDec) {
        var compoundReferenceAllowed = 0;
        for (var i = 1; i < Consts.REFS_PER_FRAME; i++) 
            if (this._refFrameSignBias[i + 1] != this._refFrameSignBias[1]) 
                compoundReferenceAllowed = 1;
        if (compoundReferenceAllowed == 1) {
            var non_single_reference = boolDec.readBitEq();
            if (non_single_reference == 0) {
                this.referenceMode = Consts.SINGLE_REF;
            } else {
                var reference_select = boolDec.readBitEq();
                if (reference_select == 0) 
                    this.referenceMode = Consts.COMPOUND_REF;
                 else 
                    this.referenceMode = Consts.REFERENCE_MODE_SELECT;
                this.setupCompoundReferenceMode();
            }
        } else {
            this.referenceMode = Consts.SINGLE_REF;
        }
    };
    prototype.frameReferenceModeProbs = function(boolDec) {
        if (this.referenceMode == Consts.REFERENCE_MODE_SELECT) {
            for (var i = 0; i < Consts.COMP_MODE_CONTEXTS; i++) 
                this.compModeProb[i] = this.diffUpdateProb(boolDec, this.compModeProb[i]);
        }
        if (this.referenceMode != Consts.COMPOUND_REF) {
            for (var i = 0; i < Consts.REF_CONTEXTS; i++) {
                this.singleRefProb[i][0] = this.diffUpdateProb(boolDec, this.singleRefProb[i][0]);
                this.singleRefProb[i][1] = this.diffUpdateProb(boolDec, this.singleRefProb[i][1]);
            }
        }
        if (this.referenceMode != Consts.SINGLE_REF) {
            for (var i = 0; i < Consts.REF_CONTEXTS; i++) 
                this.compRefProb[i] = this.diffUpdateProb(boolDec, this.compRefProb[i]);
        }
    };
    prototype.readYModeProbs = function(boolDec) {
        for (var i = 0; i < Consts.BLOCK_SIZE_GROUPS; i++) 
            for (var j = 0; j < Consts.INTRA_MODES - 1; j++) 
                this.yModeProbs[i][j] = this.diffUpdateProb(boolDec, this.yModeProbs[i][j]);
    };
    prototype.readPartitionProbs = function(boolDec) {
        for (var i = 0; i < Consts.PARTITION_CONTEXTS; i++) 
            for (var j = 0; j < Consts.PARTITION_TYPES - 1; j++) 
                this.partitionProbs[i][j] = this.diffUpdateProb(boolDec, this.partitionProbs[i][j]);
    };
    prototype.mvProbs = function(boolDec) {
        for (var j = 0; j < Consts.MV_JOINTS - 1; j++) 
            this.mvJointProbs[j] = this.updateMvProb(boolDec, this.mvJointProbs[j]);
        for (var i = 0; i < 2; i++) {
            this.mvSignProb[i] = this.updateMvProb(boolDec, this.mvSignProb[i]);
            for (var j = 0; j < Consts.MV_CLASSES - 1; j++) 
                this.mvClassProbs[i][j] = this.updateMvProb(boolDec, this.mvClassProbs[i][j]);
            this.mvClass0BitProb[i] = this.updateMvProb(boolDec, this.mvClass0BitProb[i]);
            for (var j = 0; j < Consts.MV_OFFSET_BITS; j++) 
                this.mvBitsProb[i][j] = this.updateMvProb(boolDec, this.mvBitsProb[i][j]);
        }
        for (var i = 0; i < 2; i++) {
            for (var j = 0; j < Consts.CLASS0_SIZE; j++) 
                for (var k = 0; k < Consts.MV_FR_SIZE - 1; k++) 
                    this.mvClass0FrProbs[i][j][k] = this.updateMvProb(boolDec, this.mvClass0FrProbs[i][j][k]);
            for (var k = 0; k < Consts.MV_FR_SIZE - 1; k++) 
                this.mvFrProbs[i][k] = this.updateMvProb(boolDec, this.mvFrProbs[i][k]);
        }
        if (this.allowHighPrecisionMv == 1) {
            for (var i = 0; i < 2; i++) {
                this.mvClass0HpProb[i] = this.updateMvProb(boolDec, this.mvClass0HpProb[i]);
                this.mvHpProb[i] = this.updateMvProb(boolDec, this.mvHpProb[i]);
            }
        }
    };
    prototype.updateMvProb = function(boolDec, prob) {
        var update_mv_prob = boolDec.readBit(252);
        if (update_mv_prob == 1) {
            var mv_prob = boolDec.decodeInt(7);
            prob = (mv_prob << 1) | 1;
        }
        return prob;
    };
    prototype.setupCompoundReferenceMode = function() {
        if (this._refFrameSignBias[Consts.LAST_FRAME] == this._refFrameSignBias[Consts.GOLDEN_FRAME]) {
            this.compFixedRef = Consts.ALTREF_FRAME;
            this.compVarRef0 = Consts.LAST_FRAME;
            this.compVarRef1 = Consts.GOLDEN_FRAME;
        } else if (this._refFrameSignBias[Consts.LAST_FRAME] == this._refFrameSignBias[Consts.ALTREF_FRAME]) {
            this.compFixedRef = Consts.GOLDEN_FRAME;
            this.compVarRef0 = Consts.LAST_FRAME;
            this.compVarRef1 = Consts.ALTREF_FRAME;
        } else {
            this.compFixedRef = Consts.LAST_FRAME;
            this.compVarRef0 = Consts.GOLDEN_FRAME;
            this.compVarRef1 = Consts.ALTREF_FRAME;
        }
    };
}, {refFrameWidth: "Int32Array", refFrameHeight: "Int32Array", refFrameIdx: "Int32Array", _refFrameSignBias: "Int32Array", loopFilterRefDeltas: "Int32Array", loopFilterModeDeltas: "Int32Array", segmentationTreeProbs: "Int32Array", segmentationPredProb: "Int32Array", featureEnabled: "Array", featureData: "Array", txProbs8x8: "Array", txProbs16x16: "Array", txProbs32x32: "Array", coefProbs: "Array", skipProb: "Int32Array", interModeProbs: "Array", interpFilterProbs: "Array", isInterProb: "Int32Array", compModeProb: "Int32Array", singleRefProb: "Array", compRefProb: "Int32Array", yModeProbs: "Array", partitionProbs: "Array", mvJointProbs: "Int32Array", mvSignProb: "Int32Array", mvClassProbs: "Array", mvClass0BitProb: "Int32Array", mvBitsProb: "Array", mvClass0FrProbs: "Array", mvFrProbs: "Array", mvClass0HpProb: "Int32Array", mvHpProb: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Pulls frames from MPEG elementary stream
 *  
 *  @author The JCodec project
 *  
 */
var SegmentReader = function(channel, fetchSize) {
    this.channel = channel;
    this.fetchSize = fetchSize;
    this.buf = NIOUtils.fetchFromChannel(channel, 4);
    this.pos = this.buf.remaining();
    this.curMarker = this.buf.getInt();
    this.bytesInMarker = 4;
};
SegmentReader = stjs.extend(SegmentReader, null, [], function(constructor, prototype) {
    prototype.channel = null;
    prototype.buf = null;
    prototype.curMarker = 0;
    prototype.fetchSize = 0;
    prototype.done = false;
    prototype.pos = 0;
    prototype.bytesInMarker = 0;
    prototype.bufferIncrement = 32768;
    prototype.getBufferIncrement = function() {
        return this.bufferIncrement;
    };
    prototype.setBufferIncrement = function(bufferIncrement) {
        this.bufferIncrement = bufferIncrement;
    };
    constructor.State = stjs.enumeration("MORE_DATA", "DONE", "STOP");
    /**
     *  Reads one full segment till the next marker. Will read as much data as
     *  the provided buffer fits, if the provided buffer doesn't fit all data
     *  will return MORE_DATA.
     *  
     *  @param out
     *  @return
     *  @throws IOException
     */
    prototype.readToNextMarkerPartial = function(out) {
        if (this.done) 
            return SegmentReader.State.STOP;
        var skipOneMarker = this.curMarker >= 256 && this.curMarker <= 511 ? 1 : 0;
        var written = out.position();
        do {
             while (this.buf.hasRemaining()){
                if (this.curMarker >= 256 && this.curMarker <= 511) {
                    if (skipOneMarker == 0) {
                        return SegmentReader.State.DONE;
                    }
                    --skipOneMarker;
                }
                if (!out.hasRemaining()) 
                    return SegmentReader.State.MORE_DATA;
                out.put(((this.curMarker >>> 24) << 24 >> 24));
                this.curMarker = (this.curMarker << 8) | (this.buf.get() & 255);
            }
            this.buf = NIOUtils.fetchFromChannel(this.channel, this.fetchSize);
            this.pos += this.buf.remaining();
        } while (this.buf.hasRemaining());
        written = out.position() - written;
        if (written > 0 && this.curMarker >= 256 && this.curMarker <= 511) 
            return SegmentReader.State.DONE;
        for (; this.bytesInMarker > 0 && out.hasRemaining(); ) {
            out.put(((this.curMarker >>> 24) << 24 >> 24));
            this.curMarker = (this.curMarker << 8);
            --this.bytesInMarker;
            if (this.curMarker >= 256 && this.curMarker <= 511) 
                return SegmentReader.State.DONE;
        }
        if (this.bytesInMarker == 0) {
            this.done = true;
            return SegmentReader.State.STOP;
        } else {
            return SegmentReader.State.MORE_DATA;
        }
    };
    /**
     *  Reads one full segment till the next marker. Will allocate the necessary
     *  buffer to hold the full segment. Internally uses a growing collection of
     *  smaller buffers since the segment size is intitially unkwnown.
     *  
     *  @return
     *  @throws IOException
     */
    prototype.readToNextMarkerNewBuffer = function() {
        if (this.done) 
            return null;
        var buffers = new ArrayList();
        this.readToNextMarkerBuffers(buffers);
        return NIOUtils.combineBuffers(buffers);
    };
    prototype.readToNextMarkerBuffers = function(buffers) {
        var state;
        do {
            var curBuffer = ByteBuffer.allocate(this.bufferIncrement);
            state = this.readToNextMarkerPartial(curBuffer);
            curBuffer.flip();
            buffers.add(curBuffer);
        } while (state == SegmentReader.State.MORE_DATA);
    };
    prototype.readToNextMarker = function(out) {
        var state = this.readToNextMarkerPartial(out);
        if (state == SegmentReader.State.MORE_DATA) 
             throw new BufferOverflowException();
        return state == SegmentReader.State.DONE;
    };
    prototype.skipToMarker = function() {
        if (this.done) 
            return false;
        do {
             while (this.buf.hasRemaining()){
                this.curMarker = (this.curMarker << 8) | (this.buf.get() & 255);
                if (this.curMarker >= 256 && this.curMarker <= 511) {
                    return true;
                }
            }
            this.buf = NIOUtils.fetchFromChannel(this.channel, this.fetchSize);
            this.pos += this.buf.remaining();
        } while (this.buf.hasRemaining());
        this.done = true;
        return false;
    };
    prototype.read = function(out, length) {
        if (this.done) 
            return false;
        do {
             while (this.buf.hasRemaining()){
                if (length-- == 0) 
                    return true;
                out.put(((this.curMarker >>> 24) << 24 >> 24));
                this.curMarker = (this.curMarker << 8) | (this.buf.get() & 255);
            }
            this.buf = NIOUtils.fetchFromChannel(this.channel, this.fetchSize);
            this.pos += this.buf.remaining();
        } while (this.buf.hasRemaining());
        out.putInt(this.curMarker);
        this.done = true;
        return false;
    };
    prototype.curPos = function() {
        return this.pos - this.buf.remaining() - 4;
    };
}, {channel: "ReadableByteChannel", buf: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VP8Decoder = function() {
    VideoDecoder.call(this);
    this.refLoopFilterDeltas = new Int32Array(VP8Util.MAX_REF_LF_DELTAS);
    this.modeLoopFilterDeltas = new Int32Array(VP8Util.MAX_MODE_LF_DELTAS);
};
VP8Decoder = stjs.extend(VP8Decoder, VideoDecoder, [], function(constructor, prototype) {
    prototype.segmentationMap = null;
    prototype.refLoopFilterDeltas = null;
    prototype.modeLoopFilterDeltas = null;
    prototype.decodeFrame = function(frame, buffer) {
        var firstThree = new Int8Array(3);
        frame.getBuf(firstThree);
        var keyFrame = VP8Util.getBitInBytes(firstThree, 0) == 0;
        if (!keyFrame) 
            return null;
        var version = VP8Util.getBitsInBytes(firstThree, 1, 3);
        var showFrame = VP8Util.getBitInBytes(firstThree, 4) > 0;
        var partitionSize = VP8Util.getBitsInBytes(firstThree, 5, 19);
        var threeByteToken = VP8Decoder.printHexByte(frame.get()) + " " + VP8Decoder.printHexByte(frame.get()) + " " + VP8Decoder.printHexByte(frame.get());
        var twoBytesWidth = (frame.get() & 255) | (frame.get() & 255) << 8;
        var twoBytesHeight = (frame.get() & 255) | (frame.get() & 255) << 8;
        var width = (twoBytesWidth & 16383);
        var height = (twoBytesHeight & 16383);
        var numberOfMBRows = VP8Util.getMacroblockCount(height);
        var numberOfMBCols = VP8Util.getMacroblockCount(width);
        if (this.segmentationMap == null) 
            this.segmentationMap = Array.apply(null, Array(numberOfMBRows)).map(function() {
                return new Int8Array(numberOfMBCols);
            });
        var mbs = Array.apply(null, Array(numberOfMBRows + 2)).map(function() {
            return Array(numberOfMBCols + 2);
        });
        for (var row = 0; row < numberOfMBRows + 2; row++) {
            for (var col = 0; col < numberOfMBCols + 2; col++) {
                mbs[row][col] = new VPXMacroblock(row, col);
            }
        }
        var headerOffset = frame.position();
        var headerDecoder = new VPXBooleanDecoder(frame, 0);
        var isYUVColorSpace = (headerDecoder.readBitEq() == 0);
        var clampingRequired = headerDecoder.readBitEq() == 0;
        var segmentation = headerDecoder.readBitEq();
        var segmentBased = null;
        if (segmentation != 0) {
            segmentBased = this.updateSegmentation(headerDecoder);
            for (var row = 0; row < numberOfMBRows; row++) {
                for (var col = 0; col < numberOfMBCols; col++) {
                    mbs[row + 1][col + 1].segment = this.segmentationMap[row][col];
                }
            }
        }
        var simpleFilter = headerDecoder.readBitEq();
        var filterLevel = headerDecoder.decodeInt(6);
        var filterType = (filterLevel == 0) ? 0 : (simpleFilter > 0) ? 1 : 2;
        var sharpnessLevel = headerDecoder.decodeInt(3);
        var loopFilterDeltaFlag = headerDecoder.readBitEq();
        if (loopFilterDeltaFlag == 1) {
            var loopFilterDeltaUpdate = headerDecoder.readBitEq();
            if (loopFilterDeltaUpdate == 1) {
                for (var i = 0; i < VP8Util.MAX_REF_LF_DELTAS; i++) {
                    if (headerDecoder.readBitEq() > 0) {
                        this.refLoopFilterDeltas[i] = headerDecoder.decodeInt(6);
                        ;
                        if (headerDecoder.readBitEq() > 0) 
                            this.refLoopFilterDeltas[i] = this.refLoopFilterDeltas[i] * -1;
                    }
                }
                for (var i = 0; i < VP8Util.MAX_MODE_LF_DELTAS; i++) {
                    if (headerDecoder.readBitEq() > 0) {
                        this.modeLoopFilterDeltas[i] = headerDecoder.decodeInt(6);
                        if (headerDecoder.readBitEq() > 0) 
                            this.modeLoopFilterDeltas[i] = this.modeLoopFilterDeltas[i] * -1;
                    }
                }
            }
        }
        var log2OfPartCnt = headerDecoder.decodeInt(2);
        Preconditions.checkState(0 == log2OfPartCnt);
        var partitionsCount = 1;
        var runningSize = 0;
        var zSize = frame.limit() - (partitionSize + headerOffset);
        var tokenBuffer = frame.duplicate();
        tokenBuffer.setPosition(partitionSize + headerOffset);
        var decoder = new VPXBooleanDecoder(tokenBuffer, 0);
        var yacIndex = headerDecoder.decodeInt(7);
        var ydcDelta = ((headerDecoder.readBitEq() > 0) ? VP8Util.delta(headerDecoder) : 0);
        var y2dcDelta = ((headerDecoder.readBitEq() > 0) ? VP8Util.delta(headerDecoder) : 0);
        var y2acDelta = ((headerDecoder.readBitEq() > 0) ? VP8Util.delta(headerDecoder) : 0);
        var chromaDCDelta = ((headerDecoder.readBitEq() > 0) ? VP8Util.delta(headerDecoder) : 0);
        var chromaACDelta = ((headerDecoder.readBitEq() > 0) ? VP8Util.delta(headerDecoder) : 0);
        var refreshProbs = headerDecoder.readBitEq() == 0;
        var quants = new VP8Util.QuantizationParams(yacIndex, ydcDelta, y2dcDelta, y2acDelta, chromaDCDelta, chromaACDelta);
        var coefProbs = VP8Util.getDefaultCoefProbs();
        for (var i = 0; i < VP8Util.BLOCK_TYPES; i++) 
            for (var j = 0; j < VP8Util.COEF_BANDS; j++) 
                for (var k = 0; k < VP8Util.PREV_COEF_CONTEXTS; k++) 
                    for (var l = 0; l < VP8Util.MAX_ENTROPY_TOKENS - 1; l++) {
                        if (headerDecoder.readBit(VP8Util.vp8CoefUpdateProbs[i][j][k][l]) > 0) {
                            var newp = headerDecoder.decodeInt(8);
                            coefProbs[i][j][k][l] = newp;
                        }
                    }
        var macroBlockNoCoeffSkip = stjs.trunc(headerDecoder.readBitEq());
        Preconditions.checkState(1 == macroBlockNoCoeffSkip);
        var probSkipFalse = headerDecoder.decodeInt(8);
        for (var mbRow = 0; mbRow < numberOfMBRows; mbRow++) {
            for (var mbCol = 0; mbCol < numberOfMBCols; mbCol++) {
                var mb = mbs[mbRow + 1][mbCol + 1];
                if (segmentation != 0 && segmentBased != null && segmentBased.segmentProbs != null) {
                    mb.segment = headerDecoder.readTree(VP8Util.segmentTree, segmentBased.segmentProbs);
                    this.segmentationMap[mbRow][mbCol] = (mb.segment << 24 >> 24);
                }
                if (segmentation != 0 && segmentBased != null && segmentBased.qp != null) {
                    var qIndex = yacIndex;
                    if (segmentBased.abs != 0) 
                        qIndex = segmentBased.qp[mb.segment];
                     else 
                        qIndex += segmentBased.qp[mb.segment];
                    quants = new VP8Util.QuantizationParams(qIndex, ydcDelta, y2dcDelta, y2acDelta, chromaDCDelta, chromaACDelta);
                }
                mb.quants = quants;
                if (loopFilterDeltaFlag != 0) {
                    var level = filterLevel;
                    level = level + this.refLoopFilterDeltas[0];
                    level = MathUtil.clip(level, 0, 63);
                    mb.filterLevel = level;
                } else {
                    mb.filterLevel = filterLevel;
                }
                if (segmentation != 0 && segmentBased != null && segmentBased.lf != null) {
                    if (segmentBased.abs != 0) {
                        mb.filterLevel = segmentBased.lf[mb.segment];
                    } else {
                        mb.filterLevel += segmentBased.lf[mb.segment];
                        mb.filterLevel = MathUtil.clip(mb.filterLevel, 0, 63);
                    }
                }
                if (macroBlockNoCoeffSkip > 0) 
                    mb.skipCoeff = headerDecoder.readBit(probSkipFalse);
                mb.lumaMode = headerDecoder.readTree(VP8Util.keyFrameYModeTree, VP8Util.keyFrameYModeProb);
                if (mb.lumaMode == VP8Util.SubblockConstants.B_PRED) {
                    for (var sbRow = 0; sbRow < 4; sbRow++) {
                        for (var sbCol = 0; sbCol < 4; sbCol++) {
                            var sb = mb.ySubblocks[sbRow][sbCol];
                            var A = sb.getAbove(VP8Util.PLANE.Y1, mbs);
                            var L = sb.getLeft(VP8Util.PLANE.Y1, mbs);
                            sb.mode = headerDecoder.readTree(VP8Util.SubblockConstants.subblockModeTree, VP8Util.SubblockConstants.keyFrameSubblockModeProb[A.mode][L.mode]);
                        }
                    }
                } else {
                    var fixedMode;
                    switch (mb.lumaMode) {
                        case VP8Util.SubblockConstants.DC_PRED:
                            fixedMode = VP8Util.SubblockConstants.B_DC_PRED;
                            break;
                        case VP8Util.SubblockConstants.V_PRED:
                            fixedMode = VP8Util.SubblockConstants.B_VE_PRED;
                            break;
                        case VP8Util.SubblockConstants.H_PRED:
                            fixedMode = VP8Util.SubblockConstants.B_HE_PRED;
                            break;
                        case VP8Util.SubblockConstants.TM_PRED:
                            fixedMode = VP8Util.SubblockConstants.B_TM_PRED;
                            break;
                        default:
                            fixedMode = VP8Util.SubblockConstants.B_DC_PRED;
                            break;
                    }
                    mb.lumaMode = this.edgeEmu(mb.lumaMode, mbCol, mbRow);
                    for (var x = 0; x < 4; x++) 
                        for (var y = 0; y < 4; y++) 
                            mb.ySubblocks[y][x].mode = fixedMode;
                }
                mb.chromaMode = headerDecoder.readTree(VP8Util.vp8UVModeTree, VP8Util.vp8KeyFrameUVModeProb);
            }
        }
        for (var mbRow = 0; mbRow < numberOfMBRows; mbRow++) {
            for (var mbCol = 0; mbCol < numberOfMBCols; mbCol++) {
                var mb = mbs[mbRow + 1][mbCol + 1];
                mb.decodeMacroBlock(mbs, decoder, coefProbs);
                mb.dequantMacroBlock(mbs);
            }
        }
        if (filterType > 0 && filterLevel != 0) {
            if (filterType == 2) {
                FilterUtil.loopFilterUV(mbs, sharpnessLevel, keyFrame);
                FilterUtil.loopFilterY(mbs, sharpnessLevel, keyFrame);
            } else if (filterType == 1) {}
        }
        var p = Picture.createPicture(width, height, buffer, ColorSpace.YUV420);
        var mbWidth = VP8Util.getMacroblockCount(width);
        var mbHeight = VP8Util.getMacroblockCount(height);
        for (var mbRow = 0; mbRow < mbHeight; mbRow++) {
            for (var mbCol = 0; mbCol < mbWidth; mbCol++) {
                var mb = mbs[mbRow + 1][mbCol + 1];
                mb.put(mbRow, mbCol, p);
            }
        }
        return p;
    };
    prototype.edgeEmu = function(mode, mbCol, mbRow) {
        switch (mode) {
            case VP8Util.SubblockConstants.V_PRED:
                return mbRow == 0 ? VP8Util.SubblockConstants.DC_PRED : mode;
            case VP8Util.SubblockConstants.H_PRED:
                return mbCol == 0 ? VP8Util.SubblockConstants.DC_PRED : mode;
            case VP8Util.SubblockConstants.TM_PRED:
                return this.edgeEmuTm(mode, mbCol, mbRow);
            default:
                return mode;
        }
    };
    prototype.edgeEmuTm = function(mode, mbCol, mbRow) {
        if (mbCol == 0) 
            return mbRow != 0 ? VP8Util.SubblockConstants.V_PRED : VP8Util.SubblockConstants.DC_PRED;
         else 
            return mbRow != 0 ? mode : VP8Util.SubblockConstants.H_PRED;
    };
    constructor.SegmentBasedAdjustments = function(segmentProbs, qp, lf, abs) {
        this.segmentProbs = segmentProbs;
        this.qp = qp;
        this.lf = lf;
        this.abs = abs;
    };
    constructor.SegmentBasedAdjustments = stjs.extend(constructor.SegmentBasedAdjustments, null, [], function(constructor, prototype) {
        prototype.segmentProbs = null;
        prototype.qp = null;
        prototype.lf = null;
        prototype.abs = 0;
    }, {segmentProbs: "Int32Array", qp: "Int32Array", lf: "Int32Array"}, {});
    prototype.updateSegmentation = function(headerDecoder) {
        var updateMBSegmentationMap = headerDecoder.readBitEq();
        var updateSegmentFeatureData = headerDecoder.readBitEq();
        var qp = null;
        var lf = null;
        var abs = 0;
        if (updateSegmentFeatureData != 0) {
            qp = new Int32Array(4);
            lf = new Int32Array(4);
            abs = headerDecoder.readBitEq();
            for (var i = 0; i < 4; i++) {
                var quantizerUpdate = headerDecoder.readBitEq();
                if (quantizerUpdate != 0) {
                    qp[i] = headerDecoder.decodeInt(7);
                    qp[i] = headerDecoder.readBitEq() != 0 ? -qp[i] : qp[i];
                }
            }
            for (var i = 0; i < 4; i++) {
                var loopFilterUpdate = headerDecoder.readBitEq();
                if (loopFilterUpdate != 0) {
                    lf[i] = headerDecoder.decodeInt(6);
                    lf[i] = headerDecoder.readBitEq() != 0 ? -lf[i] : lf[i];
                }
            }
        }
        var segmentProbs = new Int32Array(3);
        if (updateMBSegmentationMap != 0) {
            for (var i = 0; i < 3; i++) {
                var segmentProbUpdate = headerDecoder.readBitEq();
                if (segmentProbUpdate != 0) 
                    segmentProbs[i] = headerDecoder.decodeInt(8);
                 else 
                    segmentProbs[i] = 255;
            }
        }
        return new VP8Decoder.SegmentBasedAdjustments(segmentProbs, qp, lf, abs);
    };
    constructor.probe = function(data) {
        if ((data.getAt(3) & 255) == 157 && (data.getAt(4) & 255) == 1 && (data.getAt(5) & 255) == 42) 
            return 100;
        return 0;
    };
    constructor.printHexByte = function(b) {
        return "0x" + Integer.toHexString(b & 255);
    };
    prototype.getCodecMeta = function(frame) {
        NIOUtils.skip(frame, 6);
        var twoBytesWidth = (frame.get() & 255) | (frame.get() & 255) << 8;
        var twoBytesHeight = (frame.get() & 255) | (frame.get() & 255) << 8;
        var width = (twoBytesWidth & 16383);
        var height = (twoBytesHeight & 16383);
        return VideoCodecMeta.createSimpleVideoCodecMeta(new Size(width, height), ColorSpace.YUV420);
    };
}, {segmentationMap: "Array", refLoopFilterDeltas: "Int32Array", modeLoopFilterDeltas: "Int32Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IndexEntries = function(displayOff, keyFrameOff, flags, fileOff) {
    this.displayOff = displayOff;
    this.keyFrameOff = keyFrameOff;
    this.flags = flags;
    this.fileOff = fileOff;
};
IndexEntries = stjs.extend(IndexEntries, null, [], function(constructor, prototype) {
    prototype.displayOff = null;
    prototype.flags = null;
    prototype.fileOff = null;
    prototype.keyFrameOff = null;
    prototype.getDisplayOff = function() {
        return this.displayOff;
    };
    prototype.getFlags = function() {
        return this.flags;
    };
    prototype.getFileOff = function() {
        return this.fileOff;
    };
    prototype.getKeyFrameOff = function() {
        return this.keyFrameOff;
    };
    constructor.read = function(bb) {
        bb.order(ByteOrder.BIG_ENDIAN);
        var n = bb.getInt();
        var len = bb.getInt();
        var temporalOff = new Int32Array(n);
        var flags = new Int8Array(n);
        var fileOff = Array(n);
        var keyFrameOff = new Int8Array(n);
        for (var i = 0; i < n; i++) {
            temporalOff[i] = i + bb.get();
            keyFrameOff[i] = bb.get();
            flags[i] = bb.get();
            fileOff[i] = bb.getLong();
            NIOUtils.skip(bb, len - 11);
        }
        var displayOff = new Int8Array(n);
        for (var i = 0; i < n; i++) {
            for (var j = 0; j < n; j++) {
                if (temporalOff[j] == i) {
                    displayOff[i] = ((j - i) << 24 >> 24);
                    break;
                }
            }
        }
        return new IndexEntries(displayOff, keyFrameOff, flags, fileOff);
    };
}, {displayOff: "Int8Array", flags: "Int8Array", fileOff: "Array", keyFrameOff: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MXFMetadata = function(ul) {
    this.ul = ul;
};
MXFMetadata = stjs.extend(MXFMetadata, null, [], function(constructor, prototype) {
    prototype.ul = null;
    prototype.uid = null;
    prototype.readBuf = function(bb) {};
    /**
     *  Utility method to read a batch of ULS
     *  
     *  @param _bb
     *  @return
     */
    constructor.readULBatch = function(_bb) {
        var count = _bb.getInt();
        _bb.getInt();
        var result = Array(count);
        for (var i = 0; i < count; i++) {
            result[i] = UL.read(_bb);
        }
        return result;
    };
    /**
     *  Utility method to read a batch of int32
     *  
     *  @param _bb
     *  @return
     */
    constructor.readInt32Batch = function(_bb) {
        var count = _bb.getInt();
        _bb.getInt();
        var result = new Int32Array(count);
        for (var i = 0; i < count; i++) {
            result[i] = _bb.getInt();
        }
        return result;
    };
    constructor.readDate = function(_bb) {
        var calendar = Calendar.getInstance();
        calendar.set(Calendar.YEAR, _bb.getShort());
        calendar.set(Calendar.MONTH, _bb.get());
        calendar.set(Calendar.DAY_OF_MONTH, _bb.get());
        calendar.set(Calendar.HOUR, _bb.get());
        calendar.set(Calendar.MINUTE, _bb.get());
        calendar.set(Calendar.SECOND, _bb.get());
        calendar.set(Calendar.MILLISECOND, (_bb.get() & 255) << 2);
        return calendar.getTime();
    };
    prototype.readUtf16String = function(_bb) {
        var array;
        if (_bb.getShortAt(_bb.limit() - 2) != 0) {
            array = NIOUtils.toArray(_bb);
        } else {
            array = NIOUtils.toArray(_bb.setLimit(_bb.limit() - 2));
        }
        return Platform.stringFromCharset(array, Platform.UTF_16);
    };
    prototype.getUl = function() {
        return this.ul;
    };
    prototype.getUid = function() {
        return this.uid;
    };
}, {ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Y4MDemuxer = function(_is) {
    this.is = _is;
    var buf = NIOUtils.fetchFromChannel(this.is, 2048);
    var header = StringUtils.splitC(Y4MDemuxer.readLine(buf), ' '.charCodeAt(0));
    if (!"YUV4MPEG2".equals(header[0])) {
        this.invalidFormat = "Not yuv4mpeg stream";
        return;
    }
    var chroma = Y4MDemuxer.find(header, 'C'.charCodeAt(0));
    if (chroma != null && !chroma.startsWith("420")) {
        this.invalidFormat = "Only yuv420p is supported";
        return;
    }
    this.width = Integer.parseInt(Y4MDemuxer.find(header, 'W'.charCodeAt(0)));
    this.height = Integer.parseInt(Y4MDemuxer.find(header, 'H'.charCodeAt(0)));
    var fpsStr = Y4MDemuxer.find(header, 'F'.charCodeAt(0));
    if (fpsStr != null) {
        var numden = StringUtils.splitC(fpsStr, ':'.charCodeAt(0));
        this.fps = new Rational(Integer.parseInt(numden[0]), Integer.parseInt(numden[1]));
    }
    this.is.setPosition(buf.position());
    this.bufSize = this.width * this.height;
    this.bufSize += stjs.trunc(this.bufSize / 2);
    var fileSize = this.is.size();
    this.totalFrames = (((stjs.trunc(fileSize / (this.bufSize + 7)))) | 0);
    this.totalDuration = stjs.trunc((this.totalFrames * this.fps.getDen()) / this.fps.getNum());
};
Y4MDemuxer = stjs.extend(Y4MDemuxer, null, [DemuxerTrack, Demuxer], function(constructor, prototype) {
    prototype.is = null;
    prototype.width = 0;
    prototype.height = 0;
    prototype.invalidFormat = null;
    prototype.fps = null;
    prototype.bufSize = 0;
    prototype.frameNum = 0;
    prototype.totalFrames = 0;
    prototype.totalDuration = 0;
    prototype.nextFrame = function() {
        if (this.invalidFormat != null) 
             throw new RuntimeException("Invalid input: " + this.invalidFormat);
        var buf = NIOUtils.fetchFromChannel(this.is, 2048);
        var frame = Y4MDemuxer.readLine(buf);
        if (frame == null || !frame.startsWith("FRAME")) 
            return null;
        this.is.setPosition(this.is.position() - buf.remaining());
        var pix = NIOUtils.fetchFromChannel(this.is, this.bufSize);
        var packet = new Packet(pix, this.frameNum * this.fps.getDen(), this.fps.getNum(), this.fps.getDen(), this.frameNum, Packet.FrameType.KEY, null, this.frameNum);
        ++this.frameNum;
        return packet;
    };
    constructor.find = function(header, c) {
        for (var i = 0; i < header.length; i++) {
            var string = header[i];
            if (string.charAt(0) == c) 
                return string.substring(1);
        }
        return null;
    };
    constructor.readLine = function(y4m) {
        var duplicate = y4m.duplicate();
         while (y4m.hasRemaining() && y4m.get() != '\n'.charCodeAt(0))
            ;
        if (y4m.hasRemaining()) 
            duplicate.setLimit(y4m.position() - 1);
        return Platform.stringFromBytes(NIOUtils.toArray(duplicate));
    };
    prototype.getFps = function() {
        return this.fps;
    };
    prototype.getMeta = function() {
        return new DemuxerTrackMeta(TrackType.VIDEO, Codec.RAW, this.totalDuration, null, this.totalFrames, null, VideoCodecMeta.createSimpleVideoCodecMeta(new Size(this.width, this.height), ColorSpace.YUV420), null);
    };
    prototype.close = function() {
        this.is.close();
    };
    prototype.getTracks = function() {
        var list = new ArrayList();
        list.add(this);
        return list;
    };
    prototype.getVideoTracks = function() {
        return this.getTracks();
    };
    prototype.getAudioTracks = function() {
        return new ArrayList();
    };
}, {is: "SeekableByteChannel", fps: "Rational"}, {});
/**
 *  
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Apple ProRes encoder
 *  
 *  @author The JCodec project
 *  
 */
var ProresEncoder = function(profile, interlaced) {
    VideoEncoder.call(this);
    this.profile = profile;
    this.scaledLuma = this.scaleQMat(profile.qmatLuma, 1, 16);
    this.scaledChroma = this.scaleQMat(profile.qmatChroma, 1, 16);
    this.interlaced = interlaced;
};
ProresEncoder = stjs.extend(ProresEncoder, VideoEncoder, [], function(constructor, prototype) {
    constructor.LOG_DEFAULT_SLICE_MB_WIDTH = 3;
    constructor.DEFAULT_SLICE_MB_WIDTH = 1 << ProresEncoder.LOG_DEFAULT_SLICE_MB_WIDTH;
    constructor.Profile = function(name, qmatLuma, qmatChroma, fourcc, bitrate, firstQp, lastQp) {
        this.name = name;
        this.qmatLuma = qmatLuma;
        this.qmatChroma = qmatChroma;
        this.fourcc = fourcc;
        this.bitrate = bitrate;
        this.firstQp = firstQp;
        this.lastQp = lastQp;
    };
    constructor.Profile = stjs.extend(constructor.Profile, null, [], function(constructor, prototype) {
        constructor.PROXY = new ProresEncoder.Profile("PROXY", ProresConsts.QMAT_LUMA_APCO, ProresConsts.QMAT_CHROMA_APCO, "apco", 1000, 4, 8);
        constructor.LT = new ProresEncoder.Profile("LT", ProresConsts.QMAT_LUMA_APCS, ProresConsts.QMAT_CHROMA_APCS, "apcs", 2100, 1, 9);
        constructor.STANDARD = new ProresEncoder.Profile("STANDARD", ProresConsts.QMAT_LUMA_APCN, ProresConsts.QMAT_CHROMA_APCN, "apcn", 3500, 1, 6);
        constructor.HQ = new ProresEncoder.Profile("HQ", ProresConsts.QMAT_LUMA_APCH, ProresConsts.QMAT_CHROMA_APCH, "apch", 5400, 1, 6);
        constructor._values = [ProresEncoder.Profile.PROXY, ProresEncoder.Profile.LT, ProresEncoder.Profile.STANDARD, ProresEncoder.Profile.HQ];
        constructor.values = function() {
            return ProresEncoder.Profile._values;
        };
        constructor.valueOf = function(name) {
            var nameU = name.toUpperCase();
            for (var index$profile2 = 0, arr$profile2 = ProresEncoder.Profile._values; index$profile2 < arr$profile2.length; index$profile2++) {
                var profile2 = arr$profile2[index$profile2];
                if (name.equals(nameU)) 
                    return profile2;
            }
            return null;
        };
        prototype.name = null;
        prototype.qmatLuma = null;
        prototype.qmatChroma = null;
        prototype.fourcc = null;
        prototype.bitrate = 0;
        prototype.firstQp = 0;
        prototype.lastQp = 0;
    }, {PROXY: "ProresEncoder.Profile", LT: "ProresEncoder.Profile", STANDARD: "ProresEncoder.Profile", HQ: "ProresEncoder.Profile", _values: "Array", qmatLuma: "Int32Array", qmatChroma: "Int32Array"}, {});
    prototype.profile = null;
    prototype.scaledLuma = null;
    prototype.scaledChroma = null;
    prototype.interlaced = false;
    constructor.createProresEncoder = function(profile, interlaced) {
        return new ProresEncoder(profile == null ? ProresEncoder.Profile.HQ : ProresEncoder.Profile.valueOf(profile), interlaced);
    };
    prototype.scaleQMat = function(qmatLuma, start, count) {
        var result = Array(count);
        for (var i = 0; i < count; i++) {
            result[i] = new Int32Array(qmatLuma.length);
            for (var j = 0; j < qmatLuma.length; j++) 
                result[i][j] = qmatLuma[j] * (i + start);
        }
        return result;
    };
    constructor.writeCodeword = function(writer, codebook, val) {
        var firstExp = ((codebook.switchBits + 1) << codebook.riceOrder);
        if (val >= firstExp) {
            val -= firstExp;
            val += (1 << codebook.expOrder);
            var exp = MathUtil.log2(val);
            var zeros = exp - codebook.expOrder + codebook.switchBits + 1;
            for (var i = 0; i < zeros; i++) 
                writer.write1Bit(0);
            writer.write1Bit(1);
            writer.writeNBit(val, exp);
        } else if (codebook.riceOrder > 0) {
            for (var i = 0; i < (val >> codebook.riceOrder); i++) 
                writer.write1Bit(0);
            writer.write1Bit(1);
            writer.writeNBit(val & ((1 << codebook.riceOrder) - 1), codebook.riceOrder);
        } else {
            for (var i = 0; i < val; i++) 
                writer.write1Bit(0);
            writer.write1Bit(1);
        }
    };
    constructor.qScale = function(qMat, ind, val) {
        return stjs.trunc(val / qMat[ind]);
    };
    constructor.toGolumb = function(val) {
        return (val << 1) ^ (val >> 31);
    };
    constructor.toGolumbSign = function(val, sign) {
        if (val == 0) 
            return 0;
        return (val << 1) + sign;
    };
    constructor.diffSign = function(val, sign) {
        return (val >> 31) ^ sign;
    };
    constructor.getLevel = function(val) {
        var sign = (val >> 31);
        return (val ^ sign) - sign;
    };
    constructor.writeDCCoeffs = function(bits, qMat, _in, blocksPerSlice) {
        var prevDc = ProresEncoder.qScale(qMat, 0, _in[0] - 16384);
        ProresEncoder.writeCodeword(bits, ProresConsts.firstDCCodebook, ProresEncoder.toGolumb(prevDc));
        var code = 5, sign = 0, idx = 64;
        for (var i = 1; i < blocksPerSlice; i++ , idx += 64) {
            var newDc = ProresEncoder.qScale(qMat, 0, _in[idx] - 16384);
            var delta = newDc - prevDc;
            var newCode = ProresEncoder.toGolumbSign(ProresEncoder.getLevel(delta), ProresEncoder.diffSign(delta, sign));
            ProresEncoder.writeCodeword(bits, ProresConsts.dcCodebooks[Math.min(code, 6)], newCode);
            code = newCode;
            sign = delta >> 31;
            prevDc = newDc;
        }
    };
    constructor.writeACCoeffs = function(bits, qMat, _in, blocksPerSlice, scan, maxCoeff) {
        var prevRun = 4;
        var prevLevel = 2;
        var run = 0;
        for (var i = 1; i < maxCoeff; i++) {
            var indp = scan[i];
            for (var j = 0; j < blocksPerSlice; j++) {
                var val = ProresEncoder.qScale(qMat, indp, _in[(j << 6) + indp]);
                if (val == 0) 
                    run++;
                 else {
                    ProresEncoder.writeCodeword(bits, ProresConsts.runCodebooks[Math.min(prevRun, 15)], run);
                    prevRun = run;
                    run = 0;
                    var level = ProresEncoder.getLevel(val);
                    ProresEncoder.writeCodeword(bits, ProresConsts.levCodebooks[Math.min(prevLevel, 9)], level - 1);
                    prevLevel = level;
                    bits.write1Bit(MathUtil.sign(val));
                }
            }
        }
    };
    constructor.encodeOnePlane = function(bits, blocksPerSlice, qMat, scan, _in) {
        ProresEncoder.writeDCCoeffs(bits, qMat, _in, blocksPerSlice);
        ProresEncoder.writeACCoeffs(bits, qMat, _in, blocksPerSlice, scan, 64);
    };
    prototype.dctOnePlane = function(blocksPerSlice, src, hibd, dst) {
        for (var i = 0; i < src.length; i++) {
            dst[i] = ((src[i] + 128) << 2);
        }
        if (hibd != null) {
            for (var i = 0; i < src.length; i++) {
                dst[i] += hibd[i];
            }
        }
        for (var i = 0; i < blocksPerSlice; i++) {
            SimpleIDCT10Bit.fdctProres10(dst, i << 6);
        }
    };
    prototype.encodeSlice = function(out, scaledLuma, scaledChroma, scan, sliceMbCount, mbX, mbY, result, prevQp, mbWidth, mbHeight, unsafe, vStep, vOffset) {
        var striped = this.splitSlice(result, mbX, mbY, sliceMbCount, unsafe, vStep, vOffset);
        var ac = [new Int32Array(sliceMbCount << 8), new Int32Array(sliceMbCount << 7), new Int32Array(sliceMbCount << 7)];
        var data = striped.getData();
        var lowBits = striped.getLowBits();
        this.dctOnePlane(sliceMbCount << 2, data[0], lowBits == null ? null : lowBits[0], ac[0]);
        this.dctOnePlane(sliceMbCount << 1, data[1], lowBits == null ? null : lowBits[1], ac[1]);
        this.dctOnePlane(sliceMbCount << 1, data[2], lowBits == null ? null : lowBits[2], ac[2]);
        var est = (sliceMbCount >> 2) * this.profile.bitrate;
        var low = est - (est >> 3);
        var high = est + (est >> 3);
        var qp = prevQp;
        out.put(((6 << 3) << 24 >> 24));
        var fork = out.duplicate();
        NIOUtils.skip(out, 5);
        var rem = out.position();
        var sizes = new Int32Array(3);
        ProresEncoder.encodeSliceData(out, scaledLuma[qp - 1], scaledChroma[qp - 1], scan, sliceMbCount, ac, qp, sizes);
        if (ProresEncoder.bits(sizes) > high && qp < this.profile.lastQp) {
            do {
                ++qp;
                out.setPosition(rem);
                ProresEncoder.encodeSliceData(out, scaledLuma[qp - 1], scaledChroma[qp - 1], scan, sliceMbCount, ac, qp, sizes);
            } while (ProresEncoder.bits(sizes) > high && qp < this.profile.lastQp);
        } else if (ProresEncoder.bits(sizes) < low && qp > this.profile.firstQp) {
            do {
                --qp;
                out.setPosition(rem);
                ProresEncoder.encodeSliceData(out, scaledLuma[qp - 1], scaledChroma[qp - 1], scan, sliceMbCount, ac, qp, sizes);
            } while (ProresEncoder.bits(sizes) < low && qp > this.profile.firstQp);
        }
        fork.put((qp << 24 >> 24));
        fork.putShort(((sizes[0]) << 16 >> 16));
        fork.putShort(((sizes[1]) << 16 >> 16));
        return qp;
    };
    constructor.bits = function(sizes) {
        return sizes[0] + sizes[1] + sizes[2] << 3;
    };
    constructor.encodeSliceData = function(out, qmatLuma, qmatChroma, scan, sliceMbCount, ac, qp, sizes) {
        sizes[0] = ProresEncoder.onePlane(out, sliceMbCount << 2, qmatLuma, scan, ac[0]);
        sizes[1] = ProresEncoder.onePlane(out, sliceMbCount << 1, qmatChroma, scan, ac[1]);
        sizes[2] = ProresEncoder.onePlane(out, sliceMbCount << 1, qmatChroma, scan, ac[2]);
    };
    constructor.onePlane = function(out, blocksPerSlice, qmatLuma, scan, data) {
        var rem = out.position();
        var bits = new BitWriter(out);
        ProresEncoder.encodeOnePlane(bits, blocksPerSlice, qmatLuma, scan, data);
        bits.flush();
        return out.position() - rem;
    };
    prototype.encodePicture = function(out, scaledLuma, scaledChroma, scan, picture, vStep, vOffset) {
        var mbWidth = (picture.getWidth() + 15) >> 4;
        var shift = 4 + vStep;
        var round = (1 << shift) - 1;
        var mbHeight = (picture.getHeight() + round) >> shift;
        var qp = this.profile.firstQp;
        var nSlices = this.calcNSlices(mbWidth, mbHeight);
        ProresEncoder.writePictureHeader(ProresEncoder.LOG_DEFAULT_SLICE_MB_WIDTH, nSlices, out);
        var fork = out.duplicate();
        NIOUtils.skip(out, nSlices << 1);
        var i = 0;
        var total = new Int32Array(nSlices);
        for (var mbY = 0; mbY < mbHeight; mbY++) {
            var mbX = 0;
            var sliceMbCount = ProresEncoder.DEFAULT_SLICE_MB_WIDTH;
             while (mbX < mbWidth){
                 while (mbWidth - mbX < sliceMbCount)
                    sliceMbCount >>= 1;
                var sliceStart = out.position();
                var unsafeBottom = (picture.getHeight() % 16) != 0 && mbY == mbHeight - 1;
                var unsafeRight = (picture.getWidth() % 16) != 0 && mbX + sliceMbCount == mbWidth;
                qp = this.encodeSlice(out, scaledLuma, scaledChroma, scan, sliceMbCount, mbX, mbY, picture, qp, mbWidth, mbHeight, unsafeBottom || unsafeRight, vStep, vOffset);
                fork.putShort((((out.position() - sliceStart)) << 16 >> 16));
                total[i++] = (((out.position() - sliceStart)) << 16 >> 16);
                mbX += sliceMbCount;
            }
        }
    };
    constructor.writePictureHeader = function(logDefaultSliceMbWidth, nSlices, out) {
        var headerLen = 8;
        out.put(((headerLen << 3) << 24 >> 24));
        out.putInt(0);
        out.putShort(((nSlices) << 16 >> 16));
        out.put(((logDefaultSliceMbWidth << 4) << 24 >> 24));
    };
    prototype.calcNSlices = function(mbWidth, mbHeight) {
        var nSlices = mbWidth >> ProresEncoder.LOG_DEFAULT_SLICE_MB_WIDTH;
        for (var i = 0; i < ProresEncoder.LOG_DEFAULT_SLICE_MB_WIDTH; i++) {
            nSlices += (mbWidth >> i) & 1;
        }
        return nSlices * mbHeight;
    };
    prototype.splitSlice = function(result, mbX, mbY, sliceMbCount, unsafe, vStep, vOffset) {
        var out = Picture.createCroppedHiBD(sliceMbCount << 4, 16, result.getLowBitsNum(), ColorSpace.YUV422, null);
        if (unsafe) {
            var mbHeightPix = 16 << vStep;
            var filled = Picture.create(sliceMbCount << 4, mbHeightPix, ColorSpace.YUV422);
            ImageOP.subImageWithFillPic8(result, filled, new Rect(mbX << 4, mbY << (4 + vStep), sliceMbCount << 4, mbHeightPix));
            this.split(filled, out, 0, 0, sliceMbCount, vStep, vOffset);
        } else {
            this.split(result, out, mbX, mbY, sliceMbCount, vStep, vOffset);
        }
        return out;
    };
    prototype.split = function(src, dst, mbX, mbY, sliceMbCount, vStep, vOffset) {
        var inData = src.getData();
        var inhbdData = src.getLowBits();
        var outData = dst.getData();
        var outhbdData = dst.getLowBits();
        this.doSplit(inData[0], outData[0], src.getPlaneWidth(0), mbX, mbY, sliceMbCount, 0, vStep, vOffset);
        this.doSplit(inData[1], outData[1], src.getPlaneWidth(1), mbX, mbY, sliceMbCount, 1, vStep, vOffset);
        this.doSplit(inData[2], outData[2], src.getPlaneWidth(2), mbX, mbY, sliceMbCount, 1, vStep, vOffset);
        if (src.getLowBits() != null) {
            this.doSplit(inhbdData[0], outhbdData[0], src.getPlaneWidth(0), mbX, mbY, sliceMbCount, 0, vStep, vOffset);
            this.doSplit(inhbdData[1], outhbdData[1], src.getPlaneWidth(1), mbX, mbY, sliceMbCount, 1, vStep, vOffset);
            this.doSplit(inhbdData[2], outhbdData[2], src.getPlaneWidth(2), mbX, mbY, sliceMbCount, 1, vStep, vOffset);
        }
    };
    prototype.doSplit = function(_in, out, stride, mbX, mbY, sliceMbCount, chroma, vStep, vOffset) {
        var outOff = 0;
        var off = (mbY << 4) * (stride << vStep) + (mbX << (4 - chroma)) + stride * vOffset;
        stride <<= vStep;
        for (var i = 0; i < sliceMbCount; i++) {
            this.splitBlock(_in, stride, off, out, outOff);
            this.splitBlock(_in, stride, off + (stride << 3), out, outOff + (128 >> chroma));
            if (chroma == 0) {
                this.splitBlock(_in, stride, off + 8, out, outOff + 64);
                this.splitBlock(_in, stride, off + (stride << 3) + 8, out, outOff + 192);
            }
            outOff += (256 >> chroma);
            off += (16 >> chroma);
        }
    };
    prototype.splitBlock = function(y, stride, off, out, outOff) {
        for (var i = 0; i < 8; i++) {
            for (var j = 0; j < 8; j++) 
                out[outOff++] = y[off++];
            off += stride - 8;
        }
    };
    prototype.encodeFrame = function(pic, buffer) {
        var out = buffer.duplicate();
        var fork = out.duplicate();
        var scan = this.interlaced ? ProresConsts.interlaced_scan : ProresConsts.progressive_scan;
        ProresEncoder.writeFrameHeader(out, new ProresConsts.FrameHeader(0, pic.getCroppedWidth(), pic.getCroppedHeight(), this.interlaced ? 1 : 0, true, scan, this.profile.qmatLuma, this.profile.qmatChroma, 2));
        this.encodePicture(out, this.scaledLuma, this.scaledChroma, scan, pic, this.interlaced ? 1 : 0, 0);
        if (this.interlaced) 
            this.encodePicture(out, this.scaledLuma, this.scaledChroma, scan, pic, this.interlaced ? 1 : 0, 1);
        out.flip();
        fork.putInt(out.remaining());
        return new VideoEncoder.EncodedFrame(out, true);
    };
    constructor.writeFrameHeader = function(outp, header) {
        var headerSize = 148;
        outp.putInt(headerSize + 8 + header.payloadSize);
        outp.putArr(new Int8Array(['i'.charCodeAt(0), 'c'.charCodeAt(0), 'p'.charCodeAt(0), 'f'.charCodeAt(0)]));
        outp.putShort(headerSize);
        outp.putShort(((0) << 16 >> 16));
        outp.putArr(new Int8Array(['a'.charCodeAt(0), 'p'.charCodeAt(0), 'l'.charCodeAt(0), '0'.charCodeAt(0)]));
        outp.putShort(((header.width) << 16 >> 16));
        outp.putShort(((header.height) << 16 >> 16));
        outp.put(((header.frameType == 0 ? 131 : 135) << 24 >> 24));
        outp.putArr(new Int8Array([0, 2, 2, 6, 32, 0]));
        outp.put((3 << 24 >> 24));
        ProresEncoder.writeQMat(outp, header.qMatLuma);
        ProresEncoder.writeQMat(outp, header.qMatChroma);
    };
    constructor.writeQMat = function(out, qmat) {
        for (var i = 0; i < 64; i++) 
            out.put((qmat[i] << 24 >> 24));
    };
    prototype.getSupportedColorSpaces = function() {
        return [ColorSpace.YUV422];
    };
    prototype.estimateBufferSize = function(frame) {
        return stjs.trunc((3 * frame.getWidth() * frame.getHeight()) / 2);
    };
}, {profile: "ProresEncoder.Profile", scaledLuma: "Array", scaledChroma: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var EbmlDate = function(id) {
    EbmlSint.call(this, id);
};
EbmlDate = stjs.extend(EbmlDate, EbmlSint, [], function(constructor, prototype) {
    constructor.NANOSECONDS_IN_A_SECOND = 1000000000;
    constructor.MILISECONDS_IN_A_SECOND = 1000;
    constructor.NANOSECONDS_IN_A_MILISECOND = stjs.trunc(EbmlDate.NANOSECONDS_IN_A_SECOND / EbmlDate.MILISECONDS_IN_A_SECOND);
    constructor.MILISECONDS_SINCE_UNIX_EPOCH_START = 978307200;
    prototype.setDate = function(value) {
        this.setMiliseconds(value.getTime());
    };
    prototype.getDate = function() {
        var val = this.getLong();
        val = stjs.trunc(val / EbmlDate.NANOSECONDS_IN_A_MILISECOND) + EbmlDate.MILISECONDS_SINCE_UNIX_EPOCH_START;
        return new jsutil.Date(val);
    };
    prototype.setMiliseconds = function(milliseconds) {
        this.setLong((milliseconds - EbmlDate.MILISECONDS_SINCE_UNIX_EPOCH_START) * EbmlDate.NANOSECONDS_IN_A_MILISECOND);
    };
    prototype.setLong = function(value) {
        this.data = ByteBuffer.allocate(8);
        this.data.putLong(value);
        this.data.flip();
    };
}, {signedComplement: "Array", data: "ByteBuffer", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MkvBlock = function(type) {
    EbmlBin.call(this, type);
    if (!Platform.arrayEqualsByte(MkvBlock.SIMPLEBLOCK_ID, type) && !Platform.arrayEqualsByte(MkvBlock.BLOCK_ID, type)) 
         throw new IllegalArgumentException("Block initiated with invalid id: " + EbmlUtil.toHexString(type));
};
MkvBlock = stjs.extend(MkvBlock, EbmlBin, [], function(constructor, prototype) {
    constructor.XIPH = "Xiph";
    constructor.EBML = "EBML";
    constructor.FIXED = "Fixed";
    constructor.MAX_BLOCK_HEADER_SIZE = 512;
    prototype.frameOffsets = null;
    prototype.frameSizes = null;
    prototype.trackNumber = 0;
    prototype.timecode = 0;
    prototype.absoluteTimecode = 0;
    prototype._keyFrame = false;
    prototype.headerSize = 0;
    prototype.lacing = null;
    prototype.discardable = false;
    prototype.lacingPresent = false;
    prototype.frames = null;
    constructor.BLOCK_ID = new Int8Array([(161 << 24 >> 24)]);
    constructor.SIMPLEBLOCK_ID = new Int8Array([(163 << 24 >> 24)]);
    constructor.copy = function(old) {
        var be = new MkvBlock(old.id);
        be.trackNumber = old.trackNumber;
        be.timecode = old.timecode;
        be.absoluteTimecode = old.absoluteTimecode;
        be._keyFrame = old._keyFrame;
        be.headerSize = old.headerSize;
        be.lacing = old.lacing;
        be.discardable = old.discardable;
        be.lacingPresent = old.lacingPresent;
        be.frameOffsets = new Int32Array(old.frameOffsets.length);
        be.frameSizes = new Int32Array(old.frameSizes.length);
        be.dataOffset = old.dataOffset;
        be.offset = old.offset;
        be.type = old.type;
        System.arraycopy(old.frameOffsets, 0, be.frameOffsets, 0, be.frameOffsets.length);
        System.arraycopy(old.frameSizes, 0, be.frameSizes, 0, be.frameSizes.length);
        return be;
    };
    constructor.keyFrame = function(trackNumber, timecode, frame) {
        var be = new MkvBlock(MkvBlock.SIMPLEBLOCK_ID);
        be.frames = [frame];
        be.frameSizes = new Int32Array([frame.limit()]);
        be._keyFrame = true;
        be.trackNumber = trackNumber;
        be.timecode = timecode;
        return be;
    };
    prototype.readChannel = function(is) {
        var bb = ByteBuffer.allocate(stjs.trunc(100));
        is.read(bb);
        bb.flip();
        this.read(bb);
        is.setPosition(this.dataOffset + this.dataLen);
    };
    prototype.read = function(source) {
        var bb = source.slice();
        this.trackNumber = MkvBlock.ebmlDecode(bb);
        var tcPart1 = bb.get() & 255;
        var tcPart2 = bb.get() & 255;
        this.timecode = ((((((tcPart1) << 16 >> 16) << 8) | ((tcPart2) << 16 >> 16))) << 16 >> 16);
        var flags = bb.get() & 255;
        this._keyFrame = (flags & 128) > 0;
        this.discardable = (flags & 1) > 0;
        var laceFlags = flags & 6;
        this.lacingPresent = laceFlags != 0;
        if (this.lacingPresent) {
            var lacesCount = bb.get() & 255;
            this.frameSizes = new Int32Array(lacesCount + 1);
            if (laceFlags == 2) {
                this.lacing = MkvBlock.XIPH;
                this.headerSize = MkvBlock.readXiphLaceSizes(bb, this.frameSizes, stjs.trunc(this.dataLen), bb.position());
            } else if (laceFlags == 6) {
                this.lacing = MkvBlock.EBML;
                this.headerSize = MkvBlock.readEBMLLaceSizes(bb, this.frameSizes, stjs.trunc(this.dataLen), bb.position());
            } else if (laceFlags == 4) {
                this.lacing = MkvBlock.FIXED;
                this.headerSize = bb.position();
                var aLaceSize = stjs.trunc((stjs.trunc((this.dataLen - this.headerSize) / (lacesCount + 1))));
                Arrays.fill(this.frameSizes, aLaceSize);
            } else {
                 throw new RuntimeException("Unsupported lacing type flag.");
            }
            this.turnSizesToFrameOffsets(this.frameSizes);
        } else {
            this.lacing = "";
            var frameOffset = bb.position();
            this.frameOffsets = new Int32Array(1);
            this.frameOffsets[0] = frameOffset;
            this.headerSize = bb.position();
            this.frameSizes = new Int32Array(1);
            this.frameSizes[0] = stjs.trunc((this.dataLen - this.headerSize));
        }
    };
    prototype.turnSizesToFrameOffsets = function(sizes) {
        this.frameOffsets = new Int32Array(sizes.length);
        this.frameOffsets[0] = this.headerSize;
        for (var i = 1; i < sizes.length; i++) 
            this.frameOffsets[i] = this.frameOffsets[i - 1] + sizes[i - 1];
    };
    constructor.readXiphLaceSizes = function(bb, sizes, size, preLacingHeaderSize) {
        var startPos = bb.position();
        var lastIndex = sizes.length - 1;
        sizes[lastIndex] = size;
        for (var l = 0; l < lastIndex; l++) {
            var laceSize = 255;
             while (laceSize == 255){
                laceSize = bb.get() & 255;
                sizes[l] += laceSize;
            }
            sizes[lastIndex] -= sizes[l];
        }
        var headerSize = (bb.position() - startPos) + preLacingHeaderSize;
        sizes[lastIndex] -= headerSize;
        return headerSize;
    };
    constructor.readEBMLLaceSizes = function(source, sizes, size, preLacingHeaderSize) {
        var lastIndex = sizes.length - 1;
        sizes[lastIndex] = size;
        var startPos = source.position();
        sizes[0] = ((MkvBlock.ebmlDecode(source)) | 0);
        sizes[lastIndex] -= sizes[0];
        var laceSize = sizes[0];
        var laceSizeDiff = 0;
        for (var l = 1; l < lastIndex; l++) {
            laceSizeDiff = MkvBlock.ebmlDecodeSigned(source);
            laceSize += laceSizeDiff;
            sizes[l] = laceSize;
            sizes[lastIndex] -= sizes[l];
        }
        var headerSize = (source.position() - startPos) + preLacingHeaderSize;
        sizes[lastIndex] -= headerSize;
        return headerSize;
    };
    prototype.toString = function() {
        var sb = new StringBuilder();
        sb.append("{dataOffset: ").append(this.dataOffset);
        sb.append(", trackNumber: ").append(this.trackNumber);
        sb.append(", timecode: ").append(this.timecode);
        sb.append(", keyFrame: ").append(this._keyFrame);
        sb.append(", headerSize: ").append(this.headerSize);
        sb.append(", lacing: ").append(this.lacing);
        for (var i = 0; i < this.frameSizes.length; i++) 
            sb.append(", frame[").append(i).append("]  offset ").append(this.frameOffsets[i]).append(" size ").append(this.frameSizes[i]);
        sb.append(" }");
        return sb.toString();
    };
    prototype.getFrames = function(source) {
        var frames = Array(this.frameSizes.length);
        for (var i = 0; i < this.frameSizes.length; i++) {
            if (this.frameOffsets[i] > source.limit()) 
                System.err.println("frame offset: " + this.frameOffsets[i] + " limit: " + source.limit());
            source.setPosition(this.frameOffsets[i]);
            var bb = source.slice();
            bb.setLimit(this.frameSizes[i]);
            frames[i] = bb;
        }
        return frames;
    };
    prototype.readFrames = function(source) {
        this.frames = this.getFrames(source);
    };
    prototype.getData = function() {
        var dataSize = stjs.trunc(this.getDataSize());
        var bb = ByteBuffer.allocate(dataSize + EbmlUtil.ebmlLength(dataSize) + this.id.length);
        bb.putArr(this.id);
        bb.putArr(EbmlUtil.ebmlEncode(dataSize));
        bb.putArr(EbmlUtil.ebmlEncode(this.trackNumber));
        bb.put((((this.timecode >>> 8) & 255) << 24 >> 24));
        bb.put(((this.timecode & 255) << 24 >> 24));
        var flags = 0;
        if (MkvBlock.XIPH.equals(this.lacing)) {
            flags = 2;
        } else if (MkvBlock.EBML.equals(this.lacing)) {
            flags = 6;
        } else if (MkvBlock.FIXED.equals(this.lacing)) {
            flags = 4;
        }
        if (this.discardable) 
            flags |= 1;
        if (this._keyFrame) 
            flags |= 128;
        bb.put(flags);
        if ((flags & 6) != 0) {
            bb.put((((this.frames.length - 1) & 255) << 24 >> 24));
            bb.putArr(this.muxLacingInfo());
        }
        for (var i = 0; i < this.frames.length; i++) {
            var frame = this.frames[i];
            bb.putBuf(frame);
        }
        bb.flip();
        return bb;
    };
    prototype.seekAndReadContent = function(source) {
        this.data = ByteBuffer.allocate(stjs.trunc(this.dataLen));
        source.position(this.dataOffset);
        source.read(this.data);
        this.data.flip();
    };
    /**
     *  Get the total size of this element
     */
    prototype.size = function() {
        var size = this.getDataSize();
        size += EbmlUtil.ebmlLength(size);
        size += this.id.length;
        return size;
    };
    prototype.getDataSize = function() {
        var size = 0;
        for (var index$fsize = 0, arr$fsize = this.frameSizes; index$fsize < arr$fsize.length; index$fsize++) {
            var fsize = arr$fsize[index$fsize];
            size += fsize;
        }
        if (this.lacingPresent) {
            size += this.muxLacingInfo().length;
            size += 1;
        }
        size += 3;
        size += EbmlUtil.ebmlLength(this.trackNumber);
        return size;
    };
    prototype.muxLacingInfo = function() {
        if (MkvBlock.EBML.equals(this.lacing)) 
            return MkvBlock.muxEbmlLacing(this.frameSizes);
        if (MkvBlock.XIPH.equals(this.lacing)) 
            return MkvBlock.muxXiphLacing(this.frameSizes);
        if (MkvBlock.FIXED.equals(this.lacing)) 
            return new Int8Array(0);
        return null;
    };
    constructor.ebmlDecode = function(bb) {
        var firstByte = bb.get();
        var length = EbmlUtil.computeLength(firstByte);
        if (length == 0) 
             throw new RuntimeException("Invalid ebml integer size.");
        var value = firstByte & (255 >>> length);
        length--;
         while (length > 0){
            value = (value << 8) | (bb.get() & 255);
            length--;
        }
        return value;
    };
    constructor.ebmlDecodeSigned = function(source) {
        var firstByte = source.get();
        var size = EbmlUtil.computeLength(firstByte);
        if (size == 0) 
             throw new RuntimeException("Invalid ebml integer size.");
        var value = firstByte & (255 >>> size);
        var remaining = size - 1;
         while (remaining > 0){
            value = (value << 8) | (source.get() & 255);
            remaining--;
        }
        return value - EbmlSint.signedComplement[size];
    };
    constructor.calcEbmlLacingDiffs = function(laceSizes) {
        var lacesCount = laceSizes.length - 1;
        var out = Array(lacesCount);
        out[0] = stjs.trunc(laceSizes[0]);
        for (var i = 1; i < lacesCount; i++) {
            out[i] = laceSizes[i] - laceSizes[i - 1];
        }
        return out;
    };
    constructor.muxEbmlLacing = function(laceSizes) {
        var bytes = ByteArrayList.createByteArrayList();
        var laceSizeDiffs = MkvBlock.calcEbmlLacingDiffs(laceSizes);
        bytes.addAll(EbmlUtil.ebmlEncode(laceSizeDiffs[0]));
        for (var i = 1; i < laceSizeDiffs.length; i++) {
            bytes.addAll(EbmlSint.convertToBytes(laceSizeDiffs[i]));
        }
        return bytes.toArray();
    };
    constructor.muxXiphLacing = function(laceSizes) {
        var bytes = ByteArrayList.createByteArrayList();
        for (var i = 0; i < laceSizes.length - 1; i++) {
            var laceSize = laceSizes[i];
             while (laceSize >= 255){
                bytes.add((255 << 24 >> 24));
                laceSize -= 255;
            }
            bytes.add((laceSize << 24 >> 24));
        }
        return bytes.toArray();
    };
}, {frameOffsets: "Int32Array", frameSizes: "Int32Array", frames: "Array", BLOCK_ID: "Int8Array", SIMPLEBLOCK_ID: "Int8Array", data: "ByteBuffer", parent: "EbmlMaster", type: "MKVType", id: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Mp3Bitstream = function() {};
Mp3Bitstream = stjs.extend(Mp3Bitstream, null, [], function(constructor, prototype) {
    constructor.MP3SideInfo = function() {
        this.scfsi = Array.apply(null, Array(2)).map(function() {
            return new Int8Array(4);
        });
        this.granule = [[new Mp3Bitstream.Granule(), new Mp3Bitstream.Granule()], [new Mp3Bitstream.Granule(), new Mp3Bitstream.Granule()]];
    };
    constructor.MP3SideInfo = stjs.extend(constructor.MP3SideInfo, null, [], function(constructor, prototype) {
        prototype.mainDataBegin = 0;
        prototype.privateBits = 0;
        prototype.scfsi = null;
        prototype.granule = null;
    }, {scfsi: "Array", granule: "Array"}, {});
    constructor.Granule = function() {
        this.tableSelect = new Int32Array(3);
        this.subblockGain = new Int32Array(3);
    };
    constructor.Granule = stjs.extend(constructor.Granule, null, [], function(constructor, prototype) {
        prototype.part23Length = 0;
        prototype.bigValues = 0;
        prototype.globalGain = 0;
        prototype.scalefacCompress = 0;
        prototype.windowSwitchingFlag = false;
        prototype.blockType = 0;
        prototype.mixedBlockFlag = false;
        prototype.tableSelect = null;
        prototype.subblockGain = null;
        prototype.region0Count = 0;
        prototype.region1Count = 0;
        prototype.preflag = false;
        prototype.scalefacScale = 0;
        prototype.count1tableSelect = 0;
    }, {tableSelect: "Int32Array", subblockGain: "Int32Array"}, {});
    constructor.ScaleFactors = function() {
        this.large = new Int32Array(23);
        this.small = Array.apply(null, Array(3)).map(function() {
            return new Int32Array(13);
        });
    };
    constructor.ScaleFactors = stjs.extend(constructor.ScaleFactors, null, [], function(constructor, prototype) {
        prototype.large = null;
        prototype.small = null;
    }, {large: "Int32Array", small: "Array"}, {});
    constructor.readSideInfo = function(header, src, channels) {
        var si = new Mp3Bitstream.MP3SideInfo();
        var stream = BitReader.createBitReader(src);
        if (header.version == MpaConst.MPEG1) {
            si.mainDataBegin = stream.readNBit(9);
            if (channels == 1) 
                si.privateBits = stream.readNBit(5);
             else 
                si.privateBits = stream.readNBit(3);
            for (var ch = 0; ch < channels; ch++) {
                si.scfsi[ch][0] = stream.read1Bit() == 0;
                si.scfsi[ch][1] = stream.read1Bit() == 0;
                si.scfsi[ch][2] = stream.read1Bit() == 0;
                si.scfsi[ch][3] = stream.read1Bit() == 0;
            }
            for (var gr = 0; gr < 2; gr++) {
                for (var ch = 0; ch < channels; ch++) {
                    var granule = si.granule[ch][gr];
                    granule.part23Length = stream.readNBit(12);
                    granule.bigValues = stream.readNBit(9);
                    granule.globalGain = stream.readNBit(8);
                    granule.scalefacCompress = stream.readNBit(4);
                    granule.windowSwitchingFlag = stream.readNBit(1) != 0;
                    if (granule.windowSwitchingFlag) {
                        granule.blockType = stream.readNBit(2);
                        granule.mixedBlockFlag = stream.readNBit(1) != 0;
                        granule.tableSelect[0] = stream.readNBit(5);
                        granule.tableSelect[1] = stream.readNBit(5);
                        granule.subblockGain[0] = stream.readNBit(3);
                        granule.subblockGain[1] = stream.readNBit(3);
                        granule.subblockGain[2] = stream.readNBit(3);
                        if (granule.blockType == 0) {
                            return null;
                        } else if (granule.blockType == 2 && !granule.mixedBlockFlag) {
                            granule.region0Count = 8;
                        } else {
                            granule.region0Count = 7;
                        }
                        granule.region1Count = 20 - granule.region0Count;
                    } else {
                        granule.tableSelect[0] = stream.readNBit(5);
                        granule.tableSelect[1] = stream.readNBit(5);
                        granule.tableSelect[2] = stream.readNBit(5);
                        granule.region0Count = stream.readNBit(4);
                        granule.region1Count = stream.readNBit(3);
                        granule.blockType = 0;
                    }
                    granule.preflag = stream.readNBit(1) != 0;
                    granule.scalefacScale = stream.readNBit(1);
                    granule.count1tableSelect = stream.readNBit(1);
                }
            }
        } else {
            si.mainDataBegin = stream.readNBit(8);
            if (channels == 1) 
                si.privateBits = stream.readNBit(1);
             else 
                si.privateBits = stream.readNBit(2);
            for (var ch = 0; ch < channels; ch++) {
                var granule = si.granule[ch][0];
                granule.part23Length = stream.readNBit(12);
                granule.bigValues = stream.readNBit(9);
                granule.globalGain = stream.readNBit(8);
                granule.scalefacCompress = stream.readNBit(9);
                granule.windowSwitchingFlag = stream.readNBit(1) != 0;
                if (granule.windowSwitchingFlag) {
                    granule.blockType = stream.readNBit(2);
                    granule.mixedBlockFlag = stream.readNBit(1) != 0;
                    granule.tableSelect[0] = stream.readNBit(5);
                    granule.tableSelect[1] = stream.readNBit(5);
                    granule.subblockGain[0] = stream.readNBit(3);
                    granule.subblockGain[1] = stream.readNBit(3);
                    granule.subblockGain[2] = stream.readNBit(3);
                    if (granule.blockType == 0) {
                        return null;
                    } else if (granule.blockType == 2 && !granule.mixedBlockFlag) {
                        granule.region0Count = 8;
                    } else {
                        granule.region0Count = 7;
                        granule.region1Count = 20 - granule.region0Count;
                    }
                } else {
                    granule.tableSelect[0] = stream.readNBit(5);
                    granule.tableSelect[1] = stream.readNBit(5);
                    granule.tableSelect[2] = stream.readNBit(5);
                    granule.region0Count = stream.readNBit(4);
                    granule.region1Count = stream.readNBit(3);
                    granule.blockType = 0;
                }
                granule.scalefacScale = stream.readNBit(1);
                granule.count1tableSelect = stream.readNBit(1);
            }
        }
        stream.terminate();
        return si;
    };
    constructor.readScaleFactors = function(br, granule, b) {
        if (granule.windowSwitchingFlag && (granule.blockType == 2)) {
            if (granule.mixedBlockFlag) {
                return Mp3Bitstream.readScaleFacMixed(br, granule);
            } else {
                return Mp3Bitstream.readScaleFacShort(br, granule);
            }
        } else {
            return Mp3Bitstream.readScaleFacNonSwitch(br, granule, b);
        }
    };
    constructor.readScaleFacMixed = function(br, granule) {
        var sf = new Mp3Bitstream.ScaleFactors();
        for (var sfb = 0; sfb < 8; sfb++) 
            sf.large[sfb] = br.readNBit(MpaConst.scaleFactorLen[0][granule.scalefacCompress]);
        for (var sfb = 3; sfb < 6; sfb++) 
            for (var window = 0; window < 3; window++) 
                sf.small[window][sfb] = br.readNBit(MpaConst.scaleFactorLen[0][granule.scalefacCompress]);
        for (var sfb = 6; sfb < 12; sfb++) 
            for (var window = 0; window < 3; window++) 
                sf.small[window][sfb] = br.readNBit(MpaConst.scaleFactorLen[1][granule.scalefacCompress]);
        for (var sfb = 12, window = 0; window < 3; window++) 
            sf.small[window][sfb] = 0;
        return sf;
    };
    constructor.readScaleFacNonSwitch = function(br, granule, b) {
        var sf = new Mp3Bitstream.ScaleFactors();
        var length0 = MpaConst.scaleFactorLen[0][granule.scalefacCompress];
        var length1 = MpaConst.scaleFactorLen[1][granule.scalefacCompress];
        if (b[0]) {
            for (var i = 0; i < 6; i++) 
                sf.large[i] = br.readNBit(length0);
        }
        if (b[1]) {
            for (var i = 6; i < 11; i++) 
                sf.large[i] = br.readNBit(length0);
        }
        if (b[2]) {
            for (var i = 11; i < 16; i++) 
                sf.large[i] = br.readNBit(length1);
        }
        if (b[3]) {
            for (var i = 16; i < 21; i++) 
                sf.large[i] = br.readNBit(length1);
        }
        sf.large[21] = 0;
        sf.large[22] = 0;
        return sf;
    };
    constructor.readScaleFacShort = function(br, granule) {
        var sf = new Mp3Bitstream.ScaleFactors();
        var length0 = MpaConst.scaleFactorLen[0][granule.scalefacCompress];
        var length1 = MpaConst.scaleFactorLen[1][granule.scalefacCompress];
        for (var i = 0; i < 6; i++) {
            for (var j = 0; j < 3; j++) 
                sf.small[j][i] = br.readNBit(length0);
        }
        for (var i = 6; i < 12; i++) {
            for (var j = 0; j < 3; j++) 
                sf.small[j][i] = br.readNBit(length1);
        }
        sf.small[0][12] = 0;
        sf.small[1][12] = 0;
        sf.small[2][12] = 0;
        return sf;
    };
    constructor.readLSFScaleFactors = function(br, header, granule, ch) {
        var scalefac = new Mp3Bitstream.ScaleFactors();
        var scalefacBuffer = Mp3Bitstream.readLSFScaleData(br, header, granule, ch);
        var m = 0;
        if (granule.windowSwitchingFlag && granule.blockType == 2) {
            if (granule.mixedBlockFlag) {
                for (var sfb = 0; sfb < 8; sfb++) {
                    scalefac.large[sfb] = scalefacBuffer[m];
                    m++;
                }
                for (var sfb = 3; sfb < 12; sfb++) {
                    for (var window = 0; window < 3; window++) {
                        scalefac.small[window][sfb] = scalefacBuffer[m];
                        m++;
                    }
                }
                for (var window = 0; window < 3; window++) 
                    scalefac.small[window][12] = 0;
            } else {
                for (var sfb = 0; sfb < 12; sfb++) {
                    for (var window = 0; window < 3; window++) {
                        scalefac.small[window][sfb] = scalefacBuffer[m];
                        m++;
                    }
                }
                for (var window = 0; window < 3; window++) 
                    scalefac.small[window][12] = 0;
            }
        } else {
            for (var sfb = 0; sfb < 21; sfb++) {
                scalefac.large[sfb] = scalefacBuffer[m];
                m++;
            }
            scalefac.large[21] = 0;
            scalefac.large[22] = 0;
        }
        return scalefac;
    };
    constructor.readLSFScaleData = function(br, header, granule, ch) {
        var result = new Int32Array(54);
        var scaleFacLen = new Int32Array(4);
        var comp = granule.scalefacCompress;
        var blockType = granule.blockType == 2 ? (granule.mixedBlockFlag ? 2 : 1) : 0;
        var ch1 = (header.modeExtension == 1 || header.modeExtension == 3) && (ch == 1);
        var lenType = 0;
        if (!ch1) {
            if (comp < 400) {
                scaleFacLen[0] = stjs.trunc((comp >>> 4) / 5);
                scaleFacLen[1] = (comp >>> 4) % 5;
                scaleFacLen[2] = (comp & 15) >>> 2;
                scaleFacLen[3] = (comp & 3);
                granule.preflag = false;
                lenType = 0;
            } else if (comp < 500) {
                scaleFacLen[0] = stjs.trunc(((comp - 400) >>> 2) / 5);
                scaleFacLen[1] = ((comp - 400) >>> 2) % 5;
                scaleFacLen[2] = (comp - 400) & 3;
                scaleFacLen[3] = 0;
                granule.preflag = false;
                lenType = 1;
            } else if (comp < 512) {
                scaleFacLen[0] = stjs.trunc((comp - 500) / 3);
                scaleFacLen[1] = (comp - 500) % 3;
                scaleFacLen[2] = 0;
                scaleFacLen[3] = 0;
                granule.preflag = true;
                lenType = 2;
            }
        } else {
            var halfComp = comp >>> 1;
            if (halfComp < 180) {
                scaleFacLen[0] = stjs.trunc(halfComp / 36);
                scaleFacLen[1] = stjs.trunc((halfComp % 36) / 6);
                scaleFacLen[2] = (halfComp % 36) % 6;
                scaleFacLen[3] = 0;
                granule.preflag = false;
                lenType = 3;
            } else if (halfComp < 244) {
                scaleFacLen[0] = ((halfComp - 180) & 63) >>> 4;
                scaleFacLen[1] = ((halfComp - 180) & 15) >>> 2;
                scaleFacLen[2] = (halfComp - 180) & 3;
                scaleFacLen[3] = 0;
                granule.preflag = false;
                lenType = 4;
            } else if (halfComp < 255) {
                scaleFacLen[0] = stjs.trunc((halfComp - 244) / 3);
                scaleFacLen[1] = (halfComp - 244) % 3;
                scaleFacLen[2] = 0;
                scaleFacLen[3] = 0;
                granule.preflag = false;
                lenType = 5;
            }
        }
        for (var i = 0, m = 0; i < 4; i++) {
            for (var j = 0; j < MpaConst.numberOfScaleFactors[lenType][blockType][i]; j++ , m++) {
                result[m] = (scaleFacLen[i] == 0) ? 0 : br.readNBit(scaleFacLen[i]);
            }
        }
        return result;
    };
    constructor.readCoeffs = function(br, granule, ch, part2_start, sfreq, out) {
        var part23End = part2_start + granule.part23Length;
        var region1Start = (sfreq == 8) ? 72 : 36;
        var region2Start = 576;
        if (!granule.windowSwitchingFlag || granule.blockType != 2) {
            var region1StartIdx = MathUtil.clip(granule.region0Count + granule.region1Count + 2, 0, MpaConst.sfbLong[sfreq].length - 1);
            region1Start = MpaConst.sfbLong[sfreq][granule.region0Count + 1];
            region2Start = MpaConst.sfbLong[sfreq][region1StartIdx];
        }
        var index = 0;
        for (var i = 0; i < (granule.bigValues << 1); i += 2) {
            var tab = 0;
            if (i < region1Start) 
                tab = granule.tableSelect[0];
             else if (i < region2Start) 
                tab = granule.tableSelect[1];
             else 
                tab = granule.tableSelect[2];
            if (tab == 0 || tab == 4 || tab == 14) {
                out[index++] = 0;
                out[index++] = 0;
            } else {
                var packed = Mp3Bitstream.readBigVal(tab, br);
                out[index++] = Vector2Int.el16_0(packed);
                out[index++] = Vector2Int.el16_1(packed);
            }
        }
         while (br.position() < part23End && index < 576){
            var packed = Mp3Bitstream.readCount1(granule.count1tableSelect, br);
            out[index++] = Vector4Int.el8_0(packed);
            out[index++] = Vector4Int.el8_1(packed);
            out[index++] = Vector4Int.el8_2(packed);
            out[index++] = Vector4Int.el8_3(packed);
        }
        if (br.position() < part23End) 
            br.readNBit(part23End - br.position());
        return MathUtil.clip(index, 0, 576);
    };
    constructor.readBigVal = function(tab, br) {
        var res = MpaConst.bigValVlc[tab].readVLC(br);
        var x = res >>> 4;
        var y = res & 15;
        if (MpaConst.bigValEscBits[tab] != 0) 
            if ((MpaConst.bigValMaxval[tab] - 1) == x) 
                x += br.readNBit(MpaConst.bigValEscBits[tab]);
        if (x != 0) 
            if (br.read1Bit() != 0) 
                x = -x;
        if (MpaConst.bigValEscBits[tab] != 0) 
            if ((MpaConst.bigValMaxval[tab] - 1) == y) 
                y += br.readNBit(MpaConst.bigValEscBits[tab]);
        if (y != 0) 
            if (br.read1Bit() != 0) 
                y = -y;
        return Vector2Int.pack16(x, y);
    };
    constructor.readCount1 = function(tab, br) {
        var res = (tab == 0 ? MpaConst.cnt1A : MpaConst.cnt1B).readVLC(br);
        var v = (res >> 3) & 1;
        var w = (res >> 2) & 1;
        var x = (res >> 1) & 1;
        var y = res & 1;
        if (v != 0) 
            if (br.read1Bit() != 0) 
                v = -v;
        if (w != 0) 
            if (br.read1Bit() != 0) 
                w = -w;
        if (x != 0) 
            if (br.read1Bit() != 0) 
                x = -x;
        if (y != 0) 
            if (br.read1Bit() != 0) 
                y = -y;
        return Vector4Int.pack8(v, w, x, y);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Header for MPEG Audio (MPEG 1 audio layer 2 and 3).
 *  
 *  @author The JCodec project
 */
var MpaHeader = function() {};
MpaHeader = stjs.extend(MpaHeader, null, [], function(constructor, prototype) {
    prototype.layer = 0;
    prototype.protectionBit = 0;
    prototype.bitrateIndex = 0;
    prototype.paddingBit = 0;
    prototype.modeExtension = 0;
    prototype.version = 0;
    prototype.mode = 0;
    prototype.sampleFreq = 0;
    prototype.numSubbands = 0;
    prototype.intensityStereoBound = 0;
    prototype.copyright = false;
    prototype.original = false;
    prototype.framesize = 0;
    prototype.frameBytes = 0;
    constructor.read_header = function(bb) {
        var ret = new MpaHeader();
        var headerstring;
        var channel_bitrate;
        headerstring = bb.getInt();
        ret.version = ((headerstring >>> 19) & 1);
        if (((headerstring >>> 20) & 1) == 0) 
            if (ret.version == MpaConst.MPEG2_LSF) 
                ret.version = MpaConst.MPEG25_LSF;
             else 
                 throw new RuntimeException("UNKNOWN_ERROR");
        if ((ret.sampleFreq = ((headerstring >>> 10) & 3)) == 3) {
             throw new RuntimeException("UNKNOWN_ERROR");
        }
        ret.layer = 4 - (headerstring >>> 17) & 3;
        ret.protectionBit = (headerstring >>> 16) & 1;
        ret.bitrateIndex = (headerstring >>> 12) & 15;
        ret.paddingBit = (headerstring >>> 9) & 1;
        ret.mode = ((headerstring >>> 6) & 3);
        ret.modeExtension = (headerstring >>> 4) & 3;
        if (ret.mode == MpaConst.JOINT_STEREO) 
            ret.intensityStereoBound = (ret.modeExtension << 2) + 4;
         else 
            ret.intensityStereoBound = 0;
        if (((headerstring >>> 3) & 1) == 1) 
            ret.copyright = true;
        if (((headerstring >>> 2) & 1) == 1) 
            ret.original = true;
        if (ret.layer == 1) 
            ret.numSubbands = 32;
         else {
            channel_bitrate = ret.bitrateIndex;
            if (ret.mode != MpaConst.SINGLE_CHANNEL) 
                if (channel_bitrate == 4) 
                    channel_bitrate = 1;
                 else 
                    channel_bitrate -= 4;
            if ((channel_bitrate == 1) || (channel_bitrate == 2)) 
                if (ret.sampleFreq == MpaConst.SAMPLE_FREQ_32K) 
                    ret.numSubbands = 12;
                 else 
                    ret.numSubbands = 8;
             else if ((ret.sampleFreq == MpaConst.SAMPLE_FREQ_48K) || ((channel_bitrate >= 3) && (channel_bitrate <= 5))) 
                ret.numSubbands = 27;
             else 
                ret.numSubbands = 30;
        }
        if (ret.intensityStereoBound > ret.numSubbands) 
            ret.intensityStereoBound = ret.numSubbands;
        MpaHeader.calculateFramesize(ret);
        return ret;
    };
    constructor.calculateFramesize = function(ret) {
        if (ret.layer == 1) {
            ret.framesize = stjs.trunc((12 * MpaConst.bitrates[ret.version][0][ret.bitrateIndex]) / MpaConst.frequencies[ret.version][ret.sampleFreq]);
            if (ret.paddingBit != 0) 
                ret.framesize++;
            ret.framesize <<= 2;
            ret.frameBytes = 0;
        } else {
            ret.framesize = stjs.trunc((144 * MpaConst.bitrates[ret.version][ret.layer - 1][ret.bitrateIndex]) / MpaConst.frequencies[ret.version][ret.sampleFreq]);
            if (ret.version == MpaConst.MPEG2_LSF || ret.version == MpaConst.MPEG25_LSF) 
                ret.framesize >>= 1;
            if (ret.paddingBit != 0) 
                ret.framesize++;
            if (ret.layer == 3) {
                if (ret.version == MpaConst.MPEG1) {
                    ret.frameBytes = ret.framesize - ((ret.mode == MpaConst.SINGLE_CHANNEL) ? 17 : 32) - ((ret.protectionBit != 0) ? 0 : 2) - 4;
                } else {
                    ret.frameBytes = ret.framesize - ((ret.mode == MpaConst.SINGLE_CHANNEL) ? 9 : 17) - ((ret.protectionBit != 0) ? 0 : 2) - 4;
                }
            } else {
                ret.frameBytes = 0;
            }
        }
        ret.framesize -= 4;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var MpaPqmf = function() {};
MpaPqmf = stjs.extend(MpaPqmf, null, [], function(constructor, prototype) {
    constructor.MY_PI = 3.141592653589793;
    constructor.cos1_64 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI / 64.0)));
    constructor.cos3_64 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 3.0 / 64.0)));
    constructor.cos5_64 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 5.0 / 64.0)));
    constructor.cos7_64 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 7.0 / 64.0)));
    constructor.cos9_64 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 9.0 / 64.0)));
    constructor.cos11_64 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 11.0 / 64.0)));
    constructor.cos13_64 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 13.0 / 64.0)));
    constructor.cos15_64 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 15.0 / 64.0)));
    constructor.cos17_64 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 17.0 / 64.0)));
    constructor.cos19_64 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 19.0 / 64.0)));
    constructor.cos21_64 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 21.0 / 64.0)));
    constructor.cos23_64 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 23.0 / 64.0)));
    constructor.cos25_64 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 25.0 / 64.0)));
    constructor.cos27_64 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 27.0 / 64.0)));
    constructor.cos29_64 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 29.0 / 64.0)));
    constructor.cos31_64 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 31.0 / 64.0)));
    constructor.cos1_32 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI / 32.0)));
    constructor.cos3_32 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 3.0 / 32.0)));
    constructor.cos5_32 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 5.0 / 32.0)));
    constructor.cos7_32 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 7.0 / 32.0)));
    constructor.cos9_32 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 9.0 / 32.0)));
    constructor.cos11_32 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 11.0 / 32.0)));
    constructor.cos13_32 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 13.0 / 32.0)));
    constructor.cos15_32 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 15.0 / 32.0)));
    constructor.cos1_16 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI / 16.0)));
    constructor.cos3_16 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 3.0 / 16.0)));
    constructor.cos5_16 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 5.0 / 16.0)));
    constructor.cos7_16 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 7.0 / 16.0)));
    constructor.cos1_8 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI / 8.0)));
    constructor.cos3_8 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI * 3.0 / 8.0)));
    constructor.cos1_4 = (1.0 / (2.0 * Math.cos(MpaPqmf.MY_PI / 4.0)));
    constructor.bf32 = new Float32Array([MpaPqmf.cos1_64, MpaPqmf.cos3_64, MpaPqmf.cos5_64, MpaPqmf.cos7_64, MpaPqmf.cos9_64, MpaPqmf.cos11_64, MpaPqmf.cos13_64, MpaPqmf.cos15_64, MpaPqmf.cos17_64, MpaPqmf.cos19_64, MpaPqmf.cos21_64, MpaPqmf.cos23_64, MpaPqmf.cos25_64, MpaPqmf.cos27_64, MpaPqmf.cos29_64, MpaPqmf.cos31_64]);
    constructor.bf16 = new Float32Array([MpaPqmf.cos1_32, MpaPqmf.cos3_32, MpaPqmf.cos5_32, MpaPqmf.cos7_32, MpaPqmf.cos9_32, MpaPqmf.cos11_32, MpaPqmf.cos13_32, MpaPqmf.cos15_32]);
    constructor.bf8 = new Float32Array([MpaPqmf.cos1_16, MpaPqmf.cos3_16, MpaPqmf.cos5_16, MpaPqmf.cos7_16]);
    constructor.computeFilter = function(sampleOff, samples, out, outOff, scalefactor) {
        var dvp = 0;
        for (var i = 0; i < 32; i++) {
            var pcm_sample;
            var b = i << 4;
            pcm_sample = ((samples[((16 + sampleOff) & 15) + dvp] * MpaConst.dp[b + 0] + samples[((15 + sampleOff) & 15) + dvp] * MpaConst.dp[b + 1] + samples[((14 + sampleOff) & 15) + dvp] * MpaConst.dp[b + 2] + samples[((13 + sampleOff) & 15) + dvp] * MpaConst.dp[b + 3] + samples[((12 + sampleOff) & 15) + dvp] * MpaConst.dp[b + 4] + samples[((11 + sampleOff) & 15) + dvp] * MpaConst.dp[b + 5] + samples[((10 + sampleOff) & 15) + dvp] * MpaConst.dp[b + 6] + samples[((9 + sampleOff) & 15) + dvp] * MpaConst.dp[b + 7] + samples[((8 + sampleOff) & 15) + dvp] * MpaConst.dp[b + 8] + samples[((7 + sampleOff) & 15) + dvp] * MpaConst.dp[b + 9] + samples[((6 + sampleOff) & 15) + dvp] * MpaConst.dp[b + 10] + samples[((5 + sampleOff) & 15) + dvp] * MpaConst.dp[b + 11] + samples[((4 + sampleOff) & 15) + dvp] * MpaConst.dp[b + 12] + samples[((3 + sampleOff) & 15) + dvp] * MpaConst.dp[b + 13] + samples[((2 + sampleOff) & 15) + dvp] * MpaConst.dp[b + 14] + samples[((1 + sampleOff) & 15) + dvp] * MpaConst.dp[b + 15]) * scalefactor);
            out[outOff + i] = ((MathUtil.clip(stjs.trunc(pcm_sample), -32768, 32767)) << 16 >> 16);
            dvp += 16;
        }
    };
    constructor.computeButterfly = function(pos, s) {
        MpaPqmf.butterfly32(s);
        MpaPqmf.butterfly16L(s);
        MpaPqmf.butterfly16H(s);
        MpaPqmf.butterfly8L(s, 0);
        MpaPqmf.butterfly8H(s, 0);
        MpaPqmf.butterfly8L(s, 16);
        MpaPqmf.butterfly8H(s, 16);
        for (var i = 0; i < 32; i += 8) {
            MpaPqmf.butterfly4L(s, i);
            MpaPqmf.butterfly4H(s, i);
        }
        for (var i = 0; i < 32; i += 4) {
            MpaPqmf.butterfly2L(s, i);
            MpaPqmf.butterfly2H(s, i);
        }
        var k0 = -s[14] - s[15] - s[10] - s[11];
        var k1 = s[29] + s[31] + s[25];
        var k2 = k1 + s[17];
        var k3 = k1 + s[21] + s[23];
        var k4 = s[15] + s[11];
        var k5 = s[15] + s[13] + s[9];
        var k6 = s[7] + s[5];
        var k7 = s[31] + s[23];
        var k8 = k7 + s[27];
        var k9 = s[31] + s[27] + s[19];
        var k10 = -s[26] - s[27] - s[30] - s[31];
        var k11 = -s[24] - s[28] - s[30] - s[31];
        var k12 = s[20] + s[22] + s[23];
        var k13 = s[21] + s[29];
        var s0 = s[0];
        var s1 = s[1];
        var s2 = s[2];
        var s3 = s[3];
        var s4 = s[4];
        var s6 = s[6];
        var s7 = s[7];
        var s8 = s[8];
        var s12 = s[12];
        var s13 = s[13];
        var s14 = s[14];
        var s15 = s[15];
        var s16 = s[16];
        var s18 = s[18];
        var s19 = s[19];
        var s21 = s[21];
        var s22 = s[22];
        var s23 = s[23];
        var s28 = s[28];
        var s29 = s[29];
        var s30 = s[30];
        var s31 = s[31];
        s[0] = s1;
        s[1] = k2;
        s[2] = k5;
        s[3] = k3;
        s[4] = k6;
        s[5] = k8 + k13;
        s[6] = k4 + s13;
        s[7] = k9 + s29;
        s[8] = s3;
        s[9] = k9;
        s[10] = k4;
        s[11] = k8;
        s[12] = s7;
        s[13] = k7;
        s[14] = s15;
        s[15] = s31;
        s[16] = -k2 - s30;
        s[17] = -k5 - s14;
        s[18] = -k3 - s22 - s30;
        s[19] = -k6 - s6;
        s[20] = k10 - s29 - s21 - s22 - s23;
        s[21] = k0 - s13;
        s[22] = k10 - s29 - s18 - s19;
        s[23] = -s3 - s2;
        s[24] = k10 - s28 - s18 - s19;
        s[25] = k0 - s12;
        s[26] = k10 - s28 - k12;
        s[27] = -s6 - s7 - s4;
        s[28] = k11 - k12;
        s[29] = -s14 - s15 - s12 - s8;
        s[30] = k11 - s16;
        s[31] = -s0;
    };
    constructor.butterfly16H = function(s) {
        for (var i = 0; i < 8; i++) {
            var tmp0 = s[16 + i];
            var tmp1 = s[31 - i];
            s[16 + i] = tmp0 + tmp1;
            s[31 - i] = -(tmp0 - tmp1) * MpaPqmf.bf16[i];
        }
    };
    constructor.butterfly16L = function(s) {
        for (var i = 0; i < 8; i++) {
            var tmp0 = s[i];
            var tmp1 = s[15 - i];
            s[i] = tmp0 + tmp1;
            s[15 - i] = (tmp0 - tmp1) * MpaPqmf.bf16[i];
        }
    };
    constructor.butterfly8H = function(s, o) {
        for (var i = 0; i < 4; i++) {
            var tmp0 = s[o + 8 + i];
            var tmp1 = s[o + 15 - i];
            s[o + 8 + i] = tmp0 + tmp1;
            s[o + 15 - i] = -(tmp0 - tmp1) * MpaPqmf.bf8[i];
        }
    };
    constructor.butterfly8L = function(s, o) {
        for (var i = 0; i < 4; i++) {
            var tmp0 = s[o + i];
            var tmp1 = s[o + 7 - i];
            s[o + i] = tmp0 + tmp1;
            s[o + 7 - i] = (tmp0 - tmp1) * MpaPqmf.bf8[i];
        }
    };
    constructor.butterfly4H = function(s, o) {
        var tmp0 = s[o + 4];
        var tmp1 = s[o + 7];
        s[o + 4] = tmp0 + tmp1;
        s[o + 7] = -(tmp0 - tmp1) * MpaPqmf.cos1_8;
        var tmp2 = s[o + 5];
        var tmp3 = s[o + 6];
        s[o + 5] = tmp2 + tmp3;
        s[o + 6] = -(tmp2 - tmp3) * MpaPqmf.cos3_8;
    };
    constructor.butterfly4L = function(s, o) {
        var tmp0 = s[o];
        var tmp1 = s[o + 3];
        s[o + 0] = tmp0 + tmp1;
        s[o + 3] = (tmp0 - tmp1) * MpaPqmf.cos1_8;
        var tmp2 = s[o + 1];
        var tmp3 = s[o + 2];
        s[o + 1] = tmp2 + tmp3;
        s[o + 2] = (tmp2 - tmp3) * MpaPqmf.cos3_8;
    };
    constructor.butterfly2H = function(s, o) {
        var tmp0 = s[o + 2];
        var tmp1 = s[o + 3];
        s[o + 2] = tmp0 + tmp1;
        s[o + 3] = -(tmp0 - tmp1) * MpaPqmf.cos1_4;
    };
    constructor.butterfly2L = function(s, o) {
        var tmp0 = s[o];
        var tmp1 = s[o + 1];
        s[o + 0] = tmp0 + tmp1;
        s[o + 1] = (tmp0 - tmp1) * MpaPqmf.cos1_4;
    };
    constructor.butterfly32 = function(s) {
        for (var i = 0; i < 16; i++) {
            var tmp0 = s[i];
            var tmp1 = s[31 - i];
            s[i] = tmp0 + tmp1;
            s[31 - i] = (tmp0 - tmp1) * MpaPqmf.bf32[i];
        }
    };
}, {bf32: "Float32Array", bf16: "Float32Array", bf8: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Prediction builder class for intra 16x16 coded macroblocks
 *  
 *  
 *  @author The JCodec project
 *  
 */
var Intra16x16PredictionBuilder = function() {};
Intra16x16PredictionBuilder = stjs.extend(Intra16x16PredictionBuilder, null, [], function(constructor, prototype) {
    constructor.predictWithMode = function(predMode, residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, x, pixOut) {
        switch (predMode) {
            case 0:
                Intra16x16PredictionBuilder.predictVertical(residual, topAvailable, topLine, x, pixOut);
                break;
            case 1:
                Intra16x16PredictionBuilder.predictHorizontal(residual, leftAvailable, leftRow, x, pixOut);
                break;
            case 2:
                Intra16x16PredictionBuilder.predictDC(residual, leftAvailable, topAvailable, leftRow, topLine, x, pixOut);
                break;
            case 3:
                Intra16x16PredictionBuilder.predictPlane(residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, x, pixOut);
                break;
        }
    };
    constructor.predictVertical = function(residual, topAvailable, topLine, x, pixOut) {
        var off = 0;
        for (var j = 0; j < 16; j++) {
            for (var i = 0; i < 16; i++ , off++) 
                pixOut[off] = (MathUtil.clip(residual[H264Const.LUMA_4x4_BLOCK_LUT[off]][H264Const.LUMA_4x4_POS_LUT[off]] + topLine[x + i], -128, 127) << 24 >> 24);
        }
    };
    constructor.predictHorizontal = function(residual, leftAvailable, leftRow, x, pixOut) {
        var off = 0;
        for (var j = 0; j < 16; j++) {
            for (var i = 0; i < 16; i++ , off++) 
                pixOut[off] = (MathUtil.clip(residual[H264Const.LUMA_4x4_BLOCK_LUT[off]][H264Const.LUMA_4x4_POS_LUT[off]] + leftRow[j], -128, 127) << 24 >> 24);
        }
    };
    constructor.predictDC = function(residual, leftAvailable, topAvailable, leftRow, topLine, x, pixOut) {
        var s0;
        if (leftAvailable && topAvailable) {
            s0 = 0;
            for (var i = 0; i < 16; i++) 
                s0 += leftRow[i];
            for (var i = 0; i < 16; i++) 
                s0 += topLine[x + i];
            s0 = (s0 + 16) >> 5;
        } else if (leftAvailable) {
            s0 = 0;
            for (var i = 0; i < 16; i++) 
                s0 += leftRow[i];
            s0 = (s0 + 8) >> 4;
        } else if (topAvailable) {
            s0 = 0;
            for (var i = 0; i < 16; i++) 
                s0 += topLine[x + i];
            s0 = (s0 + 8) >> 4;
        } else {
            s0 = 0;
        }
        for (var i = 0; i < 256; i++) 
            pixOut[i] = (MathUtil.clip(residual[H264Const.LUMA_4x4_BLOCK_LUT[i]][H264Const.LUMA_4x4_POS_LUT[i]] + s0, -128, 127) << 24 >> 24);
    };
    constructor.predictPlane = function(residual, leftAvailable, topAvailable, leftRow, topLine, topLeft, x, pixOut) {
        var H = 0;
        for (var i = 0; i < 7; i++) {
            H += (i + 1) * (topLine[x + 8 + i] - topLine[x + 6 - i]);
        }
        H += 8 * (topLine[x + 15] - topLeft[0]);
        var V = 0;
        for (var j = 0; j < 7; j++) {
            V += (j + 1) * (leftRow[8 + j] - leftRow[6 - j]);
        }
        V += 8 * (leftRow[15] - topLeft[0]);
        var c = (5 * V + 32) >> 6;
        var b = (5 * H + 32) >> 6;
        var a = 16 * (leftRow[15] + topLine[x + 15]);
        var off = 0;
        for (var j = 0; j < 16; j++) {
            for (var i = 0; i < 16; i++ , off++) {
                var val = MathUtil.clip((a + b * (i - 7) + c * (j - 7) + 16) >> 5, -128, 127);
                pixOut[off] = (MathUtil.clip(residual[H264Const.LUMA_4x4_BLOCK_LUT[off]][H264Const.LUMA_4x4_POS_LUT[off]] + val, -128, 127) << 24 >> 24);
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Prediction merge and weight routines
 *  
 *  @author The JCodec project
 *  
 */
var PredictionMerger = function() {};
PredictionMerger = stjs.extend(PredictionMerger, null, [], function(constructor, prototype) {
    constructor.mergePrediction = function(sh, refIdxL0, refIdxL1, predType, comp, pred0, pred1, off, stride, blkW, blkH, out, refs, thisPoc) {
        var pps = sh.pps;
        if (sh.sliceType == SliceType.P) {
            PredictionMerger.weightPrediction(sh, refIdxL0, comp, pred0, off, stride, blkW, blkH, out);
        } else {
            if (!pps.weightedPredFlag || sh.pps.weightedBipredIdc == 0 || (sh.pps.weightedBipredIdc == 2 && predType != H264Const.PartPred.Bi)) {
                PredictionMerger.mergeAvg(pred0, pred1, stride, predType, off, blkW, blkH, out);
            } else if (sh.pps.weightedBipredIdc == 1) {
                var w = sh.predWeightTable;
                var w0 = refIdxL0 == -1 ? 0 : (comp == 0 ? w.lumaWeight[0][refIdxL0] : w.chromaWeight[0][comp - 1][refIdxL0]);
                var w1 = refIdxL1 == -1 ? 0 : (comp == 0 ? w.lumaWeight[1][refIdxL1] : w.chromaWeight[1][comp - 1][refIdxL1]);
                var o0 = refIdxL0 == -1 ? 0 : (comp == 0 ? w.lumaOffset[0][refIdxL0] : w.chromaOffset[0][comp - 1][refIdxL0]);
                var o1 = refIdxL1 == -1 ? 0 : (comp == 0 ? w.lumaOffset[1][refIdxL1] : w.chromaOffset[1][comp - 1][refIdxL1]);
                PredictionMerger.mergeWeight(pred0, pred1, stride, predType, off, blkW, blkH, comp == 0 ? w.lumaLog2WeightDenom : w.chromaLog2WeightDenom, w0, w1, o0, o1, out);
            } else {
                var tb = MathUtil.clip(thisPoc - refs[0][refIdxL0].getPOC(), -128, 127);
                var td = MathUtil.clip(refs[1][refIdxL1].getPOC() - refs[0][refIdxL0].getPOC(), -128, 127);
                var w0 = 32, w1 = 32;
                if (td != 0 && refs[0][refIdxL0].isShortTerm() && refs[1][refIdxL1].isShortTerm()) {
                    var tx = stjs.trunc((16384 + Math.abs(stjs.trunc(td / 2))) / td);
                    var dsf = MathUtil.clip((tb * tx + 32) >> 6, -1024, 1023) >> 2;
                    if (dsf >= -64 && dsf <= 128) {
                        w1 = dsf;
                        w0 = 64 - dsf;
                    }
                }
                PredictionMerger.mergeWeight(pred0, pred1, stride, predType, off, blkW, blkH, 5, w0, w1, 0, 0, out);
            }
        }
    };
    constructor.weightPrediction = function(sh, refIdxL0, comp, pred0, off, stride, blkW, blkH, out) {
        var pps = sh.pps;
        if (pps.weightedPredFlag && sh.predWeightTable != null) {
            var w = sh.predWeightTable;
            PredictionMerger.weight(pred0, stride, off, blkW, blkH, comp == 0 ? w.lumaLog2WeightDenom : w.chromaLog2WeightDenom, comp == 0 ? w.lumaWeight[0][refIdxL0] : w.chromaWeight[0][comp - 1][refIdxL0], comp == 0 ? w.lumaOffset[0][refIdxL0] : w.chromaOffset[0][comp - 1][refIdxL0], out);
        } else {
            PredictionMerger.copyPrediction(pred0, stride, off, blkW, blkH, out);
        }
    };
    constructor.mergeAvg = function(blk0, blk1, stride, p0, off, blkW, blkH, out) {
        if (p0 == H264Const.PartPred.Bi) 
            PredictionMerger._mergePrediction(blk0, blk1, stride, p0, off, blkW, blkH, out);
         else if (p0 == H264Const.PartPred.L0) 
            PredictionMerger.copyPrediction(blk0, stride, off, blkW, blkH, out);
         else if (p0 == H264Const.PartPred.L1) 
            PredictionMerger.copyPrediction(blk1, stride, off, blkW, blkH, out);
    };
    constructor.mergeWeight = function(blk0, blk1, stride, partPred, off, blkW, blkH, logWD, w0, w1, o0, o1, out) {
        if (partPred == H264Const.PartPred.L0) {
            PredictionMerger.weight(blk0, stride, off, blkW, blkH, logWD, w0, o0, out);
        } else if (partPred == H264Const.PartPred.L1) {
            PredictionMerger.weight(blk1, stride, off, blkW, blkH, logWD, w1, o1, out);
        } else if (partPred == H264Const.PartPred.Bi) {
            PredictionMerger._weightPrediction(blk0, blk1, stride, off, blkW, blkH, logWD, w0, w1, o0, o1, out);
        }
    };
    constructor.copyPrediction = function(_in, stride, off, blkW, blkH, out) {
        for (var i = 0; i < blkH; i++ , off += stride - blkW) 
            for (var j = 0; j < blkW; j++ , off++) 
                out[off] = _in[off];
    };
    constructor._mergePrediction = function(blk0, blk1, stride, p0, off, blkW, blkH, out) {
        for (var i = 0; i < blkH; i++ , off += stride - blkW) 
            for (var j = 0; j < blkW; j++ , off++) 
                out[off] = (((blk0[off] + blk1[off] + 1) >> 1) << 24 >> 24);
    };
    constructor._weightPrediction = function(blk0, blk1, stride, off, blkW, blkH, logWD, w0, w1, o0, o1, out) {
        var round = (1 << logWD) + ((w0 + w1) << 7);
        var sum = ((o0 + o1 + 1) >> 1) - 128;
        var logWDCP1 = logWD + 1;
        for (var i = 0; i < blkH; i++ , off += stride - blkW) 
            for (var j = 0; j < blkW; j++ , off++) {
                out[off] = (MathUtil.clip(((blk0[off] * w0 + blk1[off] * w1 + round) >> logWDCP1) + sum, -128, 127) << 24 >> 24);
            }
    };
    constructor.weight = function(blk0, stride, off, blkW, blkH, logWD, w, o, out) {
        var round = 1 << (logWD - 1);
        if (logWD >= 1) {
            o -= 128;
            round += w << 7;
            for (var i = 0; i < blkH; i++ , off += stride - blkW) 
                for (var j = 0; j < blkW; j++ , off++) 
                    out[off] = (MathUtil.clip(((blk0[off] * w + round) >> logWD) + o, -128, 127) << 24 >> 24);
        } else {
            o += (w << 7) - 128;
            for (var i = 0; i < blkH; i++ , off += stride - blkW) 
                for (var j = 0; j < blkW; j++ , off++) 
                    out[off] = (MathUtil.clip(blk0[off] * w + o, -128, 127) << 24 >> 24);
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Sequence Parameter Set structure of h264 bitstream
 *  
 *  capable to serialize and deserialize with CAVLC bitstream
 *  
 *  @author The JCodec project
 *  
 */
var SeqParameterSet = function() {};
SeqParameterSet = stjs.extend(SeqParameterSet, null, [], function(constructor, prototype) {
    prototype.picOrderCntType = 0;
    prototype.fieldPicFlag = false;
    prototype.deltaPicOrderAlwaysZeroFlag = false;
    prototype.mbAdaptiveFrameFieldFlag = false;
    prototype.direct8x8InferenceFlag = false;
    prototype.chromaFormatIdc = null;
    prototype.log2MaxFrameNumMinus4 = 0;
    prototype.log2MaxPicOrderCntLsbMinus4 = 0;
    prototype.picHeightInMapUnitsMinus1 = 0;
    prototype.picWidthInMbsMinus1 = 0;
    prototype.bitDepthLumaMinus8 = 0;
    prototype.bitDepthChromaMinus8 = 0;
    prototype.qpprimeYZeroTransformBypassFlag = false;
    prototype.profileIdc = 0;
    prototype.constraintSet0Flag = false;
    prototype.constraintSet1Flag = false;
    prototype.constraintSet2Flag = false;
    prototype.constraintSet3Flag = false;
    prototype.constraintSet4Flag = false;
    prototype.constraintSet5Flag = false;
    prototype.levelIdc = 0;
    prototype.seqParameterSetId = 0;
    /**
     *  separate_colour_plane_flag. When a picture is coded using three separate
     *  colour planes (separate_colour_plane_flag is equal to 1), a slice
     *  contains only macroblocks of one colour component being identified by the
     *  corresponding value of colour_plane_id, and each colour component array
     *  of a picture consists of slices having the same colour_plane_id value.
     *  Coded slices with different values of colour_plane_id within an access
     *  unit can be interleaved with each other under the constraint that for
     *  each value of colour_plane_id, the coded slice NAL units with that value
     *  colour_plane_id shall be in the order of increasing macroblock address
     *  for the first macroblock of each coded slice NAL unit.
     */
    prototype.separateColourPlaneFlag = false;
    /**
     *  offset_for_non_ref_pic is used to calculate the picture order count of a
     *  non-reference picture as specified in 8.2.1. The value of
     *  offset_for_non_ref_pic shall be in the range of -231 to 231 - 1,
     *  inclusive.
     */
    prototype.offsetForNonRefPic = 0;
    /**
     *  offset_for_top_to_bottom_field is used to calculate the picture order
     *  count of a bottom field as specified in subclause 8.2.1. The value of
     *  offset_for_top_to_bottom_field shall be in the range of -231 to 231 - 1,
     *  inclusive.
     */
    prototype.offsetForTopToBottomField = 0;
    prototype.numRefFrames = 0;
    /**
     *  gaps_in_frame_num_value_allowed_flag specifies the allowed values of
     *  frame_num as specified in subclause 7.4.3 and the decoding process in
     *  case of an inferred gap between values of frame_num as specified in
     *  subclause 8.2.5.2.
     */
    prototype.gapsInFrameNumValueAllowedFlag = false;
    /**
     *  frame_mbs_only_flag equal to 0 specifies that coded pictures of the coded
     *  video sequence may either be coded fields or coded frames.
     *  frame_mbs_only_flag equal to 1 specifies that every coded picture of the
     *  coded video sequence is a coded frame containing only frame macroblocks.
     */
    prototype.frameMbsOnlyFlag = false;
    prototype.frameCroppingFlag = false;
    prototype.frameCropLeftOffset = 0;
    prototype.frameCropRightOffset = 0;
    prototype.frameCropTopOffset = 0;
    prototype.frameCropBottomOffset = 0;
    prototype.offsetForRefFrame = null;
    prototype.vuiParams = null;
    prototype.scalingMatrix = null;
    prototype.numRefFramesInPicOrderCntCycle = 0;
    constructor.getColor = function(id) {
        switch (id) {
            case 0:
                return ColorSpace.MONO;
            case 1:
                return ColorSpace.YUV420J;
            case 2:
                return ColorSpace.YUV422;
            case 3:
                return ColorSpace.YUV444;
        }
         throw new RuntimeException("Colorspace not supported");
    };
    constructor.fromColor = function(color) {
        if (color == ColorSpace.MONO) {
            return 0;
        } else if (color == ColorSpace.YUV420J) {
            return 1;
        } else if (color == ColorSpace.YUV422) {
            return 2;
        } else if (color == ColorSpace.YUV444) {
            return 3;
        }
         throw new RuntimeException("Colorspace not supported");
    };
    constructor.read = function(is) {
        var _in = BitReader.createBitReader(is);
        var sps = new SeqParameterSet();
        sps.profileIdc = CAVLCReader.readNBit(_in, 8, "SPS: profile_idc");
        sps.constraintSet0Flag = CAVLCReader.readBool(_in, "SPS: constraint_set_0_flag");
        sps.constraintSet1Flag = CAVLCReader.readBool(_in, "SPS: constraint_set_1_flag");
        sps.constraintSet2Flag = CAVLCReader.readBool(_in, "SPS: constraint_set_2_flag");
        sps.constraintSet3Flag = CAVLCReader.readBool(_in, "SPS: constraint_set_3_flag");
        sps.constraintSet4Flag = CAVLCReader.readBool(_in, "SPS: constraint_set_4_flag");
        sps.constraintSet5Flag = CAVLCReader.readBool(_in, "SPS: constraint_set_5_flag");
        CAVLCReader.readNBit(_in, 2, "SPS: reserved_zero_2bits");
        sps.levelIdc = stjs.trunc(CAVLCReader.readNBit(_in, 8, "SPS: level_idc"));
        sps.seqParameterSetId = CAVLCReader.readUEtrace(_in, "SPS: seq_parameter_set_id");
        if (sps.profileIdc == 100 || sps.profileIdc == 110 || sps.profileIdc == 122 || sps.profileIdc == 144) {
            sps.chromaFormatIdc = SeqParameterSet.getColor(CAVLCReader.readUEtrace(_in, "SPS: chroma_format_idc"));
            if (sps.chromaFormatIdc == ColorSpace.YUV444) {
                sps.separateColourPlaneFlag = CAVLCReader.readBool(_in, "SPS: separate_colour_plane_flag");
            }
            sps.bitDepthLumaMinus8 = CAVLCReader.readUEtrace(_in, "SPS: bit_depth_luma_minus8");
            sps.bitDepthChromaMinus8 = CAVLCReader.readUEtrace(_in, "SPS: bit_depth_chroma_minus8");
            sps.qpprimeYZeroTransformBypassFlag = CAVLCReader.readBool(_in, "SPS: qpprime_y_zero_transform_bypass_flag");
            var seqScalingMatrixPresent = CAVLCReader.readBool(_in, "SPS: seq_scaling_matrix_present_lag");
            if (seqScalingMatrixPresent) {
                SeqParameterSet.readScalingListMatrix(_in, sps);
            }
        } else {
            sps.chromaFormatIdc = ColorSpace.YUV420J;
        }
        sps.log2MaxFrameNumMinus4 = CAVLCReader.readUEtrace(_in, "SPS: log2_max_frame_num_minus4");
        sps.picOrderCntType = CAVLCReader.readUEtrace(_in, "SPS: pic_order_cnt_type");
        if (sps.picOrderCntType == 0) {
            sps.log2MaxPicOrderCntLsbMinus4 = CAVLCReader.readUEtrace(_in, "SPS: log2_max_pic_order_cnt_lsb_minus4");
        } else if (sps.picOrderCntType == 1) {
            sps.deltaPicOrderAlwaysZeroFlag = CAVLCReader.readBool(_in, "SPS: delta_pic_order_always_zero_flag");
            sps.offsetForNonRefPic = CAVLCReader.readSE(_in, "SPS: offset_for_non_ref_pic");
            sps.offsetForTopToBottomField = CAVLCReader.readSE(_in, "SPS: offset_for_top_to_bottom_field");
            sps.numRefFramesInPicOrderCntCycle = CAVLCReader.readUEtrace(_in, "SPS: num_ref_frames_in_pic_order_cnt_cycle");
            sps.offsetForRefFrame = new Int32Array(sps.numRefFramesInPicOrderCntCycle);
            for (var i = 0; i < sps.numRefFramesInPicOrderCntCycle; i++) {
                sps.offsetForRefFrame[i] = CAVLCReader.readSE(_in, "SPS: offsetForRefFrame [" + i + "]");
            }
        }
        sps.numRefFrames = CAVLCReader.readUEtrace(_in, "SPS: num_ref_frames");
        sps.gapsInFrameNumValueAllowedFlag = CAVLCReader.readBool(_in, "SPS: gaps_in_frame_num_value_allowed_flag");
        sps.picWidthInMbsMinus1 = CAVLCReader.readUEtrace(_in, "SPS: pic_width_in_mbs_minus1");
        sps.picHeightInMapUnitsMinus1 = CAVLCReader.readUEtrace(_in, "SPS: pic_height_in_map_units_minus1");
        sps.frameMbsOnlyFlag = CAVLCReader.readBool(_in, "SPS: frame_mbs_only_flag");
        if (!sps.frameMbsOnlyFlag) {
            sps.mbAdaptiveFrameFieldFlag = CAVLCReader.readBool(_in, "SPS: mb_adaptive_frame_field_flag");
        }
        sps.direct8x8InferenceFlag = CAVLCReader.readBool(_in, "SPS: direct_8x8_inference_flag");
        sps.frameCroppingFlag = CAVLCReader.readBool(_in, "SPS: frame_cropping_flag");
        if (sps.frameCroppingFlag) {
            sps.frameCropLeftOffset = CAVLCReader.readUEtrace(_in, "SPS: frame_crop_left_offset");
            sps.frameCropRightOffset = CAVLCReader.readUEtrace(_in, "SPS: frame_crop_right_offset");
            sps.frameCropTopOffset = CAVLCReader.readUEtrace(_in, "SPS: frame_crop_top_offset");
            sps.frameCropBottomOffset = CAVLCReader.readUEtrace(_in, "SPS: frame_crop_bottom_offset");
        }
        var vuiParametersPresentFlag = CAVLCReader.readBool(_in, "SPS: vui_parameters_present_flag");
        if (vuiParametersPresentFlag) 
            sps.vuiParams = SeqParameterSet.readVUIParameters(_in);
        return sps;
    };
    constructor.writeScalingList = function(out, scalingMatrix, which) {
        var useDefaultScalingMatrixFlag = false;
        switch (which) {
            case 0:
                useDefaultScalingMatrixFlag = Platform.arrayEqualsInt(scalingMatrix[which], H264Const.defaultScalingList4x4Intra);
                break;
            case 1:
            case 2:
                useDefaultScalingMatrixFlag = Platform.arrayEqualsInt(scalingMatrix[which], scalingMatrix[0]);
                break;
            case 3:
                useDefaultScalingMatrixFlag = Platform.arrayEqualsInt(scalingMatrix[which], H264Const.defaultScalingList4x4Inter);
                break;
            case 4:
            case 5:
                useDefaultScalingMatrixFlag = Platform.arrayEqualsInt(scalingMatrix[which], scalingMatrix[3]);
                break;
            case 6:
                useDefaultScalingMatrixFlag = Platform.arrayEqualsInt(scalingMatrix[which], H264Const.defaultScalingList8x8Intra);
                break;
            case 7:
                useDefaultScalingMatrixFlag = Platform.arrayEqualsInt(scalingMatrix[which], H264Const.defaultScalingList8x8Inter);
                break;
        }
        var scalingList = scalingMatrix[which];
        if (useDefaultScalingMatrixFlag) {
            CAVLCWriter.writeSEtrace(out, -8, "SPS: ");
            return;
        }
        var lastScale = 8;
        var nextScale = 8;
        for (var j = 0; j < scalingList.length; j++) {
            if (nextScale != 0) {
                var deltaScale = scalingList[j] - lastScale - 256;
                CAVLCWriter.writeSEtrace(out, deltaScale, "SPS: ");
            }
            lastScale = scalingList[j];
        }
    };
    constructor.readScalingList = function(src, sizeOfScalingList) {
        var scalingList = new Int32Array(sizeOfScalingList);
        var lastScale = 8;
        var nextScale = 8;
        for (var j = 0; j < sizeOfScalingList; j++) {
            if (nextScale != 0) {
                var deltaScale = CAVLCReader.readSE(src, "deltaScale");
                nextScale = (lastScale + deltaScale + 256) % 256;
                if (j == 0 && nextScale == 0) 
                    return null;
            }
            scalingList[j] = nextScale == 0 ? lastScale : nextScale;
            lastScale = scalingList[j];
        }
        return scalingList;
    };
    constructor.readScalingListMatrix = function(src, sps) {
        sps.scalingMatrix = Array(8);
        for (var i = 0; i < 8; i++) {
            var seqScalingListPresentFlag = CAVLCReader.readBool(src, "SPS: seqScalingListPresentFlag");
            if (seqScalingListPresentFlag) {
                var scalingListSize = i < 6 ? 16 : 64;
                sps.scalingMatrix[i] = SeqParameterSet.readScalingList(src, scalingListSize);
            }
        }
    };
    constructor.readVUIParameters = function(_in) {
        var vuip = new VUIParameters();
        vuip.aspectRatioInfoPresentFlag = CAVLCReader.readBool(_in, "VUI: aspect_ratio_info_present_flag");
        if (vuip.aspectRatioInfoPresentFlag) {
            vuip.aspectRatio = AspectRatio.fromValue(stjs.trunc(CAVLCReader.readNBit(_in, 8, "VUI: aspect_ratio")));
            if (vuip.aspectRatio == AspectRatio.Extended_SAR) {
                vuip.sarWidth = stjs.trunc(CAVLCReader.readNBit(_in, 16, "VUI: sar_width"));
                vuip.sarHeight = stjs.trunc(CAVLCReader.readNBit(_in, 16, "VUI: sar_height"));
            }
        }
        vuip.overscanInfoPresentFlag = CAVLCReader.readBool(_in, "VUI: overscan_info_present_flag");
        if (vuip.overscanInfoPresentFlag) {
            vuip.overscanAppropriateFlag = CAVLCReader.readBool(_in, "VUI: overscan_appropriate_flag");
        }
        vuip.videoSignalTypePresentFlag = CAVLCReader.readBool(_in, "VUI: video_signal_type_present_flag");
        if (vuip.videoSignalTypePresentFlag) {
            vuip.videoFormat = stjs.trunc(CAVLCReader.readNBit(_in, 3, "VUI: video_format"));
            vuip.videoFullRangeFlag = CAVLCReader.readBool(_in, "VUI: video_full_range_flag");
            vuip.colourDescriptionPresentFlag = CAVLCReader.readBool(_in, "VUI: colour_description_present_flag");
            if (vuip.colourDescriptionPresentFlag) {
                vuip.colourPrimaries = stjs.trunc(CAVLCReader.readNBit(_in, 8, "VUI: colour_primaries"));
                vuip.transferCharacteristics = stjs.trunc(CAVLCReader.readNBit(_in, 8, "VUI: transfer_characteristics"));
                vuip.matrixCoefficients = stjs.trunc(CAVLCReader.readNBit(_in, 8, "VUI: matrix_coefficients"));
            }
        }
        vuip.chromaLocInfoPresentFlag = CAVLCReader.readBool(_in, "VUI: chroma_loc_info_present_flag");
        if (vuip.chromaLocInfoPresentFlag) {
            vuip.chromaSampleLocTypeTopField = CAVLCReader.readUEtrace(_in, "VUI chroma_sample_loc_type_top_field");
            vuip.chromaSampleLocTypeBottomField = CAVLCReader.readUEtrace(_in, "VUI chroma_sample_loc_type_bottom_field");
        }
        vuip.timingInfoPresentFlag = CAVLCReader.readBool(_in, "VUI: timing_info_present_flag");
        if (vuip.timingInfoPresentFlag) {
            vuip.numUnitsInTick = stjs.trunc(CAVLCReader.readNBit(_in, 32, "VUI: num_units_in_tick"));
            vuip.timeScale = stjs.trunc(CAVLCReader.readNBit(_in, 32, "VUI: time_scale"));
            vuip.fixedFrameRateFlag = CAVLCReader.readBool(_in, "VUI: fixed_frame_rate_flag");
        }
        var nalHRDParametersPresentFlag = CAVLCReader.readBool(_in, "VUI: nal_hrd_parameters_present_flag");
        if (nalHRDParametersPresentFlag) 
            vuip.nalHRDParams = SeqParameterSet.readHRDParameters(_in);
        var vclHRDParametersPresentFlag = CAVLCReader.readBool(_in, "VUI: vcl_hrd_parameters_present_flag");
        if (vclHRDParametersPresentFlag) 
            vuip.vclHRDParams = SeqParameterSet.readHRDParameters(_in);
        if (nalHRDParametersPresentFlag || vclHRDParametersPresentFlag) {
            vuip.lowDelayHrdFlag = CAVLCReader.readBool(_in, "VUI: low_delay_hrd_flag");
        }
        vuip.picStructPresentFlag = CAVLCReader.readBool(_in, "VUI: pic_struct_present_flag");
        var bitstreamRestrictionFlag = CAVLCReader.readBool(_in, "VUI: bitstream_restriction_flag");
        if (bitstreamRestrictionFlag) {
            vuip.bitstreamRestriction = new VUIParameters.BitstreamRestriction();
            vuip.bitstreamRestriction.motionVectorsOverPicBoundariesFlag = CAVLCReader.readBool(_in, "VUI: motion_vectors_over_pic_boundaries_flag");
            vuip.bitstreamRestriction.maxBytesPerPicDenom = CAVLCReader.readUEtrace(_in, "VUI max_bytes_per_pic_denom");
            vuip.bitstreamRestriction.maxBitsPerMbDenom = CAVLCReader.readUEtrace(_in, "VUI max_bits_per_mb_denom");
            vuip.bitstreamRestriction.log2MaxMvLengthHorizontal = CAVLCReader.readUEtrace(_in, "VUI log2_max_mv_length_horizontal");
            vuip.bitstreamRestriction.log2MaxMvLengthVertical = CAVLCReader.readUEtrace(_in, "VUI log2_max_mv_length_vertical");
            vuip.bitstreamRestriction.numReorderFrames = CAVLCReader.readUEtrace(_in, "VUI num_reorder_frames");
            vuip.bitstreamRestriction.maxDecFrameBuffering = CAVLCReader.readUEtrace(_in, "VUI max_dec_frame_buffering");
        }
        return vuip;
    };
    constructor.readHRDParameters = function(_in) {
        var hrd = new HRDParameters();
        hrd.cpbCntMinus1 = CAVLCReader.readUEtrace(_in, "SPS: cpb_cnt_minus1");
        hrd.bitRateScale = stjs.trunc(CAVLCReader.readNBit(_in, 4, "HRD: bit_rate_scale"));
        hrd.cpbSizeScale = stjs.trunc(CAVLCReader.readNBit(_in, 4, "HRD: cpb_size_scale"));
        hrd.bitRateValueMinus1 = new Int32Array(hrd.cpbCntMinus1 + 1);
        hrd.cpbSizeValueMinus1 = new Int32Array(hrd.cpbCntMinus1 + 1);
        hrd.cbrFlag = new Int8Array(hrd.cpbCntMinus1 + 1);
        for (var SchedSelIdx = 0; SchedSelIdx <= hrd.cpbCntMinus1; SchedSelIdx++) {
            hrd.bitRateValueMinus1[SchedSelIdx] = CAVLCReader.readUEtrace(_in, "HRD: bit_rate_value_minus1");
            hrd.cpbSizeValueMinus1[SchedSelIdx] = CAVLCReader.readUEtrace(_in, "HRD: cpb_size_value_minus1");
            hrd.cbrFlag[SchedSelIdx] = CAVLCReader.readBool(_in, "HRD: cbr_flag");
        }
        hrd.initialCpbRemovalDelayLengthMinus1 = stjs.trunc(CAVLCReader.readNBit(_in, 5, "HRD: initial_cpb_removal_delay_length_minus1"));
        hrd.cpbRemovalDelayLengthMinus1 = stjs.trunc(CAVLCReader.readNBit(_in, 5, "HRD: cpb_removal_delay_length_minus1"));
        hrd.dpbOutputDelayLengthMinus1 = stjs.trunc(CAVLCReader.readNBit(_in, 5, "HRD: dpb_output_delay_length_minus1"));
        hrd.timeOffsetLength = stjs.trunc(CAVLCReader.readNBit(_in, 5, "HRD: time_offset_length"));
        return hrd;
    };
    prototype.write = function(out) {
        var writer = new BitWriter(out);
        CAVLCWriter.writeNBit(writer, this.profileIdc, 8, "SPS: profile_idc");
        CAVLCWriter.writeBool(writer, this.constraintSet0Flag, "SPS: constraint_set_0_flag");
        CAVLCWriter.writeBool(writer, this.constraintSet1Flag, "SPS: constraint_set_1_flag");
        CAVLCWriter.writeBool(writer, this.constraintSet2Flag, "SPS: constraint_set_2_flag");
        CAVLCWriter.writeBool(writer, this.constraintSet3Flag, "SPS: constraint_set_3_flag");
        CAVLCWriter.writeBool(writer, this.constraintSet4Flag, "SPS: constraint_set_4_flag");
        CAVLCWriter.writeBool(writer, this.constraintSet5Flag, "SPS: constraint_set_5_flag");
        CAVLCWriter.writeNBit(writer, 0, 2, "SPS: reserved");
        CAVLCWriter.writeNBit(writer, this.levelIdc, 8, "SPS: level_idc");
        CAVLCWriter.writeUEtrace(writer, this.seqParameterSetId, "SPS: seq_parameter_set_id");
        if (this.profileIdc == 100 || this.profileIdc == 110 || this.profileIdc == 122 || this.profileIdc == 144) {
            CAVLCWriter.writeUEtrace(writer, SeqParameterSet.fromColor(this.chromaFormatIdc), "SPS: chroma_format_idc");
            if (this.chromaFormatIdc == ColorSpace.YUV444) {
                CAVLCWriter.writeBool(writer, this.separateColourPlaneFlag, "SPS: residual_color_transform_flag");
            }
            CAVLCWriter.writeUEtrace(writer, this.bitDepthLumaMinus8, "SPS: ");
            CAVLCWriter.writeUEtrace(writer, this.bitDepthChromaMinus8, "SPS: ");
            CAVLCWriter.writeBool(writer, this.qpprimeYZeroTransformBypassFlag, "SPS: qpprime_y_zero_transform_bypass_flag");
            CAVLCWriter.writeBool(writer, this.scalingMatrix != null, "SPS: ");
            if (this.scalingMatrix != null) {
                for (var i = 0; i < 8; i++) {
                    CAVLCWriter.writeBool(writer, this.scalingMatrix[i] != null, "SPS: ");
                    if (this.scalingMatrix[i] != null) 
                        SeqParameterSet.writeScalingList(writer, this.scalingMatrix, i);
                }
            }
        }
        CAVLCWriter.writeUEtrace(writer, this.log2MaxFrameNumMinus4, "SPS: log2_max_frame_num_minus4");
        CAVLCWriter.writeUEtrace(writer, this.picOrderCntType, "SPS: pic_order_cnt_type");
        if (this.picOrderCntType == 0) {
            CAVLCWriter.writeUEtrace(writer, this.log2MaxPicOrderCntLsbMinus4, "SPS: log2_max_pic_order_cnt_lsb_minus4");
        } else if (this.picOrderCntType == 1) {
            CAVLCWriter.writeBool(writer, this.deltaPicOrderAlwaysZeroFlag, "SPS: delta_pic_order_always_zero_flag");
            CAVLCWriter.writeSEtrace(writer, this.offsetForNonRefPic, "SPS: offset_for_non_ref_pic");
            CAVLCWriter.writeSEtrace(writer, this.offsetForTopToBottomField, "SPS: offset_for_top_to_bottom_field");
            CAVLCWriter.writeUEtrace(writer, this.offsetForRefFrame.length, "SPS: ");
            for (var i = 0; i < this.offsetForRefFrame.length; i++) 
                CAVLCWriter.writeSEtrace(writer, this.offsetForRefFrame[i], "SPS: ");
        }
        CAVLCWriter.writeUEtrace(writer, this.numRefFrames, "SPS: num_ref_frames");
        CAVLCWriter.writeBool(writer, this.gapsInFrameNumValueAllowedFlag, "SPS: gaps_in_frame_num_value_allowed_flag");
        CAVLCWriter.writeUEtrace(writer, this.picWidthInMbsMinus1, "SPS: pic_width_in_mbs_minus1");
        CAVLCWriter.writeUEtrace(writer, this.picHeightInMapUnitsMinus1, "SPS: pic_height_in_map_units_minus1");
        CAVLCWriter.writeBool(writer, this.frameMbsOnlyFlag, "SPS: frame_mbs_only_flag");
        if (!this.frameMbsOnlyFlag) {
            CAVLCWriter.writeBool(writer, this.mbAdaptiveFrameFieldFlag, "SPS: mb_adaptive_frame_field_flag");
        }
        CAVLCWriter.writeBool(writer, this.direct8x8InferenceFlag, "SPS: direct_8x8_inference_flag");
        CAVLCWriter.writeBool(writer, this.frameCroppingFlag, "SPS: frame_cropping_flag");
        if (this.frameCroppingFlag) {
            CAVLCWriter.writeUEtrace(writer, this.frameCropLeftOffset, "SPS: frame_crop_left_offset");
            CAVLCWriter.writeUEtrace(writer, this.frameCropRightOffset, "SPS: frame_crop_right_offset");
            CAVLCWriter.writeUEtrace(writer, this.frameCropTopOffset, "SPS: frame_crop_top_offset");
            CAVLCWriter.writeUEtrace(writer, this.frameCropBottomOffset, "SPS: frame_crop_bottom_offset");
        }
        CAVLCWriter.writeBool(writer, this.vuiParams != null, "SPS: ");
        if (this.vuiParams != null) 
            this.writeVUIParameters(this.vuiParams, writer);
        CAVLCWriter.writeTrailingBits(writer);
    };
    prototype.writeVUIParameters = function(vuip, writer) {
        CAVLCWriter.writeBool(writer, vuip.aspectRatioInfoPresentFlag, "VUI: aspect_ratio_info_present_flag");
        if (vuip.aspectRatioInfoPresentFlag) {
            CAVLCWriter.writeNBit(writer, vuip.aspectRatio.getValue(), 8, "VUI: aspect_ratio");
            if (vuip.aspectRatio == AspectRatio.Extended_SAR) {
                CAVLCWriter.writeNBit(writer, vuip.sarWidth, 16, "VUI: sar_width");
                CAVLCWriter.writeNBit(writer, vuip.sarHeight, 16, "VUI: sar_height");
            }
        }
        CAVLCWriter.writeBool(writer, vuip.overscanInfoPresentFlag, "VUI: overscan_info_present_flag");
        if (vuip.overscanInfoPresentFlag) {
            CAVLCWriter.writeBool(writer, vuip.overscanAppropriateFlag, "VUI: overscan_appropriate_flag");
        }
        CAVLCWriter.writeBool(writer, vuip.videoSignalTypePresentFlag, "VUI: video_signal_type_present_flag");
        if (vuip.videoSignalTypePresentFlag) {
            CAVLCWriter.writeNBit(writer, vuip.videoFormat, 3, "VUI: video_format");
            CAVLCWriter.writeBool(writer, vuip.videoFullRangeFlag, "VUI: video_full_range_flag");
            CAVLCWriter.writeBool(writer, vuip.colourDescriptionPresentFlag, "VUI: colour_description_present_flag");
            if (vuip.colourDescriptionPresentFlag) {
                CAVLCWriter.writeNBit(writer, vuip.colourPrimaries, 8, "VUI: colour_primaries");
                CAVLCWriter.writeNBit(writer, vuip.transferCharacteristics, 8, "VUI: transfer_characteristics");
                CAVLCWriter.writeNBit(writer, vuip.matrixCoefficients, 8, "VUI: matrix_coefficients");
            }
        }
        CAVLCWriter.writeBool(writer, vuip.chromaLocInfoPresentFlag, "VUI: chroma_loc_info_present_flag");
        if (vuip.chromaLocInfoPresentFlag) {
            CAVLCWriter.writeUEtrace(writer, vuip.chromaSampleLocTypeTopField, "VUI: chroma_sample_loc_type_top_field");
            CAVLCWriter.writeUEtrace(writer, vuip.chromaSampleLocTypeBottomField, "VUI: chroma_sample_loc_type_bottom_field");
        }
        CAVLCWriter.writeBool(writer, vuip.timingInfoPresentFlag, "VUI: timing_info_present_flag");
        if (vuip.timingInfoPresentFlag) {
            CAVLCWriter.writeNBit(writer, vuip.numUnitsInTick, 32, "VUI: num_units_in_tick");
            CAVLCWriter.writeNBit(writer, vuip.timeScale, 32, "VUI: time_scale");
            CAVLCWriter.writeBool(writer, vuip.fixedFrameRateFlag, "VUI: fixed_frame_rate_flag");
        }
        CAVLCWriter.writeBool(writer, vuip.nalHRDParams != null, "VUI: ");
        if (vuip.nalHRDParams != null) {
            this.writeHRDParameters(vuip.nalHRDParams, writer);
        }
        CAVLCWriter.writeBool(writer, vuip.vclHRDParams != null, "VUI: ");
        if (vuip.vclHRDParams != null) {
            this.writeHRDParameters(vuip.vclHRDParams, writer);
        }
        if (vuip.nalHRDParams != null || vuip.vclHRDParams != null) {
            CAVLCWriter.writeBool(writer, vuip.lowDelayHrdFlag, "VUI: low_delay_hrd_flag");
        }
        CAVLCWriter.writeBool(writer, vuip.picStructPresentFlag, "VUI: pic_struct_present_flag");
        CAVLCWriter.writeBool(writer, vuip.bitstreamRestriction != null, "VUI: ");
        if (vuip.bitstreamRestriction != null) {
            CAVLCWriter.writeBool(writer, vuip.bitstreamRestriction.motionVectorsOverPicBoundariesFlag, "VUI: motion_vectors_over_pic_boundaries_flag");
            CAVLCWriter.writeUEtrace(writer, vuip.bitstreamRestriction.maxBytesPerPicDenom, "VUI: max_bytes_per_pic_denom");
            CAVLCWriter.writeUEtrace(writer, vuip.bitstreamRestriction.maxBitsPerMbDenom, "VUI: max_bits_per_mb_denom");
            CAVLCWriter.writeUEtrace(writer, vuip.bitstreamRestriction.log2MaxMvLengthHorizontal, "VUI: log2_max_mv_length_horizontal");
            CAVLCWriter.writeUEtrace(writer, vuip.bitstreamRestriction.log2MaxMvLengthVertical, "VUI: log2_max_mv_length_vertical");
            CAVLCWriter.writeUEtrace(writer, vuip.bitstreamRestriction.numReorderFrames, "VUI: num_reorder_frames");
            CAVLCWriter.writeUEtrace(writer, vuip.bitstreamRestriction.maxDecFrameBuffering, "VUI: max_dec_frame_buffering");
        }
    };
    prototype.writeHRDParameters = function(hrd, writer) {
        CAVLCWriter.writeUEtrace(writer, hrd.cpbCntMinus1, "HRD: cpb_cnt_minus1");
        CAVLCWriter.writeNBit(writer, hrd.bitRateScale, 4, "HRD: bit_rate_scale");
        CAVLCWriter.writeNBit(writer, hrd.cpbSizeScale, 4, "HRD: cpb_size_scale");
        for (var SchedSelIdx = 0; SchedSelIdx <= hrd.cpbCntMinus1; SchedSelIdx++) {
            CAVLCWriter.writeUEtrace(writer, hrd.bitRateValueMinus1[SchedSelIdx], "HRD: ");
            CAVLCWriter.writeUEtrace(writer, hrd.cpbSizeValueMinus1[SchedSelIdx], "HRD: ");
            CAVLCWriter.writeBool(writer, hrd.cbrFlag[SchedSelIdx], "HRD: ");
        }
        CAVLCWriter.writeNBit(writer, hrd.initialCpbRemovalDelayLengthMinus1, 5, "HRD: initial_cpb_removal_delay_length_minus1");
        CAVLCWriter.writeNBit(writer, hrd.cpbRemovalDelayLengthMinus1, 5, "HRD: cpb_removal_delay_length_minus1");
        CAVLCWriter.writeNBit(writer, hrd.dpbOutputDelayLengthMinus1, 5, "HRD: dpb_output_delay_length_minus1");
        CAVLCWriter.writeNBit(writer, hrd.timeOffsetLength, 5, "HRD: time_offset_length");
    };
    prototype.copy = function() {
        var buf = ByteBuffer.allocate(2048);
        this.write(buf);
        buf.flip();
        return SeqParameterSet.read(buf);
    };
    prototype.getPicOrderCntType = function() {
        return this.picOrderCntType;
    };
    prototype.isFieldPicFlag = function() {
        return this.fieldPicFlag;
    };
    prototype.isDeltaPicOrderAlwaysZeroFlag = function() {
        return this.deltaPicOrderAlwaysZeroFlag;
    };
    prototype.isMbAdaptiveFrameFieldFlag = function() {
        return this.mbAdaptiveFrameFieldFlag;
    };
    prototype.isDirect8x8InferenceFlag = function() {
        return this.direct8x8InferenceFlag;
    };
    prototype.getChromaFormatIdc = function() {
        return this.chromaFormatIdc;
    };
    prototype.getLog2MaxFrameNumMinus4 = function() {
        return this.log2MaxFrameNumMinus4;
    };
    prototype.getLog2MaxPicOrderCntLsbMinus4 = function() {
        return this.log2MaxPicOrderCntLsbMinus4;
    };
    prototype.getPicHeightInMapUnitsMinus1 = function() {
        return this.picHeightInMapUnitsMinus1;
    };
    prototype.getPicWidthInMbsMinus1 = function() {
        return this.picWidthInMbsMinus1;
    };
    prototype.getBitDepthLumaMinus8 = function() {
        return this.bitDepthLumaMinus8;
    };
    prototype.getBitDepthChromaMinus8 = function() {
        return this.bitDepthChromaMinus8;
    };
    prototype.isQpprimeYZeroTransformBypassFlag = function() {
        return this.qpprimeYZeroTransformBypassFlag;
    };
    prototype.getProfileIdc = function() {
        return this.profileIdc;
    };
    prototype.isConstraintSet0Flag = function() {
        return this.constraintSet0Flag;
    };
    prototype.isConstraintSet1Flag = function() {
        return this.constraintSet1Flag;
    };
    prototype.isConstraintSet2Flag = function() {
        return this.constraintSet2Flag;
    };
    prototype.isConstraintSet3Flag = function() {
        return this.constraintSet3Flag;
    };
    prototype.isConstraintSet4Flag = function() {
        return this.constraintSet4Flag;
    };
    prototype.isConstraintSet5Flag = function() {
        return this.constraintSet5Flag;
    };
    prototype.getLevelIdc = function() {
        return this.levelIdc;
    };
    prototype.getSeqParameterSetId = function() {
        return this.seqParameterSetId;
    };
    prototype.isResidualColorTransformFlag = function() {
        return this.separateColourPlaneFlag;
    };
    prototype.getOffsetForNonRefPic = function() {
        return this.offsetForNonRefPic;
    };
    prototype.getOffsetForTopToBottomField = function() {
        return this.offsetForTopToBottomField;
    };
    prototype.getNumRefFrames = function() {
        return this.numRefFrames;
    };
    prototype.isGapsInFrameNumValueAllowedFlag = function() {
        return this.gapsInFrameNumValueAllowedFlag;
    };
    prototype.isFrameMbsOnlyFlag = function() {
        return this.frameMbsOnlyFlag;
    };
    prototype.isFrameCroppingFlag = function() {
        return this.frameCroppingFlag;
    };
    prototype.getFrameCropLeftOffset = function() {
        return this.frameCropLeftOffset;
    };
    prototype.getFrameCropRightOffset = function() {
        return this.frameCropRightOffset;
    };
    prototype.getFrameCropTopOffset = function() {
        return this.frameCropTopOffset;
    };
    prototype.getFrameCropBottomOffset = function() {
        return this.frameCropBottomOffset;
    };
    prototype.getOffsetForRefFrame = function() {
        return this.offsetForRefFrame;
    };
    prototype.getVuiParams = function() {
        return this.vuiParams;
    };
    prototype.getScalingMatrix = function() {
        return this.scalingMatrix;
    };
    prototype.getNumRefFramesInPicOrderCntCycle = function() {
        return this.numRefFramesInPicOrderCntCycle;
    };
    constructor.getPicHeightInMbs = function(sps) {
        var picHeightInMbs = (sps.picHeightInMapUnitsMinus1 + 1) << (sps.frameMbsOnlyFlag ? 0 : 1);
        return picHeightInMbs;
    };
}, {chromaFormatIdc: "ColorSpace", offsetForRefFrame: "Int32Array", vuiParams: "VUIParameters", scalingMatrix: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Non-CABAC H.264 symbols read/write routines
 *  
 *  @author Jay Codec
 *  
 */
var CAVLC = function(sps, pps, mbW, mbH) {
    this.color = sps.chromaFormatIdc;
    this.chromaDCVLC = this.codeTableChromaDC();
    this.mbWidth = sps.picWidthInMbsMinus1 + 1;
    this.mbMask = (1 << mbH) - 1;
    this.tokensLeft = new Int32Array(4);
    this.tokensTop = new Int32Array(this.mbWidth << mbW);
    this.tokensLeftSaved = new Int32Array(4);
    this.tokensTopSaved = new Int32Array(this.mbWidth << mbW);
};
CAVLC = stjs.extend(CAVLC, null, [SaveRestore], function(constructor, prototype) {
    prototype.color = null;
    prototype.chromaDCVLC = null;
    prototype.tokensLeft = null;
    prototype.tokensTop = null;
    prototype.tokensLeftSaved = null;
    prototype.tokensTopSaved = null;
    prototype.mbWidth = 0;
    prototype.mbMask = 0;
    prototype.save = function() {
        System.arraycopy(this.tokensLeft, 0, this.tokensLeftSaved, 0, this.tokensLeft.length);
        System.arraycopy(this.tokensTop, 0, this.tokensTopSaved, 0, this.tokensTop.length);
    };
    prototype.restore = function() {
        {
            var tmp = this.tokensLeft;
            this.tokensLeft = this.tokensLeftSaved;
            this.tokensLeftSaved = tmp;
        }{
            var tmp = this.tokensTop;
            this.tokensTop = this.tokensTopSaved;
            this.tokensTopSaved = tmp;
        }};
    prototype.writeACBlock = function(out, blkIndX, blkIndY, leftMBType, topMBType, coeff, totalZerosTab, firstCoeff, maxCoeff, scan) {
        var coeffTokenTab = this.getCoeffTokenVLCForLuma(blkIndX != 0, leftMBType, this.tokensLeft[blkIndY & this.mbMask], blkIndY != 0, topMBType, this.tokensTop[blkIndX]);
        var coeffToken = this.writeBlockGen(out, coeff, totalZerosTab, firstCoeff, maxCoeff, scan, coeffTokenTab);
        this.tokensLeft[blkIndY & this.mbMask] = coeffToken;
        this.tokensTop[blkIndX] = coeffToken;
        return coeffToken;
    };
    prototype.writeChrDCBlock = function(out, coeff, totalZerosTab, firstCoeff, maxCoeff, scan) {
        this.writeBlockGen(out, coeff, totalZerosTab, firstCoeff, maxCoeff, scan, this.getCoeffTokenVLCForChromaDC());
    };
    prototype.writeLumaDCBlock = function(out, blkIndX, blkIndY, leftMBType, topMBType, coeff, totalZerosTab, firstCoeff, maxCoeff, scan) {
        var coeffTokenTab = this.getCoeffTokenVLCForLuma(blkIndX != 0, leftMBType, this.tokensLeft[blkIndY & this.mbMask], blkIndY != 0, topMBType, this.tokensTop[blkIndX]);
        this.writeBlockGen(out, coeff, totalZerosTab, firstCoeff, maxCoeff, scan, coeffTokenTab);
    };
    prototype.writeBlockGen = function(out, coeff, totalZerosTab, firstCoeff, maxCoeff, scan, coeffTokenTab) {
        var trailingOnes = 0, totalCoeff = 0, totalZeros = 0;
        var runBefore = new Int32Array(maxCoeff);
        var levels = new Int32Array(maxCoeff);
        for (var i = 0; i < maxCoeff; i++) {
            var c = coeff[scan[i + firstCoeff]];
            if (c == 0) {
                runBefore[totalCoeff]++;
                totalZeros++;
            } else {
                levels[totalCoeff++] = c;
            }
        }
        if (totalCoeff < maxCoeff) 
            totalZeros -= runBefore[totalCoeff];
        for (trailingOnes = 0; trailingOnes < totalCoeff && trailingOnes < 3 && Math.abs(levels[totalCoeff - trailingOnes - 1]) == 1; trailingOnes++) 
            ;
        var coeffToken = H264Const.coeffToken(totalCoeff, trailingOnes);
        coeffTokenTab.writeVLC(out, coeffToken);
        if (totalCoeff > 0) {
            this.writeTrailingOnes(out, levels, totalCoeff, trailingOnes);
            this.writeLevels(out, levels, totalCoeff, trailingOnes);
            if (totalCoeff < maxCoeff) {
                totalZerosTab[totalCoeff - 1].writeVLC(out, totalZeros);
                this.writeRuns(out, runBefore, totalCoeff, totalZeros);
            }
        }
        return coeffToken;
    };
    prototype.writeTrailingOnes = function(out, levels, totalCoeff, trailingOne) {
        for (var i = totalCoeff - 1; i >= totalCoeff - trailingOne; i--) 
            out.write1Bit(levels[i] >>> 31);
    };
    prototype.writeLevels = function(out, levels, totalCoeff, trailingOnes) {
        var suffixLen = totalCoeff > 10 && trailingOnes < 3 ? 1 : 0;
        for (var i = totalCoeff - trailingOnes - 1; i >= 0; i--) {
            var absLev = this.unsigned(levels[i]);
            if (i == totalCoeff - trailingOnes - 1 && trailingOnes < 3) 
                absLev -= 2;
            var prefix = absLev >> suffixLen;
            if (suffixLen == 0 && prefix < 14 || suffixLen > 0 && prefix < 15) {
                out.writeNBit(1, prefix + 1);
                out.writeNBit(absLev, suffixLen);
            } else if (suffixLen == 0 && absLev < 30) {
                out.writeNBit(1, 15);
                out.writeNBit(absLev - 14, 4);
            } else {
                if (suffixLen == 0) 
                    absLev -= 15;
                var len, code;
                for (len = 12; (code = absLev - (len + 3 << suffixLen) - (1 << len) + 4096) >= (1 << len); len++) 
                    ;
                out.writeNBit(1, len + 4);
                out.writeNBit(code, len);
            }
            if (suffixLen == 0) 
                suffixLen = 1;
            if (MathUtil.abs(levels[i]) > (3 << (suffixLen - 1)) && suffixLen < 6) 
                suffixLen++;
        }
    };
    prototype.unsigned = function(signed) {
        var sign = signed >>> 31;
        var s = signed >> 31;
        return (((signed ^ s) - s) << 1) + sign - 2;
    };
    prototype.writeRuns = function(out, run, totalCoeff, totalZeros) {
        for (var i = totalCoeff - 1; i > 0 && totalZeros > 0; i--) {
            H264Const.run[Math.min(6, totalZeros - 1)].writeVLC(out, run[i]);
            totalZeros -= run[i];
        }
    };
    prototype.getCoeffTokenVLCForLuma = function(leftAvailable, leftMBType, leftToken, topAvailable, topMBType, topToken) {
        var nc = this.codeTableLuma(leftAvailable, leftMBType, leftToken, topAvailable, topMBType, topToken);
        return H264Const.CoeffToken[Math.min(nc, 8)];
    };
    prototype.getCoeffTokenVLCForChromaDC = function() {
        return this.chromaDCVLC;
    };
    prototype.codeTableLuma = function(leftAvailable, leftMBType, leftToken, topAvailable, topMBType, topToken) {
        var nA = leftMBType == null ? 0 : CAVLC.totalCoeff(leftToken);
        var nB = topMBType == null ? 0 : CAVLC.totalCoeff(topToken);
        if (leftAvailable && topAvailable) 
            return (nA + nB + 1) >> 1;
         else if (leftAvailable) 
            return nA;
         else if (topAvailable) 
            return nB;
         else 
            return 0;
    };
    prototype.codeTableChromaDC = function() {
        if (this.color == ColorSpace.YUV420J) {
            return H264Const.coeffTokenChromaDCY420;
        } else if (this.color == ColorSpace.YUV422) {
            return H264Const.coeffTokenChromaDCY422;
        } else if (this.color == ColorSpace.YUV444) {
            return H264Const.CoeffToken[0];
        }
        return null;
    };
    prototype.readCoeffs = function(_in, coeffTokenTab, totalZerosTab, coeffLevel, firstCoeff, nCoeff, zigzag) {
        var coeffToken = coeffTokenTab.readVLC(_in);
        var totalCoeff = CAVLC.totalCoeff(coeffToken);
        var trailingOnes = CAVLC.trailingOnes(coeffToken);
        if (totalCoeff > 0) {
            var suffixLength = totalCoeff > 10 && trailingOnes < 3 ? 1 : 0;
            var level = new Int32Array(totalCoeff);
            var i;
            for (i = 0; i < trailingOnes; i++) 
                level[i] = 1 - 2 * _in.read1Bit();
            for (; i < totalCoeff; i++) {
                var level_prefix = CAVLCReader.readZeroBitCount(_in, "");
                var levelSuffixSize = suffixLength;
                if (level_prefix == 14 && suffixLength == 0) 
                    levelSuffixSize = 4;
                if (level_prefix >= 15) 
                    levelSuffixSize = level_prefix - 3;
                var levelCode = (CAVLC.Min(15, level_prefix) << suffixLength);
                if (levelSuffixSize > 0) {
                    var level_suffix = CAVLCReader.readU(_in, levelSuffixSize, "RB: level_suffix");
                    levelCode += level_suffix;
                }
                if (level_prefix >= 15 && suffixLength == 0) 
                    levelCode += 15;
                if (level_prefix >= 16) 
                    levelCode += (1 << (level_prefix - 3)) - 4096;
                if (i == trailingOnes && trailingOnes < 3) 
                    levelCode += 2;
                if (levelCode % 2 == 0) 
                    level[i] = (levelCode + 2) >> 1;
                 else 
                    level[i] = (-levelCode - 1) >> 1;
                if (suffixLength == 0) 
                    suffixLength = 1;
                if (CAVLC.Abs(level[i]) > (3 << (suffixLength - 1)) && suffixLength < 6) 
                    suffixLength++;
            }
            var zerosLeft;
            if (totalCoeff < nCoeff) {
                if (coeffLevel.length == 4) {
                    zerosLeft = H264Const.totalZeros4[totalCoeff - 1].readVLC(_in);
                } else if (coeffLevel.length == 8) {
                    zerosLeft = H264Const.totalZeros8[totalCoeff - 1].readVLC(_in);
                } else {
                    zerosLeft = H264Const.totalZeros16[totalCoeff - 1].readVLC(_in);
                }
            } else 
                zerosLeft = 0;
            var runs = new Int32Array(totalCoeff);
            var r;
            for (r = 0; r < totalCoeff - 1 && zerosLeft > 0; r++) {
                var run = H264Const.run[Math.min(6, zerosLeft - 1)].readVLC(_in);
                zerosLeft -= run;
                runs[r] = run;
            }
            runs[r] = zerosLeft;
            for (var j = totalCoeff - 1, cn = 0; j >= 0 && cn < nCoeff; j-- , cn++) {
                cn += runs[j];
                coeffLevel[zigzag[cn + firstCoeff]] = level[j];
            }
        }
        return coeffToken;
    };
    constructor.Min = function(i, level_prefix) {
        return i < level_prefix ? i : level_prefix;
    };
    constructor.Abs = function(i) {
        return i < 0 ? -i : i;
    };
    constructor.totalCoeff = function(coeffToken) {
        return coeffToken >> 4;
    };
    constructor.trailingOnes = function(coeffToken) {
        return coeffToken & 15;
    };
    constructor.NO_ZIGZAG = new Int32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
    prototype.readChromaDCBlock = function(reader, coeff, leftAvailable, topAvailable) {
        var coeffTokenTab = this.getCoeffTokenVLCForChromaDC();
        this.readCoeffs(reader, coeffTokenTab, coeff.length == 16 ? H264Const.totalZeros16 : (coeff.length == 8 ? H264Const.totalZeros8 : H264Const.totalZeros4), coeff, 0, coeff.length, CAVLC.NO_ZIGZAG);
    };
    prototype.readLumaDCBlock = function(reader, coeff, mbX, leftAvailable, leftMbType, topAvailable, topMbType, zigzag4x4) {
        var coeffTokenTab = this.getCoeffTokenVLCForLuma(leftAvailable, leftMbType, this.tokensLeft[0], topAvailable, topMbType, this.tokensTop[mbX << 2]);
        this.readCoeffs(reader, coeffTokenTab, H264Const.totalZeros16, coeff, 0, 16, zigzag4x4);
    };
    prototype.readACBlock = function(reader, coeff, blkIndX, blkIndY, leftAvailable, leftMbType, topAvailable, topMbType, firstCoeff, nCoeff, zigzag4x4) {
        var coeffTokenTab = this.getCoeffTokenVLCForLuma(leftAvailable, leftMbType, this.tokensLeft[blkIndY & this.mbMask], topAvailable, topMbType, this.tokensTop[blkIndX]);
        var readCoeffs = this.readCoeffs(reader, coeffTokenTab, H264Const.totalZeros16, coeff, firstCoeff, nCoeff, zigzag4x4);
        this.tokensLeft[blkIndY & this.mbMask] = this.tokensTop[blkIndX] = readCoeffs;
        return CAVLC.totalCoeff(readCoeffs);
    };
    prototype.setZeroCoeff = function(blkIndX, blkIndY) {
        this.tokensLeft[blkIndY & this.mbMask] = this.tokensTop[blkIndX] = 0;
    };
}, {color: "ColorSpace", chromaDCVLC: "VLC", tokensLeft: "Int32Array", tokensTop: "Int32Array", tokensLeftSaved: "Int32Array", tokensTopSaved: "Int32Array", NO_ZIGZAG: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Prediction builder for chroma samples
 *  
 *  @author The JCodec project
 *  
 */
var ChromaPredictionBuilder = function() {};
ChromaPredictionBuilder = stjs.extend(ChromaPredictionBuilder, null, [], function(constructor, prototype) {
    constructor.predictWithMode = function(residual, chromaMode, mbX, leftAvailable, topAvailable, leftRow, topLine, topLeft, pixOut) {
        switch (chromaMode) {
            case 0:
                ChromaPredictionBuilder.predictDC(residual, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut);
                break;
            case 1:
                ChromaPredictionBuilder.predictHorizontal(residual, mbX, leftAvailable, leftRow, pixOut);
                break;
            case 2:
                ChromaPredictionBuilder.predictVertical(residual, mbX, topAvailable, topLine, pixOut);
                break;
            case 3:
                ChromaPredictionBuilder.predictPlane(residual, mbX, leftAvailable, topAvailable, leftRow, topLine, topLeft, pixOut);
                break;
        }
    };
    constructor.predictDC = function(planeData, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut) {
        ChromaPredictionBuilder.predictDCInside(planeData, 0, 0, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut);
        ChromaPredictionBuilder.predictDCTopBorder(planeData, 1, 0, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut);
        ChromaPredictionBuilder.predictDCLeftBorder(planeData, 0, 1, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut);
        ChromaPredictionBuilder.predictDCInside(planeData, 1, 1, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut);
    };
    constructor.predictVertical = function(residual, mbX, topAvailable, topLine, pixOut) {
        for (var off = 0, j = 0; j < 8; j++) {
            for (var i = 0; i < 8; i++ , off++) 
                pixOut[off] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off]][H264Const.CHROMA_POS_LUT[off]] + topLine[(mbX << 3) + i], -128, 127) << 24 >> 24);
        }
    };
    constructor.predictHorizontal = function(residual, mbX, leftAvailable, leftRow, pixOut) {
        for (var off = 0, j = 0; j < 8; j++) {
            for (var i = 0; i < 8; i++ , off++) 
                pixOut[off] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off]][H264Const.CHROMA_POS_LUT[off]] + leftRow[j], -128, 127) << 24 >> 24);
        }
    };
    constructor.predictDCInside = function(residual, blkX, blkY, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut) {
        var s0, blkOffX = (blkX << 2) + (mbX << 3), blkOffY = blkY << 2;
        if (leftAvailable && topAvailable) {
            s0 = 0;
            for (var i = 0; i < 4; i++) 
                s0 += leftRow[i + blkOffY];
            for (var i = 0; i < 4; i++) 
                s0 += topLine[blkOffX + i];
            s0 = (s0 + 4) >> 3;
        } else if (leftAvailable) {
            s0 = 0;
            for (var i = 0; i < 4; i++) 
                s0 += leftRow[blkOffY + i];
            s0 = (s0 + 2) >> 2;
        } else if (topAvailable) {
            s0 = 0;
            for (var i = 0; i < 4; i++) 
                s0 += topLine[blkOffX + i];
            s0 = (s0 + 2) >> 2;
        } else {
            s0 = 0;
        }
        for (var off = (blkY << 5) + (blkX << 2), j = 0; j < 4; j++ , off += 8) {
            pixOut[off] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off]][H264Const.CHROMA_POS_LUT[off]] + s0, -128, 127) << 24 >> 24);
            pixOut[off + 1] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 1]][H264Const.CHROMA_POS_LUT[off + 1]] + s0, -128, 127) << 24 >> 24);
            pixOut[off + 2] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 2]][H264Const.CHROMA_POS_LUT[off + 2]] + s0, -128, 127) << 24 >> 24);
            pixOut[off + 3] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 3]][H264Const.CHROMA_POS_LUT[off + 3]] + s0, -128, 127) << 24 >> 24);
        }
    };
    constructor.predictDCTopBorder = function(residual, blkX, blkY, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut) {
        var s1, blkOffX = (blkX << 2) + (mbX << 3), blkOffY = blkY << 2;
        if (topAvailable) {
            s1 = 0;
            for (var i = 0; i < 4; i++) 
                s1 += topLine[blkOffX + i];
            s1 = (s1 + 2) >> 2;
        } else if (leftAvailable) {
            s1 = 0;
            for (var i = 0; i < 4; i++) 
                s1 += leftRow[blkOffY + i];
            s1 = (s1 + 2) >> 2;
        } else {
            s1 = 0;
        }
        for (var off = (blkY << 5) + (blkX << 2), j = 0; j < 4; j++ , off += 8) {
            pixOut[off] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off]][H264Const.CHROMA_POS_LUT[off]] + s1, -128, 127) << 24 >> 24);
            pixOut[off + 1] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 1]][H264Const.CHROMA_POS_LUT[off + 1]] + s1, -128, 127) << 24 >> 24);
            pixOut[off + 2] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 2]][H264Const.CHROMA_POS_LUT[off + 2]] + s1, -128, 127) << 24 >> 24);
            pixOut[off + 3] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 3]][H264Const.CHROMA_POS_LUT[off + 3]] + s1, -128, 127) << 24 >> 24);
        }
    };
    constructor.predictDCLeftBorder = function(residual, blkX, blkY, mbX, leftAvailable, topAvailable, leftRow, topLine, pixOut) {
        var s2, blkOffX = (blkX << 2) + (mbX << 3), blkOffY = blkY << 2;
        if (leftAvailable) {
            s2 = 0;
            for (var i = 0; i < 4; i++) 
                s2 += leftRow[blkOffY + i];
            s2 = (s2 + 2) >> 2;
        } else if (topAvailable) {
            s2 = 0;
            for (var i = 0; i < 4; i++) 
                s2 += topLine[blkOffX + i];
            s2 = (s2 + 2) >> 2;
        } else {
            s2 = 0;
        }
        for (var off = (blkY << 5) + (blkX << 2), j = 0; j < 4; j++ , off += 8) {
            pixOut[off] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off]][H264Const.CHROMA_POS_LUT[off]] + s2, -128, 127) << 24 >> 24);
            pixOut[off + 1] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 1]][H264Const.CHROMA_POS_LUT[off + 1]] + s2, -128, 127) << 24 >> 24);
            pixOut[off + 2] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 2]][H264Const.CHROMA_POS_LUT[off + 2]] + s2, -128, 127) << 24 >> 24);
            pixOut[off + 3] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off + 3]][H264Const.CHROMA_POS_LUT[off + 3]] + s2, -128, 127) << 24 >> 24);
        }
    };
    constructor.predictPlane = function(residual, mbX, leftAvailable, topAvailable, leftRow, topLine, topLeft, pixOut) {
        var H = 0, blkOffX = (mbX << 3);
        for (var i = 0; i < 3; i++) {
            H += (i + 1) * (topLine[blkOffX + 4 + i] - topLine[blkOffX + 2 - i]);
        }
        H += 4 * (topLine[blkOffX + 7] - topLeft[0]);
        var V = 0;
        for (var j = 0; j < 3; j++) {
            V += (j + 1) * (leftRow[4 + j] - leftRow[2 - j]);
        }
        V += 4 * (leftRow[7] - topLeft[0]);
        var c = (34 * V + 32) >> 6;
        var b = (34 * H + 32) >> 6;
        var a = 16 * (leftRow[7] + topLine[blkOffX + 7]);
        for (var off = 0, j = 0; j < 8; j++) {
            for (var i = 0; i < 8; i++ , off++) {
                var val = (a + b * (i - 3) + c * (j - 3) + 16) >> 5;
                pixOut[off] = (MathUtil.clip(residual[H264Const.CHROMA_BLOCK_LUT[off]][H264Const.CHROMA_POS_LUT[off]] + MathUtil.clip(val, -128, 127), -128, 127) << 24 >> 24);
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author JCodec project
 *  
 */
var CABAC = function(mbWidth) {
    this.tmp = new Int32Array(16);
    this.chromaPredModeLeft = 0;
    this.chromaPredModeTop = new Int32Array(mbWidth);
    this.codedBlkLeft = [new Int32Array(4), new Int32Array(2), new Int32Array(2)];
    this.codedBlkTop = [new Int32Array(mbWidth << 2), new Int32Array(mbWidth << 1), new Int32Array(mbWidth << 1)];
    this.codedBlkDCLeft = new Int32Array(3);
    this.codedBlkDCTop = Array.apply(null, Array(3)).map(function() {
        return new Int32Array(mbWidth);
    });
    this.refIdxLeft = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(4);
    });
    this.refIdxTop = Array.apply(null, Array(2)).map(function() {
        return new Int32Array(mbWidth << 2);
    });
    this.skipFlagsTop = new Int8Array(mbWidth);
    this.mvdTop = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(2)).map(function() {
            return new Int32Array(mbWidth << 2);
        });
    });
    this.mvdLeft = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
    });
};
CABAC = stjs.extend(CABAC, null, [], function(constructor, prototype) {
    constructor.BlockType = function(codecBlockCtxOff, sigCoeffCtxOff, lastSigCoeffCtxOff, sigCoeffFlagFldCtxOff, lastSigCoeffFldCtxOff, coeffAbsLevelCtxOff, coeffAbsLevelAdjust) {
        this.codedBlockCtxOff = codecBlockCtxOff;
        this.sigCoeffFlagCtxOff = sigCoeffCtxOff;
        this.lastSigCoeffCtxOff = lastSigCoeffCtxOff;
        this.sigCoeffFlagFldCtxOff = sigCoeffFlagFldCtxOff;
        this.lastSigCoeffFldCtxOff = sigCoeffFlagFldCtxOff;
        this.coeffAbsLevelCtxOff = coeffAbsLevelCtxOff;
        this.coeffAbsLevelAdjust = coeffAbsLevelAdjust;
    };
    constructor.BlockType = stjs.extend(constructor.BlockType, null, [], function(constructor, prototype) {
        constructor.LUMA_16_DC = new CABAC.BlockType(85, 105, 166, 277, 338, 227, 0);
        constructor.LUMA_15_AC = new CABAC.BlockType(89, 120, 181, 292, 353, 237, 0);
        constructor.LUMA_16 = new CABAC.BlockType(93, 134, 195, 306, 367, 247, 0);
        constructor.CHROMA_DC = new CABAC.BlockType(97, 149, 210, 321, 382, 257, 1);
        constructor.CHROMA_AC = new CABAC.BlockType(101, 152, 213, 324, 385, 266, 0);
        constructor.LUMA_64 = new CABAC.BlockType(1012, 402, 417, 436, 451, 426, 0);
        constructor.CB_16_DC = new CABAC.BlockType(460, 484, 572, 776, 864, 952, 0);
        constructor.CB_15x16_AC = new CABAC.BlockType(464, 499, 587, 791, 879, 962, 0);
        constructor.CB_16 = new CABAC.BlockType(468, 513, 601, 805, 893, 972, 0);
        constructor.CB_64 = new CABAC.BlockType(1016, 660, 690, 675, 699, 708, 0);
        constructor.CR_16_DC = new CABAC.BlockType(472, 528, 616, 820, 908, 982, 0);
        constructor.CR_15x16_AC = new CABAC.BlockType(476, 543, 631, 835, 923, 992, 0);
        constructor.CR_16 = new CABAC.BlockType(480, 557, 645, 849, 937, 1002, 0);
        constructor.CR_64 = new CABAC.BlockType(1020, 718, 748, 733, 757, 766, 0);
        prototype.codedBlockCtxOff = 0;
        prototype.sigCoeffFlagCtxOff = 0;
        prototype.lastSigCoeffCtxOff = 0;
        prototype.sigCoeffFlagFldCtxOff = 0;
        prototype.lastSigCoeffFldCtxOff = 0;
        prototype.coeffAbsLevelCtxOff = 0;
        prototype.coeffAbsLevelAdjust = 0;
    }, {LUMA_16_DC: "CABAC.BlockType", LUMA_15_AC: "CABAC.BlockType", LUMA_16: "CABAC.BlockType", CHROMA_DC: "CABAC.BlockType", CHROMA_AC: "CABAC.BlockType", LUMA_64: "CABAC.BlockType", CB_16_DC: "CABAC.BlockType", CB_15x16_AC: "CABAC.BlockType", CB_16: "CABAC.BlockType", CB_64: "CABAC.BlockType", CR_16_DC: "CABAC.BlockType", CR_15x16_AC: "CABAC.BlockType", CR_16: "CABAC.BlockType", CR_64: "CABAC.BlockType"}, {});
    prototype.chromaPredModeLeft = 0;
    prototype.chromaPredModeTop = null;
    prototype.prevMbQpDelta = 0;
    prototype.prevCBP = 0;
    prototype.codedBlkLeft = null;
    prototype.codedBlkTop = null;
    prototype.codedBlkDCLeft = null;
    prototype.codedBlkDCTop = null;
    prototype.refIdxLeft = null;
    prototype.refIdxTop = null;
    prototype.skipFlagLeft = false;
    prototype.skipFlagsTop = null;
    prototype.mvdTop = null;
    prototype.mvdLeft = null;
    prototype.tmp = null;
    prototype.readCoeffs = function(decoder, blockType, out, first, num, reorder, scMapping, lscMapping) {
        var sigCoeff = new Int8Array(num);
        var numCoeff;
        for (numCoeff = 0; numCoeff < num - 1; numCoeff++) {
            sigCoeff[numCoeff] = decoder.decodeBin(blockType.sigCoeffFlagCtxOff + scMapping[numCoeff]) == 1;
            if (sigCoeff[numCoeff] && decoder.decodeBin(blockType.lastSigCoeffCtxOff + lscMapping[numCoeff]) == 1) 
                break;
        }
        sigCoeff[numCoeff++] = true;
        var numGt1 = 0, numEq1 = 0;
        for (var j = numCoeff - 1; j >= 0; j--) {
            if (!sigCoeff[j]) 
                continue;
            var absLev = this.readCoeffAbsLevel(decoder, blockType, numGt1, numEq1);
            if (absLev == 0) 
                ++numEq1;
             else 
                ++numGt1;
            out[reorder[j + first]] = MathUtil.toSigned(absLev + 1, -decoder.decodeBinBypass());
        }
        return numGt1 + numEq1;
    };
    prototype.readCoeffAbsLevel = function(decoder, blockType, numDecodAbsLevelGt1, numDecodAbsLevelEq1) {
        var incB0 = ((numDecodAbsLevelGt1 != 0) ? 0 : Math.min(4, 1 + numDecodAbsLevelEq1));
        var incBN = 5 + Math.min(4 - blockType.coeffAbsLevelAdjust, numDecodAbsLevelGt1);
        var val, b = decoder.decodeBin(blockType.coeffAbsLevelCtxOff + incB0);
        for (val = 0; b != 0 && val < 13; val++) 
            b = decoder.decodeBin(blockType.coeffAbsLevelCtxOff + incBN);
        val += b;
        if (val == 14) {
            var log = -2, add = 0, sum = 0;
            do {
                log++;
                b = decoder.decodeBinBypass();
            } while (b != 0);
            for (; log >= 0; log--) {
                add |= decoder.decodeBinBypass() << log;
                sum += 1 << log;
            }
            val += add + sum;
        }
        return val;
    };
    prototype.writeCoeffs = function(encoder, blockType, _out, first, num, reorder) {
        for (var i = 0; i < num; i++) 
            this.tmp[i] = _out[reorder[first + i]];
        var numCoeff = 0;
        for (var i = 0; i < num; i++) {
            if (this.tmp[i] != 0) 
                numCoeff = i + 1;
        }
        for (var i = 0; i < Math.min(numCoeff, num - 1); i++) {
            if (this.tmp[i] != 0) {
                encoder.encodeBin(blockType.sigCoeffFlagCtxOff + i, 1);
                encoder.encodeBin(blockType.lastSigCoeffCtxOff + i, i == numCoeff - 1 ? 1 : 0);
            } else {
                encoder.encodeBin(blockType.sigCoeffFlagCtxOff + i, 0);
            }
        }
        var numGt1 = 0, numEq1 = 0;
        for (var j = numCoeff - 1; j >= 0; j--) {
            if (this.tmp[j] == 0) 
                continue;
            var absLev = MathUtil.abs(this.tmp[j]) - 1;
            this.writeCoeffAbsLevel(encoder, blockType, numGt1, numEq1, absLev);
            if (absLev == 0) 
                ++numEq1;
             else 
                ++numGt1;
            encoder.encodeBinBypass(MathUtil.sign(this.tmp[j]));
        }
    };
    prototype.writeCoeffAbsLevel = function(encoder, blockType, numDecodAbsLevelGt1, numDecodAbsLevelEq1, absLev) {
        var incB0 = ((numDecodAbsLevelGt1 != 0) ? 0 : Math.min(4, 1 + numDecodAbsLevelEq1));
        var incBN = 5 + Math.min(4 - blockType.coeffAbsLevelAdjust, numDecodAbsLevelGt1);
        if (absLev == 0) {
            encoder.encodeBin(blockType.coeffAbsLevelCtxOff + incB0, 0);
        } else {
            encoder.encodeBin(blockType.coeffAbsLevelCtxOff + incB0, 1);
            if (absLev < 14) {
                for (var i = 1; i < absLev; i++) 
                    encoder.encodeBin(blockType.coeffAbsLevelCtxOff + incBN, 1);
                encoder.encodeBin(blockType.coeffAbsLevelCtxOff + incBN, 0);
            } else {
                for (var i = 1; i < 14; i++) 
                    encoder.encodeBin(blockType.coeffAbsLevelCtxOff + incBN, 1);
                absLev -= 14;
                var sufLen, pow;
                for (sufLen = 0 , pow = 1; absLev >= pow; sufLen++ , pow = (1 << sufLen)) {
                    encoder.encodeBinBypass(1);
                    absLev -= pow;
                }
                encoder.encodeBinBypass(0);
                for (sufLen--; sufLen >= 0; sufLen--) 
                    encoder.encodeBinBypass((absLev >> sufLen) & 1);
            }
        }
    };
    prototype.initModels = function(cm, sliceType, cabacIdc, sliceQp) {
        var tabA = sliceType.isIntra() ? CABACContst.cabac_context_init_I_A : CABACContst.cabac_context_init_PB_A[cabacIdc];
        var tabB = sliceType.isIntra() ? CABACContst.cabac_context_init_I_B : CABACContst.cabac_context_init_PB_B[cabacIdc];
        for (var i = 0; i < 1024; i++) {
            var preCtxState = MathUtil.clip(((tabA[i] * MathUtil.clip(sliceQp, 0, 51)) >> 4) + tabB[i], 1, 126);
            if (preCtxState <= 63) {
                cm[0][i] = 63 - preCtxState;
                cm[1][i] = 0;
            } else {
                cm[0][i] = preCtxState - 64;
                cm[1][i] = 1;
            }
        }
    };
    prototype.readMBTypeI = function(decoder, left, top, leftAvailable, topAvailable) {
        var ctx = 3;
        ctx += !leftAvailable || left == MBType.I_NxN ? 0 : 1;
        ctx += !topAvailable || top == MBType.I_NxN ? 0 : 1;
        if (decoder.decodeBin(ctx) == 0) {
            return 0;
        } else {
            return decoder.decodeFinalBin() == 1 ? 25 : 1 + this.readMBType16x16(decoder);
        }
    };
    prototype.readMBType16x16 = function(decoder) {
        var type = decoder.decodeBin(6) * 12;
        if (decoder.decodeBin(7) == 0) {
            return type + (decoder.decodeBin(9) << 1) + decoder.decodeBin(10);
        } else {
            return type + (decoder.decodeBin(8) << 2) + (decoder.decodeBin(9) << 1) + decoder.decodeBin(10) + 4;
        }
    };
    prototype.readMBTypeP = function(decoder) {
        if (decoder.decodeBin(14) == 1) {
            return 5 + this.readIntraP(decoder, 17);
        } else {
            if (decoder.decodeBin(15) == 0) {
                return decoder.decodeBin(16) == 0 ? 0 : 3;
            } else {
                return decoder.decodeBin(17) == 0 ? 2 : 1;
            }
        }
    };
    prototype.readIntraP = function(decoder, ctxOff) {
        if (decoder.decodeBin(ctxOff) == 0) {
            return 0;
        } else {
            return decoder.decodeFinalBin() == 1 ? 25 : 1 + this.readMBType16x16P(decoder, ctxOff);
        }
    };
    prototype.readMBType16x16P = function(decoder, ctxOff) {
        ctxOff++;
        var type = decoder.decodeBin(ctxOff) * 12;
        ctxOff++;
        if (decoder.decodeBin(ctxOff) == 0) {
            ctxOff++;
            return type + (decoder.decodeBin(ctxOff) << 1) + decoder.decodeBin(ctxOff);
        } else {
            return type + (decoder.decodeBin(ctxOff) << 2) + (decoder.decodeBin(ctxOff + 1) << 1) + decoder.decodeBin(ctxOff + 1) + 4;
        }
    };
    prototype.readMBTypeB = function(mDecoder, left, top, leftAvailable, topAvailable) {
        var ctx = 27;
        ctx += !leftAvailable || left == null || left == MBType.B_Direct_16x16 ? 0 : 1;
        ctx += !topAvailable || top == null || top == MBType.B_Direct_16x16 ? 0 : 1;
        if (mDecoder.decodeBin(ctx) == 0) 
            return 0;
        if (mDecoder.decodeBin(30) == 0) 
            return 1 + mDecoder.decodeBin(32);
        var b1 = mDecoder.decodeBin(31);
        if (b1 == 0) {
            return 3 + ((mDecoder.decodeBin(32) << 2) | (mDecoder.decodeBin(32) << 1) | mDecoder.decodeBin(32));
        } else {
            if (mDecoder.decodeBin(32) == 0) {
                return 12 + ((mDecoder.decodeBin(32) << 2) | (mDecoder.decodeBin(32) << 1) | mDecoder.decodeBin(32));
            } else {
                switch ((mDecoder.decodeBin(32) << 1) + mDecoder.decodeBin(32)) {
                    case 0:
                        return 20 + mDecoder.decodeBin(32);
                    case 1:
                        return 23 + this.readIntraP(mDecoder, 32);
                    case 2:
                        return 11;
                    case 3:
                        return 22;
                }
            }
        }
        return 0;
    };
    prototype.writeMBTypeI = function(encoder, left, top, leftAvailable, topAvailable, mbType) {
        var ctx = 3;
        ctx += !leftAvailable || left == MBType.I_NxN ? 0 : 1;
        ctx += !topAvailable || top == MBType.I_NxN ? 0 : 1;
        if (mbType == 0) 
            encoder.encodeBin(ctx, 0);
         else {
            encoder.encodeBin(ctx, 1);
            if (mbType == 25) 
                encoder.encodeBinFinal(1);
             else {
                encoder.encodeBinFinal(0);
                this.writeMBType16x16(encoder, mbType - 1);
            }
        }
    };
    prototype.writeMBType16x16 = function(encoder, mbType) {
        if (mbType < 12) {
            encoder.encodeBin(6, 0);
        } else {
            encoder.encodeBin(6, 1);
            mbType -= 12;
        }
        if (mbType < 4) {
            encoder.encodeBin(7, 0);
            encoder.encodeBin(9, mbType >> 1);
            encoder.encodeBin(10, mbType & 1);
        } else {
            mbType -= 4;
            encoder.encodeBin(7, 1);
            encoder.encodeBin(8, mbType >> 2);
            encoder.encodeBin(9, (mbType >> 1) & 1);
            encoder.encodeBin(10, mbType & 1);
        }
    };
    prototype.readMBQpDelta = function(decoder, prevMbType) {
        var ctx = 60;
        ctx += prevMbType == null || prevMbType == MBType.I_PCM || (prevMbType != MBType.I_16x16 && this.prevCBP == 0) || this.prevMbQpDelta == 0 ? 0 : 1;
        var val = 0;
        if (decoder.decodeBin(ctx) == 1) {
            val++;
            if (decoder.decodeBin(62) == 1) {
                val++;
                 while (decoder.decodeBin(63) == 1)
                    val++;
            }
        }
        this.prevMbQpDelta = H264Utils2.golomb2Signed(val);
        return this.prevMbQpDelta;
    };
    prototype.writeMBQpDelta = function(encoder, prevMbType, mbQpDelta) {
        var ctx = 60;
        ctx += prevMbType == null || prevMbType == MBType.I_PCM || (prevMbType != MBType.I_16x16 && this.prevCBP == 0) || this.prevMbQpDelta == 0 ? 0 : 1;
        this.prevMbQpDelta = mbQpDelta;
        if (mbQpDelta-- == 0) 
            encoder.encodeBin(ctx, 0);
         else {
            encoder.encodeBin(ctx, 1);
            if (mbQpDelta-- == 0) 
                encoder.encodeBin(62, 0);
             else {
                 while (mbQpDelta-- > 0)
                    encoder.encodeBin(63, 1);
                encoder.encodeBin(63, 0);
            }
        }
    };
    prototype.readIntraChromaPredMode = function(decoder, mbX, left, top, leftAvailable, topAvailable) {
        var ctx = 64;
        ctx += !leftAvailable || left == null || !left.isIntra() || this.chromaPredModeLeft == 0 ? 0 : 1;
        ctx += !topAvailable || top == null || !top.isIntra() || this.chromaPredModeTop[mbX] == 0 ? 0 : 1;
        var mode;
        if (decoder.decodeBin(ctx) == 0) 
            mode = 0;
         else if (decoder.decodeBin(67) == 0) 
            mode = 1;
         else if (decoder.decodeBin(67) == 0) 
            mode = 2;
         else 
            mode = 3;
        this.chromaPredModeLeft = this.chromaPredModeTop[mbX] = mode;
        return mode;
    };
    prototype.writeIntraChromaPredMode = function(encoder, mbX, left, top, leftAvailable, topAvailable, mode) {
        var ctx = 64;
        ctx += !leftAvailable || !left.isIntra() || this.chromaPredModeLeft == 0 ? 0 : 1;
        ctx += !topAvailable || !top.isIntra() || this.chromaPredModeTop[mbX] == 0 ? 0 : 1;
        encoder.encodeBin(ctx, mode-- == 0 ? 0 : 1);
        for (var i = 0; mode >= 0 && i < 2; i++) 
            encoder.encodeBin(67, mode-- == 0 ? 0 : 1);
        this.chromaPredModeLeft = this.chromaPredModeTop[mbX] = mode;
    };
    prototype.condTerm = function(mbCur, nAvb, mbN, nBlkAvb, cbpN) {
        if (!nAvb) 
            return mbCur.isIntra() ? 1 : 0;
        if (mbN == MBType.I_PCM) 
            return 1;
        if (!nBlkAvb) 
            return 0;
        return cbpN;
    };
    prototype.readCodedBlockFlagLumaDC = function(decoder, mbX, left, top, leftAvailable, topAvailable, cur) {
        var tLeft = this.condTerm(cur, leftAvailable, left, left == MBType.I_16x16, this.codedBlkDCLeft[0]);
        var tTop = this.condTerm(cur, topAvailable, top, top == MBType.I_16x16, this.codedBlkDCTop[0][mbX]);
        var decoded = decoder.decodeBin(CABAC.BlockType.LUMA_16_DC.codedBlockCtxOff + tLeft + 2 * tTop);
        this.codedBlkDCLeft[0] = decoded;
        this.codedBlkDCTop[0][mbX] = decoded;
        return decoded;
    };
    prototype.readCodedBlockFlagChromaDC = function(decoder, mbX, comp, left, top, leftAvailable, topAvailable, leftCBPChroma, topCBPChroma, cur) {
        var tLeft = this.condTerm(cur, leftAvailable, left, left != null && leftCBPChroma != 0, this.codedBlkDCLeft[comp]);
        var tTop = this.condTerm(cur, topAvailable, top, top != null && topCBPChroma != 0, this.codedBlkDCTop[comp][mbX]);
        var decoded = decoder.decodeBin(CABAC.BlockType.CHROMA_DC.codedBlockCtxOff + tLeft + 2 * tTop);
        this.codedBlkDCLeft[comp] = decoded;
        this.codedBlkDCTop[comp][mbX] = decoded;
        return decoded;
    };
    prototype.readCodedBlockFlagLumaAC = function(decoder, blkType, blkX, blkY, comp, left, top, leftAvailable, topAvailable, leftCBPLuma, topCBPLuma, curCBPLuma, cur) {
        var blkOffLeft = blkX & 3, blkOffTop = blkY & 3;
        var tLeft;
        if (blkOffLeft == 0) 
            tLeft = this.condTerm(cur, leftAvailable, left, left != null && left != MBType.I_PCM && this.cbp(leftCBPLuma, 3, blkOffTop), this.codedBlkLeft[comp][blkOffTop]);
         else 
            tLeft = this.condTerm(cur, true, cur, this.cbp(curCBPLuma, blkOffLeft - 1, blkOffTop), this.codedBlkLeft[comp][blkOffTop]);
        var tTop;
        if (blkOffTop == 0) 
            tTop = this.condTerm(cur, topAvailable, top, top != null && top != MBType.I_PCM && this.cbp(topCBPLuma, blkOffLeft, 3), this.codedBlkTop[comp][blkX]);
         else 
            tTop = this.condTerm(cur, true, cur, this.cbp(curCBPLuma, blkOffLeft, blkOffTop - 1), this.codedBlkTop[comp][blkX]);
        var decoded = decoder.decodeBin(blkType.codedBlockCtxOff + tLeft + 2 * tTop);
        this.codedBlkLeft[comp][blkOffTop] = decoded;
        this.codedBlkTop[comp][blkX] = decoded;
        return decoded;
    };
    prototype.readCodedBlockFlagLuma64 = function(decoder, blkX, blkY, comp, left, top, leftAvailable, topAvailable, leftCBPLuma, topCBPLuma, curCBPLuma, cur, is8x8Left, is8x8Top) {
        var blkOffLeft = blkX & 3, blkOffTop = blkY & 3;
        var tLeft;
        if (blkOffLeft == 0) 
            tLeft = this.condTerm(cur, leftAvailable, left, left != null && left != MBType.I_PCM && is8x8Left && this.cbp(leftCBPLuma, 3, blkOffTop), this.codedBlkLeft[comp][blkOffTop]);
         else 
            tLeft = this.condTerm(cur, true, cur, this.cbp(curCBPLuma, blkOffLeft - 1, blkOffTop), this.codedBlkLeft[comp][blkOffTop]);
        var tTop;
        if (blkOffTop == 0) 
            tTop = this.condTerm(cur, topAvailable, top, top != null && top != MBType.I_PCM && is8x8Top && this.cbp(topCBPLuma, blkOffLeft, 3), this.codedBlkTop[comp][blkX]);
         else 
            tTop = this.condTerm(cur, true, cur, this.cbp(curCBPLuma, blkOffLeft, blkOffTop - 1), this.codedBlkTop[comp][blkX]);
        var decoded = decoder.decodeBin(CABAC.BlockType.LUMA_64.codedBlockCtxOff + tLeft + 2 * tTop);
        this.codedBlkLeft[comp][blkOffTop] = decoded;
        this.codedBlkTop[comp][blkX] = decoded;
        return decoded;
    };
    prototype.cbp = function(cbpLuma, blkX, blkY) {
        var x8x8 = (blkY & 2) + (blkX >> 1);
        return ((cbpLuma >> x8x8) & 1) == 1;
    };
    prototype.readCodedBlockFlagChromaAC = function(decoder, blkX, blkY, comp, left, top, leftAvailable, topAvailable, leftCBPChroma, topCBPChroma, cur) {
        var blkOffLeft = blkX & 1, blkOffTop = blkY & 1;
        var tLeft;
        if (blkOffLeft == 0) 
            tLeft = this.condTerm(cur, leftAvailable, left, left != null && left != MBType.I_PCM && (leftCBPChroma & 2) != 0, this.codedBlkLeft[comp][blkOffTop]);
         else 
            tLeft = this.condTerm(cur, true, cur, true, this.codedBlkLeft[comp][blkOffTop]);
        var tTop;
        if (blkOffTop == 0) 
            tTop = this.condTerm(cur, topAvailable, top, top != null && top != MBType.I_PCM && (topCBPChroma & 2) != 0, this.codedBlkTop[comp][blkX]);
         else 
            tTop = this.condTerm(cur, true, cur, true, this.codedBlkTop[comp][blkX]);
        var decoded = decoder.decodeBin(CABAC.BlockType.CHROMA_AC.codedBlockCtxOff + tLeft + 2 * tTop);
        this.codedBlkLeft[comp][blkOffTop] = decoded;
        this.codedBlkTop[comp][blkX] = decoded;
        return decoded;
    };
    prototype.prev4x4PredModeFlag = function(decoder) {
        return decoder.decodeBin(68) == 1;
    };
    prototype.rem4x4PredMode = function(decoder) {
        return decoder.decodeBin(69) | (decoder.decodeBin(69) << 1) | (decoder.decodeBin(69) << 2);
    };
    prototype.codedBlockPatternIntra = function(mDecoder, leftAvailable, topAvailable, cbpLeft, cbpTop, mbLeft, mbTop) {
        var cbp0 = mDecoder.decodeBin(73 + this._condTerm(leftAvailable, mbLeft, (cbpLeft >> 1) & 1) + 2 * this._condTerm(topAvailable, mbTop, (cbpTop >> 2) & 1));
        var cbp1 = mDecoder.decodeBin(73 + (1 - cbp0) + 2 * this._condTerm(topAvailable, mbTop, (cbpTop >> 3) & 1));
        var cbp2 = mDecoder.decodeBin(73 + this._condTerm(leftAvailable, mbLeft, (cbpLeft >> 3) & 1) + 2 * (1 - cbp0));
        var cbp3 = mDecoder.decodeBin(73 + (1 - cbp2) + 2 * (1 - cbp1));
        var cr0 = mDecoder.decodeBin(77 + this.condTermCr0(leftAvailable, mbLeft, cbpLeft >> 4) + 2 * this.condTermCr0(topAvailable, mbTop, cbpTop >> 4));
        var cr1 = cr0 != 0 ? mDecoder.decodeBin(81 + this.condTermCr1(leftAvailable, mbLeft, cbpLeft >> 4) + 2 * this.condTermCr1(topAvailable, mbTop, cbpTop >> 4)) : 0;
        return cbp0 | (cbp1 << 1) | (cbp2 << 2) | (cbp3 << 3) | (cr0 << 4) | (cr1 << 5);
    };
    prototype.condTermCr0 = function(avb, mbt, cbpChroma) {
        return avb && (mbt == MBType.I_PCM || mbt != null && cbpChroma != 0) ? 1 : 0;
    };
    prototype.condTermCr1 = function(avb, mbt, cbpChroma) {
        return avb && (mbt == MBType.I_PCM || mbt != null && (cbpChroma & 2) != 0) ? 1 : 0;
    };
    prototype._condTerm = function(avb, mbt, cbp) {
        return !avb || mbt == MBType.I_PCM || (mbt != null && cbp == 1) ? 0 : 1;
    };
    prototype.setPrevCBP = function(prevCBP) {
        this.prevCBP = prevCBP;
    };
    prototype.readMVD = function(decoder, comp, leftAvailable, topAvailable, leftType, topType, leftPred, topPred, curPred, mbX, partX, partY, partW, partH, list) {
        var ctx = comp == 0 ? 40 : 47;
        var partAbsX = (mbX << 2) + partX;
        var predEqA = leftPred != null && leftPred != H264Const.PartPred.Direct && (leftPred == H264Const.PartPred.Bi || leftPred == curPred || (curPred == H264Const.PartPred.Bi && H264Const.usesList(leftPred, list)));
        var predEqB = topPred != null && topPred != H264Const.PartPred.Direct && (topPred == H264Const.PartPred.Bi || topPred == curPred || (curPred == H264Const.PartPred.Bi && H264Const.usesList(topPred, list)));
        var absMvdComp = !leftAvailable || leftType == null || leftType.isIntra() || !predEqA ? 0 : Math.abs(this.mvdLeft[list][comp][partY]);
        absMvdComp += !topAvailable || topType == null || topType.isIntra() || !predEqB ? 0 : Math.abs(this.mvdTop[list][comp][partAbsX]);
        var val, b = decoder.decodeBin(ctx + (absMvdComp < 3 ? 0 : (absMvdComp > 32 ? 2 : 1)));
        for (val = 0; b != 0 && val < 8; val++) 
            b = decoder.decodeBin(Math.min(ctx + val + 3, ctx + 6));
        val += b;
        if (val != 0) {
            if (val == 9) {
                var log = 2, add = 0, sum = 0, leftover = 0;
                do {
                    sum += leftover;
                    log++;
                    b = decoder.decodeBinBypass();
                    leftover = 1 << log;
                } while (b != 0);
                --log;
                for (; log >= 0; log--) {
                    add |= decoder.decodeBinBypass() << log;
                }
                val += add + sum;
            }
            val = MathUtil.toSigned(val, -decoder.decodeBinBypass());
        }
        for (var i = 0; i < partW; i++) {
            this.mvdTop[list][comp][partAbsX + i] = val;
        }
        for (var i = 0; i < partH; i++) {
            this.mvdLeft[list][comp][partY + i] = val;
        }
        return val;
    };
    prototype.readRefIdx = function(mDecoder, leftAvailable, topAvailable, leftType, topType, leftPred, topPred, curPred, mbX, partX, partY, partW, partH, list) {
        var partAbsX = (mbX << 2) + partX;
        var predEqA = leftPred != null && leftPred != H264Const.PartPred.Direct && (leftPred == H264Const.PartPred.Bi || leftPred == curPred || (curPred == H264Const.PartPred.Bi && H264Const.usesList(leftPred, list)));
        var predEqB = topPred != null && topPred != H264Const.PartPred.Direct && (topPred == H264Const.PartPred.Bi || topPred == curPred || (curPred == H264Const.PartPred.Bi && H264Const.usesList(topPred, list)));
        var ctA = !leftAvailable || leftType == null || leftType.isIntra() || !predEqA || this.refIdxLeft[list][partY] == 0 ? 0 : 1;
        var ctB = !topAvailable || topType == null || topType.isIntra() || !predEqB || this.refIdxTop[list][partAbsX] == 0 ? 0 : 1;
        var b0 = mDecoder.decodeBin(54 + ctA + 2 * ctB);
        var val;
        if (b0 == 0) 
            val = 0;
         else {
            var b1 = mDecoder.decodeBin(58);
            if (b1 == 0) 
                val = 1;
             else {
                for (val = 2; mDecoder.decodeBin(59) == 1; val++) 
                    ;
            }
        }
        for (var i = 0; i < partW; i++) {
            this.refIdxTop[list][partAbsX + i] = val;
        }
        for (var i = 0; i < partH; i++) {
            this.refIdxLeft[list][partY + i] = val;
        }
        return val;
    };
    prototype.readMBSkipFlag = function(mDecoder, slType, leftAvailable, topAvailable, mbX) {
        var base = slType == SliceType.P ? 11 : 24;
        var ret = mDecoder.decodeBin(base + (leftAvailable && !this.skipFlagLeft ? 1 : 0) + (topAvailable && !this.skipFlagsTop[mbX] ? 1 : 0)) == 1;
        this.skipFlagLeft = this.skipFlagsTop[mbX] = ret;
        return ret;
    };
    prototype.readSubMbTypeP = function(mDecoder) {
        if (mDecoder.decodeBin(21) == 1) 
            return 0;
         else if (mDecoder.decodeBin(22) == 0) 
            return 1;
         else if (mDecoder.decodeBin(23) == 1) 
            return 2;
         else 
            return 3;
    };
    prototype.readSubMbTypeB = function(mDecoder) {
        if (mDecoder.decodeBin(36) == 0) 
            return 0;
        if (mDecoder.decodeBin(37) == 0) 
            return 1 + mDecoder.decodeBin(39);
        if (mDecoder.decodeBin(38) == 0) 
            return 3 + (mDecoder.decodeBin(39) << 1) + mDecoder.decodeBin(39);
        if (mDecoder.decodeBin(39) == 0) 
            return 7 + (mDecoder.decodeBin(39) << 1) + mDecoder.decodeBin(39);
        return 11 + mDecoder.decodeBin(39);
    };
    prototype.readTransform8x8Flag = function(mDecoder, leftAvailable, topAvailable, leftType, topType, is8x8Left, is8x8Top) {
        var ctx = 399 + (leftAvailable && leftType != null && is8x8Left ? 1 : 0) + (topAvailable && topType != null && is8x8Top ? 1 : 0);
        return mDecoder.decodeBin(ctx) == 1;
    };
    prototype.setCodedBlock = function(blkX, blkY) {
        this.codedBlkLeft[0][blkY & 3] = this.codedBlkTop[0][blkX] = 1;
    };
}, {chromaPredModeTop: "Int32Array", codedBlkLeft: "Array", codedBlkTop: "Array", codedBlkDCLeft: "Int32Array", codedBlkDCTop: "Array", refIdxLeft: "Array", refIdxTop: "Array", skipFlagsTop: "Int8Array", mvdTop: "Array", mvdLeft: "Array", tmp: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SequenceScalableExtension = function() {};
SequenceScalableExtension = stjs.extend(SequenceScalableExtension, null, [MPEGHeader], function(constructor, prototype) {
    constructor.DATA_PARTITIONING = 0;
    constructor.SPATIAL_SCALABILITY = 1;
    constructor.SNR_SCALABILITY = 2;
    constructor.TEMPORAL_SCALABILITY = 3;
    prototype.scalable_mode = 0;
    prototype.layer_id = 0;
    prototype.lower_layer_prediction_horizontal_size = 0;
    prototype.lower_layer_prediction_vertical_size = 0;
    prototype.horizontal_subsampling_factor_m = 0;
    prototype.horizontal_subsampling_factor_n = 0;
    prototype.vertical_subsampling_factor_m = 0;
    prototype.vertical_subsampling_factor_n = 0;
    prototype.picture_mux_enable = 0;
    prototype.mux_to_progressive_sequence = 0;
    prototype.picture_mux_order = 0;
    prototype.picture_mux_factor = 0;
    constructor.Sequence_Scalable_Extension = 5;
    constructor.read = function(_in) {
        var sse = new SequenceScalableExtension();
        sse.scalable_mode = _in.readNBit(2);
        sse.layer_id = _in.readNBit(4);
        if (sse.scalable_mode == SequenceScalableExtension.SPATIAL_SCALABILITY) {
            sse.lower_layer_prediction_horizontal_size = _in.readNBit(14);
            _in.read1Bit();
            sse.lower_layer_prediction_vertical_size = _in.readNBit(14);
            sse.horizontal_subsampling_factor_m = _in.readNBit(5);
            sse.horizontal_subsampling_factor_n = _in.readNBit(5);
            sse.vertical_subsampling_factor_m = _in.readNBit(5);
            sse.vertical_subsampling_factor_n = _in.readNBit(5);
        }
        if (sse.scalable_mode == SequenceScalableExtension.TEMPORAL_SCALABILITY) {
            sse.picture_mux_enable = _in.read1Bit();
            if (sse.picture_mux_enable != 0) 
                sse.mux_to_progressive_sequence = _in.read1Bit();
            sse.picture_mux_order = _in.readNBit(3);
            sse.picture_mux_factor = _in.readNBit(3);
        }
        return sse;
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(SequenceScalableExtension.Sequence_Scalable_Extension, 4);
        bw.writeNBit(this.scalable_mode, 2);
        bw.writeNBit(this.layer_id, 4);
        if (this.scalable_mode == SequenceScalableExtension.SPATIAL_SCALABILITY) {
            bw.writeNBit(this.lower_layer_prediction_horizontal_size, 14);
            bw.write1Bit(1);
            bw.writeNBit(this.lower_layer_prediction_vertical_size, 14);
            bw.writeNBit(this.horizontal_subsampling_factor_m, 5);
            bw.writeNBit(this.horizontal_subsampling_factor_n, 5);
            bw.writeNBit(this.vertical_subsampling_factor_m, 5);
            bw.writeNBit(this.vertical_subsampling_factor_n, 5);
        }
        if (this.scalable_mode == SequenceScalableExtension.TEMPORAL_SCALABILITY) {
            bw.write1Bit(this.picture_mux_enable);
            if (this.picture_mux_enable != 0) 
                bw.write1Bit(this.mux_to_progressive_sequence);
            bw.writeNBit(this.picture_mux_order, 3);
            bw.writeNBit(this.picture_mux_factor, 3);
        }
        bw.flush();
    };
    constructor.mbTypeVal = function(picture_coding_type, sse) {
        if (sse != null && sse.scalable_mode == SequenceScalableExtension.SNR_SCALABILITY) {
            return MPEGConst.mbTypeValSNR;
        } else if (sse != null && sse.scalable_mode == SequenceScalableExtension.SPATIAL_SCALABILITY) {
            return picture_coding_type == MPEGConst.IntraCoded ? MPEGConst.mbTypeValISpat : (picture_coding_type == MPEGConst.PredictiveCoded ? MPEGConst.mbTypeValPSpat : MPEGConst.mbTypeValBSpat);
        } else {
            return picture_coding_type == MPEGConst.IntraCoded ? MPEGConst.mbTypeValI : (picture_coding_type == MPEGConst.PredictiveCoded ? MPEGConst.mbTypeValP : MPEGConst.mbTypeValB);
        }
    };
    constructor.vlcMBType = function(picture_coding_type, sse) {
        if (sse != null && sse.scalable_mode == SequenceScalableExtension.SNR_SCALABILITY) {
            return MPEGConst.vlcMBTypeSNR;
        } else if (sse != null && sse.scalable_mode == SequenceScalableExtension.SPATIAL_SCALABILITY) {
            return picture_coding_type == MPEGConst.IntraCoded ? MPEGConst.vlcMBTypeISpat : (picture_coding_type == MPEGConst.PredictiveCoded ? MPEGConst.vlcMBTypePSpat : MPEGConst.vlcMBTypeBSpat);
        } else {
            return picture_coding_type == MPEGConst.IntraCoded ? MPEGConst.vlcMBTypeI : (picture_coding_type == MPEGConst.PredictiveCoded ? MPEGConst.vlcMBTypeP : MPEGConst.vlcMBTypeB);
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PictureHeader = function() {};
PictureHeader = stjs.extend(PictureHeader, null, [MPEGHeader], function(constructor, prototype) {
    prototype.temporal_reference = 0;
    prototype.picture_coding_type = 0;
    prototype.vbv_delay = 0;
    prototype.full_pel_forward_vector = 0;
    prototype.forward_f_code = 0;
    prototype.full_pel_backward_vector = 0;
    prototype.backward_f_code = 0;
    prototype.quantMatrixExtension = null;
    prototype.copyrightExtension = null;
    prototype.pictureDisplayExtension = null;
    prototype.pictureCodingExtension = null;
    prototype.pictureSpatialScalableExtension = null;
    prototype.pictureTemporalScalableExtension = null;
    prototype._hasExtensions = false;
    constructor.createPictureHeader = function(temporal_reference, picture_coding_type, vbv_delay, full_pel_forward_vector, forward_f_code, full_pel_backward_vector, backward_f_code) {
        var p = new PictureHeader();
        p.temporal_reference = temporal_reference;
        p.picture_coding_type = picture_coding_type;
        p.vbv_delay = vbv_delay;
        p.full_pel_forward_vector = full_pel_forward_vector;
        p.forward_f_code = forward_f_code;
        p.full_pel_backward_vector = full_pel_backward_vector;
        p.backward_f_code = backward_f_code;
        return p;
    };
    constructor.read = function(bb) {
        var _in = BitReader.createBitReader(bb);
        var ph = new PictureHeader();
        ph.temporal_reference = _in.readNBit(10);
        ph.picture_coding_type = _in.readNBit(3);
        ph.vbv_delay = _in.readNBit(16);
        if (ph.picture_coding_type == 2 || ph.picture_coding_type == 3) {
            ph.full_pel_forward_vector = _in.read1Bit();
            ph.forward_f_code = _in.readNBit(3);
        }
        if (ph.picture_coding_type == 3) {
            ph.full_pel_backward_vector = _in.read1Bit();
            ph.backward_f_code = _in.readNBit(3);
        }
         while (_in.read1Bit() == 1){
            _in.readNBit(8);
        }
        return ph;
    };
    constructor.readExtension = function(bb, ph, sh) {
        ph._hasExtensions = true;
        var _in = BitReader.createBitReader(bb);
        var extType = _in.readNBit(4);
        switch (extType) {
            case QuantMatrixExtension.Quant_Matrix_Extension:
                ph.quantMatrixExtension = QuantMatrixExtension.read(_in);
                break;
            case CopyrightExtension.Copyright_Extension:
                ph.copyrightExtension = CopyrightExtension.read(_in);
                break;
            case PictureDisplayExtension.Picture_Display_Extension:
                ph.pictureDisplayExtension = PictureDisplayExtension.read(_in, sh.sequenceExtension, ph.pictureCodingExtension);
                break;
            case PictureCodingExtension.Picture_Coding_Extension:
                ph.pictureCodingExtension = PictureCodingExtension.read(_in);
                break;
            case PictureSpatialScalableExtension.Picture_Spatial_Scalable_Extension:
                ph.pictureSpatialScalableExtension = PictureSpatialScalableExtension.read(_in);
                break;
            case PictureTemporalScalableExtension.Picture_Temporal_Scalable_Extension:
                ph.pictureTemporalScalableExtension = PictureTemporalScalableExtension.read(_in);
                break;
            default:
                 throw new RuntimeException("Unsupported extension: " + extType);
        }
    };
    prototype.write = function(os) {
        var out = new BitWriter(os);
        out.writeNBit(this.temporal_reference, 10);
        out.writeNBit(this.picture_coding_type, 3);
        out.writeNBit(this.vbv_delay, 16);
        if (this.picture_coding_type == 2 || this.picture_coding_type == 3) {
            out.write1Bit(this.full_pel_forward_vector);
            out.write1Bit(this.forward_f_code);
        }
        if (this.picture_coding_type == 3) {
            out.write1Bit(this.full_pel_backward_vector);
            out.writeNBit(this.backward_f_code, 3);
        }
        out.write1Bit(0);
        out.flush();
        this.writeExtensions(os);
    };
    prototype.writeExtensions = function(out) {
        if (this.quantMatrixExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.quantMatrixExtension.write(out);
        }
        if (this.copyrightExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.copyrightExtension.write(out);
        }
        if (this.pictureCodingExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.pictureCodingExtension.write(out);
        }
        if (this.pictureDisplayExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.pictureDisplayExtension.write(out);
        }
        if (this.pictureSpatialScalableExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.pictureSpatialScalableExtension.write(out);
        }
        if (this.pictureTemporalScalableExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.pictureTemporalScalableExtension.write(out);
        }
    };
    prototype.hasExtensions = function() {
        return this._hasExtensions;
    };
}, {quantMatrixExtension: "QuantMatrixExtension", copyrightExtension: "CopyrightExtension", pictureDisplayExtension: "PictureDisplayExtension", pictureCodingExtension: "PictureCodingExtension", pictureSpatialScalableExtension: "PictureSpatialScalableExtension", pictureTemporalScalableExtension: "PictureTemporalScalableExtension"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 1/2 decoder interframe motion compensation routines
 *  
 *  @author The JCodec project
 *  
 */
var MPEGPred = function(fCode, chromaFormat, topFieldFirst) {
    this.mvPred = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(2)).map(function() {
            return new Int32Array(2);
        });
    });
    this.fCode = fCode;
    this.chromaFormat = chromaFormat;
    this.topFieldFirst = topFieldFirst;
};
MPEGPred = stjs.extend(MPEGPred, null, [], function(constructor, prototype) {
    prototype.mvPred = null;
    prototype.chromaFormat = 0;
    prototype.fCode = null;
    prototype.topFieldFirst = false;
    prototype.predictFullXFullYSafe = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var offRef = ((refY << refVertStep) + refVertOff) * refW + refX, offTgt = tgtW * tgtY, lfRef = (refW << refVertStep) - tgtW, lfTgt = tgtVertStep * tgtW;
        for (var i = 0; i < tgtH; i++) {
            for (var j = 0; j < tgtW; j++) 
                tgt[offTgt++] = ref[offRef++] + 128;
            offRef += lfRef;
            offTgt += lfTgt;
        }
    };
    prototype.predictEvenOddSafe = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var offRef = ((refY << refVertStep) + refVertOff) * refW + refX, offTgt = tgtW * tgtY, lfRef = (refW << refVertStep) - tgtW, lfTgt = tgtVertStep * tgtW;
        for (var i = 0; i < tgtH; i++) {
            for (var j = 0; j < tgtW; j++) {
                tgt[offTgt++] = ((ref[offRef] + ref[offRef + 1] + 1) >> 1) + 128;
                ++offRef;
            }
            offRef += lfRef;
            offTgt += lfTgt;
        }
    };
    prototype.predictOddEvenSafe = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var offRef = ((refY << refVertStep) + refVertOff) * refW + refX, offTgt = tgtW * tgtY, lfRef = (refW << refVertStep) - tgtW, lfTgt = tgtVertStep * tgtW, stride = refW << refVertStep;
        for (var i = 0; i < tgtH; i++) {
            for (var j = 0; j < tgtW; j++) {
                tgt[offTgt++] = ((ref[offRef] + ref[offRef + stride] + 1) >> 1) + 128;
                ++offRef;
            }
            offRef += lfRef;
            offTgt += lfTgt;
        }
    };
    prototype.predictOddOddSafe = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var offRef = ((refY << refVertStep) + refVertOff) * refW + refX, offTgt = tgtW * tgtY, lfRef = (refW << refVertStep) - tgtW, lfTgt = tgtVertStep * tgtW, stride = refW << refVertStep;
        for (var i = 0; i < tgtH; i++) {
            for (var j = 0; j < tgtW; j++) {
                tgt[offTgt++] = ((ref[offRef] + ref[offRef + 1] + ref[offRef + stride] + ref[offRef + stride + 1] + 3) >> 2) + 128;
                ++offRef;
            }
            offRef += lfRef;
            offTgt += lfTgt;
        }
    };
    prototype.getPix1 = function(ref, refW, refH, x, y, refVertStep, refVertOff) {
        x = MathUtil.clip(x, 0, refW - 1);
        y = MathUtil.clip(y, 0, refH - (1 << refVertStep) + refVertOff);
        return ref[y * refW + x] + 128;
    };
    prototype.getPix2 = function(ref, refW, refH, x1, y1, x2, y2, refVertStep, refVertOff) {
        x1 = MathUtil.clip(x1, 0, refW - 1);
        var lastLine = refH - (1 << refVertStep) + refVertOff;
        y1 = MathUtil.clip(y1, 0, lastLine);
        x2 = MathUtil.clip(x2, 0, refW - 1);
        y2 = MathUtil.clip(y2, 0, lastLine);
        return ((ref[y1 * refW + x1] + ref[y2 * refW + x2] + 1) >> 1) + 128;
    };
    prototype.getPix4 = function(ref, refW, refH, x1, y1, x2, y2, x3, y3, x4, y4, refVertStep, refVertOff) {
        var lastLine = refH - (1 << refVertStep) + refVertOff;
        x1 = MathUtil.clip(x1, 0, refW - 1);
        y1 = MathUtil.clip(y1, 0, lastLine);
        x2 = MathUtil.clip(x2, 0, refW - 1);
        y2 = MathUtil.clip(y2, 0, lastLine);
        x3 = MathUtil.clip(x3, 0, refW - 1);
        y3 = MathUtil.clip(y3, 0, lastLine);
        x4 = MathUtil.clip(x4, 0, refW - 1);
        y4 = MathUtil.clip(y4, 0, lastLine);
        return ((ref[y1 * refW + x1] + ref[y2 * refW + x2] + ref[y3 * refW + x3] + ref[y4 * refW + x4] + 3) >> 2) + 128;
    };
    prototype.predictFullXFullYUnSafe = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var tgtOff = tgtW * tgtY, jump = tgtVertStep * tgtW;
        for (var j = 0; j < tgtH; j++) {
            var y = ((j + refY) << refVertStep) + refVertOff;
            for (var i = 0; i < tgtW; i++) {
                tgt[tgtOff++] = this.getPix1(ref, refW, refH, i + refX, y, refVertStep, refVertOff);
            }
            tgtOff += jump;
        }
    };
    prototype.predictEvenOddUnSafe = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var tgtOff = tgtW * tgtY, jump = tgtVertStep * tgtW;
        for (var j = 0; j < tgtH; j++) {
            var y = ((j + refY) << refVertStep) + refVertOff;
            for (var i = 0; i < tgtW; i++) {
                tgt[tgtOff++] = this.getPix2(ref, refW, refH, i + refX, y, i + refX + 1, y, refVertStep, refVertOff);
            }
            tgtOff += jump;
        }
    };
    prototype.predictOddEvenUnSafe = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var tgtOff = tgtW * tgtY, jump = tgtVertStep * tgtW;
        for (var j = 0; j < tgtH; j++) {
            var y1 = ((j + refY) << refVertStep) + refVertOff;
            var y2 = ((j + refY + 1) << refVertStep) + refVertOff;
            for (var i = 0; i < tgtW; i++) {
                tgt[tgtOff++] = this.getPix2(ref, refW, refH, i + refX, y1, i + refX, y2, refVertStep, refVertOff);
            }
            tgtOff += jump;
        }
    };
    prototype.predictOddOddUnSafe = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var tgtOff = tgtW * tgtY, jump = tgtVertStep * tgtW;
        for (var j = 0; j < tgtH; j++) {
            var y1 = ((j + refY) << refVertStep) + refVertOff;
            var y2 = ((j + refY + 1) << refVertStep) + refVertOff;
            for (var i = 0; i < tgtW; i++) {
                var ptX = i + refX;
                tgt[tgtOff++] = this.getPix4(ref, refW, refH, ptX, y1, ptX + 1, y1, ptX, y2, ptX + 1, y2, refVertStep, refVertOff);
            }
            tgtOff += jump;
        }
    };
    prototype.predictPlane = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var rx = refX >> 1, ry = refY >> 1;
        var safe = rx >= 0 && ry >= 0 && rx + tgtW < refW && (ry + tgtH << refVertStep) < refH;
        if ((refX & 1) == 0) {
            if ((refY & 1) == 0) {
                if (safe) 
                    this.predictFullXFullYSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
                 else 
                    this.predictFullXFullYUnSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
            } else {
                if (safe) 
                    this.predictOddEvenSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
                 else 
                    this.predictOddEvenUnSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
            }
        } else if ((refY & 1) == 0) {
            if (safe) 
                this.predictEvenOddSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
             else 
                this.predictEvenOddUnSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
        } else {
            if (safe) 
                this.predictOddOddSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
             else 
                this.predictOddOddUnSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
        }
    };
    prototype.predictInField = function(reference, x, y, mbPix, bits, motionType, backward, fieldNo) {
        switch (motionType) {
            case 1:
                this.predict16x16Field(reference, x, y, bits, backward, mbPix);
                break;
            case 2:
                this.predict16x8MC(reference, x, y, bits, backward, mbPix, 0, 0);
                this.predict16x8MC(reference, x, y, bits, backward, mbPix, 8, 1);
                break;
            case 3:
                this.predict16x16DualPrimeField(reference, x, y, bits, mbPix, fieldNo);
        }
    };
    prototype.predictInFrame = function(reference, x, y, mbPix, _in, motionType, backward, spatial_temporal_weight_code) {
        var refs = [reference, reference];
        switch (motionType) {
            case 1:
                this.predictFieldInFrame(reference, x, y, mbPix, _in, backward, spatial_temporal_weight_code);
                break;
            case 2:
                this.predict16x16Frame(reference, x, y, _in, backward, mbPix);
                break;
            case 3:
                this.predict16x16DualPrimeFrame(refs, x, y, _in, backward, mbPix);
                break;
        }
    };
    prototype.predict16x16DualPrimeField = function(reference, x, y, bits, mbPix, fieldNo) {
        var vect1X = this.mvectDecode(bits, this.fCode[0][0], this.mvPred[0][0][0]);
        var dmX = MPEGConst.vlcDualPrime.readVLC(bits) - 1;
        var vect1Y = this.mvectDecode(bits, this.fCode[0][1], this.mvPred[0][0][1]);
        var dmY = MPEGConst.vlcDualPrime.readVLC(bits) - 1;
        var vect2X = this.dpXField(vect1X, dmX, 1 - fieldNo);
        var vect2Y = this.dpYField(vect1Y, dmY, 1 - fieldNo);
        var ch = this.chromaFormat == SequenceExtension.Chroma420 ? 1 : 0;
        var cw = this.chromaFormat == SequenceExtension.Chroma444 ? 0 : 1;
        var sh = this.chromaFormat == SequenceExtension.Chroma420 ? 2 : 1;
        var sw = this.chromaFormat == SequenceExtension.Chroma444 ? 1 : 2;
        var mbPix1 = Array.apply(null, Array(3)).map(function() {
            return new Int32Array(256);
        }), mbPix2 = Array.apply(null, Array(3)).map(function() {
            return new Int32Array(256);
        });
        var refX1 = (x << 1) + vect1X;
        var refY1 = (y << 1) + vect1Y;
        var refX1Chr = ((x << 1) >> cw) + stjs.trunc(vect1X / sw);
        var refY1Chr = ((y << 1) >> ch) + stjs.trunc(vect1Y / sh);
        this.predictPlane(reference[fieldNo].getPlaneData(0), refX1, refY1, reference[fieldNo].getPlaneWidth(0), reference[fieldNo].getPlaneHeight(0), 1, fieldNo, mbPix1[0], 0, 16, 16, 0);
        this.predictPlane(reference[fieldNo].getPlaneData(1), refX1Chr, refY1Chr, reference[fieldNo].getPlaneWidth(1), reference[fieldNo].getPlaneHeight(1), 1, fieldNo, mbPix1[1], 0, 16 >> cw, 16 >> ch, 0);
        this.predictPlane(reference[fieldNo].getPlaneData(2), refX1Chr, refY1Chr, reference[fieldNo].getPlaneWidth(2), reference[fieldNo].getPlaneHeight(2), 1, fieldNo, mbPix1[2], 0, 16 >> cw, 16 >> ch, 0);
        var refX2 = (x << 1) + vect2X;
        var refY2 = (y << 1) + vect2Y;
        var refX2Chr = ((x << 1) >> cw) + stjs.trunc(vect2X / sw);
        var refY2Chr = ((y << 1) >> ch) + stjs.trunc(vect2Y / sh);
        var opposite = 1 - fieldNo;
        this.predictPlane(reference[opposite].getPlaneData(0), refX2, refY2, reference[opposite].getPlaneWidth(0), reference[opposite].getPlaneHeight(0), 1, opposite, mbPix2[0], 0, 16, 16, 0);
        this.predictPlane(reference[opposite].getPlaneData(1), refX2Chr, refY2Chr, reference[opposite].getPlaneWidth(1), reference[opposite].getPlaneHeight(1), 1, opposite, mbPix2[1], 0, 16 >> cw, 16 >> ch, 0);
        this.predictPlane(reference[opposite].getPlaneData(2), refX2Chr, refY2Chr, reference[opposite].getPlaneWidth(2), reference[opposite].getPlaneHeight(2), 1, opposite, mbPix2[2], 0, 16 >> cw, 16 >> ch, 0);
        for (var i = 0; i < 3; i++) {
            for (var j = 0; j < mbPix[i].length; j++) 
                mbPix[i][j] = (mbPix1[i][j] + mbPix2[i][j] + 1) >> 1;
        }
        this.mvPred[1][0][0] = this.mvPred[0][0][0] = vect1X;
        this.mvPred[1][0][1] = this.mvPred[0][0][1] = vect1Y;
    };
    prototype.dpYField = function(vect1y, dmY, topField) {
        return ((vect1y + (vect1y > 0 ? 1 : 0)) >> 1) + (1 - (topField << 1)) + dmY;
    };
    prototype.dpXField = function(vect1x, dmX, topField) {
        return ((vect1x + (vect1x > 0 ? 1 : 0)) >> 1) + dmX;
    };
    prototype.predict16x8MC = function(reference, x, y, bits, backward, mbPix, vertPos, vectIdx) {
        var field = bits.read1Bit();
        this.predictGeneric(reference[field], x, y + vertPos, bits, backward, mbPix, vertPos, 16, 8, 1, field, 0, vectIdx, 0);
    };
    prototype.predict16x16Field = function(reference, x, y, bits, backward, mbPix) {
        var field = bits.read1Bit();
        this.predictGeneric(reference[field], x, y, bits, backward, mbPix, 0, 16, 16, 1, field, 0, 0, 0);
        this.mvPred[1][backward][0] = this.mvPred[0][backward][0];
        this.mvPred[1][backward][1] = this.mvPred[0][backward][1];
    };
    prototype.predict16x16DualPrimeFrame = function(reference, x, y, bits, backward, mbPix) {
        var vect1X = this.mvectDecode(bits, this.fCode[0][0], this.mvPred[0][0][0]);
        var dmX = MPEGConst.vlcDualPrime.readVLC(bits) - 1;
        var vect1Y = this.mvectDecode(bits, this.fCode[0][1], this.mvPred[0][0][1] >> 1);
        var dmY = MPEGConst.vlcDualPrime.readVLC(bits) - 1;
        var m = this.topFieldFirst ? 1 : 3;
        var vect2X = ((vect1X * m + (vect1X > 0 ? 1 : 0)) >> 1) + dmX;
        var vect2Y = ((vect1Y * m + (vect1Y > 0 ? 1 : 0)) >> 1) + dmY - 1;
        m = 4 - m;
        var vect3X = ((vect1X * m + (vect1X > 0 ? 1 : 0)) >> 1) + dmX;
        var vect3Y = ((vect1Y * m + (vect1Y > 0 ? 1 : 0)) >> 1) + dmY + 1;
        var ch = this.chromaFormat == SequenceExtension.Chroma420 ? 1 : 0;
        var cw = this.chromaFormat == SequenceExtension.Chroma444 ? 0 : 1;
        var sh = this.chromaFormat == SequenceExtension.Chroma420 ? 2 : 1;
        var sw = this.chromaFormat == SequenceExtension.Chroma444 ? 1 : 2;
        var mbPix1 = Array.apply(null, Array(3)).map(function() {
            return new Int32Array(256);
        }), mbPix2 = Array.apply(null, Array(3)).map(function() {
            return new Int32Array(256);
        });
        var refX1 = (x << 1) + vect1X;
        var refY1 = y + vect1Y;
        var refX1Chr = ((x << 1) >> cw) + stjs.trunc(vect1X / sw);
        var refY1Chr = (y >> ch) + stjs.trunc(vect1Y / sh);
        this.predictPlane(reference[0].getPlaneData(0), refX1, refY1, reference[0].getPlaneWidth(0), reference[0].getPlaneHeight(0), 1, 0, mbPix1[0], 0, 16, 8, 1);
        this.predictPlane(reference[0].getPlaneData(1), refX1Chr, refY1Chr, reference[0].getPlaneWidth(1), reference[0].getPlaneHeight(1), 1, 0, mbPix1[1], 0, 16 >> cw, 8 >> ch, 1);
        this.predictPlane(reference[0].getPlaneData(2), refX1Chr, refY1Chr, reference[0].getPlaneWidth(2), reference[0].getPlaneHeight(2), 1, 0, mbPix1[2], 0, 16 >> cw, 8 >> ch, 1);
        this.predictPlane(reference[1].getPlaneData(0), refX1, refY1, reference[1].getPlaneWidth(0), reference[1].getPlaneHeight(0), 1, 1, mbPix1[0], 1, 16, 8, 1);
        this.predictPlane(reference[1].getPlaneData(1), refX1Chr, refY1Chr, reference[1].getPlaneWidth(1), reference[1].getPlaneHeight(1), 1, 1, mbPix1[1], 1, 16 >> cw, 8 >> ch, 1);
        this.predictPlane(reference[1].getPlaneData(2), refX1Chr, refY1Chr, reference[1].getPlaneWidth(2), reference[1].getPlaneHeight(2), 1, 1, mbPix1[2], 1, 16 >> cw, 8 >> ch, 1);
        var refX2 = (x << 1) + vect2X;
        var refY2 = y + vect2Y;
        var refX2Chr = ((x << 1) >> cw) + stjs.trunc(vect2X / sw);
        var refY2Chr = (y >> ch) + stjs.trunc(vect2Y / sh);
        this.predictPlane(reference[1].getPlaneData(0), refX2, refY2, reference[1].getPlaneWidth(0), reference[1].getPlaneHeight(0), 1, 1, mbPix2[0], 0, 16, 8, 1);
        this.predictPlane(reference[1].getPlaneData(1), refX2Chr, refY2Chr, reference[1].getPlaneWidth(1), reference[1].getPlaneHeight(1), 1, 1, mbPix2[1], 0, 16 >> cw, 8 >> ch, 1);
        this.predictPlane(reference[1].getPlaneData(2), refX2Chr, refY2Chr, reference[1].getPlaneWidth(2), reference[1].getPlaneHeight(2), 1, 1, mbPix2[2], 0, 16 >> cw, 8 >> ch, 1);
        var refX3 = (x << 1) + vect3X;
        var refY3 = y + vect3Y;
        var refX3Chr = ((x << 1) >> cw) + stjs.trunc(vect3X / sw);
        var refY3Chr = (y >> ch) + stjs.trunc(vect3Y / sh);
        this.predictPlane(reference[0].getPlaneData(0), refX3, refY3, reference[0].getPlaneWidth(0), reference[0].getPlaneHeight(0), 1, 0, mbPix2[0], 1, 16, 8, 1);
        this.predictPlane(reference[0].getPlaneData(1), refX3Chr, refY3Chr, reference[0].getPlaneWidth(1), reference[0].getPlaneHeight(1), 1, 0, mbPix2[1], 1, 16 >> cw, 8 >> ch, 1);
        this.predictPlane(reference[0].getPlaneData(2), refX3Chr, refY3Chr, reference[0].getPlaneWidth(2), reference[0].getPlaneHeight(2), 1, 0, mbPix2[2], 1, 16 >> cw, 8 >> ch, 1);
        for (var i = 0; i < 3; i++) {
            for (var j = 0; j < mbPix[i].length; j++) 
                mbPix[i][j] = (mbPix1[i][j] + mbPix2[i][j] + 1) >> 1;
        }
        this.mvPred[1][0][0] = this.mvPred[0][0][0] = vect1X;
        this.mvPred[1][0][1] = this.mvPred[0][0][1] = vect1Y << 1;
    };
    prototype.predict16x16Frame = function(reference, x, y, bits, backward, mbPix) {
        this.predictGeneric(reference, x, y, bits, backward, mbPix, 0, 16, 16, 0, 0, 0, 0, 0);
        this.mvPred[1][backward][0] = this.mvPred[0][backward][0];
        this.mvPred[1][backward][1] = this.mvPred[0][backward][1];
    };
    prototype.mvectDecode = function(bits, fcode, pred) {
        var code = MPEGConst.vlcMotionCode.readVLC(bits);
        if (code == 0) {
            return pred;
        }
        if (code < 0) {
            return 65535;
        }
        var sign, val, shift;
        sign = bits.read1Bit();
        shift = fcode - 1;
        val = code;
        if (shift > 0) {
            val = (val - 1) << shift;
            val |= bits.readNBit(shift);
            val++;
        }
        if (sign != 0) 
            val = -val;
        val += pred;
        return this.sign_extend(val, 5 + shift);
    };
    prototype.sign_extend = function(val, bits) {
        var shift = 32 - bits;
        return (val << shift) >> shift;
    };
    prototype.predictGeneric = function(reference, x, y, bits, backward, mbPix, tgtY, blkW, blkH, isSrcField, srcField, isDstField, vectIdx, predScale) {
        var vectX = this.mvectDecode(bits, this.fCode[backward][0], this.mvPred[vectIdx][backward][0]);
        var vectY = this.mvectDecode(bits, this.fCode[backward][1], this.mvPred[vectIdx][backward][1] >> predScale);
        this.predictMB(reference, (x << 1), vectX, (y << 1), vectY, blkW, blkH, isSrcField, srcField, mbPix, tgtY, isDstField);
        this.mvPred[vectIdx][backward][0] = vectX;
        this.mvPred[vectIdx][backward][1] = vectY << predScale;
    };
    prototype.predictFieldInFrame = function(reference, x, y, mbPix, bits, backward, spatial_temporal_weight_code) {
        y >>= 1;
        var field = bits.read1Bit();
        this.predictGeneric(reference, x, y, bits, backward, mbPix, 0, 16, 8, 1, field, 1, 0, 1);
        if (spatial_temporal_weight_code == 0 || spatial_temporal_weight_code == 1) {
            field = bits.read1Bit();
            this.predictGeneric(reference, x, y, bits, backward, mbPix, 1, 16, 8, 1, field, 1, 1, 1);
        } else {
            this.mvPred[1][backward][0] = this.mvPred[0][backward][0];
            this.mvPred[1][backward][1] = this.mvPred[0][backward][1];
            this.predictMB(reference, this.mvPred[1][backward][0], 0, this.mvPred[1][backward][1], 0, 16, 8, 1, 1 - field, mbPix, 1, 1);
        }
    };
    prototype.predictMB = function(ref, refX, vectX, refY, vectY, blkW, blkH, refVertStep, refVertOff, tgt, tgtY, tgtVertStep) {
        var ch = this.chromaFormat == SequenceExtension.Chroma420 ? 1 : 0;
        var cw = this.chromaFormat == SequenceExtension.Chroma444 ? 0 : 1;
        var sh = this.chromaFormat == SequenceExtension.Chroma420 ? 2 : 1;
        var sw = this.chromaFormat == SequenceExtension.Chroma444 ? 1 : 2;
        this.predictPlane(ref.getPlaneData(0), refX + vectX, refY + vectY, ref.getPlaneWidth(0), ref.getPlaneHeight(0), refVertStep, refVertOff, tgt[0], tgtY, blkW, blkH, tgtVertStep);
        this.predictPlane(ref.getPlaneData(1), (refX >> cw) + stjs.trunc(vectX / sw), (refY >> ch) + stjs.trunc(vectY / sh), ref.getPlaneWidth(1), ref.getPlaneHeight(1), refVertStep, refVertOff, tgt[1], tgtY, blkW >> cw, blkH >> ch, tgtVertStep);
        this.predictPlane(ref.getPlaneData(2), (refX >> cw) + stjs.trunc(vectX / sw), (refY >> ch) + stjs.trunc(vectY / sh), ref.getPlaneWidth(2), ref.getPlaneHeight(2), refVertStep, refVertOff, tgt[2], tgtY, blkW >> cw, blkH >> ch, tgtVertStep);
    };
    prototype.predict16x16NoMV = function(picture, x, y, pictureStructure, backward, mbPix) {
        if (pictureStructure == 3) {
            this.predictMB(picture, (x << 1), this.mvPred[0][backward][0], (y << 1), this.mvPred[0][backward][1], 16, 16, 0, 0, mbPix, 0, 0);
        } else 
            this.predictMB(picture, (x << 1), this.mvPred[0][backward][0], (y << 1), this.mvPred[0][backward][1], 16, 16, 1, pictureStructure - 1, mbPix, 0, 0);
    };
    prototype.reset = function() {
        this.mvPred[0][0][0] = this.mvPred[0][0][1] = this.mvPred[0][1][0] = this.mvPred[0][1][1] = this.mvPred[1][0][0] = this.mvPred[1][0][1] = this.mvPred[1][1][0] = this.mvPred[1][1][1] = 0;
    };
}, {mvPred: "Array", fCode: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var Element = function() {};
Element = stjs.extend(Element, null, [SyntaxConstants], function(constructor, prototype) {
    prototype.elementInstanceTag = 0;
    prototype.sbr = null;
    prototype.readElementInstanceTag = function(_in) {
        this.elementInstanceTag = _in.readBits(4);
    };
    prototype.getElementInstanceTag = function() {
        return this.elementInstanceTag;
    };
    prototype.decodeSBR = function(_in, sf, count, stereo, crc, downSampled, smallFrames) {
        if (this.sbr == null) 
            this.sbr = new SBR(smallFrames, this.elementInstanceTag == SyntaxConstants.ELEMENT_CPE, sf, downSampled);
        this.sbr.decode(_in, count);
    };
    prototype.isSBRPresent = function() {
        return this.sbr != null;
    };
    prototype.getSBR = function() {
        return this.sbr;
    };
}, {sbr: "SBR"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Compresses a set of long's creating a dictionary and then outputting it using
 *  a huffman table
 *  
 *  @author The JCodec project
 *  
 */
var DictionaryCompressor = function() {};
DictionaryCompressor = stjs.extend(DictionaryCompressor, null, [], function(constructor, prototype) {
    prototype.buildCodes = function(counts, esc) {
        var codes = new Int32Array(counts.length);
        var codeSizes = new Int32Array(counts.length);
        var code = 0;
        for (; code < Math.min(codes.length, esc); code++) {
            var max = 0;
            for (var i = 0; i < counts.length; i++) {
                if (counts[i] > counts[max]) 
                    max = i;
            }
            codes[max] = code;
            codeSizes[max] = Math.max(1, MathUtil.log2(code));
            counts[max] = Integer.MIN_VALUE;
        }
        var escSize = MathUtil.log2(esc);
        for (var i = 0; i < counts.length; i++) 
            if (counts[i] >= 0) {
                codes[i] = esc;
                codeSizes[i] = escSize;
            }
        return new VLC(codes, codeSizes);
    };
    constructor.Long = function() {
        DictionaryCompressor.call(this);
    };
    constructor.Long = stjs.extend(constructor.Long, DictionaryCompressor, [], function(constructor, prototype) {
        prototype.compress = function(values, bb) {
            var rl = this.getValueStats(values);
            var counts = rl.getCounts();
            var keys = rl.getValues();
            var vlc = this.buildCodes(counts, stjs.trunc(values.length / 10));
            var codes = vlc.getCodes();
            var codeSizes = vlc.getCodeSizes();
            bb.putInt(codes.length);
            for (var i = 0; i < codes.length; i++) {
                bb.put((codeSizes[i] << 24 >> 24));
                bb.putShort((((codes[i] >>> 16)) << 16 >> 16));
                bb.putLong(keys[i]);
            }
            var br = new BitWriter(bb);
            for (var j = 0; j < values.length; j++) {
                var l = values[j];
                for (var i = 0; i < keys.length; i++) 
                    if (keys[i] == l) {
                        vlc.writeVLC(br, i);
                        if (codes[i] == 15) 
                            br.writeNBit(16, i);
                    }
            }
            br.flush();
        };
        prototype.getValueStats = function(values) {
            var copy = Platform.copyOfLong(values, values.length);
            Arrays.sort(copy);
            var rl = new RunLength.Long();
            for (var i = 0; i < copy.length; i++) {
                var l = copy[i];
                rl.add(l);
            }
            return rl;
        };
    }, {}, {});
    constructor.Int = function() {
        DictionaryCompressor.call(this);
    };
    constructor.Int = stjs.extend(constructor.Int, DictionaryCompressor, [], function(constructor, prototype) {
        prototype.compress = function(values, bb) {
            var rl = this.getValueStats(values);
            var counts = rl.getCounts();
            var keys = rl.getValues();
            var esc = Math.max(1, (1 << (MathUtil.log2(counts.length) - 2)) - 1);
            var vlc = this.buildCodes(counts, esc);
            var codes = vlc.getCodes();
            var codeSizes = vlc.getCodeSizes();
            bb.putInt(codes.length);
            for (var i = 0; i < codes.length; i++) {
                bb.put((codeSizes[i] << 24 >> 24));
                bb.putShort((((codes[i] >>> 16)) << 16 >> 16));
                bb.putInt(keys[i]);
            }
            var br = new BitWriter(bb);
            for (var j = 0; j < values.length; j++) {
                var l = values[j];
                for (var i = 0; i < keys.length; i++) 
                    if (keys[i] == l) {
                        vlc.writeVLC(br, i);
                        if (codes[i] == esc) 
                            br.writeNBit(i, 16);
                    }
            }
            br.flush();
        };
        prototype.getValueStats = function(values) {
            var copy = Platform.copyOfInt(values, values.length);
            Arrays.sort(copy);
            var rl = new RunLength.Integer();
            for (var i = 0; i < copy.length; i++) {
                var l = copy[i];
                rl.add(l);
            }
            return rl;
        };
    }, {}, {});
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Represents index for MPEG PS stream, enables demuxers to do precise seek
 *  
 *  @author The JCodec project
 *  
 */
var MPSIndex = function(pesTokens, pesStreamIds, streams) {
    this.pesTokens = pesTokens;
    this.pesStreamIds = pesStreamIds;
    this.streams = streams;
};
MPSIndex = stjs.extend(MPSIndex, null, [], function(constructor, prototype) {
    prototype.pesTokens = null;
    prototype.pesStreamIds = null;
    prototype.streams = null;
    constructor.MPSStreamIndex = function(streamId, fsizes, fpts, fdur, sync) {
        this.streamId = streamId;
        this.fsizes = fsizes;
        this.fpts = fpts;
        this.fdur = fdur;
        this.sync = sync;
    };
    constructor.MPSStreamIndex = stjs.extend(constructor.MPSStreamIndex, null, [], function(constructor, prototype) {
        prototype.streamId = 0;
        prototype.fsizes = null;
        prototype.fpts = null;
        prototype.fdur = null;
        prototype.sync = null;
        prototype.getStreamId = function() {
            return this.streamId;
        };
        prototype.getFsizes = function() {
            return this.fsizes;
        };
        prototype.getFpts = function() {
            return this.fpts;
        };
        prototype.getFdur = function() {
            return this.fdur;
        };
        prototype.getSync = function() {
            return this.sync;
        };
        constructor.parseIndex = function(index) {
            var streamId = index.get() & 255;
            var fCnt = index.getInt();
            var fsizes = new Int32Array(fCnt);
            for (var i = 0; i < fCnt; i++) {
                fsizes[i] = index.getInt();
            }
            var fptsCnt = index.getInt();
            var fpts = new Int32Array(fptsCnt);
            for (var i = 0; i < fptsCnt; i++) {
                fpts[i] = index.getInt();
            }
            var fdurCnt = index.getInt();
            var fdur = new Int32Array(fdurCnt);
            for (var i = 0; i < fdurCnt; i++) {
                fdur[i] = index.getInt();
            }
            var syncCount = index.getInt();
            var sync = new Int32Array(syncCount);
            for (var i = 0; i < syncCount; i++) 
                sync[i] = index.getInt();
            return new MPSIndex.MPSStreamIndex(streamId, fsizes, fpts, fdur, sync);
        };
        prototype.serialize = function(index) {
            index.put((this.streamId << 24 >> 24));
            index.putInt(this.fsizes.length);
            for (var i = 0; i < this.fsizes.length; i++) 
                index.putInt(this.fsizes[i]);
            index.putInt(this.fpts.length);
            for (var i = 0; i < this.fpts.length; i++) 
                index.putInt(this.fpts[i]);
            index.putInt(this.fdur.length);
            for (var i = 0; i < this.fdur.length; i++) 
                index.putInt(this.fdur[i]);
            index.putInt(this.sync.length);
            for (var i = 0; i < this.sync.length; i++) 
                index.putInt(this.sync[i]);
        };
        prototype.estimateSize = function() {
            return (this.fpts.length << 2) + (this.fdur.length << 2) + (this.sync.length << 2) + (this.fsizes.length << 2) + 64;
        };
    }, {fsizes: "Int32Array", fpts: "Int32Array", fdur: "Int32Array", sync: "Int32Array"}, {});
    prototype.getPesTokens = function() {
        return this.pesTokens;
    };
    prototype.getPesStreamIds = function() {
        return this.pesStreamIds;
    };
    prototype.getStreams = function() {
        return this.streams;
    };
    constructor.parseIndex = function(index) {
        var pesCnt = index.getInt();
        var pesTokens = Array(pesCnt);
        for (var i = 0; i < pesCnt; i++) {
            pesTokens[i] = index.getLong();
        }
        var pesStreamId = RunLength.Integer.parse(index);
        var nStreams = index.getInt();
        var streams = Array(nStreams);
        for (var i = 0; i < nStreams; i++) {
            streams[i] = MPSIndex.MPSStreamIndex.parseIndex(index);
        }
        return new MPSIndex(pesTokens, pesStreamId, streams);
    };
    prototype.serializeTo = function(index) {
        index.putInt(this.pesTokens.length);
        for (var i = 0; i < this.pesTokens.length; i++) {
            index.putLong(this.pesTokens[i]);
        }
        this.pesStreamIds.serialize(index);
        index.putInt(this.streams.length);
        for (var index$mpsStreamIndex = 0, arr$mpsStreamIndex = this.streams; index$mpsStreamIndex < arr$mpsStreamIndex.length; index$mpsStreamIndex++) {
            var mpsStreamIndex = arr$mpsStreamIndex[index$mpsStreamIndex];
            mpsStreamIndex.serialize(index);
        }
    };
    prototype.estimateSize = function() {
        var size = (this.pesTokens.length << 3) + this.pesStreamIds.estimateSize();
        for (var index$mpsStreamIndex = 0, arr$mpsStreamIndex = this.streams; index$mpsStreamIndex < arr$mpsStreamIndex.length; index$mpsStreamIndex++) {
            var mpsStreamIndex = arr$mpsStreamIndex[index$mpsStreamIndex];
            size += mpsStreamIndex.estimateSize();
        }
        return size + 64;
    };
    constructor.makePESToken = function(leading, pesLen, payloadLen) {
        return (leading << 48) | (pesLen << 24) | payloadLen;
    };
    constructor.leadingSize = function(token) {
        return (((token >> 48)) | 0) & 65535;
    };
    constructor.pesLen = function(token) {
        return (((token >> 24)) | 0) & 16777215;
    };
    constructor.payLoadSize = function(token) {
        return ((token) | 0) & 16777215;
    };
}, {pesTokens: "Array", pesStreamIds: "RunLength.Integer", streams: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Represents PMT ( Program Map Table ) of the MPEG Transport stream
 *  
 *  This section contains information about streams of an individual program, a
 *  program usually contains two or more streams, such as video, audio, text,
 *  etc..
 *  
 *  @author The JCodec project
 *  
 */
var PMTSection = function(psi, pcrPid, tags, streams) {
    PSISection.call(this, psi.tableId, psi.specificId, psi.versionNumber, psi.currentNextIndicator, psi.sectionNumber, psi.lastSectionNumber);
    this.pcrPid = pcrPid;
    this.tags = tags;
    this.streams = streams;
};
PMTSection = stjs.extend(PMTSection, PSISection, [], function(constructor, prototype) {
    prototype.pcrPid = 0;
    prototype.tags = null;
    prototype.streams = null;
    prototype.getPcrPid = function() {
        return this.pcrPid;
    };
    prototype.getTags = function() {
        return this.tags;
    };
    prototype.getStreams = function() {
        return this.streams;
    };
    constructor.parsePMT = function(data) {
        var psi = PSISection.parsePSI(data);
        var w1 = data.getShort() & 65535;
        var pcrPid = w1 & 8191;
        var w2 = data.getShort() & 65535;
        var programInfoLength = w2 & 4095;
        var tags = PMTSection.parseTags(NIOUtils.read(data, programInfoLength));
        var streams = new ArrayList();
         while (data.remaining() > 4){
            var streamType = data.get() & 255;
            var wn = data.getShort() & 65535;
            var elementaryPid = wn & 8191;
            var wn1 = data.getShort() & 65535;
            var esInfoLength = wn1 & 4095;
            var read = NIOUtils.read(data, esInfoLength);
            streams.add(new PMTSection.PMTStream(streamType, elementaryPid, MPSUtils.parseDescriptors(read)));
        }
        return new PMTSection(psi, pcrPid, tags.toArray(Array(0)), streams.toArray(Array(0)));
    };
    constructor.parseTags = function(bb) {
        var tags = new ArrayList();
         while (bb.hasRemaining()){
            var tag = bb.get();
            var tagLen = bb.get();
            tags.add(new PMTSection.Tag(tag, NIOUtils.read(bb, tagLen)));
        }
        return tags;
    };
    constructor.Tag = function(tag, content) {
        this.tag = tag;
        this.content = content;
    };
    constructor.Tag = stjs.extend(constructor.Tag, null, [], function(constructor, prototype) {
        prototype.tag = 0;
        prototype.content = null;
        prototype.getTag = function() {
            return this.tag;
        };
        prototype.getContent = function() {
            return this.content;
        };
    }, {content: "ByteBuffer"}, {});
    constructor.PMTStream = function(streamTypeTag, pid, descriptors) {
        this.streamTypeTag = streamTypeTag;
        this.pid = pid;
        this.descriptors = descriptors;
        this.streamType = MTSStreamType.fromTag(streamTypeTag);
    };
    constructor.PMTStream = stjs.extend(constructor.PMTStream, null, [], function(constructor, prototype) {
        prototype.streamTypeTag = 0;
        prototype.pid = 0;
        prototype.descriptors = null;
        prototype.streamType = null;
        prototype.getStreamTypeTag = function() {
            return this.streamTypeTag;
        };
        prototype.getStreamType = function() {
            return this.streamType;
        };
        prototype.getPid = function() {
            return this.pid;
        };
        prototype.getDesctiptors = function() {
            return this.descriptors;
        };
    }, {descriptors: {name: "List", arguments: ["MPSUtils.MPEGMediaDescriptor"]}, streamType: "MTSStreamType"}, {});
}, {tags: "Array", streams: "Array"}, {});
var DPXReader = function(ch) {
    this.readBuf = ByteBuffer.allocate(DPXReader.READ_BUFFER_SIZE);
    this.initialRead(ch);
    this.magic = this.readBuf.getInt();
    if (this.magic == DPXReader.SDPX) {
        this.readBuf.order(ByteOrder.BIG_ENDIAN);
    } else {
        this.readBuf.order(ByteOrder.LITTLE_ENDIAN);
    }
};
DPXReader = stjs.extend(DPXReader, null, [], function(constructor, prototype) {
    constructor.READ_BUFFER_SIZE = 2048 + 1024;
    constructor.IMAGEINFO_OFFSET = 768;
    constructor.IMAGESOURCE_OFFSET = 1408;
    constructor.FILM_OFFSET = 1664;
    constructor.TVINFO_OFFSET = 1920;
    constructor.SDPX = 1396985944;
    prototype.readBuf = null;
    prototype.magic = 0;
    prototype.eof = false;
    prototype.parseMetadata = function() {
        var dpx = new DPXMetadata();
        dpx.file = DPXReader.readFileInfo(this.readBuf);
        dpx.file.magic = this.magic;
        this.readBuf.setPosition(DPXReader.IMAGEINFO_OFFSET);
        dpx.image = DPXReader.readImageInfoHeader(this.readBuf);
        this.readBuf.setPosition(DPXReader.IMAGESOURCE_OFFSET);
        dpx.imageSource = DPXReader.readImageSourceHeader(this.readBuf);
        this.readBuf.setPosition(DPXReader.FILM_OFFSET);
        dpx.film = DPXReader.readFilmInformationHeader(this.readBuf);
        this.readBuf.setPosition(DPXReader.TVINFO_OFFSET);
        dpx.television = DPXReader.readTelevisionInfoHeader(this.readBuf);
        dpx.userId = DPXReader.readNullTermString(this.readBuf, 32);
        return dpx;
    };
    prototype.initialRead = function(ch) {
        this.readBuf.clear();
        if (ch.read(this.readBuf) == -1) 
            this.eof = true;
        this.readBuf.flip();
    };
    constructor.readFileInfo = function(bb) {
        var h = new FileHeader();
        h.imageOffset = bb.getInt();
        h.version = DPXReader.readNullTermString(bb, 8);
        h.filesize = bb.getInt();
        h.ditto = bb.getInt();
        h.genericHeaderLength = bb.getInt();
        h.industryHeaderLength = bb.getInt();
        h.userHeaderLength = bb.getInt();
        h.filename = DPXReader.readNullTermString(bb, 100);
        h.created = DPXReader.tryParseISO8601Date(DPXReader.readNullTermString(bb, 24));
        h.creator = DPXReader.readNullTermString(bb, 100);
        h.projectName = DPXReader.readNullTermString(bb, 200);
        h.copyright = DPXReader.readNullTermString(bb, 200);
        h.encKey = bb.getInt();
        return h;
    };
    constructor.tryParseISO8601Date = function(dateString) {
        if (StringUtils.isEmpty(dateString)) {
            return null;
        }
        var noTZ = "yyyy:MM:dd:HH:mm:ss";
        if (dateString.length == noTZ.length) {
            return DPXReader.date(dateString, noTZ);
        } else if (dateString.length == noTZ.length + 4) {
            dateString = dateString + "00";
        }
        return DPXReader.date(dateString, "yyyy:MM:dd:HH:mm:ss:Z");
    };
    constructor.date = function(dateString, dateFormat) {
        var format = new SimpleDateFormat(dateFormat, Locale.US);
        try {
            return format.parse(dateString);
        }catch (e) {
            return null;
        }
    };
    constructor.readNullTermString = function(bb, length) {
        var b = ByteBuffer.allocate(length);
        bb.getBuf3(b.array(), 0, length);
        return NIOUtils.readNullTermString(b);
    };
    constructor.readFile = function(file) {
        var _in = NIOUtils.readableChannel(file);
        try {
            return new DPXReader(_in);
        } finally {
            IOUtils.closeQuietly(_in);
        }
    };
    constructor.readTelevisionInfoHeader = function(r) {
        var h = new TelevisionHeader();
        h.timecode = r.getInt();
        h.userBits = r.getInt();
        h.interlace = r.get();
        h.filedNumber = r.get();
        h.videoSignalStarted = r.get();
        h.zero = r.get();
        h.horSamplingRateHz = r.getInt();
        h.vertSampleRateHz = r.getInt();
        h.frameRate = r.getInt();
        h.timeOffset = r.getInt();
        h.gamma = r.getInt();
        h.blackLevel = r.getInt();
        h.blackGain = r.getInt();
        h.breakpoint = r.getInt();
        h.referenceWhiteLevel = r.getInt();
        h.integrationTime = r.getInt();
        return h;
    };
    constructor.readFilmInformationHeader = function(r) {
        var h = new FilmHeader();
        h.idCode = DPXReader.readNullTermString(r, 2);
        h.type = DPXReader.readNullTermString(r, 2);
        h.offset = DPXReader.readNullTermString(r, 2);
        h.prefix = DPXReader.readNullTermString(r, 6);
        h.count = DPXReader.readNullTermString(r, 4);
        h.format = DPXReader.readNullTermString(r, 32);
        return h;
    };
    constructor.readImageSourceHeader = function(r) {
        var h = new ImageSourceHeader();
        h.xOffset = r.getInt();
        h.yOffset = r.getInt();
        h.xCenter = r.getFloat();
        h.yCenter = r.getFloat();
        h.xOriginal = r.getInt();
        h.yOriginal = r.getInt();
        h.sourceImageFilename = DPXReader.readNullTermString(r, 100);
        h.sourceImageDate = DPXReader.tryParseISO8601Date(DPXReader.readNullTermString(r, 24));
        h.deviceName = DPXReader.readNullTermString(r, 32);
        h.deviceSerial = DPXReader.readNullTermString(r, 32);
        h.borderValidity = new Int16Array([r.getShort(), r.getShort(), r.getShort(), r.getShort()]);
        h.aspectRatio = new Int32Array([r.getInt(), r.getInt()]);
        return h;
    };
    constructor.readImageInfoHeader = function(r) {
        var h = new ImageHeader();
        h.orientation = r.getShort();
        h.numberOfImageElements = r.getShort();
        h.pixelsPerLine = r.getInt();
        h.linesPerImageElement = r.getInt();
        h.imageElement1 = new ImageElement();
        h.imageElement1.dataSign = r.getInt();
        return h;
    };
}, {readBuf: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MainUtils = function() {};
MainUtils = stjs.extend(MainUtils, null, [], function(constructor, prototype) {
    constructor.KEY_GIT_REVISION = "git.commit.id.abbrev";
    constructor.JCODEC_LOG_SINK_COLOR = "jcodec.colorPrint";
    constructor.GIT_PROPERTIES = "git.properties";
    constructor.isColorSupported = System.console() != null || Boolean.parseBoolean(System.getProperty(MainUtils.JCODEC_LOG_SINK_COLOR));
    constructor.FlagType = stjs.enumeration("VOID", "STRING", "INT", "LONG", "DOUBLE", "MULT", "ENUM", "ANY");
    constructor.Flag = function(longName, shortName, description, type) {
        this.longName = longName;
        this.shortName = shortName;
        this.description = description;
        this.type = type;
    };
    constructor.Flag = stjs.extend(constructor.Flag, null, [], function(constructor, prototype) {
        prototype.longName = null;
        prototype.shortName = null;
        prototype.description = null;
        prototype.type = null;
        constructor.flag = function(longName, shortName, description) {
            return new MainUtils.Flag(longName, shortName, description, MainUtils.FlagType.ANY);
        };
        prototype.getLongName = function() {
            return this.longName;
        };
        prototype.getDescription = function() {
            return this.description;
        };
        prototype.getShortName = function() {
            return this.shortName;
        };
        prototype.getType = function() {
            return this.type;
        };
    }, {type: {name: "Enum", arguments: ["MainUtils.FlagType"]}}, {});
    constructor.Cmd = function(longFlags, shortFlags, args, longArgFlags, shortArgFlags) {
        this.args = args;
        this.longFlags = longFlags;
        this.shortFlags = shortFlags;
        this.longArgFlags = longArgFlags;
        this.shortArgFlags = shortArgFlags;
    };
    constructor.Cmd = stjs.extend(constructor.Cmd, null, [], function(constructor, prototype) {
        prototype.longFlags = null;
        prototype.shortFlags = null;
        prototype.args = null;
        prototype.longArgFlags = null;
        prototype.shortArgFlags = null;
        prototype.getLongFlagInternal = function(longFlags, shortFlags, flag, defaultValue) {
            return longFlags.containsKey(flag.getLongName()) ? new Long(longFlags.get(flag.getLongName())) : (shortFlags.containsKey(flag.getShortName()) ? new Long(shortFlags.get(flag.getShortName())) : defaultValue);
        };
        prototype.getIntegerFlagInternal = function(longFlags, shortFlags, flag, defaultValue) {
            return longFlags.containsKey(flag.getLongName()) ? new Integer(longFlags.get(flag.getLongName())) : (shortFlags.containsKey(flag.getShortName()) ? new Integer(shortFlags.get(flag.getShortName())) : defaultValue);
        };
        prototype.getBooleanFlagInternal = function(longFlags, shortFlags, flag, defaultValue) {
            return longFlags.containsKey(flag.getLongName()) ? !"false".equalsIgnoreCase(longFlags.get(flag.getLongName())) : (shortFlags.containsKey(flag.getShortName()) ? !"false".equalsIgnoreCase(shortFlags.get(flag.getShortName())) : defaultValue);
        };
        prototype.getDoubleFlagInternal = function(longFlags, shortFlags, flag, defaultValue) {
            return longFlags.containsKey(flag.getLongName()) ? new Double(longFlags.get(flag.getLongName())) : (shortFlags.containsKey(flag.getShortName()) ? new Double(shortFlags.get(flag.getShortName())) : defaultValue);
        };
        prototype.getStringFlagInternal = function(longFlags, shortFlags, flag, defaultValue) {
            return longFlags.containsKey(flag.getLongName()) ? longFlags.get(flag.getLongName()) : (shortFlags.containsKey(flag.getShortName()) ? shortFlags.get(flag.getShortName()) : defaultValue);
        };
        prototype.getMultiIntegerFlagInternal = function(longFlags, shortFlags, flag, defaultValue) {
            var flagValue;
            if (longFlags.containsKey(flag.getLongName())) 
                flagValue = longFlags.get(flag.getLongName());
             else if (shortFlags.containsKey(flag.getShortName())) 
                flagValue = shortFlags.get(flag.getShortName());
             else 
                return defaultValue;
            var split = StringUtils.splitS(flagValue, ",");
            var result = new Int32Array(split.length);
            for (var i = 0; i < split.length; i++) 
                result[i] = Integer.parseInt(split[i]);
            return result;
        };
        prototype.getEnumFlagInternal = function(longFlags, shortFlags, flag, defaultValue, class1) {
            var flagValue;
            if (longFlags.containsKey(flag.getLongName())) 
                flagValue = longFlags.get(flag.getLongName());
             else if (shortFlags.containsKey(flag.getShortName())) 
                flagValue = shortFlags.get(flag.getShortName());
             else 
                return defaultValue;
            var strVal = flagValue.toLowerCase();
            var allOf = EnumSet.allOf(class1);
            for (var iterator$val = allOf.iterator(); iterator$val.hasNext(); ) {
                var val = iterator$val.next();
                if (val.name().toLowerCase().equals(strVal)) 
                    return val;
            }
            return null;
        };
        prototype.getLongFlagD = function(flagName, defaultValue) {
            return this.getLongFlagInternal(this.longFlags, this.shortFlags, flagName, defaultValue);
        };
        prototype.getLongFlag = function(flagName) {
            return this.getLongFlagInternal(this.longFlags, this.shortFlags, flagName, null);
        };
        prototype.getLongFlagID = function(arg, flagName, defaultValue) {
            return this.getLongFlagInternal(this.longArgFlags[arg], this.shortArgFlags[arg], flagName, defaultValue);
        };
        prototype.getLongFlagI = function(arg, flagName) {
            return this.getLongFlagInternal(this.longArgFlags[arg], this.shortArgFlags[arg], flagName, null);
        };
        prototype.getIntegerFlagD = function(flagName, defaultValue) {
            return this.getIntegerFlagInternal(this.longFlags, this.shortFlags, flagName, defaultValue);
        };
        prototype.getIntegerFlag = function(flagName) {
            return this.getIntegerFlagInternal(this.longFlags, this.shortFlags, flagName, null);
        };
        prototype.getIntegerFlagID = function(arg, flagName, defaultValue) {
            return this.getIntegerFlagInternal(this.longArgFlags[arg], this.shortArgFlags[arg], flagName, defaultValue);
        };
        prototype.getIntegerFlagI = function(arg, flagName) {
            return this.getIntegerFlagInternal(this.longArgFlags[arg], this.shortArgFlags[arg], flagName, null);
        };
        prototype.getBooleanFlagD = function(flagName, defaultValue) {
            return this.getBooleanFlagInternal(this.longFlags, this.shortFlags, flagName, defaultValue);
        };
        prototype.getBooleanFlag = function(flagName) {
            return this.getBooleanFlagInternal(this.longFlags, this.shortFlags, flagName, false);
        };
        prototype.getBooleanFlagID = function(arg, flagName, defaultValue) {
            return this.getBooleanFlagInternal(this.longArgFlags[arg], this.shortArgFlags[arg], flagName, defaultValue);
        };
        prototype.getBooleanFlagI = function(arg, flagName) {
            return this.getBooleanFlagInternal(this.longArgFlags[arg], this.shortArgFlags[arg], flagName, false);
        };
        prototype.getDoubleFlagD = function(flagName, defaultValue) {
            return this.getDoubleFlagInternal(this.longFlags, this.shortFlags, flagName, defaultValue);
        };
        prototype.getDoubleFlag = function(flagName) {
            return this.getDoubleFlagInternal(this.longFlags, this.shortFlags, flagName, null);
        };
        prototype.getDoubleFlagID = function(arg, flagName, defaultValue) {
            return this.getDoubleFlagInternal(this.longArgFlags[arg], this.shortArgFlags[arg], flagName, defaultValue);
        };
        prototype.getDoubleFlagI = function(arg, flagName) {
            return this.getDoubleFlagInternal(this.longArgFlags[arg], this.shortArgFlags[arg], flagName, null);
        };
        prototype.getStringFlagD = function(flagName, defaultValue) {
            return this.getStringFlagInternal(this.longFlags, this.shortFlags, flagName, defaultValue);
        };
        prototype.getStringFlag = function(flagName) {
            return this.getStringFlagInternal(this.longFlags, this.shortFlags, flagName, null);
        };
        prototype.getStringFlagID = function(arg, flagName, defaultValue) {
            return this.getStringFlagInternal(this.longArgFlags[arg], this.shortArgFlags[arg], flagName, defaultValue);
        };
        prototype.getStringFlagI = function(arg, flagName) {
            return this.getStringFlagInternal(this.longArgFlags[arg], this.shortArgFlags[arg], flagName, null);
        };
        prototype.getMultiIntegerFlagD = function(flagName, defaultValue) {
            return this.getMultiIntegerFlagInternal(this.longFlags, this.shortFlags, flagName, defaultValue);
        };
        prototype.getMultiIntegerFlag = function(flagName) {
            return this.getMultiIntegerFlagInternal(this.longFlags, this.shortFlags, flagName, new Int32Array(0));
        };
        prototype.getMultiIntegerFlagID = function(arg, flagName, defaultValue) {
            return this.getMultiIntegerFlagInternal(this.longArgFlags[arg], this.shortArgFlags[arg], flagName, defaultValue);
        };
        prototype.getMultiIntegerFlagI = function(arg, flagName) {
            return this.getMultiIntegerFlagInternal(this.longArgFlags[arg], this.shortArgFlags[arg], flagName, new Int32Array(0));
        };
        prototype.getEnumFlagD = function(flagName, defaultValue, class1) {
            return this.getEnumFlagInternal(this.longFlags, this.shortFlags, flagName, defaultValue, class1);
        };
        prototype.getEnumFlag = function(flagName, class1) {
            return this.getEnumFlagInternal(this.longFlags, this.shortFlags, flagName, null, class1);
        };
        prototype.getEnumFlagID = function(arg, flagName, defaultValue, class1) {
            return this.getEnumFlagInternal(this.longArgFlags[arg], this.shortArgFlags[arg], flagName, defaultValue, class1);
        };
        prototype.getEnumFlagI = function(arg, flagName, class1) {
            return this.getEnumFlagInternal(this.longArgFlags[arg], this.shortArgFlags[arg], flagName, null, class1);
        };
        prototype.getArg = function(i) {
            return i < this.args.length ? this.args[i] : null;
        };
        prototype.argsLength = function() {
            return this.args.length;
        };
        prototype.popArg = function() {
            this.args = Platform.copyOfRangeO(this.args, 1, this.args.length);
        };
    }, {longFlags: {name: "Map", arguments: [null, null]}, shortFlags: {name: "Map", arguments: [null, null]}, args: "Array", longArgFlags: "Array", shortArgFlags: "Array"}, {});
    constructor.flagPattern = Pattern.compile("^--([^=]+)=(.*)$");
    constructor.parseArguments = function(args, flags) {
        var longFlags = new HashMap();
        var shortFlags = new HashMap();
        var allLongFlags = new HashMap();
        var allShortFlags = new HashMap();
        var outArgs = new ArrayList();
        var argLongFlags = new ArrayList();
        var argShortFlags = new ArrayList();
        var arg = 0;
        for (; arg < args.length; arg++) {
            if (args[arg].startsWith("--")) {
                var matcher = MainUtils.flagPattern.matcher(args[arg]);
                if (matcher.matches()) {
                    longFlags.put(matcher.group(1), matcher.group(2));
                } else {
                    longFlags.put(args[arg].substring(2), "true");
                }
            } else if (args[arg].startsWith("-")) {
                var shortName = args[arg].substring(1);
                var found = false;
                for (var index$flag = 0, arr$flag = flags; index$flag < arr$flag.length; index$flag++) {
                    var flag = arr$flag[index$flag];
                    if (shortName.equals(flag.getShortName())) {
                        found = true;
                        if (flag.getType() != MainUtils.FlagType.VOID) 
                            shortFlags.put(shortName, args[++arg]);
                         else 
                            shortFlags.put(shortName, "true");
                    }
                }
                if (!found) 
                    ++arg;
            } else {
                allLongFlags.putAll(longFlags);
                allShortFlags.putAll(shortFlags);
                outArgs.add(args[arg]);
                argLongFlags.add(longFlags);
                argShortFlags.add(shortFlags);
                longFlags = new HashMap();
                shortFlags = new HashMap();
            }
        }
        return new MainUtils.Cmd(allLongFlags, allShortFlags, outArgs.toArray(Array(0)), argLongFlags.toArray(jslang.reflect.Array.newInstance(longFlags.getClass(), 0)), argShortFlags.toArray(jslang.reflect.Array.newInstance(shortFlags.getClass(), 0)));
    };
    constructor.printHelpArgs = function(flags, _arguments) {
        MainUtils.printHelpOut(System.out, "", flags, Arrays.asList(arguments));
    };
    constructor.printHelp = function(flags, params) {
        MainUtils.printHelpOut(System.out, "", flags, params);
    };
    constructor.printHelpNoFlags = function(_arguments) {
        MainUtils.printHelpOut(System.out, "", [], Arrays.asList(arguments));
    };
    constructor.printHelpCmdVa = function(command, flags, _arguments) {
        MainUtils.printHelpOut(System.out, command, flags, Collections.singletonList(arguments));
    };
    constructor.printHelpCmd = function(command, flags, params) {
        MainUtils.printHelpOut(System.out, command, flags, params);
    };
    constructor.getGitRevision = function() {
        var is = null;
        try {
            is = Thread.currentThread().getContextClassLoader().getResourceAsStream(MainUtils.GIT_PROPERTIES);
            if (is == null) 
                return null;
            var properties = new Properties();
            properties.load(is);
            return properties.get(MainUtils.KEY_GIT_REVISION);
        }catch (e) {} finally {
            IOUtils.closeQuietly(is);
        }
        return null;
    };
    constructor.printHelpOut = function(out, command, flags, params) {
        var version = MainUtils.getPackage().getImplementationVersion();
        var gitRevision = MainUtils.getGitRevision();
        if (command == null || command.isEmpty()) 
            command = "jcodec";
        if (gitRevision != null || version != null) {
            out.println(command + MainUtils.bold((version != null ? " v." + version : "") + (gitRevision != null ? " rev. " + gitRevision : "")));
            out.println();
        }
        out.print(MainUtils.bold("Syntax: " + command));
        var sample = new StringBuilder();
        var detail = new StringBuilder();
        for (var index$flag = 0, arr$flag = flags; index$flag < arr$flag.length; index$flag++) {
            var flag = arr$flag[index$flag];
            sample.append(" [");
            detail.append("\t");
            if (flag.getLongName() != null) {
                sample.append(MainUtils.bold(MainUtils.color("--" + flag.getLongName() + "=<value>", MainUtils.ANSIColor.MAGENTA)));
                detail.append(MainUtils.bold(MainUtils.color("--" + flag.getLongName(), MainUtils.ANSIColor.MAGENTA)));
            }
            if (flag.getShortName() != null) {
                if (flag.getLongName() != null) {
                    sample.append(" (");
                    detail.append(" (");
                }
                sample.append(MainUtils.bold(MainUtils.color("-" + flag.getShortName() + " <value>", MainUtils.ANSIColor.MAGENTA)));
                detail.append(MainUtils.bold(MainUtils.color("-" + flag.getShortName(), MainUtils.ANSIColor.MAGENTA)));
                if (flag.getLongName() != null) {
                    sample.append(")");
                    detail.append(")");
                }
            }
            sample.append("]");
            detail.append("\t\t" + flag.getDescription() + "\n");
        }
        for (var iterator$param = params.iterator(); iterator$param.hasNext(); ) {
            var param = iterator$param.next();
            if (param.charAt(0) != '?'.charCodeAt(0)) 
                sample.append(MainUtils.bold(" <" + param + ">"));
             else 
                sample.append(MainUtils.bold(" [" + param.substring(1) + "]"));
        }
        out.println(sample);
        out.println(MainUtils.bold("Where:"));
        out.println(detail);
    };
    constructor.ANSIColor = stjs.enumeration("BLACK", "RED", "GREEN", "BROWN", "BLUE", "MAGENTA", "CYAN", "GREY");
    constructor.bold = function(str) {
        return MainUtils.isColorSupported ? "\x1b[1m" + str + "\x1b[0m" : str;
    };
    constructor.colorString = function(str, placeholder) {
        return MainUtils.isColorSupported ? "\x1b[" + placeholder + "m" + str + "\x1b[0m" : str;
    };
    constructor.color = function(str, fg) {
        return MainUtils.isColorSupported ? "\x1b[" + (30 + (fg.ordinal() & 7)) + "m" + str + "\x1b[0m" : str;
    };
    constructor.colorBright = function(str, fg, bright) {
        return MainUtils.isColorSupported ? "\x1b[" + (30 + (fg.ordinal() & 7)) + ";" + (bright ? 1 : 2) + "m" + str + "\x1b[0m" : str;
    };
    constructor.color3 = function(str, fg, bg) {
        return MainUtils.isColorSupported ? "\x1b[" + (30 + (fg.ordinal() & 7)) + ";" + (40 + (bg.ordinal() & 7)) + ";1m" + str + "\x1b[0m" : str;
    };
    constructor.color4 = function(str, fg, bg, bright) {
        return MainUtils.isColorSupported ? "\x1b[" + (30 + (fg.ordinal() & 7)) + ";" + (40 + (bg.ordinal() & 7)) + ";" + (bright ? 1 : 2) + "m" + str + "\x1b[0m" : str;
    };
    constructor.tildeExpand = function(path) {
        if (path.startsWith("~")) {
            path = path.replaceFirst("~", System.getProperty("user.home"));
        }
        return new File(path);
    };
}, {flagPattern: "Pattern"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var WavHeader = function(chunkId, chunkSize, format, fmt, dataOffset, dataSize) {
    this.chunkId = chunkId;
    this.chunkSize = chunkSize;
    this.format = format;
    this.fmt = fmt;
    this.dataOffset = dataOffset;
    this.dataSize = dataSize;
};
WavHeader = stjs.extend(WavHeader, null, [], function(constructor, prototype) {
    constructor.FmtChunkExtended = function(other, cbSize, bitsPerCodedSample, channelLayout, guid) {
        WavHeader.FmtChunk.call(this, other.audioFormat, other.numChannels, other.sampleRate, other.byteRate, other.blockAlign, other.bitsPerSample);
        this.cbSize = cbSize;
        this.bitsPerCodedSample = bitsPerCodedSample;
        this.channelLayout = channelLayout;
        this.guid = guid;
    };
    constructor.FmtChunkExtended = stjs.extend(constructor.FmtChunkExtended, WavHeader.FmtChunk, [], function(constructor, prototype) {
        prototype.cbSize = 0;
        prototype.bitsPerCodedSample = 0;
        prototype.channelLayout = 0;
        prototype.guid = 0;
        constructor.read = function(bb) {
            var fmtChunk = WavHeader.FmtChunk.get(bb);
            var old = bb.getOrder();
            try {
                bb.order(ByteOrder.LITTLE_ENDIAN);
                return new WavHeader.FmtChunkExtended(fmtChunk, bb.getShort(), bb.getShort(), bb.getInt(), bb.getInt());
            } finally {
                bb.order(old);
            }
        };
        prototype.put = function(bb) {
            WavHeader.FmtChunk.prototype.put.call(this, bb);
            var old = bb.getOrder();
            bb.order(ByteOrder.LITTLE_ENDIAN);
            bb.putShort(this.cbSize);
            bb.putShort(this.bitsPerCodedSample);
            bb.putInt(this.channelLayout);
            bb.putInt(this.guid);
            bb.order(old);
        };
        prototype.size = function() {
            return WavHeader.FmtChunk.prototype.size.call(this) + 12;
        };
        prototype.getLabels = function() {
            var labels = new ArrayList();
            for (var i = 0; i < WavHeader.mapping.length; i++) {
                if ((this.channelLayout & (1 << i)) != 0) 
                    labels.add(WavHeader.mapping[i]);
            }
            return labels.toArray(Array(0));
        };
    }, {}, {});
    constructor.mapping = [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.CENTER, ChannelLabel.LFE, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT, ChannelLabel.FRONT_CENTER_LEFT, ChannelLabel.FRONT_CENTER_RIGHT, ChannelLabel.REAR_CENTER, ChannelLabel.SIDE_LEFT, ChannelLabel.SIDE_RIGHT, ChannelLabel.CENTER, ChannelLabel.FRONT_LEFT, ChannelLabel.CENTER, ChannelLabel.FRONT_RIGHT, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_CENTER, ChannelLabel.REAR_RIGHT, ChannelLabel.STEREO_LEFT, ChannelLabel.STEREO_RIGHT];
    constructor.FmtChunk = function(audioFormat, numChannels, sampleRate, byteRate, blockAlign, bitsPerSample) {
        this.audioFormat = audioFormat;
        this.numChannels = numChannels;
        this.sampleRate = sampleRate;
        this.byteRate = byteRate;
        this.blockAlign = blockAlign;
        this.bitsPerSample = bitsPerSample;
    };
    constructor.FmtChunk = stjs.extend(constructor.FmtChunk, null, [], function(constructor, prototype) {
        prototype.audioFormat = 0;
        prototype.numChannels = 0;
        prototype.sampleRate = 0;
        prototype.byteRate = 0;
        prototype.blockAlign = 0;
        prototype.bitsPerSample = 0;
        constructor.get = function(bb) {
            var old = bb.getOrder();
            try {
                bb.order(ByteOrder.LITTLE_ENDIAN);
                return new WavHeader.FmtChunk(bb.getShort(), bb.getShort(), bb.getInt(), bb.getInt(), bb.getShort(), bb.getShort());
            } finally {
                bb.order(old);
            }
        };
        prototype.put = function(bb) {
            var old = bb.getOrder();
            bb.order(ByteOrder.LITTLE_ENDIAN);
            bb.putShort(this.audioFormat);
            bb.putShort(this.numChannels);
            bb.putInt(this.sampleRate);
            bb.putInt(this.byteRate);
            bb.putShort(this.blockAlign);
            bb.putShort(this.bitsPerSample);
            bb.order(old);
        };
        prototype.size = function() {
            return 16;
        };
    }, {}, {});
    prototype.chunkId = null;
    prototype.chunkSize = 0;
    prototype.format = null;
    prototype.fmt = null;
    prototype.dataOffset = 0;
    prototype.dataSize = 0;
    constructor.WAV_HEADER_SIZE = 44;
    constructor.copyWithRate = function(header, rate) {
        var result = new WavHeader(header.chunkId, header.chunkSize, header.format, WavHeader.copyFmt(header.fmt), header.dataOffset, header.dataSize);
        result.fmt.sampleRate = rate;
        return result;
    };
    constructor.copyWithChannels = function(header, channels) {
        var result = new WavHeader(header.chunkId, header.chunkSize, header.format, WavHeader.copyFmt(header.fmt), header.dataOffset, header.dataSize);
        result.fmt.numChannels = ((channels) << 16 >> 16);
        return result;
    };
    constructor.copyFmt = function(fmt) {
        if (stjs.isInstanceOf(fmt.constructor, WavHeader.FmtChunkExtended)) {
            var fmtext = fmt;
            fmt = new WavHeader.FmtChunkExtended(fmtext, fmtext.cbSize, fmtext.bitsPerCodedSample, fmtext.channelLayout, fmtext.guid);
        } else {
            fmt = new WavHeader.FmtChunk(fmt.audioFormat, fmt.numChannels, fmt.sampleRate, fmt.byteRate, fmt.blockAlign, fmt.bitsPerSample);
        }
        return fmt;
    };
    /**
     *  Creates wav header for the specified audio format
     *  
     *  @param format
     *  @param samples
     */
    constructor.createWavHeader = function(format, samples) {
        var w = new WavHeader("RIFF", 40, "WAVE", new WavHeader.FmtChunk(((1) << 16 >> 16), ((format.getChannels()) << 16 >> 16), format.getSampleRate(), format.getSampleRate() * format.getChannels() * (format.getSampleSizeInBits() >> 3), (((format.getChannels() * (format.getSampleSizeInBits() >> 3))) << 16 >> 16), ((format.getSampleSizeInBits()) << 16 >> 16)), 44, WavHeader.calcDataSize(format.getChannels(), format.getSampleSizeInBits() >> 3, samples));
        return w;
    };
    constructor.stereo48k = function() {
        return WavHeader.stereo48kWithSamples(0);
    };
    constructor.stereo48kWithSamples = function(samples) {
        return new WavHeader("RIFF", 40, "WAVE", new WavHeader.FmtChunk(((1) << 16 >> 16), ((2) << 16 >> 16), 48000, stjs.trunc(48000 * 2 * 16 / 8), ((4) << 16 >> 16), ((16) << 16 >> 16)), 44, WavHeader.calcDataSize(2, 2, samples));
    };
    constructor.mono48k = function(samples) {
        return new WavHeader("RIFF", 40, "WAVE", new WavHeader.FmtChunk(((1) << 16 >> 16), ((1) << 16 >> 16), 48000, stjs.trunc(48000 * 1 * 16 / 8), ((2) << 16 >> 16), ((16) << 16 >> 16)), 44, WavHeader.calcDataSize(1, 2, samples));
    };
    constructor.emptyWavHeader = function() {
        return new WavHeader("RIFF", 40, "WAVE", WavHeader.newFmtChunk(), 44, 0);
    };
    constructor.newFmtChunk = function() {
        return new WavHeader.FmtChunk(((1) << 16 >> 16), ((0) << 16 >> 16), 0, 0, ((0) << 16 >> 16), ((0) << 16 >> 16));
    };
    constructor.read = function(file) {
        var is = null;
        try {
            is = NIOUtils.readableChannel(file);
            return WavHeader.readChannel(is);
        } finally {
            IOUtils.closeQuietly(is);
        }
    };
    constructor.readChannel = function(_in) {
        var buf = ByteBuffer.allocate(128);
        buf.order(ByteOrder.LITTLE_ENDIAN);
        _in.read(buf);
        if (buf.remaining() > 0) 
             throw new IOException("Incomplete wav header found");
        buf.flip();
        var chunkId = NIOUtils.readString(buf, 4);
        var chunkSize = buf.getInt();
        var format = NIOUtils.readString(buf, 4);
        var fmt = null;
        if (!"RIFF".equals(chunkId) || !"WAVE".equals(format)) {
            return null;
        }
        var fourcc;
        var size = 0;
        do {
            fourcc = NIOUtils.readString(buf, 4);
            size = buf.getInt();
            if ("fmt ".equals(fourcc) && size >= 14 && size <= 1024 * 1024) {
                switch (size) {
                    case 16:
                        fmt = WavHeader.FmtChunk.get(buf);
                        break;
                    case 18:
                        fmt = WavHeader.FmtChunk.get(buf);
                        NIOUtils.skip(buf, 2);
                        break;
                    case 40:
                        fmt = WavHeader.FmtChunkExtended.get(buf);
                        NIOUtils.skip(buf, 12);
                        break;
                    case 28:
                        fmt = WavHeader.FmtChunkExtended.get(buf);
                        break;
                    default:
                         throw new UnhandledStateException("Don't know how to handle fmt size: " + size);
                }
            } else if (!"data".equals(fourcc)) {
                NIOUtils.skip(buf, size);
            }
        } while (!"data".equals(fourcc));
        return new WavHeader(chunkId, chunkSize, format, fmt, buf.position(), size);
    };
    constructor.multiChannelWavFromFiles = function(_arguments) {
        var headers = Array(arguments.length);
        for (var i = 0; i < arguments.length; i++) {
            headers[i] = WavHeader.read(arguments[i]);
        }
        return WavHeader.multiChannelWav(headers);
    };
    /**
     * Takes single channel wavs as input produces multi channel wav 
     */
    constructor.multiChannelWav = function(_arguments) {
        var w = WavHeader.emptyWavHeader();
        var totalSize = 0;
        for (var i = 0; i < arguments.length; i++) {
            var wavHeader = arguments[i];
            totalSize += wavHeader.dataSize;
        }
        w.dataSize = totalSize;
        var fmt = arguments[0].fmt;
        var bitsPerSample = fmt.bitsPerSample;
        var bytesPerSample = stjs.trunc(bitsPerSample / 8);
        var sampleRate = stjs.trunc(fmt.sampleRate);
        w.fmt.bitsPerSample = ((bitsPerSample) << 16 >> 16);
        w.fmt.blockAlign = (((arguments.length * bytesPerSample)) << 16 >> 16);
        w.fmt.byteRate = arguments.length * bytesPerSample * sampleRate;
        w.fmt.numChannels = ((arguments.length) << 16 >> 16);
        w.fmt.sampleRate = sampleRate;
        return w;
    };
    prototype.write = function(out) {
        var bb = ByteBuffer.allocate(44);
        bb.order(ByteOrder.LITTLE_ENDIAN);
        var chunkSize;
        if (this.dataSize <= 4294967295) {
            chunkSize = this.dataSize + 36;
        } else {
            chunkSize = 40;
        }
        bb.putArr(JCodecUtil2.asciiString("RIFF"));
        bb.putInt(((chunkSize) | 0));
        bb.putArr(JCodecUtil2.asciiString("WAVE"));
        bb.putArr(JCodecUtil2.asciiString("fmt "));
        bb.putInt(this.fmt.size());
        this.fmt.put(bb);
        bb.putArr(JCodecUtil2.asciiString("data"));
        if (this.dataSize <= 4294967295) {
            bb.putInt(((this.dataSize) | 0));
        } else {
            bb.putInt(0);
        }
        bb.flip();
        out.write(bb);
    };
    constructor.calcDataSize = function(numChannels, bytesPerSample, samples) {
        return samples * numChannels * bytesPerSample;
    };
    constructor.create = function(af, size) {
        var w = WavHeader.emptyWavHeader();
        w.dataSize = size;
        var fmt = WavHeader.newFmtChunk();
        var bitsPerSample = af.getSampleSizeInBits();
        var bytesPerSample = stjs.trunc(bitsPerSample / 8);
        var sampleRate = stjs.trunc(af.getSampleRate());
        w.fmt.bitsPerSample = ((bitsPerSample) << 16 >> 16);
        w.fmt.blockAlign = stjs.trunc((af.getFrameSize()));
        w.fmt.byteRate = stjs.trunc(af.getFrameRate()) * af.getFrameSize();
        w.fmt.numChannels = ((af.getChannels()) << 16 >> 16);
        w.fmt.sampleRate = stjs.trunc(af.getSampleRate());
        return w;
    };
    prototype.getChannelLabels = function() {
        if (stjs.isInstanceOf(this.fmt.constructor, WavHeader.FmtChunkExtended)) {
            return (this.fmt).getLabels();
        } else {
            switch (this.fmt.numChannels) {
                case 1:
                    return [ChannelLabel.MONO];
                case 2:
                    return [ChannelLabel.STEREO_LEFT, ChannelLabel.STEREO_RIGHT];
                case 3:
                    return [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.REAR_CENTER];
                case 4:
                    return [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT];
                case 5:
                    return [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.CENTER, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT];
                case 6:
                    return [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.CENTER, ChannelLabel.LFE, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT];
                case 7:
                    return [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.CENTER, ChannelLabel.LFE, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT, ChannelLabel.REAR_CENTER];
                case 8:
                    return [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.CENTER, ChannelLabel.LFE, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT];
                default:
                    var labels = Array(this.fmt.numChannels);
                    Arrays.fill(labels, ChannelLabel.MONO);
                    return labels;
            }
        }
    };
    prototype.getFormat = function() {
        return new AudioFormat(this.fmt.sampleRate, this.fmt.bitsPerSample, this.fmt.numChannels, true, false);
    };
}, {mapping: "Array", fmt: "WavHeader.FmtChunk"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var KLV = function(k, len, offset, dataOffset) {
    this.key = k;
    this.len = len;
    this.offset = offset;
    this.dataOffset = dataOffset;
};
KLV = stjs.extend(KLV, null, [], function(constructor, prototype) {
    prototype.offset = 0;
    prototype.dataOffset = 0;
    prototype.key = null;
    prototype.len = 0;
    prototype.value = null;
    prototype.toString = function() {
        return "KLV [offset=" + this.offset + ", dataOffset=" + this.dataOffset + ", key=" + this.key + ", len=" + this.len + ", value=" + this.value + "]";
    };
    constructor.readKL = function(ch) {
        var offset = ch.position();
        if (offset >= ch.size() - 1) 
            return null;
        var key = new Int8Array(16);
        ch.read(ByteBuffer.wrap(key));
        var len = BER.decodeLength(ch);
        var dataOffset = ch.position();
        return new KLV(new UL(key), len, offset, dataOffset);
    };
    /**
     *  @return byte count of BER encoded "length" field
     */
    prototype.getLenByteCount = function() {
        var berlen = (((this.dataOffset - this.offset - 16)) | 0);
        return berlen <= 0 ? 4 : berlen;
    };
    constructor.matches = function(key1, key2, len) {
        for (var i = 0; i < len; i++) 
            if (key1[i] != key2[i]) 
                return false;
        return true;
    };
    constructor.readKLFromBuffer = function(buffer, baseOffset) {
        if (buffer.remaining() < 17) 
            return null;
        var offset = baseOffset + buffer.position();
        var ul = UL.read(buffer);
        var len = BER.decodeLengthBuf(buffer);
        return new KLV(ul, len, offset, baseOffset + buffer.position());
    };
}, {key: "UL", value: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var DecoderSpecific = function(data) {
    Descriptor.call(this, DecoderSpecific.tag(), 0);
    this.data = data;
};
DecoderSpecific = stjs.extend(DecoderSpecific, Descriptor, [], function(constructor, prototype) {
    prototype.data = null;
    prototype.doWrite = function(out) {
        NIOUtils.write(out, this.data);
    };
    constructor.tag = function() {
        return 5;
    };
    prototype.getData = function() {
        return this.data;
    };
}, {data: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var NodeDescriptor = function(tag, children) {
    Descriptor.call(this, tag, 0);
    this.children = children;
};
NodeDescriptor = stjs.extend(NodeDescriptor, Descriptor, [], function(constructor, prototype) {
    prototype.children = null;
    prototype.doWrite = function(out) {
        for (var iterator$descr = this.children.iterator(); iterator$descr.hasNext(); ) {
            var descr = iterator$descr.next();
            descr.write(out);
        }
    };
    prototype.getChildren = function() {
        return this.children;
    };
    constructor.findByTag = function(es, tag) {
        if (es.getTag() == tag) 
            return es;
         else {
            if (stjs.isInstanceOf(es.constructor, NodeDescriptor)) {
                for (var iterator$descriptor = (es).getChildren().iterator(); iterator$descriptor.hasNext(); ) {
                    var descriptor = iterator$descriptor.next();
                    var res = NodeDescriptor.findByTag(descriptor, tag);
                    if (res != null) 
                        return res;
                }
            }
        }
        return null;
    };
}, {children: {name: "Collection", arguments: ["Descriptor"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SL = function() {
    Descriptor.call(this, SL.tag(), 0);
};
SL = stjs.extend(SL, Descriptor, [], function(constructor, prototype) {
    prototype.doWrite = function(out) {
        out.put((2 << 24 >> 24));
    };
    constructor.tag = function() {
        return 6;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MXFPartitionPack = function(ul) {
    MXFMetadata.call(this, ul);
};
MXFPartitionPack = stjs.extend(MXFPartitionPack, MXFMetadata, [], function(constructor, prototype) {
    prototype.kagSize = 0;
    prototype.thisPartition = 0;
    prototype.prevPartition = 0;
    prototype.footerPartition = 0;
    prototype.headerByteCount = 0;
    prototype.indexByteCount = 0;
    prototype.indexSid = 0;
    prototype.bodySid = 0;
    prototype.op = null;
    prototype.nbEssenceContainers = 0;
    prototype.readBuf = function(bb) {
        bb.order(ByteOrder.BIG_ENDIAN);
        NIOUtils.skip(bb, 4);
        this.kagSize = bb.getInt();
        this.thisPartition = bb.getLong();
        this.prevPartition = bb.getLong();
        this.footerPartition = bb.getLong();
        this.headerByteCount = bb.getLong();
        this.indexByteCount = bb.getLong();
        this.indexSid = bb.getInt();
        NIOUtils.skip(bb, 8);
        this.bodySid = bb.getInt();
        this.op = UL.read(bb);
        this.nbEssenceContainers = bb.getInt();
    };
    prototype.getKagSize = function() {
        return this.kagSize;
    };
    prototype.getThisPartition = function() {
        return this.thisPartition;
    };
    prototype.getPrevPartition = function() {
        return this.prevPartition;
    };
    prototype.getFooterPartition = function() {
        return this.footerPartition;
    };
    prototype.getHeaderByteCount = function() {
        return this.headerByteCount;
    };
    prototype.getIndexByteCount = function() {
        return this.indexByteCount;
    };
    prototype.getIndexSid = function() {
        return this.indexSid;
    };
    prototype.getBodySid = function() {
        return this.bodySid;
    };
    prototype.getOp = function() {
        return this.op;
    };
    prototype.getNbEssenceContainers = function() {
        return this.nbEssenceContainers;
    };
}, {op: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MXFInterchangeObject = function(ul) {
    MXFMetadata.call(this, ul);
};
MXFInterchangeObject = stjs.extend(MXFInterchangeObject, MXFMetadata, [], function(constructor, prototype) {
    prototype.generationUID = null;
    prototype.objectClass = null;
    prototype.readBuf = function(bb) {
        bb.order(ByteOrder.BIG_ENDIAN);
        var tags = new HashMap();
         while (bb.hasRemaining()){
            var tag = bb.getShort() & 65535;
            var size = bb.getShort() & 65535;
            var _bb = NIOUtils.read(bb, size);
            switch (tag) {
                case 15370:
                    this.uid = UL.read(_bb);
                    break;
                case 258:
                    this.generationUID = UL.read(_bb);
                    break;
                case 257:
                    this.objectClass = UL.read(_bb);
                    break;
                default:
                    tags.put(tag, _bb);
            }
        }
        if (tags.size() > 0) 
            this.read(tags);
    };
    prototype.read = function(tags) {};
    prototype.getGenerationUID = function() {
        return this.generationUID;
    };
    prototype.getObjectClass = function() {
        return this.objectClass;
    };
}, {generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var MKVType = function(name, id, clazz) {
    this._name = name;
    this.id = id;
    this.clazz = clazz;
    MKVType._values.add(this);
};
MKVType = stjs.extend(MKVType, null, [], function(constructor, prototype) {
    constructor._values = new ArrayList();
    constructor.Void = new MKVType("Void", new Int8Array([(236 << 24 >> 24)]), EbmlVoid);
    constructor.CRC32 = new MKVType("CRC32", new Int8Array([(191 << 24 >> 24)]), EbmlBin);
    constructor.EBML = new MKVType("EBML", new Int8Array([26, 69, (223 << 24 >> 24), (163 << 24 >> 24)]), EbmlMaster);
    constructor.EBMLVersion = new MKVType("EBMLVersion", new Int8Array([66, (134 << 24 >> 24)]), EbmlUint);
    constructor.EBMLReadVersion = new MKVType("EBMLReadVersion", new Int8Array([66, (247 << 24 >> 24)]), EbmlUint);
    constructor.EBMLMaxIDLength = new MKVType("EBMLMaxIDLength", new Int8Array([66, (242 << 24 >> 24)]), EbmlUint);
    constructor.EBMLMaxSizeLength = new MKVType("EBMLMaxSizeLength", new Int8Array([66, (243 << 24 >> 24)]), EbmlUint);
    constructor.DocType = new MKVType("DocType", new Int8Array([66, (130 << 24 >> 24)]), EbmlString);
    constructor.DocTypeVersion = new MKVType("DocTypeVersion", new Int8Array([66, (135 << 24 >> 24)]), EbmlUint);
    constructor.DocTypeReadVersion = new MKVType("DocTypeReadVersion", new Int8Array([66, (133 << 24 >> 24)]), EbmlUint);
    constructor.Segment = new MKVType("Segment", MkvSegment.SEGMENT_ID, MkvSegment);
    constructor.SeekHead = new MKVType("SeekHead", new Int8Array([17, 77, (155 << 24 >> 24), 116]), EbmlMaster);
    constructor.Seek = new MKVType("Seek", new Int8Array([77, (187 << 24 >> 24)]), EbmlMaster);
    constructor.SeekID = new MKVType("SeekID", new Int8Array([83, (171 << 24 >> 24)]), EbmlBin);
    constructor.SeekPosition = new MKVType("SeekPosition", new Int8Array([83, (172 << 24 >> 24)]), EbmlUint);
    constructor.Info = new MKVType("Info", new Int8Array([21, (73 << 24 >> 24), (169 << 24 >> 24), (102 << 24 >> 24)]), EbmlMaster);
    constructor.SegmentUID = new MKVType("SegmentUID", new Int8Array([115, (164 << 24 >> 24)]), EbmlBin);
    constructor.SegmentFilename = new MKVType("SegmentFilename", new Int8Array([115, (132 << 24 >> 24)]), EbmlString);
    constructor.PrevUID = new MKVType("PrevUID", new Int8Array([60, (185 << 24 >> 24), 35]), EbmlBin);
    constructor.PrevFilename = new MKVType("PrevFilename", new Int8Array([60, (131 << 24 >> 24), (171 << 24 >> 24)]), EbmlString);
    constructor.NextUID = new MKVType("NextUID", new Int8Array([62, (185 << 24 >> 24), 35]), EbmlBin);
    constructor.NextFilenam = new MKVType("NextFilenam", new Int8Array([62, (131 << 24 >> 24), (187 << 24 >> 24)]), EbmlString);
    constructor.SegmentFamily = new MKVType("SegmentFamily", new Int8Array([68, 68]), EbmlBin);
    constructor.ChapterTranslate = new MKVType("ChapterTranslate", new Int8Array([105, 36]), EbmlMaster);
    constructor.ChapterTranslateEditionUID = new MKVType("ChapterTranslateEditionUID", new Int8Array([105, (252 << 24 >> 24)]), EbmlUint);
    constructor.ChapterTranslateCodec = new MKVType("ChapterTranslateCodec", new Int8Array([105, (191 << 24 >> 24)]), EbmlUint);
    constructor.ChapterTranslateID = new MKVType("ChapterTranslateID", new Int8Array([105, (165 << 24 >> 24)]), EbmlBin);
    constructor.TimecodeScale = new MKVType("TimecodeScale", new Int8Array([42, (215 << 24 >> 24), (177 << 24 >> 24)]), EbmlUint);
    constructor.Duration = new MKVType("Duration", new Int8Array([68, (137 << 24 >> 24)]), EbmlFloat);
    constructor.DateUTC = new MKVType("DateUTC", new Int8Array([68, (97 << 24 >> 24)]), EbmlDate);
    constructor.Title = new MKVType("Title", new Int8Array([123, (169 << 24 >> 24)]), EbmlString);
    constructor.MuxingApp = new MKVType("MuxingApp", new Int8Array([77, (128 << 24 >> 24)]), EbmlString);
    constructor.WritingApp = new MKVType("WritingApp", new Int8Array([87, 65]), EbmlString);
    constructor.Cluster = new MKVType("Cluster", EbmlMaster.CLUSTER_ID, EbmlMaster);
    constructor.Timecode = new MKVType("Timecode", new Int8Array([(231 << 24 >> 24)]), EbmlUint);
    constructor.SilentTracks = new MKVType("SilentTracks", new Int8Array([88, 84]), EbmlMaster);
    constructor.SilentTrackNumber = new MKVType("SilentTrackNumber", new Int8Array([88, (215 << 24 >> 24)]), EbmlUint);
    constructor.Position = new MKVType("Position", new Int8Array([(167 << 24 >> 24)]), EbmlUint);
    constructor.PrevSize = new MKVType("PrevSize", new Int8Array([(171 << 24 >> 24)]), EbmlUint);
    constructor.SimpleBlock = new MKVType("SimpleBlock", MkvBlock.SIMPLEBLOCK_ID, MkvBlock);
    constructor.BlockGroup = new MKVType("BlockGroup", new Int8Array([(160 << 24 >> 24)]), EbmlMaster);
    constructor.Block = new MKVType("Block", MkvBlock.BLOCK_ID, MkvBlock);
    constructor.BlockAdditions = new MKVType("BlockAdditions", new Int8Array([117, (161 << 24 >> 24)]), EbmlMaster);
    constructor.BlockMore = new MKVType("BlockMore", new Int8Array([(166 << 24 >> 24)]), EbmlMaster);
    constructor.BlockAddID = new MKVType("BlockAddID", new Int8Array([(238 << 24 >> 24)]), EbmlUint);
    constructor.BlockAdditional = new MKVType("BlockAdditional", new Int8Array([(165 << 24 >> 24)]), EbmlBin);
    /**
     *  The duration of the Block (based on TimecodeScale). 
     *  This EbmlBase is mandatory when DefaultDuration is set for the track (but can be omitted as other default values). 
     *  When not written and with no DefaultDuration, the value is assumed to be the difference between the timecode 
     *  of this Block and the timecode of the next Block in "display" order (not coding order). 
     *  This EbmlBase can be useful at the end of a Track (as there is not other Block available); 
     *  or when there is a break in a track like for subtitle tracks. 
     *  When set to 0 that means the frame is not a keyframe.
     */
    constructor.BlockDuration = new MKVType("BlockDuration", new Int8Array([(155 << 24 >> 24)]), EbmlUint);
    constructor.ReferencePriority = new MKVType("ReferencePriority", new Int8Array([(250 << 24 >> 24)]), EbmlUint);
    constructor.ReferenceBlock = new MKVType("ReferenceBlock", new Int8Array([(251 << 24 >> 24)]), EbmlSint);
    constructor.CodecState = new MKVType("CodecState", new Int8Array([(164 << 24 >> 24)]), EbmlBin);
    constructor.Slices = new MKVType("Slices", new Int8Array([(142 << 24 >> 24)]), EbmlMaster);
    constructor.TimeSlice = new MKVType("TimeSlice", new Int8Array([(232 << 24 >> 24)]), EbmlMaster);
    constructor.LaceNumber = new MKVType("LaceNumber", new Int8Array([(204 << 24 >> 24)]), EbmlUint);
    constructor.Tracks = new MKVType("Tracks", new Int8Array([22, (84 << 24 >> 24), (174 << 24 >> 24), (107 << 24 >> 24)]), EbmlMaster);
    constructor.TrackEntry = new MKVType("TrackEntry", new Int8Array([(174 << 24 >> 24)]), EbmlMaster);
    constructor.TrackNumber = new MKVType("TrackNumber", new Int8Array([(215 << 24 >> 24)]), EbmlUint);
    constructor.TrackUID = new MKVType("TrackUID", new Int8Array([115, (197 << 24 >> 24)]), EbmlUint);
    constructor.TrackType = new MKVType("TrackType", new Int8Array([(131 << 24 >> 24)]), EbmlUint);
    constructor.FlagEnabled = new MKVType("FlagEnabled", new Int8Array([(185 << 24 >> 24)]), EbmlUint);
    constructor.FlagDefault = new MKVType("FlagDefault", new Int8Array([(136 << 24 >> 24)]), EbmlUint);
    constructor.FlagForced = new MKVType("FlagForced", new Int8Array([85, (170 << 24 >> 24)]), EbmlUint);
    constructor.FlagLacing = new MKVType("FlagLacing", new Int8Array([(156 << 24 >> 24)]), EbmlUint);
    constructor.MinCache = new MKVType("MinCache", new Int8Array([109, (231 << 24 >> 24)]), EbmlUint);
    constructor.MaxCache = new MKVType("MaxCache", new Int8Array([109, (248 << 24 >> 24)]), EbmlUint);
    constructor.DefaultDuration = new MKVType("DefaultDuration", new Int8Array([35, (227 << 24 >> 24), (131 << 24 >> 24)]), EbmlUint);
    constructor.MaxBlockAdditionID = new MKVType("MaxBlockAdditionID", new Int8Array([85, (238 << 24 >> 24)]), EbmlUint);
    constructor.Name = new MKVType("Name", new Int8Array([83, 110]), EbmlString);
    constructor.Language = new MKVType("Language", new Int8Array([34, (181 << 24 >> 24), (156 << 24 >> 24)]), EbmlString);
    constructor.CodecID = new MKVType("CodecID", new Int8Array([(134 << 24 >> 24)]), EbmlString);
    constructor.CodecPrivate = new MKVType("CodecPrivate", new Int8Array([(99 << 24 >> 24), (162 << 24 >> 24)]), EbmlBin);
    constructor.CodecName = new MKVType("CodecName", new Int8Array([(37 << 24 >> 24), (134 << 24 >> 24), (136 << 24 >> 24)]), EbmlString);
    constructor.AttachmentLink = new MKVType("AttachmentLink", new Int8Array([116, 70]), EbmlUint);
    constructor.CodecDecodeAll = new MKVType("CodecDecodeAll", new Int8Array([(170 << 24 >> 24)]), EbmlUint);
    constructor.TrackOverlay = new MKVType("TrackOverlay", new Int8Array([111, (171 << 24 >> 24)]), EbmlUint);
    constructor.TrackTranslate = new MKVType("TrackTranslate", new Int8Array([102, 36]), EbmlMaster);
    constructor.TrackTranslateEditionUID = new MKVType("TrackTranslateEditionUID", new Int8Array([102, (252 << 24 >> 24)]), EbmlUint);
    constructor.TrackTranslateCodec = new MKVType("TrackTranslateCodec", new Int8Array([102, (191 << 24 >> 24)]), EbmlUint);
    constructor.TrackTranslateTrackID = new MKVType("TrackTranslateTrackID", new Int8Array([102, (165 << 24 >> 24)]), EbmlBin);
    constructor.Video = new MKVType("Video", new Int8Array([(224 << 24 >> 24)]), EbmlMaster);
    constructor.FlagInterlaced = new MKVType("FlagInterlaced", new Int8Array([(154 << 24 >> 24)]), EbmlUint);
    constructor.StereoMode = new MKVType("StereoMode", new Int8Array([83, (184 << 24 >> 24)]), EbmlUint);
    constructor.AlphaMode = new MKVType("AlphaMode", new Int8Array([83, (192 << 24 >> 24)]), EbmlUint);
    constructor.PixelWidth = new MKVType("PixelWidth", new Int8Array([(176 << 24 >> 24)]), EbmlUint);
    constructor.PixelHeight = new MKVType("PixelHeight", new Int8Array([(186 << 24 >> 24)]), EbmlUint);
    constructor.PixelCropBottom = new MKVType("PixelCropBottom", new Int8Array([84, (170 << 24 >> 24)]), EbmlUint);
    constructor.PixelCropTop = new MKVType("PixelCropTop", new Int8Array([84, (187 << 24 >> 24)]), EbmlUint);
    constructor.PixelCropLeft = new MKVType("PixelCropLeft", new Int8Array([84, (204 << 24 >> 24)]), EbmlUint);
    constructor.PixelCropRight = new MKVType("PixelCropRight", new Int8Array([84, (221 << 24 >> 24)]), EbmlUint);
    constructor.DisplayWidth = new MKVType("DisplayWidth", new Int8Array([84, (176 << 24 >> 24)]), EbmlUint);
    constructor.DisplayHeight = new MKVType("DisplayHeight", new Int8Array([84, (186 << 24 >> 24)]), EbmlUint);
    constructor.DisplayUnit = new MKVType("DisplayUnit", new Int8Array([84, (178 << 24 >> 24)]), EbmlUint);
    constructor.AspectRatioType = new MKVType("AspectRatioType", new Int8Array([84, (179 << 24 >> 24)]), EbmlUint);
    constructor.ColourSpace = new MKVType("ColourSpace", new Int8Array([46, (181 << 24 >> 24), 36]), EbmlBin);
    constructor.Audio = new MKVType("Audio", new Int8Array([(225 << 24 >> 24)]), EbmlMaster);
    constructor.SamplingFrequency = new MKVType("SamplingFrequency", new Int8Array([(181 << 24 >> 24)]), EbmlFloat);
    constructor.OutputSamplingFrequency = new MKVType("OutputSamplingFrequency", new Int8Array([120, (181 << 24 >> 24)]), EbmlFloat);
    constructor.Channels = new MKVType("Channels", new Int8Array([(159 << 24 >> 24)]), EbmlUint);
    constructor.BitDepth = new MKVType("BitDepth", new Int8Array([98, 100]), EbmlUint);
    constructor.TrackOperation = new MKVType("TrackOperation", new Int8Array([(226 << 24 >> 24)]), EbmlMaster);
    constructor.TrackCombinePlanes = new MKVType("TrackCombinePlanes", new Int8Array([(227 << 24 >> 24)]), EbmlMaster);
    constructor.TrackPlane = new MKVType("TrackPlane", new Int8Array([(228 << 24 >> 24)]), EbmlMaster);
    constructor.TrackPlaneUID = new MKVType("TrackPlaneUID", new Int8Array([(229 << 24 >> 24)]), EbmlUint);
    constructor.TrackPlaneType = new MKVType("TrackPlaneType", new Int8Array([(230 << 24 >> 24)]), EbmlUint);
    constructor.TrackJoinBlocks = new MKVType("TrackJoinBlocks", new Int8Array([(233 << 24 >> 24)]), EbmlMaster);
    constructor.TrackJoinUID = new MKVType("TrackJoinUID", new Int8Array([(237 << 24 >> 24)]), EbmlUint);
    constructor.ContentEncodings = new MKVType("ContentEncodings", new Int8Array([109, (128 << 24 >> 24)]), EbmlMaster);
    constructor.ContentEncoding = new MKVType("ContentEncoding", new Int8Array([98, 64]), EbmlMaster);
    constructor.ContentEncodingOrder = new MKVType("ContentEncodingOrder", new Int8Array([80, 49]), EbmlUint);
    constructor.ContentEncodingScope = new MKVType("ContentEncodingScope", new Int8Array([80, 50]), EbmlUint);
    constructor.ContentEncodingType = new MKVType("ContentEncodingType", new Int8Array([80, 51]), EbmlUint);
    constructor.ContentCompression = new MKVType("ContentCompression", new Int8Array([80, 52]), EbmlMaster);
    constructor.ContentCompAlgo = new MKVType("ContentCompAlgo", new Int8Array([66, (84 << 24 >> 24)]), EbmlUint);
    constructor.ContentCompSettings = new MKVType("ContentCompSettings", new Int8Array([66, 85]), EbmlBin);
    constructor.ContentEncryption = new MKVType("ContentEncryption", new Int8Array([80, 53]), EbmlMaster);
    constructor.ContentEncAlgo = new MKVType("ContentEncAlgo", new Int8Array([71, (225 << 24 >> 24)]), EbmlUint);
    constructor.ContentEncKeyID = new MKVType("ContentEncKeyID", new Int8Array([71, (226 << 24 >> 24)]), EbmlBin);
    constructor.ContentSignature = new MKVType("ContentSignature", new Int8Array([71, (227 << 24 >> 24)]), EbmlBin);
    constructor.ContentSigKeyID = new MKVType("ContentSigKeyID", new Int8Array([71, (228 << 24 >> 24)]), EbmlBin);
    constructor.ContentSigAlgo = new MKVType("ContentSigAlgo", new Int8Array([71, (229 << 24 >> 24)]), EbmlUint);
    constructor.ContentSigHashAlgo = new MKVType("ContentSigHashAlgo", new Int8Array([71, (230 << 24 >> 24)]), EbmlUint);
    constructor.Cues = new MKVType("Cues", new Int8Array([28, 83, (187 << 24 >> 24), 107]), EbmlMaster);
    constructor.CuePoint = new MKVType("CuePoint", new Int8Array([(187 << 24 >> 24)]), EbmlMaster);
    constructor.CueTime = new MKVType("CueTime", new Int8Array([(179 << 24 >> 24)]), EbmlUint);
    constructor.CueTrackPositions = new MKVType("CueTrackPositions", new Int8Array([(183 << 24 >> 24)]), EbmlMaster);
    constructor.CueTrack = new MKVType("CueTrack", new Int8Array([(247 << 24 >> 24)]), EbmlUint);
    constructor.CueClusterPosition = new MKVType("CueClusterPosition", new Int8Array([(241 << 24 >> 24)]), EbmlUint);
    constructor.CueRelativePosition = new MKVType("CueRelativePosition", new Int8Array([(240 << 24 >> 24)]), EbmlUint);
    constructor.CueDuration = new MKVType("CueDuration", new Int8Array([(178 << 24 >> 24)]), EbmlUint);
    constructor.CueBlockNumber = new MKVType("CueBlockNumber", new Int8Array([83, 120]), EbmlUint);
    constructor.CueCodecState = new MKVType("CueCodecState", new Int8Array([(234 << 24 >> 24)]), EbmlUint);
    constructor.CueReference = new MKVType("CueReference", new Int8Array([(219 << 24 >> 24)]), EbmlMaster);
    constructor.CueRefTime = new MKVType("CueRefTime", new Int8Array([(150 << 24 >> 24)]), EbmlUint);
    constructor.Attachments = new MKVType("Attachments", new Int8Array([25, 65, (164 << 24 >> 24), 105]), EbmlMaster);
    constructor.AttachedFile = new MKVType("AttachedFile", new Int8Array([97, (167 << 24 >> 24)]), EbmlMaster);
    constructor.FileDescription = new MKVType("FileDescription", new Int8Array([70, (126 << 24 >> 24)]), EbmlString);
    constructor.FileName = new MKVType("FileName", new Int8Array([70, (110 << 24 >> 24)]), EbmlString);
    constructor.FileMimeType = new MKVType("FileMimeType", new Int8Array([70, (96 << 24 >> 24)]), EbmlString);
    constructor.FileData = new MKVType("FileData", new Int8Array([70, (92 << 24 >> 24)]), EbmlBin);
    constructor.FileUID = new MKVType("FileUID", new Int8Array([70, (174 << 24 >> 24)]), EbmlUint);
    constructor.Chapters = new MKVType("Chapters", new Int8Array([16, (67 << 24 >> 24), (167 << 24 >> 24), (112 << 24 >> 24)]), EbmlMaster);
    constructor.EditionEntry = new MKVType("EditionEntry", new Int8Array([(69 << 24 >> 24), (185 << 24 >> 24)]), EbmlMaster);
    constructor.EditionUID = new MKVType("EditionUID", new Int8Array([(69 << 24 >> 24), (188 << 24 >> 24)]), EbmlUint);
    constructor.EditionFlagHidden = new MKVType("EditionFlagHidden", new Int8Array([(69 << 24 >> 24), (189 << 24 >> 24)]), EbmlUint);
    constructor.EditionFlagDefault = new MKVType("EditionFlagDefault", new Int8Array([(69 << 24 >> 24), (219 << 24 >> 24)]), EbmlUint);
    constructor.EditionFlagOrdered = new MKVType("EditionFlagOrdered", new Int8Array([(69 << 24 >> 24), (221 << 24 >> 24)]), EbmlUint);
    constructor.ChapterAtom = new MKVType("ChapterAtom", new Int8Array([(182 << 24 >> 24)]), EbmlMaster);
    constructor.ChapterUID = new MKVType("ChapterUID", new Int8Array([(115 << 24 >> 24), (196 << 24 >> 24)]), EbmlUint);
    constructor.ChapterStringUID = new MKVType("ChapterStringUID", new Int8Array([86, 84]), EbmlString);
    constructor.ChapterTimeStart = new MKVType("ChapterTimeStart", new Int8Array([(145 << 24 >> 24)]), EbmlUint);
    constructor.ChapterTimeEnd = new MKVType("ChapterTimeEnd", new Int8Array([(146 << 24 >> 24)]), EbmlUint);
    constructor.ChapterFlagHidden = new MKVType("ChapterFlagHidden", new Int8Array([(152 << 24 >> 24)]), EbmlUint);
    constructor.ChapterFlagEnabled = new MKVType("ChapterFlagEnabled", new Int8Array([(69 << 24 >> 24), (152 << 24 >> 24)]), EbmlUint);
    constructor.ChapterSegmentUID = new MKVType("ChapterSegmentUID", new Int8Array([110, 103]), EbmlBin);
    constructor.ChapterSegmentEditionUID = new MKVType("ChapterSegmentEditionUID", new Int8Array([110, (188 << 24 >> 24)]), EbmlUint);
    constructor.ChapterPhysicalEquiv = new MKVType("ChapterPhysicalEquiv", new Int8Array([(99 << 24 >> 24), (195 << 24 >> 24)]), EbmlUint);
    constructor.ChapterTrack = new MKVType("ChapterTrack", new Int8Array([(143 << 24 >> 24)]), EbmlMaster);
    constructor.ChapterTrackNumber = new MKVType("ChapterTrackNumber", new Int8Array([(137 << 24 >> 24)]), EbmlUint);
    constructor.ChapterDisplay = new MKVType("ChapterDisplay", new Int8Array([(128 << 24 >> 24)]), EbmlMaster);
    constructor.ChapString = new MKVType("ChapString", new Int8Array([(133 << 24 >> 24)]), EbmlString);
    constructor.ChapLanguage = new MKVType("ChapLanguage", new Int8Array([(67 << 24 >> 24), (124 << 24 >> 24)]), EbmlString);
    constructor.ChapCountry = new MKVType("ChapCountry", new Int8Array([(67 << 24 >> 24), (126 << 24 >> 24)]), EbmlString);
    constructor.ChapProcess = new MKVType("ChapProcess", new Int8Array([105, 68]), EbmlMaster);
    constructor.ChapProcessCodecID = new MKVType("ChapProcessCodecID", new Int8Array([105, 85]), EbmlUint);
    constructor.ChapProcessPrivate = new MKVType("ChapProcessPrivate", new Int8Array([69, 13]), EbmlBin);
    constructor.ChapProcessCommand = new MKVType("ChapProcessCommand", new Int8Array([105, 17]), EbmlMaster);
    constructor.ChapProcessTime = new MKVType("ChapProcessTime", new Int8Array([105, 34]), EbmlUint);
    constructor.ChapProcessData = new MKVType("ChapProcessData", new Int8Array([105, 51]), EbmlBin);
    constructor.Tags = new MKVType("Tags", new Int8Array([18, (84 << 24 >> 24), (195 << 24 >> 24), (103 << 24 >> 24)]), EbmlMaster);
    constructor.Tag = new MKVType("Tag", new Int8Array([115, (115 << 24 >> 24)]), EbmlMaster);
    constructor.Targets = new MKVType("Targets", new Int8Array([99, (192 << 24 >> 24)]), EbmlMaster);
    constructor.TargetTypeValue = new MKVType("TargetTypeValue", new Int8Array([104, (202 << 24 >> 24)]), EbmlUint);
    constructor.TargetType = new MKVType("TargetType", new Int8Array([99, (202 << 24 >> 24)]), EbmlString);
    constructor.TagTrackUID = new MKVType("TagTrackUID", new Int8Array([99, (197 << 24 >> 24)]), EbmlUint);
    constructor.TagEditionUID = new MKVType("TagEditionUID", new Int8Array([99, (201 << 24 >> 24)]), EbmlUint);
    constructor.TagChapterUID = new MKVType("TagChapterUID", new Int8Array([99, (196 << 24 >> 24)]), EbmlUint);
    constructor.TagAttachmentUID = new MKVType("TagAttachmentUID", new Int8Array([99, (198 << 24 >> 24)]), EbmlUint);
    constructor.SimpleTag = new MKVType("SimpleTag", new Int8Array([103, (200 << 24 >> 24)]), EbmlMaster);
    constructor.TagName = new MKVType("TagName", new Int8Array([69, (163 << 24 >> 24)]), EbmlString);
    constructor.TagLanguage = new MKVType("TagLanguage", new Int8Array([68, 122]), EbmlString);
    constructor.TagDefault = new MKVType("TagDefault", new Int8Array([68, (132 << 24 >> 24)]), EbmlUint);
    constructor.TagString = new MKVType("TagString", new Int8Array([68, (135 << 24 >> 24)]), EbmlString);
    constructor.TagBinary = new MKVType("TagBinary", new Int8Array([68, (133 << 24 >> 24)]), EbmlBin);
    constructor.firstLevelHeaders = [MKVType.SeekHead, MKVType.Info, MKVType.Cluster, MKVType.Tracks, MKVType.Cues, MKVType.Attachments, MKVType.Chapters, MKVType.Tags, MKVType.EBMLVersion, MKVType.EBMLReadVersion, MKVType.EBMLMaxIDLength, MKVType.EBMLMaxSizeLength, MKVType.DocType, MKVType.DocTypeVersion, MKVType.DocTypeReadVersion];
    prototype.id = null;
    prototype.clazz = null;
    prototype._name = null;
    prototype.name = function() {
        return this._name;
    };
    prototype.toString = function() {
        return this._name;
    };
    constructor.values = function() {
        return MKVType._values.toArray(Array(0));
    };
    constructor.createByType = function(g) {
        try {
            var elem = Platform.newInstance(g.clazz, [g.id]);
            elem.type = g;
            return elem;
        }catch (e) {
            e.printStackTrace();
            return new EbmlBin(g.id);
        }
    };
    constructor.createById = function(id, offset) {
        var values = MKVType.values();
        for (var i = 0; i < values.length; i++) {
            var t = values[i];
            if (Platform.arrayEqualsByte(t.id, id)) 
                return MKVType.createByType(t);
        }
        System.err.println("WARNING: unspecified ebml ID (" + EbmlUtil.toHexString(id) + ") encountered at position 0x" + Long.toHexString(offset).toUpperCase());
        var t = new EbmlVoid(id);
        t.type = MKVType.Void;
        return t;
    };
    constructor.isHeaderFirstByte = function(b) {
        var values = MKVType.values();
        for (var i = 0; i < values.length; i++) {
            var t = values[i];
            if (t.id[0] == b) 
                return true;
        }
        return false;
    };
    constructor.isSpecifiedHeader = function(b) {
        var values = MKVType.values();
        for (var i = 0; i < values.length; i++) {
            var firstLevelHeader = values[i];
            if (Platform.arrayEqualsByte(firstLevelHeader.id, b)) 
                return true;
        }
        return false;
    };
    constructor.isFirstLevelHeader = function(b) {
        for (var index$firstLevelHeader = 0, arr$firstLevelHeader = MKVType.firstLevelHeaders; index$firstLevelHeader < arr$firstLevelHeader.length; index$firstLevelHeader++) {
            var firstLevelHeader = arr$firstLevelHeader[index$firstLevelHeader];
            if (Platform.arrayEqualsByte(firstLevelHeader.id, b)) 
                return true;
        }
        return false;
    };
    constructor.children = new HashMap();
    constructor.getParent = function(t) {
        for (var iterator$ent = MKVType.children.entrySet().iterator(); iterator$ent.hasNext(); ) {
            var ent = iterator$ent.next();
            if (ent.getValue().contains(t)) 
                return ent.getKey();
        }
        return null;
    };
    constructor.possibleChild = function(parent, child) {
        if (parent == null) 
            if (child.type == MKVType.EBML || child.type == MKVType.Segment) 
                return true;
             else 
                return false;
        if (Platform.arrayEqualsByte(child.id, MKVType.Void.id) || Platform.arrayEqualsByte(child.id, MKVType.CRC32.id)) 
            return !(child.offset == (parent.dataOffset + parent.dataLen));
        if (child.type == MKVType.Void || child.type == MKVType.CRC32) 
            return true;
        var candidates = MKVType.children.get(parent.type);
        return candidates != null && candidates.contains(child.type);
    };
    constructor.possibleChildById = function(parent, typeId) {
        if (parent == null && (Platform.arrayEqualsByte(MKVType.EBML.id, typeId) || Platform.arrayEqualsByte(MKVType.Segment.id, typeId))) 
            return true;
        if (parent == null) 
            return false;
        if (Platform.arrayEqualsByte(MKVType.Void.id, typeId) || Platform.arrayEqualsByte(MKVType.CRC32.id, typeId)) 
            return true;
        for (var iterator$aCandidate = MKVType.children.get(parent.type).iterator(); iterator$aCandidate.hasNext(); ) {
            var aCandidate = iterator$aCandidate.next();
            if (Platform.arrayEqualsByte(aCandidate.id, typeId)) 
                return true;
        }
        return false;
    };
    constructor.findFirst = function(master, path) {
        var tlist = new LinkedList(Arrays.asList(path));
        return MKVType.findFirstSub(master, tlist);
    };
    constructor.findFirstTree = function(tree, path) {
        var tlist = new LinkedList(Arrays.asList(path));
        for (var iterator$e = tree.iterator(); iterator$e.hasNext(); ) {
            var e = iterator$e.next();
            var z = MKVType.findFirstSub(e, tlist);
            if (z != null) 
                return z;
        }
        return null;
    };
    constructor.findFirstSub = function(elem, path) {
        if (path.size() == 0) 
            return null;
        if (!elem.type.equals(path.get(0))) 
            return null;
        if (path.size() == 1) 
            return elem;
        var head = path.remove(0);
        var result = null;
        if (stjs.isInstanceOf(elem.constructor, EbmlMaster)) {
            var iter = (elem).children.iterator();
             while (iter.hasNext() && result == null)
                result = MKVType.findFirstSub(iter.next(), path);
        }
        path.add(0, head);
        return result;
    };
    constructor.findList = function(tree, class1, path) {
        var result = new LinkedList();
        var tlist = new LinkedList(Arrays.asList(path));
        if (tlist.size() > 0) 
            for (var iterator$node = tree.iterator(); iterator$node.hasNext(); ) {
                var node = iterator$node.next();
                var head = tlist.remove(0);
                if (head == null || head.equals(node.type)) {
                    MKVType.findSubList(node, tlist, result);
                }
                tlist.add(0, head);
            }
        return result;
    };
    constructor.findSubList = function(element, path, result) {
        if (path.size() > 0) {
            var head = path.remove(0);
            if (stjs.isInstanceOf(element.constructor, EbmlMaster)) {
                var nb = element;
                for (var iterator$candidate = nb.children.iterator(); iterator$candidate.hasNext(); ) {
                    var candidate = iterator$candidate.next();
                    if (head == null || head.equals(candidate.type)) {
                        MKVType.findSubList(candidate, path, result);
                    }
                }
            }
            path.add(0, head);
        } else {
            result.add(element);
        }
    };
    constructor.findAllTree = function(tree, class1, path) {
        var result = new LinkedList();
        var tlist = new LinkedList(Arrays.asList(path));
        if (tlist.size() > 0) 
            for (var iterator$node = tree.iterator(); iterator$node.hasNext(); ) {
                var node = iterator$node.next();
                var head = tlist.remove(0);
                if (head == null || head.equals(node.type)) {
                    MKVType.findSub(node, tlist, result);
                }
                tlist.add(0, head);
            }
        return result.toArray(jslang.reflect.Array.newInstance(class1, 0));
    };
    constructor.findAll = function(master, class1, ga, path) {
        var result = new LinkedList();
        var tlist = new LinkedList(Arrays.asList(path));
        if (!master.type.equals(tlist.get(0))) 
            return result.toArray(jslang.reflect.Array.newInstance(class1, 0));
        tlist.remove(0);
        MKVType.findSub(master, tlist, result);
        return result.toArray(jslang.reflect.Array.newInstance(class1, 0));
    };
    constructor.findSub = function(master, path, result) {
        if (path.size() > 0) {
            var head = path.remove(0);
            if (stjs.isInstanceOf(master.constructor, EbmlMaster)) {
                var nb = master;
                for (var iterator$candidate = nb.children.iterator(); iterator$candidate.hasNext(); ) {
                    var candidate = iterator$candidate.next();
                    if (head == null || head.equals(candidate.type)) {
                        MKVType.findSub(candidate, path, result);
                    }
                }
            }
            path.add(0, head);
        } else {
            result.add(master);
        }
    };
}, {_values: {name: "List", arguments: ["MKVType"]}, Void: "MKVType", CRC32: "MKVType", EBML: "MKVType", EBMLVersion: "MKVType", EBMLReadVersion: "MKVType", EBMLMaxIDLength: "MKVType", EBMLMaxSizeLength: "MKVType", DocType: "MKVType", DocTypeVersion: "MKVType", DocTypeReadVersion: "MKVType", Segment: "MKVType", SeekHead: "MKVType", Seek: "MKVType", SeekID: "MKVType", SeekPosition: "MKVType", Info: "MKVType", SegmentUID: "MKVType", SegmentFilename: "MKVType", PrevUID: "MKVType", PrevFilename: "MKVType", NextUID: "MKVType", NextFilenam: "MKVType", SegmentFamily: "MKVType", ChapterTranslate: "MKVType", ChapterTranslateEditionUID: "MKVType", ChapterTranslateCodec: "MKVType", ChapterTranslateID: "MKVType", TimecodeScale: "MKVType", Duration: "MKVType", DateUTC: "MKVType", Title: "MKVType", MuxingApp: "MKVType", WritingApp: "MKVType", Cluster: "MKVType", Timecode: "MKVType", SilentTracks: "MKVType", SilentTrackNumber: "MKVType", Position: "MKVType", PrevSize: "MKVType", SimpleBlock: "MKVType", BlockGroup: "MKVType", Block: "MKVType", BlockAdditions: "MKVType", BlockMore: "MKVType", BlockAddID: "MKVType", BlockAdditional: "MKVType", BlockDuration: "MKVType", ReferencePriority: "MKVType", ReferenceBlock: "MKVType", CodecState: "MKVType", Slices: "MKVType", TimeSlice: "MKVType", LaceNumber: "MKVType", Tracks: "MKVType", TrackEntry: "MKVType", TrackNumber: "MKVType", TrackUID: "MKVType", TrackType: "MKVType", FlagEnabled: "MKVType", FlagDefault: "MKVType", FlagForced: "MKVType", FlagLacing: "MKVType", MinCache: "MKVType", MaxCache: "MKVType", DefaultDuration: "MKVType", MaxBlockAdditionID: "MKVType", Name: "MKVType", Language: "MKVType", CodecID: "MKVType", CodecPrivate: "MKVType", CodecName: "MKVType", AttachmentLink: "MKVType", CodecDecodeAll: "MKVType", TrackOverlay: "MKVType", TrackTranslate: "MKVType", TrackTranslateEditionUID: "MKVType", TrackTranslateCodec: "MKVType", TrackTranslateTrackID: "MKVType", Video: "MKVType", FlagInterlaced: "MKVType", StereoMode: "MKVType", AlphaMode: "MKVType", PixelWidth: "MKVType", PixelHeight: "MKVType", PixelCropBottom: "MKVType", PixelCropTop: "MKVType", PixelCropLeft: "MKVType", PixelCropRight: "MKVType", DisplayWidth: "MKVType", DisplayHeight: "MKVType", DisplayUnit: "MKVType", AspectRatioType: "MKVType", ColourSpace: "MKVType", Audio: "MKVType", SamplingFrequency: "MKVType", OutputSamplingFrequency: "MKVType", Channels: "MKVType", BitDepth: "MKVType", TrackOperation: "MKVType", TrackCombinePlanes: "MKVType", TrackPlane: "MKVType", TrackPlaneUID: "MKVType", TrackPlaneType: "MKVType", TrackJoinBlocks: "MKVType", TrackJoinUID: "MKVType", ContentEncodings: "MKVType", ContentEncoding: "MKVType", ContentEncodingOrder: "MKVType", ContentEncodingScope: "MKVType", ContentEncodingType: "MKVType", ContentCompression: "MKVType", ContentCompAlgo: "MKVType", ContentCompSettings: "MKVType", ContentEncryption: "MKVType", ContentEncAlgo: "MKVType", ContentEncKeyID: "MKVType", ContentSignature: "MKVType", ContentSigKeyID: "MKVType", ContentSigAlgo: "MKVType", ContentSigHashAlgo: "MKVType", Cues: "MKVType", CuePoint: "MKVType", CueTime: "MKVType", CueTrackPositions: "MKVType", CueTrack: "MKVType", CueClusterPosition: "MKVType", CueRelativePosition: "MKVType", CueDuration: "MKVType", CueBlockNumber: "MKVType", CueCodecState: "MKVType", CueReference: "MKVType", CueRefTime: "MKVType", Attachments: "MKVType", AttachedFile: "MKVType", FileDescription: "MKVType", FileName: "MKVType", FileMimeType: "MKVType", FileData: "MKVType", FileUID: "MKVType", Chapters: "MKVType", EditionEntry: "MKVType", EditionUID: "MKVType", EditionFlagHidden: "MKVType", EditionFlagDefault: "MKVType", EditionFlagOrdered: "MKVType", ChapterAtom: "MKVType", ChapterUID: "MKVType", ChapterStringUID: "MKVType", ChapterTimeStart: "MKVType", ChapterTimeEnd: "MKVType", ChapterFlagHidden: "MKVType", ChapterFlagEnabled: "MKVType", ChapterSegmentUID: "MKVType", ChapterSegmentEditionUID: "MKVType", ChapterPhysicalEquiv: "MKVType", ChapterTrack: "MKVType", ChapterTrackNumber: "MKVType", ChapterDisplay: "MKVType", ChapString: "MKVType", ChapLanguage: "MKVType", ChapCountry: "MKVType", ChapProcess: "MKVType", ChapProcessCodecID: "MKVType", ChapProcessPrivate: "MKVType", ChapProcessCommand: "MKVType", ChapProcessTime: "MKVType", ChapProcessData: "MKVType", Tags: "MKVType", Tag: "MKVType", Targets: "MKVType", TargetTypeValue: "MKVType", TargetType: "MKVType", TagTrackUID: "MKVType", TagEditionUID: "MKVType", TagChapterUID: "MKVType", TagAttachmentUID: "MKVType", SimpleTag: "MKVType", TagName: "MKVType", TagLanguage: "MKVType", TagDefault: "MKVType", TagString: "MKVType", TagBinary: "MKVType", firstLevelHeaders: "Array", id: "Int8Array", clazz: {name: "Class", arguments: ["Object"]}, children: {name: "Map", arguments: ["MKVType", {name: "Set", arguments: ["MKVType"]}]}}, {});
(function() {
    MKVType.children.put(MKVType.EBML, new HashSet(Arrays.asList([MKVType.EBMLVersion, MKVType.EBMLReadVersion, MKVType.EBMLMaxIDLength, MKVType.EBMLMaxSizeLength, MKVType.DocType, MKVType.DocTypeVersion, MKVType.DocTypeReadVersion])));
    MKVType.children.put(MKVType.Segment, new HashSet(Arrays.asList([MKVType.SeekHead, MKVType.Info, MKVType.Cluster, MKVType.Tracks, MKVType.Cues, MKVType.Attachments, MKVType.Chapters, MKVType.Tags])));
    MKVType.children.put(MKVType.SeekHead, new HashSet(Arrays.asList([MKVType.Seek])));
    MKVType.children.put(MKVType.Seek, new HashSet(Arrays.asList([MKVType.SeekID, MKVType.SeekPosition])));
    MKVType.children.put(MKVType.Info, new HashSet(Arrays.asList([MKVType.SegmentUID, MKVType.SegmentFilename, MKVType.PrevUID, MKVType.PrevFilename, MKVType.NextUID, MKVType.NextFilenam, MKVType.SegmentFamily, MKVType.ChapterTranslate, MKVType.TimecodeScale, MKVType.Duration, MKVType.DateUTC, MKVType.Title, MKVType.MuxingApp, MKVType.WritingApp])));
    MKVType.children.put(MKVType.ChapterTranslate, new HashSet(Arrays.asList([MKVType.ChapterTranslateEditionUID, MKVType.ChapterTranslateCodec, MKVType.ChapterTranslateID])));
    MKVType.children.put(MKVType.Cluster, new HashSet(Arrays.asList([MKVType.Timecode, MKVType.SilentTracks, MKVType.Position, MKVType.PrevSize, MKVType.SimpleBlock, MKVType.BlockGroup])));
    MKVType.children.put(MKVType.SilentTracks, new HashSet(Arrays.asList([MKVType.SilentTrackNumber])));
    MKVType.children.put(MKVType.BlockGroup, new HashSet(Arrays.asList([MKVType.Block, MKVType.BlockAdditions, MKVType.BlockDuration, MKVType.ReferencePriority, MKVType.ReferenceBlock, MKVType.CodecState, MKVType.Slices])));
    MKVType.children.put(MKVType.BlockAdditions, new HashSet(Arrays.asList([MKVType.BlockMore])));
    MKVType.children.put(MKVType.BlockMore, new HashSet(Arrays.asList([MKVType.BlockAddID, MKVType.BlockAdditional])));
    MKVType.children.put(MKVType.Slices, new HashSet(Arrays.asList([MKVType.TimeSlice])));
    MKVType.children.put(MKVType.TimeSlice, new HashSet(Arrays.asList([MKVType.LaceNumber])));
    MKVType.children.put(MKVType.Tracks, new HashSet(Arrays.asList([MKVType.TrackEntry])));
    MKVType.children.put(MKVType.TrackEntry, new HashSet(Arrays.asList([MKVType.TrackNumber, MKVType.TrackUID, MKVType.TrackType, MKVType.TrackType, MKVType.FlagDefault, MKVType.FlagForced, MKVType.FlagLacing, MKVType.MinCache, MKVType.MaxCache, MKVType.DefaultDuration, MKVType.MaxBlockAdditionID, MKVType.Name, MKVType.Language, MKVType.CodecID, MKVType.CodecPrivate, MKVType.CodecName, MKVType.AttachmentLink, MKVType.CodecDecodeAll, MKVType.TrackOverlay, MKVType.TrackTranslate, MKVType.Video, MKVType.Audio, MKVType.TrackOperation, MKVType.ContentEncodings])));
    MKVType.children.put(MKVType.TrackTranslate, new HashSet(Arrays.asList([MKVType.TrackTranslateEditionUID, MKVType.TrackTranslateCodec, MKVType.TrackTranslateTrackID])));
    MKVType.children.put(MKVType.Video, new HashSet(Arrays.asList([MKVType.FlagInterlaced, MKVType.StereoMode, MKVType.AlphaMode, MKVType.PixelWidth, MKVType.PixelHeight, MKVType.PixelCropBottom, MKVType.PixelCropTop, MKVType.PixelCropLeft, MKVType.PixelCropRight, MKVType.DisplayWidth, MKVType.DisplayHeight, MKVType.DisplayUnit, MKVType.AspectRatioType, MKVType.ColourSpace])));
    MKVType.children.put(MKVType.Audio, new HashSet(Arrays.asList([MKVType.SamplingFrequency, MKVType.OutputSamplingFrequency, MKVType.Channels, MKVType.BitDepth])));
    MKVType.children.put(MKVType.TrackOperation, new HashSet(Arrays.asList([MKVType.TrackCombinePlanes, MKVType.TrackJoinBlocks])));
    MKVType.children.put(MKVType.TrackCombinePlanes, new HashSet(Arrays.asList([MKVType.TrackPlane])));
    MKVType.children.put(MKVType.TrackPlane, new HashSet(Arrays.asList([MKVType.TrackPlaneUID, MKVType.TrackPlaneType])));
    MKVType.children.put(MKVType.TrackJoinBlocks, new HashSet(Arrays.asList([MKVType.TrackJoinUID])));
    MKVType.children.put(MKVType.ContentEncodings, new HashSet(Arrays.asList([MKVType.ContentEncoding])));
    MKVType.children.put(MKVType.ContentEncoding, new HashSet(Arrays.asList([MKVType.ContentEncodingOrder, MKVType.ContentEncodingScope, MKVType.ContentEncodingType, MKVType.ContentCompression, MKVType.ContentEncryption])));
    MKVType.children.put(MKVType.ContentCompression, new HashSet(Arrays.asList([MKVType.ContentCompAlgo, MKVType.ContentCompSettings])));
    MKVType.children.put(MKVType.ContentEncryption, new HashSet(Arrays.asList([MKVType.ContentEncAlgo, MKVType.ContentEncKeyID, MKVType.ContentSignature, MKVType.ContentSigKeyID, MKVType.ContentSigAlgo, MKVType.ContentSigHashAlgo])));
    MKVType.children.put(MKVType.Cues, new HashSet(Arrays.asList([MKVType.CuePoint])));
    MKVType.children.put(MKVType.CuePoint, new HashSet(Arrays.asList([MKVType.CueTime, MKVType.CueTrackPositions])));
    MKVType.children.put(MKVType.CueTrackPositions, new HashSet(Arrays.asList([MKVType.CueTrack, MKVType.CueClusterPosition, MKVType.CueRelativePosition, MKVType.CueDuration, MKVType.CueBlockNumber, MKVType.CueCodecState, MKVType.CueReference])));
    MKVType.children.put(MKVType.CueReference, new HashSet(Arrays.asList([MKVType.CueRefTime])));
    MKVType.children.put(MKVType.Attachments, new HashSet(Arrays.asList([MKVType.AttachedFile])));
    MKVType.children.put(MKVType.AttachedFile, new HashSet(Arrays.asList([MKVType.FileDescription, MKVType.FileName, MKVType.FileMimeType, MKVType.FileData, MKVType.FileUID])));
    MKVType.children.put(MKVType.Chapters, new HashSet(Arrays.asList([MKVType.EditionEntry])));
    MKVType.children.put(MKVType.EditionEntry, new HashSet(Arrays.asList([MKVType.EditionUID, MKVType.EditionFlagHidden, MKVType.EditionFlagDefault, MKVType.EditionFlagOrdered, MKVType.ChapterAtom])));
    MKVType.children.put(MKVType.ChapterAtom, new HashSet(Arrays.asList([MKVType.ChapterUID, MKVType.ChapterStringUID, MKVType.ChapterTimeStart, MKVType.ChapterTimeEnd, MKVType.ChapterFlagHidden, MKVType.ChapterFlagEnabled, MKVType.ChapterSegmentUID, MKVType.ChapterSegmentEditionUID, MKVType.ChapterPhysicalEquiv, MKVType.ChapterTrack, MKVType.ChapterDisplay, MKVType.ChapProcess])));
    MKVType.children.put(MKVType.ChapterTrack, new HashSet(Arrays.asList([MKVType.ChapterTrackNumber])));
    MKVType.children.put(MKVType.ChapterDisplay, new HashSet(Arrays.asList([MKVType.ChapString, MKVType.ChapLanguage, MKVType.ChapCountry])));
    MKVType.children.put(MKVType.ChapProcess, new HashSet(Arrays.asList([MKVType.ChapProcessCodecID, MKVType.ChapProcessPrivate, MKVType.ChapProcessCommand])));
    MKVType.children.put(MKVType.ChapProcessCommand, new HashSet(Arrays.asList([MKVType.ChapProcessTime, MKVType.ChapProcessData])));
    MKVType.children.put(MKVType.Tags, new HashSet(Arrays.asList([MKVType.Tag])));
    MKVType.children.put(MKVType.Tag, new HashSet(Arrays.asList([MKVType.Targets, MKVType.SimpleTag])));
    MKVType.children.put(MKVType.Targets, new HashSet(Arrays.asList([MKVType.TargetTypeValue, MKVType.TargetType, MKVType.TagTrackUID, MKVType.TagEditionUID, MKVType.TagChapterUID, MKVType.TagAttachmentUID])));
    MKVType.children.put(MKVType.SimpleTag, new HashSet(Arrays.asList([MKVType.TagName, MKVType.TagLanguage, MKVType.TagDefault, MKVType.TagString, MKVType.TagBinary])));
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MKVMuxerTrack = function() {
    this.trackBlocks = new ArrayList();
    this.type = MKVMuxerTrack.MKVMuxerTrackType.VIDEO;
};
MKVMuxerTrack = stjs.extend(MKVMuxerTrack, null, [MuxerTrack], function(constructor, prototype) {
    constructor.MKVMuxerTrackType = stjs.enumeration("VIDEO");
    prototype.type = null;
    prototype.videoMeta = null;
    prototype.codecId = null;
    prototype.trackNo = 0;
    prototype.frameDuration = 0;
    prototype.trackBlocks = null;
    constructor.DEFAULT_TIMESCALE = 1000000000;
    constructor.NANOSECONDS_IN_A_MILISECOND = 1000000;
    constructor.MULTIPLIER = stjs.trunc(MKVMuxerTrack.DEFAULT_TIMESCALE / MKVMuxerTrack.NANOSECONDS_IN_A_MILISECOND);
    prototype.getTimescale = function() {
        return MKVMuxerTrack.NANOSECONDS_IN_A_MILISECOND;
    };
    prototype.addFrame = function(outPacket) {
        var frame = MkvBlock.keyFrame(this.trackNo, 0, outPacket.getData());
        frame.absoluteTimecode = outPacket.getPts() - 1;
        this.trackBlocks.add(frame);
    };
    prototype.getTrackNo = function() {
        return this.trackNo;
    };
}, {type: {name: "Enum", arguments: ["MKVMuxerTrack.MKVMuxerTrackType"]}, videoMeta: "VideoCodecMeta", trackBlocks: {name: "List", arguments: ["MkvBlock"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var ChannelSynthesizer = function(channelnumber, factor) {
    this.v = Array.apply(null, Array(2)).map(function() {
        return new Float32Array(512);
    });
    this.scalefactor = factor;
    this.pos = 15;
};
ChannelSynthesizer = stjs.extend(ChannelSynthesizer, null, [], function(constructor, prototype) {
    prototype.v = null;
    prototype.pos = 0;
    prototype.scalefactor = 0.0;
    prototype.current = 0;
    prototype.distributeSamples = function(pos, dest, next, s) {
        for (var i = 0; i < 16; i++) 
            dest[(i << 4) + pos] = s[i];
        for (var i = 1; i < 17; i++) 
            next[(i << 4) + pos] = s[15 + i];
        dest[256 + pos] = 0.0;
        next[0 + pos] = -s[0];
        for (var i = 0; i < 15; i++) 
            dest[272 + (i << 4) + pos] = -s[15 - i];
        for (var i = 0; i < 15; i++) 
            next[272 + (i << 4) + pos] = s[30 - i];
    };
    prototype.synthesize = function(coeffs, out, off) {
        MpaPqmf.computeButterfly(this.pos, coeffs);
        var next = ~this.current & 1;
        this.distributeSamples(this.pos, this.v[this.current], this.v[next], coeffs);
        MpaPqmf.computeFilter(this.pos, this.v[this.current], out, off, this.scalefactor);
        this.pos = (this.pos + 1) & 15;
        this.current = next;
    };
}, {v: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Picture Parameter Set entity of H264 bitstream
 *  
 *  capable to serialize / deserialize with CAVLC bitstream
 *  
 *  @author The JCodec project
 *  
 */
var PictureParameterSet = function() {
    this.numRefIdxActiveMinus1 = new Int32Array(2);
};
PictureParameterSet = stjs.extend(PictureParameterSet, null, [], function(constructor, prototype) {
    constructor.PPSExt = function() {};
    constructor.PPSExt = stjs.extend(constructor.PPSExt, null, [], function(constructor, prototype) {
        prototype.transform8x8ModeFlag = false;
        prototype.scalingMatrix = null;
        prototype.secondChromaQpIndexOffset = 0;
        prototype.isTransform8x8ModeFlag = function() {
            return this.transform8x8ModeFlag;
        };
        prototype.getScalingMatrix = function() {
            return this.scalingMatrix;
        };
        prototype.getSecondChromaQpIndexOffset = function() {
            return this.secondChromaQpIndexOffset;
        };
    }, {scalingMatrix: "Array"}, {});
    prototype.entropyCodingModeFlag = false;
    prototype.numRefIdxActiveMinus1 = null;
    prototype.sliceGroupChangeRateMinus1 = 0;
    prototype.picParameterSetId = 0;
    prototype.seqParameterSetId = 0;
    prototype.picOrderPresentFlag = false;
    prototype.numSliceGroupsMinus1 = 0;
    prototype.sliceGroupMapType = 0;
    prototype.weightedPredFlag = false;
    prototype.weightedBipredIdc = 0;
    prototype.picInitQpMinus26 = 0;
    prototype.picInitQsMinus26 = 0;
    prototype.chromaQpIndexOffset = 0;
    prototype.deblockingFilterControlPresentFlag = false;
    prototype.constrainedIntraPredFlag = false;
    prototype.redundantPicCntPresentFlag = false;
    prototype.topLeft = null;
    prototype.bottomRight = null;
    prototype.runLengthMinus1 = null;
    prototype.sliceGroupChangeDirectionFlag = false;
    prototype.sliceGroupId = null;
    prototype.extended = null;
    constructor.read = function(is) {
        var _in = BitReader.createBitReader(is);
        var pps = new PictureParameterSet();
        pps.picParameterSetId = CAVLCReader.readUEtrace(_in, "PPS: pic_parameter_set_id");
        pps.seqParameterSetId = CAVLCReader.readUEtrace(_in, "PPS: seq_parameter_set_id");
        pps.entropyCodingModeFlag = CAVLCReader.readBool(_in, "PPS: entropy_coding_mode_flag");
        pps.picOrderPresentFlag = CAVLCReader.readBool(_in, "PPS: pic_order_present_flag");
        pps.numSliceGroupsMinus1 = CAVLCReader.readUEtrace(_in, "PPS: num_slice_groups_minus1");
        if (pps.numSliceGroupsMinus1 > 0) {
            pps.sliceGroupMapType = CAVLCReader.readUEtrace(_in, "PPS: slice_group_map_type");
            pps.topLeft = new Int32Array(pps.numSliceGroupsMinus1 + 1);
            pps.bottomRight = new Int32Array(pps.numSliceGroupsMinus1 + 1);
            pps.runLengthMinus1 = new Int32Array(pps.numSliceGroupsMinus1 + 1);
            if (pps.sliceGroupMapType == 0) 
                for (var iGroup = 0; iGroup <= pps.numSliceGroupsMinus1; iGroup++) 
                    pps.runLengthMinus1[iGroup] = CAVLCReader.readUEtrace(_in, "PPS: run_length_minus1");
             else if (pps.sliceGroupMapType == 2) 
                for (var iGroup = 0; iGroup < pps.numSliceGroupsMinus1; iGroup++) {
                    pps.topLeft[iGroup] = CAVLCReader.readUEtrace(_in, "PPS: top_left");
                    pps.bottomRight[iGroup] = CAVLCReader.readUEtrace(_in, "PPS: bottom_right");
                }
             else if (pps.sliceGroupMapType == 3 || pps.sliceGroupMapType == 4 || pps.sliceGroupMapType == 5) {
                pps.sliceGroupChangeDirectionFlag = CAVLCReader.readBool(_in, "PPS: slice_group_change_direction_flag");
                pps.sliceGroupChangeRateMinus1 = CAVLCReader.readUEtrace(_in, "PPS: slice_group_change_rate_minus1");
            } else if (pps.sliceGroupMapType == 6) {
                var NumberBitsPerSliceGroupId;
                if (pps.numSliceGroupsMinus1 + 1 > 4) 
                    NumberBitsPerSliceGroupId = 3;
                 else if (pps.numSliceGroupsMinus1 + 1 > 2) 
                    NumberBitsPerSliceGroupId = 2;
                 else 
                    NumberBitsPerSliceGroupId = 1;
                var pic_size_in_map_units_minus1 = CAVLCReader.readUEtrace(_in, "PPS: pic_size_in_map_units_minus1");
                pps.sliceGroupId = new Int32Array(pic_size_in_map_units_minus1 + 1);
                for (var i = 0; i <= pic_size_in_map_units_minus1; i++) {
                    pps.sliceGroupId[i] = CAVLCReader.readU(_in, NumberBitsPerSliceGroupId, "PPS: slice_group_id [" + i + "]f");
                }
            }
        }
        pps.numRefIdxActiveMinus1 = new Int32Array([CAVLCReader.readUEtrace(_in, "PPS: num_ref_idx_l0_active_minus1"), CAVLCReader.readUEtrace(_in, "PPS: num_ref_idx_l1_active_minus1")]);
        pps.weightedPredFlag = CAVLCReader.readBool(_in, "PPS: weighted_pred_flag");
        pps.weightedBipredIdc = CAVLCReader.readNBit(_in, 2, "PPS: weighted_bipred_idc");
        pps.picInitQpMinus26 = CAVLCReader.readSE(_in, "PPS: pic_init_qp_minus26");
        pps.picInitQsMinus26 = CAVLCReader.readSE(_in, "PPS: pic_init_qs_minus26");
        pps.chromaQpIndexOffset = CAVLCReader.readSE(_in, "PPS: chroma_qp_index_offset");
        pps.deblockingFilterControlPresentFlag = CAVLCReader.readBool(_in, "PPS: deblocking_filter_control_present_flag");
        pps.constrainedIntraPredFlag = CAVLCReader.readBool(_in, "PPS: constrained_intra_pred_flag");
        pps.redundantPicCntPresentFlag = CAVLCReader.readBool(_in, "PPS: redundant_pic_cnt_present_flag");
        if (CAVLCReader.moreRBSPData(_in)) {
            pps.extended = new PictureParameterSet.PPSExt();
            pps.extended.transform8x8ModeFlag = CAVLCReader.readBool(_in, "PPS: transform_8x8_mode_flag");
            var pic_scaling_matrix_present_flag = CAVLCReader.readBool(_in, "PPS: pic_scaling_matrix_present_flag");
            if (pic_scaling_matrix_present_flag) {
                pps.extended.scalingMatrix = Array(8);
                for (var i = 0; i < 6 + 2 * (pps.extended.transform8x8ModeFlag ? 1 : 0); i++) {
                    var scalingListSize = i < 6 ? 16 : 64;
                    if (CAVLCReader.readBool(_in, "PPS: pic_scaling_list_present_flag")) {
                        pps.extended.scalingMatrix[i] = SeqParameterSet.readScalingList(_in, scalingListSize);
                    }
                }
            }
            pps.extended.secondChromaQpIndexOffset = CAVLCReader.readSE(_in, "PPS: second_chroma_qp_index_offset");
        }
        return pps;
    };
    prototype.write = function(out) {
        var writer = new BitWriter(out);
        CAVLCWriter.writeUEtrace(writer, this.picParameterSetId, "PPS: pic_parameter_set_id");
        CAVLCWriter.writeUEtrace(writer, this.seqParameterSetId, "PPS: seq_parameter_set_id");
        CAVLCWriter.writeBool(writer, this.entropyCodingModeFlag, "PPS: entropy_coding_mode_flag");
        CAVLCWriter.writeBool(writer, this.picOrderPresentFlag, "PPS: pic_order_present_flag");
        CAVLCWriter.writeUEtrace(writer, this.numSliceGroupsMinus1, "PPS: num_slice_groups_minus1");
        if (this.numSliceGroupsMinus1 > 0) {
            CAVLCWriter.writeUEtrace(writer, this.sliceGroupMapType, "PPS: slice_group_map_type");
            var top_left = new Int32Array(1);
            var bottom_right = new Int32Array(1);
            var run_length_minus1 = new Int32Array(1);
            if (this.sliceGroupMapType == 0) {
                for (var iGroup = 0; iGroup <= this.numSliceGroupsMinus1; iGroup++) {
                    CAVLCWriter.writeUEtrace(writer, run_length_minus1[iGroup], "PPS: ");
                }
            } else if (this.sliceGroupMapType == 2) {
                for (var iGroup = 0; iGroup < this.numSliceGroupsMinus1; iGroup++) {
                    CAVLCWriter.writeUEtrace(writer, top_left[iGroup], "PPS: ");
                    CAVLCWriter.writeUEtrace(writer, bottom_right[iGroup], "PPS: ");
                }
            } else if (this.sliceGroupMapType == 3 || this.sliceGroupMapType == 4 || this.sliceGroupMapType == 5) {
                CAVLCWriter.writeBool(writer, this.sliceGroupChangeDirectionFlag, "PPS: slice_group_change_direction_flag");
                CAVLCWriter.writeUEtrace(writer, this.sliceGroupChangeRateMinus1, "PPS: slice_group_change_rate_minus1");
            } else if (this.sliceGroupMapType == 6) {
                var NumberBitsPerSliceGroupId;
                if (this.numSliceGroupsMinus1 + 1 > 4) 
                    NumberBitsPerSliceGroupId = 3;
                 else if (this.numSliceGroupsMinus1 + 1 > 2) 
                    NumberBitsPerSliceGroupId = 2;
                 else 
                    NumberBitsPerSliceGroupId = 1;
                CAVLCWriter.writeUEtrace(writer, this.sliceGroupId.length, "PPS: ");
                for (var i = 0; i <= this.sliceGroupId.length; i++) {
                    CAVLCWriter.writeU(writer, this.sliceGroupId[i], NumberBitsPerSliceGroupId);
                }
            }
        }
        CAVLCWriter.writeUEtrace(writer, this.numRefIdxActiveMinus1[0], "PPS: num_ref_idx_l0_active_minus1");
        CAVLCWriter.writeUEtrace(writer, this.numRefIdxActiveMinus1[1], "PPS: num_ref_idx_l1_active_minus1");
        CAVLCWriter.writeBool(writer, this.weightedPredFlag, "PPS: weighted_pred_flag");
        CAVLCWriter.writeNBit(writer, this.weightedBipredIdc, 2, "PPS: weighted_bipred_idc");
        CAVLCWriter.writeSEtrace(writer, this.picInitQpMinus26, "PPS: pic_init_qp_minus26");
        CAVLCWriter.writeSEtrace(writer, this.picInitQsMinus26, "PPS: pic_init_qs_minus26");
        CAVLCWriter.writeSEtrace(writer, this.chromaQpIndexOffset, "PPS: chroma_qp_index_offset");
        CAVLCWriter.writeBool(writer, this.deblockingFilterControlPresentFlag, "PPS: deblocking_filter_control_present_flag");
        CAVLCWriter.writeBool(writer, this.constrainedIntraPredFlag, "PPS: constrained_intra_pred_flag");
        CAVLCWriter.writeBool(writer, this.redundantPicCntPresentFlag, "PPS: redundant_pic_cnt_present_flag");
        if (this.extended != null) {
            CAVLCWriter.writeBool(writer, this.extended.transform8x8ModeFlag, "PPS: transform_8x8_mode_flag");
            CAVLCWriter.writeBool(writer, this.extended.scalingMatrix != null, "PPS: scalindMatrix");
            if (this.extended.scalingMatrix != null) {
                for (var i = 0; i < 6 + 2 * (this.extended.transform8x8ModeFlag ? 1 : 0); i++) {
                    CAVLCWriter.writeBool(writer, this.extended.scalingMatrix[i] != null, "PPS: ");
                    if (this.extended.scalingMatrix[i] != null) {
                        SeqParameterSet.writeScalingList(writer, this.extended.scalingMatrix, i);
                    }
                }
            }
            CAVLCWriter.writeSEtrace(writer, this.extended.secondChromaQpIndexOffset, "PPS: ");
        }
        CAVLCWriter.writeTrailingBits(writer);
    };
    prototype.hashCode = function() {
        var prime = 31;
        var result = 1;
        result = prime * result + Arrays.hashCode(this.bottomRight);
        result = prime * result + this.chromaQpIndexOffset;
        result = prime * result + (this.constrainedIntraPredFlag ? 1231 : 1237);
        result = prime * result + (this.deblockingFilterControlPresentFlag ? 1231 : 1237);
        result = prime * result + (this.entropyCodingModeFlag ? 1231 : 1237);
        result = prime * result + ((this.extended == null) ? 0 : this.extended.hashCode());
        result = prime * result + this.numRefIdxActiveMinus1[0];
        result = prime * result + this.numRefIdxActiveMinus1[1];
        result = prime * result + this.numSliceGroupsMinus1;
        result = prime * result + this.picInitQpMinus26;
        result = prime * result + this.picInitQsMinus26;
        result = prime * result + (this.picOrderPresentFlag ? 1231 : 1237);
        result = prime * result + this.picParameterSetId;
        result = prime * result + (this.redundantPicCntPresentFlag ? 1231 : 1237);
        result = prime * result + Arrays.hashCode(this.runLengthMinus1);
        result = prime * result + this.seqParameterSetId;
        result = prime * result + (this.sliceGroupChangeDirectionFlag ? 1231 : 1237);
        result = prime * result + this.sliceGroupChangeRateMinus1;
        result = prime * result + Arrays.hashCode(this.sliceGroupId);
        result = prime * result + this.sliceGroupMapType;
        result = prime * result + Arrays.hashCode(this.topLeft);
        result = prime * result + this.weightedBipredIdc;
        result = prime * result + (this.weightedPredFlag ? 1231 : 1237);
        return result;
    };
    prototype.equals = function(obj) {
        if (this == obj) 
            return true;
        if (obj == null) 
            return false;
        if (this.getClass() != obj.getClass()) 
            return false;
        var other = obj;
        if (!Platform.arrayEqualsInt(this.bottomRight, other.bottomRight)) 
            return false;
        if (this.chromaQpIndexOffset != other.chromaQpIndexOffset) 
            return false;
        if (this.constrainedIntraPredFlag != other.constrainedIntraPredFlag) 
            return false;
        if (this.deblockingFilterControlPresentFlag != other.deblockingFilterControlPresentFlag) 
            return false;
        if (this.entropyCodingModeFlag != other.entropyCodingModeFlag) 
            return false;
        if (this.extended == null) {
            if (other.extended != null) 
                return false;
        } else if (!this.extended.equals(other.extended)) 
            return false;
        if (this.numRefIdxActiveMinus1[0] != other.numRefIdxActiveMinus1[0]) 
            return false;
        if (this.numRefIdxActiveMinus1[1] != other.numRefIdxActiveMinus1[1]) 
            return false;
        if (this.numSliceGroupsMinus1 != other.numSliceGroupsMinus1) 
            return false;
        if (this.picInitQpMinus26 != other.picInitQpMinus26) 
            return false;
        if (this.picInitQsMinus26 != other.picInitQsMinus26) 
            return false;
        if (this.picOrderPresentFlag != other.picOrderPresentFlag) 
            return false;
        if (this.picParameterSetId != other.picParameterSetId) 
            return false;
        if (this.redundantPicCntPresentFlag != other.redundantPicCntPresentFlag) 
            return false;
        if (!Platform.arrayEqualsInt(this.runLengthMinus1, other.runLengthMinus1)) 
            return false;
        if (this.seqParameterSetId != other.seqParameterSetId) 
            return false;
        if (this.sliceGroupChangeDirectionFlag != other.sliceGroupChangeDirectionFlag) 
            return false;
        if (this.sliceGroupChangeRateMinus1 != other.sliceGroupChangeRateMinus1) 
            return false;
        if (!Platform.arrayEqualsInt(this.sliceGroupId, other.sliceGroupId)) 
            return false;
        if (this.sliceGroupMapType != other.sliceGroupMapType) 
            return false;
        if (!Platform.arrayEqualsInt(this.topLeft, other.topLeft)) 
            return false;
        if (this.weightedBipredIdc != other.weightedBipredIdc) 
            return false;
        if (this.weightedPredFlag != other.weightedPredFlag) 
            return false;
        return true;
    };
    prototype.copy = function() {
        var buf = ByteBuffer.allocate(2048);
        this.write(buf);
        buf.flip();
        return PictureParameterSet.read(buf);
    };
    prototype.isEntropyCodingModeFlag = function() {
        return this.entropyCodingModeFlag;
    };
    prototype.getNumRefIdxActiveMinus1 = function() {
        return this.numRefIdxActiveMinus1;
    };
    prototype.getSliceGroupChangeRateMinus1 = function() {
        return this.sliceGroupChangeRateMinus1;
    };
    prototype.getPicParameterSetId = function() {
        return this.picParameterSetId;
    };
    prototype.getSeqParameterSetId = function() {
        return this.seqParameterSetId;
    };
    prototype.isPicOrderPresentFlag = function() {
        return this.picOrderPresentFlag;
    };
    prototype.getNumSliceGroupsMinus1 = function() {
        return this.numSliceGroupsMinus1;
    };
    prototype.getSliceGroupMapType = function() {
        return this.sliceGroupMapType;
    };
    prototype.isWeightedPredFlag = function() {
        return this.weightedPredFlag;
    };
    prototype.getWeightedBipredIdc = function() {
        return this.weightedBipredIdc;
    };
    prototype.getPicInitQpMinus26 = function() {
        return this.picInitQpMinus26;
    };
    prototype.getPicInitQsMinus26 = function() {
        return this.picInitQsMinus26;
    };
    prototype.getChromaQpIndexOffset = function() {
        return this.chromaQpIndexOffset;
    };
    prototype.isDeblockingFilterControlPresentFlag = function() {
        return this.deblockingFilterControlPresentFlag;
    };
    prototype.isConstrainedIntraPredFlag = function() {
        return this.constrainedIntraPredFlag;
    };
    prototype.isRedundantPicCntPresentFlag = function() {
        return this.redundantPicCntPresentFlag;
    };
    prototype.getTopLeft = function() {
        return this.topLeft;
    };
    prototype.getBottomRight = function() {
        return this.bottomRight;
    };
    prototype.getRunLengthMinus1 = function() {
        return this.runLengthMinus1;
    };
    prototype.isSliceGroupChangeDirectionFlag = function() {
        return this.sliceGroupChangeDirectionFlag;
    };
    prototype.getSliceGroupId = function() {
        return this.sliceGroupId;
    };
    prototype.getExtended = function() {
        return this.extended;
    };
}, {numRefIdxActiveMinus1: "Int32Array", topLeft: "Int32Array", bottomRight: "Int32Array", runLengthMinus1: "Int32Array", sliceGroupId: "Int32Array", extended: "PictureParameterSet.PPSExt"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Reads header of the coded slice
 *  
 *  @author The JCodec project
 *  
 */
var SliceHeaderReader = function() {};
SliceHeaderReader = stjs.extend(SliceHeaderReader, null, [], function(constructor, prototype) {
    constructor.readPart1 = function(_in) {
        var sh = new SliceHeader();
        sh.firstMbInSlice = CAVLCReader.readUEtrace(_in, "SH: first_mb_in_slice");
        var shType = CAVLCReader.readUEtrace(_in, "SH: slice_type");
        sh.sliceType = SliceType.fromValue(shType % 5);
        sh.sliceTypeRestr = (stjs.trunc(shType / 5)) > 0;
        sh.picParameterSetId = CAVLCReader.readUEtrace(_in, "SH: pic_parameter_set_id");
        return sh;
    };
    constructor.readPart2 = function(sh, nalUnit, sps, pps, _in) {
        sh.pps = pps;
        sh.sps = sps;
        sh.frameNum = CAVLCReader.readU(_in, sps.log2MaxFrameNumMinus4 + 4, "SH: frame_num");
        if (!sps.frameMbsOnlyFlag) {
            sh.fieldPicFlag = CAVLCReader.readBool(_in, "SH: field_pic_flag");
            if (sh.fieldPicFlag) {
                sh.bottomFieldFlag = CAVLCReader.readBool(_in, "SH: bottom_field_flag");
            }
        }
        if (nalUnit.type == NALUnitType.IDR_SLICE) {
            sh.idrPicId = CAVLCReader.readUEtrace(_in, "SH: idr_pic_id");
        }
        if (sps.picOrderCntType == 0) {
            sh.picOrderCntLsb = CAVLCReader.readU(_in, sps.log2MaxPicOrderCntLsbMinus4 + 4, "SH: pic_order_cnt_lsb");
            if (pps.picOrderPresentFlag && !sps.fieldPicFlag) {
                sh.deltaPicOrderCntBottom = CAVLCReader.readSE(_in, "SH: delta_pic_order_cnt_bottom");
            }
        }
        sh.deltaPicOrderCnt = new Int32Array(2);
        if (sps.picOrderCntType == 1 && !sps.deltaPicOrderAlwaysZeroFlag) {
            sh.deltaPicOrderCnt[0] = CAVLCReader.readSE(_in, "SH: delta_pic_order_cnt[0]");
            if (pps.picOrderPresentFlag && !sps.fieldPicFlag) 
                sh.deltaPicOrderCnt[1] = CAVLCReader.readSE(_in, "SH: delta_pic_order_cnt[1]");
        }
        if (pps.redundantPicCntPresentFlag) {
            sh.redundantPicCnt = CAVLCReader.readUEtrace(_in, "SH: redundant_pic_cnt");
        }
        if (sh.sliceType == SliceType.B) {
            sh.directSpatialMvPredFlag = CAVLCReader.readBool(_in, "SH: direct_spatial_mv_pred_flag");
        }
        if (sh.sliceType == SliceType.P || sh.sliceType == SliceType.SP || sh.sliceType == SliceType.B) {
            sh.numRefIdxActiveOverrideFlag = CAVLCReader.readBool(_in, "SH: num_ref_idx_active_override_flag");
            if (sh.numRefIdxActiveOverrideFlag) {
                sh.numRefIdxActiveMinus1[0] = CAVLCReader.readUEtrace(_in, "SH: num_ref_idx_l0_active_minus1");
                if (sh.sliceType == SliceType.B) {
                    sh.numRefIdxActiveMinus1[1] = CAVLCReader.readUEtrace(_in, "SH: num_ref_idx_l1_active_minus1");
                }
            }
        }
        SliceHeaderReader.readRefPicListReordering(sh, _in);
        if ((pps.weightedPredFlag && (sh.sliceType == SliceType.P || sh.sliceType == SliceType.SP)) || (pps.weightedBipredIdc == 1 && sh.sliceType == SliceType.B)) 
            SliceHeaderReader.readPredWeightTable(sps, pps, sh, _in);
        if (nalUnit.nal_ref_idc != 0) 
            SliceHeaderReader.readDecoderPicMarking(nalUnit, sh, _in);
        if (pps.entropyCodingModeFlag && sh.sliceType.isInter()) {
            sh.cabacInitIdc = CAVLCReader.readUEtrace(_in, "SH: cabac_init_idc");
        }
        sh.sliceQpDelta = CAVLCReader.readSE(_in, "SH: slice_qp_delta");
        if (sh.sliceType == SliceType.SP || sh.sliceType == SliceType.SI) {
            if (sh.sliceType == SliceType.SP) {
                sh.spForSwitchFlag = CAVLCReader.readBool(_in, "SH: sp_for_switch_flag");
            }
            sh.sliceQsDelta = CAVLCReader.readSE(_in, "SH: slice_qs_delta");
        }
        if (pps.deblockingFilterControlPresentFlag) {
            sh.disableDeblockingFilterIdc = CAVLCReader.readUEtrace(_in, "SH: disable_deblocking_filter_idc");
            if (sh.disableDeblockingFilterIdc != 1) {
                sh.sliceAlphaC0OffsetDiv2 = CAVLCReader.readSE(_in, "SH: slice_alpha_c0_offset_div2");
                sh.sliceBetaOffsetDiv2 = CAVLCReader.readSE(_in, "SH: slice_beta_offset_div2");
            }
        }
        if (pps.numSliceGroupsMinus1 > 0 && pps.sliceGroupMapType >= 3 && pps.sliceGroupMapType <= 5) {
            var len = stjs.trunc(SeqParameterSet.getPicHeightInMbs(sps) * (sps.picWidthInMbsMinus1 + 1) / (pps.sliceGroupChangeRateMinus1 + 1));
            if ((SeqParameterSet.getPicHeightInMbs(sps) * (sps.picWidthInMbsMinus1 + 1)) % (pps.sliceGroupChangeRateMinus1 + 1) > 0) 
                len += 1;
            len = SliceHeaderReader.CeilLog2(len + 1);
            sh.sliceGroupChangeCycle = CAVLCReader.readU(_in, len, "SH: slice_group_change_cycle");
        }
        return sh;
    };
    constructor.CeilLog2 = function(uiVal) {
        var uiTmp = uiVal - 1;
        var uiRet = 0;
         while (uiTmp != 0){
            uiTmp >>= 1;
            uiRet++;
        }
        return uiRet;
    };
    constructor.readDecoderPicMarking = function(nalUnit, sh, _in) {
        if (nalUnit.type == NALUnitType.IDR_SLICE) {
            var noOutputOfPriorPicsFlag = CAVLCReader.readBool(_in, "SH: no_output_of_prior_pics_flag");
            var longTermReferenceFlag = CAVLCReader.readBool(_in, "SH: long_term_reference_flag");
            sh.refPicMarkingIDR = new RefPicMarkingIDR(noOutputOfPriorPicsFlag, longTermReferenceFlag);
        } else {
            var adaptiveRefPicMarkingModeFlag = CAVLCReader.readBool(_in, "SH: adaptive_ref_pic_marking_mode_flag");
            if (adaptiveRefPicMarkingModeFlag) {
                var mmops = new ArrayList();
                var memoryManagementControlOperation;
                do {
                    memoryManagementControlOperation = CAVLCReader.readUEtrace(_in, "SH: memory_management_control_operation");
                    var instr = null;
                    switch (memoryManagementControlOperation) {
                        case 1:
                            instr = new RefPicMarking.Instruction(RefPicMarking.InstrType.REMOVE_SHORT, CAVLCReader.readUEtrace(_in, "SH: difference_of_pic_nums_minus1") + 1, 0);
                            break;
                        case 2:
                            instr = new RefPicMarking.Instruction(RefPicMarking.InstrType.REMOVE_LONG, CAVLCReader.readUEtrace(_in, "SH: long_term_pic_num"), 0);
                            break;
                        case 3:
                            instr = new RefPicMarking.Instruction(RefPicMarking.InstrType.CONVERT_INTO_LONG, CAVLCReader.readUEtrace(_in, "SH: difference_of_pic_nums_minus1") + 1, CAVLCReader.readUEtrace(_in, "SH: long_term_frame_idx"));
                            break;
                        case 4:
                            instr = new RefPicMarking.Instruction(RefPicMarking.InstrType.TRUNK_LONG, CAVLCReader.readUEtrace(_in, "SH: max_long_term_frame_idx_plus1") - 1, 0);
                            break;
                        case 5:
                            instr = new RefPicMarking.Instruction(RefPicMarking.InstrType.CLEAR, 0, 0);
                            break;
                        case 6:
                            instr = new RefPicMarking.Instruction(RefPicMarking.InstrType.MARK_LONG, CAVLCReader.readUEtrace(_in, "SH: long_term_frame_idx"), 0);
                            break;
                    }
                    if (instr != null) 
                        mmops.add(instr);
                } while (memoryManagementControlOperation != 0);
                sh.refPicMarkingNonIDR = new RefPicMarking(mmops.toArray([]));
            }
        }
    };
    constructor.readPredWeightTable = function(sps, pps, sh, _in) {
        sh.predWeightTable = new PredictionWeightTable();
        var numRefsMinus1 = sh.numRefIdxActiveOverrideFlag ? sh.numRefIdxActiveMinus1 : pps.numRefIdxActiveMinus1;
        var nr = new Int32Array([numRefsMinus1[0] + 1, numRefsMinus1[1] + 1]);
        sh.predWeightTable.lumaLog2WeightDenom = CAVLCReader.readUEtrace(_in, "SH: luma_log2_weight_denom");
        if (sps.chromaFormatIdc != ColorSpace.MONO) {
            sh.predWeightTable.chromaLog2WeightDenom = CAVLCReader.readUEtrace(_in, "SH: chroma_log2_weight_denom");
        }
        var defaultLW = 1 << sh.predWeightTable.lumaLog2WeightDenom;
        var defaultCW = 1 << sh.predWeightTable.chromaLog2WeightDenom;
        for (var list = 0; list < 2; list++) {
            sh.predWeightTable.lumaWeight[list] = new Int32Array(nr[list]);
            sh.predWeightTable.lumaOffset[list] = new Int32Array(nr[list]);
            sh.predWeightTable.chromaWeight[list] = Array.apply(null, Array(2)).map(function() {
                return new Int32Array(nr[list]);
            });
            sh.predWeightTable.chromaOffset[list] = Array.apply(null, Array(2)).map(function() {
                return new Int32Array(nr[list]);
            });
            for (var i = 0; i < nr[list]; i++) {
                sh.predWeightTable.lumaWeight[list][i] = defaultLW;
                sh.predWeightTable.lumaOffset[list][i] = 0;
                sh.predWeightTable.chromaWeight[list][0][i] = defaultCW;
                sh.predWeightTable.chromaOffset[list][0][i] = 0;
                sh.predWeightTable.chromaWeight[list][1][i] = defaultCW;
                sh.predWeightTable.chromaOffset[list][1][i] = 0;
            }
        }
        SliceHeaderReader.readWeightOffset(sps, pps, sh, _in, nr, 0);
        if (sh.sliceType == SliceType.B) {
            SliceHeaderReader.readWeightOffset(sps, pps, sh, _in, nr, 1);
        }
    };
    constructor.readWeightOffset = function(sps, pps, sh, _in, numRefs, list) {
        for (var i = 0; i < numRefs[list]; i++) {
            var lumaWeightL0Flag = CAVLCReader.readBool(_in, "SH: luma_weight_l0_flag");
            if (lumaWeightL0Flag) {
                sh.predWeightTable.lumaWeight[list][i] = CAVLCReader.readSE(_in, "SH: weight");
                sh.predWeightTable.lumaOffset[list][i] = CAVLCReader.readSE(_in, "SH: offset");
            }
            if (sps.chromaFormatIdc != ColorSpace.MONO) {
                var chromaWeightL0Flag = CAVLCReader.readBool(_in, "SH: chroma_weight_l0_flag");
                if (chromaWeightL0Flag) {
                    sh.predWeightTable.chromaWeight[list][0][i] = CAVLCReader.readSE(_in, "SH: weight");
                    sh.predWeightTable.chromaOffset[list][0][i] = CAVLCReader.readSE(_in, "SH: offset");
                    sh.predWeightTable.chromaWeight[list][1][i] = CAVLCReader.readSE(_in, "SH: weight");
                    sh.predWeightTable.chromaOffset[list][1][i] = CAVLCReader.readSE(_in, "SH: offset");
                }
            }
        }
    };
    constructor.readRefPicListReordering = function(sh, _in) {
        sh.refPicReordering = Array(2);
        if (sh.sliceType.isInter()) {
            var refPicListReorderingFlagL0 = CAVLCReader.readBool(_in, "SH: ref_pic_list_reordering_flag_l0");
            if (refPicListReorderingFlagL0) {
                sh.refPicReordering[0] = SliceHeaderReader.readReorderingEntries(_in);
            }
        }
        if (sh.sliceType == SliceType.B) {
            var refPicListReorderingFlagL1 = CAVLCReader.readBool(_in, "SH: ref_pic_list_reordering_flag_l1");
            if (refPicListReorderingFlagL1) {
                sh.refPicReordering[1] = SliceHeaderReader.readReorderingEntries(_in);
            }
        }
    };
    constructor.readReorderingEntries = function(_in) {
        var ops = IntArrayList.createIntArrayList();
        var args = IntArrayList.createIntArrayList();
        do {
            var idc = CAVLCReader.readUEtrace(_in, "SH: reordering_of_pic_nums_idc");
            if (idc == 3) 
                break;
            ops.add(idc);
            args.add(CAVLCReader.readUEtrace(_in, "SH: abs_diff_pic_num_minus1"));
        } while (true);
        return [ops.toArray(), args.toArray()];
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MapManager = function(sps, pps) {
    this.sps = sps;
    this.pps = pps;
    this.mbToSliceGroupMap = this.buildMap(sps, pps);
};
MapManager = stjs.extend(MapManager, null, [], function(constructor, prototype) {
    prototype.sps = null;
    prototype.pps = null;
    prototype.mbToSliceGroupMap = null;
    prototype.prevSliceGroupChangeCycle = 0;
    prototype.buildMap = function(sps, pps) {
        var numGroups = pps.numSliceGroupsMinus1 + 1;
        if (numGroups > 1) {
            var map;
            var picWidthInMbs = sps.picWidthInMbsMinus1 + 1;
            var picHeightInMbs = SeqParameterSet.getPicHeightInMbs(sps);
            if (pps.sliceGroupMapType == 0) {
                var runLength = new Int32Array(numGroups);
                for (var i = 0; i < numGroups; i++) {
                    runLength[i] = pps.runLengthMinus1[i] + 1;
                }
                map = SliceGroupMapBuilder.buildInterleavedMap(picWidthInMbs, picHeightInMbs, runLength);
            } else if (pps.sliceGroupMapType == 1) {
                map = SliceGroupMapBuilder.buildDispersedMap(picWidthInMbs, picHeightInMbs, numGroups);
            } else if (pps.sliceGroupMapType == 2) {
                map = SliceGroupMapBuilder.buildForegroundMap(picWidthInMbs, picHeightInMbs, numGroups, pps.topLeft, pps.bottomRight);
            } else if (pps.sliceGroupMapType >= 3 && pps.sliceGroupMapType <= 5) {
                return null;
            } else if (pps.sliceGroupMapType == 6) {
                map = pps.sliceGroupId;
            } else {
                 throw new RuntimeException("Unsupported slice group map type");
            }
            return this.buildMapIndices(map, numGroups);
        }
        return null;
    };
    prototype.buildMapIndices = function(map, numGroups) {
        var ind = new Int32Array(numGroups);
        var indices = new Int32Array(map.length);
        for (var i = 0; i < map.length; i++) {
            indices[i] = ind[map[i]]++;
        }
        var inverse = Array(numGroups);
        for (var i = 0; i < numGroups; i++) {
            inverse[i] = new Int32Array(ind[i]);
        }
        ind = new Int32Array(numGroups);
        for (var i = 0; i < map.length; i++) {
            var sliceGroup = map[i];
            inverse[sliceGroup][ind[sliceGroup]++] = i;
        }
        return new MBToSliceGroupMap(map, indices, inverse);
    };
    prototype.updateMap = function(sh) {
        var mapType = this.pps.sliceGroupMapType;
        var numGroups = this.pps.numSliceGroupsMinus1 + 1;
        if (numGroups > 1 && mapType >= 3 && mapType <= 5 && (sh.sliceGroupChangeCycle != this.prevSliceGroupChangeCycle || this.mbToSliceGroupMap == null)) {
            this.prevSliceGroupChangeCycle = sh.sliceGroupChangeCycle;
            var picWidthInMbs = this.sps.picWidthInMbsMinus1 + 1;
            var picHeightInMbs = SeqParameterSet.getPicHeightInMbs(this.sps);
            var picSizeInMapUnits = picWidthInMbs * picHeightInMbs;
            var mapUnitsInSliceGroup0 = sh.sliceGroupChangeCycle * (this.pps.sliceGroupChangeRateMinus1 + 1);
            mapUnitsInSliceGroup0 = mapUnitsInSliceGroup0 > picSizeInMapUnits ? picSizeInMapUnits : mapUnitsInSliceGroup0;
            var sizeOfUpperLeftGroup = (this.pps.sliceGroupChangeDirectionFlag ? (picSizeInMapUnits - mapUnitsInSliceGroup0) : mapUnitsInSliceGroup0);
            var map;
            if (mapType == 3) {
                map = SliceGroupMapBuilder.buildBoxOutMap(picWidthInMbs, picHeightInMbs, this.pps.sliceGroupChangeDirectionFlag, mapUnitsInSliceGroup0);
            } else if (mapType == 4) {
                map = SliceGroupMapBuilder.buildRasterScanMap(picWidthInMbs, picHeightInMbs, sizeOfUpperLeftGroup, this.pps.sliceGroupChangeDirectionFlag);
            } else {
                map = SliceGroupMapBuilder.buildWipeMap(picWidthInMbs, picHeightInMbs, sizeOfUpperLeftGroup, this.pps.sliceGroupChangeDirectionFlag);
            }
            this.mbToSliceGroupMap = this.buildMapIndices(map, numGroups);
        }
    };
    prototype.getMapper = function(sh) {
        this.updateMap(sh);
        var firstMBInSlice = sh.firstMbInSlice;
        if (this.pps.numSliceGroupsMinus1 > 0) {
            return new PrebuiltMBlockMapper(this.mbToSliceGroupMap, firstMBInSlice, this.sps.picWidthInMbsMinus1 + 1);
        } else {
            return new FlatMBlockMapper(this.sps.picWidthInMbsMinus1 + 1, firstMBInSlice);
        }
    };
}, {sps: "SeqParameterSet", pps: "PictureParameterSet", mbToSliceGroupMap: "MBToSliceGroupMap"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SequenceHeader = function() {};
SequenceHeader = stjs.extend(SequenceHeader, null, [MPEGHeader], function(constructor, prototype) {
    constructor._hasExtensions = false;
    prototype.horizontal_size = 0;
    prototype.vertical_size = 0;
    prototype.aspect_ratio_information = 0;
    prototype.frame_rate_code = 0;
    prototype.bit_rate = 0;
    prototype.vbv_buffer_size_value = 0;
    prototype.constrained_parameters_flag = 0;
    prototype.intra_quantiser_matrix = null;
    prototype.non_intra_quantiser_matrix = null;
    prototype.sequenceExtension = null;
    prototype.sequenceScalableExtension = null;
    prototype.sequenceDisplayExtension = null;
    constructor.createSequenceHeader = function(horizontal_size, vertical_size, aspect_ratio_information, frame_rate_code, bit_rate, vbv_buffer_size_value, constrained_parameters_flag, intra_quantiser_matrix, non_intra_quantiser_matrix) {
        var sh = new SequenceHeader();
        sh.horizontal_size = horizontal_size;
        sh.vertical_size = vertical_size;
        sh.aspect_ratio_information = aspect_ratio_information;
        sh.frame_rate_code = frame_rate_code;
        sh.bit_rate = bit_rate;
        sh.vbv_buffer_size_value = vbv_buffer_size_value;
        sh.constrained_parameters_flag = constrained_parameters_flag;
        sh.intra_quantiser_matrix = intra_quantiser_matrix;
        sh.non_intra_quantiser_matrix = non_intra_quantiser_matrix;
        return sh;
    };
    constructor.read = function(bb) {
        var _in = BitReader.createBitReader(bb);
        var sh = new SequenceHeader();
        sh.horizontal_size = _in.readNBit(12);
        sh.vertical_size = _in.readNBit(12);
        sh.aspect_ratio_information = _in.readNBit(4);
        sh.frame_rate_code = _in.readNBit(4);
        sh.bit_rate = _in.readNBit(18);
        _in.read1Bit();
        sh.vbv_buffer_size_value = _in.readNBit(10);
        sh.constrained_parameters_flag = _in.read1Bit();
        if (_in.read1Bit() != 0) {
            sh.intra_quantiser_matrix = new Int32Array(64);
            for (var i = 0; i < 64; i++) {
                sh.intra_quantiser_matrix[i] = _in.readNBit(8);
            }
        }
        if (_in.read1Bit() != 0) {
            sh.non_intra_quantiser_matrix = new Int32Array(64);
            for (var i = 0; i < 64; i++) {
                sh.non_intra_quantiser_matrix[i] = _in.readNBit(8);
            }
        }
        return sh;
    };
    constructor.readExtension = function(bb, sh) {
        SequenceHeader._hasExtensions = true;
        var _in = BitReader.createBitReader(bb);
        var extType = _in.readNBit(4);
        switch (extType) {
            case SequenceExtension.Sequence_Extension:
                sh.sequenceExtension = SequenceExtension.read(_in);
                break;
            case SequenceScalableExtension.Sequence_Scalable_Extension:
                sh.sequenceScalableExtension = SequenceScalableExtension.read(_in);
                break;
            case SequenceDisplayExtension.Sequence_Display_Extension:
                sh.sequenceDisplayExtension = SequenceDisplayExtension.read(_in);
                break;
            default:
                 throw new RuntimeException("Unsupported extension: " + extType);
        }
    };
    prototype.write = function(bb) {
        var bw = new BitWriter(bb);
        bw.writeNBit(this.horizontal_size, 12);
        bw.writeNBit(this.vertical_size, 12);
        bw.writeNBit(this.aspect_ratio_information, 4);
        bw.writeNBit(this.frame_rate_code, 4);
        bw.writeNBit(this.bit_rate, 18);
        bw.write1Bit(1);
        bw.writeNBit(this.vbv_buffer_size_value, 10);
        bw.write1Bit(this.constrained_parameters_flag);
        bw.write1Bit(this.intra_quantiser_matrix != null ? 1 : 0);
        if (this.intra_quantiser_matrix != null) {
            for (var i = 0; i < 64; i++) {
                bw.writeNBit(this.intra_quantiser_matrix[i], 8);
            }
        }
        bw.write1Bit(this.non_intra_quantiser_matrix != null ? 1 : 0);
        if (this.non_intra_quantiser_matrix != null) {
            for (var i = 0; i < 64; i++) {
                bw.writeNBit(this.non_intra_quantiser_matrix[i], 8);
            }
        }
        bw.flush();
        this.writeExtensions(bb);
    };
    prototype.writeExtensions = function(out) {
        if (this.sequenceExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.sequenceExtension.write(out);
        }
        if (this.sequenceScalableExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.sequenceScalableExtension.write(out);
        }
        if (this.sequenceDisplayExtension != null) {
            out.putInt(MPEGConst.EXTENSION_START_CODE);
            this.sequenceDisplayExtension.write(out);
        }
    };
    prototype.hasExtensions = function() {
        return SequenceHeader._hasExtensions;
    };
    prototype.copyExtensions = function(sh) {
        this.sequenceExtension = sh.sequenceExtension;
        this.sequenceScalableExtension = sh.sequenceScalableExtension;
        this.sequenceDisplayExtension = sh.sequenceDisplayExtension;
    };
}, {intra_quantiser_matrix: "Int32Array", non_intra_quantiser_matrix: "Int32Array", sequenceExtension: "SequenceExtension", sequenceScalableExtension: "SequenceScalableExtension", sequenceDisplayExtension: "SequenceDisplayExtension"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 1/2 decoder interframe motion compensation routines, octal interpolation
 *  
 *  @author The JCodec project
 *  
 */
var MPEGPredOct = function(other) {
    MPEGPred.call(this, other.fCode, other.chromaFormat, other.topFieldFirst);
    this.tmp = new Int32Array(16 * 21);
};
MPEGPredOct = stjs.extend(MPEGPredOct, MPEGPred, [], function(constructor, prototype) {
    prototype.tmp = null;
    constructor.COEFF = [new Int32Array([0, 0, 128, 0, 0, 0]), new Int32Array([0, -6, 123, 12, -1, 0]), new Int32Array([2, -11, 108, 36, -8, 1]), new Int32Array([0, -9, 93, 50, -6, 0]), new Int32Array([3, -16, 77, 77, -16, 3]), new Int32Array([0, -6, 50, 93, -9, 0]), new Int32Array([1, -8, 36, 108, -11, 2]), new Int32Array([0, -1, 12, 123, -6, 0])];
    prototype.predictPlane = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var rx = refX >> 3, ry = refY >> 3;
        tgtW >>= 3;
        tgtH >>= 3;
        var safe = rx >= 2 && ry >= 2 && rx + tgtW + 3 < refW && ((ry + tgtH + 3) << refVertStep) < refH;
        if ((refX & 7) == 0) {
            if ((refY & 7) == 0) {
                if (safe) 
                    this.predictFullXFullYSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
                 else 
                    this.predictFullXFullYUnSafe(ref, rx, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
            } else {
                if (safe) 
                    this.predictFullXSubYSafe(ref, rx, ry, refY & 7, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
                 else 
                    this.predictFullXSubYUnSafe(ref, rx, ry, refY & 7, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
            }
        } else if ((refY & 7) == 0) {
            if (safe) 
                this.predictSubXFullYSafe(ref, rx, refX & 7, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
             else 
                this.predictSubXFullYUnSafe(ref, rx, refX & 7, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
        } else {
            if (safe) 
                this.predictSubXSubYSafe(ref, rx, refX & 7, ry, refY & 7, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
             else 
                this.predictSubXSubYUnSafe(ref, rx, refX & 7, ry, refY & 7, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep);
        }
    };
    prototype.getPix6 = function(ref, refW, refH, x, y, refVertStep, refVertOff, coeff) {
        var lastLine = refH - (1 << refVertStep) + refVertOff;
        var x0 = MathUtil.clip(x - 2, 0, refW - 1);
        var x1 = MathUtil.clip(x - 1, 0, refW - 1);
        var x2 = MathUtil.clip(x, 0, refW - 1);
        var x3 = MathUtil.clip(x + 1, 0, refW - 1);
        var x4 = MathUtil.clip(x + 2, 0, refW - 1);
        var x5 = MathUtil.clip(x + 3, 0, refW - 1);
        var off = MathUtil.clip(y, refVertOff, lastLine) * refW;
        return ref[off + x0] * coeff[0] + ref[off + x1] * coeff[1] + ref[off + x2] * coeff[2] + ref[off + x3] * coeff[3] + ref[off + x4] * coeff[4] + ref[off + x5] * coeff[5] + 16384;
    };
    prototype.getPix6Vert = function(ref, refW, refH, x, y, refVertStep, refVertOff, coeff) {
        var lastLine = refH - (1 << refVertStep) + refVertOff;
        var y0 = MathUtil.clip(y - (2 << refVertStep), refVertOff, lastLine);
        var y1 = MathUtil.clip(y - (1 << refVertStep), refVertOff, lastLine);
        var y2 = MathUtil.clip(y, 0, lastLine);
        var y3 = MathUtil.clip(y + (1 << refVertStep), refVertOff, lastLine);
        var y4 = MathUtil.clip(y + (2 << refVertStep), refVertOff, lastLine);
        var y5 = MathUtil.clip(y + (3 << refVertStep), refVertOff, lastLine);
        x = MathUtil.clip(x, 0, refW - 1);
        return ref[y0 * refW + x] * coeff[0] + ref[y1 * refW + x] * coeff[1] + ref[y2 * refW + x] * coeff[2] + ref[y3 * refW + x] * coeff[3] + ref[y4 * refW + x] * coeff[4] + ref[y5 * refW + x] * coeff[5] + 16384;
    };
    prototype.predictSubXSubYUnSafe = function(ref, rx, ix, ry, iy, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var offTgt = tgtW * tgtY;
        var dblTgtW = tgtW << 1;
        var tripleTgtW = dblTgtW + tgtW;
        var lfTgt = tgtVertStep * tgtW;
        var coeff = MPEGPredOct.COEFF[ix];
        for (var i = -2, offTmp = 0; i < tgtH + 3; i++) {
            var y = ((i + ry) << refVertStep) + refVertOff;
            for (var j = 0; j < tgtW; j++ , ++offTmp) {
                this.tmp[offTmp] = this.getPix6(ref, refW, refH, j + rx, y, refVertStep, refVertOff, coeff);
            }
        }
        coeff = MPEGPredOct.COEFF[iy];
        for (var i = 0, offTmp = dblTgtW; i < tgtH; i++) {
            for (var j = 0; j < tgtW; j++ , ++offTmp , ++offTgt) {
                tgt[offTgt] = (this.tmp[offTmp - dblTgtW] * coeff[0] + this.tmp[offTmp - tgtW] * coeff[1] + this.tmp[offTmp] * coeff[2] + this.tmp[offTmp + tgtW] * coeff[3] + this.tmp[offTmp + dblTgtW] * coeff[4] + this.tmp[offTmp + tripleTgtW] * coeff[5] + 8192) >> 14;
            }
            offTgt += lfTgt;
        }
    };
    prototype.predictSubXSubYSafe = function(ref, rx, ix, ry, iy, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var coeff = MPEGPredOct.COEFF[ix];
        var offRef = (((ry - 2) << refVertStep) + refVertOff) * refW + rx;
        var offTgt = tgtW * tgtY;
        var lfRef = (refW << refVertStep) - tgtW;
        var lfTgt = tgtVertStep * tgtW;
        var dblTgtW = tgtW << 1;
        var tripleTgtW = dblTgtW + tgtW;
        for (var i = 0, offTmp = 0; i < tgtH + 5; i++) {
            for (var j = 0; j < tgtW; j++ , ++offTmp , ++offRef) {
                this.tmp[offTmp] = ref[offRef - 2] * coeff[0] + ref[offRef - 1] * coeff[1] + ref[offRef] * coeff[2] + ref[offRef + 1] * coeff[3] + ref[offRef + 2] * coeff[4] + ref[offRef + 3] * coeff[5];
            }
            offRef += lfRef;
        }
        coeff = MPEGPredOct.COEFF[iy];
        for (var i = 0, offTmp = dblTgtW; i < tgtH; i++) {
            for (var j = 0; j < tgtW; j++ , ++offTmp , ++offTgt) {
                tgt[offTgt] = ((this.tmp[offTmp - dblTgtW] * coeff[0] + this.tmp[offTmp - tgtW] * coeff[1] + this.tmp[offTmp] * coeff[2] + this.tmp[offTmp + tgtW] * coeff[3] + this.tmp[offTmp + dblTgtW] * coeff[4] + this.tmp[offTmp + tripleTgtW] * coeff[5] + 8192) >> 14) + 128;
            }
            offTgt += lfTgt;
        }
    };
    prototype.predictSubXFullYUnSafe = function(ref, rx, ix, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var coeff = MPEGPredOct.COEFF[ix];
        var tgtOff = tgtW * tgtY;
        var lfTgt = tgtVertStep * tgtW;
        for (var i = 0; i < tgtH; i++) {
            var y = ((i + ry) << refVertStep) + refVertOff;
            for (var j = 0; j < tgtW; j++) {
                tgt[tgtOff++] = (this.getPix6(ref, refW, refH, j + rx, y, refVertStep, refVertOff, coeff) + 64) >> 7;
            }
            tgtOff += lfTgt;
        }
    };
    prototype.predictSubXFullYSafe = function(ref, rx, ix, ry, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var coeff = MPEGPredOct.COEFF[ix];
        var offRef = ((ry << refVertStep) + refVertOff) * refW + rx;
        var offTgt = tgtW * tgtY;
        var lfRef = (refW << refVertStep) - tgtW;
        var lfTgt = tgtVertStep * tgtW;
        for (var i = 0; i < tgtH; i++) {
            for (var j = 0; j < tgtW; j++ , ++offRef) {
                tgt[offTgt++] = ((ref[offRef - 2] * coeff[0] + ref[offRef - 1] * coeff[1] + ref[offRef] * coeff[2] + ref[offRef + 1] * coeff[3] + ref[offRef + 2] * coeff[4] + ref[offRef + 3] * coeff[5] + 64) >> 7) + 128;
            }
            offRef += lfRef;
            offTgt += lfTgt;
        }
    };
    prototype.predictFullXSubYUnSafe = function(ref, rx, ry, iy, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var coeff = MPEGPredOct.COEFF[iy];
        var tgtOff = tgtW * tgtY;
        var lfTgt = tgtVertStep * tgtW;
        for (var i = 0; i < tgtH; i++) {
            var y = ((i + ry) << refVertStep) + refVertOff;
            for (var j = 0; j < tgtW; j++) {
                tgt[tgtOff++] = (this.getPix6Vert(ref, refW, refH, j + rx, y, refVertStep, refVertOff, coeff) + 64) >> 7;
            }
            tgtOff += lfTgt;
        }
    };
    prototype.predictFullXSubYSafe = function(ref, rx, ry, iy, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        var coeff = MPEGPredOct.COEFF[iy];
        var offTgt = tgtW * tgtY;
        var offRef = ((ry << refVertStep) + refVertOff) * refW + rx;
        var singleRefW = refW << refVertStep;
        var dblRefW = refW << (1 + refVertStep);
        var tripleRefW = dblRefW + singleRefW;
        var lfTgt = tgtVertStep * tgtW;
        var lfRef = (refW << refVertStep) - tgtW;
        for (var i = 0; i < tgtH; i++) {
            for (var j = 0; j < tgtW; ++j , ++offTgt , ++offRef) {
                tgt[offTgt] = ((ref[offRef - dblRefW] * coeff[0] + ref[offRef - singleRefW] * coeff[1] + ref[offRef] * coeff[2] + ref[offRef + singleRefW] * coeff[3] + ref[offRef + dblRefW] * coeff[4] + ref[offRef + tripleRefW] * coeff[5] + 64) >> 7) + 128;
            }
            offRef += lfRef;
            offTgt += lfTgt;
        }
    };
}, {tmp: "Int32Array", COEFF: "Array", mvPred: "Array", fCode: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var DSE = function() {
    Element.call(this);
};
DSE = stjs.extend(DSE, Element, [], function(constructor, prototype) {
    prototype.dataStreamBytes = null;
    prototype.decode = function(_in) {
        var byteAlign = _in.readBool();
        var count = _in.readBits(8);
        if (count == 255) 
            count += _in.readBits(8);
        if (byteAlign) 
            _in.byteAlign();
        this.dataStreamBytes = new Int8Array(count);
        for (var i = 0; i < count; i++) {
            this.dataStreamBytes[i] = (_in.readBits(8) << 24 >> 24);
        }
    };
}, {dataStreamBytes: "Int8Array", sbr: "SBR"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Represents index for MPEG TS stream, enables demuxers to do precise seek
 *  
 *  Note: some values inside the MPSIndex are not expressed in bytes anymore, but
 *  rather in integral MPEG TS packets.
 *  
 *  @author The JCodec project
 *  
 */
var MTSIndex = function(programs) {
    this.programs = programs;
};
MTSIndex = stjs.extend(MTSIndex, null, [], function(constructor, prototype) {
    prototype.programs = null;
    constructor.createMTSProgram = function(mpsIndex, target) {
        var m = new MTSIndex.MTSProgram(mpsIndex.pesTokens, mpsIndex.pesStreamIds, mpsIndex.streams, target);
        return m;
    };
    constructor.MTSProgram = function(pesTokens, pesStreamIds, streams, targetGuid) {
        MPSIndex.call(this, pesTokens, pesStreamIds, streams);
        this.targetGuid = targetGuid;
    };
    constructor.MTSProgram = stjs.extend(constructor.MTSProgram, MPSIndex, [], function(constructor, prototype) {
        prototype.targetGuid = 0;
        prototype.getTargetGuid = function() {
            return this.targetGuid;
        };
        prototype.serializeTo = function(index) {
            index.putInt(this.targetGuid);
            MPSIndex.prototype.serializeTo.call(this, index);
        };
        constructor.parse = function(read) {
            var targetGuid = read.getInt();
            return MTSIndex.createMTSProgram(MPSIndex.parseIndex(read), targetGuid);
        };
    }, {pesTokens: "Array", pesStreamIds: "RunLength.Integer", streams: "Array"}, {});
    prototype.getPrograms = function() {
        return this.programs;
    };
    constructor.parse = function(buf) {
        var numPrograms = buf.getInt();
        var programs = Array(numPrograms);
        for (var i = 0; i < numPrograms; i++) {
            var programDataSize = buf.getInt();
            programs[i] = MTSIndex.MTSProgram.parse(NIOUtils.read(buf, programDataSize));
        }
        return new MTSIndex(programs);
    };
    prototype.estimateSize = function() {
        var totalSize = 64;
        for (var index$mtsProgram = 0, arr$mtsProgram = this.programs; index$mtsProgram < arr$mtsProgram.length; index$mtsProgram++) {
            var mtsProgram = arr$mtsProgram[index$mtsProgram];
            totalSize += 4 + mtsProgram.estimateSize();
        }
        return totalSize;
    };
    prototype.serializeTo = function(buf) {
        buf.putInt(this.programs.length);
        for (var index$mtsAnalyser = 0, arr$mtsAnalyser = this.programs; index$mtsAnalyser < arr$mtsAnalyser.length; index$mtsAnalyser++) {
            var mtsAnalyser = arr$mtsAnalyser[index$mtsAnalyser];
            var dup = buf.duplicate();
            NIOUtils.skip(buf, 4);
            mtsAnalyser.serializeTo(buf);
            dup.putInt(buf.position() - dup.position() - 4);
        }
    };
    prototype.serialize = function() {
        var bb = ByteBuffer.allocate(this.estimateSize());
        this.serializeTo(bb);
        bb.flip();
        return bb;
    };
}, {programs: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Demuxer for MPEG Program Stream format with random access
 *  
 *  Uses index to assist random access, see MPSIndexer
 *  
 *  @author The JCodec project
 *  
 */
var MPSRandomAccessDemuxer = function(ch, mpsIndex) {
    this.pesTokens = mpsIndex.getPesTokens();
    this.pesStreamIds = mpsIndex.getPesStreamIds().flattern();
    var streamIndices = mpsIndex.getStreams();
    this.streams = Array(streamIndices.length);
    for (var i = 0; i < streamIndices.length; i++) {
        this.streams[i] = this.newStream(ch, streamIndices[i]);
    }
};
MPSRandomAccessDemuxer = stjs.extend(MPSRandomAccessDemuxer, null, [], function(constructor, prototype) {
    prototype.streams = null;
    prototype.pesTokens = null;
    prototype.pesStreamIds = null;
    prototype.newStream = function(ch, streamIndex) {
        return new MPSRandomAccessDemuxer.Stream(this, streamIndex, ch);
    };
    prototype.getStreams = function() {
        return this.streams;
    };
    constructor.Stream = function(demuxer, streamIndex, source) {
        MPSIndex.MPSStreamIndex.call(this, streamIndex.streamId, streamIndex.fsizes, streamIndex.fpts, streamIndex.fdur, streamIndex.sync);
        this.demuxer = demuxer;
        this.source = source;
        this.foffs = Array(this.fsizes.length);
        var curOff = 0;
        for (var i = 0; i < this.fsizes.length; i++) {
            this.foffs[i] = curOff;
            curOff += this.fsizes[i];
        }
        var seg = Platform.copyOfInt(streamIndex.getFpts(), 100);
        Arrays.sort(seg);
        this._seekToFrame = 0;
        this.seekToFrame();
    };
    constructor.Stream = stjs.extend(constructor.Stream, MPSIndex.MPSStreamIndex, [SeekableDemuxerTrack], function(constructor, prototype) {
        constructor.MPEG_TIMESCALE = 90000;
        prototype.curPesIdx = 0;
        prototype.curFrame = 0;
        prototype.pesBuf = null;
        prototype._seekToFrame = -1;
        prototype.source = null;
        prototype.foffs = null;
        prototype.demuxer = null;
        prototype.nextFrame = function() {
            this.seekToFrame();
            if (this.curFrame >= this.fsizes.length) 
                return null;
            var fs = this.fsizes[this.curFrame];
            var result = ByteBuffer.allocate(fs);
            return this._nextFrame(result);
        };
        prototype._nextFrame = function(buf) {
            this.seekToFrame();
            if (this.curFrame >= this.fsizes.length) 
                return null;
            var fs = this.fsizes[this.curFrame];
            var result = buf.duplicate();
            result.setLimit(result.position() + fs);
             while (result.hasRemaining()){
                if (this.pesBuf.hasRemaining()) {
                    result.putBuf(NIOUtils.read(this.pesBuf, Math.min(this.pesBuf.remaining(), result.remaining())));
                } else {
                    ++this.curPesIdx;
                    var posShift = 0;
                     while (this.demuxer.pesStreamIds[this.curPesIdx] != this.streamId){
                        posShift += MPSIndex.pesLen(this.demuxer.pesTokens[this.curPesIdx]) + MPSIndex.leadingSize(this.demuxer.pesTokens[this.curPesIdx]);
                        ++this.curPesIdx;
                    }
                    this.skip(posShift + MPSIndex.leadingSize(this.demuxer.pesTokens[this.curPesIdx]));
                    var pesLen = MPSIndex.pesLen(this.demuxer.pesTokens[this.curPesIdx]);
                    this.pesBuf = this.fetch(pesLen);
                    MPSUtils.readPESHeader(this.pesBuf, 0);
                }
            }
            result.flip();
            var pkt = Packet.createPacket(result, this.fpts[this.curFrame], MPSRandomAccessDemuxer.Stream.MPEG_TIMESCALE, this.fdur[this.curFrame], this.curFrame, this.sync.length == 0 || Arrays.binarySearch(this.sync, this.curFrame) >= 0 ? Packet.FrameType.KEY : Packet.FrameType.INTER, null);
            this.curFrame++;
            return pkt;
        };
        prototype.fetch = function(pesLen) {
            return NIOUtils.fetchFromChannel(this.source, pesLen);
        };
        prototype.skip = function(leadingSize) {
            this.source.setPosition(this.source.position() + leadingSize);
        };
        prototype.reset = function() {
            this.source.setPosition(0);
        };
        prototype.getMeta = function() {
            return null;
        };
        prototype.gotoFrame = function(frameNo) {
            this._seekToFrame = ((frameNo) | 0);
            return true;
        };
        prototype.gotoSyncFrame = function(frameNo) {
            for (var i = 0; i < this.sync.length; i++) {
                if (this.sync[i] > frameNo) {
                    this._seekToFrame = this.sync[i - 1];
                    return true;
                }
            }
            this._seekToFrame = this.sync[this.sync.length - 1];
            return true;
        };
        prototype.seekToFrame = function() {
            if (this._seekToFrame == -1) 
                return;
            this.curFrame = this._seekToFrame;
            var payloadOff = this.foffs[this.curFrame];
            var posShift = 0;
            this.reset();
            for (this.curPesIdx = 0; ; this.curPesIdx++) {
                if (this.demuxer.pesStreamIds[this.curPesIdx] == this.streamId) {
                    var payloadSize = MPSIndex.payLoadSize(this.demuxer.pesTokens[this.curPesIdx]);
                    if (payloadOff < payloadSize) 
                        break;
                    payloadOff -= payloadSize;
                }
                posShift += MPSIndex.pesLen(this.demuxer.pesTokens[this.curPesIdx]) + MPSIndex.leadingSize(this.demuxer.pesTokens[this.curPesIdx]);
            }
            this.skip(posShift + MPSIndex.leadingSize(this.demuxer.pesTokens[this.curPesIdx]));
            this.pesBuf = this.fetch(MPSIndex.pesLen(this.demuxer.pesTokens[this.curPesIdx]));
            MPSUtils.readPESHeader(this.pesBuf, 0);
            NIOUtils.skip(this.pesBuf, ((payloadOff) | 0));
            this._seekToFrame = -1;
        };
        prototype.getCurFrame = function() {
            return this.curFrame;
        };
        prototype.seek = function(second) {
             throw new NotSupportedException();
        };
    }, {pesBuf: "ByteBuffer", source: "SeekableByteChannel", foffs: "Array", demuxer: "MPSRandomAccessDemuxer", fsizes: "Int32Array", fpts: "Int32Array", fdur: "Int32Array", sync: "Int32Array"}, {});
}, {streams: "Array", pesTokens: "Array", pesStreamIds: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MTSUtils = function() {};
MTSUtils = stjs.extend(MTSUtils, null, [], function(constructor, prototype) {
    /**
     *  Parses PAT ( Program Association Table )
     *  
     *  @param data
     *  @deprecated Use org.jcodec.containers.mps.psi.PAT.parse method instead,
     *              this method will not work correctly for streams with multiple
     *              programs
     *  @return Pid of the first PMT found in the PAT
     */
    constructor.parsePAT = function(data) {
        var pat = PATSection.parsePAT(data);
        if (pat.getPrograms().size() > 0) 
            return pat.getPrograms().values()[0];
         else 
            return -1;
    };
    constructor.parsePMT = function(data) {
        return PMTSection.parsePMT(data);
    };
    constructor.parseSection = function(data) {
        return PSISection.parsePSI(data);
    };
    constructor.parseEsInfo = function(read) {};
    constructor.getProgramGuids = function(src) {
        var ch = null;
        try {
            ch = NIOUtils.readableChannel(src);
            return MTSUtils.getProgramGuidsFromChannel(ch);
        } finally {
            NIOUtils.closeQuietly(ch);
        }
    };
    constructor.getProgramGuidsFromChannel = function(_in) {
        var ex = new MTSUtils.PMTExtractor();
        ex.readTsFile(_in);
        var pmt = ex.getPmt();
        return pmt.getStreams();
    };
    constructor.PMTExtractor = function() {
        MTSUtils.TSReader.call(this, false);
    };
    constructor.PMTExtractor = stjs.extend(constructor.PMTExtractor, MTSUtils.TSReader, [], function(constructor, prototype) {
        prototype.pmtGuid = -1;
        prototype.pmt = null;
        prototype.onPkt = function(guid, payloadStart, tsBuf, filePos, sectionSyntax, fullPkt) {
            if (guid == 0) {
                this.pmtGuid = MTSUtils.parsePAT(tsBuf);
            } else if (this.pmtGuid != -1 && guid == this.pmtGuid) {
                this.pmt = MTSUtils.parsePMT(tsBuf);
                return false;
            }
            return true;
        };
        prototype.getPmt = function() {
            return this.pmt;
        };
    }, {pmt: "PMTSection"}, {});
    constructor.TSReader = function(flush) {
        this.flush = flush;
    };
    constructor.TSReader = stjs.extend(constructor.TSReader, null, [], function(constructor, prototype) {
        constructor.TS_SYNC_MARKER = 71;
        constructor.TS_PKT_SIZE = 188;
        constructor.BUFFER_SIZE = MTSUtils.TSReader.TS_PKT_SIZE << 9;
        prototype.flush = false;
        prototype.readTsFile = function(ch) {
            ch.setPosition(0);
            var buf = ByteBuffer.allocate(MTSUtils.TSReader.BUFFER_SIZE);
            for (var pos = ch.position(); ch.read(buf) >= MTSUtils.TSReader.TS_PKT_SIZE; pos = ch.position()) {
                var posRem = pos;
                buf.flip();
                 while (buf.remaining() >= MTSUtils.TSReader.TS_PKT_SIZE){
                    var tsBuf = NIOUtils.read(buf, MTSUtils.TSReader.TS_PKT_SIZE);
                    var fullPkt = tsBuf.duplicate();
                    pos += MTSUtils.TSReader.TS_PKT_SIZE;
                    Preconditions.checkState(MTSUtils.TSReader.TS_SYNC_MARKER == (tsBuf.get() & 255));
                    var guidFlags = ((tsBuf.get() & 255) << 8) | (tsBuf.get() & 255);
                    var guid = stjs.trunc(guidFlags) & 8191;
                    var payloadStart = (guidFlags >> 14) & 1;
                    var b0 = tsBuf.get() & 255;
                    var counter = b0 & 15;
                    if ((b0 & 32) != 0) {
                        NIOUtils.skip(tsBuf, tsBuf.get() & 255);
                    }
                    var sectionSyntax = payloadStart == 1 && (NIOUtils.getRel(tsBuf, NIOUtils.getRel(tsBuf, 0) + 2) & 128) == 128;
                    if (sectionSyntax) {
                        NIOUtils.skip(tsBuf, tsBuf.get() & 255);
                    }
                    if (!this.onPkt(guid, payloadStart == 1, tsBuf, pos - tsBuf.remaining(), sectionSyntax, fullPkt)) 
                        return;
                }
                if (this.flush) {
                    buf.flip();
                    ch.setPosition(posRem);
                    ch.write(buf);
                }
                buf.clear();
            }
        };
        prototype.onPkt = function(guid, payloadStart, tsBuf, filePos, sectionSyntax, fullPkt) {
            return true;
        };
    }, {}, {});
    constructor.getVideoPid = function(src) {
        for (var index$stream = 0, arr$stream = MTSUtils.getProgramGuids(src); index$stream < arr$stream.length; index$stream++) {
            var stream = arr$stream[index$stream];
            if (stream.getStreamType().isVideo()) 
                return stream.getPid();
        }
         throw new RuntimeException("No video stream");
    };
    constructor.getAudioPid = function(src) {
        for (var index$stream = 0, arr$stream = MTSUtils.getProgramGuids(src); index$stream < arr$stream.length; index$stream++) {
            var stream = arr$stream[index$stream];
            if (stream.getStreamType().isAudio()) 
                return stream.getPid();
        }
         throw new RuntimeException("No audio stream");
    };
    constructor.getMediaPidsFromChannel = function(src) {
        return MTSUtils.filterMediaPids(MTSUtils.getProgramGuidsFromChannel(src));
    };
    constructor.getMediaPids = function(src) {
        return MTSUtils.filterMediaPids(MTSUtils.getProgramGuids(src));
    };
    constructor.filterMediaPids = function(programs) {
        var result = IntArrayList.createIntArrayList();
        for (var index$stream = 0, arr$stream = programs; index$stream < arr$stream.length; index$stream++) {
            var stream = arr$stream[index$stream];
            if (stream.getStreamType().isVideo() || stream.getStreamType().isAudio()) 
                result.add(stream.getPid());
        }
        return result.toArray();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Outputs messages to standard output
 *  
 *  @author The JCodec project
 */
var OutLogSink = function(out, fmt, minLevel) {
    this.out = out;
    this.fmt = fmt;
    this.minLevel = minLevel;
};
OutLogSink = stjs.extend(OutLogSink, null, [LogSink], function(constructor, prototype) {
    constructor.empty = "                                                                                                                                                                                                                                                ";
    constructor.SimpleFormat = function(fmt) {
        this.fmt = fmt;
    };
    constructor.SimpleFormat = stjs.extend(constructor.SimpleFormat, null, [OutLogSink.MessageFormat], function(constructor, prototype) {
        prototype.fmt = null;
        constructor.colorMap = new HashMap();
        prototype.formatMessage = function(msg) {
            var str = this.fmt.replace("#level", String.valueOf(msg.getLevel())).replace("#color_code", String.valueOf(30 + OutLogSink.SimpleFormat.colorMap.get(msg.getLevel()).ordinal())).replace("#class", msg.getClassName()).replace("#method", msg.getMethodName()).replace("#file", msg.getFileName()).replace("#line", String.valueOf(msg.getLineNumber())).replace("#message", msg.getMessage());
            return str;
        };
    }, {colorMap: {name: "Map", arguments: [{name: "Enum", arguments: ["LogLevel"]}, {name: "Enum", arguments: ["MainUtils.ANSIColor"]}]}}, {});
    (function() {
        OutLogSink.SimpleFormat.colorMap.put(LogLevel.DEBUG, MainUtils.ANSIColor.BROWN);
        OutLogSink.SimpleFormat.colorMap.put(LogLevel.INFO, MainUtils.ANSIColor.GREEN);
        OutLogSink.SimpleFormat.colorMap.put(LogLevel.WARN, MainUtils.ANSIColor.MAGENTA);
        OutLogSink.SimpleFormat.colorMap.put(LogLevel.ERROR, MainUtils.ANSIColor.RED);
    })();
    constructor.DEFAULT_FORMAT = new OutLogSink.SimpleFormat(MainUtils.colorString("[#level]", "#color_code") + MainUtils.bold("\t#class.#method (#file:#line):") + "\t#message");
    constructor.createOutLogSink = function() {
        return new OutLogSink(System.out, OutLogSink.DEFAULT_FORMAT, LogLevel.INFO);
    };
    prototype.out = null;
    prototype.fmt = null;
    prototype.minLevel = null;
    prototype.postMessage = function(msg) {
        if (msg.getLevel().ordinal() < this.minLevel.ordinal()) 
            return;
        var str = this.fmt.formatMessage(msg);
        this.out.println(str);
    };
    constructor.MessageFormat = function() {};
    constructor.MessageFormat = stjs.extend(constructor.MessageFormat, null, [], function(constructor, prototype) {
        prototype.formatMessage = function(msg) {};
    }, {}, {});
}, {DEFAULT_FORMAT: "OutLogSink.SimpleFormat", out: "PrintStream", fmt: "OutLogSink.MessageFormat", minLevel: {name: "Enum", arguments: ["LogLevel"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  This utility relocates PAT/PMT PSI packets from anywhere within a file to the
 *  beginning of the file so that the file is playable
 *  
 *  @author The JCodec project
 *  
 */
var HLSRelocatePMT = function() {};
HLSRelocatePMT = stjs.extend(HLSRelocatePMT, null, [], function(constructor, prototype) {
    constructor.TS_START_CODE = 71;
    constructor.CHUNK_SIZE_PKT = 1024;
    constructor.TS_PKT_SIZE = 188;
    constructor.main1 = function(args) {
        var cmd = MainUtils.parseArguments(args, []);
        if (cmd.args.length < 2) {
            MainUtils.printHelpNoFlags("file _in", "file out");
            return;
        }
        var _in = null;
        var out = null;
        try {
            _in = NIOUtils.readableChannel(new File(cmd.args[0]));
            out = NIOUtils.writableChannel(new File(cmd.args[1]));
            System.err.println("Processed: " + HLSRelocatePMT.replocatePMT(_in, out) + " packets.");
        } finally {
            NIOUtils.closeQuietly(_in);
            NIOUtils.closeQuietly(out);
        }
    };
    constructor.replocatePMT = function(_in, out) {
        var buf = ByteBuffer.allocate(HLSRelocatePMT.TS_PKT_SIZE * HLSRelocatePMT.CHUNK_SIZE_PKT);
        var pmtPids = new HashSet();
        var held = new ArrayList();
        var patPkt = null;
        var pmtPkt = null;
        var totalPkt = 0;
         while (_in.read(buf) != -1){
            buf.flip();
            buf.setLimit((stjs.trunc(buf.limit() / HLSRelocatePMT.TS_PKT_SIZE)) * HLSRelocatePMT.TS_PKT_SIZE);
             while (buf.hasRemaining()){
                var pkt = NIOUtils.read(buf, HLSRelocatePMT.TS_PKT_SIZE);
                var pktRead = pkt.duplicate();
                Preconditions.checkState(HLSRelocatePMT.TS_START_CODE == (pktRead.get() & 255));
                ++totalPkt;
                var guidFlags = ((pktRead.get() & 255) << 8) | (pktRead.get() & 255);
                var guid = stjs.trunc(guidFlags) & 8191;
                var payloadStart = (guidFlags >> 14) & 1;
                var b0 = pktRead.get() & 255;
                var counter = b0 & 15;
                if ((b0 & 32) != 0) {
                    NIOUtils.skip(pktRead, (pktRead.get() & 255));
                }
                if (guid == 0 || pmtPids.contains(guid)) {
                    if (payloadStart == 1) {
                        NIOUtils.skip(pktRead, (pktRead.get() & 255));
                    }
                    if (guid == 0) {
                        patPkt = pkt;
                        var pat = PATSection.parsePAT(pktRead);
                        var values = pat.getPrograms().values();
                        for (var i = 0; i < values.length; i++) {
                            var pmtPid = values[i];
                            pmtPids.add(pmtPid);
                        }
                    } else if (pmtPids.contains(guid)) {
                        pmtPkt = pkt;
                        out.write(patPkt);
                        out.write(pmtPkt);
                        for (var iterator$heldPkt = held.iterator(); iterator$heldPkt.hasNext(); ) {
                            var heldPkt = iterator$heldPkt.next();
                            out.write(heldPkt);
                        }
                        held.clear();
                    }
                } else {
                    if (pmtPkt == null) 
                        held.add(pkt);
                     else 
                        out.write(pkt);
                }
            }
            buf.clear();
        }
        return totalPkt;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var MTSPktDump = function() {};
MTSPktDump = stjs.extend(MTSPktDump, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        var cmd = MainUtils.parseArguments(args, []);
        if (cmd.args.length < 1) {
            MainUtils.printHelpNoFlags("file name");
            return;
        }
        var ch = null;
        try {
            ch = NIOUtils.readableChannel(new File(cmd.args[0]));
            MTSPktDump.dumpTSPackets(ch);
        } finally {
            NIOUtils.closeQuietly(ch);
        }
    };
    constructor.dumpTSPackets = function(_in) {
        var buf = ByteBuffer.allocate(188 * 1024);
         while (_in.read(buf) != -1){
            buf.flip();
            buf.setLimit((stjs.trunc(buf.limit() / 188)) * 188);
            var pmtPid = -1;
            for (var pkt = 0; buf.hasRemaining(); ++pkt) {
                var tsBuf = NIOUtils.read(buf, 188);
                Preconditions.checkState(71 == (tsBuf.get() & 255));
                var guidFlags = ((tsBuf.get() & 255) << 8) | (tsBuf.get() & 255);
                var guid = stjs.trunc(guidFlags) & 8191;
                var payloadStart = (guidFlags >> 14) & 1;
                var b0 = tsBuf.get() & 255;
                var counter = b0 & 15;
                if ((b0 & 32) != 0) {
                    NIOUtils.skip(tsBuf, (tsBuf.get() & 255));
                }
                System.out.print("#" + pkt + "[guid: " + guid + ", cnt: " + counter + ", start: " + (payloadStart == 1 ? "y" : "-"));
                if (guid == 0 || guid == pmtPid) {
                    System.out.print(", PSI]: ");
                    if (payloadStart == 1) {
                        NIOUtils.skip(tsBuf, (tsBuf.get() & 255));
                    }
                    if (guid == 0) {
                        var pat = PATSection.parsePAT(tsBuf);
                        var programs = pat.getPrograms();
                        pmtPid = programs.values()[0];
                        MTSPktDump.printPat(pat);
                    } else if (guid == pmtPid) {
                        var pmt = PMTSection.parsePMT(tsBuf);
                        MTSPktDump.printPmt(pmt);
                    }
                } else {
                    System.out.print("]: " + tsBuf.remaining());
                }
                System.out.println();
            }
            buf.clear();
        }
    };
    constructor.printPat = function(pat) {
        var programs = pat.getPrograms();
        System.out.print("PAT: ");
        var keys = programs.keys();
        for (var index$i = 0, arr$i = keys; index$i < arr$i.length; index$i++) {
            var i = arr$i[index$i];
            System.out.print(i + ":" + programs.get(i) + ", ");
        }
    };
    constructor.printPmt = function(pmt) {
        System.out.print("PMT: ");
        for (var index$pmtStream = 0, arr$pmtStream = pmt.getStreams(); index$pmtStream < arr$pmtStream.length; index$pmtStream++) {
            var pmtStream = arr$pmtStream[index$pmtStream];
            System.out.print(pmtStream.getPid() + ":" + pmtStream.getStreamTypeTag() + ", ");
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Interleaves 2 or more single channel wave files into a multichannel wav
 *  
 *  @author The JCodec project
 *  
 */
var WavMerge = function() {};
WavMerge = stjs.extend(WavMerge, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 3) {
            System.out.println("wavmerge <output wav> <input wav> .... <input wav>");
            System.exit(-1);
        }
        var out = new File(args[0]);
        var ins = Array(args.length - 1);
        for (var i = 1; i < args.length; i++) 
            ins[i - 1] = new File(args[i]);
        WavMerge.merge(out, ins);
    };
    constructor.merge = function(result, src) {
        var out = null;
        var inputs = Array(src.length);
        var headers = Array(src.length);
        var ins = Array(src.length);
        try {
            var sampleSize = -1;
            for (var i = 0; i < src.length; i++) {
                inputs[i] = NIOUtils.readableChannel(src[i]);
                var hdr = WavHeader.readChannel(inputs[i]);
                if (sampleSize != -1 && sampleSize != hdr.fmt.bitsPerSample) 
                     throw new RuntimeException("Input files have different sample sizes");
                sampleSize = hdr.fmt.bitsPerSample;
                headers[i] = hdr;
                ins[i] = ByteBuffer.allocate(hdr.getFormat().framesToBytes(4096));
            }
            var outb = ByteBuffer.allocate(headers[0].getFormat().framesToBytes(4096) * src.length);
            var newHeader = WavHeader.multiChannelWav(headers);
            out = NIOUtils.writableChannel(result);
            newHeader.write(out);
            for (var readOnce = true; ; ) {
                readOnce = false;
                for (var i = 0; i < ins.length; i++) {
                    if (inputs[i] != null) {
                        ins[i].clear();
                        if (inputs[i].read(ins[i]) == -1) {
                            NIOUtils.closeQuietly(inputs[i]);
                            inputs[i] = null;
                        } else 
                            readOnce = true;
                        ins[i].flip();
                    }
                }
                if (!readOnce) 
                    break;
                outb.clear();
                AudioUtil.interleave(headers[0].getFormat(), ins, outb);
                outb.flip();
                out.write(outb);
            }
        } finally {
            IOUtils.closeQuietly(out);
            for (var index$inputStream = 0, arr$inputStream = inputs; index$inputStream < arr$inputStream.length; index$inputStream++) {
                var inputStream = arr$inputStream[index$inputStream];
                IOUtils.closeQuietly(inputStream);
            }
        }
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Reads integer samples from the wav file
 *  
 *  @author The JCodec project
 */
var WavInput = function(_in) {
    this.header = WavHeader.readChannel(_in);
    this.format = this.header.getFormat();
    this._in = _in;
};
WavInput = stjs.extend(WavInput, null, [Closeable], function(constructor, prototype) {
    prototype.header = null;
    prototype.prevBuf = null;
    prototype._in = null;
    prototype.format = null;
    prototype.read = function(buf) {
        var maxRead = this.format.framesToBytes(this.format.bytesToFrames(buf.remaining()));
        return NIOUtils.readL(this._in, buf, maxRead);
    };
    prototype.close = function() {
        this._in.close();
    };
    prototype.getHeader = function() {
        return this.header;
    };
    prototype.getFormat = function() {
        return this.format;
    };
    /**
     *  Manages file resource on top of WavInput
     */
    constructor.WavFile = function(f) {
        WavInput.call(this, NIOUtils.readableChannel(f));
    };
    constructor.WavFile = stjs.extend(constructor.WavFile, WavInput, [], function(constructor, prototype) {
        prototype.close = function() {
            WavInput.prototype.close.call(this);
            this._in.close();
        };
    }, {header: "WavHeader", prevBuf: "Int8Array", _in: "ReadableByteChannel", format: "AudioFormat"}, {});
    /**
     *  Supports more high-level float and integer input on top of WavInput
     */
    constructor.Source = function(src) {
        this.src = src;
        this.format = src.getFormat();
    };
    constructor.Source = stjs.extend(constructor.Source, null, [AudioSource, Closeable], function(constructor, prototype) {
        prototype.src = null;
        prototype.format = null;
        prototype.pos = 0;
        prototype.getFormat = function() {
            return this.src.getFormat();
        };
        prototype.close = function() {
            this.src.close();
        };
        prototype.read = function(samples, max) {
            max = Math.min(max, samples.length);
            var bb = ByteBuffer.allocate(this.format.samplesToBytes(max));
            var read = this.src.read(bb);
            bb.flip();
            AudioUtil.toInt(this.format, bb, samples);
            return this.format.bytesToFrames(read);
        };
        prototype.readFloat = function(samples) {
            var bb = ByteBuffer.allocate(this.format.samplesToBytes(samples.remaining()));
            var i = this.src.read(bb);
            if (i == -1) 
                return -1;
            bb.flip();
            AudioUtil.toFloat(this.format, bb, samples);
            var read = this.format.bytesToFrames(i);
            this.pos += read;
            return read;
        };
    }, {src: "WavInput", format: "AudioFormat"}, {});
}, {header: "WavHeader", prevBuf: "Int8Array", _in: "ReadableByteChannel", format: "AudioFormat"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Splits a multichannel wave file into a number of single-channel wavs
 *  
 *  @author The JCodec project
 *  
 */
var WavSplit = function() {};
WavSplit = stjs.extend(WavSplit, null, [], function(constructor, prototype) {
    constructor.FLAG_PATTERN = MainUtils.Flag.flag("pattern", "p", "Output file name pattern, i.e. out%02d.wav");
    constructor.ALL_FLAGS = [WavSplit.FLAG_PATTERN];
    constructor.main1 = function(args) {
        var cmd = MainUtils.parseArguments(args, WavSplit.ALL_FLAGS);
        if (cmd.argsLength() < 1) {
            MainUtils.printHelp(WavSplit.ALL_FLAGS, Arrays.asList("filename.wav"));
            System.exit(-1);
        }
        var s = new File(args[0]);
        var pattern = cmd.getStringFlagD(WavSplit.FLAG_PATTERN, "c%02d.wav");
        var wavHeader = WavHeader.read(s);
        System.out.println("WAV: " + wavHeader.getFormat());
        Preconditions.checkState(2 == stjs.trunc(wavHeader.fmt.numChannels));
        var dataOffset = wavHeader.dataOffset;
        var is = NIOUtils.readableChannel(s);
        is.setPosition(dataOffset);
        var channels = wavHeader.getFormat().getChannels();
        var out = Array(channels);
        for (var i = 0; i < channels; i++) {
            out[i] = NIOUtils.writableChannel((new File(s.getParentFile(), String.format(pattern, i))));
            WavHeader.copyWithChannels(wavHeader, 1).write(out[i]);
        }
        WavSplit.copy(wavHeader.getFormat(), is, out);
        for (var i = 0; i < channels; i++) {
            out[i].close();
        }
    };
    constructor.copy = function(format, is, out) {
        var outs = Array(out.length);
        for (var i = 0; i < out.length; i++) {
            outs[i] = ByteBuffer.allocate(format.framesToBytes(4096));
        }
        var inb = ByteBuffer.allocate(format.framesToBytes(4096) * out.length);
         while (is.read(inb) != -1){
            inb.flip();
            AudioUtil.deinterleave(format, inb, outs);
            inb.clear();
            for (var i = 0; i < out.length; i++) {
                outs[i].flip();
                out[i].write(outs[i]);
                outs[i].clear();
            }
        }
    };
}, {FLAG_PATTERN: "MainUtils.Flag", ALL_FLAGS: "Array"}, {});
/**
 *  A demuxer for a wav file.
 *  
 *  
 *  @author Stan Vitvitskiy
 */
var WavDemuxer = function(ch) {
    this.ch = ch;
    this.header = WavHeader.readChannel(ch);
    this.dataSize = ch.size() - ch.position();
    this.frameSize = this.header.getFormat().getFrameSize();
};
WavDemuxer = stjs.extend(WavDemuxer, null, [Demuxer, DemuxerTrack], function(constructor, prototype) {
    constructor.FRAMES_PER_PKT = 1024;
    prototype.ch = null;
    prototype.header = null;
    prototype.dataSize = 0;
    prototype.frameSize = 0;
    prototype.frameNo = 0;
    prototype.pts = 0;
    prototype.close = function() {
        this.ch.close();
    };
    prototype.nextFrame = function() {
        var data = NIOUtils.fetchFromChannel(this.ch, this.frameSize * WavDemuxer.FRAMES_PER_PKT);
        if (!data.hasRemaining()) 
            return null;
        var oldPts = this.pts;
        var duration = stjs.trunc(data.remaining() / this.frameSize);
        this.pts += duration;
        return Packet.createPacket(data, oldPts, this.header.getFormat().getFrameRate(), stjs.trunc(data.remaining() / this.frameSize), this.frameNo++, Packet.FrameType.KEY, null);
    };
    prototype.getMeta = function() {
        var format = this.header.getFormat();
        var audioCodecMeta = AudioCodecMeta.fromAudioFormat(format);
        var totalFrames = stjs.trunc(this.dataSize / format.getFrameSize());
        return new DemuxerTrackMeta(TrackType.AUDIO, Codec.PCM, totalFrames / format.getFrameRate(), null, ((totalFrames) | 0), null, null, audioCodecMeta);
    };
    prototype.getTracks = function() {
        var result = new ArrayList();
        result.add(this);
        return result;
    };
    prototype.getVideoTracks = function() {
        var result = new ArrayList();
        return result;
    };
    prototype.getAudioTracks = function() {
        return this.getTracks();
    };
}, {ch: "SeekableByteChannel", header: "WavHeader"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Outputs integer samples into wav file
 *  
 *  @author The JCodec project
 */
var WavOutput = function(out, format) {
    this.out = out;
    this.format = format;
    this.header = WavHeader.createWavHeader(format, 0);
    this.header.write(out);
};
WavOutput = stjs.extend(WavOutput, null, [Closeable], function(constructor, prototype) {
    prototype.out = null;
    prototype.header = null;
    prototype.written = 0;
    prototype.format = null;
    prototype.write = function(samples) {
        this.written += this.out.write(samples);
    };
    prototype.close = function() {
        this.out.setPosition(0);
        WavHeader.createWavHeader(this.format, this.format.bytesToFrames(this.written)).write(this.out);
        NIOUtils.closeQuietly(this.out);
    };
    /**
     *  Manages the file resource on top of WavOutput
     */
    constructor.WavOutFile = function(f, format) {
        WavOutput.call(this, NIOUtils.writableChannel(f), format);
    };
    constructor.WavOutFile = stjs.extend(constructor.WavOutFile, WavOutput, [], function(constructor, prototype) {
        prototype.close = function() {
            WavOutput.prototype.close.call(this);
            NIOUtils.closeQuietly(this.out);
        };
    }, {out: "SeekableByteChannel", header: "WavHeader", format: "AudioFormat"}, {});
    /**
     *  Supports more high-level float and int array output on top of WavOutput
     */
    constructor.Sink = function(out) {
        this.out = out;
    };
    constructor.Sink = stjs.extend(constructor.Sink, null, [AudioSink, Closeable], function(constructor, prototype) {
        prototype.out = null;
        prototype.writeFloat = function(data) {
            var buf = ByteBuffer.allocate(this.out.format.samplesToBytes(data.remaining()));
            AudioUtil.fromFloat(data, this.out.format, buf);
            buf.flip();
            this.out.write(buf);
        };
        prototype.write = function(data, len) {
            len = Math.min(data.length, len);
            var buf = ByteBuffer.allocate(this.out.format.samplesToBytes(len));
            AudioUtil.fromInt(data, len, this.out.format, buf);
            buf.flip();
            this.out.write(buf);
        };
        prototype.close = function() {
            this.out.close();
        };
    }, {out: "WavOutput"}, {});
}, {out: "SeekableByteChannel", header: "WavHeader", format: "AudioFormat"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Outputs integer samples into wav file
 *  
 *  @author The JCodec project
 */
var WavMuxer = function(out) {
    this.out = out;
};
WavMuxer = stjs.extend(WavMuxer, null, [Muxer, MuxerTrack], function(constructor, prototype) {
    prototype.out = null;
    prototype.header = null;
    prototype.written = 0;
    prototype.format = null;
    prototype.addFrame = function(outPacket) {
        this.written += this.out.write(outPacket.getData());
    };
    prototype.close = function() {
        this.out.setPosition(0);
        WavHeader.createWavHeader(this.format, this.format.bytesToFrames(this.written)).write(this.out);
        NIOUtils.closeQuietly(this.out);
    };
    prototype.addVideoTrack = function(codec, meta) {
        return null;
    };
    prototype.addAudioTrack = function(codec, meta) {
        this.header = WavHeader.createWavHeader(meta.getFormat(), 0);
        this.format = meta.getFormat();
        try {
            this.header.write(this.out);
        }catch (e) {
             throw new RuntimeException(e);
        }
        return this;
    };
    prototype.finish = function() {};
}, {out: "SeekableByteChannel", header: "WavHeader", format: "AudioFormat"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var DecoderConfig = function(objectType, bufSize, maxBitrate, avgBitrate, children) {
    NodeDescriptor.call(this, DecoderConfig.tag(), children);
    this.objectType = objectType;
    this.bufSize = bufSize;
    this.maxBitrate = maxBitrate;
    this.avgBitrate = avgBitrate;
};
DecoderConfig = stjs.extend(DecoderConfig, NodeDescriptor, [], function(constructor, prototype) {
    prototype.objectType = 0;
    prototype.bufSize = 0;
    prototype.maxBitrate = 0;
    prototype.avgBitrate = 0;
    prototype.doWrite = function(out) {
        out.put((this.objectType << 24 >> 24));
        out.put((21 << 24 >> 24));
        out.put(((this.bufSize >> 16) << 24 >> 24));
        out.putShort(((this.bufSize) << 16 >> 16));
        out.putInt(this.maxBitrate);
        out.putInt(this.avgBitrate);
        NodeDescriptor.prototype.doWrite.call(this, out);
    };
    constructor.tag = function() {
        return 4;
    };
    prototype.getObjectType = function() {
        return this.objectType;
    };
    prototype.getBufSize = function() {
        return this.bufSize;
    };
    prototype.getMaxBitrate = function() {
        return this.maxBitrate;
    };
    prototype.getAvgBitrate = function() {
        return this.avgBitrate;
    };
}, {children: {name: "Collection", arguments: ["Descriptor"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ES = function(trackId, children) {
    NodeDescriptor.call(this, ES.tag(), children);
    this.trackId = trackId;
};
ES = stjs.extend(ES, NodeDescriptor, [], function(constructor, prototype) {
    prototype.trackId = 0;
    constructor.tag = function() {
        return 3;
    };
    prototype.doWrite = function(out) {
        out.putShort(((this.trackId) << 16 >> 16));
        out.put((0 << 24 >> 24));
        NodeDescriptor.prototype.doWrite.call(this, out);
    };
    prototype.getTrackId = function() {
        return this.trackId;
    };
}, {children: {name: "Collection", arguments: ["Descriptor"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MXFPartition = function(pack, essenceFilePos, closed, complete, essenceLength) {
    this.pack = pack;
    this.essenceFilePos = essenceFilePos;
    this.closed = closed;
    this.complete = complete;
    this.essenceLength = essenceLength;
};
MXFPartition = stjs.extend(MXFPartition, null, [], function(constructor, prototype) {
    prototype.pack = null;
    prototype.essenceFilePos = 0;
    prototype.closed = false;
    prototype.complete = false;
    prototype.essenceLength = 0;
    constructor.read = function(ul, bb, packSize, nextPartition) {
        var closed = (ul.get(14) & 1) == 0;
        var complete = ul.get(14) > 2;
        var pp = new MXFPartitionPack(ul);
        pp.readBuf(bb);
        var essenceFilePos = MXFPartition.roundToKag(pp.getThisPartition() + packSize, pp.getKagSize()) + MXFPartition.roundToKag(pp.getHeaderByteCount(), pp.getKagSize()) + MXFPartition.roundToKag(pp.getIndexByteCount(), pp.getKagSize());
        return new MXFPartition(pp, essenceFilePos, closed, complete, nextPartition - essenceFilePos);
    };
    constructor.roundToKag = function(position, kag_size) {
        var ret = (stjs.trunc(position / kag_size)) * kag_size;
        return ret == position ? ret : ret + kag_size;
    };
    prototype.getPack = function() {
        return this.pack;
    };
    prototype.getEssenceFilePos = function() {
        return this.essenceFilePos;
    };
    prototype.isClosed = function() {
        return this.closed;
    };
    prototype.isComplete = function() {
        return this.complete;
    };
    prototype.getEssenceLength = function() {
        return this.essenceLength;
    };
}, {pack: "MXFPartitionPack"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var CuesFactory = function(offset, videoTrack) {
    this.a = new ArrayList();
    this.offsetBase = offset;
    this.videoTrackNr = videoTrack;
    this.currentDataOffset += this.offsetBase;
};
CuesFactory = stjs.extend(CuesFactory, null, [], function(constructor, prototype) {
    prototype.a = null;
    prototype.offsetBase = 0;
    prototype.currentDataOffset = 0;
    prototype.videoTrackNr = 0;
    prototype.addFixedSize = function(z) {
        z.elementOffset = this.currentDataOffset;
        z.cueClusterPositionSize = 8;
        this.currentDataOffset += z.size;
        this.a.add(z);
    };
    prototype.add = function(z) {
        z.elementOffset = this.currentDataOffset;
        z.cueClusterPositionSize = EbmlUint.calculatePayloadSize(z.elementOffset);
        this.currentDataOffset += z.size;
        this.a.add(z);
    };
    prototype.createCues = function() {
        var estimatedSize = this.computeCuesSize();
        var cues = MKVType.createByType(MKVType.Cues);
        for (var iterator$cpm = this.a.iterator(); iterator$cpm.hasNext(); ) {
            var cpm = iterator$cpm.next();
            var cuePoint = MKVType.createByType(MKVType.CuePoint);
            var cueTime = MKVType.createByType(MKVType.CueTime);
            cueTime.setUint(cpm.timecode);
            cuePoint.add(cueTime);
            var cueTrackPositions = MKVType.createByType(MKVType.CueTrackPositions);
            var cueTrack = MKVType.createByType(MKVType.CueTrack);
            cueTrack.setUint(this.videoTrackNr);
            cueTrackPositions.add(cueTrack);
            var cueClusterPosition = MKVType.createByType(MKVType.CueClusterPosition);
            cueClusterPosition.setUint(cpm.elementOffset + estimatedSize);
            if (cueClusterPosition.data.limit() != cpm.cueClusterPositionSize) 
                System.err.println("estimated size of CueClusterPosition differs from the one actually used. ElementId: " + EbmlUtil.toHexString(cpm.id) + " " + cueClusterPosition.getData().limit() + " vs " + cpm.cueClusterPositionSize);
            cueTrackPositions.add(cueClusterPosition);
            cuePoint.add(cueTrackPositions);
            cues.add(cuePoint);
        }
        return cues;
    };
    prototype.computeCuesSize = function() {
        var cuesSize = this.estimateSize();
        var reindex = false;
        do {
            reindex = false;
            for (var iterator$z = this.a.iterator(); iterator$z.hasNext(); ) {
                var z = iterator$z.next();
                var minByteSize = EbmlUint.calculatePayloadSize(z.elementOffset + cuesSize);
                if (minByteSize > z.cueClusterPositionSize) {
                    System.out.println(minByteSize + ">" + z.cueClusterPositionSize);
                    System.err.println("Size " + cuesSize + " seems too small for element " + EbmlUtil.toHexString(z.id) + " increasing size by one.");
                    z.cueClusterPositionSize += 1;
                    cuesSize += 1;
                    reindex = true;
                    break;
                } else if (minByteSize < z.cueClusterPositionSize) {
                     throw new RuntimeException("Downsizing the index is not well thought through");
                }
            }
        } while (reindex);
        return cuesSize;
    };
    prototype.estimateFixedSize = function(numberOfClusters) {
        var s = 34 * numberOfClusters;
        s += MKVType.Cues.id.length + EbmlUtil.ebmlLength(s);
        return s;
    };
    prototype.estimateSize = function() {
        var s = 0;
        for (var iterator$cpm = this.a.iterator(); iterator$cpm.hasNext(); ) {
            var cpm = iterator$cpm.next();
            s += CuesFactory.estimateCuePointSize(EbmlUint.calculatePayloadSize(cpm.timecode), EbmlUint.calculatePayloadSize(this.videoTrackNr), EbmlUint.calculatePayloadSize(cpm.elementOffset));
        }
        s += MKVType.Cues.id.length + EbmlUtil.ebmlLength(s);
        return s;
    };
    constructor.estimateCuePointSize = function(timecodeSizeInBytes, trackNrSizeInBytes, clusterPositionSizeInBytes) {
        var cueTimeSize = MKVType.CueTime.id.length + EbmlUtil.ebmlLength(timecodeSizeInBytes) + timecodeSizeInBytes;
        var cueTrackPositionSize = MKVType.CueTrack.id.length + EbmlUtil.ebmlLength(trackNrSizeInBytes) + trackNrSizeInBytes + MKVType.CueClusterPosition.id.length + EbmlUtil.ebmlLength(clusterPositionSizeInBytes) + clusterPositionSizeInBytes;
        cueTrackPositionSize += MKVType.CueTrackPositions.id.length + EbmlUtil.ebmlLength(cueTrackPositionSize);
        var cuePointSize = MKVType.CuePoint.id.length + EbmlUtil.ebmlLength(cueTimeSize + cueTrackPositionSize) + cueTimeSize + cueTrackPositionSize;
        return cuePointSize;
    };
    constructor.CuePointMock = function() {};
    constructor.CuePointMock = stjs.extend(constructor.CuePointMock, null, [], function(constructor, prototype) {
        prototype.cueClusterPositionSize = 0;
        prototype.elementOffset = 0;
        prototype.timecode = 0;
        prototype.size = 0;
        prototype.id = null;
        constructor.make = function(c) {
            var path = [MKVType.Cluster, MKVType.Timecode];
            var tc = MKVType.findFirst(c, path);
            return CuesFactory.CuePointMock.doMake(c.id, tc.getUint(), c.size());
        };
        constructor.doMake = function(id, timecode, size) {
            var mock = new CuesFactory.CuePointMock();
            mock.id = id;
            mock.timecode = timecode;
            mock.size = size;
            return mock;
        };
    }, {id: "Int8Array"}, {});
}, {a: {name: "List", arguments: ["CuesFactory.CuePointMock"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var MKVParser = function(channel) {
    this.channel = channel;
    this.trace = new LinkedList();
};
MKVParser = stjs.extend(MKVParser, null, [], function(constructor, prototype) {
    prototype.channel = null;
    prototype.trace = null;
    prototype.parse = function() {
        var tree = new ArrayList();
        var e = null;
         while ((e = this.nextElement()) != null){
            if (!this.isKnownType(e.id)) 
                System.err.println("Unspecified header: " + EbmlUtil.toHexString(e.id) + " at " + e.offset);
             while (!this.possibleChild(this.trace.peekFirst(), e))
                this.closeElem(this.trace.removeFirst(), tree);
            this.openElem(e);
            if (stjs.isInstanceOf(e.constructor, EbmlMaster)) {
                this.trace.push(e);
            } else if (stjs.isInstanceOf(e.constructor, EbmlBin)) {
                var bin = e;
                var traceTop = this.trace.peekFirst();
                if ((traceTop.dataOffset + traceTop.dataLen) < (e.dataOffset + e.dataLen)) {
                    this.channel.setPosition((traceTop.dataOffset + traceTop.dataLen));
                } else 
                    try {
                        bin.readChannel(this.channel);
                    }catch (oome) {
                         throw new RuntimeException(e.type + " 0x" + EbmlUtil.toHexString(bin.id) + " size: " + Long.toHexString(bin.dataLen) + " offset: 0x" + Long.toHexString(e.offset), oome);
                    }
                this.trace.peekFirst().add(e);
            } else if (stjs.isInstanceOf(e.constructor, EbmlVoid)) {
                (e).skip(this.channel);
            } else {
                 throw new RuntimeException("Currently there are no elements that are neither Master nor Binary, should never actually get here");
            }
        }
         while (this.trace.peekFirst() != null)
            this.closeElem(this.trace.removeFirst(), tree);
        return tree;
    };
    prototype.possibleChild = function(parent, child) {
        if (parent != null && MKVType.Cluster.equals(parent.type) && child != null && !MKVType.Cluster.equals(child.type) && !MKVType.Info.equals(child.type) && !MKVType.SeekHead.equals(child.type) && !MKVType.Tracks.equals(child.type) && !MKVType.Cues.equals(child.type) && !MKVType.Attachments.equals(child.type) && !MKVType.Tags.equals(child.type) && !MKVType.Chapters.equals(child.type)) 
            return true;
        return MKVType.possibleChild(parent, child);
    };
    prototype.openElem = function(e) {};
    prototype.closeElem = function(e, tree) {
        if (this.trace.peekFirst() == null) {
            tree.add(e);
        } else {
            this.trace.peekFirst().add(e);
        }
    };
    prototype.nextElement = function() {
        var offset = this.channel.position();
        if (offset >= this.channel.size()) 
            return null;
        var typeId = MKVParser.readEbmlId(this.channel);
         while ((typeId == null && !this.isKnownType(typeId)) && offset < this.channel.size()){
            offset++;
            this.channel.setPosition(offset);
            typeId = MKVParser.readEbmlId(this.channel);
        }
        var dataLen = MKVParser.readEbmlInt(this.channel);
        var elem = MKVType.createById(typeId, offset);
        elem.offset = offset;
        elem.typeSizeLength = (((this.channel.position() - offset)) | 0);
        elem.dataOffset = this.channel.position();
        elem.dataLen = ((dataLen) | 0);
        return elem;
    };
    prototype.isKnownType = function(b) {
        if (!this.trace.isEmpty() && MKVType.Cluster.equals(this.trace.peekFirst().type)) 
            return true;
        return MKVType.isSpecifiedHeader(b);
    };
    /**
     *  Reads an EBML id from the channel. EBML ids have length encoded inside of them For instance, all one-byte ids have first byte set to '1', like 0xA3 or 0xE7, whereas the two-byte ids have first
     *  byte set to '0' and second byte set to '1', thus: 0x42 0x86  or 0x42 0xF7
     *  
     *  @return byte array filled with the ebml id
     *  @throws IOException
     */
    constructor.readEbmlId = function(source) {
        if (source.position() == source.size()) 
            return null;
        var buffer = ByteBuffer.allocate(8);
        buffer.setLimit(1);
        source.read(buffer);
        buffer.flip();
        var firstByte = buffer.get();
        var numBytes = EbmlUtil.computeLength(firstByte);
        if (numBytes == 0) 
            return null;
        if (numBytes > 1) {
            buffer.setLimit(numBytes);
            source.read(buffer);
        }
        buffer.flip();
        var val = ByteBuffer.allocate(buffer.remaining());
        val.putBuf(buffer);
        return val.array();
    };
    constructor.readEbmlInt = function(source) {
        var buffer = ByteBuffer.allocate(8);
        buffer.setLimit(1);
        source.read(buffer);
        buffer.flip();
        var firstByte = stjs.trunc(buffer.get());
        var length = EbmlUtil.computeLength(firstByte);
        if (length == 0) 
             throw new RuntimeException("Invalid ebml integer size.");
        buffer.setLimit(length);
        source.read(buffer);
        buffer.setPosition(1);
        var value = firstByte & (255 >>> length);
        length--;
         while (length > 0){
            value = (value << 8) | (buffer.get() & 255);
            length--;
        }
        return value;
    };
}, {channel: "SeekableByteChannel", trace: {name: "LinkedList", arguments: ["EbmlMaster"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed under FreeBSD License
 *  
 *  EBML IO implementation
 *  
 *  @author The JCodec project
 *  
 */
var SeekHeadFactory = function() {
    this.a = new ArrayList();
};
SeekHeadFactory = stjs.extend(SeekHeadFactory, null, [], function(constructor, prototype) {
    prototype.a = null;
    prototype.currentDataOffset = 0;
    prototype.add = function(e) {
        var z = SeekHeadFactory.SeekMock.make(e);
        z.dataOffset = this.currentDataOffset;
        z.seekPointerSize = EbmlUint.calculatePayloadSize(z.dataOffset);
        this.currentDataOffset += z.size;
        this.a.add(z);
    };
    prototype.indexSeekHead = function() {
        var seekHeadSize = this.computeSeekHeadSize();
        var seekHead = MKVType.createByType(MKVType.SeekHead);
        for (var iterator$z = this.a.iterator(); iterator$z.hasNext(); ) {
            var z = iterator$z.next();
            var seek = MKVType.createByType(MKVType.Seek);
            var seekId = MKVType.createByType(MKVType.SeekID);
            seekId.setBuf(ByteBuffer.wrap(z.id));
            seek.add(seekId);
            var seekPosition = MKVType.createByType(MKVType.SeekPosition);
            seekPosition.setUint(z.dataOffset + seekHeadSize);
            if (seekPosition.data.limit() != z.seekPointerSize) 
                System.err.println("estimated size of seekPosition differs from the one actually used. ElementId: " + EbmlUtil.toHexString(z.id) + " " + seekPosition.getData().limit() + " vs " + z.seekPointerSize);
            seek.add(seekPosition);
            seekHead.add(seek);
        }
        var mux = seekHead.getData();
        if (mux.limit() != seekHeadSize) 
            System.err.println("estimated size of seekHead differs from the one actually used. " + mux.limit() + " vs " + seekHeadSize);
        return seekHead;
    };
    prototype.computeSeekHeadSize = function() {
        var seekHeadSize = this.estimateSize();
        var reindex = false;
        do {
            reindex = false;
            for (var iterator$z = this.a.iterator(); iterator$z.hasNext(); ) {
                var z = iterator$z.next();
                var minSize = EbmlUint.calculatePayloadSize(z.dataOffset + seekHeadSize);
                if (minSize > z.seekPointerSize) {
                    System.out.println("Size " + seekHeadSize + " seems too small for element " + EbmlUtil.toHexString(z.id) + " increasing size by one.");
                    z.seekPointerSize += 1;
                    seekHeadSize += 1;
                    reindex = true;
                    break;
                } else if (minSize < z.seekPointerSize) {
                     throw new RuntimeException("Downsizing the index is not well thought through.");
                }
            }
        } while (reindex);
        return seekHeadSize;
    };
    prototype.estimateSize = function() {
        var s = MKVType.SeekHead.id.length + 1;
        s += SeekHeadFactory.estimeteSeekSize(this.a.get(0).id.length, 1);
        for (var i = 1; i < this.a.size(); i++) {
            s += SeekHeadFactory.estimeteSeekSize(this.a.get(i).id.length, this.a.get(i).seekPointerSize);
        }
        return s;
    };
    constructor.estimeteSeekSize = function(idLength, offsetSizeInBytes) {
        var seekIdSize = MKVType.SeekID.id.length + EbmlUtil.ebmlLength(idLength) + idLength;
        var seekPositionSize = MKVType.SeekPosition.id.length + EbmlUtil.ebmlLength(offsetSizeInBytes) + offsetSizeInBytes;
        var seekSize = MKVType.Seek.id.length + EbmlUtil.ebmlLength(seekIdSize + seekPositionSize) + seekIdSize + seekPositionSize;
        return seekSize;
    };
    constructor.SeekMock = function() {};
    constructor.SeekMock = stjs.extend(constructor.SeekMock, null, [], function(constructor, prototype) {
        prototype.dataOffset = 0;
        prototype.id = null;
        prototype.size = 0;
        prototype.seekPointerSize = 0;
        constructor.make = function(e) {
            var z = new SeekHeadFactory.SeekMock();
            z.id = e.id;
            z.size = ((e.size()) | 0);
            return z;
        };
    }, {id: "Int8Array"}, {});
}, {a: {name: "List", arguments: ["SeekHeadFactory.SeekMock"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Mp3Decoder = function() {
    this.filter = [null, null];
    this.frameData = ByteBuffer.allocate(4096);
    this.samples = new Float32Array(32);
    this.mdctIn = new Float32Array(18);
    this.mdctOut = new Float32Array(36);
    this.dequant = Array.apply(null, Array(2)).map(function() {
        return new Float32Array(576);
    });
    this.tmpOut = Array.apply(null, Array(2)).map(function() {
        return new Int16Array(576);
    });
};
Mp3Decoder = stjs.extend(Mp3Decoder, null, [AudioDecoder], function(constructor, prototype) {
    constructor.ALL_TRUE = new Int8Array([true, true, true, true]);
    constructor.SAMPLES_PER_BAND = 18;
    constructor.NUM_BANDS = 32;
    prototype.filter = null;
    prototype.initialized = false;
    constructor.fourByThree = (4.0 / 3.0);
    prototype.prevBlk = null;
    prototype.frameData = null;
    prototype.channels = 0;
    prototype.sfreq = 0;
    prototype.samples = null;
    prototype.mdctIn = null;
    prototype.mdctOut = null;
    prototype.dequant = null;
    prototype.tmpOut = null;
    prototype.init = function(header) {
        var scalefactor = 32700.0;
        this.channels = (header.mode == MpaConst.SINGLE_CHANNEL) ? 1 : 2;
        this.filter[0] = new ChannelSynthesizer(0, scalefactor);
        if (this.channels == 2) 
            this.filter[1] = new ChannelSynthesizer(1, scalefactor);
        this.prevBlk = Array.apply(null, Array(2)).map(function() {
            return new Float32Array(Mp3Decoder.NUM_BANDS * Mp3Decoder.SAMPLES_PER_BAND);
        });
        this.sfreq = header.sampleFreq + ((header.version == MpaConst.MPEG1) ? 3 : (header.version == MpaConst.MPEG25_LSF) ? 6 : 0);
        for (var ch = 0; ch < 2; ch++) 
            Arrays.fill(this.prevBlk[ch], 0.0);
        this.initialized = true;
    };
    prototype.decodeGranule = function(header, output, si, br, scalefac, grInd) {
        Arrays.fill(this.dequant[0], 0);
        Arrays.fill(this.dequant[1], 0);
        for (var ch = 0; ch < this.channels; ch++) {
            var part2Start = br.position();
            var granule = si.granule[ch][grInd];
            if (header.version == MpaConst.MPEG1) {
                var old = scalefac[ch];
                var scfi = grInd == 0 ? Mp3Decoder.ALL_TRUE : si.scfsi[ch];
                scalefac[ch] = Mp3Bitstream.readScaleFactors(br, si.granule[ch][grInd], scfi);
                this.mergeScaleFac(scalefac[ch], old, scfi);
            } else {
                scalefac[ch] = Mp3Bitstream.readLSFScaleFactors(br, header, granule, ch);
            }
            var coeffs = new Int32Array(Mp3Decoder.NUM_BANDS * Mp3Decoder.SAMPLES_PER_BAND + 4);
            var nonzero = Mp3Bitstream.readCoeffs(br, granule, ch, part2Start, this.sfreq, coeffs);
            this.dequantizeCoeffs(coeffs, nonzero, granule, scalefac[ch], this.dequant[ch]);
        }
        var msStereo = ((header.mode == MpaConst.JOINT_STEREO) && ((header.modeExtension & 2) != 0));
        if (msStereo && this.channels == 2) 
            this.decodeMsStereo(header, si.granule[0][grInd], scalefac, this.dequant);
        for (var ch = 0; ch < this.channels; ch++) {
            var out = this.dequant[ch];
            var granule = si.granule[ch][grInd];
            this.antialias(granule, out);
            this.mdctDecode(ch, granule, out);
            for (var sb18 = 18; sb18 < 576; sb18 += 36) {
                for (var ss = 1; ss < Mp3Decoder.SAMPLES_PER_BAND; ss += 2) 
                    out[sb18 + ss] = -out[sb18 + ss];
            }
            for (var ss = 0, off = 0; ss < Mp3Decoder.SAMPLES_PER_BAND; ss++ , off += 32) {
                for (var sb18 = 0, sb = 0; sb18 < 576; sb18 += 18 , sb++) {
                    this.samples[sb] = out[sb18 + ss];
                }
                this.filter[ch].synthesize(this.samples, this.tmpOut[ch], off);
            }
        }
        if (this.channels == 2) {
            Mp3Decoder.appendSamplesInterleave(output, this.tmpOut[0], this.tmpOut[1], 576);
        } else {
            Mp3Decoder.appendSamples(output, this.tmpOut[0], 576);
        }
    };
    constructor.appendSamples = function(buf, f, n) {
        for (var i = 0; i < n; i++) {
            buf.putShort(f[i]);
        }
    };
    constructor.appendSamplesInterleave = function(buf, f0, f1, n) {
        for (var i = 0; i < n; i++) {
            buf.putShort(f0[i]);
            buf.putShort(f1[i]);
        }
    };
    prototype.mergeScaleFac = function(sf, old, scfsi) {
        if (!scfsi[0]) {
            for (var i = 0; i < 6; i++) 
                sf.large[i] = old.large[i];
        }
        if (!scfsi[1]) {
            for (var i = 6; i < 11; i++) 
                sf.large[i] = old.large[i];
        }
        if (!scfsi[2]) {
            for (var i = 11; i < 16; i++) 
                sf.large[i] = old.large[i];
        }
        if (!scfsi[3]) {
            for (var i = 16; i < 21; i++) 
                sf.large[i] = old.large[i];
        }
    };
    prototype.dequantizeCoeffs = function(input, nonzero, granule, scalefac, out) {
        var globalGain = Math.pow(2.0, (0.25 * (granule.globalGain - 210.0)));
        if (granule.windowSwitchingFlag && (granule.blockType == 2)) {
            if (granule.mixedBlockFlag) {
                this.dequantMixed(input, nonzero, granule, scalefac, globalGain, out);
            } else {
                this.dequantShort(input, nonzero, granule, scalefac, globalGain, out);
            }
        } else {
            this.dequantLong(input, nonzero, granule, scalefac, globalGain, out);
        }
    };
    prototype.dequantMixed = function(input, nonzero, granule, scalefac, globalGain, out) {
        var i = 0;
        for (var sfb = 0; sfb < 8 && i < nonzero; sfb++) {
            for (; i < MpaConst.sfbLong[this.sfreq][sfb + 1] && i < nonzero; i++) {
                var idx = (scalefac.large[sfb] + (granule.preflag ? MpaConst.pretab[sfb] : 0)) << granule.scalefacScale;
                out[i] = globalGain * this.pow43(input[i]) * MpaConst.quantizerTab[idx];
            }
        }
        for (var sfb = 3; sfb < 12 && i < nonzero; sfb++) {
            var sfbSz = MpaConst.sfbShort[this.sfreq][sfb + 1] - MpaConst.sfbShort[this.sfreq][sfb];
            var sfbStart = i;
            for (var wnd = 0; wnd < 3; wnd++) {
                for (var j = 0; j < sfbSz && i < nonzero; j++ , i++) {
                    var idx = (scalefac.small[wnd][sfb] << granule.scalefacScale) + (granule.subblockGain[wnd] << 2);
                    out[sfbStart + j * 3 + wnd] = globalGain * this.pow43(input[i]) * MpaConst.quantizerTab[idx];
                }
            }
        }
    };
    prototype.dequantShort = function(input, nonzero, granule, scalefac, globalGain, out) {
        for (var sfb = 0, i = 0; i < nonzero; sfb++) {
            var sfbSz = MpaConst.sfbShort[this.sfreq][sfb + 1] - MpaConst.sfbShort[this.sfreq][sfb];
            var sfbStart = i;
            for (var wnd = 0; wnd < 3; wnd++) {
                for (var j = 0; j < sfbSz && i < nonzero; j++ , i++) {
                    var idx = (scalefac.small[wnd][sfb] << granule.scalefacScale) + (granule.subblockGain[wnd] << 2);
                    out[sfbStart + j * 3 + wnd] = globalGain * this.pow43(input[i]) * MpaConst.quantizerTab[idx];
                }
            }
        }
    };
    prototype.dequantLong = function(input, nonzero, granule, scalefac, globalGain, out) {
        for (var i = 0, sfb = 0; i < nonzero; i++) {
            if (i == MpaConst.sfbLong[this.sfreq][sfb + 1]) 
                ++sfb;
            var idx = (scalefac.large[sfb] + (granule.preflag ? MpaConst.pretab[sfb] : 0)) << granule.scalefacScale;
            out[i] = globalGain * this.pow43(input[i]) * MpaConst.quantizerTab[idx];
        }
    };
    prototype.pow43 = function(val) {
        if (val == 0) {
            return 0.0;
        } else {
            var sign = 1 - ((val >>> 31) << 1);
            var abs = MathUtil.abs(val);
            if (abs < MpaConst.power43Tab.length) 
                return sign * MpaConst.power43Tab[abs];
             else 
                return sign * Math.pow(abs, Mp3Decoder.fourByThree);
        }
    };
    prototype.decodeMsStereo = function(header, granule, scalefac, ro) {
        for (var i = 0; i < 576; i++) {
            var a = ro[0][i];
            var b = ro[1][i];
            ro[0][i] = (a + b) * 0.70710677;
            ro[1][i] = (a - b) * 0.70710677;
        }
    };
    prototype.antialias = function(granule, out) {
        if (granule.windowSwitchingFlag && (granule.blockType == 2) && !granule.mixedBlockFlag) 
            return;
        var bands = granule.windowSwitchingFlag && granule.mixedBlockFlag && (granule.blockType == 2) ? 1 : 31;
        for (var band = 0, bandStart = 0; band < bands; band++ , bandStart += 18) {
            for (var sample = 0; sample < 8; sample++) {
                var src_idx1 = bandStart + 17 - sample;
                var src_idx2 = bandStart + 18 + sample;
                var bu = out[src_idx1];
                var bd = out[src_idx2];
                out[src_idx1] = (bu * MpaConst.cs[sample]) - (bd * MpaConst.ca[sample]);
                out[src_idx2] = (bd * MpaConst.cs[sample]) + (bu * MpaConst.ca[sample]);
            }
        }
    };
    prototype.mdctDecode = function(ch, granule, out) {
        for (var sb18 = 0; sb18 < 576; sb18 += 18) {
            var blockType = (granule.windowSwitchingFlag && granule.mixedBlockFlag && (sb18 < 36)) ? 0 : granule.blockType;
            for (var cc = 0; cc < 18; cc++) 
                this.mdctIn[cc] = out[cc + sb18];
            if (blockType == 2) {
                Mp3Mdct.threeShort(this.mdctIn, this.mdctOut);
            } else {
                Mp3Mdct.oneLong(this.mdctIn, this.mdctOut);
                for (var i = 0; i < 36; i++) 
                    this.mdctOut[i] *= MpaConst.win[blockType][i];
            }
            for (var i = 0; i < 18; i++) {
                out[i + sb18] = this.mdctOut[i] + this.prevBlk[ch][sb18 + i];
                this.prevBlk[ch][sb18 + i] = this.mdctOut[18 + i];
            }
        }
    };
    prototype.decodeFrame = function(frame, dst) {
        var header = MpaHeader.read_header(frame);
        if (!this.initialized) {
            this.init(header);
        }
        var intensityStereo = ((header.mode == MpaConst.JOINT_STEREO) && ((header.modeExtension & 1) != 0));
        if (intensityStereo) 
             throw new RuntimeException("Intensity stereo is not supported.");
        dst.order(ByteOrder.LITTLE_ENDIAN);
        var si = Mp3Bitstream.readSideInfo(header, frame, this.channels);
        var reserve = this.frameData.position();
        this.frameData.putBuf(NIOUtils.read(frame, header.frameBytes));
        this.frameData.flip();
        if (header.protectionBit == 0) {
            frame.getShort();
        }
        NIOUtils.skip(this.frameData, reserve - si.mainDataBegin);
        var br = BitReader.createBitReader(this.frameData);
        var scalefac = Array(2);
        this.decodeGranule(header, dst, si, br, scalefac, 0);
        if (header.version == MpaConst.MPEG1) 
            this.decodeGranule(header, dst, si, br, scalefac, 1);
        br.terminate();
        NIOUtils.relocateLeftover(this.frameData);
        dst.flip();
        return new AudioBuffer(dst, null, 1);
    };
    prototype.getCodecMeta = function(data) {
        var header = MpaHeader.read_header(data.duplicate());
        var format = new AudioFormat(MpaConst.frequencies[header.version][header.sampleFreq], 16, header.mode == MpaConst.SINGLE_CHANNEL ? 1 : 2, true, false);
        return AudioCodecMeta.fromAudioFormat(format);
    };
}, {ALL_TRUE: "Int8Array", filter: "Array", prevBlk: "Array", frameData: "ByteBuffer", samples: "Float32Array", mdctIn: "Float32Array", mdctOut: "Float32Array", dequant: "Array", tmpOut: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 1/2 Decoder
 *  
 *  Supports I/P/B frames, frame/field/interlaced frame encoding
 *  
 *  Conforms to H.262 ( ISO/IEC 13818-2, ISO/IEC 11172-2 ) specifications
 *  
 *  @author The JCodec project
 *  
 */
var MPEGDecoder = function() {
    VideoDecoder.call(this);
    this.refFrames = Array(2);
    this.refFields = Array(2);
};
MPEGDecoder = stjs.extend(MPEGDecoder, VideoDecoder, [], function(constructor, prototype) {
    prototype.sh = null;
    prototype.gh = null;
    prototype.refFrames = null;
    prototype.refFields = null;
    constructor.Context = function() {
        this.intra_dc_predictor = new Int32Array(3);
    };
    constructor.Context = stjs.extend(constructor.Context, null, [], function(constructor, prototype) {
        prototype.intra_dc_predictor = null;
        prototype.mbWidth = 0;
        prototype.mbNo = 0;
        prototype.codedWidth = 0;
        prototype.codedHeight = 0;
        prototype.mbHeight = 0;
        prototype.color = null;
        prototype.lastPredB = null;
        prototype.qMats = null;
        prototype.scan = null;
        prototype.picWidth = 0;
        prototype.picHeight = 0;
    }, {intra_dc_predictor: "Int32Array", color: "ColorSpace", lastPredB: "MPEGConst.MBType", qMats: "Array", scan: "Int32Array"}, {});
    prototype.decodeFrame = function(buffer, buf) {
        var ph = this.readHeader(buffer);
        if (this.refFrames[0] == null && ph.picture_coding_type > 1 || this.refFrames[1] == null && ph.picture_coding_type > 2) {
             throw new RuntimeException("Not enough references to decode " + (ph.picture_coding_type == 1 ? "P" : "B") + " frame");
        }
        var context = this.initContext(this.sh, ph);
        var pic = new Picture(context.codedWidth, context.codedHeight, buf, null, context.color, 0, new Rect(0, 0, context.picWidth, context.picHeight));
        if (ph.pictureCodingExtension != null && ph.pictureCodingExtension.picture_structure != PictureCodingExtension.Frame) {
            this.decodePicture(context, ph, buffer, buf, ph.pictureCodingExtension.picture_structure - 1, 1);
            ph = this.readHeader(buffer);
            context = this.initContext(this.sh, ph);
            this.decodePicture(context, ph, buffer, buf, ph.pictureCodingExtension.picture_structure - 1, 1);
        } else {
            this.decodePicture(context, ph, buffer, buf, 0, 0);
        }
        if (ph.picture_coding_type == MPEGConst.IntraCoded || ph.picture_coding_type == MPEGConst.PredictiveCoded) {
            var unused = this.refFrames[1];
            this.refFrames[1] = this.refFrames[0];
            this.refFrames[0] = this.copyAndCreateIfNeeded(pic, unused);
        }
        return pic;
    };
    prototype.copyAndCreateIfNeeded = function(src, dst) {
        if (dst == null || !dst.compatible(src)) {
            dst = src.createCompatible();
        }
        dst.copyFrom(src);
        return dst;
    };
    prototype.readHeader = function(buffer) {
        var ph = null;
        var segment;
        var fork = buffer.duplicate();
         while ((segment = MPEGUtil.nextSegment(fork)) != null){
            var code = segment.getInt() & 255;
            if (code == MPEGConst.SEQUENCE_HEADER_CODE) {
                var newSh = SequenceHeader.read(segment);
                if (this.sh != null) {
                    newSh.copyExtensions(this.sh);
                }
                this.sh = newSh;
            } else if (code == MPEGConst.GROUP_START_CODE) {
                this.gh = GOPHeader.read(segment);
            } else if (code == MPEGConst.PICTURE_START_CODE) {
                ph = PictureHeader.read(segment);
            } else if (code == MPEGConst.EXTENSION_START_CODE) {
                var extType = segment.getAt(4) >> 4;
                if (extType == SequenceExtension.Sequence_Extension || extType == SequenceScalableExtension.Sequence_Scalable_Extension || extType == SequenceDisplayExtension.Sequence_Display_Extension) 
                    SequenceHeader.readExtension(segment, this.sh);
                 else 
                    PictureHeader.readExtension(segment, ph, this.sh);
            } else if (code == MPEGConst.USER_DATA_START_CODE) {} else {
                break;
            }
            buffer.setPosition(fork.position());
        }
        return ph;
    };
    prototype.initContext = function(sh, ph) {
        var context = new MPEGDecoder.Context();
        context.codedWidth = (sh.horizontal_size + 15) & ~15;
        context.codedHeight = MPEGDecoder.getCodedHeight(sh, ph);
        context.mbWidth = (sh.horizontal_size + 15) >> 4;
        context.mbHeight = (sh.vertical_size + 15) >> 4;
        context.picWidth = sh.horizontal_size;
        context.picHeight = sh.vertical_size;
        var chromaFormat = SequenceExtension.Chroma420;
        if (sh.sequenceExtension != null) 
            chromaFormat = sh.sequenceExtension.chroma_format;
        context.color = this.getColor(chromaFormat);
        context.scan = MPEGConst.scan[ph.pictureCodingExtension == null ? 0 : ph.pictureCodingExtension.alternate_scan];
        var inter = sh.non_intra_quantiser_matrix == null ? this.zigzag(MPEGConst.defaultQMatInter, context.scan) : sh.non_intra_quantiser_matrix;
        var intra = sh.intra_quantiser_matrix == null ? this.zigzag(MPEGConst.defaultQMatIntra, context.scan) : sh.intra_quantiser_matrix;
        context.qMats = [inter, inter, intra, intra];
        if (ph.quantMatrixExtension != null) {
            if (ph.quantMatrixExtension.non_intra_quantiser_matrix != null) 
                context.qMats[0] = ph.quantMatrixExtension.non_intra_quantiser_matrix;
            if (ph.quantMatrixExtension.chroma_non_intra_quantiser_matrix != null) 
                context.qMats[1] = ph.quantMatrixExtension.chroma_non_intra_quantiser_matrix;
            if (ph.quantMatrixExtension.intra_quantiser_matrix != null) 
                context.qMats[2] = ph.quantMatrixExtension.intra_quantiser_matrix;
            if (ph.quantMatrixExtension.chroma_intra_quantiser_matrix != null) 
                context.qMats[3] = ph.quantMatrixExtension.chroma_intra_quantiser_matrix;
        }
        return context;
    };
    prototype.zigzag = function(array, scan) {
        var result = new Int32Array(64);
        for (var i = 0; i < scan.length; i++) 
            result[i] = array[scan[i]];
        return result;
    };
    constructor.getCodedHeight = function(sh, ph) {
        var field = ph.pictureCodingExtension != null && ph.pictureCodingExtension.picture_structure != PictureCodingExtension.Frame ? 1 : 0;
        return (((sh.vertical_size >> field) + 15) & ~15) << field;
    };
    prototype.decodePicture = function(context, ph, buffer, buf, vertOff, vertStep) {
        var planeSize = context.codedWidth * context.codedHeight;
        if (buf.length < 3 || buf[0].length < planeSize || buf[1].length < planeSize || buf[2].length < planeSize) {
             throw new RuntimeException("ByteBuffer too small to hold output picture [" + context.codedWidth + "x" + context.codedHeight + "]");
        }
        try {
            var segment;
             while ((segment = MPEGUtil.nextSegment(buffer)) != null){
                var startCode = segment.getAt(3) & 255;
                if (startCode >= MPEGConst.SLICE_START_CODE_FIRST && startCode <= MPEGConst.SLICE_START_CODE_LAST) {
                    this.doDecodeSlice(context, ph, buf, vertOff, vertStep, segment);
                } else if (startCode >= 179 && startCode != 182 && startCode != 183) {
                     throw new RuntimeException("Unexpected start code " + startCode);
                } else if (startCode == 0) {
                    buffer.reset();
                    break;
                }
            }
            var pic = Picture.createPicture(context.codedWidth, context.codedHeight, buf, context.color);
            if ((ph.picture_coding_type == MPEGConst.IntraCoded || ph.picture_coding_type == MPEGConst.PredictiveCoded) && ph.pictureCodingExtension != null && ph.pictureCodingExtension.picture_structure != PictureCodingExtension.Frame) {
                this.refFields[ph.pictureCodingExtension.picture_structure - 1] = this.copyAndCreateIfNeeded(pic, this.refFields[ph.pictureCodingExtension.picture_structure - 1]);
            }
            return pic;
        }catch (e) {
             throw new RuntimeException(e);
        }
    };
    prototype.doDecodeSlice = function(context, ph, buf, vertOff, vertStep, segment) {
        var startCode = segment.getAt(3) & 255;
        var dup = segment.duplicate();
        dup.setPosition(4);
        try {
            this.decodeSlice(ph, startCode, context, buf, BitReader.createBitReader(dup), vertOff, vertStep);
        }catch (e) {
            e.printStackTrace();
        }
    };
    prototype.getColor = function(chromaFormat) {
        switch (chromaFormat) {
            case SequenceExtension.Chroma420:
                return ColorSpace.YUV420;
            case SequenceExtension.Chroma422:
                return ColorSpace.YUV422;
            case SequenceExtension.Chroma444:
                return ColorSpace.YUV444;
        }
        return null;
    };
    prototype.decodeSlice = function(ph, verticalPos, context, buf, _in, vertOff, vertStep) {
        var stride = context.codedWidth;
        this.resetDCPredictors(context, ph);
        var mbRow = verticalPos - 1;
        if (this.sh.vertical_size > 2800) {
            mbRow += (_in.readNBit(3) << 7);
        }
        if (this.sh.sequenceScalableExtension != null && this.sh.sequenceScalableExtension.scalable_mode == SequenceScalableExtension.DATA_PARTITIONING) {
            var priorityBreakpoint = _in.readNBit(7);
        }
        var qScaleCode = _in.readNBit(5);
        if (_in.read1Bit() == 1) {
            var intraSlice = _in.read1Bit();
            _in.skip(7);
             while (_in.read1Bit() == 1)
                _in.readNBit(8);
        }
        var pred = new MPEGPred(ph.pictureCodingExtension != null ? ph.pictureCodingExtension.f_code : [new Int32Array([ph.forward_f_code, ph.forward_f_code]), new Int32Array([ph.backward_f_code, ph.backward_f_code])], this.sh.sequenceExtension != null ? this.sh.sequenceExtension.chroma_format : SequenceExtension.Chroma420, ph.pictureCodingExtension != null && ph.pictureCodingExtension.top_field_first == 0 ? false : true);
        var ctx = new Int32Array([qScaleCode]);
        for (var prevAddr = mbRow * context.mbWidth - 1; _in.checkNBit(23) != 0; ) {
            prevAddr = this.decodeMacroblock(ph, context, prevAddr, ctx, buf, stride, _in, vertOff, vertStep, pred);
            context.mbNo++;
        }
    };
    prototype.resetDCPredictors = function(context, ph) {
        var rval = 1 << 7;
        if (ph.pictureCodingExtension != null) 
            rval = 1 << (7 + ph.pictureCodingExtension.intra_dc_precision);
        context.intra_dc_predictor[0] = context.intra_dc_predictor[1] = context.intra_dc_predictor[2] = rval;
    };
    prototype.decodeMacroblock = function(ph, context, prevAddr, qScaleCode, buf, stride, bits, vertOff, vertStep, pred) {
        var mbAddr = prevAddr;
         while (bits.checkNBit(11) == 8){
            bits.skip(11);
            mbAddr += 33;
        }
        mbAddr += MPEGConst.vlcAddressIncrement.readVLC(bits) + 1;
        var chromaFormat = SequenceExtension.Chroma420;
        if (this.sh.sequenceExtension != null) 
            chromaFormat = this.sh.sequenceExtension.chroma_format;
        for (var i = prevAddr + 1; i < mbAddr; i++) {
            var predFwd = [new Int32Array(256), new Int32Array(1 << (chromaFormat + 5)), new Int32Array(1 << (chromaFormat + 5))];
            var mbX = i % context.mbWidth;
            var mbY = stjs.trunc(i / context.mbWidth);
            if (ph.picture_coding_type == MPEGConst.PredictiveCoded) 
                pred.reset();
            this.mvZero(context, ph, pred, mbX, mbY, predFwd);
            this.put(predFwd, buf, stride, chromaFormat, mbX, mbY, context.codedWidth, context.codedHeight >> vertStep, vertOff, vertStep);
        }
        var vlcMBType = SequenceScalableExtension.vlcMBType(ph.picture_coding_type, this.sh.sequenceScalableExtension);
        var mbTypeVal = SequenceScalableExtension.mbTypeVal(ph.picture_coding_type, this.sh.sequenceScalableExtension);
        var mbType = mbTypeVal[vlcMBType.readVLC(bits)];
        if (mbType.macroblock_intra != 1 || (mbAddr - prevAddr) > 1) {
            this.resetDCPredictors(context, ph);
        }
        var spatial_temporal_weight_code = 0;
        if (mbType.spatial_temporal_weight_code_flag == 1 && ph.pictureSpatialScalableExtension != null && ph.pictureSpatialScalableExtension.spatial_temporal_weight_code_table_index != 0) {
            spatial_temporal_weight_code = bits.readNBit(2);
        }
        var motion_type = -1;
        if (mbType.macroblock_motion_forward != 0 || mbType.macroblock_motion_backward != 0) {
            if (ph.pictureCodingExtension == null || ph.pictureCodingExtension.picture_structure == PictureCodingExtension.Frame && ph.pictureCodingExtension.frame_pred_frame_dct == 1) 
                motion_type = 2;
             else 
                motion_type = bits.readNBit(2);
        }
        var dctType = 0;
        if (ph.pictureCodingExtension != null && ph.pictureCodingExtension.picture_structure == PictureCodingExtension.Frame && ph.pictureCodingExtension.frame_pred_frame_dct == 0 && (mbType.macroblock_intra != 0 || mbType.macroblock_pattern != 0)) {
            dctType = bits.read1Bit();
        }
        if (mbType.macroblock_quant != 0) {
            qScaleCode[0] = bits.readNBit(5);
        }
        var concealmentMv = ph.pictureCodingExtension != null && ph.pictureCodingExtension.concealment_motion_vectors != 0;
        var predFwd = null;
        var mbX = mbAddr % context.mbWidth;
        var mbY = stjs.trunc(mbAddr / context.mbWidth);
        if (mbType.macroblock_intra == 1) {
            if (concealmentMv) {} else 
                pred.reset();
        } else if (mbType.macroblock_motion_forward != 0) {
            var refIdx = ph.picture_coding_type == MPEGConst.PredictiveCoded ? 0 : 1;
            predFwd = [new Int32Array(256), new Int32Array(1 << (chromaFormat + 5)), new Int32Array(1 << (chromaFormat + 5))];
            if (ph.pictureCodingExtension == null || ph.pictureCodingExtension.picture_structure == PictureCodingExtension.Frame) {
                pred.predictInFrame(this.refFrames[refIdx], mbX << 4, mbY << 4, predFwd, bits, motion_type, 0, spatial_temporal_weight_code);
            } else {
                if (ph.picture_coding_type == MPEGConst.PredictiveCoded) {
                    pred.predictInField(this.refFields, mbX << 4, mbY << 4, predFwd, bits, motion_type, 0, ph.pictureCodingExtension.picture_structure - 1);
                } else {
                    pred.predictInField([this.refFrames[refIdx], this.refFrames[refIdx]], mbX << 4, mbY << 4, predFwd, bits, motion_type, 0, ph.pictureCodingExtension.picture_structure - 1);
                }
            }
        } else if (ph.picture_coding_type == MPEGConst.PredictiveCoded) {
            predFwd = [new Int32Array(256), new Int32Array(1 << (chromaFormat + 5)), new Int32Array(1 << (chromaFormat + 5))];
            pred.reset();
            this.mvZero(context, ph, pred, mbX, mbY, predFwd);
        }
        var predBack = null;
        if (mbType.macroblock_motion_backward != 0) {
            predBack = [new Int32Array(256), new Int32Array(1 << (chromaFormat + 5)), new Int32Array(1 << (chromaFormat + 5))];
            if (ph.pictureCodingExtension == null || ph.pictureCodingExtension.picture_structure == PictureCodingExtension.Frame) {
                pred.predictInFrame(this.refFrames[0], mbX << 4, mbY << 4, predBack, bits, motion_type, 1, spatial_temporal_weight_code);
            } else {
                pred.predictInField([this.refFrames[0], this.refFrames[0]], mbX << 4, mbY << 4, predBack, bits, motion_type, 1, ph.pictureCodingExtension.picture_structure - 1);
            }
        }
        context.lastPredB = mbType;
        var pp = mbType.macroblock_intra == 1 ? [new Int32Array(256), new Int32Array(1 << (chromaFormat + 5)), new Int32Array(1 << (chromaFormat + 5))] : MPEGDecoder.buildPred(predFwd, predBack);
        if (mbType.macroblock_intra != 0 && concealmentMv) 
            Preconditions.checkState(1 == bits.read1Bit());
        var cbp = mbType.macroblock_intra == 1 ? 4095 : 0;
        if (mbType.macroblock_pattern != 0) {
            cbp = this.readCbPattern(bits);
        }
        var vlcCoeff = MPEGConst.vlcCoeff0;
        if (ph.pictureCodingExtension != null && mbType.macroblock_intra == 1 && ph.pictureCodingExtension.intra_vlc_format == 1) 
            vlcCoeff = MPEGConst.vlcCoeff1;
        var qScaleTab = ph.pictureCodingExtension != null && ph.pictureCodingExtension.q_scale_type == 1 ? MPEGConst.qScaleTab2 : MPEGConst.qScaleTab1;
        var qScale = qScaleTab[qScaleCode[0]];
        var intra_dc_mult = 8;
        if (ph.pictureCodingExtension != null) 
            intra_dc_mult = 8 >> ph.pictureCodingExtension.intra_dc_precision;
        var blkCount = 6 + (chromaFormat == SequenceExtension.Chroma420 ? 0 : (chromaFormat == SequenceExtension.Chroma422 ? 2 : 6));
        var block = new Int32Array(64);
        for (var i = 0, cbpMask = 1 << (blkCount - 1); i < blkCount; i++ , cbpMask >>= 1) {
            if ((cbp & cbpMask) == 0) 
                continue;
            var qmat = context.qMats[(i >= 4 ? 1 : 0) + (mbType.macroblock_intra << 1)];
            if (mbType.macroblock_intra == 1) 
                this.blockIntra(bits, vlcCoeff, block, context.intra_dc_predictor, i, context.scan, this.sh.hasExtensions() || ph.hasExtensions() ? 12 : 8, intra_dc_mult, qScale, qmat);
             else 
                this.blockInter(bits, vlcCoeff, block, context.scan, this.sh.hasExtensions() || ph.hasExtensions() ? 12 : 8, qScale, qmat);
            this.mapBlock(block, pp[MPEGConst.BLOCK_TO_CC[i]], i, dctType, chromaFormat);
        }
        this.put(pp, buf, stride, chromaFormat, mbX, mbY, context.codedWidth, context.codedHeight >> vertStep, vertOff, vertStep);
        return mbAddr;
    };
    prototype.mapBlock = function(block, out, blkIdx, dctType, chromaFormat) {
        var stepVert = chromaFormat == SequenceExtension.Chroma420 && (blkIdx == 4 || blkIdx == 5) ? 0 : dctType;
        var log2stride = blkIdx < 4 ? 4 : 4 - MPEGConst.SQUEEZE_X[chromaFormat];
        var blkIdxExt = blkIdx + (dctType << 4);
        var x = MPEGConst.BLOCK_POS_X[blkIdxExt];
        var y = MPEGConst.BLOCK_POS_Y[blkIdxExt];
        var off = (y << log2stride) + x, stride = 1 << (log2stride + stepVert);
        for (var i = 0, coeff = 0; i < 8; i++ , coeff += 8) {
            out[off] += block[coeff];
            out[off + 1] += block[coeff + 1];
            out[off + 2] += block[coeff + 2];
            out[off + 3] += block[coeff + 3];
            out[off + 4] += block[coeff + 4];
            out[off + 5] += block[coeff + 5];
            out[off + 6] += block[coeff + 6];
            out[off + 7] += block[coeff + 7];
            off += stride;
        }
    };
    constructor.buildPred = function(predFwd, predBack) {
        if (predFwd != null && predBack != null) {
            MPEGDecoder.avgPred(predFwd, predBack);
            return predFwd;
        } else if (predFwd != null) 
            return predFwd;
         else if (predBack != null) 
            return predBack;
         else 
             throw new RuntimeException("Omited pred _in B-frames --> invalid");
    };
    constructor.avgPred = function(predFwd, predBack) {
        for (var i = 0; i < predFwd.length; i++) {
            for (var j = 0; j < predFwd[i].length; j += 4) {
                predFwd[i][j] = (predFwd[i][j] + predBack[i][j] + 1) >> 1;
                predFwd[i][j + 1] = (predFwd[i][j + 1] + predBack[i][j + 1] + 1) >> 1;
                predFwd[i][j + 2] = (predFwd[i][j + 2] + predBack[i][j + 2] + 1) >> 1;
                predFwd[i][j + 3] = (predFwd[i][j + 3] + predBack[i][j + 3] + 1) >> 1;
            }
        }
    };
    prototype.mvZero = function(context, ph, pred, mbX, mbY, mbPix) {
        if (ph.picture_coding_type == MPEGConst.PredictiveCoded) {
            pred.predict16x16NoMV(this.refFrames[0], mbX << 4, mbY << 4, ph.pictureCodingExtension == null ? PictureCodingExtension.Frame : ph.pictureCodingExtension.picture_structure, 0, mbPix);
        } else {
            var pp = mbPix;
            if (context.lastPredB.macroblock_motion_backward == 1) {
                pred.predict16x16NoMV(this.refFrames[0], mbX << 4, mbY << 4, ph.pictureCodingExtension == null ? PictureCodingExtension.Frame : ph.pictureCodingExtension.picture_structure, 1, pp);
                pp = [new Int32Array(mbPix[0].length), new Int32Array(mbPix[1].length), new Int32Array(mbPix[2].length)];
            }
            if (context.lastPredB.macroblock_motion_forward == 1) {
                pred.predict16x16NoMV(this.refFrames[1], mbX << 4, mbY << 4, ph.pictureCodingExtension == null ? PictureCodingExtension.Frame : ph.pictureCodingExtension.picture_structure, 0, pp);
                if (mbPix != pp) 
                    MPEGDecoder.avgPred(mbPix, pp);
            }
        }
    };
    prototype.put = function(mbPix, buf, stride, chromaFormat, mbX, mbY, width, height, vertOff, vertStep) {
        var chromaStride = (stride + (1 << MPEGConst.SQUEEZE_X[chromaFormat]) - 1) >> MPEGConst.SQUEEZE_X[chromaFormat];
        var chromaMBW = 4 - MPEGConst.SQUEEZE_X[chromaFormat];
        var chromaMBH = 4 - MPEGConst.SQUEEZE_Y[chromaFormat];
        this.putSub(buf[0], (mbY << 4) * (stride << vertStep) + vertOff * stride + (mbX << 4), stride << vertStep, mbPix[0], 4, 4);
        this.putSub(buf[1], (mbY << chromaMBH) * (chromaStride << vertStep) + vertOff * chromaStride + (mbX << chromaMBW), chromaStride << vertStep, mbPix[1], chromaMBW, chromaMBH);
        this.putSub(buf[2], (mbY << chromaMBH) * (chromaStride << vertStep) + vertOff * chromaStride + (mbX << chromaMBW), chromaStride << vertStep, mbPix[2], chromaMBW, chromaMBH);
    };
    prototype.putSub = function(big, off, stride, block, mbW, mbH) {
        var blOff = 0;
        if (mbW == 3) {
            for (var i = 0; i < (1 << mbH); i++) {
                big[off] = MPEGDecoder.clipTo8Bit(block[blOff]);
                big[off + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 1]);
                big[off + 2] = MPEGDecoder.clipTo8Bit(block[blOff + 2]);
                big[off + 3] = MPEGDecoder.clipTo8Bit(block[blOff + 3]);
                big[off + 4] = MPEGDecoder.clipTo8Bit(block[blOff + 4]);
                big[off + 5] = MPEGDecoder.clipTo8Bit(block[blOff + 5]);
                big[off + 6] = MPEGDecoder.clipTo8Bit(block[blOff + 6]);
                big[off + 7] = MPEGDecoder.clipTo8Bit(block[blOff + 7]);
                blOff += 8;
                off += stride;
            }
        } else {
            for (var i = 0; i < (1 << mbH); i++) {
                big[off] = MPEGDecoder.clipTo8Bit(block[blOff]);
                big[off + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 1]);
                big[off + 2] = MPEGDecoder.clipTo8Bit(block[blOff + 2]);
                big[off + 3] = MPEGDecoder.clipTo8Bit(block[blOff + 3]);
                big[off + 4] = MPEGDecoder.clipTo8Bit(block[blOff + 4]);
                big[off + 5] = MPEGDecoder.clipTo8Bit(block[blOff + 5]);
                big[off + 6] = MPEGDecoder.clipTo8Bit(block[blOff + 6]);
                big[off + 7] = MPEGDecoder.clipTo8Bit(block[blOff + 7]);
                big[off + 8] = MPEGDecoder.clipTo8Bit(block[blOff + 8]);
                big[off + 9] = MPEGDecoder.clipTo8Bit(block[blOff + 9]);
                big[off + 10] = MPEGDecoder.clipTo8Bit(block[blOff + 10]);
                big[off + 11] = MPEGDecoder.clipTo8Bit(block[blOff + 11]);
                big[off + 12] = MPEGDecoder.clipTo8Bit(block[blOff + 12]);
                big[off + 13] = MPEGDecoder.clipTo8Bit(block[blOff + 13]);
                big[off + 14] = MPEGDecoder.clipTo8Bit(block[blOff + 14]);
                big[off + 15] = MPEGDecoder.clipTo8Bit(block[blOff + 15]);
                blOff += 16;
                off += stride;
            }
        }
    };
    constructor.clipTo8Bit = function(val) {
        return (((val < 0 ? 0 : (val > 255 ? 255 : val)) - 128) << 24 >> 24);
    };
    constructor.clip = function(val) {
        return val < 0 ? 0 : (val > 255 ? 255 : val);
    };
    constructor.quantInter = function(level, quant) {
        return (((level << 1) + 1) * quant) >> 5;
    };
    constructor.quantInterSigned = function(level, quant) {
        return level >= 0 ? MPEGDecoder.quantInter(level, quant) : -MPEGDecoder.quantInter(-level, quant);
    };
    prototype.blockIntra = function(bits, vlcCoeff, block, intra_dc_predictor, blkIdx, scan, escSize, intra_dc_mult, qScale, qmat) {
        var cc = MPEGConst.BLOCK_TO_CC[blkIdx];
        var size = (cc == 0 ? MPEGConst.vlcDCSizeLuma : MPEGConst.vlcDCSizeChroma).readVLC(bits);
        var delta = (size != 0) ? MPEGDecoder.mpegSigned(bits, size) : 0;
        intra_dc_predictor[cc] = intra_dc_predictor[cc] + delta;
        var dc = intra_dc_predictor[cc] * intra_dc_mult;
        SparseIDCT.start(block, dc);
        for (var idx = 0; idx < 64; ) {
            var readVLC = vlcCoeff.readVLC(bits);
            var level;
            if (readVLC == MPEGConst.CODE_END) {
                break;
            } else if (readVLC == MPEGConst.CODE_ESCAPE) {
                idx += bits.readNBit(6) + 1;
                level = MPEGDecoder.twosSigned(bits, escSize) * qScale * qmat[idx];
                level = level >= 0 ? (level >> 4) : -(-level >> 4);
            } else {
                idx += (readVLC >> 6) + 1;
                level = MPEGDecoder.toSigned(((readVLC & 63) * qScale * qmat[idx]) >> 4, bits.read1Bit());
            }
            SparseIDCT.coeff(block, scan[idx], level);
        }
        SparseIDCT.finish(block);
    };
    prototype.blockInter = function(bits, vlcCoeff, block, scan, escSize, qScale, qmat) {
        var idx = -1;
        if (vlcCoeff == MPEGConst.vlcCoeff0 && bits.checkNBit(1) == 1) {
            bits.read1Bit();
            var dc = MPEGDecoder.toSigned(MPEGDecoder.quantInter(1, qScale * qmat[0]), bits.read1Bit());
            SparseIDCT.start(block, dc);
            idx++;
        } else {
            SparseIDCT.start(block, 0);
        }
        for (; idx < 64; ) {
            var readVLC = vlcCoeff.readVLC(bits);
            var ac;
            if (readVLC == MPEGConst.CODE_END) {
                break;
            } else if (readVLC == MPEGConst.CODE_ESCAPE) {
                idx += bits.readNBit(6) + 1;
                ac = MPEGDecoder.quantInterSigned(MPEGDecoder.twosSigned(bits, escSize), qScale * qmat[idx]);
            } else {
                idx += (readVLC >> 6) + 1;
                ac = MPEGDecoder.toSigned(MPEGDecoder.quantInter(readVLC & 63, qScale * qmat[idx]), bits.read1Bit());
            }
            SparseIDCT.coeff(block, scan[idx], ac);
        }
        SparseIDCT.finish(block);
    };
    constructor.twosSigned = function(bits, size) {
        var shift = 32 - size;
        return (bits.readNBit(size) << shift) >> shift;
    };
    constructor.mpegSigned = function(bits, size) {
        var val = bits.readNBit(size);
        var sign = (val >>> (size - 1)) ^ 1;
        return val + sign - (sign << size);
    };
    constructor.toSigned = function(val, s) {
        var sign = (s << 31) >> 31;
        return (val ^ sign) - sign;
    };
    prototype.readCbPattern = function(bits) {
        var cbp420 = MPEGConst.vlcCBP.readVLC(bits);
        if (this.sh.sequenceExtension == null || this.sh.sequenceExtension.chroma_format == SequenceExtension.Chroma420) 
            return cbp420;
         else if (this.sh.sequenceExtension.chroma_format == SequenceExtension.Chroma422) 
            return (cbp420 << 2) | bits.readNBit(2);
         else if (this.sh.sequenceExtension.chroma_format == SequenceExtension.Chroma444) 
            return (cbp420 << 6) | bits.readNBit(6);
         throw new RuntimeException("Unsupported chroma format: " + this.sh.sequenceExtension.chroma_format);
    };
    constructor.probe = function(data) {
        data = data.duplicate();
        data.order(ByteOrder.BIG_ENDIAN);
        for (var i = 0; i < 2; i++) {
            if (MPEGUtil.gotoNextMarker(data) == null) 
                break;
            if (!data.hasRemaining()) 
                break;
            var marker = data.getInt();
            if (marker == 256 || (marker >= 432 && marker <= 440)) 
                return 50 - i * 10;
             else if (marker > 256 && marker < 432) 
                return 20 - i * 10;
        }
        return 0;
    };
    constructor.getSequenceHeader = function(data) {
        var segment = MPEGUtil.nextSegment(data);
         while (segment != null){
            var marker = segment.getInt();
            if (marker == (256 | MPEGConst.SEQUENCE_HEADER_CODE)) {
                return segment;
            }
            segment = MPEGUtil.nextSegment(data);
        }
        return null;
    };
    constructor.getRawPictureHeader = function(data) {
        var segment = MPEGUtil.nextSegment(data);
         while (segment != null){
            var marker = segment.getInt();
            if (marker == (256 | MPEGConst.PICTURE_START_CODE)) {
                return segment;
            }
            segment = MPEGUtil.nextSegment(data);
        }
        return null;
    };
    constructor.getSequenceNumber = function(data) {
        var ph = MPEGDecoder.getPictureHeader(data);
        if (ph == null) 
            return -1;
        return ph.temporal_reference;
    };
    constructor.getPictureHeader = function(data) {
        var bb = MPEGDecoder.getRawPictureHeader(data);
        if (bb == null) 
            return null;
        var ph = PictureHeader.read(bb);
        return ph;
    };
    prototype.getCodecMeta = function(data) {
        var codecPrivate = MPEGDecoder.getSequenceHeader(data.duplicate());
        var sh = SequenceHeader.read(codecPrivate.duplicate());
        return VideoCodecMeta.createSimpleVideoCodecMeta(new Size(sh.horizontal_size, sh.vertical_size), ColorSpace.YUV420);
    };
}, {sh: "SequenceHeader", gh: "GOPHeader", refFrames: "Array", refFields: "Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Dumps MPEG Proram stream file. Can firther parse MPEG elementary stream
 *  packets.
 *  
 *  @author The JCodec project
 *  
 */
var MPSDump = function(ch) {
    this.ch = ch;
};
MPSDump = stjs.extend(MPSDump, null, [], function(constructor, prototype) {
    constructor.DUMP_FROM = MainUtils.Flag.flag("dump-from", null, "Stop reading at timestamp");
    constructor.STOP_AT = MainUtils.Flag.flag("stop-at", null, "Start dumping from timestamp");
    constructor.ALL_FLAGS = [MPSDump.DUMP_FROM, MPSDump.STOP_AT];
    prototype.ch = null;
    constructor.main1 = function(args) {
        var ch = null;
        try {
            var cmd = MainUtils.parseArguments(args, MPSDump.ALL_FLAGS);
            if (cmd.args.length < 1) {
                MainUtils.printHelp(MPSDump.ALL_FLAGS, Arrays.asList("file name"));
                return;
            }
            ch = NIOUtils.readableChannel(new File(cmd.args[0]));
            var dumpAfterPts = cmd.getLongFlag(MPSDump.DUMP_FROM);
            var stopPts = cmd.getLongFlag(MPSDump.STOP_AT);
            new MPSDump(ch).dump(dumpAfterPts, stopPts);
        } finally {
            NIOUtils.closeQuietly(ch);
        }
    };
    prototype.dump = function(dumpAfterPts, stopPts) {
        var analyzer = null;
        var buffer = ByteBuffer.allocate(1048576);
        var pkt = null;
        var hdrSize = 0;
        for (var position = 0; ; ) {
            position -= buffer.position();
            if (this.fillBuffer(buffer) == -1) 
                break;
            buffer.flip();
            if (buffer.remaining() < 4) 
                break;
            position += buffer.remaining();
             while (true){
                var payload = null;
                if (pkt != null && pkt.length > 0) {
                    var pesLen = pkt.length - hdrSize + 6;
                    if (pesLen <= buffer.remaining()) 
                        payload = NIOUtils.read(buffer, pesLen);
                } else {
                    payload = MPSDump.getPesPayload(buffer);
                }
                if (payload == null) 
                    break;
                if (pkt != null) 
                    this.logPes(pkt, hdrSize, payload);
                if (analyzer != null && pkt != null && pkt.streamId >= 224 && pkt.streamId <= 239) {
                    analyzer.analyzeMpegVideoPacket(payload);
                }
                if (buffer.remaining() < 32) {
                    pkt = null;
                    break;
                }
                MPSDump.skipToNextPES(buffer);
                if (buffer.remaining() < 32) {
                    pkt = null;
                    break;
                }
                hdrSize = buffer.position();
                pkt = MPSUtils.readPESHeader(buffer, position - buffer.remaining());
                hdrSize = buffer.position() - hdrSize;
                if (dumpAfterPts != null && pkt.pts >= dumpAfterPts) 
                    analyzer = new MPSDump.MPEGVideoAnalyzer();
                if (stopPts != null && pkt.pts >= stopPts) 
                    return;
            }
            buffer = this.transferRemainder(buffer);
        }
    };
    prototype.fillBuffer = function(buffer) {
        return this.ch.read(buffer);
    };
    prototype.logPes = function(pkt, hdrSize, payload) {
        System.out.println(pkt.streamId + "(" + (pkt.streamId >= 224 ? "video" : "audio") + ") [" + pkt.pos + ", " + (payload.remaining() + hdrSize) + "], pts: " + pkt.pts + ", dts: " + pkt.dts);
    };
    prototype.transferRemainder = function(buffer) {
        var dup = buffer.duplicate();
        dup.clear();
         while (buffer.hasRemaining())
            dup.put(buffer.get());
        return dup;
    };
    constructor.skipToNextPES = function(buffer) {
         while (buffer.hasRemaining()){
            var marker = buffer.duplicate().getInt();
            if (marker >= 445 && marker <= 511 && marker != 446) 
                break;
            buffer.getInt();
            MPEGUtil.gotoNextMarker(buffer);
        }
    };
    constructor.getPesPayload = function(buffer) {
        var copy = buffer.duplicate();
        var result = buffer.duplicate();
         while (copy.hasRemaining()){
            var marker = copy.duplicate().getInt();
            if (marker >= 441) {
                result.setLimit(copy.position());
                buffer.setPosition(copy.position());
                return result;
            }
            copy.getInt();
            MPEGUtil.gotoNextMarker(copy);
        }
        return null;
    };
    constructor.MPEGVideoAnalyzer = function() {
        this.bselPayload = ByteBuffer.allocate(1048576);
    };
    constructor.MPEGVideoAnalyzer = stjs.extend(constructor.MPEGVideoAnalyzer, null, [], function(constructor, prototype) {
        prototype.nextStartCode = -1;
        prototype.bselPayload = null;
        prototype.bselStartCode = 0;
        prototype.bselOffset = 0;
        prototype.bselBufInd = 0;
        prototype.prevBufSize = 0;
        prototype.curBufInd = 0;
        prototype.picHeader = null;
        prototype.sequenceHeader = null;
        prototype.pictureCodingExtension = null;
        prototype.sequenceExtension = null;
        prototype.analyzeMpegVideoPacket = function(buffer) {
            var pos = buffer.position();
            var bufSize = buffer.remaining();
             while (buffer.hasRemaining()){
                this.bselPayload.put(((this.nextStartCode >> 24) << 24 >> 24));
                this.nextStartCode = (this.nextStartCode << 8) | (buffer.get() & 255);
                if (this.nextStartCode >= 256 && this.nextStartCode <= 440) {
                    this.bselPayload.flip();
                    this.bselPayload.getInt();
                    if (this.bselStartCode != 0) {
                        if (this.bselBufInd != this.curBufInd) 
                            this.bselOffset -= this.prevBufSize;
                        this.dumpBSEl(this.bselStartCode, this.bselOffset, this.bselPayload);
                    }
                    this.bselPayload.clear();
                    this.bselStartCode = this.nextStartCode;
                    this.bselOffset = buffer.position() - 4 - pos;
                    this.bselBufInd = this.curBufInd;
                }
            }
            ++this.curBufInd;
            this.prevBufSize = bufSize;
        };
        prototype.dumpBSEl = function(mark, offset, b) {
            System.out.print(String.format("marker: 0x%02x [@%d] ( ", mark, offset));
            if (mark == 256) 
                this.dumpPictureHeader(b);
             else if (mark <= 431) 
                System.out.print(MainUtils.colorBright(String.format("slice @0x%02x", mark - 257), MainUtils.ANSIColor.BLACK, true));
             else if (mark == 435) 
                this.dumpSequenceHeader(b);
             else if (mark == 437) 
                this.dumpExtension(b);
             else if (mark == 440) 
                this.dumpGroupHeader(b);
             else 
                System.out.print("--");
            System.out.println(" )");
        };
        prototype.dumpExtension = function(b) {
            var _in = BitReader.createBitReader(b);
            var extType = _in.readNBit(4);
            if (this.picHeader == null) {
                if (this.sequenceHeader != null) {
                    switch (extType) {
                        case SequenceExtension.Sequence_Extension:
                            this.sequenceExtension = SequenceExtension.read(_in);
                            this.dumpSequenceExtension(this.sequenceExtension);
                            break;
                        case SequenceScalableExtension.Sequence_Scalable_Extension:
                            this.dumpSequenceScalableExtension(SequenceScalableExtension.read(_in));
                            break;
                        case SequenceDisplayExtension.Sequence_Display_Extension:
                            this.dumpSequenceDisplayExtension(SequenceDisplayExtension.read(_in));
                            break;
                        default:
                            System.out.print(MainUtils.colorBright("extension " + extType, MainUtils.ANSIColor.GREEN, true));
                    }
                } else {
                    System.out.print(MainUtils.colorBright("dangling extension " + extType, MainUtils.ANSIColor.GREEN, true));
                }
            } else {
                switch (extType) {
                    case QuantMatrixExtension.Quant_Matrix_Extension:
                        this.dumpQuantMatrixExtension(QuantMatrixExtension.read(_in));
                        break;
                    case CopyrightExtension.Copyright_Extension:
                        this.dumpCopyrightExtension(CopyrightExtension.read(_in));
                        break;
                    case PictureDisplayExtension.Picture_Display_Extension:
                        if (this.sequenceHeader != null && this.pictureCodingExtension != null) 
                            this.dumpPictureDisplayExtension(PictureDisplayExtension.read(_in, this.sequenceExtension, this.pictureCodingExtension));
                        break;
                    case PictureCodingExtension.Picture_Coding_Extension:
                        this.pictureCodingExtension = PictureCodingExtension.read(_in);
                        this.dumpPictureCodingExtension(this.pictureCodingExtension);
                        break;
                    case PictureSpatialScalableExtension.Picture_Spatial_Scalable_Extension:
                        this.dumpPictureSpatialScalableExtension(PictureSpatialScalableExtension.read(_in));
                        break;
                    case PictureTemporalScalableExtension.Picture_Temporal_Scalable_Extension:
                        this.dumpPictureTemporalScalableExtension(PictureTemporalScalableExtension.read(_in));
                        break;
                    default:
                        System.out.print(MainUtils.colorBright("extension " + extType, MainUtils.ANSIColor.GREEN, true));
                }
            }
        };
        prototype.dumpSequenceDisplayExtension = function(read) {
            System.out.print(MainUtils.colorBright("sequence display extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpSequenceScalableExtension = function(read) {
            System.out.print(MainUtils.colorBright("sequence scalable extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpSequenceExtension = function(read) {
            System.out.print(MainUtils.colorBright("sequence extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpPictureTemporalScalableExtension = function(read) {
            System.out.print(MainUtils.colorBright("picture temporal scalable extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpPictureSpatialScalableExtension = function(read) {
            System.out.print(MainUtils.colorBright("picture spatial scalable extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpPictureCodingExtension = function(read) {
            System.out.print(MainUtils.colorBright("picture coding extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpPictureDisplayExtension = function(read) {
            System.out.print(MainUtils.colorBright("picture display extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpCopyrightExtension = function(read) {
            System.out.print(MainUtils.colorBright("copyright extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpQuantMatrixExtension = function(read) {
            System.out.print(MainUtils.colorBright("quant matrix extension " + this.dumpBin(read), MainUtils.ANSIColor.GREEN, true));
        };
        prototype.dumpBin = function(read) {
            var bldr = new StringBuilder();
            bldr.append("<");
            var fields = Platform.getFields(read.getClass());
            for (var i = 0; i < fields.length; i++) {
                if (!Modifier.isPublic(fields[i].getModifiers()) || Modifier.isStatic(fields[i].getModifiers())) 
                    continue;
                bldr.append(this.convertName(fields[i].getName()) + ": ");
                if (fields[i].getType().isPrimitive()) {
                    try {
                        bldr.append(fields[i].get(read));
                    }catch (e) {}
                } else {
                    try {
                        var val = fields[i].get(read);
                        if (val != null) 
                            bldr.append(this.dumpBin(val));
                         else 
                            bldr.append("N/A");
                    }catch (e) {}
                }
                if (i < fields.length - 1) 
                    bldr.append(",");
            }
            bldr.append(">");
            return bldr.toString();
        };
        prototype.convertName = function(name) {
            return name.replaceAll("([A-Z])", " $1").replaceFirst("^ ", "").toLowerCase();
        };
        prototype.dumpGroupHeader = function(b) {
            var gopHeader = GOPHeader.read(b);
            System.out.print(MainUtils.colorBright("group header <closed:" + gopHeader.isClosedGop() + ",broken link:" + gopHeader.isBrokenLink() + (gopHeader.getTimeCode() != null ? (",timecode:" + gopHeader.getTimeCode().toString()) : "") + ">", MainUtils.ANSIColor.MAGENTA, true));
        };
        prototype.dumpSequenceHeader = function(b) {
            this.picHeader = null;
            this.pictureCodingExtension = null;
            this.sequenceExtension = null;
            this.sequenceHeader = SequenceHeader.read(b);
            System.out.print(MainUtils.colorBright("sequence header", MainUtils.ANSIColor.BLUE, true));
        };
        prototype.dumpPictureHeader = function(b) {
            this.picHeader = PictureHeader.read(b);
            this.pictureCodingExtension = null;
            System.out.print(MainUtils.colorBright("picture header <type:" + (this.picHeader.picture_coding_type == 1 ? "I" : (this.picHeader.picture_coding_type == 2 ? "P" : "B")) + ", temp_ref:" + this.picHeader.temporal_reference + ">", MainUtils.ANSIColor.BROWN, true));
        };
    }, {bselPayload: "ByteBuffer", picHeader: "PictureHeader", sequenceHeader: "SequenceHeader", pictureCodingExtension: "PictureCodingExtension", sequenceExtension: "SequenceExtension"}, {});
}, {DUMP_FROM: "MainUtils.Flag", STOP_AT: "MainUtils.Flag", ALL_FLAGS: "Array", ch: "ReadableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 1/2 decoder interframe motion compensation routines.
 *  
 *  Quad subpixel interpolator which is just a sub-case of octal subpixel
 *  interpolator.
 *  
 *  @author The JCodec project
 *  
 */
var MPEGPredQuad = function(other) {
    MPEGPredOct.call(this, other);
};
MPEGPredQuad = stjs.extend(MPEGPredQuad, MPEGPredOct, [], function(constructor, prototype) {
    prototype.predictPlane = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        MPEGPredOct.prototype.predictPlane.call(this, ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW << 1, tgtH << 1, tgtVertStep);
    };
}, {tmp: "Int32Array", COEFF: "Array", mvPred: "Array", fCode: "Array"}, {});
var MPEGPredDbl = function(other) {
    MPEGPredOct.call(this, other);
};
MPEGPredDbl = stjs.extend(MPEGPredDbl, MPEGPredOct, [], function(constructor, prototype) {
    prototype.predictPlane = function(ref, refX, refY, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW, tgtH, tgtVertStep) {
        MPEGPredOct.prototype.predictPlane.call(this, ref, refX << 1, refY << 1, refW, refH, refVertStep, refVertOff, tgt, tgtY, tgtW << 2, tgtH << 2, tgtVertStep);
    };
}, {tmp: "Int32Array", COEFF: "Array", mvPred: "Array", fCode: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MTSRandomAccessDemuxer = function(ch, index) {
    this.programs = index.getPrograms();
    this.ch = ch;
};
MTSRandomAccessDemuxer = stjs.extend(MTSRandomAccessDemuxer, null, [], function(constructor, prototype) {
    prototype.programs = null;
    prototype.ch = null;
    prototype.getGuids = function() {
        var guids = new Int32Array(this.programs.length);
        for (var i = 0; i < this.programs.length; i++) 
            guids[i] = this.programs[i].getTargetGuid();
        return guids;
    };
    prototype.getProgramDemuxer = function(tgtGuid) {
        var index = this.getProgram(tgtGuid);
        return new (stjs.extend(function MTSRandomAccessDemuxer$1(x0, x1) {
            MPSRandomAccessDemuxer.call(this, x0, x1);
        }, MPSRandomAccessDemuxer, [], function(constructor, prototype) {
            prototype.newStream = function(ch, streamIndex) {
                return new (stjs.extend(function MTSRandomAccessDemuxer$1$1(x0, x1, x2) {
                    MPSRandomAccessDemuxer.Stream.call(this, x0, x1, x2);
                }, MPSRandomAccessDemuxer.Stream, [], function(constructor, prototype) {
                    prototype.fetch = function(pesLen) {
                        var bb = ByteBuffer.allocate(pesLen * 188);
                        for (var i = 0; i < pesLen; i++) {
                            var tsBuf = NIOUtils.fetchFromChannel(this.source, 188);
                            Preconditions.checkState(71 == (tsBuf.get() & 255));
                            var guidFlags = ((tsBuf.get() & 255) << 8) | (tsBuf.get() & 255);
                            var guid = stjs.trunc(guidFlags) & 8191;
                            if (guid != tgtGuid) 
                                continue;
                            var payloadStart = (guidFlags >> 14) & 1;
                            var b0 = tsBuf.get() & 255;
                            var counter = b0 & 15;
                            if ((b0 & 32) != 0) {
                                NIOUtils.skip(tsBuf, tsBuf.get() & 255);
                            }
                            bb.putBuf(tsBuf);
                        }
                        bb.flip();
                        return bb;
                    };
                    prototype.skip = function(leadingSize) {
                        this.source.setPosition(this.source.position() + leadingSize * 188);
                    };
                    prototype.reset = function() {
                        this.source.setPosition(0);
                    };
                }, {pesBuf: "ByteBuffer", source: "SeekableByteChannel", foffs: "Array", demuxer: "MPSRandomAccessDemuxer", fsizes: "Int32Array", fpts: "Int32Array", fdur: "Int32Array", sync: "Int32Array"}, {}))(this, streamIndex, ch);
            };
        }, {streams: "Array", pesTokens: "Array", pesStreamIds: "Int32Array"}, {}))(this.ch, index);
    };
    prototype.getProgram = function(guid) {
        for (var index$mtsProgram = 0, arr$mtsProgram = this.programs; index$mtsProgram < arr$mtsProgram.length; index$mtsProgram++) {
            var mtsProgram = arr$mtsProgram[index$mtsProgram];
            if (mtsProgram.getTargetGuid() == guid) 
                return mtsProgram;
        }
        return null;
    };
}, {programs: "Array", ch: "SeekableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Replaces pid of a stream with a different value
 *  
 *  @author Stan Vitvitskyy
 *  
 */
var MTSReplacePid = function(replaceSpec) {
    MTSUtils.TSReader.call(this, true);
    this.pmtPids = new HashSet();
    this.replaceSpec = replaceSpec;
};
MTSReplacePid = stjs.extend(MTSReplacePid, MTSUtils.TSReader, [], function(constructor, prototype) {
    prototype.pmtPids = null;
    prototype.replaceSpec = null;
    prototype.onPkt = function(guid, payloadStart, tsBuf, filePos, sectionSyntax, fullPkt) {
        if (sectionSyntax) {
            this.replaceRefs(this.replaceSpec, guid, tsBuf, this.pmtPids);
        } else {
            System.out.print("TS ");
            var buf = fullPkt.duplicate();
            var tsFlags = buf.getShortAt(buf.position() + 1);
            buf.putShort(buf.position() + 1, (((this.replacePid(this.replaceSpec, tsFlags & 8191) | (tsFlags & ~8191))) << 16 >> 16));
        }
        return true;
    };
    constructor.parseReplaceSpec = function(spec) {
        var map = new IntIntMap();
        for (var index$pidPair = 0, arr$pidPair = spec.split(","); index$pidPair < arr$pidPair.length; index$pidPair++) {
            var pidPair = arr$pidPair[index$pidPair];
            var pidPairParsed = pidPair.split(":");
            map.put(Integer.parseInt(pidPairParsed[0]), Integer.parseInt(pidPairParsed[1]));
        }
        return map;
    };
    prototype.replaceRefs = function(replaceSpec, guid, buf, pmtPids) {
        if (guid == 0) {
            var pat = PATSection.parsePAT(buf);
            for (var index$pids = 0, arr$pids = pat.getPrograms().values(); index$pids < arr$pids.length; index$pids++) {
                var pids = arr$pids[index$pids];
                pmtPids.add(pids);
            }
        } else if (pmtPids.contains(guid)) {
            System.out.println(MainUtils.bold("PMT"));
            PSISection.parsePSI(buf);
            buf.getShort();
            NIOUtils.skip(buf, buf.getShort() & 4095);
             while (buf.remaining() > 4){
                var streamType = buf.get();
                var fromTag = MTSStreamType.fromTag(streamType);
                System.out.print((fromTag == null ? "UNKNOWN" : fromTag) + "(" + String.format("0x%02x", streamType) + "):\t");
                var wn = buf.getShort() & 65535;
                var wasPid = wn & 8191;
                var elementaryPid = this.replacePid(replaceSpec, wasPid);
                buf.putShort(buf.position() - 2, ((((elementaryPid & 8191) | (wn & ~8191))) << 16 >> 16));
                NIOUtils.skip(buf, buf.getShort() & 4095);
            }
        }
    };
    prototype.replacePid = function(replaceSpec, pid) {
        var newPid = pid;
        if (replaceSpec.contains(pid)) {
            newPid = replaceSpec.get(pid);
        }
        System.out.println("[" + pid + "->" + newPid + "]");
        return newPid;
    };
    constructor.main1 = function(args) {
        var cmd = MainUtils.parseArguments(args, []);
        if (cmd.args.length < 2) {
            MainUtils.printHelpNoFlags("pid_from:pid_to,[pid_from:pid_to...]", "file");
            return;
        }
        var replaceSpec = MTSReplacePid.parseReplaceSpec(cmd.getArg(0));
        var ch = null;
        try {
            ch = NIOUtils.rwChannel(new File(cmd.getArg(1)));
            new MTSReplacePid(replaceSpec).readTsFile(ch);
        } finally {
            NIOUtils.closeQuietly(ch);
        }
    };
}, {pmtPids: {name: "Set", arguments: [null]}, replaceSpec: "IntIntMap"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FixTimestamp = function() {};
FixTimestamp = stjs.extend(FixTimestamp, null, [], function(constructor, prototype) {
    prototype.fix = function(file) {
        var ra = null;
        try {
            ra = new RandomAccessFile(file, "rw");
            var ch = new FileChannelWrapper(ra.getChannel());
            var self = this;
            new (stjs.extend(function FixTimestamp$1(x0) {
                MTSUtils.TSReader.call(this, x0);
            }, MTSUtils.TSReader, [], function(constructor, prototype) {
                prototype.onPkt = function(guid, payloadStart, bb, filePos, sectionSyntax, fullPkt) {
                    return self.processPacket(payloadStart, bb, sectionSyntax, fullPkt);
                };
            }, {}, {}))(true).readTsFile(ch);
        } finally {
            if (ra != null) 
                ra.close();
        }
    };
    prototype.processPacket = function(payloadStart, bb, sectionSyntax, fullPkt) {
        if (!payloadStart || sectionSyntax) 
            return true;
        var streamId = bb.getInt();
        if (streamId == 445 || streamId >= 448 && streamId < 495) {
            var len = bb.getShort();
            var b0 = bb.get() & 255;
            bb.setPosition(bb.position() - 1);
            if ((b0 & 192) == 128) 
                this.fixMpeg2(streamId & 255, bb);
             else 
                this.fixMpeg1(streamId & 255, bb);
        }
        return true;
    };
    prototype.fixMpeg1 = function(streamId, is) {
        var c = is.getInt() & 255;
         while (c == 255){
            c = is.get() & 255;
        }
        if ((c & 192) == 64) {
            is.get();
            c = is.get() & 255;
        }
        if ((c & 240) == 32) {
            is.setPosition(is.position() - 1);
            this.fixTs(streamId, is, true);
        } else if ((c & 240) == 48) {
            is.setPosition(is.position() - 1);
            this.fixTs(streamId, is, true);
            this.fixTs(streamId, is, false);
        } else {
            if (c != 15) 
                 throw new RuntimeException("Invalid data");
        }
    };
    prototype.fixTs = function(streamId, is, isPts) {
        var b0 = is.get();
        var b1 = is.get();
        var b2 = is.get();
        var b3 = is.get();
        var b4 = is.get();
        var pts = ((stjs.trunc(b0) & 14) << 29) | ((b1 & 255) << 22) | (((b2 & 255) >> 1) << 15) | ((b3 & 255) << 7) | ((b4 & 255) >> 1);
        pts = this.doWithTimestamp(streamId, pts, isPts);
        is.setPosition(is.position() - 5);
        is.put((((b0 & 240) | (pts >>> 29) | 1) << 24 >> 24));
        is.put(((pts >>> 22) << 24 >> 24));
        is.put((((pts >>> 14) | 1) << 24 >> 24));
        is.put(((pts >>> 7) << 24 >> 24));
        is.put((((pts << 1) | 1) << 24 >> 24));
        return pts;
    };
    prototype.fixMpeg2 = function(streamId, is) {
        var flags1 = is.get() & 255;
        var flags2 = is.get() & 255;
        var header_len = is.get() & 255;
        if ((flags2 & 192) == 128) {
            this.fixTs(streamId, is, true);
        } else if ((flags2 & 192) == 192) {
            this.fixTs(streamId, is, true);
            this.fixTs(streamId, is, false);
        }
    };
    prototype.isVideo = function(streamId) {
        return streamId >= 224 && streamId <= 239;
    };
    prototype.isAudio = function(streamId) {
        return streamId >= 191 && streamId <= 223;
    };
    prototype.doWithTimestamp = function(streamId, pts, isPts) {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var HLSFixPMT = function() {};
HLSFixPMT = stjs.extend(HLSFixPMT, null, [], function(constructor, prototype) {
    prototype.fix = function(file) {
        var ra = null;
        try {
            ra = new RandomAccessFile(file, "rw");
            var tsPkt = new Int8Array(188);
             while (ra.read(tsPkt) == 188){
                Preconditions.checkState(71 == (tsPkt[0] & 255));
                var guidFlags = ((tsPkt[1] & 255) << 8) | (tsPkt[2] & 255);
                var guid = stjs.trunc(guidFlags) & 8191;
                var payloadStart = (guidFlags >> 14) & 1;
                var b0 = tsPkt[3] & 255;
                var counter = b0 & 15;
                var payloadOff = 0;
                if ((b0 & 32) != 0) {
                    payloadOff = (tsPkt[4 + payloadOff] & 255) + 1;
                }
                if (payloadStart == 1) {
                    payloadOff += (tsPkt[4 + payloadOff] & 255) + 1;
                }
                if (guid == 0) {
                    if (payloadStart == 0) 
                         throw new RuntimeException("PAT spans multiple TS packets, not supported!!!!!!");
                    var bb = ByteBuffer.wrap(tsPkt, 4 + payloadOff, 184 - payloadOff);
                    HLSFixPMT.fixPAT(bb);
                    ra.seek(ra.getFilePointer() - 188);
                    ra.write(tsPkt);
                }
            }
        } finally {
            if (ra != null) 
                ra.close();
        }
    };
    constructor.fixPAT = function(data) {
        var table = data.duplicate();
        MTSUtils.parseSection(data);
        var newPmt = data.duplicate();
         while (data.remaining() > 4){
            var num = data.getShort();
            var pid = data.getShort();
            if (num != 0) {
                newPmt.putShort(num);
                newPmt.putShort(pid);
            }
        }
        if (newPmt.position() != data.position()) {
            var section = table.duplicate();
            section.get();
            var sectionLen = newPmt.position() - table.position() + 1;
            section.putShort(((((sectionLen & 4095) | 45056)) << 16 >> 16));
            var crc32 = new CRC32();
            table.setLimit(newPmt.position());
            crc32.updateB(NIOUtils.toArray(table));
            newPmt.putInt(((crc32.getValue()) | 0));
             while (newPmt.hasRemaining())
                newPmt.put((255 << 24 >> 24));
        }
    };
    constructor.main1 = function(args) {
        if (args.length < 1) 
            HLSFixPMT.exit("Please specify package location");
        var hlsPkg = new File(args[0]);
        if (!hlsPkg.isDirectory()) 
            HLSFixPMT.exit("Not an HLS package, expected a folder");
        var listFiles = hlsPkg.listFiles(new (stjs.extend(function HLSFixPMT$1() {}, null, [FilenameFilter], function(constructor, prototype) {
            prototype.accept = function(dir, name) {
                return name.endsWith(".ts");
            };
        }, {}, {}))());
        var fix = new HLSFixPMT();
        for (var i = 0; i < listFiles.length; i++) {
            var file = listFiles[i];
            System.err.println("Processing: " + file.getName());
            fix.fix(file);
        }
    };
    constructor.exit = function(message) {
        System.err.println("Syntax: hls_fixpmt <hls package location>");
        System.err.println(message);
        System.exit(-1);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  JCodec has to be dependancy free, so it can run both on Java SE and Android
 *  hence defining here our small logger that can be plugged into the logging
 *  framework of choice on the target platform
 *  
 *  @author The JCodec project
 */
var Logger = function() {};
Logger = stjs.extend(Logger, null, [], function(constructor, prototype) {
    constructor.stageSinks = new LinkedList();
    constructor.sinks = null;
    constructor.argsToArray = function(args) {
        var _arr = args;
        return ((_arr.length == 1) ? [_arr[0]] : Array.apply(null, _arr));
    };
    constructor.debug = function(_arguments) {
        Logger.message(LogLevel.DEBUG, arguments[0], Logger.argsToArray(arguments).slice(1));
    };
    constructor.info = function(_arguments) {
        Logger.message(LogLevel.INFO, arguments[0], Logger.argsToArray(arguments).slice(1));
    };
    constructor.warn = function(_arguments) {
        Logger.message(LogLevel.WARN, arguments[0], Logger.argsToArray(arguments).slice(1));
    };
    constructor.error = function(_arguments) {
        Logger.message(LogLevel.WARN, arguments[0], Logger.argsToArray(arguments).slice(1));
    };
    constructor.message = function(level, message, args) {
        if (Logger.globalLogLevel.ordinal() >= level.ordinal()) {
            return;
        }
        if (Logger.sinks == null) {
            {
                if (Logger.sinks == null) {
                    Logger.sinks = Logger.stageSinks;
                    Logger.stageSinks = null;
                    if (Logger.sinks.isEmpty()) 
                        Logger.sinks.add(OutLogSink.createOutLogSink());
                }
            }}
        var msg;
        if (LogLevel.DEBUG.equals(Logger.globalLogLevel)) {
            var tr = Thread.currentThread().getStackTrace()[3];
            msg = new Message(level, tr.getFileName(), tr.getClassName(), tr.getMethodName(), tr.getLineNumber(), message, args);
        } else {
            msg = new Message(level, "", "", "", 0, message, args);
        }
        for (var iterator$logSink = Logger.sinks.iterator(); iterator$logSink.hasNext(); ) {
            var logSink = iterator$logSink.next();
            logSink.postMessage(msg);
        }
    };
    constructor.globalLogLevel = LogLevel.INFO;
    constructor.setLevel = function(level) {
        Logger.globalLogLevel = level;
    };
    constructor.getLevel = function() {
        return Logger.globalLogLevel;
    };
    constructor.addSink = function(sink) {
        if (Logger.stageSinks == null) 
             throw new IllegalStateException("Logger already started");
        Logger.stageSinks.add(sink);
    };
}, {stageSinks: {name: "List", arguments: ["LogSink"]}, sinks: {name: "List", arguments: ["LogSink"]}, globalLogLevel: {name: "Enum", arguments: ["LogLevel"]}}, {});
var DescriptorParser = function() {};
DescriptorParser = stjs.extend(DescriptorParser, null, [], function(constructor, prototype) {
    constructor.ES_TAG = 3;
    constructor.DC_TAG = 4;
    constructor.DS_TAG = 5;
    constructor.SL_TAG = 6;
    constructor.read = function(input) {
        if (input.remaining() < 2) 
            return null;
        var tag = input.get() & 255;
        var size = JCodecUtil2.readBER32(input);
        var byteBuffer = NIOUtils.read(input, size);
        switch (tag) {
            case DescriptorParser.ES_TAG:
                return DescriptorParser.parseES(byteBuffer);
            case DescriptorParser.SL_TAG:
                return DescriptorParser.parseSL(byteBuffer);
            case DescriptorParser.DC_TAG:
                return DescriptorParser.parseDecoderConfig(byteBuffer);
            case DescriptorParser.DS_TAG:
                return DescriptorParser.parseDecoderSpecific(byteBuffer);
            default:
                 throw new RuntimeException("unknown tag " + tag);
        }
    };
    constructor.parseNodeDesc = function(input) {
        var children = new ArrayList();
        var d;
        do {
            d = DescriptorParser.read(input);
            if (d != null) 
                children.add(d);
        } while (d != null);
        return new NodeDescriptor(0, children);
    };
    constructor.parseES = function(input) {
        var trackId = input.getShort();
        input.get();
        var node = DescriptorParser.parseNodeDesc(input);
        return new ES(trackId, node.getChildren());
    };
    constructor.parseSL = function(input) {
        Preconditions.checkState(2 == (input.get() & 255));
        return new SL();
    };
    constructor.parseDecoderSpecific = function(input) {
        var data = NIOUtils.readBuf(input);
        return new DecoderSpecific(data);
    };
    constructor.parseDecoderConfig = function(input) {
        var objectType = input.get() & 255;
        input.get();
        var bufSize = ((input.get() & 255) << 16) | (input.getShort() & 65535);
        var maxBitrate = input.getInt();
        var avgBitrate = input.getInt();
        var node = DescriptorParser.parseNodeDesc(input);
        return new DecoderConfig(objectType, bufSize, maxBitrate, avgBitrate, node.getChildren());
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MKVMuxer = function(s) {
    this.sink = s;
    this.tracks = new ArrayList();
    this.clusterList = new LinkedList();
};
MKVMuxer = stjs.extend(MKVMuxer, null, [Muxer], function(constructor, prototype) {
    prototype.tracks = null;
    prototype.audioTrack = null;
    prototype.videoTrack = null;
    prototype.mkvInfo = null;
    prototype.mkvTracks = null;
    prototype.mkvCues = null;
    prototype.mkvSeekHead = null;
    prototype.clusterList = null;
    prototype.sink = null;
    constructor.codec2mkv = new HashMap();
    prototype.createVideoTrack = function(meta, codecId) {
        if (this.videoTrack == null) {
            this.videoTrack = new MKVMuxerTrack();
            this.tracks.add(this.videoTrack);
            this.videoTrack.codecId = codecId;
            this.videoTrack.videoMeta = meta;
            this.videoTrack.trackNo = this.tracks.size();
        }
        return this.videoTrack;
    };
    prototype.finish = function() {
        var mkvFile = new ArrayList();
        var ebmlHeader = this.defaultEbmlHeader();
        mkvFile.add(ebmlHeader);
        var segmentElem = MKVType.createByType(MKVType.Segment);
        this.mkvInfo = this.muxInfo();
        this.mkvTracks = this.muxTracks();
        this.mkvCues = MKVType.createByType(MKVType.Cues);
        this.mkvSeekHead = this.muxSeekHead();
        this.muxCues();
        segmentElem.add(this.mkvSeekHead);
        segmentElem.add(this.mkvInfo);
        segmentElem.add(this.mkvTracks);
        segmentElem.add(this.mkvCues);
        for (var iterator$aCluster = this.clusterList.iterator(); iterator$aCluster.hasNext(); ) {
            var aCluster = iterator$aCluster.next();
            segmentElem.add(aCluster);
        }
        mkvFile.add(segmentElem);
        for (var iterator$el = mkvFile.iterator(); iterator$el.hasNext(); ) {
            var el = iterator$el.next();
            el.mux(this.sink);
        }
    };
    prototype.defaultEbmlHeader = function() {
        var master = MKVType.createByType(MKVType.EBML);
        MKVMuxer.createLong(master, MKVType.EBMLVersion, 1);
        MKVMuxer.createLong(master, MKVType.EBMLReadVersion, 1);
        MKVMuxer.createLong(master, MKVType.EBMLMaxIDLength, 4);
        MKVMuxer.createLong(master, MKVType.EBMLMaxSizeLength, 8);
        MKVMuxer.createString(master, MKVType.DocType, "webm");
        MKVMuxer.createLong(master, MKVType.DocTypeVersion, 2);
        MKVMuxer.createLong(master, MKVType.DocTypeReadVersion, 2);
        return master;
    };
    prototype.muxInfo = function() {
        var master = MKVType.createByType(MKVType.Info);
        var frameDurationInNanoseconds = MKVMuxerTrack.NANOSECONDS_IN_A_MILISECOND * 40;
        MKVMuxer.createLong(master, MKVType.TimecodeScale, frameDurationInNanoseconds);
        MKVMuxer.createString(master, MKVType.WritingApp, "JCodec");
        MKVMuxer.createString(master, MKVType.MuxingApp, "JCodec");
        var tracks2 = this.tracks;
        var max = 0;
        for (var iterator$track = tracks2.iterator(); iterator$track.hasNext(); ) {
            var track = iterator$track.next();
            var lastBlock = track.trackBlocks.get(track.trackBlocks.size() - 1);
            if (lastBlock.absoluteTimecode > max) 
                max = lastBlock.absoluteTimecode;
        }
        MKVMuxer.createDouble(master, MKVType.Duration, (max + 1) * frameDurationInNanoseconds * 1.0);
        MKVMuxer.createDate(master, MKVType.DateUTC, new jsutil.Date());
        return master;
    };
    prototype.muxTracks = function() {
        var master = MKVType.createByType(MKVType.Tracks);
        for (var i = 0; i < this.tracks.size(); i++) {
            var track = this.tracks.get(i);
            var trackEntryElem = MKVType.createByType(MKVType.TrackEntry);
            MKVMuxer.createLong(trackEntryElem, MKVType.TrackNumber, track.trackNo);
            MKVMuxer.createLong(trackEntryElem, MKVType.TrackUID, track.trackNo);
            if (MKVMuxerTrack.MKVMuxerTrackType.VIDEO.equals(track.type)) {
                MKVMuxer.createLong(trackEntryElem, MKVType.TrackType, (1 << 24 >> 24));
                MKVMuxer.createString(trackEntryElem, MKVType.Name, "Track " + (i + 1) + " Video");
                MKVMuxer.createString(trackEntryElem, MKVType.CodecID, track.codecId);
                var trackVideoElem = MKVType.createByType(MKVType.Video);
                MKVMuxer.createLong(trackVideoElem, MKVType.PixelWidth, track.videoMeta.getSize().getWidth());
                MKVMuxer.createLong(trackVideoElem, MKVType.PixelHeight, track.videoMeta.getSize().getHeight());
                trackEntryElem.add(trackVideoElem);
            } else {
                MKVMuxer.createLong(trackEntryElem, MKVType.TrackType, (2 << 24 >> 24));
                MKVMuxer.createString(trackEntryElem, MKVType.Name, "Track " + (i + 1) + " Audio");
                MKVMuxer.createString(trackEntryElem, MKVType.CodecID, track.codecId);
            }
            master.add(trackEntryElem);
        }
        return master;
    };
    prototype.muxCues = function() {
        var cf = new CuesFactory(this.mkvSeekHead.size() + this.mkvInfo.size() + this.mkvTracks.size(), this.videoTrack.trackNo);
        for (var iterator$aBlock = this.videoTrack.trackBlocks.iterator(); iterator$aBlock.hasNext(); ) {
            var aBlock = iterator$aBlock.next();
            var mkvCluster = this.singleBlockedCluster(aBlock);
            this.clusterList.add(mkvCluster);
            cf.add(CuesFactory.CuePointMock.make(mkvCluster));
        }
        var indexedCues = cf.createCues();
        for (var iterator$aCuePoint = indexedCues.children.iterator(); iterator$aCuePoint.hasNext(); ) {
            var aCuePoint = iterator$aCuePoint.next();
            this.mkvCues.add(aCuePoint);
        }
    };
    prototype.singleBlockedCluster = function(aBlock) {
        var mkvCluster = MKVType.createByType(MKVType.Cluster);
        MKVMuxer.createLong(mkvCluster, MKVType.Timecode, aBlock.absoluteTimecode - aBlock.timecode);
        mkvCluster.add(aBlock);
        return mkvCluster;
    };
    prototype.muxSeekHead = function() {
        var shi = new SeekHeadFactory();
        shi.add(this.mkvInfo);
        shi.add(this.mkvTracks);
        shi.add(this.mkvCues);
        return shi.indexSeekHead();
    };
    constructor.createLong = function(parent, type, value) {
        var se = MKVType.createByType(type);
        se.setUint(value);
        parent.add(se);
    };
    constructor.createString = function(parent, type, value) {
        var se = MKVType.createByType(type);
        se.setString(value);
        parent.add(se);
    };
    constructor.createDate = function(parent, type, value) {
        var se = MKVType.createByType(type);
        se.setDate(value);
        parent.add(se);
    };
    constructor.createBuffer = function(parent, type, value) {
        var se = MKVType.createByType(type);
        se.setBuf(value);
        parent.add(se);
    };
    constructor.createDouble = function(parent, type, value) {
        try {
            var se = MKVType.createByType(type);
            se.setDouble(value);
            parent.add(se);
        }catch (cce) {
             throw new RuntimeException("Element of type " + type + " can't be cast to EbmlFloat", cce);
        }
    };
    prototype.addVideoTrack = function(codec, meta) {
        return this.createVideoTrack(meta, MKVMuxer.codec2mkv.get(codec));
    };
    prototype.addAudioTrack = function(codec, meta) {
        this.audioTrack = new MKVMuxerTrack();
        this.tracks.add(this.audioTrack);
        this.audioTrack.codecId = MKVMuxer.codec2mkv.get(codec);
        this.audioTrack.trackNo = this.tracks.size();
        return this.audioTrack;
    };
}, {tracks: {name: "List", arguments: ["MKVMuxerTrack"]}, audioTrack: "MKVMuxerTrack", videoTrack: "MKVMuxerTrack", mkvInfo: "EbmlMaster", mkvTracks: "EbmlMaster", mkvCues: "EbmlMaster", mkvSeekHead: "EbmlMaster", clusterList: {name: "List", arguments: ["EbmlMaster"]}, sink: "SeekableByteChannel", codec2mkv: {name: "Map", arguments: ["Codec", null]}}, {});
(function() {
    MKVMuxer.codec2mkv.put(Codec.H264, "V_MPEG4/ISO/AVC");
    MKVMuxer.codec2mkv.put(Codec.VP8, "V_VP8");
    MKVMuxer.codec2mkv.put(Codec.VP9, "V_VP9");
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Pulls frames from MPEG elementary stream
 *  
 *  @author The JCodec project
 *  
 */
var MPEGES = function(channel, fetchSize) {
    SegmentReader.call(this, channel, fetchSize);
};
MPEGES = stjs.extend(MPEGES, SegmentReader, [], function(constructor, prototype) {
    prototype.frameNo = 0;
    prototype.lastKnownDuration = 0;
    /**
     *  Reads one MPEG1/2 video frame from MPEG1/2 elementary stream into a
     *  provided buffer.
     *  
     *  @param buffer
     *             A buffer to use for the data.
     *  @return A packet with a video frame or null at for end of the stream. The
     *          data buffer inside the packet will be a sub-buffer of a 'buffer'
     *          provided as an argument.
     *  @throws IOException
     */
    prototype.frame = function(buffer) {
        var dup = buffer.duplicate();
         while (this.curMarker != 256 && this.curMarker != 435 && this.skipToMarker())
            ;
         while (this.curMarker != 256 && this.readToNextMarker(dup))
            ;
        this.readToNextMarker(dup);
         while (this.curMarker != 256 && this.curMarker != 435 && this.readToNextMarker(dup))
            ;
        dup.flip();
        var ph = MPEGDecoder.getPictureHeader(dup.duplicate());
        return dup.hasRemaining() ? new MPEGPacket(dup, 0, 90000, 0, this.frameNo++, ph.picture_coding_type <= MPEGConst.IntraCoded ? Packet.FrameType.KEY : Packet.FrameType.INTER, null) : null;
    };
    /**
     *  Reads one MPEG1/2 video frame from MPEG1/2 elementary stream.
     *  
     *  @return A packet with a video frame or null at the end of stream.
     *  @throws IOException
     */
    prototype.getFrame = function() {
         while (this.curMarker != 256 && this.curMarker != 435 && this.skipToMarker())
            ;
        var buffers = new ArrayList();
         while (this.curMarker != 256 && !this.done)
            this.readToNextMarkerBuffers(buffers);
        this.readToNextMarkerBuffers(buffers);
         while (this.curMarker != 256 && this.curMarker != 435 && !this.done)
            this.readToNextMarkerBuffers(buffers);
        var dup = NIOUtils.combineBuffers(buffers);
        var ph = MPEGDecoder.getPictureHeader(dup.duplicate());
        return dup.hasRemaining() ? new MPEGPacket(dup, 0, 90000, 0, this.frameNo++, ph.picture_coding_type <= MPEGConst.IntraCoded ? Packet.FrameType.KEY : Packet.FrameType.INTER, null) : null;
    };
}, {channel: "ReadableByteChannel", buf: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var MTSDump = function(ch, targetGuid) {
    MPSDump.call(this, ch);
    this.buf = ByteBuffer.allocate(188 * 1024);
    this.tsBuf = ByteBuffer.allocate(188);
    this.guid = targetGuid;
    this.buf.setPosition(this.buf.limit());
    this.tsBuf.setPosition(this.tsBuf.limit());
};
MTSDump = stjs.extend(MTSDump, MPSDump, [], function(constructor, prototype) {
    constructor.DUMP_FROM = MainUtils.Flag.flag("dump-from", null, "Stop reading at timestamp");
    constructor.STOP_AT = MainUtils.Flag.flag("stop-at", null, "Start dumping from timestamp");
    constructor.ALL_FLAGS = [MTSDump.DUMP_FROM, MTSDump.STOP_AT];
    prototype.guid = 0;
    prototype.buf = null;
    prototype.tsBuf = null;
    prototype.tsNo = 0;
    prototype.globalPayload = 0;
    prototype.payloads = null;
    prototype.nums = null;
    prototype.prevPayloads = null;
    prototype.prevNums = null;
    constructor.main2 = function(args) {
        var ch = null;
        try {
            var cmd = MainUtils.parseArguments(args, MTSDump.ALL_FLAGS);
            if (cmd.args.length < 1) {
                MainUtils.printHelp(MTSDump.ALL_FLAGS, Arrays.asList("file name", "guid"));
                return;
            } else if (cmd.args.length == 1) {
                System.out.println("MTS programs:");
                MTSDump.dumpProgramPids(NIOUtils.readableChannel(new File(cmd.args[0])));
                return;
            }
            ch = NIOUtils.readableChannel(new File(cmd.args[0]));
            var dumpAfterPts = cmd.getLongFlag(MTSDump.DUMP_FROM);
            var stopPts = cmd.getLongFlag(MTSDump.STOP_AT);
            new MTSDump(ch, Integer.parseInt(cmd.args[1])).dump(dumpAfterPts, stopPts);
        } finally {
            NIOUtils.closeQuietly(ch);
        }
    };
    constructor.dumpProgramPids = function(readableFileChannel) {
        var pids = new HashSet();
        var buf = ByteBuffer.allocate(188 * 10240);
        readableFileChannel.read(buf);
        buf.flip();
        buf.setLimit(buf.limit() - (buf.limit() % 188));
        var pmtPid = -1;
         while (buf.hasRemaining()){
            var tsBuf = NIOUtils.read(buf, 188);
            Preconditions.checkState(71 == (tsBuf.get() & 255));
            var guidFlags = ((tsBuf.get() & 255) << 8) | (tsBuf.get() & 255);
            var guid = guidFlags & 8191;
            System.out.println(guid);
            if (guid != 0) 
                pids.add(guid);
            if (guid == 0 || guid == pmtPid) {
                var payloadStart = (guidFlags >> 14) & 1;
                var b0 = tsBuf.get() & 255;
                var counter = b0 & 15;
                var payloadOff = 0;
                if ((b0 & 32) != 0) {
                    NIOUtils.skip(tsBuf, (tsBuf.get() & 255));
                }
                if (payloadStart == 1) {
                    NIOUtils.skip(tsBuf, (tsBuf.get() & 255));
                }
                if (guid == 0) {
                    var pat = PATSection.parsePAT(tsBuf);
                    var programs = pat.getPrograms();
                    pmtPid = programs.values()[0];
                    MTSDump.printPat(pat);
                } else if (guid == pmtPid) {
                    var pmt = PMTSection.parsePMT(tsBuf);
                    MTSDump.printPmt(pmt);
                    return;
                }
            }
        }
        for (var iterator$pid = pids.iterator(); iterator$pid.hasNext(); ) {
            var pid = iterator$pid.next();
            System.out.println(pid);
        }
    };
    constructor.printPat = function(pat) {
        var programs = pat.getPrograms();
        System.out.print("PAT: ");
        var keys = programs.keys();
        for (var index$i = 0, arr$i = keys; index$i < arr$i.length; index$i++) {
            var i = arr$i[index$i];
            System.out.print(i + ":" + programs.get(i) + ", ");
        }
        System.out.println();
    };
    constructor.printPmt = function(pmt) {
        System.out.print("PMT: ");
        for (var index$pmtStream = 0, arr$pmtStream = pmt.getStreams(); index$pmtStream < arr$pmtStream.length; index$pmtStream++) {
            var pmtStream = arr$pmtStream[index$pmtStream];
            System.out.print(pmtStream.getPid() + ":" + pmtStream.getStreamTypeTag() + ", ");
            for (var iterator$descriptor = pmtStream.getDesctiptors().iterator(); iterator$descriptor.hasNext(); ) {
                var descriptor = iterator$descriptor.next();
                System.out.println(Platform.toJSON(descriptor));
            }
        }
        System.out.println();
    };
    prototype.logPes = function(pkt, hdrSize, payload) {
        System.out.println(pkt.streamId + "(" + (pkt.streamId >= 224 ? "video" : "audio") + ") [ts#" + this.mapPos(pkt.pos) + ", " + (payload.remaining() + hdrSize) + "b], pts: " + pkt.pts + ", dts: " + pkt.dts);
    };
    prototype.mapPos = function(pos) {
        var left = this.globalPayload;
        for (var i = this.payloads.length - 1; i >= 0; --i) {
            left -= this.payloads[i];
            if (left <= pos) {
                return this.nums[i];
            }
        }
        if (this.prevPayloads != null) {
            for (var i = this.prevPayloads.length - 1; i >= 0; --i) {
                left -= this.prevPayloads[i];
                if (left <= pos) {
                    return this.prevNums[i];
                }
            }
        }
        return -1;
    };
    prototype.fillBuffer = function(dst) {
        var payloads = IntArrayList.createIntArrayList();
        var nums = IntArrayList.createIntArrayList();
        var remaining = dst.remaining();
        try {
            dst.putBuf(NIOUtils.read(this.tsBuf, Math.min(dst.remaining(), this.tsBuf.remaining())));
             while (dst.hasRemaining()){
                if (!this.buf.hasRemaining()) {
                    var dub = this.buf.duplicate();
                    dub.clear();
                    var read = this.ch.read(dub);
                    if (read == -1) 
                        return dst.remaining() != remaining ? remaining - dst.remaining() : -1;
                    dub.flip();
                    dub.setLimit(dub.limit() - (dub.limit() % 188));
                    this.buf = dub;
                }
                this.tsBuf = NIOUtils.read(this.buf, 188);
                Preconditions.checkState(71 == (this.tsBuf.get() & 255));
                ++this.tsNo;
                var guidFlags = ((this.tsBuf.get() & 255) << 8) | (this.tsBuf.get() & 255);
                var guid = stjs.trunc(guidFlags) & 8191;
                if (guid != this.guid) 
                    continue;
                var payloadStart = (guidFlags >> 14) & 1;
                var b0 = this.tsBuf.get() & 255;
                var counter = b0 & 15;
                if ((b0 & 32) != 0) {
                    NIOUtils.skip(this.tsBuf, this.tsBuf.get() & 255);
                }
                this.globalPayload += this.tsBuf.remaining();
                payloads.add(this.tsBuf.remaining());
                nums.add(this.tsNo - 1);
                dst.putBuf(NIOUtils.read(this.tsBuf, Math.min(dst.remaining(), this.tsBuf.remaining())));
            }
        } finally {
            this.prevPayloads = this.payloads;
            this.payloads = payloads.toArray();
            this.prevNums = this.nums;
            this.nums = nums.toArray();
        }
        return remaining - dst.remaining();
    };
}, {DUMP_FROM: "MainUtils.Flag", STOP_AT: "MainUtils.Flag", ALL_FLAGS: "Array", buf: "ByteBuffer", tsBuf: "ByteBuffer", payloads: "Int32Array", nums: "Int32Array", prevPayloads: "Int32Array", prevNums: "Int32Array", DUMP_FROM: "MainUtils.Flag", STOP_AT: "MainUtils.Flag", ALL_FLAGS: "Array", ch: "ReadableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 1/2 Decoder, downscaled 2x2
 *  
 *  @author The JCodec project
 *  
 */
var Mpeg2Thumb2x2 = function() {
    MPEGDecoder.call(this);
};
Mpeg2Thumb2x2 = stjs.extend(Mpeg2Thumb2x2, MPEGDecoder, [], function(constructor, prototype) {
    prototype.localPred = null;
    prototype.oldPred = null;
    prototype.blockIntra = function(bits, vlcCoeff, block, intra_dc_predictor, blkIdx, scan, escSize, intra_dc_mult, qScale, qmat) {
        var cc = MPEGConst.BLOCK_TO_CC[blkIdx];
        var size = (cc == 0 ? MPEGConst.vlcDCSizeLuma : MPEGConst.vlcDCSizeChroma).readVLC(bits);
        var delta = (size != 0) ? MPEGDecoder.mpegSigned(bits, size) : 0;
        intra_dc_predictor[cc] = intra_dc_predictor[cc] + delta;
        block[0] = intra_dc_predictor[cc] * intra_dc_mult;
        block[1] = block[2] = block[3] = 0;
        var idx, readVLC = 0;
        for (idx = 0; idx < 6; ) {
            readVLC = vlcCoeff.readVLC(bits);
            var level;
            if (readVLC == MPEGConst.CODE_END) {
                break;
            } else if (readVLC == MPEGConst.CODE_ESCAPE) {
                idx += bits.readNBit(6) + 1;
                level = MPEGDecoder.twosSigned(bits, escSize) * qScale * qmat[idx];
                level = level >= 0 ? (level >> 4) : -(-level >> 4);
            } else {
                idx += (readVLC >> 6) + 1;
                level = MPEGDecoder.toSigned(((readVLC & 63) * qScale * qmat[idx]) >> 4, bits.read1Bit());
            }
            block[scan[idx]] = level;
        }
        if (readVLC != MPEGConst.CODE_END) 
            this.finishOff(bits, idx, vlcCoeff, escSize);
        IDCT2x2.idct(block, 0);
    };
    prototype.finishOff = function(bits, idx, vlcCoeff, escSize) {
        for (; idx < 64; ) {
            var readVLC = vlcCoeff.readVLC(bits);
            if (readVLC == MPEGConst.CODE_END) {
                break;
            } else if (readVLC == MPEGConst.CODE_ESCAPE) {
                idx += bits.readNBit(6) + 1;
                bits.readNBit(escSize);
            } else {
                bits.read1Bit();
            }
        }
    };
    prototype.blockInter = function(bits, vlcCoeff, block, scan, escSize, qScale, qmat) {
        block[1] = block[2] = block[3] = 0;
        var idx = -1;
        if (vlcCoeff == MPEGConst.vlcCoeff0 && bits.checkNBit(1) == 1) {
            bits.read1Bit();
            block[0] = MPEGDecoder.toSigned(MPEGDecoder.quantInter(1, qScale * qmat[0]), bits.read1Bit());
            idx++;
        } else {
            block[0] = 0;
        }
        var readVLC = 0;
        for (; idx < 6; ) {
            readVLC = vlcCoeff.readVLC(bits);
            var ac;
            if (readVLC == MPEGConst.CODE_END) {
                break;
            } else if (readVLC == MPEGConst.CODE_ESCAPE) {
                idx += bits.readNBit(6) + 1;
                ac = MPEGDecoder.quantInterSigned(MPEGDecoder.twosSigned(bits, escSize), qScale * qmat[idx]);
            } else {
                idx += (readVLC >> 6) + 1;
                ac = MPEGDecoder.toSigned(MPEGDecoder.quantInter(readVLC & 63, qScale * qmat[idx]), bits.read1Bit());
            }
            block[scan[idx]] = ac;
        }
        if (readVLC != MPEGConst.CODE_END) 
            this.finishOff(bits, idx, vlcCoeff, escSize);
        IDCT2x2.idct(block, 0);
    };
    prototype.decodeMacroblock = function(ph, context, prevAddr, qScaleCode, buf, stride, bits, vertOff, vertStep, pred) {
        if (this.localPred == null || this.oldPred != pred) {
            this.localPred = new MPEGPredQuad(pred);
            this.oldPred = pred;
        }
        return MPEGDecoder.prototype.decodeMacroblock.call(this, ph, context, prevAddr, qScaleCode, buf, stride, bits, vertOff, vertStep, this.localPred);
    };
    constructor.BLOCK_POS_X = new Int32Array([0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2]);
    constructor.BLOCK_POS_Y = new Int32Array([0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]);
    prototype.mapBlock = function(block, out, blkIdx, dctType, chromaFormat) {
        var stepVert = chromaFormat == SequenceExtension.Chroma420 && (blkIdx == 4 || blkIdx == 5) ? 0 : dctType;
        var log2stride = blkIdx < 4 ? 2 : 2 - MPEGConst.SQUEEZE_X[chromaFormat];
        var blkIdxExt = blkIdx + (dctType << 4);
        var x = Mpeg2Thumb2x2.BLOCK_POS_X[blkIdxExt];
        var y = Mpeg2Thumb2x2.BLOCK_POS_Y[blkIdxExt];
        var off = (y << log2stride) + x, stride = 1 << (log2stride + stepVert);
        out[off] += block[0];
        out[off + 1] += block[1];
        out[off + stride] += block[2];
        out[off + stride + 1] += block[3];
    };
    prototype.put = function(mbPix, buf, stride, chromaFormat, mbX, mbY, width, height, vertOff, vertStep) {
        var chromaStride = (stride + (1 << MPEGConst.SQUEEZE_X[chromaFormat]) - 1) >> MPEGConst.SQUEEZE_X[chromaFormat];
        var chromaMBW = 2 - MPEGConst.SQUEEZE_X[chromaFormat];
        var chromaMBH = 2 - MPEGConst.SQUEEZE_Y[chromaFormat];
        this.putSub(buf[0], (mbY << 2) * (stride << vertStep) + vertOff * stride + (mbX << 2), stride << vertStep, mbPix[0], 2, 2);
        this.putSub(buf[1], (mbY << chromaMBH) * (chromaStride << vertStep) + vertOff * chromaStride + (mbX << chromaMBW), chromaStride << vertStep, mbPix[1], chromaMBW, chromaMBH);
        this.putSub(buf[2], (mbY << chromaMBH) * (chromaStride << vertStep) + vertOff * chromaStride + (mbX << chromaMBW), chromaStride << vertStep, mbPix[2], chromaMBW, chromaMBH);
    };
    prototype.putSub = function(big, off, stride, block, mbW, mbH) {
        var blOff = 0;
        if (mbW == 1) {
            big[off] = MPEGDecoder.clipTo8Bit(block[blOff]);
            big[off + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 1]);
            big[off + stride] = MPEGDecoder.clipTo8Bit(block[blOff + 2]);
            big[off + stride + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 3]);
            if (mbH == 2) {
                off += stride << 1;
                big[off] = MPEGDecoder.clipTo8Bit(block[blOff + 4]);
                big[off + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 5]);
                big[off + stride] = MPEGDecoder.clipTo8Bit(block[blOff + 6]);
                big[off + stride + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 7]);
            }
        } else {
            for (var i = 0; i < 4; i++) {
                big[off] = MPEGDecoder.clipTo8Bit(block[blOff]);
                big[off + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 1]);
                big[off + 2] = MPEGDecoder.clipTo8Bit(block[blOff + 2]);
                big[off + 3] = MPEGDecoder.clipTo8Bit(block[blOff + 3]);
                off += stride;
                blOff += 4;
            }
        }
    };
    constructor.scan2x2 = [new Int32Array([0, 1, 2, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]), new Int32Array([0, 2, 4, 4, 1, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4])];
    prototype.initContext = function(sh, ph) {
        var context = MPEGDecoder.prototype.initContext.call(this, sh, ph);
        context.codedWidth >>= 2;
        context.codedHeight >>= 2;
        context.picWidth >>= 2;
        context.picHeight >>= 2;
        context.scan = Mpeg2Thumb2x2.scan2x2[ph.pictureCodingExtension == null ? 0 : ph.pictureCodingExtension.alternate_scan];
        return context;
    };
}, {localPred: "MPEGPred", oldPred: "MPEGPred", BLOCK_POS_X: "Int32Array", BLOCK_POS_Y: "Int32Array", scan2x2: "Array", sh: "SequenceHeader", gh: "GOPHeader", refFrames: "Array", refFields: "Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 1/2 Decoder, downscaled 4x4
 *  
 *  @author The JCodec project
 *  
 */
var Mpeg2Thumb4x4 = function() {
    MPEGDecoder.call(this);
};
Mpeg2Thumb4x4 = stjs.extend(Mpeg2Thumb4x4, MPEGDecoder, [], function(constructor, prototype) {
    prototype.localPred = null;
    prototype.oldPred = null;
    prototype.blockIntra = function(bits, vlcCoeff, block, intra_dc_predictor, blkIdx, scan, escSize, intra_dc_mult, qScale, qmat) {
        var cc = MPEGConst.BLOCK_TO_CC[blkIdx];
        var size = (cc == 0 ? MPEGConst.vlcDCSizeLuma : MPEGConst.vlcDCSizeChroma).readVLC(bits);
        var delta = (size != 0) ? MPEGDecoder.mpegSigned(bits, size) : 0;
        intra_dc_predictor[cc] = intra_dc_predictor[cc] + delta;
        Arrays.fillRange(block, 1, 16, 0);
        block[0] = intra_dc_predictor[cc] * intra_dc_mult;
        var idx, readVLC = 0;
        for (idx = 0; idx < 19 + (scan == Mpeg2Thumb4x4.scan4x4[1] ? 7 : 0); ) {
            readVLC = vlcCoeff.readVLC(bits);
            var level;
            if (readVLC == MPEGConst.CODE_END) {
                break;
            } else if (readVLC == MPEGConst.CODE_ESCAPE) {
                idx += bits.readNBit(6) + 1;
                level = MPEGDecoder.twosSigned(bits, escSize) * qScale * qmat[idx];
                level = level >= 0 ? (level >> 4) : -(-level >> 4);
            } else {
                idx += (readVLC >> 6) + 1;
                level = MPEGDecoder.toSigned(((readVLC & 63) * qScale * qmat[idx]) >> 4, bits.read1Bit());
            }
            block[scan[idx]] = level;
        }
        if (readVLC != MPEGConst.CODE_END) 
            this.finishOff(bits, idx, vlcCoeff, escSize);
        IDCT4x4.idct(block, 0);
    };
    prototype.finishOff = function(bits, idx, vlcCoeff, escSize) {
        for (; idx < 64; ) {
            var readVLC = vlcCoeff.readVLC(bits);
            if (readVLC == MPEGConst.CODE_END) {
                break;
            } else if (readVLC == MPEGConst.CODE_ESCAPE) {
                idx += bits.readNBit(6) + 1;
                bits.readNBit(escSize);
            } else {
                bits.read1Bit();
            }
        }
    };
    prototype.blockInter = function(bits, vlcCoeff, block, scan, escSize, qScale, qmat) {
        Arrays.fillRange(block, 1, 16, 0);
        var idx = -1;
        if (vlcCoeff == MPEGConst.vlcCoeff0 && bits.checkNBit(1) == 1) {
            bits.read1Bit();
            block[0] = MPEGDecoder.toSigned(MPEGDecoder.quantInter(1, qScale * qmat[0]), bits.read1Bit());
            idx++;
        } else {
            block[0] = 0;
        }
        var readVLC = 0;
        for (; idx < 19 + (scan == Mpeg2Thumb4x4.scan4x4[1] ? 7 : 0); ) {
            readVLC = vlcCoeff.readVLC(bits);
            var ac;
            if (readVLC == MPEGConst.CODE_END) {
                break;
            } else if (readVLC == MPEGConst.CODE_ESCAPE) {
                idx += bits.readNBit(6) + 1;
                ac = MPEGDecoder.quantInterSigned(MPEGDecoder.twosSigned(bits, escSize), qScale * qmat[idx]);
            } else {
                idx += (readVLC >> 6) + 1;
                ac = MPEGDecoder.toSigned(MPEGDecoder.quantInter(readVLC & 63, qScale * qmat[idx]), bits.read1Bit());
            }
            block[scan[idx]] = ac;
        }
        if (readVLC != MPEGConst.CODE_END) 
            this.finishOff(bits, idx, vlcCoeff, escSize);
        IDCT4x4.idct(block, 0);
    };
    prototype.decodeMacroblock = function(ph, context, prevAddr, qScaleCode, buf, stride, bits, vertOff, vertStep, pred) {
        if (this.localPred == null || this.oldPred != pred) {
            this.localPred = new MPEGPredDbl(pred);
            this.oldPred = pred;
        }
        return MPEGDecoder.prototype.decodeMacroblock.call(this, ph, context, prevAddr, qScaleCode, buf, stride, bits, vertOff, vertStep, this.localPred);
    };
    constructor.BLOCK_POS_X = new Int32Array([0, 4, 0, 4, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 4, 4, 4, 4]);
    constructor.BLOCK_POS_Y = new Int32Array([0, 0, 4, 4, 0, 0, 4, 4, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]);
    prototype.mapBlock = function(block, out, blkIdx, dctType, chromaFormat) {
        var stepVert = chromaFormat == SequenceExtension.Chroma420 && (blkIdx == 4 || blkIdx == 5) ? 0 : dctType;
        var log2stride = blkIdx < 4 ? 3 : 3 - MPEGConst.SQUEEZE_X[chromaFormat];
        var blkIdxExt = blkIdx + (dctType << 4);
        var x = Mpeg2Thumb4x4.BLOCK_POS_X[blkIdxExt];
        var y = Mpeg2Thumb4x4.BLOCK_POS_Y[blkIdxExt];
        var off = (y << log2stride) + x, stride = 1 << (log2stride + stepVert);
        for (var i = 0; i < 16; i += 4 , off += stride) {
            out[off] += block[i];
            out[off + 1] += block[i + 1];
            out[off + 2] += block[i + 2];
            out[off + 3] += block[i + 3];
        }
    };
    prototype.put = function(mbPix, buf, stride, chromaFormat, mbX, mbY, width, height, vertOff, vertStep) {
        var chromaStride = (stride + (1 << MPEGConst.SQUEEZE_X[chromaFormat]) - 1) >> MPEGConst.SQUEEZE_X[chromaFormat];
        var chromaMBW = 3 - MPEGConst.SQUEEZE_X[chromaFormat];
        var chromaMBH = 3 - MPEGConst.SQUEEZE_Y[chromaFormat];
        this.putSub(buf[0], (mbY << 3) * (stride << vertStep) + vertOff * stride + (mbX << 3), stride << vertStep, mbPix[0], 3, 3);
        this.putSub(buf[1], (mbY << chromaMBH) * (chromaStride << vertStep) + vertOff * chromaStride + (mbX << chromaMBW), chromaStride << vertStep, mbPix[1], chromaMBW, chromaMBH);
        this.putSub(buf[2], (mbY << chromaMBH) * (chromaStride << vertStep) + vertOff * chromaStride + (mbX << chromaMBW), chromaStride << vertStep, mbPix[2], chromaMBW, chromaMBH);
    };
    prototype.putSub = function(big, off, stride, block, mbW, mbH) {
        var blOff = 0;
        if (mbW == 2) {
            for (var i = 0; i < (1 << mbH); i++) {
                big[off] = MPEGDecoder.clipTo8Bit(block[blOff]);
                big[off + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 1]);
                big[off + 2] = MPEGDecoder.clipTo8Bit(block[blOff + 2]);
                big[off + 3] = MPEGDecoder.clipTo8Bit(block[blOff + 3]);
                blOff += 4;
                off += stride;
            }
        } else {
            for (var i = 0; i < (1 << mbH); i++) {
                big[off] = MPEGDecoder.clipTo8Bit(block[blOff]);
                big[off + 1] = MPEGDecoder.clipTo8Bit(block[blOff + 1]);
                big[off + 2] = MPEGDecoder.clipTo8Bit(block[blOff + 2]);
                big[off + 3] = MPEGDecoder.clipTo8Bit(block[blOff + 3]);
                big[off + 4] = MPEGDecoder.clipTo8Bit(block[blOff + 4]);
                big[off + 5] = MPEGDecoder.clipTo8Bit(block[blOff + 5]);
                big[off + 6] = MPEGDecoder.clipTo8Bit(block[blOff + 6]);
                big[off + 7] = MPEGDecoder.clipTo8Bit(block[blOff + 7]);
                blOff += 8;
                off += stride;
            }
        }
    };
    constructor.scan4x4 = [new Int32Array([0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 16, 13, 10, 7, 16, 16, 16, 11, 14, 16, 16, 16, 16, 16, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]), new Int32Array([0, 4, 8, 12, 1, 5, 2, 6, 9, 13, 16, 16, 16, 16, 16, 16, 16, 16, 14, 10, 3, 7, 16, 16, 11, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16])];
    prototype.initContext = function(sh, ph) {
        var context = MPEGDecoder.prototype.initContext.call(this, sh, ph);
        context.codedWidth >>= 1;
        context.codedHeight >>= 1;
        context.picWidth >>= 1;
        context.picHeight >>= 1;
        context.scan = Mpeg2Thumb4x4.scan4x4[ph.pictureCodingExtension == null ? 0 : ph.pictureCodingExtension.alternate_scan];
        return context;
    };
}, {localPred: "MPEGPred", oldPred: "MPEGPred", BLOCK_POS_X: "Int32Array", BLOCK_POS_Y: "Int32Array", scan4x4: "Array", sh: "SequenceHeader", gh: "GOPHeader", refFrames: "Array", refFields: "Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A utility for manipulation MPEG TS timestamps
 *  
 *  @author The JCodec project
 *  
 */
var TimestampUtil = function() {};
TimestampUtil = stjs.extend(TimestampUtil, null, [], function(constructor, prototype) {
    constructor.STREAM_ALL = "all";
    constructor.STREAM_AUDIO = "audio";
    constructor.STRAM_VIDEO = "video";
    constructor.FLAG_STREAM = MainUtils.Flag.flag("stream", "s", "A stream to shift, i.e. '" + TimestampUtil.STRAM_VIDEO + "' or '" + TimestampUtil.STREAM_AUDIO + "' or '" + TimestampUtil.STREAM_ALL + "' [default]");
    constructor.ALL_FLAGS = [TimestampUtil.FLAG_STREAM];
    constructor.COMMAND_SHIFT = "shift";
    constructor.COMMAND_SCALE = "scale";
    constructor.COMMAND_ROUND = "round";
    constructor.main1 = function(args) {
        var cmd = MainUtils.parseArguments(args, TimestampUtil.ALL_FLAGS);
        if (cmd.args.length < 3) {
            System.out.println("A utility to tweak MPEG TS timestamps.");
            MainUtils.printHelp(TimestampUtil.ALL_FLAGS, Arrays.asList("command", "arg", "in name", "?out file"));
            System.out.println("Where command is:\n\t" + TimestampUtil.COMMAND_SHIFT + "\tShift timestamps of selected stream by arg.\n\t" + TimestampUtil.COMMAND_SCALE + "\tScale timestams of selected stream by arg [num:den].\n\t" + TimestampUtil.COMMAND_ROUND + "\tRound timestamps of selected stream to multiples of arg.");
            return;
        }
        var src = new File(cmd.getArg(2));
        if (cmd.argsLength() > 3) {
            var dst = new File(cmd.getArg(3));
            IOUtils.copyFile(src, dst);
            src = dst;
        }
        var command = cmd.getArg(0);
        var stream = cmd.getStringFlagD(TimestampUtil.FLAG_STREAM, TimestampUtil.STREAM_ALL);
        if (TimestampUtil.COMMAND_SHIFT.equalsIgnoreCase(command)) {
            var shift = Long.parseLong(cmd.getArg(1));
            new (stjs.extend(function TimestampUtil$1(stream) {
                TimestampUtil.BaseCommand.call(this, stream);
            }, TimestampUtil.BaseCommand, [], function(constructor, prototype) {
                prototype.withTimestamp = function(pts, isPts) {
                    return Math.max(pts + shift, 0);
                };
            }, {}, {}))(stream).fix(src);
        } else if (TimestampUtil.COMMAND_SCALE.equalsIgnoreCase(command)) {
            var scale = RationalLarge.parse(cmd.getArg(1));
            new (stjs.extend(function TimestampUtil$2(stream) {
                TimestampUtil.BaseCommand.call(this, stream);
            }, TimestampUtil.BaseCommand, [], function(constructor, prototype) {
                prototype.withTimestamp = function(pts, isPts) {
                    return scale.multiplyS(pts);
                };
            }, {}, {}))(stream).fix(src);
        } else if (TimestampUtil.COMMAND_ROUND.equalsIgnoreCase(command)) {
            var precision = Integer.parseInt(cmd.getArg(1));
            new (stjs.extend(function TimestampUtil$3(stream) {
                TimestampUtil.BaseCommand.call(this, stream);
            }, TimestampUtil.BaseCommand, [], function(constructor, prototype) {
                prototype.withTimestamp = function(pts, isPts) {
                    return Math.round(pts / precision) * precision;
                };
            }, {}, {}))(stream).fix(src);
        }
    };
    constructor.BaseCommand = function(stream) {
        FixTimestamp.call(this);
        this.streamSelector = stream;
    };
    constructor.BaseCommand = stjs.extend(constructor.BaseCommand, FixTimestamp, [], function(constructor, prototype) {
        prototype.streamSelector = null;
        prototype.doWithTimestamp = function(streamId, pts, isPts) {
            if (TimestampUtil.STREAM_ALL.equals(this.streamSelector) || TimestampUtil.STRAM_VIDEO.equals(this.streamSelector) && this.isVideo(streamId) || TimestampUtil.STREAM_AUDIO.equals(this.streamSelector) && this.isAudio(streamId)) {
                return this.withTimestamp(pts, isPts);
            } else {
                return pts;
            }
        };
        prototype.withTimestamp = function(pts, isPts) {};
    }, {}, {});
}, {FLAG_STREAM: "MainUtils.Flag", ALL_FLAGS: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FixHLSTimestamps = function() {
    FixTimestamp.call(this);
    this.lastPts = Array(256);
};
FixHLSTimestamps = stjs.extend(FixHLSTimestamps, FixTimestamp, [], function(constructor, prototype) {
    prototype.lastPts = null;
    constructor.main1 = function(args) {
        var wildCard = args[0];
        var startIdx = Integer.parseInt(args[1]);
        new FixHLSTimestamps().doIt(wildCard, startIdx);
    };
    prototype.doIt = function(wildCard, startIdx) {
        Arrays.fill(this.lastPts, -1);
        for (var i = startIdx; ; i++) {
            var file = new File(String.format(wildCard, i));
            System.out.println(file.getAbsolutePath());
            if (!file.exists()) 
                break;
            this.fix(file);
        }
    };
    prototype.doWithTimestamp = function(streamId, pts, isPts) {
        if (!isPts) 
            return pts;
        if (this.lastPts[streamId] == -1) {
            this.lastPts[streamId] = pts;
            return pts;
        }
        if (this.isVideo(streamId)) {
            this.lastPts[streamId] += 3003;
            return this.lastPts[streamId];
        } else if (this.isAudio(streamId)) {
            this.lastPts[streamId] += 1920;
            return this.lastPts[streamId];
        }
         throw new RuntimeException("Unexpected!!!");
    };
}, {lastPts: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SetBaseTimestamp = function(video, baseTs) {
    FixTimestamp.call(this);
    this.video = video;
    this.baseTs = baseTs;
};
SetBaseTimestamp = stjs.extend(SetBaseTimestamp, FixTimestamp, [], function(constructor, prototype) {
    prototype.baseTs = 0;
    prototype.firstPts = -1;
    prototype.video = false;
    constructor.main1 = function(args) {
        var file = new File(args[0]);
        new SetBaseTimestamp("video".equalsIgnoreCase(args[1]), Integer.parseInt(args[2])).fix(file);
    };
    prototype.doWithTimestamp = function(streamId, pts, isPts) {
        if (this.video && this.isVideo(streamId) || !this.video && this.isAudio(streamId)) {
            if (this.firstPts == -1) 
                this.firstPts = pts;
            return pts - this.firstPts + this.baseTs;
        } else 
            return pts;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  An MP4 file structure (atom)
 *  
 *  @author The JCodec project
 *  
 */
var Header = function(fourcc) {
    this.fourcc = fourcc;
};
Header = stjs.extend(Header, null, [], function(constructor, prototype) {
    constructor.FOURCC_FREE = new Int8Array(['f'.charCodeAt(0), 'r'.charCodeAt(0), 'e'.charCodeAt(0), 'e'.charCodeAt(0)]);
    constructor.MAX_UNSIGNED_INT = 4294967296;
    prototype.fourcc = null;
    prototype.size = 0;
    prototype.lng = false;
    constructor.createHeader = function(fourcc, size) {
        var header = new Header(fourcc);
        header.size = size;
        return header;
    };
    constructor.newHeader = function(fourcc, size, lng) {
        var header = new Header(fourcc);
        header.size = size;
        header.lng = lng;
        return header;
    };
    constructor.read = function(input) {
        var size = 0;
         while (input.remaining() >= 4 && (size = Platform.unsignedInt(input.getInt())) == 0)
            ;
        if (input.remaining() < 4 || size < 8 && size != 1) {
            Logger.error("Broken atom of size " + size);
            return null;
        }
        var fourcc = NIOUtils.readString(input, 4);
        var lng = false;
        if (size == 1) {
            if (input.remaining() >= 8) {
                lng = true;
                size = input.getLong();
            } else {
                Logger.error("Broken atom of size " + size);
                return null;
            }
        }
        return Header.newHeader(fourcc, size, lng);
    };
    prototype.skip = function(di) {
        StringReader.sureSkip(di, this.size - this.headerSize());
    };
    prototype.headerSize = function() {
        return this.lng || (this.size > Header.MAX_UNSIGNED_INT) ? 16 : 8;
    };
    constructor.estimateHeaderSize = function(size) {
        return size + 8 > Header.MAX_UNSIGNED_INT ? 16 : 8;
    };
    prototype.readContents = function(di) {
        var baos = new ByteArrayOutputStream();
        for (var i = 0; i < this.size - this.headerSize(); i++) {
            baos.write(di.read());
        }
        return baos.toByteArray();
    };
    prototype.getFourcc = function() {
        return this.fourcc;
    };
    prototype.getBodySize = function() {
        return this.size - this.headerSize();
    };
    prototype.setBodySize = function(length) {
        this.size = length + this.headerSize();
    };
    prototype.write = function(out) {
        if (this.size > Header.MAX_UNSIGNED_INT) 
            out.putInt(1);
         else 
            out.putInt(((this.size) | 0));
        var bt = JCodecUtil2.asciiString(this.fourcc);
        if (bt != null && bt.length == 4) 
            out.putArr(bt);
         else 
            out.putArr(Header.FOURCC_FREE);
        if (this.size > Header.MAX_UNSIGNED_INT) {
            out.putLong(this.size);
        }
    };
    prototype.writeChannel = function(output) {
        var bb = ByteBuffer.allocate(16);
        this.write(bb);
        bb.flip();
        output.write(bb);
    };
    prototype.getSize = function() {
        return this.size;
    };
    prototype.hashCode = function() {
        var prime = 31;
        var result = 1;
        result = prime * result + ((this.fourcc == null) ? 0 : this.fourcc.hashCode());
        return result;
    };
    prototype.equals = function(obj) {
        if (this == obj) 
            return true;
        if (obj == null) 
            return false;
        if (this.getClass() != obj.getClass()) 
            return false;
        var other = obj;
        if (this.fourcc == null) {
            if (other.fourcc != null) 
                return false;
        } else if (!this.fourcc.equals(other.fourcc)) 
            return false;
        return true;
    };
}, {FOURCC_FREE: "Int8Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  RIFF 'AVI '            Audio/Video Interleaved file
 *   LIST 'hdrl'        Header LIST
 *       'avih'         Main AVI header
 *       LIST 'strl'    Video stream LIST
 *           'strh'     Video stream header
 *           'strf'     Video format
 *           <Optional Open DML Super Index + List of standard indexes >
 *       LIST 'strl'    Audio stream LIST
 *           'strh'     Audio stream header
 *           'strf'     Audio format
 *           <Optional Open DML Super Index + List of standard indexes >
 *   LIST 'movi'        Main data LIST
 *       '01wb'         Audio data
 *       '00dc'         Video frame
 *       ...
 *   'idx1'             Index    <Optional old Avi Index>
 *  
 *  @author Owen McGovern
 */
var AVIReader = function(src) {
    this.raf = DataReader.createDataReader(src, ByteOrder.LITTLE_ENDIAN);
    this.aviIndexes = new ArrayList();
};
AVIReader = stjs.extend(AVIReader, null, [], function(constructor, prototype) {
    constructor.FOURCC_RIFF = 1179011410;
    constructor.FOURCC_AVI = 541677121;
    constructor.FOURCC_AVIX = 1481201217;
    constructor.FOURCC_AVIH = 1751742049;
    constructor.FOURCC_LIST = 1414744396;
    constructor.FOURCC_HDRL = 1819436136;
    constructor.FOURCC_JUNK = 1263424842;
    constructor.FOURCC_INDX = 2019847785;
    constructor.FOURCC_IDXL = 829973609;
    constructor.FOURCC_STRL = 1819440243;
    constructor.FOURCC_STRH = 1752331379;
    constructor.FOURCC_STRF = 1718776947;
    constructor.FOURCC_MOVI = 1769369453;
    constructor.FOURCC_REC = 543384946;
    constructor.FOURCC_SEGM = 1835492723;
    constructor.FOURCC_ODML = 1819108463;
    constructor.FOURCC_VIDS = 1935960438;
    constructor.FOURCC_AUDS = 1935963489;
    constructor.FOURCC_MIDS = 1935960429;
    constructor.FOURCC_TXTS = 1937012852;
    constructor.FOURCC_strd = 1685222515;
    constructor.FOURCC_strn = 1852994675;
    constructor.AVIF_HASINDEX = 16;
    constructor.AVIF_MUSTUSEINDEX = 32;
    constructor.AVIF_ISINTERLEAVED = 256;
    constructor.AVIF_TRUSTCKTYPE = 2048;
    constructor.AVIF_WASCAPTUREFILE = 65536;
    constructor.AVIF_COPYRIGHTED = 131072;
    constructor.AVIIF_LIST = 1;
    constructor.AVIIF_KEYFRAME = 16;
    constructor.AVIIF_FIRSTPART = 32;
    constructor.AVIIF_LASTPART = 64;
    constructor.AVIIF_NOTIME = 256;
    constructor.AUDIO_FORMAT_PCM = 1;
    constructor.AUDIO_FORMAT_MP3 = 85;
    constructor.AUDIO_FORMAT_AC3 = 8192;
    constructor.AUDIO_FORMAT_DTS = 8193;
    constructor.AUDIO_FORMAT_VORBIS = 22127;
    constructor.AUDIO_FORMAT_EXTENSIBLE = 65534;
    prototype.AVI_INDEX_OF_INDEXES = 0;
    prototype.AVI_INDEX_OF_CHUNKS = 1;
    prototype.AVI_INDEX_OF_TIMED_CHUNKS = 2;
    prototype.AVI_INDEX_OF_SUB_2FIELD = 3;
    prototype.AVI_INDEX_IS_DATA = 128;
    constructor.STDINDEXSIZE = 16384;
    constructor.SIZE_MASK = 4294967295;
    prototype.raf = null;
    prototype.fileLeft = 0;
    prototype.aviHeader = null;
    prototype.streamHeaders = null;
    prototype.streamFormats = null;
    prototype.aviIndexes = null;
    prototype.openDmlSuperIndex = null;
    prototype.ps = null;
    prototype.skipFrames = true;
    constructor.fromFourCC = function(str) {
        var strBytes = str.getBytes();
        if (strBytes.length != 4) 
             throw new IllegalArgumentException("Expected 4 bytes not " + strBytes.length);
        var fourCCInt = strBytes[3];
        fourCCInt = (fourCCInt <<= 8) | strBytes[2];
        fourCCInt = (fourCCInt <<= 8) | strBytes[1];
        fourCCInt = (fourCCInt <<= 8) | strBytes[0];
        return (fourCCInt);
    };
    /**
     *  
     *  @param fourcc
     *  @return
     */
    constructor.toFourCC = function(fourcc) {
        var sb = new StringBuilder();
        for (var i = 0; i < 4; i++) {
            var c = fourcc & 255;
            sb.append(Character.toString(((c) & 65535)));
            fourcc >>= 8;
        }
        return sb.toString();
    };
    prototype.getFileLeft = function() {
        return (this.fileLeft);
    };
    prototype.getAviIndexes = function() {
        return (this.aviIndexes);
    };
    prototype.parse = function() {
        try {
            var t1 = System.currentTimeMillis();
            var fileSize = this.raf.size();
            this.fileLeft = fileSize;
            var numStreams = 0;
            var streamIndex = -1;
            var videoFrameNo = 1;
            var dwFourCC = this.raf.readInt();
            if (dwFourCC != AVIReader.FOURCC_RIFF) 
                 throw new FormatException("No RIFF header found");
            var aviItem = new AVIReader.AVIList();
            aviItem.read(dwFourCC, this.raf);
            Logger.debug(aviItem.toString());
            var previousStreamType = 0;
            do {
                dwFourCC = this.raf.readInt();
                var dwFourCCStr = AVIReader.toFourCC(dwFourCC);
                switch (dwFourCC) {
                    case AVIReader.FOURCC_RIFF:
                        {
                            aviItem = new AVIReader.AVIList();
                            aviItem.read(dwFourCC, this.raf);
                            break;
                        }case AVIReader.FOURCC_LIST:
                        {
                            aviItem = new AVIReader.AVIList();
                            aviItem.read(dwFourCC, this.raf);
                            if ((aviItem).getListType() == AVIReader.FOURCC_MOVI) {
                                aviItem.skip(this.raf);
                            }
                            break;
                        }case AVIReader.FOURCC_STRL:
                        {
                            aviItem = new AVIReader.AVIList();
                            aviItem.read(dwFourCC, this.raf);
                            break;
                        }case AVIReader.FOURCC_AVIH:
                        {
                            aviItem = this.aviHeader = new AVIReader.AVITag_AVIH();
                            aviItem.read(dwFourCC, this.raf);
                            numStreams = this.aviHeader.getStreams();
                            this.streamHeaders = Array(numStreams);
                            this.streamFormats = Array(numStreams);
                            this.openDmlSuperIndex = Array(numStreams);
                            break;
                        }case AVIReader.FOURCC_STRH:
                        {
                            if (streamIndex >= numStreams) {
                                 throw new IllegalStateException("Read more stream headers than expected, expected [" + numStreams + "]");
                            }
                            streamIndex++;
                            aviItem = this.streamHeaders[streamIndex] = new AVIReader.AVITag_STRH();
                            aviItem.read(dwFourCC, this.raf);
                            previousStreamType = (aviItem).getType();
                            break;
                        }case AVIReader.FOURCC_STRF:
                        {
                            switch (previousStreamType) {
                                case AVIReader.FOURCC_VIDS:
                                    {
                                        aviItem = this.streamFormats[streamIndex] = new AVIReader.AVITag_BitmapInfoHeader();
                                        aviItem.read(dwFourCC, this.raf);
                                        break;
                                    }case AVIReader.FOURCC_AUDS:
                                    {
                                        aviItem = this.streamFormats[streamIndex] = new AVIReader.AVITag_WaveFormatEx();
                                        aviItem.read(dwFourCC, this.raf);
                                        break;
                                    }default:
                                    {
                                         throw new IOException("Expected vids or auds got [" + AVIReader.toFourCC(previousStreamType) + "]");
                                    }}
                            break;
                        }case AVIReader.FOURCC_SEGM:
                        {
                            aviItem = new AVIReader.AVI_SEGM();
                            aviItem.read(dwFourCC, this.raf);
                            aviItem.skip(this.raf);
                            break;
                        }case AVIReader.FOURCC_IDXL:
                        {
                            aviItem = new AVIReader.AVITag_AviIndex();
                            aviItem.read(dwFourCC, this.raf);
                            this.aviIndexes.add(aviItem);
                            break;
                        }case AVIReader.FOURCC_INDX:
                        {
                            this.openDmlSuperIndex[streamIndex] = new AVIReader.AVITag_AviDmlSuperIndex();
                            this.openDmlSuperIndex[streamIndex].read(dwFourCC, this.raf);
                            aviItem = this.openDmlSuperIndex[streamIndex];
                            break;
                        }default:
                        {
                            if (dwFourCCStr.endsWith("db")) {
                                aviItem = new AVIReader.AVITag_VideoChunk(false, this.raf);
                                aviItem.read(dwFourCC, this.raf);
                                if (this.skipFrames) {
                                    aviItem.skip(this.raf);
                                } else {
                                    var videoFrameData = (aviItem).getVideoPacket();
                                    var bb = ByteBuffer.wrap(videoFrameData);
                                }
                            } else if (dwFourCCStr.endsWith("dc")) {
                                aviItem = new AVIReader.AVITag_VideoChunk(true, this.raf);
                                aviItem.read(dwFourCC, this.raf);
                                (aviItem).setFrameNo(videoFrameNo);
                                videoFrameNo++;
                                var fourccStr = AVIReader.toFourCC(dwFourCC);
                                var streamNo = Integer.parseInt(fourccStr.substring(0, 2));
                                if (this.skipFrames) {
                                    aviItem.skip(this.raf);
                                } else {
                                    var videoFrameData = (aviItem).getVideoPacket();
                                    var bb = ByteBuffer.wrap(videoFrameData);
                                }
                            } else if (dwFourCCStr.endsWith("wb")) {
                                aviItem = new AVIReader.AVITag_AudioChunk();
                                aviItem.read(dwFourCC, this.raf);
                                aviItem.skip(this.raf);
                            } else if (dwFourCCStr.endsWith("tx")) {
                                aviItem = new AVIReader.AVIChunk();
                                aviItem.read(dwFourCC, this.raf);
                                aviItem.skip(this.raf);
                            } else if (dwFourCCStr.startsWith("ix")) {
                                aviItem = new AVIReader.AVITag_AviDmlStandardIndex();
                                aviItem.read(dwFourCC, this.raf);
                            } else {
                                aviItem = new AVIReader.AVIChunk();
                                aviItem.read(dwFourCC, this.raf);
                                aviItem.skip(this.raf);
                            }
                            break;
                        }}
                Logger.debug(aviItem.toString());
                this.fileLeft = fileSize - this.raf.position();
            } while (this.fileLeft > 0);
            var t2 = System.currentTimeMillis();
            Logger.debug("\tFile Left [" + this.fileLeft + "]");
            Logger.debug("\tParse time : " + (t2 - t1) + "ms");
        } finally {
            if (this.ps != null) {
                this.ps.close();
            }
        }
    };
    constructor.AVIChunk = function() {};
    constructor.AVIChunk = stjs.extend(constructor.AVIChunk, null, [], function(constructor, prototype) {
        prototype.dwFourCC = 0;
        prototype.fwFourCCStr = null;
        prototype.dwChunkSize = 0;
        prototype.startOfChunk = 0;
        prototype.read = function(dwFourCC, raf) {
            this.startOfChunk = raf.position() - 4;
            this.dwFourCC = dwFourCC;
            this.fwFourCCStr = AVIReader.toFourCC(dwFourCC);
            this.dwChunkSize = raf.readInt();
        };
        prototype.getStartOfChunk = function() {
            return (this.startOfChunk);
        };
        prototype.getEndOfChunk = function() {
            return (this.startOfChunk + 8 + this.getChunkSize());
        };
        prototype.getFourCC = function() {
            return (this.dwFourCC);
        };
        prototype.skip = function(raf) {
            var chunkSize = this.getChunkSize();
            if (chunkSize < 0) 
                 throw new IOException("Negative chunk size for chunk [" + AVIReader.toFourCC(this.dwFourCC) + "]");
            raf.skipBytes(chunkSize);
        };
        prototype.getChunkSize = function() {
            if ((this.dwChunkSize & 1) == 1) 
                return (this.dwChunkSize + 1);
             else 
                return (this.dwChunkSize);
        };
        prototype.toString = function() {
            var chunkStr = AVIReader.toFourCC(this.dwFourCC);
            if (chunkStr.trim().length == 0) {
                chunkStr = Integer.toHexString(this.dwFourCC);
            }
            return ("\tCHUNK [" + chunkStr + "], Size [" + this.dwChunkSize + "], StartOfChunk [" + this.getStartOfChunk() + "]");
        };
    }, {}, {});
    constructor.AVIList = function() {
        AVIReader.AVIChunk.call(this);
    };
    constructor.AVIList = stjs.extend(constructor.AVIList, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype.dwListTypeFourCC = 0;
        prototype.dwListTypeFourCCStr = null;
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            this.dwChunkSize -= 4;
            this.dwListTypeFourCC = raf.readInt();
            this.dwListTypeFourCCStr = AVIReader.toFourCC(this.dwListTypeFourCC);
        };
        prototype.getListType = function() {
            return (this.dwListTypeFourCC);
        };
        prototype.toString = function() {
            var dwFourCCStr = AVIReader.toFourCC(this.dwFourCC);
            return (dwFourCCStr + " [" + this.dwListTypeFourCCStr + "], Size [" + this.dwChunkSize + "], StartOfChunk [" + this.getStartOfChunk() + "]");
        };
    }, {}, {});
    constructor.AVI_SEGM = function() {
        AVIReader.AVIChunk.call(this);
    };
    constructor.AVI_SEGM = stjs.extend(constructor.AVI_SEGM, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
        };
        prototype.getChunkSize = function() {
            if (this.dwChunkSize == 0) 
                return (0);
             else 
                return (this.dwChunkSize + 1);
        };
        prototype.toString = function() {
            return ("SEGMENT Align, Size [" + this.dwChunkSize + "], StartOfChunk [" + this.getStartOfChunk() + "]");
        };
    }, {}, {});
    constructor.AVITag_AVIH = function() {
        AVIReader.AVIChunk.call(this);
        this.dwReserved = new Int32Array(4);
    };
    constructor.AVITag_AVIH = stjs.extend(constructor.AVITag_AVIH, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype._getHeight = null;
        constructor.AVIF_HASINDEX = 16;
        constructor.AVIF_MUSTUSEINDEX = 32;
        constructor.AVIF_ISINTERLEAVED = 256;
        constructor.AVIF_TRUSTCKTYPE = 2048;
        constructor.AVIF_WASCAPTUREFILE = 65536;
        constructor.AVIF_COPYRIGHTED = 131072;
        prototype.dwMicroSecPerFrame = 0;
        prototype.dwMaxBytesPerSec = 0;
        prototype.dwPaddingGranularity = 0;
        prototype.dwFlags = 0;
        prototype.dwTotalFrames = 0;
        prototype.dwInitialFrames = 0;
        prototype.dwStreams = 0;
        prototype.dwSuggestedBufferSize = 0;
        prototype.dwWidth = 0;
        prototype.dwHeight = 0;
        prototype.dwReserved = null;
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            if (dwFourCC != AVIReader.FOURCC_AVIH) 
                 throw new IOException("Unexpected AVI header : " + AVIReader.toFourCC(dwFourCC));
            if (this.getChunkSize() != 56) 
                 throw new IOException("Expected dwSize=56");
            this.dwMicroSecPerFrame = raf.readInt();
            this.dwMaxBytesPerSec = raf.readInt();
            this.dwPaddingGranularity = raf.readInt();
            this.dwFlags = raf.readInt();
            this.dwTotalFrames = raf.readInt();
            this.dwInitialFrames = raf.readInt();
            this.dwStreams = raf.readInt();
            this.dwSuggestedBufferSize = raf.readInt();
            this.dwWidth = raf.readInt();
            this.dwHeight = raf.readInt();
            this.dwReserved[0] = raf.readInt();
            this.dwReserved[1] = raf.readInt();
            this.dwReserved[2] = raf.readInt();
            this.dwReserved[3] = raf.readInt();
        };
        prototype.getWidth = function() {
            return this.dwWidth;
        };
        prototype.getHeight = function() {
            return this.dwHeight;
        };
        prototype.getStreams = function() {
            return (this.dwStreams);
        };
        prototype.getTotalFrames = function() {
            return (this.dwTotalFrames);
        };
        prototype.toString = function() {
            var sb = new StringBuilder();
            if ((this.dwFlags & AVIReader.AVITag_AVIH.AVIF_HASINDEX) != 0) 
                sb.append("HASINDEX ");
            if ((this.dwFlags & AVIReader.AVITag_AVIH.AVIF_MUSTUSEINDEX) != 0) 
                sb.append("MUSTUSEINDEX ");
            if ((this.dwFlags & AVIReader.AVITag_AVIH.AVIF_ISINTERLEAVED) != 0) 
                sb.append("ISINTERLEAVED ");
            if ((this.dwFlags & AVIReader.AVITag_AVIH.AVIF_WASCAPTUREFILE) != 0) 
                sb.append("AVIF_WASCAPTUREFILE ");
            if ((this.dwFlags & AVIReader.AVITag_AVIH.AVIF_COPYRIGHTED) != 0) 
                sb.append("AVIF_COPYRIGHTED ");
            return ("AVIH Resolution [" + this.dwWidth + "x" + this.dwHeight + "], NumFrames [" + this.dwTotalFrames + "], Flags [" + Integer.toHexString(this.dwFlags) + "] - [" + sb.toString().trim() + "]");
        };
    }, {dwReserved: "Int32Array"}, {});
    constructor.AVITag_STRH = function() {
        AVIReader.AVIChunk.call(this);
    };
    constructor.AVITag_STRH = stjs.extend(constructor.AVITag_STRH, AVIReader.AVIChunk, [], function(constructor, prototype) {
        constructor.AVISF_DISABLED = 1;
        constructor.AVISF_VIDEO_PALCHANGES = 65536;
        prototype.fccType = 0;
        prototype.fccCodecHandler = 0;
        prototype.dwFlags = 0;
        prototype.wPriority = 0;
        prototype.wLanguage = 0;
        prototype.dwInitialFrames = 0;
        prototype.dwScale = 0;
        prototype.dwRate = 1000000;
        prototype.dwStart = 0;
        prototype.dwLength = 0;
        prototype.dwSuggestedBufferSize = 0;
        prototype.dwQuality = -1;
        prototype.dwSampleSize = 0;
        prototype.left = 0;
        prototype.top = 0;
        prototype.right = 0;
        prototype.bottom = 0;
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            if (dwFourCC != AVIReader.FOURCC_STRH) 
                 throw new IOException("Expected 'strh' fourcc got [" + AVIReader.toFourCC(this.dwFourCC) + "]");
            this.fccType = raf.readInt();
            this.fccCodecHandler = raf.readInt();
            this.dwFlags = raf.readInt();
            this.wPriority = raf.readShort();
            this.wLanguage = raf.readShort();
            this.dwInitialFrames = raf.readInt();
            this.dwScale = raf.readInt();
            this.dwRate = raf.readInt();
            this.dwStart = raf.readInt();
            this.dwLength = raf.readInt();
            this.dwSuggestedBufferSize = raf.readInt();
            this.dwQuality = raf.readInt();
            this.dwSampleSize = raf.readInt();
            this.left = raf.readShort();
            this.top = raf.readShort();
            this.right = raf.readShort();
            this.bottom = raf.readShort();
        };
        prototype.getType = function() {
            return (this.fccType);
        };
        prototype.getHandler = function() {
            return (this.fccCodecHandler);
        };
        prototype.getHandlerStr = function() {
            if (this.fccCodecHandler != 0) 
                return (AVIReader.toFourCC(this.fccCodecHandler));
             else 
                return ("");
        };
        prototype.getInitialFrames = function() {
            return this.dwInitialFrames;
        };
        prototype.toString = function() {
            return ("\tCHUNK [" + AVIReader.toFourCC(this.dwFourCC) + "], Type[" + (this.fccType > 0 ? AVIReader.toFourCC(this.fccType) : "    ") + "], Handler [" + (this.fccCodecHandler > 0 ? AVIReader.toFourCC(this.fccCodecHandler) : "    ") + "]");
        };
    }, {}, {});
    /**
     *  typedef struct tagBITMAPINFOHEADER { DWORD biSize; LONG biWidth; LONG
     *  biHeight; WORD biPlanes; WORD biBitCount; DWORD biCompression; DWORD
     *  biSizeImage; LONG biXPelsPerMeter; LONG biYPelsPerMeter; DWORD biClrUsed;
     *  DWORD biClrImportant; } BITMAPINFOHEADER;
     */
    constructor.AVITag_BitmapInfoHeader = function() {
        AVIReader.AVIChunk.call(this);
    };
    constructor.AVITag_BitmapInfoHeader = stjs.extend(constructor.AVITag_BitmapInfoHeader, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype.biSize = 0;
        prototype.biWidth = 0;
        prototype.biHeight = 0;
        prototype.biPlanes = 0;
        prototype.biBitCount = 0;
        prototype.biCompression = 0;
        prototype.biSizeImage = 0;
        prototype.biXPelsPerMeter = 0;
        prototype.biYPelsPerMeter = 0;
        prototype.biClrUsed = 0;
        prototype.biClrImportant = 0;
        prototype.r = 0;
        prototype.g = 0;
        prototype.b = 0;
        prototype.x = 0;
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            this.biSize = raf.readInt();
            this.biWidth = raf.readInt();
            this.biHeight = raf.readInt();
            this.biPlanes = raf.readShort();
            this.biBitCount = raf.readShort();
            this.biCompression = raf.readInt();
            this.biSizeImage = raf.readInt();
            this.biXPelsPerMeter = raf.readInt();
            this.biYPelsPerMeter = raf.readInt();
            this.biClrUsed = raf.readInt();
            this.biClrImportant = raf.readInt();
            if (this.getChunkSize() == 56) {
                this.r = raf.readByte();
                this.g = raf.readByte();
                this.b = raf.readByte();
                this.x = raf.readByte();
            }
        };
        prototype.getChunkSize = function() {
            return (this.biSize);
        };
        prototype.toString = function() {
            return ("\tCHUNK [" + AVIReader.toFourCC(this.dwFourCC) + "], BitsPerPixel [" + this.biBitCount + "], Resolution [" + (this.biWidth & AVIReader.SIZE_MASK) + " x " + (this.biHeight & AVIReader.SIZE_MASK) + "], Planes [" + this.biPlanes + "]");
        };
    }, {}, {});
    constructor.AVITag_WaveFormatEx = function() {
        AVIReader.AVIChunk.call(this);
        this.guid_data4 = new Int8Array(8);
    };
    constructor.AVITag_WaveFormatEx = stjs.extend(constructor.AVITag_WaveFormatEx, AVIReader.AVIChunk, [], function(constructor, prototype) {
        constructor.SPEAKER_FRONT_LEFT = 1;
        constructor.SPEAKER_FRONT_RIGHT = 2;
        constructor.SPEAKER_FRONT_CENTER = 4;
        constructor.SPEAKER_LOW_FREQUENCY = 8;
        constructor.SPEAKER_BACK_LEFT = 16;
        constructor.SPEAKER_BACK_RIGHT = 32;
        constructor.SPEAKER_FRONT_LEFT_OF_CENTER = 64;
        constructor.SPEAKER_FRONT_RIGHT_OF_CENTER = 128;
        constructor.SPEAKER_BACK_CENTER = 256;
        constructor.SPEAKER_SIDE_LEFT = 512;
        constructor.SPEAKER_SIDE_RIGHT = 1024;
        constructor.SPEAKER_TOP_CENTER = 2048;
        constructor.SPEAKER_TOP_FRONT_LEFT = 4096;
        constructor.SPEAKER_TOP_FRONT_CENTER = 8192;
        constructor.SPEAKER_TOP_FRONT_RIGHT = 16384;
        constructor.SPEAKER_TOP_BACK_LEFT = 32768;
        constructor.SPEAKER_TOP_BACK_CENTER = 65536;
        constructor.SPEAKER_TOP_BACK_RIGHT = 131072;
        prototype.wFormatTag = 0;
        prototype.channels = 0;
        prototype.nSamplesPerSec = 0;
        prototype.nAvgBytesPerSec = 0;
        prototype.nBlockAlign = 0;
        prototype.wBitsPerSample = 0;
        prototype.cbSize = 0;
        prototype.wValidBitsPerSample = 0;
        prototype.samplesValidBitsPerSample = 0;
        prototype.wReserved = 0;
        prototype.channelMask = 0;
        prototype.guid_data1 = 0;
        prototype.guid_data2 = 0;
        prototype.guid_data3 = 0;
        prototype.guid_data4 = null;
        prototype.mp3Flag = false;
        prototype.wID = 0;
        prototype.fdwFlags = 0;
        prototype.nBlockSize = 0;
        prototype.nFramesPerBlock = 0;
        prototype.nCodecDelay = 0;
        prototype.audioFormat = "?";
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            this.wFormatTag = raf.readShort();
            this.channels = raf.readShort();
            this.nSamplesPerSec = raf.readInt();
            this.nAvgBytesPerSec = raf.readInt();
            this.nBlockAlign = raf.readShort();
            switch (stjs.trunc(this.wFormatTag)) {
                case AVIReader.AUDIO_FORMAT_PCM:
                    {
                        this.wBitsPerSample = raf.readShort();
                        if (this.dwChunkSize == 40) {
                            this.wValidBitsPerSample = this.samplesValidBitsPerSample = this.wReserved = raf.readShort();
                            this.cbSize = raf.readShort();
                            this.channelMask = raf.readInt();
                            this.guid_data1 = raf.readInt();
                            this.guid_data2 = raf.readShort();
                            this.guid_data3 = raf.readShort();
                            raf.readFully(this.guid_data4);
                        }
                        this.audioFormat = "PCM";
                        break;
                    }case AVIReader.AUDIO_FORMAT_MP3:
                    {
                        this.wBitsPerSample = raf.readShort();
                        this.cbSize = raf.readShort();
                        this.wID = raf.readShort();
                        this.fdwFlags = raf.readInt();
                        this.nBlockSize = raf.readShort();
                        this.nFramesPerBlock = raf.readShort();
                        this.nCodecDelay = raf.readShort();
                        this.mp3Flag = true;
                        this.audioFormat = "MP3";
                        break;
                    }case AVIReader.AUDIO_FORMAT_AC3:
                    {
                        this.audioFormat = "AC3";
                        break;
                    }case AVIReader.AUDIO_FORMAT_DTS:
                    {
                        this.audioFormat = "DTS";
                        break;
                    }case AVIReader.AUDIO_FORMAT_VORBIS:
                    {
                        this.audioFormat = "VORBIS";
                        break;
                    }case AVIReader.AUDIO_FORMAT_EXTENSIBLE:
                    {
                        this.wBitsPerSample = raf.readShort();
                        this.cbSize = raf.readShort();
                        this.wValidBitsPerSample = this.samplesValidBitsPerSample = this.wReserved = raf.readShort();
                        this.channelMask = raf.readInt();
                        this.guid_data1 = raf.readInt();
                        this.guid_data2 = raf.readShort();
                        this.guid_data3 = raf.readShort();
                        raf.readFully(this.guid_data4);
                        this.audioFormat = "EXTENSIBLE";
                        break;
                    }default:
                    {
                        this.audioFormat = "Unknown : " + Integer.toHexString(this.wFormatTag);
                        break;
                    }}
        };
        prototype.isMP3 = function() {
            return (this.mp3Flag);
        };
        prototype.getCbSize = function() {
            return (this.cbSize);
        };
        prototype.toString = function() {
            return (String.format("\tCHUNK [%s], ChunkSize [%d], Format [%s], Channels [%d], Channel Mask [%s], MP3 [%b], SamplesPerSec [%d], nBlockAlign [%d]", AVIReader.toFourCC(this.dwFourCC), this.getChunkSize(), this.audioFormat, this.channels, Integer.toHexString(this.channelMask), this.mp3Flag, this.nSamplesPerSec, this.getStartOfChunk(), this.nBlockAlign));
        };
    }, {guid_data4: "Int8Array"}, {});
    constructor.AVITag_VideoChunk = function(compressed, raf) {
        AVIReader.AVIChunk.call(this);
        this.compressed = compressed;
        this.raf = raf;
    };
    constructor.AVITag_VideoChunk = stjs.extend(constructor.AVITag_VideoChunk, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype.streamNo = 0;
        prototype.compressed = false;
        prototype.frameNo = -1;
        prototype.raf = null;
        prototype.getStreamNo = function() {
            return (this.streamNo);
        };
        prototype.setFrameNo = function(frameNo) {
            this.frameNo = frameNo;
        };
        prototype.getChunkSize = function() {
            if ((this.dwChunkSize & 1) == 1) 
                return (this.dwChunkSize + 1);
             else 
                return (this.dwChunkSize);
        };
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            var fourccStr = AVIReader.toFourCC(dwFourCC);
            this.streamNo = Integer.parseInt(fourccStr.substring(0, 2));
        };
        prototype.getVideoPacket = function() {
            var videoFrameData = new Int8Array(this.dwChunkSize);
            var bytesRead = this.raf.readFully(videoFrameData);
            if (bytesRead != this.dwChunkSize) 
                 throw new IOException("Read mismatch expected chunksize [" + this.dwChunkSize + "], Actual read [" + bytesRead + "]");
            var alignment = this.getChunkSize() - this.dwChunkSize;
            if (alignment > 0) 
                this.raf.skipBytes(alignment);
            return (videoFrameData);
        };
        prototype.toString = function() {
            return ("\tVIDEO CHUNK - Stream " + this.streamNo + ",  chunkStart=" + this.getStartOfChunk() + ", " + (this.compressed ? "compressed" : "uncompressed") + ", ChunkSize=" + this.getChunkSize() + ", FrameNo=" + this.frameNo);
        };
    }, {raf: "DataReader"}, {});
    constructor.AVITag_AudioChunk = function() {
        AVIReader.AVIChunk.call(this);
    };
    constructor.AVITag_AudioChunk = stjs.extend(constructor.AVITag_AudioChunk, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype.streamNo = 0;
        prototype.raf = null;
        prototype.read = function(dwFourCC, raf) {
            this.raf = raf;
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            var fourccStr = AVIReader.toFourCC(dwFourCC);
            this.streamNo = Integer.parseInt(fourccStr.substring(0, 2));
        };
        prototype.getChunkSize = function() {
            if ((this.dwChunkSize & 1) == 1) 
                return (this.dwChunkSize + 1);
             else 
                return (this.dwChunkSize);
        };
        prototype.getAudioPacket = function() {
            var audioFrameData = new Int8Array(this.dwChunkSize);
            var bytesRead = this.raf.readFully(audioFrameData);
            if (bytesRead != this.dwChunkSize) 
                 throw new IOException("Read mismatch expected chunksize [" + this.dwChunkSize + "], Actual read [" + bytesRead + "]");
            var alignment = this.getChunkSize() - this.dwChunkSize;
            if (alignment > 0) 
                this.raf.skipBytes(alignment);
            return (audioFrameData);
        };
        prototype.toString = function() {
            return ("\tAUDIO CHUNK - Stream " + this.streamNo + ", StartOfChunk=" + this.getStartOfChunk() + ", ChunkSize=" + this.getChunkSize());
        };
    }, {raf: "DataReader"}, {});
    /**
     *  AVIINDEXENTRY index_entry[n]
     *  
     *  typedef struct { DWORD ckid; DWORD dwFlags; DWORD dwChunkOffset; DWORD
     *  dwChunkLength; } AVIINDEXENTRY;
     *  
     *  // Flag bitmasks #define AVIIF_LIST 0x00000001 #define AVIIF_KEYFRAME
     *  0x00000010 #define AVIIF_NO_TIME 0x00000100 #define AVIIF_COMPRESSOR
     *  0x0FFF0000 // unused?
     */
    constructor.AVITag_AviIndex = function() {
        AVIReader.AVIChunk.call(this);
    };
    constructor.AVITag_AviIndex = stjs.extend(constructor.AVITag_AviIndex, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype.numIndexes = 0;
        prototype.ckid = null;
        prototype.dwFlags = null;
        prototype.dwChunkOffset = null;
        prototype.dwChunkLength = null;
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            this.numIndexes = this.getChunkSize() >> 4;
            this.ckid = new Int32Array(this.numIndexes);
            this.dwFlags = new Int32Array(this.numIndexes);
            this.dwChunkOffset = new Int32Array(this.numIndexes);
            this.dwChunkLength = new Int32Array(this.numIndexes);
            for (var i = 0; i < this.numIndexes; i++) {
                this.ckid[i] = raf.readInt();
                this.dwFlags[i] = raf.readInt();
                this.dwChunkOffset[i] = raf.readInt();
                this.dwChunkLength[i] = raf.readInt();
            }
            raf.setPosition(this.getEndOfChunk());
            var alignment = this.getChunkSize() - this.dwChunkSize;
            if (alignment > 0) 
                raf.skipBytes(alignment);
        };
        prototype.getNumIndexes = function() {
            return this.numIndexes;
        };
        prototype.getCkid = function() {
            return this.ckid;
        };
        prototype.getDwFlags = function() {
            return this.dwFlags;
        };
        prototype.getDwChunkOffset = function() {
            return this.dwChunkOffset;
        };
        prototype.getDwChunkLength = function() {
            return this.dwChunkLength;
        };
        prototype.debugOut = function() {
            for (var i = 0; i < this.numIndexes; i++) {
                Logger.debug("\t");
            }
        };
        prototype.toString = function() {
            return (String.format("\tAvi Index List, StartOfChunk [%d], ChunkSize [%d], NumIndexes [%d]", this.getStartOfChunk(), this.dwChunkSize, (this.getChunkSize() >> 4)));
        };
    }, {ckid: "Int32Array", dwFlags: "Int32Array", dwChunkOffset: "Int32Array", dwChunkLength: "Int32Array"}, {});
    /**
     *  typedef struct _avisuperindex_chunk { FOURCC fcc; DWORD cb; WORD
     *  wLongsPerEntry; BYTE bIndexSubType; BYTE bIndexType; DWORD nEntriesInUse;
     *  DWORD dwChunkId; DWORD dwReserved[3]; struct _avisuperindex_entry {
     *  __int64 qwOffset; DWORD dwSize; DWORD dwDuration; } aIndex[ ]; }
     *  AVISUPERINDEX;
     *  
     *  #define STDINDEXSIZE 0x4000 #define NUMINDEX(wLongsPerEntry)
     *  ((STDINDEXSIZE-32)/4/(wLongsPerEntry)) #define
     *  NUMINDEXFILL(wLongsPerEntry) ((STDINDEXSIZE/4) -
     *  NUMINDEX(wLongsPerEntry))
     */
    constructor.AVITag_AviDmlSuperIndex = function() {
        AVIReader.AVIChunk.call(this);
        this.dwReserved = new Int32Array(3);
        this.sb = new StringBuilder();
    };
    constructor.AVITag_AviDmlSuperIndex = stjs.extend(constructor.AVITag_AviDmlSuperIndex, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype.wLongsPerEntry = 0;
        prototype.bIndexSubType = 0;
        prototype.bIndexType = 0;
        prototype.nEntriesInUse = 0;
        prototype.dwChunkId = 0;
        prototype.dwReserved = null;
        prototype.qwOffset = null;
        prototype.dwSize = null;
        prototype.dwDuration = null;
        prototype.numIndex = 0;
        prototype.numIndexFill = 0;
        prototype.sb = null;
        prototype.streamNo = 0;
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            this.wLongsPerEntry = raf.readShort();
            this.bIndexSubType = raf.readByte();
            this.bIndexType = raf.readByte();
            this.nEntriesInUse = raf.readInt();
            this.dwChunkId = raf.readInt();
            this.dwReserved[0] = raf.readInt();
            this.dwReserved[1] = raf.readInt();
            this.dwReserved[2] = raf.readInt();
            this.qwOffset = Array(this.nEntriesInUse);
            this.dwSize = new Int32Array(this.nEntriesInUse);
            this.dwDuration = new Int32Array(this.nEntriesInUse);
            var chunkIdStr = AVIReader.toFourCC(this.dwChunkId);
            this.sb.append(String.format("\tAvi DML Super Index List - ChunkSize=%d, NumIndexes = %d, longsPerEntry = %d, Stream = %s, Type = %s", this.getChunkSize(), this.nEntriesInUse, this.wLongsPerEntry, chunkIdStr.substring(0, 2), chunkIdStr.substring(2)));
            for (var i = 0; i < this.nEntriesInUse; i++) {
                this.qwOffset[i] = raf.readLong();
                this.dwSize[i] = raf.readInt();
                this.dwDuration[i] = raf.readInt();
                this.sb.append(String.format("\n\t\tStandard Index - Offset [%d], Size [%d], Duration [%d]", this.qwOffset[i], this.dwSize[i], this.dwDuration[i]));
            }
            raf.setPosition(this.getEndOfChunk());
        };
        prototype.toString = function() {
            return (this.sb.toString());
        };
    }, {dwReserved: "Int32Array", qwOffset: "Array", dwSize: "Int32Array", dwDuration: "Int32Array", sb: "StringBuilder"}, {});
    /**
     *  typedef struct _avistdindex_chunk { FOURCC fcc; DWORD cb; WORD
     *  wLongsPerEntry; // 2 bytes BYTE bIndexSubType; // 1 byte BYTE bIndexType;
     *  // 1 byte DWORD nEntriesInUse; // 4 bytes DWORD dwChunkId; // 4 bytes
     *  __int64 qwBaseOffset; // 8 bytes DWORD dwReserved3; // 4 bytes
     *  
     *  struct _avistdindex_entry { DWORD dwOffset; // 4 bytes DWORD dwSize; // 4
     *  bytes } aIndex[ ]; } AVISTDINDEX;
     *  
     *  
     *  #define AVISTDINDEX_DELTAFRAME ( 0x80000000) // Delta frames have the
     *  high bit set #define AVISTDINDEX_SIZEMASK (~0x80000000)
     *  
     *  #define AVI_INDEX_OF_INDEXES 0x00 #define AVI_INDEX_OF_CHUNKS 0x01
     *  #define AVI_INDEX_OF_TIMED_CHUNKS 0x02 #define AVI_INDEX_OF_SUB_2FIELD
     *  0x03 #define AVI_INDEX_IS_DATA 0x80
     */
    constructor.AVITag_AviDmlStandardIndex = function() {
        AVIReader.AVIChunk.call(this);
    };
    constructor.AVITag_AviDmlStandardIndex = stjs.extend(constructor.AVITag_AviDmlStandardIndex, AVIReader.AVIChunk, [], function(constructor, prototype) {
        prototype.wLongsPerEntry = 0;
        prototype.bIndexSubType = 0;
        prototype.bIndexType = 0;
        prototype.nEntriesInUse = 0;
        prototype.dwChunkId = 0;
        prototype.qwBaseOffset = 0;
        prototype.dwReserved2 = 0;
        prototype.dwOffset = null;
        prototype.dwDuration = null;
        prototype.lastOffset = -1;
        prototype.lastDuration = -1;
        prototype.getChunkSize = function() {
            return (this.dwChunkSize);
        };
        prototype.read = function(dwFourCC, raf) {
            AVIReader.AVIChunk.prototype.read.call(this, dwFourCC, raf);
            this.wLongsPerEntry = raf.readShort();
            this.bIndexSubType = raf.readByte();
            this.bIndexType = raf.readByte();
            this.nEntriesInUse = raf.readInt();
            this.dwChunkId = raf.readInt();
            this.qwBaseOffset = raf.readLong();
            this.dwReserved2 = raf.readInt();
            this.dwOffset = new Int32Array(this.nEntriesInUse);
            this.dwDuration = new Int32Array(this.nEntriesInUse);
            try {
                for (var i = 0; i < this.nEntriesInUse; i++) {
                    this.dwOffset[i] = raf.readInt();
                    this.dwDuration[i] = raf.readInt();
                    this.lastOffset = this.dwOffset[i];
                    this.lastDuration = this.dwDuration[i];
                }
            }catch (e) {
                Logger.debug("Failed to read : " + this.toString());
            }
            raf.setPosition(this.getEndOfChunk());
        };
        prototype.toString = function() {
            return (String.format("\tAvi DML Standard Index List Type=%d, SubType=%d, ChunkId=%s, StartOfChunk=%d, NumIndexes=%d, LongsPerEntry=%d, ChunkSize=%d, FirstOffset=%d, FirstDuration=%d,LastOffset=%d, LastDuration=%d", this.bIndexType, this.bIndexSubType, AVIReader.toFourCC(this.dwChunkId), this.getStartOfChunk(), this.nEntriesInUse, this.wLongsPerEntry, this.getChunkSize(), this.dwOffset[0], this.dwDuration[0], this.lastOffset, this.lastDuration));
        };
    }, {dwOffset: "Int32Array", dwDuration: "Int32Array"}, {});
}, {raf: "DataReader", aviHeader: "AVIReader.AVITag_AVIH", streamHeaders: "Array", streamFormats: "Array", aviIndexes: {name: "List", arguments: ["AVIReader.AVITag_AviIndex"]}, openDmlSuperIndex: "Array", ps: "PrintStream"}, {});
/**
 *  
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Decoder for Apple ProRes format
 *  
 *  As posted at http://git.videolan.org/?p=ffmpeg.git;a=commitdiff;h=5554d
 *  e13b29b9bb812ee5cfd606349873ddf0945
 *  
 *  @author The JCodec project
 *  
 */
var ProresDecoder = function() {
    VideoDecoder.call(this);
};
ProresDecoder = stjs.extend(ProresDecoder, VideoDecoder, [], function(constructor, prototype) {
    constructor.table = new Int32Array([8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    constructor.mask = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, -1]);
    constructor.nZeros = function(check16Bit) {
        var low = ProresDecoder.table[check16Bit & 255];
        check16Bit >>= 8;
        var high = ProresDecoder.table[check16Bit];
        return high + (ProresDecoder.mask[high] & low);
    };
    constructor.readCodeword = function(reader, codebook) {
        var q = ProresDecoder.nZeros(reader.check16Bits());
        reader.skipFast(q + 1);
        if (q > codebook.switchBits) {
            var bits = codebook.golombBits + q;
            if (bits > 16) 
                Logger.error("Broken prores slice");
            return ((1 << bits) | reader.readFast16(bits)) - codebook.golombOffset;
        } else if (codebook.riceOrder > 0) 
            return (q << codebook.riceOrder) | reader.readFast16(codebook.riceOrder);
         else 
            return q;
    };
    constructor.golumbToSigned = function(val) {
        return (val >> 1) ^ ProresDecoder.golumbSign(val);
    };
    constructor.golumbSign = function(val) {
        return -(val & 1);
    };
    constructor.readDCCoeffs = function(bits, qMat, out, blocksPerSlice, blkSize) {
        var c = ProresDecoder.readCodeword(bits, ProresConsts.firstDCCodebook);
        if (c < 0) {
            return;
        }
        var prevDc = ProresDecoder.golumbToSigned(c);
        out[0] = 4096 + ProresDecoder.qScale(qMat, 0, prevDc);
        var code = 5, sign = 0, idx = blkSize;
        for (var i = 1; i < blocksPerSlice; i++ , idx += blkSize) {
            code = ProresDecoder.readCodeword(bits, ProresConsts.dcCodebooks[Math.min(code, 6)]);
            if (code < 0) {
                return;
            }
            if (code != 0) 
                sign ^= ProresDecoder.golumbSign(code);
             else 
                sign = 0;
            prevDc += MathUtil.toSigned((code + 1) >> 1, sign);
            out[idx] = 4096 + ProresDecoder.qScale(qMat, 0, prevDc);
        }
    };
    constructor.readACCoeffs = function(bits, qMat, out, blocksPerSlice, scan, max, log2blkSize) {
        var run = 4;
        var level = 2;
        var blockMask = blocksPerSlice - 1;
        var log2BlocksPerSlice = MathUtil.log2(blocksPerSlice);
        var maxCoeffs = 64 << log2BlocksPerSlice;
        var pos = blockMask;
         while (bits.remaining() > 32 || bits.checkAllBits() != 0){
            run = ProresDecoder.readCodeword(bits, ProresConsts.runCodebooks[Math.min(run, 15)]);
            if (run < 0 || run >= maxCoeffs - pos - 1) {
                return;
            }
            pos += run + 1;
            level = ProresDecoder.readCodeword(bits, ProresConsts.levCodebooks[Math.min(level, 9)]) + 1;
            if (level < 0 || level > 65535) {
                return;
            }
            var sign = -bits.read1Bit();
            var ind = pos >> log2BlocksPerSlice;
            if (ind >= max) 
                break;
            out[((pos & blockMask) << log2blkSize) + scan[ind]] = ProresDecoder.qScale(qMat, ind, MathUtil.toSigned(level, sign));
        }
    };
    constructor.qScale = function(qMat, ind, val) {
        return ((val * qMat[ind]) >> 2);
    };
    prototype.decodeOnePlane = function(bits, blocksPerSlice, out, qMat, scan, mbX, mbY, plane) {
        try {
            ProresDecoder.readDCCoeffs(bits, qMat, out, blocksPerSlice, 64);
            ProresDecoder.readACCoeffs(bits, qMat, out, blocksPerSlice, scan, 64, 6);
        }catch (e) {
            System.err.println("Suppressing slice error at [" + mbX + ", " + mbY + "].");
        }
        for (var i = 0; i < blocksPerSlice; i++) {
            SimpleIDCT10Bit.idct10(out, i << 6);
        }
    };
    prototype.decodeFrame = function(data, target) {
        return this.decodeFrameHiBD(data, target, null);
    };
    prototype.decodeFrameHiBD = function(data, target, lowBits) {
        var fh = ProresDecoder.readFrameHeader(data);
        var codedWidth = (fh.width + 15) & ~15;
        var codedHeight = (fh.height + 15) & ~15;
        var lumaSize = codedWidth * codedHeight;
        var chromaSize = lumaSize >> (3 - fh.chromaType);
        if (target == null || target[0].length < lumaSize || target[1].length < chromaSize || target[2].length < chromaSize) {
             throw new RuntimeException("Provided output picture won't fit into provided buffer");
        }
        if (fh.frameType == 0) {
            this.decodePicture(data, target, lowBits, codedWidth, codedHeight, codedWidth >> 4, fh.qMatLuma, fh.qMatChroma, fh.scan, 0, fh.chromaType);
        } else {
            this.decodePicture(data, target, lowBits, codedWidth, codedHeight >> 1, codedWidth >> 4, fh.qMatLuma, fh.qMatChroma, fh.scan, fh.topFieldFirst ? 1 : 2, fh.chromaType);
            this.decodePicture(data, target, lowBits, codedWidth, codedHeight >> 1, codedWidth >> 4, fh.qMatLuma, fh.qMatChroma, fh.scan, fh.topFieldFirst ? 2 : 1, fh.chromaType);
        }
        var color = fh.chromaType == 2 ? ColorSpace.YUV422 : ColorSpace.YUV444;
        return new Picture(codedWidth, codedHeight, target, lowBits, color, lowBits == null ? 0 : 2, new Rect(0, 0, fh.width & color.getWidthMask(), fh.height & color.getHeightMask()));
    };
    prototype.decodeFields = function(data, target) {
        return this.decodeFieldsHiBD(data, target, null);
    };
    prototype.decodeFieldsHiBD = function(data, target, lowBits) {
        var fh = ProresDecoder.readFrameHeader(data);
        var codedWidth = (fh.width + 15) & ~15;
        var codedHeight = (fh.height + 15) & ~15;
        var lumaSize = codedWidth * codedHeight;
        var chromaSize = lumaSize >> 1;
        if (fh.frameType == 0) {
            if (target == null || target[0][0].length < lumaSize || target[0][1].length < chromaSize || target[0][2].length < chromaSize) {
                 throw new RuntimeException("Provided output picture won't fit into provided buffer");
            }
            this.decodePicture(data, target[0], lowBits[0], fh.width, fh.height, codedWidth >> 4, fh.qMatLuma, fh.qMatChroma, fh.scan, 0, fh.chromaType);
            return [Picture.createPicture(codedWidth, codedHeight, target[0], ColorSpace.YUV422)];
        } else {
            lumaSize >>= 1;
            chromaSize >>= 1;
            if (target == null || target[0][0].length < lumaSize || target[0][1].length < chromaSize || target[0][2].length < chromaSize || target[1][0].length < lumaSize || target[1][1].length < chromaSize || target[1][2].length < chromaSize) {
                 throw new RuntimeException("Provided output picture won't fit into provided buffer");
            }
            this.decodePicture(data, target[fh.topFieldFirst ? 0 : 1], lowBits[fh.topFieldFirst ? 0 : 1], fh.width, fh.height >> 1, codedWidth >> 4, fh.qMatLuma, fh.qMatChroma, fh.scan, 0, fh.chromaType);
            this.decodePicture(data, target[fh.topFieldFirst ? 1 : 0], lowBits[fh.topFieldFirst ? 0 : 1], fh.width, fh.height >> 1, codedWidth >> 4, fh.qMatLuma, fh.qMatChroma, fh.scan, 0, fh.chromaType);
            return [Picture.createPicture(codedWidth, codedHeight >> 1, target[0], ColorSpace.YUV422), Picture.createPicture(codedWidth, codedHeight >> 1, target[1], ColorSpace.YUV422)];
        }
    };
    constructor.readFrameHeader = function(inp) {
        var frameSize = inp.getInt();
        var sig = ProresDecoder.readSig(inp);
        if (!"icpf".equals(sig)) 
             throw new RuntimeException("Not a prores frame");
        var hdrSize = inp.getShort();
        var version = inp.getShort();
        var res1 = inp.getInt();
        var width = inp.getShort();
        var height = inp.getShort();
        var flags1 = inp.get();
        var frameType = (flags1 >> 2) & 3;
        var chromaType = (flags1 >> 6) & 3;
        var scan;
        var topFieldFirst = false;
        if (frameType == 0) {
            scan = ProresConsts.progressive_scan;
        } else {
            scan = ProresConsts.interlaced_scan;
            if (frameType == 1) 
                topFieldFirst = true;
        }
        var res2 = inp.get();
        var prim = inp.get();
        var transFunc = inp.get();
        var matrix = inp.get();
        var pixFmt = inp.get();
        var res3 = inp.get();
        var flags2 = inp.get() & 255;
        var qMatLuma = new Int32Array(64);
        var qMatChroma = new Int32Array(64);
        if (ProresDecoder.hasQMatLuma(flags2)) {
            ProresDecoder.readQMat(inp, qMatLuma, scan);
        } else {
            Arrays.fill(qMatLuma, 4);
        }
        if (ProresDecoder.hasQMatChroma(flags2)) {
            ProresDecoder.readQMat(inp, qMatChroma, scan);
        } else {
            Arrays.fill(qMatChroma, 4);
        }
        inp.setPosition(inp.position() + hdrSize - (20 + (ProresDecoder.hasQMatLuma(flags2) ? 64 : 0) + (ProresDecoder.hasQMatChroma(flags2) ? 64 : 0)));
        return new ProresConsts.FrameHeader(frameSize - hdrSize - 8, width, height, frameType, topFieldFirst, scan, qMatLuma, qMatChroma, chromaType);
    };
    constructor.readSig = function(inp) {
        var sig = new Int8Array(4);
        inp.getBuf(sig);
        return Platform.stringFromBytes(sig);
    };
    prototype.decodePicture = function(data, result, lowBits, width, height, mbWidth, qMatLuma, qMatChroma, scan, pictureType, chromaType) {
        var ph = ProresDecoder.readPictureHeader(data);
        var mbX = 0, mbY = 0;
        var sliceMbCount = 1 << ph.log2SliceMbWidth;
        for (var i = 0; i < ph.sliceSizes.length; i++) {
             while (mbWidth - mbX < sliceMbCount)
                sliceMbCount >>= 1;
            this.decodeSlice(NIOUtils.read(data, ph.sliceSizes[i]), qMatLuma, qMatChroma, scan, sliceMbCount, mbX, mbY, ph.sliceSizes[i], result, lowBits, width, pictureType, chromaType);
            mbX += sliceMbCount;
            if (mbX == mbWidth) {
                sliceMbCount = 1 << ph.log2SliceMbWidth;
                mbX = 0;
                mbY++;
            }
        }
    };
    constructor.readPictureHeader = function(inp) {
        var hdrSize = (inp.get() & 255) >> 3;
        inp.getInt();
        var sliceCount = inp.getShort();
        var a = inp.get() & 255;
        var log2SliceMbWidth = a >> 4;
        var sliceSizes = new Int16Array(sliceCount);
        for (var i = 0; i < sliceCount; i++) {
            sliceSizes[i] = inp.getShort();
        }
        return new ProresConsts.PictureHeader(log2SliceMbWidth, sliceSizes);
    };
    prototype.decodeSlice = function(data, qMatLuma, qMatChroma, scan, sliceMbCount, mbX, mbY, sliceSize, result, lowBits, lumaStride, pictureType, chromaType) {
        var hdrSize = (data.get() & 255) >> 3;
        var qScale = ProresDecoder.clip(data.get() & 255, 1, 224);
        qScale = qScale > 128 ? qScale - 96 << 2 : qScale;
        var yDataSize = data.getShort();
        var uDataSize = data.getShort();
        var vDataSize = hdrSize > 7 ? data.getShort() : sliceSize - uDataSize - yDataSize - hdrSize;
        var y = new Int32Array(sliceMbCount << 8);
        this.decodeOnePlane(ProresDecoder.bitstream(data, yDataSize), sliceMbCount << 2, y, ProresDecoder.scaleMat(qMatLuma, qScale), scan, mbX, mbY, 0);
        var chromaBlkCount = (sliceMbCount << chromaType) >> 1;
        var u = new Int32Array(chromaBlkCount << 6);
        this.decodeOnePlane(ProresDecoder.bitstream(data, uDataSize), chromaBlkCount, u, ProresDecoder.scaleMat(qMatChroma, qScale), scan, mbX, mbY, 1);
        var v = new Int32Array(chromaBlkCount << 6);
        this.decodeOnePlane(ProresDecoder.bitstream(data, vDataSize), chromaBlkCount, v, ProresDecoder.scaleMat(qMatChroma, qScale), scan, mbX, mbY, 2);
        this.putSlice(result, lowBits, lumaStride, mbX, mbY, y, u, v, pictureType == 0 ? 0 : 1, pictureType == 2 ? 1 : 0, chromaType, sliceMbCount);
    };
    constructor.scaleMat = function(qMatLuma, qScale) {
        var res = new Int32Array(qMatLuma.length);
        for (var i = 0; i < qMatLuma.length; i++) 
            res[i] = qMatLuma[i] * qScale;
        return res;
    };
    constructor.bitstream = function(data, dataSize) {
        return BitReader.createBitReader(NIOUtils.read(data, dataSize));
    };
    constructor.clip = function(val, min, max) {
        return val < min ? min : (val > max ? max : val);
    };
    prototype.putSlice = function(result, lowBits, lumaStride, mbX, mbY, y, u, v, dist, shift, chromaType, sliceMbCount) {
        var chromaStride = lumaStride >> 1;
        this.putLuma(result[0], lowBits != null ? lowBits[0] : null, shift * lumaStride, lumaStride << dist, mbX, mbY, y, sliceMbCount, dist, shift);
        if (chromaType == 2) {
            this.putChroma(result[1], lowBits != null ? lowBits[1] : null, shift * chromaStride, chromaStride << dist, mbX, mbY, u, sliceMbCount, dist, shift);
            this.putChroma(result[2], lowBits != null ? lowBits[2] : null, shift * chromaStride, chromaStride << dist, mbX, mbY, v, sliceMbCount, dist, shift);
        } else {
            this.putLuma(result[1], lowBits != null ? lowBits[1] : null, shift * lumaStride, lumaStride << dist, mbX, mbY, u, sliceMbCount, dist, shift);
            this.putLuma(result[2], lowBits != null ? lowBits[2] : null, shift * lumaStride, lumaStride << dist, mbX, mbY, v, sliceMbCount, dist, shift);
        }
    };
    prototype.putLuma = function(y, lowBits, off, stride, mbX, mbY, luma, mbPerSlice, dist, shift) {
        off += (mbX << 4) + (mbY << 4) * stride;
        for (var k = 0; k < mbPerSlice; k++) {
            this.putBlock(y, lowBits, off, stride, luma, k << 8, dist, shift);
            this.putBlock(y, lowBits, off + 8, stride, luma, (k << 8) + 64, dist, shift);
            this.putBlock(y, lowBits, off + 8 * stride, stride, luma, (k << 8) + 128, dist, shift);
            this.putBlock(y, lowBits, off + 8 * stride + 8, stride, luma, (k << 8) + 192, dist, shift);
            off += 16;
        }
    };
    prototype.putChroma = function(y, lowBits, off, stride, mbX, mbY, chroma, mbPerSlice, dist, shift) {
        off += (mbX << 3) + (mbY << 4) * stride;
        for (var k = 0; k < mbPerSlice; k++) {
            this.putBlock(y, lowBits, off, stride, chroma, k << 7, dist, shift);
            this.putBlock(y, lowBits, off + 8 * stride, stride, chroma, (k << 7) + 64, dist, shift);
            off += 8;
        }
    };
    prototype.putBlock = function(square, lowBits, sqOff, sqStride, flat, flOff, dist, shift) {
        for (var i = 0, dstOff = sqOff, srcOff = flOff; i < 8; i++ , dstOff += sqStride , srcOff += 8) {
            for (var j = 0; j < 8; j++) {
                var round = MathUtil.clip((flat[j + srcOff] + 2) >> 2, 1, 255);
                square[j + dstOff] = ((round - 128) << 24 >> 24);
            }
        }
        if (lowBits != null) {
            for (var i = 0, dstOff = sqOff, srcOff = flOff; i < 8; i++ , dstOff += sqStride , srcOff += 8) {
                for (var j = 0; j < 8; j++) {
                    var val = MathUtil.clip(flat[j + srcOff], 4, 1019);
                    var round = MathUtil.clip((flat[j + srcOff] + 2) >> 2, 1, 255);
                    lowBits[j + dstOff] = ((val - (round << 2)) << 24 >> 24);
                }
            }
        }
    };
    constructor.hasQMatChroma = function(flags2) {
        return (flags2 & 1) != 0;
    };
    constructor.readQMat = function(inp, qMatLuma, scan) {
        var b = new Int8Array(64);
        inp.getBuf(b);
        for (var i = 0; i < 64; i++) {
            qMatLuma[i] = b[scan[i]] & 255;
        }
    };
    constructor.hasQMatLuma = function(flags2) {
        return (flags2 & 2) != 0;
    };
    prototype.isProgressive = function(data) {
        return (((data.getAt(20) & 255) >> 2) & 3) == 0;
    };
    constructor.probe = function(data) {
        if (data.getAt(4) == 'i'.charCodeAt(0) && data.getAt(5) == 'c'.charCodeAt(0) && data.getAt(6) == 'p'.charCodeAt(0) && data.getAt(7) == 'f'.charCodeAt(0)) 
            return 100;
        return 0;
    };
    prototype.getCodecMeta = function(data) {
        var fh = ProresDecoder.readFrameHeader(data);
        return VideoCodecMeta.createSimpleVideoCodecMeta(new Size(fh.width, fh.height), fh.chromaType == 2 ? ColorSpace.YUV422 : ColorSpace.YUV444);
    };
}, {table: "Int32Array", mask: "Int32Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Intra-channel prediction used in profile Main
 *  @author in-somnia
 */
var ICPrediction = function() {
    this.states = Array(ICPrediction.MAX_PREDICTORS);
    this.resetAllPredictors();
};
ICPrediction = stjs.extend(ICPrediction, null, [], function(constructor, prototype) {
    constructor.SF_SCALE = 1.0 / -1024.0;
    constructor.INV_SF_SCALE = 1.0 / ICPrediction.SF_SCALE;
    constructor.MAX_PREDICTORS = 672;
    constructor.A = 0.953125;
    constructor.ALPHA = 0.90625;
    prototype.predictorReset = false;
    prototype.predictorResetGroup = 0;
    prototype.predictionUsed = null;
    prototype.states = null;
    constructor.PredictorState = function() {};
    constructor.PredictorState = stjs.extend(constructor.PredictorState, null, [], function(constructor, prototype) {
        prototype.cor0 = 0.0;
        prototype.cor1 = 0.0;
        prototype.var0 = 0.0;
        prototype.var1 = 0.0;
        prototype.r0 = 1.0;
        prototype.r1 = 1.0;
    }, {}, {});
    prototype.decode = function(_in, maxSFB, sf) {
        var predictorCount = sf.getPredictorCount();
        if (this.predictorReset = _in.readBool()) 
            this.predictorResetGroup = _in.readBits(5);
        var maxPredSFB = sf.getMaximalPredictionSFB();
        var length = Math.min(maxSFB, maxPredSFB);
        this.predictionUsed = new Int8Array(length);
        for (var sfb = 0; sfb < length; sfb++) {
            this.predictionUsed[sfb] = _in.readBool();
        }
        Logger.warn("ICPrediction: maxSFB={0}, maxPredSFB={1}", new Int32Array([maxSFB, maxPredSFB]));
    };
    prototype.setPredictionUnused = function(sfb) {
        this.predictionUsed[sfb] = false;
    };
    prototype.process = function(ics, data, sf) {
        var info = ics.getInfo();
        if (info.isEightShortFrame()) 
            this.resetAllPredictors();
         else {
            var len = Math.min(sf.getMaximalPredictionSFB(), info.getMaxSFB());
            var swbOffsets = info.getSWBOffsets();
            var k;
            for (var sfb = 0; sfb < len; sfb++) {
                for (k = swbOffsets[sfb]; k < swbOffsets[sfb + 1]; k++) {
                    this.predict(data, k, this.predictionUsed[sfb]);
                }
            }
            if (this.predictorReset) 
                this.resetPredictorGroup(this.predictorResetGroup);
        }
    };
    prototype.resetPredictState = function(index) {
        if (this.states[index] == null) 
            this.states[index] = new ICPrediction.PredictorState();
        this.states[index].r0 = 0;
        this.states[index].r1 = 0;
        this.states[index].cor0 = 0;
        this.states[index].cor1 = 0;
        this.states[index].var0 = 16256;
        this.states[index].var1 = 16256;
    };
    prototype.resetAllPredictors = function() {
        var i;
        for (i = 0; i < this.states.length; i++) {
            this.resetPredictState(i);
        }
    };
    prototype.resetPredictorGroup = function(group) {
        var i;
        for (i = group - 1; i < this.states.length; i += 30) {
            this.resetPredictState(i);
        }
    };
    prototype.predict = function(data, off, output) {
        if (this.states[off] == null) 
            this.states[off] = new ICPrediction.PredictorState();
        var state = this.states[off];
        var r0 = state.r0, r1 = state.r1;
        var cor0 = state.cor0, cor1 = state.cor1;
        var var0 = state.var0, var1 = state.var1;
        var k1 = var0 > 1 ? cor0 * this.even(ICPrediction.A / var0) : 0;
        var k2 = var1 > 1 ? cor1 * this.even(ICPrediction.A / var1) : 0;
        var pv = this.round(k1 * r0 + k2 * r1);
        if (output) 
            data[off] += pv * ICPrediction.SF_SCALE;
        var e0 = (data[off] * ICPrediction.INV_SF_SCALE);
        var e1 = e0 - k1 * r0;
        state.cor1 = this.trunc(ICPrediction.ALPHA * cor1 + r1 * e1);
        state.var1 = this.trunc(ICPrediction.ALPHA * var1 + 0.5 * (r1 * r1 + e1 * e1));
        state.cor0 = this.trunc(ICPrediction.ALPHA * cor0 + r0 * e0);
        state.var0 = this.trunc(ICPrediction.ALPHA * var0 + 0.5 * (r0 * r0 + e0 * e0));
        state.r1 = this.trunc(ICPrediction.A * (r0 - k1 * e0));
        state.r0 = this.trunc(ICPrediction.A * e0);
    };
    prototype.round = function(pf) {
        return Float.intBitsToFloat((Float.floatToIntBits(pf) + 32768) & -65536);
    };
    prototype.even = function(pf) {
        var i = Float.floatToIntBits(pf);
        i = (i + 32767 + (i & 65536 >> 16)) & -65536;
        return Float.intBitsToFloat(i);
    };
    prototype.trunc = function(pf) {
        return Float.intBitsToFloat(Float.floatToIntBits(pf) & -65536);
    };
}, {predictionUsed: "Int8Array", states: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var J2KPictureDescriptor = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
J2KPictureDescriptor = stjs.extend(J2KPictureDescriptor, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.rsiz = 0;
    prototype.xsiz = 0;
    prototype.ysiz = 0;
    prototype.xOsiz = 0;
    prototype.yOsiz = 0;
    prototype.xTsiz = 0;
    prototype.yTsiz = 0;
    prototype.xTOsiz = 0;
    prototype.yTOsiz = 0;
    prototype.csiz = 0;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 24836:
                    this.rsiz = _bb.getShort();
                    break;
                case 24837:
                    this.xsiz = _bb.getInt();
                    break;
                case 24838:
                    this.ysiz = _bb.getInt();
                    break;
                case 24839:
                    this.xOsiz = _bb.getInt();
                    break;
                case 24840:
                    this.yOsiz = _bb.getInt();
                    break;
                case 24841:
                    this.xTsiz = _bb.getInt();
                    break;
                case 24842:
                    this.yTsiz = _bb.getInt();
                    break;
                case 24843:
                    this.xTOsiz = _bb.getInt();
                    break;
                case 24844:
                    this.yTOsiz = _bb.getInt();
                    break;
                case 24845:
                    this.csiz = _bb.getShort();
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getRsiz = function() {
        return this.rsiz;
    };
    prototype.getXsiz = function() {
        return this.xsiz;
    };
    prototype.getYsiz = function() {
        return this.ysiz;
    };
    prototype.getxOsiz = function() {
        return this.xOsiz;
    };
    prototype.getyOsiz = function() {
        return this.yOsiz;
    };
    prototype.getxTsiz = function() {
        return this.xTsiz;
    };
    prototype.getyTsiz = function() {
        return this.yTsiz;
    };
    prototype.getxTOsiz = function() {
        return this.xTOsiz;
    };
    prototype.getyTOsiz = function() {
        return this.yTOsiz;
    };
    prototype.getCsiz = function() {
        return this.csiz;
    };
}, {generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var GenericDescriptor = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
GenericDescriptor = stjs.extend(GenericDescriptor, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.locators = null;
    prototype.subDescriptors = null;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 12033:
                    this.locators = MXFMetadata.readULBatch(_bb);
                    break;
                case 16129:
                    this.subDescriptors = MXFMetadata.readULBatch(_bb);
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getLocators = function() {
        return this.locators;
    };
    prototype.getSubDescriptors = function() {
        return this.subDescriptors;
    };
}, {locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MXFStructuralComponent = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
MXFStructuralComponent = stjs.extend(MXFStructuralComponent, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.duration = 0;
    prototype.dataDefinitionUL = null;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            switch (entry.getKey()) {
                case 514:
                    this.duration = entry.getValue().getLong();
                    break;
                case 513:
                    this.dataDefinitionUL = UL.read(entry.getValue());
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getDataDefinitionUL = function() {
        return this.dataDefinitionUL;
    };
}, {dataDefinitionUL: "UL", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ContentStorage = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
ContentStorage = stjs.extend(ContentStorage, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.packageRefs = null;
    prototype.essenceContainerData = null;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 6401:
                    this.packageRefs = MXFMetadata.readULBatch(_bb);
                    break;
                case 6402:
                    this.essenceContainerData = MXFMetadata.readULBatch(_bb);
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ ContentStorage: " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getPackageRefs = function() {
        return this.packageRefs;
    };
    prototype.getEssenceContainerData = function() {
        return this.essenceContainerData;
    };
}, {packageRefs: "Array", essenceContainerData: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MXF demuxer, Index segment structure. Contains information about frame
 *  offsets. Used for rapid random positioning within the movie.
 *  
 *  @author The JCodec project
 *  
 */
var IndexSegment = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
IndexSegment = stjs.extend(IndexSegment, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.ie = null;
    prototype.editUnitByteCount = 0;
    prototype.deltaEntries = null;
    prototype.indexSID = 0;
    prototype.bodySID = 0;
    prototype.indexEditRateNum = 0;
    prototype.indexEditRateDen = 0;
    prototype.indexStartPosition = 0;
    prototype.indexDuration = 0;
    prototype.instanceUID = null;
    prototype.sliceCount = 0;
    prototype.posTableCount = 0;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 15370:
                    this.instanceUID = UL.read(_bb);
                    break;
                case 16133:
                    this.editUnitByteCount = _bb.getInt();
                    break;
                case 16134:
                    this.indexSID = _bb.getInt();
                    break;
                case 16135:
                    this.bodySID = _bb.getInt();
                    break;
                case 16136:
                    this.sliceCount = _bb.get() & 255;
                    break;
                case 16137:
                    this.deltaEntries = DeltaEntries.read(_bb);
                    break;
                case 16138:
                    this.ie = IndexEntries.read(_bb);
                    break;
                case 16139:
                    this.indexEditRateNum = _bb.getInt();
                    this.indexEditRateDen = _bb.getInt();
                    break;
                case 16140:
                    this.indexStartPosition = _bb.getLong();
                    break;
                case 16141:
                    this.indexDuration = _bb.getLong();
                    break;
                case 16142:
                    this.posTableCount = _bb.get() & 255;
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [" + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getIe = function() {
        return this.ie;
    };
    prototype.getEditUnitByteCount = function() {
        return this.editUnitByteCount;
    };
    prototype.getDeltaEntries = function() {
        return this.deltaEntries;
    };
    prototype.getIndexSID = function() {
        return this.indexSID;
    };
    prototype.getBodySID = function() {
        return this.bodySID;
    };
    prototype.getIndexEditRateNum = function() {
        return this.indexEditRateNum;
    };
    prototype.getIndexEditRateDen = function() {
        return this.indexEditRateDen;
    };
    prototype.getIndexStartPosition = function() {
        return this.indexStartPosition;
    };
    prototype.getIndexDuration = function() {
        return this.indexDuration;
    };
    prototype.getInstanceUID = function() {
        return this.instanceUID;
    };
    prototype.getSliceCount = function() {
        return this.sliceCount;
    };
    prototype.getPosTableCount = function() {
        return this.posTableCount;
    };
}, {ie: "IndexEntries", deltaEntries: "DeltaEntries", instanceUID: "UL", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var EssenceContainerData = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
EssenceContainerData = stjs.extend(EssenceContainerData, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.linkedPackageUID = null;
    prototype.indexSID = 0;
    prototype.bodySID = 0;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 9985:
                    this.linkedPackageUID = UL.read(_bb);
                    break;
                case 16134:
                    this.indexSID = _bb.getInt();
                    break;
                case 16135:
                    this.bodySID = _bb.getInt();
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ EssenceContainerData: " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getLinkedPackageUID = function() {
        return this.linkedPackageUID;
    };
    prototype.getIndexSID = function() {
        return this.indexSID;
    };
    prototype.getBodySID = function() {
        return this.bodySID;
    };
}, {linkedPackageUID: "UL", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Gets media info from MPEG PS file
 *  
 *  @author The JCodec project
 *  
 */
var MPSMediaInfo = function() {
    MPSUtils.PESReader.call(this);
    this.infos = new HashMap();
};
MPSMediaInfo = stjs.extend(MPSMediaInfo, MPSUtils.PESReader, [], function(constructor, prototype) {
    prototype.infos = null;
    prototype.pesTried = 0;
    prototype.psm = null;
    constructor.MPEGTimecodeMetadata = function() {};
    constructor.MPEGTimecodeMetadata = stjs.extend(constructor.MPEGTimecodeMetadata, null, [], function(constructor, prototype) {
        prototype.getNumFrames = function() {
            return null;
        };
        prototype.isDropFrame = function() {
            return null;
        };
        prototype.getStartCounter = function() {
            return null;
        };
    }, {}, {});
    constructor.MPEGTrackMetadata = function(streamId) {
        this.streamId = streamId;
    };
    constructor.MPEGTrackMetadata = stjs.extend(constructor.MPEGTrackMetadata, null, [], function(constructor, prototype) {
        prototype.streamId = 0;
        prototype.codec = null;
        prototype.probeData = null;
        prototype.getAudioFormat = function() {
            return null;
        };
        prototype.getChannelLables = function() {
            return null;
        };
        prototype.getDisplaySize = function() {
            return null;
        };
        prototype.getCodedSize = function() {
            return null;
        };
        prototype.getFps = function() {
            return 0;
        };
        prototype.getDuration = function() {
            return 0;
        };
        prototype.getFourcc = function() {
            return null;
        };
        prototype.getFpsR = function() {
            return null;
        };
        prototype.getNumFrames = function() {
            return 0;
        };
        prototype.getTimecode = function() {
            return null;
        };
    }, {codec: "Codec", probeData: "ByteBuffer"}, {});
    prototype.getMediaInfo = function(f) {
        try {
            new (stjs.extend(function MPSMediaInfo$1() {
                NIOUtils.FileReader.call(this);
            }, NIOUtils.FileReader, [], function(constructor, prototype) {
                prototype.data = function(data, filePos) {
                    this.analyseBuffer(data, filePos);
                };
                prototype.done = function() {};
            }, {}, {}))().readFile(f, 65536, null);
        }catch (e) {
            Logger.info("Media info done");
        }
        return this.getInfos();
    };
    constructor.MediaInfoDone = function() {
        RuntimeException.call(this);
    };
    constructor.MediaInfoDone = stjs.extend(constructor.MediaInfoDone, RuntimeException, [], null, {}, {});
    prototype.pes = function(pesBuffer, start, pesLen, stream) {
        if (!MPSUtils.mediaStream(stream)) 
            return;
        var info = this.infos.get(stream);
        if (info == null) {
            info = new MPSMediaInfo.MPEGTrackMetadata(stream);
            this.infos.put(stream, info);
        }
        if (info.probeData == null) 
            info.probeData = NIOUtils.cloneBuffer(pesBuffer);
        if (++this.pesTried >= 100) {
            this.deriveMediaInfo();
             throw new MPSMediaInfo.MediaInfoDone();
        }
    };
    prototype.deriveMediaInfo = function() {
        var values = this.infos.values();
        for (var iterator$stream = values.iterator(); iterator$stream.hasNext(); ) {
            var stream = iterator$stream.next();
            var streamId = 256 | stream.streamId;
            if (streamId >= MPSUtils.AUDIO_MIN && streamId <= MPSUtils.AUDIO_MAX) {
                stream.codec = Codec.MP2;
            } else if (streamId == MPSUtils.PRIVATE_1) {
                var dup = stream.probeData.duplicate();
                MPSUtils.readPESHeader(dup, 0);
                var type = dup.get() & 255;
                if (type >= 128 && type <= 135) {
                    stream.codec = Codec.AC3;
                } else if ((type >= 136 && type <= 143) || (type >= 152 && type <= 159)) {
                    stream.codec = Codec.DTS;
                } else if (type >= 160 && type <= 175) {
                    stream.codec = Codec.PCM_DVD;
                } else if (type >= 176 && type <= 191) {
                    stream.codec = Codec.TRUEHD;
                } else if (type >= 192 && type <= 207) {
                    stream.codec = Codec.AC3;
                }
            } else if (streamId >= MPSUtils.VIDEO_MIN && streamId <= MPSUtils.VIDEO_MAX) {
                stream.codec = Codec.MPEG2;
            }
        }
    };
    prototype.parseSystem = function(pesBuffer) {
        NIOUtils.skip(pesBuffer, 12);
        var result = IntArrayList.createIntArrayList();
         while (pesBuffer.remaining() >= 3 && (pesBuffer.getAt(pesBuffer.position()) & 128) == 128){
            result.add(pesBuffer.get() & 255);
            pesBuffer.getShort();
        }
        return result.toArray();
    };
    constructor.PSM = function() {};
    constructor.PSM = stjs.extend(constructor.PSM, null, [], null, {}, {});
    prototype.parsePSM = function(pesBuffer) {
        pesBuffer.getInt();
        var psmLen = pesBuffer.getShort();
        if (psmLen > 1018) 
             throw new RuntimeException("Invalid PSM");
        var b0 = pesBuffer.get();
        var b1 = pesBuffer.get();
        if ((b1 & 1) != 1) 
             throw new RuntimeException("Invalid PSM");
        var psiLen = pesBuffer.getShort();
        var psi = NIOUtils.read(pesBuffer, psiLen & 65535);
        var elStreamLen = pesBuffer.getShort();
        this.parseElStreams(NIOUtils.read(pesBuffer, elStreamLen & 65535));
        var crc = pesBuffer.getInt();
        return new MPSMediaInfo.PSM();
    };
    prototype.parseElStreams = function(buf) {
         while (buf.hasRemaining()){
            var streamType = buf.get();
            var streamId = buf.get();
            var strInfoLen = buf.getShort();
            var strInfo = NIOUtils.read(buf, strInfoLen & 65535);
        }
    };
    prototype.getInfos = function() {
        return new ArrayList(this.infos.values());
    };
    constructor.main1 = function(args) {
        new MPSMediaInfo().getMediaInfo(new File(args[0]));
    };
    constructor.extract = function(input) {
        return null;
    };
    prototype.getAudioTracks = function() {
        return null;
    };
    prototype.getVideoTrack = function() {
        return null;
    };
}, {infos: {name: "Map", arguments: [null, "MPSMediaInfo.MPEGTrackMetadata"]}, psm: "MPSMediaInfo.PSM", pesBuffer: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Indexes MPEG PS/TS file for the purpose of quick random access in the future
 *  
 *  @author The JCodec project
 *  
 */
var BaseIndexer = function() {
    MPSUtils.PESReader.call(this);
    this.analyzers = new HashMap();
    this.tokens = LongArrayList.createLongArrayList();
    this.streams = new RunLength.Integer();
};
BaseIndexer = stjs.extend(BaseIndexer, MPSUtils.PESReader, [], function(constructor, prototype) {
    prototype.analyzers = null;
    prototype.tokens = null;
    prototype.streams = null;
    prototype.estimateSize = function() {
        var sizeEstimate = (this.tokens.size() << 3) + this.streams.estimateSize() + 128;
        for (var iterator$stream = this.analyzers.keySet().iterator(); iterator$stream.hasNext(); ) {
            var stream = iterator$stream.next();
            sizeEstimate += this.analyzers.get(stream).estimateSize();
        }
        return sizeEstimate;
    };
    constructor.BaseAnalyser = function() {
        this.pts = new IntArrayList(250000);
        this.dur = new IntArrayList(250000);
    };
    constructor.BaseAnalyser = stjs.extend(constructor.BaseAnalyser, null, [], function(constructor, prototype) {
        prototype.pts = null;
        prototype.dur = null;
        prototype.pkt = function(pkt, pesHeader) {};
        prototype.finishAnalyse = function() {};
        prototype.estimateSize = function() {
            return (this.pts.size() << 2) + 4;
        };
        prototype.serialize = function(streamId) {};
    }, {pts: "IntArrayList", dur: "IntArrayList"}, {});
    constructor.GenericAnalyser = function() {
        BaseIndexer.BaseAnalyser.call(this);
        this.sizes = new IntArrayList(250000);
    };
    constructor.GenericAnalyser = stjs.extend(constructor.GenericAnalyser, BaseIndexer.BaseAnalyser, [], function(constructor, prototype) {
        prototype.sizes = null;
        prototype.knownDuration = 0;
        prototype.lastPts = 0;
        prototype.pkt = function(pkt, pesHeader) {
            this.sizes.add(pkt.remaining());
            if (pesHeader.pts == -1) {
                pesHeader.pts = this.lastPts + this.knownDuration;
            } else {
                this.knownDuration = (((pesHeader.pts - this.lastPts)) | 0);
                this.lastPts = pesHeader.pts;
            }
            this.pts.add(((pesHeader.pts) | 0));
            this.dur.add(this.knownDuration);
        };
        prototype.serialize = function(streamId) {
            return new MPSIndex.MPSStreamIndex(streamId, this.sizes.toArray(), this.pts.toArray(), this.dur.toArray(), new Int32Array(0));
        };
        prototype.estimateSize = function() {
            return BaseIndexer.BaseAnalyser.prototype.estimateSize.call(this) + (this.sizes.size() << 2) + 32;
        };
        prototype.finishAnalyse = function() {};
    }, {sizes: "IntArrayList", pts: "IntArrayList", dur: "IntArrayList"}, {});
    constructor.MPEGVideoAnalyser = function() {
        BaseIndexer.BaseAnalyser.call(this);
        this.sizes = new IntArrayList(250000);
        this.keyFrames = new IntArrayList(20000);
        this.curGop = new ArrayList();
    };
    constructor.MPEGVideoAnalyser = stjs.extend(constructor.MPEGVideoAnalyser, BaseIndexer.BaseAnalyser, [], function(constructor, prototype) {
        prototype.marker = -1;
        prototype.position = 0;
        prototype.sizes = null;
        prototype.keyFrames = null;
        prototype.frameNo = 0;
        prototype.inFrameData = false;
        prototype.lastFrame = null;
        prototype.curGop = null;
        prototype.phPos = -1;
        prototype.lastFrameOfLastGop = null;
        constructor.Frame = function() {};
        constructor.Frame = stjs.extend(constructor.Frame, null, [], function(constructor, prototype) {
            prototype.offset = 0;
            prototype.size = 0;
            prototype.pts = 0;
            prototype.tempRef = 0;
        }, {}, {});
        prototype.pkt = function(pkt, pesHeader) {
             while (pkt.hasRemaining()){
                var b = pkt.get() & 255;
                ++this.position;
                this.marker = (this.marker << 8) | b;
                if (this.phPos != -1) {
                    var phOffset = this.position - this.phPos;
                    if (phOffset == 5) 
                        this.lastFrame.tempRef = b << 2;
                     else if (phOffset == 6) {
                        var picCodingType = (b >> 3) & 7;
                        this.lastFrame.tempRef |= b >> 6;
                        if (picCodingType == MPEGConst.IntraCoded) {
                            this.keyFrames.add(this.frameNo - 1);
                            if (this.curGop.size() > 0) 
                                this.outGop();
                        }
                    }
                }
                if ((this.marker & -256) != 256) 
                    continue;
                if (this.inFrameData && (this.marker == 256 || this.marker > 431)) {
                    this.lastFrame.size = (((this.position - 4 - this.lastFrame.offset)) | 0);
                    this.curGop.add(this.lastFrame);
                    this.lastFrame = null;
                    this.inFrameData = false;
                } else if (!this.inFrameData && (this.marker > 256 && this.marker <= 431)) {
                    this.inFrameData = true;
                }
                if (this.lastFrame == null && (this.marker == 435 || this.marker == 440 || this.marker == 256)) {
                    var frame = new BaseIndexer.MPEGVideoAnalyser.Frame();
                    frame.pts = ((pesHeader.pts) | 0);
                    frame.offset = this.position - 4;
                    Logger.info(String.format("FRAME[%d]: %012x, %d", this.frameNo, (pesHeader.pos + pkt.position() - 4), pesHeader.pts));
                    this.frameNo++;
                    this.lastFrame = frame;
                }
                if (this.lastFrame != null && this.lastFrame.pts == -1 && this.marker == 256) {
                    this.lastFrame.pts = ((pesHeader.pts) | 0);
                }
                this.phPos = this.marker == 256 ? this.position - 4 : -1;
            }
        };
        prototype.outGop = function() {
            this.fixPts(this.curGop);
            for (var iterator$frame = this.curGop.iterator(); iterator$frame.hasNext(); ) {
                var frame = iterator$frame.next();
                this.sizes.add(frame.size);
                this.pts.add(frame.pts);
            }
            this.curGop.clear();
        };
        prototype.fixPts = function(curGop) {
            var frames = curGop.toArray(Array(0));
            Arrays.sort(frames, new (stjs.extend(function BaseIndexer$MPEGVideoAnalyser$1() {}, null, [Comparator], function(constructor, prototype) {
                prototype.compare = function(o1, o2) {
                    return o1.tempRef > o2.tempRef ? 1 : (o1.tempRef == o2.tempRef ? 0 : -1);
                };
            }, {}, {}))());
            for (var dir = 0; dir < 3; dir++) {
                for (var i = 0, lastPts = -1, secondLastPts = -1, lastTref = -1, secondLastTref = -1; i < frames.length; i++) {
                    if (frames[i].pts == -1 && lastPts != -1 && secondLastPts != -1) 
                        frames[i].pts = lastPts + stjs.trunc((lastPts - secondLastPts) / MathUtil.abs(lastTref - secondLastTref));
                    if (frames[i].pts != -1) {
                        secondLastPts = lastPts;
                        secondLastTref = lastTref;
                        lastPts = frames[i].pts;
                        lastTref = frames[i].tempRef;
                    }
                }
                ArrayUtil.reverse(frames);
            }
            if (this.lastFrameOfLastGop != null) {
                this.dur.add(frames[0].pts - this.lastFrameOfLastGop.pts);
            }
            for (var i = 1; i < frames.length; i++) {
                this.dur.add(frames[i].pts - frames[i - 1].pts);
            }
            this.lastFrameOfLastGop = frames[frames.length - 1];
        };
        prototype.finishAnalyse = function() {
            if (this.lastFrame == null) 
                return;
            this.lastFrame.size = (((this.position - this.lastFrame.offset)) | 0);
            this.curGop.add(this.lastFrame);
            this.outGop();
        };
        prototype.serialize = function(streamId) {
            return new MPSIndex.MPSStreamIndex(streamId, this.sizes.toArray(), this.pts.toArray(), this.dur.toArray(), this.keyFrames.toArray());
        };
    }, {sizes: "IntArrayList", keyFrames: "IntArrayList", lastFrame: "BaseIndexer.MPEGVideoAnalyser.Frame", curGop: {name: "List", arguments: ["BaseIndexer.MPEGVideoAnalyser.Frame"]}, lastFrameOfLastGop: "BaseIndexer.MPEGVideoAnalyser.Frame", pts: "IntArrayList", dur: "IntArrayList"}, {});
    prototype.getAnalyser = function(stream) {
        var analizer = this.analyzers.get(stream);
        if (analizer == null) {
            analizer = stream >= 224 && stream <= 239 ? new BaseIndexer.MPEGVideoAnalyser() : new BaseIndexer.GenericAnalyser();
            this.analyzers.put(stream, analizer);
        }
        return this.analyzers.get(stream);
    };
    prototype.serialize = function() {
        var streamsIndices = new ArrayList();
        var entrySet = this.analyzers.entrySet();
        for (var iterator$entry = entrySet.iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            streamsIndices.add(entry.getValue().serialize(entry.getKey()));
        }
        return new MPSIndex(this.tokens.toArray(), this.streams, streamsIndices.toArray(Array(0)));
    };
    prototype.savePESMeta = function(stream, token) {
        this.tokens.add(token);
        this.streams.add(stream);
    };
    prototype.finishAnalyse = function() {
        MPSUtils.PESReader.prototype.finishRead.call(this);
        for (var iterator$baseAnalyser = this.analyzers.values().iterator(); iterator$baseAnalyser.hasNext(); ) {
            var baseAnalyser = iterator$baseAnalyser.next();
            baseAnalyser.finishAnalyse();
        }
    };
}, {analyzers: {name: "Map", arguments: [null, "BaseIndexer.BaseAnalyser"]}, tokens: "LongArrayList", streams: "RunLength.Integer", pesBuffer: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var GenericTrack = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
GenericTrack = stjs.extend(GenericTrack, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.trackId = 0;
    prototype.name = null;
    prototype.sequenceRef = null;
    prototype.trackNumber = 0;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 18433:
                    this.trackId = _bb.getInt();
                    break;
                case 18434:
                    this.name = this.readUtf16String(_bb);
                    break;
                case 18435:
                    this.sequenceRef = UL.read(_bb);
                    break;
                case 18436:
                    this.trackNumber = _bb.getInt();
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getTrackId = function() {
        return this.trackId;
    };
    prototype.getName = function() {
        return this.name;
    };
    prototype.getSequenceRef = function() {
        return this.sequenceRef;
    };
    prototype.getTrackNumber = function() {
        return this.trackNumber;
    };
}, {sequenceRef: "UL", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var GenericPackage = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
GenericPackage = stjs.extend(GenericPackage, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.tracks = null;
    prototype.packageUID = null;
    prototype.name = null;
    prototype.packageModifiedDate = null;
    prototype.packageCreationDate = null;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 17409:
                    this.packageUID = UL.read(_bb);
                    break;
                case 17410:
                    this.name = this.readUtf16String(_bb);
                    break;
                case 17411:
                    this.tracks = MXFMetadata.readULBatch(_bb);
                    break;
                case 17412:
                    this.packageModifiedDate = MXFMetadata.readDate(_bb);
                    break;
                case 17413:
                    this.packageCreationDate = MXFMetadata.readDate(_bb);
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getTracks = function() {
        return this.tracks;
    };
    prototype.getPackageUID = function() {
        return this.packageUID;
    };
    prototype.getName = function() {
        return this.name;
    };
    prototype.getPackageModifiedDate = function() {
        return this.packageModifiedDate;
    };
    prototype.getPackageCreationDate = function() {
        return this.packageCreationDate;
    };
}, {tracks: "Array", packageUID: "UL", packageModifiedDate: "jsutil.Date", packageCreationDate: "jsutil.Date", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var JpegDecoder = function() {
    VideoDecoder.call(this);
    this.buf = new Int32Array(64);
};
JpegDecoder = stjs.extend(JpegDecoder, VideoDecoder, [], function(constructor, prototype) {
    prototype.interlace = false;
    prototype.topFieldFirst = false;
    prototype.buf = null;
    prototype.setInterlace = function(interlace, topFieldFirst) {
        this.interlace = interlace;
        this.topFieldFirst = topFieldFirst;
    };
    prototype.decodeScan = function(data, header, scan, huffTables, quant, data2, field, step) {
        var blockW = header.getHmax();
        var blockH = header.getVmax();
        var mcuW = blockW << 3;
        var mcuH = blockH << 3;
        var width = header.width;
        var height = header.height;
        var xBlocks = (width + mcuW - 1) >> (blockW + 2);
        var yBlocks = (height + mcuH - 1) >> (blockH + 2);
        var nn = blockW + blockH;
        var result = new Picture(xBlocks << (blockW + 2), yBlocks << (blockH + 2), data2, null, nn == 4 ? ColorSpace.YUV420J : (nn == 3 ? ColorSpace.YUV422J : ColorSpace.YUV444J), 0, new Rect(0, 0, width, height));
        var bits = BitReader.createBitReader(data);
        var dcPredictor = new Int32Array([1024, 1024, 1024]);
        for (var by = 0; by < yBlocks; by++) 
            for (var bx = 0; bx < xBlocks && bits.moreData(); bx++) 
                this.decodeMCU(bits, dcPredictor, quant, huffTables, result, bx, by, blockW, blockH, field, step);
        return result;
    };
    prototype.putBlock = function(plane, stride, patch, x, y, field, step) {
        var dstride = step * stride;
        for (var i = 0, off = field * stride + y * dstride + x, poff = 0; i < 8; i++) {
            for (var j = 0; j < 8; j++) 
                plane[j + off] = ((MathUtil.clip(patch[j + poff], 0, 255) - 128) << 24 >> 24);
            off += dstride;
            poff += 8;
        }
    };
    prototype.decodeMCU = function(bits, dcPredictor, quant, huff, result, bx, by, blockH, blockV, field, step) {
        var sx = bx << (blockH - 1);
        var sy = by << (blockV - 1);
        for (var i = 0; i < blockV; i++) 
            for (var j = 0; j < blockH; j++) {
                this.decodeBlock(bits, dcPredictor, quant, huff, result, this.buf, (sx + j) << 3, (sy + i) << 3, 0, 0, field, step);
            }
        this.decodeBlock(bits, dcPredictor, quant, huff, result, this.buf, bx << 3, by << 3, 1, 1, field, step);
        this.decodeBlock(bits, dcPredictor, quant, huff, result, this.buf, bx << 3, by << 3, 2, 1, field, step);
    };
    prototype.decodeBlock = function(bits, dcPredictor, quant, huff, result, buf, blkX, blkY, plane, chroma, field, step) {
        Arrays.fill(buf, 0);
        dcPredictor[plane] = buf[0] = this.readDCValue(bits, huff[chroma]) * quant[chroma][0] + dcPredictor[plane];
        this.readACValues(bits, buf, huff[chroma + 2], quant[chroma]);
        SimpleIDCT10Bit.idct10(buf, 0);
        this.putBlock(result.getPlaneData(plane), result.getPlaneWidth(plane), buf, blkX, blkY, field, step);
    };
    prototype.readDCValue = function(_in, table) {
        var code = table.readVLC16(_in);
        return code != 0 ? JpegDecoder.toValue(_in.readNBit(code), code) : 0;
    };
    prototype.readACValues = function(_in, target, table, quantTable) {
        var code;
        var curOff = 1;
        do {
            code = table.readVLC16(_in);
            if (code == 240) {
                curOff += 16;
            } else if (code > 0) {
                var rle = code >> 4;
                curOff += rle;
                var len = code & 15;
                target[JpegConst.naturalOrder[curOff]] = JpegDecoder.toValue(_in.readNBit(len), len) * quantTable[curOff];
                curOff++;
            }
        } while (code != 0 && curOff < 64);
    };
    constructor.toValue = function(raw, length) {
        return (length >= 1 && raw < (1 << length - 1)) ? -(1 << length) + 1 + raw : raw;
    };
    prototype.decodeFrame = function(data, data2) {
        if (this.interlace) {
            var r1 = this.decodeField(data, data2, this.topFieldFirst ? 0 : 1, 2);
            var r2 = this.decodeField(data, data2, this.topFieldFirst ? 1 : 0, 2);
            return Picture.createPicture(r1.getWidth(), r1.getHeight() << 1, data2, r1.getColor());
        } else {
            return this.decodeField(data, data2, 0, 1);
        }
    };
    prototype.decodeField = function(data, data2, field, step) {
        var result = null;
        var header = null;
        var huffTables = [JpegConst.YDC_DEFAULT, JpegConst.CDC_DEFAULT, JpegConst.YAC_DEFAULT, JpegConst.CAC_DEFAULT];
        var quant = [JpegConst.DEFAULT_QUANT_LUMA, JpegConst.DEFAULT_QUANT_CHROMA];
        var scan = null;
        var skipToNext = false;
         while (data.hasRemaining()){
            var marker;
            if (!skipToNext) {
                marker = data.get() & 255;
            } else {
                 while ((marker = (data.get() & 255)) != 255)
                    ;
            }
            skipToNext = false;
            if (marker == 0) 
                continue;
            if (marker != 255) 
                 throw new RuntimeException("@" + Long.toHexString(data.position()) + " Marker expected: 0x" + Integer.toHexString(marker));
            var b;
             while ((b = data.get() & 255) == 255)
                ;
            if (b == JpegConst.SOF0) {
                header = FrameHeader.read(data);
            } else if (b == JpegConst.DHT) {
                var len1 = data.getShort() & 65535;
                var buf = NIOUtils.read(data, len1 - 2);
                 while (buf.hasRemaining()){
                    var tableNo = buf.get() & 255;
                    huffTables[(tableNo & 1) | ((tableNo >> 3) & 2)] = JpegDecoder.readHuffmanTable(buf);
                }
            } else if (b == JpegConst.DQT) {
                var len4 = data.getShort() & 65535;
                var buf = NIOUtils.read(data, len4 - 2);
                 while (buf.hasRemaining()){
                    var ind = buf.get() & 255;
                    quant[ind] = JpegDecoder.readQuantTable(buf);
                }
            } else if (b == JpegConst.SOS) {
                if (scan != null) {
                     throw new UnhandledStateException("unhandled - more than one scan header");
                }
                scan = ScanHeader.read(data);
                result = this.decodeScan(JpegDecoder.readToMarker(data), header, scan, huffTables, quant, data2, field, step);
            } else if (b == JpegConst.SOI || (b >= JpegConst.RST0 && b <= JpegConst.RST7)) {
                Logger.warn("SOI not supported.");
                skipToNext = true;
            } else if (b == JpegConst.EOI) {
                break;
            } else if (b >= JpegConst.APP0 && b <= JpegConst.COM) {
                var len3 = data.getShort() & 65535;
                NIOUtils.read(data, len3 - 2);
            } else if (b == JpegConst.DRI) {
                Logger.warn("DRI not supported.");
                skipToNext = true;
            } else {
                if (b != 0) 
                    Logger.warn("unhandled marker " + JpegConst.markerToString(b));
                skipToNext = true;
            }
        }
        return result;
    };
    constructor.readToMarker = function(data) {
        var out = ByteBuffer.allocate(data.remaining());
         while (data.hasRemaining()){
            var b0 = data.get();
            if (b0 == -1) {
                var b1 = data.get();
                if (b1 == 0) 
                    out.put((-1 << 24 >> 24));
                 else {
                    data.setPosition(data.position() - 2);
                    break;
                }
            } else 
                out.put(b0);
        }
        out.flip();
        return out;
    };
    constructor.readHuffmanTable = function(data) {
        var builder = new VLCBuilder();
        var levelSizes = NIOUtils.toArray(NIOUtils.read(data, 16));
        var levelStart = 0;
        for (var i = 0; i < 16; i++) {
            var length = levelSizes[i] & 255;
            for (var c = 0; c < length; c++) {
                var val = data.get() & 255;
                var code = levelStart++;
                builder.setInt(code, i + 1, val);
            }
            levelStart <<= 1;
        }
        return builder.getVLC();
    };
    constructor.readQuantTable = function(data) {
        var result = new Int32Array(64);
        for (var i = 0; i < 64; i++) {
            result[i] = data.get() & 255;
        }
        return result;
    };
    prototype.getCodecMeta = function(data) {
        var header = null;
         while (data.hasRemaining()){
             while (data.hasRemaining() && (data.get() & 255) != 255)
                continue;
            var type;
             while ((type = data.get() & 255) == 255)
                ;
            if (type == JpegConst.SOF0) {
                header = FrameHeader.read(data);
                break;
            }
        }
        if (header != null) {
            var blockW = header.getHmax();
            var blockH = header.getVmax();
            var nn = blockW + blockH;
            var color = nn == 4 ? ColorSpace.YUV420J : (nn == 3 ? ColorSpace.YUV422J : ColorSpace.YUV444J);
            return VideoCodecMeta.createSimpleVideoCodecMeta(new Size(header.width, header.height), color);
        }
        return null;
    };
}, {buf: "Int32Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var MPEG4Bitstream = function() {};
MPEG4Bitstream = stjs.extend(MPEG4Bitstream, null, [], function(constructor, prototype) {
    constructor.I_VOP = 0;
    constructor.P_VOP = 1;
    constructor.B_VOP = 2;
    constructor.S_VOP = 3;
    constructor.N_VOP = 4;
    constructor.REVERSE_EVENT_LEN = 0;
    constructor.REVERSE_EVENT_LAST = 1;
    constructor.REVERSE_EVENT_RUN = 2;
    constructor.REVERSE_EVENT_LEVEL = 3;
    constructor.VLC_TABLE_VLC_CODE = 0;
    constructor.VLC_TABLE_VLC_LEN = 1;
    constructor.VLC_TABLE_EVENT_LAST = 2;
    constructor.VLC_TABLE_EVENT_RUN = 3;
    constructor.VLC_TABLE_EVENT_LEVEL = 4;
    constructor.VLC_CODE = 0;
    constructor.VLC_LEN = 1;
    constructor.ESCAPE = 3;
    constructor.NUMBITS_VP_RESYNC_MARKER = 17;
    constructor.RESYNC_MARKER = 1;
    constructor.VIDOBJLAY_SHAPE_RECTANGULAR = 0;
    constructor.VIDOBJLAY_SHAPE_BINARY_ONLY = 2;
    constructor.SPRITE_STATIC = 1;
    constructor.SPRITE_GMC = 2;
    constructor.DQUANT_TABLE = new Int32Array([-1, -2, 1, 2]);
    constructor.vlcTab = Array.apply(null, Array(2)).map(function() {
        return Array.apply(null, Array(4096)).map(function() {
            return new Int8Array(4);
        });
    });
    constructor.initVLCTables = function() {
        for (var intra = 0; intra < 2; intra++) 
            for (var i = 0; i < 4096; i++) 
                MPEG4Bitstream.vlcTab[intra][i][MPEG4Bitstream.REVERSE_EVENT_LEVEL] = 0;
        for (var intra = 0; intra < 2; intra++) {
            for (var i = 0; i < 102; i++) {
                var len = MPEG4Consts.COEFF_TAB[intra][i][MPEG4Bitstream.VLC_TABLE_VLC_LEN];
                var last = MPEG4Consts.COEFF_TAB[intra][i][MPEG4Bitstream.VLC_TABLE_EVENT_LAST];
                var run = MPEG4Consts.COEFF_TAB[intra][i][MPEG4Bitstream.VLC_TABLE_EVENT_RUN];
                var level = MPEG4Consts.COEFF_TAB[intra][i][MPEG4Bitstream.VLC_TABLE_EVENT_LEVEL];
                var code = MPEG4Consts.COEFF_TAB[intra][i][MPEG4Bitstream.VLC_TABLE_VLC_CODE];
                var lowBits = 12 - len;
                for (var j = 0; j < (1 << lowBits); j++) {
                    var entry = (code << lowBits) | j;
                    MPEG4Bitstream.vlcTab[intra][entry][MPEG4Bitstream.REVERSE_EVENT_LEN] = (len << 24 >> 24);
                    MPEG4Bitstream.vlcTab[intra][entry][MPEG4Bitstream.REVERSE_EVENT_LAST] = (last << 24 >> 24);
                    MPEG4Bitstream.vlcTab[intra][entry][MPEG4Bitstream.REVERSE_EVENT_RUN] = (run << 24 >> 24);
                    MPEG4Bitstream.vlcTab[intra][entry][MPEG4Bitstream.REVERSE_EVENT_LEVEL] = (level << 24 >> 24);
                }
            }
        }
    };
    constructor.readMatrix = function(br, matrix) {
        var last, value = 0;
        var i = 0;
        do {
            last = value;
            value = br.readNBit(8);
            matrix[MPEG4Consts.SCAN_TABLES[0][i++]] = ((value) << 16 >> 16);
        } while (value != 0 && i < 64);
        i--;
         while (i < 64){
            matrix[MPEG4Consts.SCAN_TABLES[0][i++]] = ((last) << 16 >> 16);
        }
    };
    constructor.readMcbpcIntra = function(br) {
        var index = br.checkNBit(9);
        index >>= 3;
        br.skip(MPEG4Consts.MCBPC_INTRA_TABLE[index][MPEG4Bitstream.VLC_LEN]);
        return MPEG4Consts.MCBPC_INTRA_TABLE[index][MPEG4Bitstream.VLC_CODE];
    };
    constructor.readMcbpcInter = function(br) {
        var index = Math.min(br.checkNBit(9), 256);
        br.skip(MPEG4Consts.MCBPC_INTER_TABLE[index][MPEG4Bitstream.VLC_LEN]);
        return MPEG4Consts.MCBPC_INTER_TABLE[index][MPEG4Bitstream.VLC_CODE];
    };
    constructor.readCbpy = function(br, intra) {
        var index = br.checkNBit(6);
        br.skip(MPEG4Consts.CBPY_TABLE[index][MPEG4Bitstream.VLC_LEN]);
        var cbpy = MPEG4Consts.CBPY_TABLE[index][MPEG4Bitstream.VLC_CODE];
        if (!intra) 
            cbpy = 15 - cbpy;
        return cbpy;
    };
    constructor.readIntraBlock = function(br, block, direction, coeff) {
        var scan = MPEG4Consts.SCAN_TABLES[direction];
        var c;
        do {
            c = MPEG4Bitstream.readCoeffs(br, true, false);
            var level = MPEG4Bitstream.level(c);
            coeff += MPEG4Bitstream.run(c);
            if ((coeff & ~63) != 0) {
                Logger.error("invalid run or index");
                break;
            }
            block[scan[coeff]] = ((level) << 16 >> 16);
            if (level < -2047 || level > 2047) {
                Logger.error("intra_overflow: " + level);
            }
            coeff++;
        } while (MPEG4Bitstream.last(c) == 0);
    };
    constructor.readInterBlockH263 = function(br, block, direction, quant) {
        var scan = MPEG4Consts.SCAN_TABLES[direction];
        var quant_m_2 = quant << 1;
        var quant_add = ((quant & 1) != 0 ? quant : quant - 1);
        var p = 0;
        p = 0;
        var coeff;
        do {
            coeff = MPEG4Bitstream.readCoeffs(br, false, false);
            var level = MPEG4Bitstream.level(coeff);
            p += MPEG4Bitstream.run(coeff);
            if ((p & ~63) != 0) {
                Logger.error("invalid run or index");
                break;
            }
            if (level < 0) {
                level = level * quant_m_2 - quant_add;
                block[scan[p]] = (((level >= -2048 ? level : -2048)) << 16 >> 16);
            } else {
                level = level * quant_m_2 + quant_add;
                block[scan[p]] = (((level <= 2047 ? level : 2047)) << 16 >> 16);
            }
            p++;
        } while (MPEG4Bitstream.last(coeff) == 0);
    };
    constructor.readInterBlockMPEG = function(br, block, direction, quant, matrix) {
        var scan = MPEG4Consts.SCAN_TABLES[direction];
        var p = 0;
        var sum = 0;
        var coeff;
        do {
            coeff = MPEG4Bitstream.readCoeffs(br, false, false);
            var level = MPEG4Bitstream.level(coeff);
            p += MPEG4Bitstream.run(coeff);
            if ((p & ~63) != 0) {
                Logger.error("invalid run or index");
                break;
            }
            if (level < 0) {
                level = ((2 * -level + 1) * matrix[scan[p]] * quant) >> 4;
                block[scan[p]] = (((level <= 2048 ? -level : -2048)) << 16 >> 16);
            } else {
                level = ((2 * level + 1) * matrix[scan[p]] * quant) >> 4;
                block[scan[p]] = (((level <= 2047 ? level : 2047)) << 16 >> 16);
            }
            sum ^= block[scan[p]];
            p++;
        } while (MPEG4Bitstream.last(coeff) == 0);
        if ((sum & 1) == 0) {
            block[63] ^= 1;
        }
    };
    constructor.packCoeff = function(level, run, last) {
        return ((last & 255) << 24) | ((run & 255) << 16) | (level & 65535);
    };
    constructor.last = function(coeff) {
        return coeff >> 24;
    };
    constructor.run = function(coeff) {
        return (coeff >> 16) & 255;
    };
    constructor.level = function(coeff) {
        return ((coeff) << 16 >> 16);
    };
    constructor.readCoeffs = function(br, intra, shortVideoHeader) {
        var mode;
        var level;
        var run, last;
        var reverse;
        if (shortVideoHeader) 
            intra = false;
        var intraIndex = intra ? 1 : 0;
        if (br.checkNBit(7) != MPEG4Bitstream.ESCAPE) {
            reverse = MPEG4Bitstream.vlcTab[intraIndex][br.checkNBit(12)];
            if ((level = reverse[MPEG4Bitstream.REVERSE_EVENT_LEVEL]) == 0) {
                run = 64;
                return MPEG4Bitstream.packCoeff(0, run, 1);
            }
            last = reverse[MPEG4Bitstream.REVERSE_EVENT_LAST];
            run = reverse[MPEG4Bitstream.REVERSE_EVENT_RUN];
            br.skip(reverse[MPEG4Bitstream.REVERSE_EVENT_LEN]);
            return MPEG4Bitstream.packCoeff(br.readBool() ? -level : level, run, last);
        }
        br.skip(7);
        if (shortVideoHeader) {
            last = br.readNBit(1);
            run = br.readNBit(6);
            level = (br.readNBit(8) << 24 >> 24);
            if (level == 0 || level == 128) 
                Logger.error("Illegal LEVEL for ESCAPE mode 4: " + level);
            return MPEG4Bitstream.packCoeff(level, run, last);
        }
        mode = br.checkNBit(2);
        if (mode < 3) {
            br.skip((mode == 2) ? 2 : 1);
            reverse = MPEG4Bitstream.vlcTab[intraIndex][br.checkNBit(12)];
            if ((level = reverse[MPEG4Bitstream.REVERSE_EVENT_LEVEL]) == 0) {
                run = 64;
                return MPEG4Bitstream.packCoeff(0, run, 1);
            }
            last = reverse[MPEG4Bitstream.REVERSE_EVENT_LAST];
            run = reverse[MPEG4Bitstream.REVERSE_EVENT_RUN];
            br.skip(reverse[MPEG4Bitstream.REVERSE_EVENT_LEN]);
            if (mode < 2) 
                level += MPEG4Consts.MAX_LEVEL[intraIndex][last][run];
             else 
                run += MPEG4Consts.MAX_RUN[intraIndex][last][level] + 1;
            return MPEG4Bitstream.packCoeff(br.readBool() ? -level : level, run, last);
        }
        br.skip(2);
        last = br.read1Bit();
        run = br.readNBit(6);
        br.skip(1);
        level = ((((br.readNBit(12) << 20) >> 20)) << 16 >> 16);
        br.skip(1);
        return MPEG4Bitstream.packCoeff(level, run, last);
    };
    constructor.readMVData = function(br) {
        if (br.readBool()) {
            return 0;
        }
        var tab;
        var index = br.checkNBit(12);
        if (index >= 512) {
            tab = MPEG4Consts.TMNMV_TAB_0[(index >> 8) - 2];
        } else if (index >= 128) {
            tab = MPEG4Consts.TMNMV_TAB_1[(index >> 2) - 32];
        } else {
            if (index < 4) {
                return 0;
            }
            tab = MPEG4Consts.TMNMV_TAB_2[index - 4];
        }
        br.skip(tab[1]);
        return tab[0];
    };
    constructor.readMVComponent = function(br, fcode) {
        var scaleFac = 1 << (fcode - 1);
        var data = MPEG4Bitstream.readMVData(br);
        if (scaleFac == 1 || data == 0) {
            return data;
        }
        var res = br.readNBit(fcode - 1);
        var mv = ((Math.abs(data) - 1) * scaleFac) + res + 1;
        return data < 0 ? -mv : mv;
    };
    constructor.readMBType = function(br) {
        for (var mbType = 0; mbType <= 3; mbType++) {
            if (br.readBool()) {
                return mbType;
            }
        }
        return -1;
    };
    constructor.readDBQuant = function(br) {
        if (!br.readBool()) {
            return 0;
        } else if (!br.readBool()) {
            return -2;
        }
        return 2;
    };
    constructor.readDCSizeLum = function(br) {
        var code = br.checkNBit(11);
        for (var i = 11; i > 3; i--) {
            if (code == 1) {
                br.skip(i);
                return i + 1;
            }
            code >>= 1;
        }
        br.skip(MPEG4Consts.DC_LUM_TAB[code][1]);
        return MPEG4Consts.DC_LUM_TAB[code][0];
    };
    constructor.readDCSizeChrom = function(br) {
        var code = br.checkNBit(12);
        for (var i = 12; i > 2; i--) {
            if (code == 1) {
                br.skip(i);
                return i;
            }
            code >>= 1;
        }
        return 3 - br.readNBit(2);
    };
    constructor.readDCDif = function(br, dcSize) {
        var code = br.readNBit(dcSize);
        var msb = code >> (dcSize - 1);
        if (msb == 0) 
            return (((-1 * (code ^ ((1 << dcSize) - 1)))) << 16 >> 16);
        return ((code) << 16 >> 16);
    };
    constructor.readVideoPacketHeader = function(br, ctx, addBits, fcodeForwardEnabled, fcodeBackwardEnabled, intraDCThresholdEnabled) {
        var startcodeBits = MPEG4Bitstream.NUMBITS_VP_RESYNC_MARKER + addBits;
        var mbNumBits = MathUtil.log2(ctx.mbWidth * ctx.mbHeight - 1) + 1;
        var mbnum;
        var hec = false;
        br.align();
        br.skip(startcodeBits);
        if (ctx.shape != MPEG4Bitstream.VIDOBJLAY_SHAPE_RECTANGULAR) {
            hec = br.readBool();
            if (hec && ctx.spriteEnable != MPEG4Bitstream.SPRITE_STATIC) {
                br.skip(13);
                br.skip(1);
                br.skip(13);
                br.skip(1);
                br.skip(13);
                br.skip(1);
                br.skip(13);
                br.skip(1);
            }
        }
        mbnum = br.readNBit(mbNumBits);
        if (ctx.shape != MPEG4Bitstream.VIDOBJLAY_SHAPE_BINARY_ONLY) {
            ctx.quant = br.readNBit(ctx.quantBits);
        }
        if (ctx.shape == MPEG4Bitstream.VIDOBJLAY_SHAPE_RECTANGULAR) 
            hec = br.readBool();
        if (hec) {
            var timeBase;
            var timeIncrement = 0;
            var codingType;
            for (timeBase = 0; br.readBool(); timeBase++) {}
            br.skip(1);
            if (ctx.timeIncrementBits != 0) 
                timeIncrement = (br.readNBit(ctx.timeIncrementBits));
            br.skip(1);
            codingType = br.readNBit(2);
            if (ctx.shape != MPEG4Bitstream.VIDOBJLAY_SHAPE_RECTANGULAR) {
                br.skip(1);
                if (codingType != MPEG4Bitstream.I_VOP) 
                    br.skip(1);
            }
            if (ctx.shape != MPEG4Bitstream.VIDOBJLAY_SHAPE_BINARY_ONLY) {
                if (intraDCThresholdEnabled) {
                    ctx.intraDCThreshold = MPEG4Consts.INTRA_DC_THRESHOLD_TABLE[br.readNBit(3)];
                }
                if (ctx.spriteEnable == MPEG4Bitstream.SPRITE_GMC && codingType == MPEG4Bitstream.S_VOP && ctx.spriteWarpingPoints > 0) {}
                if (ctx.reducedResolutionEnable && ctx.shape == MPEG4Bitstream.VIDOBJLAY_SHAPE_RECTANGULAR && (codingType == MPEG4Bitstream.P_VOP || codingType == MPEG4Bitstream.I_VOP)) {
                    br.skip(1);
                }
                if (codingType != MPEG4Bitstream.I_VOP && fcodeForwardEnabled) {
                    ctx.fcodeForward = br.readNBit(3);
                }
                if (codingType == MPEG4Bitstream.B_VOP && fcodeBackwardEnabled) {
                    ctx.fcodeBackward = br.readNBit(3);
                }
            }
        }
        if (ctx.newPredEnable) {
            var vopId;
            var vopIdForPrediction;
            vopId = br.readNBit(Math.min(ctx.timeIncrementBits + 3, 15));
            if (br.readBool()) {
                vopIdForPrediction = br.readNBit(Math.min(ctx.timeIncrementBits + 3, 15));
            }
            br.skip(1);
        }
        return mbnum;
    };
    constructor.checkResyncMarker = function(br, addBits) {
        var nbits = br.bitsToAlign();
        var nbitResyncMarker = MPEG4Bitstream.NUMBITS_VP_RESYNC_MARKER + addBits;
        var code = br.checkNBitDontCare(nbitResyncMarker + nbits);
        var MASK1 = (1 << (nbits - 1)) - 1;
        var MASK2 = (1 << nbitResyncMarker) - 1;
        if ((code >> nbitResyncMarker) == MASK1) {
            return (code & MASK2) == MPEG4Bitstream.RESYNC_MARKER;
        }
        return false;
    };
    constructor.readIntraMode = function(br, ctx, mb) {
         while (br.checkNBit(9) == 1)
            br.skip(9);
        if (MPEG4Bitstream.checkResyncMarker(br, 0)) {
            mb.bound = MPEG4Bitstream.readVideoPacketHeader(br, ctx, 0, false, false, true);
            mb.x = mb.bound % ctx.mbWidth;
            mb.y = stjs.trunc(mb.bound / ctx.mbWidth);
        }
        var mcbpc = MPEG4Bitstream.readMcbpcIntra(br);
        mb.mode = mcbpc & 7;
        var cbpc = mcbpc >>> 4;
        mb.acpredFlag = br.readBool();
        var cbpy = MPEG4Bitstream.readCbpy(br, true);
        mb.cbp = (cbpy << 2) | cbpc;
        if (mb.mode == MPEG4Consts.MODE_INTRA_Q) {
            ctx.quant += MPEG4Bitstream.DQUANT_TABLE[br.readNBit(2)];
            if (ctx.quant > 31) {
                ctx.quant = 31;
            } else if (ctx.quant < 1) {
                ctx.quant = 1;
            }
        }
        mb.quant = ctx.quant;
        mb.mvs[0].x = mb.mvs[0].y = mb.mvs[1].x = mb.mvs[1].y = mb.mvs[2].x = mb.mvs[2].y = mb.mvs[3].x = mb.mvs[3].y = 0;
        if (ctx.interlacing) {
            mb.fieldDCT = br.readBool();
        }
    };
    constructor.readCoeffIntra = function(br, ctx, mb, aboveMb, leftMb, aboveLeftMb) {
        for (var i = 0; i < 6; i++) {
            Arrays.fill(mb.block[i], (0 << 24 >> 24));
            var iDcScaler = MPEG4Bitstream.getDCScaler(mb.quant, i < 4);
            var startCoeff;
            MPEG4Bitstream.predictAcdc(ctx, mb.x, mb.y, i, mb.quant, iDcScaler, mb.predictors, mb.bound, mb, aboveMb, leftMb, aboveLeftMb);
            if (!mb.acpredFlag) {
                mb.acpredDirections[i] = 0;
            }
            if (mb.quant < ctx.intraDCThreshold) {
                var dcSize = i < 4 ? MPEG4Bitstream.readDCSizeLum(br) : MPEG4Bitstream.readDCSizeChrom(br);
                var dcDif = dcSize != 0 ? MPEG4Bitstream.readDCDif(br, dcSize) : 0;
                if (dcSize > 8) {
                    br.skip(1);
                }
                mb.block[i][0] = dcDif;
                startCoeff = 1;
            } else {
                startCoeff = 0;
            }
            if ((mb.cbp & (1 << (5 - i))) != 0) {
                var direction = ctx.alternateVerticalScan ? 2 : mb.acpredDirections[i];
                MPEG4Bitstream.readIntraBlock(br, mb.block[i], direction, startCoeff);
            }
            MPEG4Bitstream.addAcdc(mb, ctx.bsVersion, i, iDcScaler);
            if (!ctx.quantType) {
                MPEG4Bitstream.dequantH263Intra(ctx, mb.block[i], mb.quant, iDcScaler);
            } else {
                MPEG4Bitstream.dequantMpegIntra(ctx, mb.block[i], mb.quant, iDcScaler);
            }
        }
    };
    constructor.addAcdc = function(mb, bsVersion, block, iDcScaler) {
        var coeffs = mb.block[block];
        var acpredDirection = (mb.acpredDirections[block] << 24 >> 24);
        var current = mb.predValues[block];
        coeffs[0] += mb.predictors[0];
        current[0] = (((coeffs[0] * iDcScaler)) << 16 >> 16);
        if (bsVersion == 0 || bsVersion > MPEG4Consts.BS_VERSION_BUGGY_DC_CLIP) {
            current[0] = (((current[0]) < (-2048)) ? (-2048) : ((current[0]) > (2047)) ? (2047) : (current[0]));
        }
        if (acpredDirection == 1) {
            for (var i = 1; i < 8; i++) {
                var level = (((coeffs[i] + mb.predictors[i])) << 16 >> 16);
                coeffs[i] = level;
                current[i] = level;
                current[i + 7] = coeffs[i * 8];
            }
        } else if (acpredDirection == 2) {
            for (var i = 1; i < 8; i++) {
                var level = (((coeffs[i * 8] + mb.predictors[i])) << 16 >> 16);
                coeffs[i * 8] = level;
                current[i + 7] = level;
                current[i] = coeffs[i];
            }
        } else {
            for (var i = 1; i < 8; i++) {
                current[i] = coeffs[i];
                current[i + 7] = coeffs[i * 8];
            }
        }
    };
    constructor.readInterModeCoeffs = function(br, ctx, fcode, mb, aboveMb, leftMb, aboveLeftMb, aboveRightMb) {
        if (!br.readBool()) {
            mb.coded = true;
            var mcbpc, cbpc, cbpy;
            var intra = false;
            var mcsel = false;
            mcbpc = MPEG4Bitstream.readMcbpcInter(br);
            mb.mode = mcbpc & 7;
            cbpc = (mcbpc >>> 4);
            intra = (mb.mode == MPEG4Consts.MODE_INTRA || mb.mode == MPEG4Consts.MODE_INTRA_Q);
            if (intra) {
                mb.acpredFlag = br.readBool();
            }
            mb.mcsel = mcsel;
            cbpy = MPEG4Bitstream.readCbpy(br, intra);
            mb.cbp = (cbpy << 2) | cbpc;
            if (mb.mode == MPEG4Consts.MODE_INTER_Q || mb.mode == MPEG4Consts.MODE_INTRA_Q) {
                var dquant = MPEG4Bitstream.DQUANT_TABLE[br.readNBit(2)];
                ctx.quant += dquant;
                if (ctx.quant > 31) {
                    ctx.quant = 31;
                } else if (ctx.quant < 1) {
                    ctx.quant = 1;
                }
            }
            mb.quant = ctx.quant;
            if (ctx.interlacing) {
                if (mb.cbp != 0 || intra) {
                    mb.fieldDCT = br.readBool();
                }
                if ((mb.mode == MPEG4Consts.MODE_INTER || mb.mode == MPEG4Consts.MODE_INTER_Q) && !mcsel) {
                    mb.fieldPred = br.readBool();
                    if (mb.fieldPred) {
                        mb.fieldForTop = br.readBool();
                        mb.fieldForBottom = br.readBool();
                    }
                }
            }
            if (mcsel) {
                MPEG4Bitstream.readInterCoeffs(br, ctx, mb);
            } else if (mb.mode == MPEG4Consts.MODE_INTER || mb.mode == MPEG4Consts.MODE_INTER_Q || mb.mode == MPEG4Consts.MODE_INTER4V) {
                if (mb.mode == MPEG4Consts.MODE_INTER || mb.mode == MPEG4Consts.MODE_INTER_Q) {
                    if (ctx.interlacing && mb.fieldPred) {
                        MPEG4Bitstream.readMVInterlaced(br, ctx, mb.x, mb.y, 0, mb, fcode, mb.bound, mb, aboveMb, leftMb, aboveRightMb);
                    } else {
                        MPEG4Bitstream.readMV(br, ctx, mb.x, mb.y, 0, mb.mvs[0], fcode, mb.bound, mb, aboveMb, leftMb, aboveRightMb);
                        mb.mvs[1].x = mb.mvs[2].x = mb.mvs[3].x = mb.mvs[0].x;
                        mb.mvs[1].y = mb.mvs[2].y = mb.mvs[3].y = mb.mvs[0].y;
                    }
                } else if (mb.mode == MPEG4Consts.MODE_INTER4V) {
                    MPEG4Bitstream.readMV(br, ctx, mb.x, mb.y, 0, mb.mvs[0], fcode, mb.bound, mb, aboveMb, leftMb, aboveRightMb);
                    MPEG4Bitstream.readMV(br, ctx, mb.x, mb.y, 1, mb.mvs[1], fcode, mb.bound, mb, aboveMb, leftMb, aboveRightMb);
                    MPEG4Bitstream.readMV(br, ctx, mb.x, mb.y, 2, mb.mvs[2], fcode, mb.bound, mb, aboveMb, leftMb, aboveRightMb);
                    MPEG4Bitstream.readMV(br, ctx, mb.x, mb.y, 3, mb.mvs[3], fcode, mb.bound, mb, aboveMb, leftMb, aboveRightMb);
                }
                if (!mb.fieldPred) {
                    MPEG4Bitstream.readInterCoeffs(br, ctx, mb);
                } else {
                    MPEG4Bitstream.readInterCoeffs(br, ctx, mb);
                }
            } else {
                mb.mvs[0].x = mb.mvs[1].x = mb.mvs[2].x = mb.mvs[3].x = 0;
                mb.mvs[0].y = mb.mvs[1].y = mb.mvs[2].y = mb.mvs[3].y = 0;
                MPEG4Bitstream.readCoeffIntra(br, ctx, mb, aboveMb, leftMb, aboveLeftMb);
            }
        } else {
            mb.mode = MPEG4Consts.MODE_NOT_CODED;
            mb.quant = ctx.quant;
            mb.mvs[0].x = mb.mvs[1].x = mb.mvs[2].x = mb.mvs[3].x = 0;
            mb.mvs[0].y = mb.mvs[1].y = mb.mvs[2].y = mb.mvs[3].y = 0;
            mb.cbp = 0;
            MPEG4Bitstream.readInterCoeffs(br, ctx, mb);
        }
    };
    constructor.dequantH263Intra = function(ctx, block, quant, dcscalar) {
        var quantM2 = quant << 1;
        var quantAdd = ((quant & 1) != 0 ? quant : quant - 1);
        block[0] = ((MathUtil.clip(block[0] * dcscalar, -2048, 2047)) << 16 >> 16);
        for (var i = 1; i < 64; i++) {
            var acLevel = block[i];
            if (acLevel == 0) {
                block[i] = 0;
            } else if (acLevel < 0) {
                acLevel = quantM2 * -acLevel + quantAdd;
                block[i] = (((acLevel <= 2048 ? -acLevel : -2048)) << 16 >> 16);
            } else {
                acLevel = quantM2 * acLevel + quantAdd;
                block[i] = (((acLevel <= 2047 ? acLevel : 2047)) << 16 >> 16);
            }
        }
    };
    constructor.dequantMpegIntra = function(ctx, block, quant, dcscalar) {
        block[0] = ((MathUtil.clip(block[0] * dcscalar, -2048, 2047)) << 16 >> 16);
        for (var i = 1; i < 64; i++) {
            if (block[i] == 0) {
                block[i] = 0;
            } else if (block[i] < 0) {
                var level = ((-block[i]) * ctx.intraMpegQuantMatrix[i] * quant) >> 3;
                block[i] = (((level <= 2048 ? -((level) << 16 >> 16) : -2048)) << 16 >> 16);
            } else {
                var level = (block[i] * ctx.intraMpegQuantMatrix[i] * quant) >> 3;
                block[i] = (((level <= 2047 ? level : 2047)) << 16 >> 16);
            }
        }
    };
    constructor.readMV = function(br, ctx, x, y, k, retMV, fcode, bound, mb, aboveMb, leftMb, aboveRightMb) {
        var scaleFac = 1 << (fcode - 1);
        var high = (32 * scaleFac) - 1;
        var low = ((-32) * scaleFac);
        var range = (64 * scaleFac);
        var pmv = MPEG4Bitstream.getPMV2(ctx, bound, x, y, k, mb, aboveMb, leftMb, aboveRightMb);
        var mv = Macroblock.vec();
        mv.x = MPEG4Bitstream.readMVComponent(br, fcode);
        mv.y = MPEG4Bitstream.readMVComponent(br, fcode);
        mv.x += pmv.x;
        mv.y += pmv.y;
        if (mv.x < low) {
            mv.x += range;
        } else if (mv.x > high) {
            mv.x -= range;
        }
        if (mv.y < low) {
            mv.y += range;
        } else if (mv.y > high) {
            mv.y -= range;
        }
        retMV.x = mv.x;
        retMV.y = mv.y;
    };
    constructor.readMVInterlaced = function(br, ctx, x, y, k, pMB, fcode, bound, mb, aboveMb, leftMb, aboveRightMb) {
        var scaleFac = 1 << (fcode - 1);
        var high = (32 * scaleFac) - 1;
        var low = ((-32) * scaleFac);
        var range = (64 * scaleFac);
        var pmv = MPEG4Bitstream.getPMV2Interlaced(ctx, bound, mb, aboveMb, leftMb, aboveRightMb);
        var mv = Macroblock.vec();
        var mvf1 = Macroblock.vec();
        var mvf2 = Macroblock.vec();
        if (!pMB.fieldPred) {
            mv.x = MPEG4Bitstream.readMVComponent(br, fcode);
            mv.y = MPEG4Bitstream.readMVComponent(br, fcode);
            mv.x += pmv.x;
            mv.y += pmv.y;
            if (mv.x < low) {
                mv.x += range;
            } else if (mv.x > high) {
                mv.x -= range;
            }
            if (mv.y < low) {
                mv.y += range;
            } else if (mv.y > high) {
                mv.y -= range;
            }
            pMB.mvs[0] = pMB.mvs[1] = pMB.mvs[2] = pMB.mvs[3] = mv;
        } else {
            mvf1.x = MPEG4Bitstream.readMVComponent(br, fcode);
            mvf1.y = MPEG4Bitstream.readMVComponent(br, fcode);
            mvf1.x += pmv.x;
            mvf1.y = 2 * (mvf1.y + stjs.trunc(pmv.y / 2));
            if (mvf1.x < low) {
                mvf1.x += range;
            } else if (mvf1.x > high) {
                mvf1.x -= range;
            }
            if (mvf1.y < low) {
                mvf1.y += range;
            } else if (mvf1.y > high) {
                mvf1.y -= range;
            }
            mvf2.x = MPEG4Bitstream.readMVComponent(br, fcode);
            mvf2.y = MPEG4Bitstream.readMVComponent(br, fcode);
            mvf2.x += pmv.x;
            mvf2.y = 2 * (mvf2.y + stjs.trunc(pmv.y / 2));
            if (mvf2.x < low) {
                mvf2.x += range;
            } else if (mvf2.x > high) {
                mvf2.x -= range;
            }
            if (mvf2.y < low) {
                mvf2.y += range;
            } else if (mvf2.y > high) {
                mvf2.y -= range;
            }
            pMB.mvs[0] = mvf1;
            pMB.mvs[1] = mvf2;
            pMB.mvs[2].x = pMB.mvs[3].x = 0;
            pMB.mvs[2].y = pMB.mvs[3].y = 0;
            var n = pMB.mvs[0].x + pMB.mvs[1].x;
            pMB.mvsAvg.x = (((n) >> 1) | ((n) & 1));
            n = pMB.mvs[0].y + pMB.mvs[1].y;
            pMB.mvsAvg.y = (((n) >> 1) | ((n) & 1));
        }
    };
    constructor.getPMV2Interlaced = function(ctx, bound, mb, aboveMb, leftMb, aboveRightMb) {
        var num_cand = 0, last_cand = 1;
        var pmv = Array(4);
        for (var i = 0; i < 4; i++) {
            pmv[i] = Macroblock.vec();
        }
        var lz = 1;
        var tz = 2;
        var rz = 2;
        if (leftMb != null) {
            num_cand++;
            if (leftMb.fieldPred) {
                pmv[1] = leftMb.mvsAvg;
            } else {
                pmv[1] = leftMb.mvs[lz];
            }
        } else {
            pmv[1] = MPEG4Consts.ZERO_MV;
        }
        if (aboveMb != null) {
            num_cand++;
            last_cand = 2;
            if (aboveMb.fieldPred) {
                pmv[2] = aboveMb.mvsAvg;
            } else {
                pmv[2] = aboveMb.mvs[tz];
            }
        } else {
            pmv[2] = MPEG4Consts.ZERO_MV;
        }
        if (aboveRightMb != null) {
            num_cand++;
            last_cand = 3;
            if (aboveRightMb.fieldPred) {
                pmv[3] = aboveRightMb.mvsAvg;
            } else {
                pmv[3] = aboveRightMb.mvs[rz];
            }
        } else {
            pmv[3] = MPEG4Consts.ZERO_MV;
        }
        if (num_cand > 1) {
            pmv[0].x = Math.min(Math.max(pmv[1].x, pmv[2].x), (Math.min(Math.max(pmv[2].x, pmv[3].x), Math.max(pmv[1].x, pmv[3].x))));
            pmv[0].y = Math.min(Math.max(pmv[1].y, pmv[2].y), (Math.min(Math.max(pmv[2].y, pmv[3].y), Math.max(pmv[1].y, pmv[3].y))));
            return pmv[0];
        }
        return pmv[last_cand];
    };
    constructor.getDCScaler = function(quant, lum) {
        if (quant < 5) 
            return 8;
        if (quant < 25 && !lum) 
            return stjs.trunc((quant + 13) / 2);
        if (quant < 9) 
            return 2 * quant;
        if (quant < 25) 
            return quant + 8;
        if (lum) 
            return 2 * quant - 16;
        return quant - 6;
    };
    constructor.predictAcdc = function(ctx, x, y, block, currentQuant, iDcScaler, predictors, bound, mb, aboveMb, leftMb, aboveLeftMb) {
        var mbpos = (y * ctx.mbWidth) + x;
        var leftPred = null, topPred = null, diag = null, current = null;
        var leftQuant = currentQuant;
        var topQuant = currentQuant;
        var pLeft = MPEG4Consts.DEFAULT_ACDC_VALUES;
        var pTop = MPEG4Consts.DEFAULT_ACDC_VALUES;
        var pDiag = MPEG4Consts.DEFAULT_ACDC_VALUES;
        if (x != 0 && mbpos >= bound + 1 && (leftMb.mode == MPEG4Consts.MODE_INTRA || leftMb.mode == MPEG4Consts.MODE_INTRA_Q)) {
            leftPred = leftMb.predValues[0];
            leftQuant = leftMb.quant;
        }
        if (mbpos >= bound + ctx.mbWidth && (aboveMb.mode == MPEG4Consts.MODE_INTRA || aboveMb.mode == MPEG4Consts.MODE_INTRA_Q)) {
            topPred = aboveMb.predValues[0];
            topQuant = aboveMb.quant;
        }
        if (x != 0 && mbpos >= bound + ctx.mbWidth + 1 && (aboveLeftMb.mode == MPEG4Consts.MODE_INTRA || aboveLeftMb.mode == MPEG4Consts.MODE_INTRA_Q)) {
            diag = aboveLeftMb.predValues[0];
        }
        current = mb.predValues[0];
        switch (block) {
            case 0:
                if (leftPred != null) 
                    pLeft = leftMb.predValues[1];
                if (topPred != null) 
                    pTop = aboveMb.predValues[2];
                if (diag != null) 
                    pDiag = aboveLeftMb.predValues[3];
                break;
            case 1:
                pLeft = current;
                leftQuant = currentQuant;
                if (topPred != null) {
                    pTop = aboveMb.predValues[3];
                    pDiag = aboveMb.predValues[2];
                }
                break;
            case 2:
                if (leftPred != null) {
                    pLeft = leftMb.predValues[3];
                    pDiag = leftMb.predValues[1];
                }
                pTop = current;
                topQuant = currentQuant;
                break;
            case 3:
                pLeft = mb.predValues[2];
                leftQuant = currentQuant;
                pTop = mb.predValues[1];
                topQuant = currentQuant;
                pDiag = current;
                break;
            case 4:
                if (leftPred != null) 
                    pLeft = leftMb.predValues[4];
                if (topPred != null) 
                    pTop = aboveMb.predValues[4];
                if (diag != null) 
                    pDiag = aboveLeftMb.predValues[4];
                break;
            case 5:
                if (leftPred != null) 
                    pLeft = leftMb.predValues[5];
                if (topPred != null) 
                    pTop = aboveMb.predValues[5];
                if (diag != null) 
                    pDiag = aboveLeftMb.predValues[5];
                break;
        }
        if (MathUtil.abs(pLeft[0] - pDiag[0]) < MathUtil.abs(pDiag[0] - pTop[0])) {
            mb.acpredDirections[block] = 1;
            predictors[0] = (((pTop[0] > 0 ? (stjs.trunc((pTop[0] + (iDcScaler >>> 1)) / iDcScaler)) : (stjs.trunc((pTop[0] - (iDcScaler >>> 1)) / iDcScaler)))) << 16 >> 16);
            for (var i = 1; i < 8; i++) {
                var a = pTop[i] * topQuant;
                predictors[i] = (pTop[i] != 0 ? (((a > 0 ? (stjs.trunc((a + (currentQuant >>> 1)) / currentQuant)) : (stjs.trunc((a - (currentQuant >>> 1)) / currentQuant)))) << 16 >> 16) : 0);
            }
        } else {
            mb.acpredDirections[block] = 2;
            predictors[0] = (((pLeft[0] > 0 ? (stjs.trunc((pLeft[0] + (iDcScaler >>> 1)) / iDcScaler)) : (stjs.trunc((pLeft[0] - (iDcScaler >>> 1)) / iDcScaler)))) << 16 >> 16);
            for (var i = 1; i < 8; i++) {
                var a = pLeft[i + 7] * leftQuant;
                predictors[i] = (pLeft[i + 7] != 0 ? (((a > 0 ? (stjs.trunc((a + (currentQuant >>> 1)) / currentQuant)) : (stjs.trunc((a - (currentQuant >>> 1)) / currentQuant)))) << 16 >> 16) : 0);
            }
        }
    };
    constructor.getPMV2 = function(ctx, bound, x, y, block, mb, aboveMb, leftMb, aboveRightMb) {
        var num_cand = 0, last_cand = 1;
        var pmv = Array(4);
        for (var i = 0; i < 4; i++) {
            pmv[i] = Macroblock.vec();
        }
        var lz, tz, rz;
        switch (block) {
            case 0:
                lz = 1;
                tz = 2;
                rz = 2;
                break;
            case 1:
                leftMb = mb;
                lz = 0;
                tz = 3;
                rz = 2;
                break;
            case 2:
                aboveMb = mb;
                aboveRightMb = mb;
                lz = 3;
                tz = 0;
                rz = 1;
                break;
            default:
                leftMb = mb;
                aboveMb = mb;
                aboveRightMb = mb;
                lz = 2;
                tz = 0;
                rz = 1;
        }
        if (leftMb != null) {
            num_cand++;
            pmv[1] = leftMb.mvs[lz];
        } else {
            pmv[1] = MPEG4Consts.ZERO_MV;
        }
        if (aboveMb != null) {
            num_cand++;
            last_cand = 2;
            pmv[2] = aboveMb.mvs[tz];
        } else {
            pmv[2] = MPEG4Consts.ZERO_MV;
        }
        if (aboveRightMb != null) {
            num_cand++;
            last_cand = 3;
            pmv[3] = aboveRightMb.mvs[rz];
        } else {
            pmv[3] = MPEG4Consts.ZERO_MV;
        }
        if (num_cand > 1) {
            pmv[0].x = MPEG4Bitstream.selectCand(pmv[1].x, pmv[2].x, pmv[3].x);
            pmv[0].y = MPEG4Bitstream.selectCand(pmv[1].y, pmv[2].y, pmv[3].y);
            return pmv[0];
        }
        return pmv[last_cand];
    };
    constructor.selectCand = function(p1x, p2x, p3x) {
        var neg12x = MPEG4Bitstream.neg(p1x - p2x);
        var neg13x = MPEG4Bitstream.neg(p1x - p3x);
        var neg23x = MPEG4Bitstream.neg(p2x - p3x);
        var neg1x = MPEG4Bitstream.neg(p1x - p2x + neg23x - neg13x);
        var neg2x = MPEG4Bitstream.neg(p2x - p1x + neg1x + neg12x - neg23x);
        return p1x - neg12x + neg2x;
    };
    constructor.neg = function(v) {
        return v < 0 ? v : 0;
    };
    constructor.readBi = function(br, ctx, fcodeForward, fcodeBackward, mb, lastMB, pFMV, pBMV) {
        if (!br.readBool()) {
            var modb2 = br.readBool();
            mb.mode = MPEG4Bitstream.readMBType(br);
            if (!modb2) {
                mb.cbp = br.readNBit(6);
            } else {
                mb.cbp = 0;
            }
            if (mb.mode != 0 && mb.cbp != 0) {
                mb.quant += MPEG4Bitstream.readDBQuant(br);
                if (mb.quant > 31) 
                    mb.quant = 31;
                 else if (mb.quant < 1) 
                    mb.quant = 1;
            }
            if (ctx.interlacing) {
                if (mb.cbp != 0) {
                    mb.fieldDCT = br.readBool();
                }
                if (mb.mode != 0) {
                    mb.fieldPred = br.readBool();
                    if (mb.fieldPred) {
                        mb.fieldForTop = br.readBool();
                        mb.fieldForBottom = br.readBool();
                    }
                }
            }
        } else {
            mb.mode = MPEG4Consts.MODE_DIRECT_NONE_MV;
            mb.cbp = 0;
        }
        var mv = Macroblock.vec();
        switch (mb.mode) {
            case MPEG4Consts.MODE_DIRECT:
                MPEG4Bitstream.getBMotionVector(br, mv, 1, MPEG4Consts.ZERO_MV, mb.x, mb.y);
            case MPEG4Consts.MODE_DIRECT_NONE_MV:
                for (var i = 0; i < 4; i++) {
                    mb.mvs[i].x = stjs.trunc(lastMB.mvs[i].x * ctx.bframeTs / ctx.pframeTs) + mv.x;
                    mb.mvs[i].y = stjs.trunc(lastMB.mvs[i].y * ctx.bframeTs / ctx.pframeTs) + mv.y;
                    mb.bmvs[i].x = (mv.x != 0) ? mb.mvs[i].x - lastMB.mvs[i].x : stjs.trunc(lastMB.mvs[i].x * (ctx.bframeTs - ctx.pframeTs) / ctx.pframeTs);
                    mb.bmvs[i].y = (mv.y != 0) ? mb.mvs[i].y - lastMB.mvs[i].y : stjs.trunc(lastMB.mvs[i].y * (ctx.bframeTs - ctx.pframeTs) / ctx.pframeTs);
                }
                MPEG4Bitstream.readInterCoeffs(br, ctx, mb);
                break;
            case MPEG4Consts.MODE_INTERPOLATE:
                MPEG4Bitstream.getBMotionVector(br, mb.mvs[0], fcodeForward, pFMV, mb.x, mb.y);
                pFMV.x = mb.mvs[1].x = mb.mvs[2].x = mb.mvs[3].x = mb.mvs[0].x;
                pFMV.y = mb.mvs[1].y = mb.mvs[2].y = mb.mvs[3].y = mb.mvs[0].y;
                MPEG4Bitstream.getBMotionVector(br, mb.bmvs[0], fcodeBackward, pBMV, mb.x, mb.y);
                pBMV.x = mb.bmvs[1].x = mb.bmvs[2].x = mb.bmvs[3].x = mb.bmvs[0].x;
                pBMV.y = mb.bmvs[1].y = mb.bmvs[2].y = mb.bmvs[3].y = mb.bmvs[0].y;
                MPEG4Bitstream.readInterCoeffs(br, ctx, mb);
                break;
            case MPEG4Consts.MODE_BACKWARD:
                MPEG4Bitstream.getBMotionVector(br, mb.mvs[0], fcodeBackward, pBMV, mb.x, mb.y);
                pBMV.x = mb.mvs[1].x = mb.mvs[2].x = mb.mvs[3].x = mb.mvs[0].x;
                pBMV.y = mb.mvs[1].y = mb.mvs[2].y = mb.mvs[3].y = mb.mvs[0].y;
                MPEG4Bitstream.readInterCoeffs(br, ctx, mb);
                break;
            case MPEG4Consts.MODE_FORWARD:
                MPEG4Bitstream.getBMotionVector(br, mb.mvs[0], fcodeForward, pFMV, mb.x, mb.y);
                pFMV.x = mb.mvs[1].x = mb.mvs[2].x = mb.mvs[3].x = mb.mvs[0].x;
                pFMV.y = mb.mvs[1].y = mb.mvs[2].y = mb.mvs[3].y = mb.mvs[0].y;
                MPEG4Bitstream.readInterCoeffs(br, ctx, mb);
                break;
            default:
        }
    };
    constructor.getBMotionVector = function(br, mv, fcode, pmv, x, y) {
        var scaleFac = 1 << (fcode - 1);
        var high = (32 * scaleFac) - 1;
        var low = ((-32) * scaleFac);
        var range = (64 * scaleFac);
        var mvX = MPEG4Bitstream.readMVComponent(br, fcode);
        var mvY = MPEG4Bitstream.readMVComponent(br, fcode);
        mvX += pmv.x;
        mvY += pmv.y;
        if (mvX < low) 
            mvX += range;
         else if (mvX > high) 
            mvX -= range;
        if (mvY < low) 
            mvY += range;
         else if (mvY > high) 
            mvY -= range;
        mv.x = mvX;
        mv.y = mvY;
    };
    constructor.readInterCoeffs = function(br, ctx, mb) {
        var iQuant = mb.quant;
        var direction = ctx.alternateVerticalScan ? 2 : 0;
        for (var i = 0; i < 6; i++) {
            var block = mb.block[i];
            Arrays.fill(block, (0 << 24 >> 24));
            if ((mb.cbp & (1 << (5 - i))) != 0) {
                if (ctx.quantType) {
                    MPEG4Bitstream.readInterBlockMPEG(br, block, direction, iQuant, ctx.interMpegQuantMatrix);
                } else {
                    MPEG4Bitstream.readInterBlockH263(br, block, direction, iQuant);
                }
            }
        }
    };
}, {DQUANT_TABLE: "Int32Array", vlcTab: "Array"}, {});
(function() {
    MPEG4Bitstream.initVLCTables();
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A demuxer that reads image files out of a folder.
 *  
 *  Supports both sequences starting with 0 and 1 index.
 *  
 *  @author Stanislav Vitvitskyy
 *  
 */
var ImageSequenceDemuxer = function(namePattern, maxFrames) {
    this.namePattern = namePattern;
    this.maxFrames = maxFrames;
    this.maxAvailableFrame = -1;
    this.curFrame = this.loadFrame();
    var lowerCase = namePattern.toLowerCase();
    if (lowerCase.endsWith(".png")) {
        this.codec = Codec.PNG;
    } else if (lowerCase.endsWith(".jpg") || lowerCase.endsWith(".jpeg")) {
        this.codec = Codec.JPEG;
    }
};
ImageSequenceDemuxer = stjs.extend(ImageSequenceDemuxer, null, [Demuxer, DemuxerTrack], function(constructor, prototype) {
    constructor.VIDEO_FPS = 25;
    prototype.namePattern = null;
    prototype.frameNo = 0;
    prototype.curFrame = null;
    prototype.codec = null;
    prototype.maxAvailableFrame = 0;
    prototype.maxFrames = 0;
    prototype.prevName = null;
    prototype.close = function() {};
    prototype.getTracks = function() {
        var tracks = new ArrayList();
        tracks.add(this);
        return tracks;
    };
    prototype.getVideoTracks = function() {
        return this.getTracks();
    };
    prototype.getAudioTracks = function() {
        return new ArrayList();
    };
    prototype.nextFrame = function() {
        try {
            return this.curFrame;
        } finally {
            this.curFrame = this.loadFrame();
        }
    };
    prototype.loadFrame = function() {
        if (this.frameNo > this.maxFrames) {
            return null;
        }
        var file = null;
        do {
            var name = String.format(this.namePattern, this.frameNo);
            if (name.equals(this.prevName)) {
                return null;
            }
            this.prevName = name;
            file = new File(name);
            if (file.exists() || this.frameNo > 0) 
                break;
            this.frameNo++;
        } while (this.frameNo < 2);
        if (file == null || !file.exists()) 
            return null;
        var ret = new Packet(NIOUtils.fetchFromFile(file), this.frameNo, ImageSequenceDemuxer.VIDEO_FPS, 1, this.frameNo, Packet.FrameType.KEY, null, this.frameNo);
        ++this.frameNo;
        return ret;
    };
    constructor.MAX_MAX = 60 * 60 * 60 * 24;
    /**
     *  Finds maximum frame of a sequence by bisecting the range.
     *  
     *  Performs at max at max 48 Stat calls ( 2*log2(MAX_MAX) ).
     *  
     *  @return
     */
    prototype.getMaxAvailableFrame = function() {
        if (this.maxAvailableFrame == -1) {
            var firstPoint = 0;
            for (var i = ImageSequenceDemuxer.MAX_MAX; i > 0; i = stjs.trunc(i / (2))) {
                if (new File(String.format(this.namePattern, i)).exists()) {
                    firstPoint = i;
                    break;
                }
            }
            var pos = firstPoint;
            for (var interv = stjs.trunc(firstPoint / 2); interv > 1; interv = stjs.trunc(interv / (2))) {
                if (new File(String.format(this.namePattern, pos + interv)).exists()) {
                    pos += interv;
                }
            }
            this.maxAvailableFrame = pos;
            Logger.info("Max frame found: " + this.maxAvailableFrame);
        }
        return Math.min(this.maxAvailableFrame, this.maxFrames);
    };
    prototype.getMeta = function() {
        var durationFrames = this.getMaxAvailableFrame();
        return new DemuxerTrackMeta(TrackType.VIDEO, this.codec, (durationFrames + 1) * ImageSequenceDemuxer.VIDEO_FPS, null, durationFrames + 1, null, null, null);
    };
}, {curFrame: "Packet", codec: "Codec"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  FLV ( Flash Media Video ) demuxer
 *  
 *  @author Stan Vitvitskyy
 *  
 */
var FLVReader = function(ch) {
    this.ch = ch;
    this.readBuf = ByteBuffer.allocate(FLVReader.READ_BUFFER_SIZE);
    this.readBuf.order(ByteOrder.BIG_ENDIAN);
    this.initialRead(ch);
    if (!FLVReader.readHeader(this.readBuf)) {
        this.readBuf.setPosition(0);
        if (!this.repositionFile()) 
             throw new RuntimeException("Invalid FLV file");
         else {
            Logger.warn(String.format("Parsing a corrupt FLV file, first tag found at %d. %s", this.readBuf.position(), this.readBuf.position() == 0 ? "Did you forget the FLV 9-byte header?" : ""));
        }
    }
};
FLVReader = stjs.extend(FLVReader, null, [], function(constructor, prototype) {
    constructor.REPOSITION_BUFFER_READS = 10;
    constructor.TAG_HEADER_SIZE = 15;
    constructor.READ_BUFFER_SIZE = 1 << 10;
    prototype.frameNo = 0;
    prototype.readBuf = null;
    prototype.ch = null;
    prototype.eof = false;
    constructor.platformBigEndian = ByteBuffer.allocate(0).getOrder() == ByteOrder.BIG_ENDIAN;
    constructor.audioCodecMapping = [Codec.PCM, Codec.ADPCM, Codec.MP3, Codec.PCM, Codec.NELLYMOSER, Codec.NELLYMOSER, Codec.NELLYMOSER, Codec.G711, Codec.G711, null, Codec.AAC, Codec.SPEEX, Codec.MP3, null];
    constructor.videoCodecMapping = [null, null, Codec.SORENSON, Codec.FLASH_SCREEN_VIDEO, Codec.VP6, Codec.VP6, Codec.FLASH_SCREEN_V2, Codec.H264];
    constructor.sampleRates = new Int32Array([5500, 11000, 22000, 44100]);
    prototype.initialRead = function(ch) {
        this.readBuf.clear();
        if (ch.read(this.readBuf) == -1) 
            this.eof = true;
        this.readBuf.flip();
    };
    prototype.readNextPacket = function() {
        if (this.eof) 
            return null;
        var pkt = this.parsePacket(this.readBuf);
        if (pkt == null && !this.eof) {
            FLVReader.moveRemainderToTheStart(this.readBuf);
            if (this.ch.read(this.readBuf) == -1) {
                this.eof = true;
                return null;
            }
             while (MathUtil.log2(this.readBuf.capacity()) <= 22){
                this.readBuf.flip();
                pkt = this.parsePacket(this.readBuf);
                if (pkt != null || this.readBuf.position() > 0) 
                    break;
                var newBuf = ByteBuffer.allocate(this.readBuf.capacity() << 2);
                newBuf.putBuf(this.readBuf);
                this.readBuf = newBuf;
                if (this.ch.read(this.readBuf) == -1) {
                    this.eof = true;
                    return null;
                }
            }
        }
        return pkt;
    };
    prototype.readPrevPacket = function() {
        var startOfLastPacket = this.readBuf.getInt();
        this.readBuf.setPosition(this.readBuf.position() - 4);
        if (this.readBuf.position() > startOfLastPacket) {
            this.readBuf.setPosition(this.readBuf.position() - startOfLastPacket);
            return this.parsePacket(this.readBuf);
        } else {
            var oldPos = this.ch.position() - this.readBuf.remaining();
            if (oldPos <= 9) {
                return null;
            }
            var newPos = Math.max(0, oldPos - stjs.trunc(this.readBuf.capacity() / 2));
            this.ch.setPosition(newPos);
            this.readBuf.clear();
            this.ch.read(this.readBuf);
            this.readBuf.flip();
            this.readBuf.setPosition((((oldPos - newPos)) | 0));
            return this.readPrevPacket();
        }
    };
    constructor.moveRemainderToTheStart = function(readBuf) {
        var rem = readBuf.remaining();
        for (var i = 0; i < rem; i++) {
            readBuf.putAt(i, readBuf.get());
        }
        readBuf.clear();
        readBuf.setPosition(rem);
    };
    prototype.parsePacket = function(readBuf) {
        for (; ; ) {
            if (readBuf.remaining() < FLVReader.TAG_HEADER_SIZE) {
                return null;
            }
            var pos = readBuf.position();
            var packetPos = this.ch.position() - readBuf.remaining();
            var prevPacketSize = readBuf.getInt();
            var packetType = readBuf.get() & 255;
            var payloadSize = ((readBuf.getShort() & 65535) << 8) | (readBuf.get() & 255);
            var timestamp = ((readBuf.getShort() & 65535) << 8) | (readBuf.get() & 255) | ((readBuf.get() & 255) << 24);
            var streamId = ((readBuf.getShort() & 65535) << 8) | (readBuf.get() & 255);
            if (readBuf.remaining() >= payloadSize + 4) {
                var thisPacketSize = readBuf.getIntAt(readBuf.position() + payloadSize);
                if (thisPacketSize != payloadSize + 11) {
                    readBuf.setPosition(readBuf.position() - FLVReader.TAG_HEADER_SIZE);
                    if (!this.repositionFile()) {
                        Logger.error(String.format("Corrupt FLV stream at %d, failed to reposition!", packetPos));
                        this.ch.setPosition(this.ch.size());
                        this.eof = true;
                        return null;
                    }
                    Logger.warn(String.format("Corrupt FLV stream at %d, repositioned to %d.", packetPos, this.ch.position() - readBuf.remaining()));
                    continue;
                }
            }
            if (readBuf.remaining() < payloadSize) {
                readBuf.setPosition(pos);
                return null;
            }
            if (packetType != 8 && packetType != 9 && packetType != 18) {
                NIOUtils.skip(readBuf, payloadSize);
                continue;
            }
            var payload = NIOUtils.clone(NIOUtils.read(readBuf, payloadSize));
            var type;
            var tagHeader;
            if (packetType == 8) {
                type = FLVTag.Type.AUDIO;
                tagHeader = FLVReader.parseAudioTagHeader(payload.duplicate());
            } else if (packetType == 9) {
                type = FLVTag.Type.VIDEO;
                tagHeader = FLVReader.parseVideoTagHeader(payload.duplicate());
            } else if (packetType == 18) {
                type = FLVTag.Type.SCRIPT;
                tagHeader = null;
            } else {
                System.out.println("NON AV packet");
                continue;
            }
            var keyFrame = false;
            if (tagHeader != null && stjs.isInstanceOf(tagHeader.constructor, FLVTag.VideoTagHeader)) {
                var vth = tagHeader;
                keyFrame &= vth.getFrameType() == 1;
            }
            keyFrame &= packetType == 8 || packetType == 9;
            return new FLVTag(type, packetPos, tagHeader, timestamp, payload, keyFrame, this.frameNo++, streamId, prevPacketSize);
        }
    };
    constructor.readHeader = function(readBuf) {
        if (readBuf.remaining() < 9 || readBuf.get() != 'F'.charCodeAt(0) || readBuf.get() != 'L'.charCodeAt(0) || readBuf.get() != 'V'.charCodeAt(0) || readBuf.get() != 1 || (readBuf.get() & 5) == 0 || readBuf.getInt() != 9) {
            return false;
        }
        return true;
    };
    constructor.parseMetadata = function(bb) {
        if ("onMetaData".equals(FLVReader.readAMFData(bb, -1))) 
            return new FLVMetadata(FLVReader.readAMFData(bb, -1));
        return null;
    };
    constructor.readAMFData = function(input, type) {
        if (type == -1) {
            type = input.get() & 255;
        }
        switch (type) {
            case 0:
                return input.getDouble();
            case 1:
                return input.get() == 1;
            case 2:
                return FLVReader.readAMFString(input);
            case 3:
                return FLVReader.readAMFObject(input);
            case 8:
                return FLVReader.readAMFEcmaArray(input);
            case 10:
                return FLVReader.readAMFStrictArray(input);
            case 11:
                var date = new jsutil.Date(stjs.trunc(input.getDouble()));
                input.getShort();
                return date;
            case 13:
                return "UNDEFINED";
            default:
                return null;
        }
    };
    constructor.readAMFStrictArray = function(input) {
        var count = input.getInt();
        var result = Array(count);
        for (var i = 0; i < count; i++) {
            result[i] = FLVReader.readAMFData(input, -1);
        }
        return result;
    };
    constructor.readAMFString = function(input) {
        var size = input.getShort() & 65535;
        return Platform.stringFromCharset(NIOUtils.toArray(NIOUtils.read(input, size)), Platform.UTF_8);
    };
    constructor.readAMFObject = function(input) {
        var array = new HashMap();
         while (true){
            var key = FLVReader.readAMFString(input);
            var dataType = input.get() & 255;
            if (dataType == 9) {
                break;
            }
            array.put(key, FLVReader.readAMFData(input, dataType));
        }
        return array;
    };
    constructor.readAMFEcmaArray = function(input) {
        var size = input.getInt();
        var array = new HashMap();
        for (var i = 0; i < size; i++) {
            var key = FLVReader.readAMFString(input);
            var dataType = input.get() & 255;
            array.put(key, FLVReader.readAMFData(input, dataType));
        }
        return array;
    };
    constructor.parseVideoTagHeader = function(dup) {
        var b0 = dup.get();
        var frameType = (b0 & 255) >> 4;
        var codecId = (b0 & 15);
        var codec = FLVReader.videoCodecMapping[codecId];
        if (codecId == 7) {
            var avcPacketType = dup.get();
            var compOffset = (dup.getShort() << 8) | (dup.get() & 255);
            return new FLVTag.AvcVideoTagHeader(codec, frameType, avcPacketType, compOffset);
        }
        return new FLVTag.VideoTagHeader(codec, frameType);
    };
    constructor.parseAudioTagHeader = function(dup) {
        var b = dup.get();
        var codecId = (b & 255) >> 4;
        var sampleRate = FLVReader.sampleRates[(b >> 2) & 3];
        if (codecId == 4 || codecId == 11) 
            sampleRate = 16000;
        if (codecId == 5 || codecId == 14) 
            sampleRate = 8000;
        var sampleSizeInBits = (b & 2) == 0 ? 8 : 16;
        var signed = codecId != 3 && codecId != 0 || sampleSizeInBits == 16;
        var channelCount = 1 + (b & 1);
        if (codecId == 11) 
            channelCount = 1;
        var audioFormat = new AudioFormat(sampleRate, sampleSizeInBits, channelCount, signed, codecId == 3 ? false : FLVReader.platformBigEndian);
        var codec = FLVReader.audioCodecMapping[codecId];
        if (codecId == 10) {
            var packetType = dup.get();
            return new FLVTag.AacAudioTagHeader(codec, audioFormat, packetType);
        }
        return new FLVTag.AudioTagHeader(codec, audioFormat);
    };
    constructor.probe = function(buf) {
        try {
            FLVReader.readHeader(buf);
            return 100;
        }catch (e) {
            return 0;
        }
    };
    prototype.reset = function() {
        this.initialRead(this.ch);
    };
    prototype.reposition = function() {
        this.reset();
        if (!FLVReader.positionAtPacket(this.readBuf)) {
             throw new RuntimeException("Could not find at FLV tag start");
        }
    };
    constructor.positionAtPacket = function(readBuf) {
        var dup = readBuf.duplicate();
        var payloadSize = 0;
        NIOUtils.skip(dup, 5);
         while (dup.hasRemaining()){
            payloadSize = ((payloadSize & 65535) << 8) | (dup.get() & 255);
            var pointerPos = dup.position() + 7 + payloadSize;
            if (dup.position() >= 8 && pointerPos < dup.limit() - 4 && dup.getIntAt(pointerPos) - payloadSize == 11) {
                readBuf.setPosition(dup.position() - 8);
                return true;
            }
        }
        return false;
    };
    /**
     *  Searching for the next tag in a file after corrupt segment
     *  
     *  @return
     *  @throws IOException
     */
    prototype.repositionFile = function() {
        var payloadSize = 0;
        for (var i = 0; i < FLVReader.REPOSITION_BUFFER_READS; i++) {
             while (this.readBuf.hasRemaining()){
                payloadSize = ((payloadSize & 65535) << 8) | (this.readBuf.get() & 255);
                var pointerPos = this.readBuf.position() + 7 + payloadSize;
                if (this.readBuf.position() >= 8 && pointerPos < this.readBuf.limit() - 4 && this.readBuf.getIntAt(pointerPos) - payloadSize == 11) {
                    this.readBuf.setPosition(this.readBuf.position() - 8);
                    return true;
                }
            }
            this.initialRead(this.ch);
            if (!this.readBuf.hasRemaining()) 
                break;
        }
        return false;
    };
}, {readBuf: "ByteBuffer", ch: "SeekableByteChannel", audioCodecMapping: "Array", videoCodecMapping: "Array", sampleRates: "Int32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var PCE = function() {
    Element.call(this);
    this.frontElements = Array(PCE.MAX_FRONT_CHANNEL_ELEMENTS);
    this.sideElements = Array(PCE.MAX_SIDE_CHANNEL_ELEMENTS);
    this.backElements = Array(PCE.MAX_BACK_CHANNEL_ELEMENTS);
    this.lfeElementTags = new Int32Array(PCE.MAX_LFE_CHANNEL_ELEMENTS);
    this.assocDataElementTags = new Int32Array(PCE.MAX_ASSOC_DATA_ELEMENTS);
    this.ccElements = Array(PCE.MAX_VALID_CC_ELEMENTS);
    this.sampleFrequency = SampleFrequency.SAMPLE_FREQUENCY_NONE;
};
PCE = stjs.extend(PCE, Element, [], function(constructor, prototype) {
    constructor.MAX_FRONT_CHANNEL_ELEMENTS = 16;
    constructor.MAX_SIDE_CHANNEL_ELEMENTS = 16;
    constructor.MAX_BACK_CHANNEL_ELEMENTS = 16;
    constructor.MAX_LFE_CHANNEL_ELEMENTS = 4;
    constructor.MAX_ASSOC_DATA_ELEMENTS = 8;
    constructor.MAX_VALID_CC_ELEMENTS = 16;
    constructor.TaggedElement = function(isCPE, tag) {
        this.isCPE = isCPE;
        this.tag = tag;
    };
    constructor.TaggedElement = stjs.extend(constructor.TaggedElement, null, [], function(constructor, prototype) {
        prototype.isCPE = false;
        prototype.tag = 0;
        prototype.isIsCPE = function() {
            return this.isCPE;
        };
        prototype.getTag = function() {
            return this.tag;
        };
    }, {}, {});
    constructor.CCE = function(isIndSW, tag) {
        this.isIndSW = isIndSW;
        this.tag = tag;
    };
    constructor.CCE = stjs.extend(constructor.CCE, null, [], function(constructor, prototype) {
        prototype.isIndSW = false;
        prototype.tag = 0;
        prototype.isIsIndSW = function() {
            return this.isIndSW;
        };
        prototype.getTag = function() {
            return this.tag;
        };
    }, {}, {});
    prototype.profile = null;
    prototype.sampleFrequency = null;
    prototype.frontChannelElementsCount = 0;
    prototype.sideChannelElementsCount = 0;
    prototype.backChannelElementsCount = 0;
    prototype.lfeChannelElementsCount = 0;
    prototype.assocDataElementsCount = 0;
    prototype.validCCElementsCount = 0;
    prototype.monoMixdown = false;
    prototype.stereoMixdown = false;
    prototype.matrixMixdownIDXPresent = false;
    prototype.monoMixdownElementNumber = 0;
    prototype.stereoMixdownElementNumber = 0;
    prototype.matrixMixdownIDX = 0;
    prototype.pseudoSurround = false;
    prototype.frontElements = null;
    prototype.sideElements = null;
    prototype.backElements = null;
    prototype.lfeElementTags = null;
    prototype.assocDataElementTags = null;
    prototype.ccElements = null;
    prototype.commentFieldData = null;
    prototype.decode = function(_in) {
        this.readElementInstanceTag(_in);
        this.profile = Profile.forInt(_in.readBits(2));
        this.sampleFrequency = SampleFrequency.forInt(_in.readBits(4));
        this.frontChannelElementsCount = _in.readBits(4);
        this.sideChannelElementsCount = _in.readBits(4);
        this.backChannelElementsCount = _in.readBits(4);
        this.lfeChannelElementsCount = _in.readBits(2);
        this.assocDataElementsCount = _in.readBits(3);
        this.validCCElementsCount = _in.readBits(4);
        if (this.monoMixdown = _in.readBool()) {
            Logger.warn("mono mixdown present, but not yet supported");
            this.monoMixdownElementNumber = _in.readBits(4);
        }
        if (this.stereoMixdown = _in.readBool()) {
            Logger.warn("stereo mixdown present, but not yet supported");
            this.stereoMixdownElementNumber = _in.readBits(4);
        }
        if (this.matrixMixdownIDXPresent = _in.readBool()) {
            Logger.warn("matrix mixdown present, but not yet supported");
            this.matrixMixdownIDX = _in.readBits(2);
            this.pseudoSurround = _in.readBool();
        }
        this.readTaggedElementArray(this.frontElements, _in, this.frontChannelElementsCount);
        this.readTaggedElementArray(this.sideElements, _in, this.sideChannelElementsCount);
        this.readTaggedElementArray(this.backElements, _in, this.backChannelElementsCount);
        var i;
        for (i = 0; i < this.lfeChannelElementsCount; ++i) {
            this.lfeElementTags[i] = _in.readBits(4);
        }
        for (i = 0; i < this.assocDataElementsCount; ++i) {
            this.assocDataElementTags[i] = _in.readBits(4);
        }
        for (i = 0; i < this.validCCElementsCount; ++i) {
            this.ccElements[i] = new PCE.CCE(_in.readBool(), _in.readBits(4));
        }
        _in.byteAlign();
        var commentFieldBytes = _in.readBits(8);
        this.commentFieldData = new Int8Array(commentFieldBytes);
        for (i = 0; i < commentFieldBytes; i++) {
            this.commentFieldData[i] = (_in.readBits(8) << 24 >> 24);
        }
    };
    prototype.readTaggedElementArray = function(te, _in, len) {
        for (var i = 0; i < len; ++i) {
            te[i] = new PCE.TaggedElement(_in.readBool(), _in.readBits(4));
        }
    };
    prototype.getProfile = function() {
        return this.profile;
    };
    prototype.getSampleFrequency = function() {
        return this.sampleFrequency;
    };
    prototype.getChannelCount = function() {
        return this.frontChannelElementsCount + this.sideChannelElementsCount + this.backChannelElementsCount + this.lfeChannelElementsCount + this.assocDataElementsCount;
    };
}, {profile: "Profile", sampleFrequency: "SampleFrequency", frontElements: "Array", sideElements: "Array", backElements: "Array", lfeElementTags: "Int32Array", assocDataElementTags: "Int32Array", ccElements: "Array", commentFieldData: "Int8Array", sbr: "SBR"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Color transform filter.
 *  
 *  @author Stanislav Vitvitskyy
 */
var ColorTransformFilter = function(outputColor) {
    this.outputColor = outputColor;
};
ColorTransformFilter = stjs.extend(ColorTransformFilter, null, [Filter], function(constructor, prototype) {
    prototype.transform = null;
    prototype.outputColor = null;
    prototype.filter = function(picture, store) {
        if (this.transform == null) {
            this.transform = ColorUtil.getTransform(picture.getColor(), this.outputColor);
            Logger.debug("Creating transform: " + this.transform);
        }
        var outFrame = store.getPicture(picture.getWidth(), picture.getHeight(), this.outputColor);
        outFrame.getPicture().setCrop(picture.getCrop());
        this.transform.transform(picture, outFrame.getPicture());
        return outFrame;
    };
    prototype.getInputColor = function() {
        return ColorSpace.ANY_PLANAR;
    };
    prototype.getOutputColor = function() {
        return this.outputColor;
    };
}, {transform: "Transform", outputColor: "ColorSpace"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  PNG image decoder.
 *  
 *  Supports: RGB, palette, grey, alpha, interlace, transparency.
 *  
 *  @author Stanislav Vitvitskyy
 *  
 */
var PNGDecoder = function() {
    VideoDecoder.call(this);
    this.ca = new Int8Array(4);
};
PNGDecoder = stjs.extend(PNGDecoder, VideoDecoder, [], function(constructor, prototype) {
    constructor.PNGSIG = -8552249625308161526;
    constructor.MNGSIG = -8481036456200365558;
    constructor.TAG_IHDR = 1229472850;
    constructor.TAG_IDAT = 1229209940;
    constructor.TAG_PLTE = 1347179589;
    constructor.TAG_tRNS = 1951551059;
    constructor.TAG_IEND = 1229278788;
    constructor.FILTER_TYPE_LOCO = 64;
    constructor.FILTER_VALUE_NONE = 0;
    constructor.FILTER_VALUE_SUB = 1;
    constructor.FILTER_VALUE_UP = 2;
    constructor.FILTER_VALUE_AVG = 3;
    constructor.FILTER_VALUE_PAETH = 4;
    constructor.PNG_COLOR_MASK_PALETTE = 1;
    constructor.PNG_COLOR_MASK_COLOR = 2;
    constructor.PNG_COLOR_MASK_ALPHA = 4;
    constructor.PNG_COLOR_TYPE_GRAY = 0;
    constructor.PNG_COLOR_TYPE_PALETTE = (PNGDecoder.PNG_COLOR_MASK_COLOR | PNGDecoder.PNG_COLOR_MASK_PALETTE);
    constructor.PNG_COLOR_TYPE_RGB = (PNGDecoder.PNG_COLOR_MASK_COLOR);
    constructor.alphaR = 127;
    constructor.alphaG = 127;
    constructor.alphaB = 127;
    constructor.logPassStep = new Int32Array([3, 3, 2, 2, 1, 1, 0]);
    constructor.logPassRowStep = new Int32Array([3, 3, 3, 2, 2, 1, 1]);
    constructor.passOff = new Int32Array([0, 4, 0, 2, 0, 1, 0]);
    constructor.passRowOff = new Int32Array([0, 0, 4, 0, 2, 0, 1]);
    prototype.ca = null;
    prototype.decodeFrame = function(data, buffer) {
        var sig = data.getLong();
        if (sig != PNGDecoder.PNGSIG && sig != PNGDecoder.MNGSIG) 
             throw new RuntimeException("Not a PNG file.");
        var ihdr = null;
        var plte = null;
        var trns = null;
        var list = new ArrayList();
         while (data.remaining() >= 8){
            var length = data.getInt();
            var tag = data.getInt();
            if (data.remaining() < length) 
                break;
            switch (tag) {
                case PNGDecoder.TAG_IHDR:
                    ihdr = new PNGDecoder.IHDR();
                    ihdr.parse(data);
                    break;
                case PNGDecoder.TAG_PLTE:
                    plte = new PNGDecoder.PLTE();
                    plte.parse(data, length);
                    break;
                case PNGDecoder.TAG_tRNS:
                    if (ihdr == null) {
                         throw new IllegalStateException("tRNS tag before IHDR");
                    }
                    trns = new PNGDecoder.TRNS(ihdr.colorType);
                    trns.parse(data, length);
                    break;
                case PNGDecoder.TAG_IDAT:
                    list.add(NIOUtils.read(data, length));
                    NIOUtils.skip(data, 4);
                    break;
                case PNGDecoder.TAG_IEND:
                    NIOUtils.skip(data, 4);
                    break;
                default:
                    data.setPosition(data.position() + length + 4);
            }
        }
        try {
            this.decodeData(ihdr, plte, trns, list, buffer);
        }catch (e) {
            return null;
        }
        if (ihdr == null) {
             throw new IllegalStateException("no IHDR tag");
        }
        return Picture.createPicture(ihdr.width, ihdr.height, buffer, ihdr.colorSpace());
    };
    prototype.decodeData = function(ihdr, plte, trns, list, buffer) {
        var bpp = (ihdr.getBitsPerPixel() + 7) >> 3;
        var passes = ihdr.interlaceType == 0 ? 1 : 7;
        var inflater = new Inflater();
        var it = list.iterator();
        for (var pass = 0; pass < passes; pass++) {
            var rowSize, rowStart, rowStep, colStart, colStep;
            if (ihdr.interlaceType == 0) {
                rowSize = ihdr.rowSize() + 1;
                colStart = rowStart = 0;
                colStep = rowStep = 1;
            } else {
                var round = (1 << PNGDecoder.logPassStep[pass]) - 1;
                rowSize = ((ihdr.width + round) >> PNGDecoder.logPassStep[pass]) + 1;
                rowStart = PNGDecoder.passRowOff[pass];
                rowStep = 1 << PNGDecoder.logPassRowStep[pass];
                colStart = PNGDecoder.passOff[pass];
                colStep = 1 << PNGDecoder.logPassStep[pass];
            }
            var lastRow = new Int8Array(rowSize - 1);
            var uncompressed = new Int8Array(rowSize);
            var bptr = 3 * (ihdr.width * rowStart + colStart);
            for (var row = rowStart; row < ihdr.height; row += rowStep) {
                var count = inflater.inflate(uncompressed);
                if (count < uncompressed.length && inflater.needsInput()) {
                    if (!it.hasNext()) {
                        Logger.warn(String.format("Data truncation at row %d", row));
                        break;
                    }
                    var next = it.next();
                    inflater.setInput(NIOUtils.toArray(next));
                    var toRead = uncompressed.length - count;
                    count = inflater.inflate3(uncompressed, count, toRead);
                    if (count != toRead) {
                        Logger.warn(String.format("Data truncation at row %d", row));
                        break;
                    }
                }
                var filter = uncompressed[0];
                switch (filter) {
                    case PNGDecoder.FILTER_VALUE_NONE:
                        for (var i = 0; i < rowSize - 1; i++) {
                            lastRow[i] = uncompressed[i + 1];
                        }
                        break;
                    case PNGDecoder.FILTER_VALUE_SUB:
                        this.filterSub(uncompressed, rowSize - 1, lastRow, bpp);
                        break;
                    case PNGDecoder.FILTER_VALUE_UP:
                        this.filterUp(uncompressed, rowSize - 1, lastRow);
                        break;
                    case PNGDecoder.FILTER_VALUE_AVG:
                        this.filterAvg(uncompressed, rowSize - 1, lastRow, bpp);
                        break;
                    case PNGDecoder.FILTER_VALUE_PAETH:
                        this.filterPaeth(uncompressed, rowSize - 1, lastRow, bpp);
                        break;
                }
                var bptrWas = bptr;
                if ((ihdr.colorType & PNGDecoder.PNG_COLOR_MASK_PALETTE) != 0) {
                    for (var i = 0; i < rowSize - 1; i += bpp , bptr += 3 * colStep) {
                        var plt = plte.palette[lastRow[i] & 255];
                        buffer[0][bptr] = ((((plt >> 16) & 255) - 128) << 24 >> 24);
                        buffer[0][bptr + 1] = ((((plt >> 8) & 255) - 128) << 24 >> 24);
                        buffer[0][bptr + 2] = (((plt & 255) - 128) << 24 >> 24);
                    }
                } else if ((ihdr.colorType & PNGDecoder.PNG_COLOR_MASK_COLOR) != 0) {
                    for (var i = 0; i < rowSize - 1; i += bpp , bptr += 3 * colStep) {
                        buffer[0][bptr] = (((lastRow[i] & 255) - 128) << 24 >> 24);
                        buffer[0][bptr + 1] = (((lastRow[i + 1] & 255) - 128) << 24 >> 24);
                        buffer[0][bptr + 2] = (((lastRow[i + 2] & 255) - 128) << 24 >> 24);
                    }
                } else {
                    for (var i = 0; i < rowSize - 1; i += bpp , bptr += 3 * colStep) {
                        buffer[0][bptr] = buffer[0][bptr + 1] = buffer[0][bptr + 2] = (((lastRow[i] & 255) - 128) << 24 >> 24);
                    }
                }
                if ((ihdr.colorType & PNGDecoder.PNG_COLOR_MASK_ALPHA) != 0) {
                    for (var i = bpp - 1, j = bptrWas; i < rowSize - 1; i += bpp , j += 3 * colStep) {
                        var alpha = lastRow[i] & 255, nalpha = 256 - alpha;
                        buffer[0][j] = (((PNGDecoder.alphaR * nalpha + buffer[0][j] * alpha) >> 8) << 24 >> 24);
                        buffer[0][j + 1] = (((PNGDecoder.alphaG * nalpha + buffer[0][j + 1] * alpha) >> 8) << 24 >> 24);
                        buffer[0][j + 2] = (((PNGDecoder.alphaB * nalpha + buffer[0][j + 2] * alpha) >> 8) << 24 >> 24);
                    }
                } else if (trns != null) {
                    if (ihdr.colorType == PNGDecoder.PNG_COLOR_TYPE_PALETTE) {
                        for (var i = 0, j = bptrWas; i < rowSize - 1; i++ , j += 3 * colStep) {
                            var alpha = trns.alphaPal[lastRow[i] & 255] & 255, nalpha = 256 - alpha;
                            buffer[0][j] = (((PNGDecoder.alphaR * nalpha + buffer[0][j] * alpha) >> 8) << 24 >> 24);
                            buffer[0][j + 1] = (((PNGDecoder.alphaG * nalpha + buffer[0][j + 1] * alpha) >> 8) << 24 >> 24);
                            buffer[0][j + 2] = (((PNGDecoder.alphaB * nalpha + buffer[0][j + 2] * alpha) >> 8) << 24 >> 24);
                        }
                    } else if (ihdr.colorType == PNGDecoder.PNG_COLOR_TYPE_RGB) {
                        var ar = (trns.alphaR & 255) - 128;
                        var ag = (trns.alphaG & 255) - 128;
                        var ab = (trns.alphaB & 255) - 128;
                        if (ab != PNGDecoder.alphaB || ag != PNGDecoder.alphaG || ar != PNGDecoder.alphaR) {
                            for (var i = 0, j = bptrWas; i < rowSize - 1; i += bpp , j += 3 * colStep) {
                                if (buffer[0][j] == ar && buffer[0][j + 1] == ag && buffer[0][j + 2] == ab) {
                                    buffer[0][j] = PNGDecoder.alphaR;
                                    buffer[0][j + 1] = PNGDecoder.alphaG;
                                    buffer[0][j + 2] = PNGDecoder.alphaB;
                                }
                            }
                        }
                    } else if (ihdr.colorType == PNGDecoder.PNG_COLOR_TYPE_GRAY) {
                        for (var i = 0, j = bptrWas; i < rowSize - 1; i++ , j += 3 * colStep) {
                            if (lastRow[i] == trns.alphaGrey) {
                                buffer[0][j] = PNGDecoder.alphaR;
                                buffer[0][j + 1] = PNGDecoder.alphaG;
                                buffer[0][j + 2] = PNGDecoder.alphaB;
                            }
                        }
                    }
                }
                bptr = bptrWas + (3 * ihdr.width * rowStep);
            }
        }
    };
    prototype.filterPaeth = function(uncompressed, rowSize, lastRow, bpp) {
        for (var i = 0; i < bpp; i++) {
            this.ca[i] = lastRow[i];
            lastRow[i] = (((uncompressed[i + 1] & 255) + (lastRow[i] & 255)) << 24 >> 24);
        }
        for (var i = bpp; i < rowSize; i++) {
            var a = lastRow[i - bpp] & 255;
            var b = lastRow[i] & 255;
            var c = this.ca[i % bpp] & 255;
            var p = b - c;
            var pc = a - c;
            var pa = MathUtil.abs(p);
            var pb = MathUtil.abs(pc);
            pc = MathUtil.abs(p + pc);
            if (pa <= pb && pa <= pc) 
                p = a;
             else if (pb <= pc) 
                p = b;
             else 
                p = c;
            this.ca[i % bpp] = lastRow[i];
            lastRow[i] = ((p + (uncompressed[i + 1] & 255)) << 24 >> 24);
        }
    };
    prototype.filterSub = function(uncompressed, rowSize, lastRow, bpp) {
        switch (bpp) {
            case 1:
                this.filterSub1(uncompressed, lastRow, rowSize);
                break;
            case 2:
                this.filterSub2(uncompressed, lastRow, rowSize);
                break;
            case 3:
                this.filterSub3(uncompressed, lastRow, rowSize);
                break;
            default:
                this.filterSub4(uncompressed, lastRow, rowSize);
        }
    };
    prototype.filterAvg = function(uncompressed, rowSize, lastRow, bpp) {
        switch (bpp) {
            case 1:
                this.filterAvg1(uncompressed, lastRow, rowSize);
                break;
            case 2:
                this.filterAvg2(uncompressed, lastRow, rowSize);
                break;
            case 3:
                this.filterAvg3(uncompressed, lastRow, rowSize);
                break;
            default:
                this.filterAvg4(uncompressed, lastRow, rowSize);
        }
    };
    prototype.filterSub1 = function(uncompressed, lastRow, rowSize) {
        var p = lastRow[0] = uncompressed[1];
        for (var i = 1; i < rowSize; i++) {
            p = lastRow[i] = (((p & 255) + (uncompressed[i + 1] & 255)) << 24 >> 24);
        }
    };
    prototype.filterUp = function(uncompressed, rowSize, lastRow) {
        for (var i = 0; i < rowSize; i++) {
            lastRow[i] = (((lastRow[i] & 255) + (uncompressed[i + 1] & 255)) << 24 >> 24);
        }
    };
    prototype.filterAvg1 = function(uncompressed, lastRow, rowSize) {
        var p = lastRow[0] = (((uncompressed[1] & 255) + ((lastRow[0] & 255) >> 1)) << 24 >> 24);
        for (var i = 1; i < rowSize; i++) {
            p = lastRow[i] = (((((lastRow[i] & 255) + (p & 255)) >> 1) + (uncompressed[i + 1] & 255)) << 24 >> 24);
        }
    };
    prototype.filterSub2 = function(uncompressed, lastRow, rowSize) {
        var p0 = lastRow[0] = uncompressed[1];
        var p1 = lastRow[1] = uncompressed[2];
        for (var i = 2; i < rowSize; i += 2) {
            p0 = lastRow[i] = (((p0 & 255) + (uncompressed[1 + i] & 255)) << 24 >> 24);
            p1 = lastRow[i + 1] = (((p1 & 255) + (uncompressed[2 + i] & 255)) << 24 >> 24);
        }
    };
    prototype.filterAvg2 = function(uncompressed, lastRow, rowSize) {
        var p0 = lastRow[0] = (((uncompressed[1] & 255) + ((lastRow[0] & 255) >> 1)) << 24 >> 24);
        var p1 = lastRow[1] = (((uncompressed[2] & 255) + ((lastRow[1] & 255) >> 1)) << 24 >> 24);
        for (var i = 2; i < rowSize; i += 2) {
            p0 = lastRow[i] = (((((lastRow[i] & 255) + (p0 & 255)) >> 1) + (uncompressed[1 + i] & 255)) << 24 >> 24);
            p1 = lastRow[i + 1] = (((((lastRow[i + 1] & 255) + (p1 & 255)) >> 1) + (uncompressed[i + 2] & 255)) << 24 >> 24);
        }
    };
    prototype.filterSub3 = function(uncompressed, lastRow, rowSize) {
        var p0 = lastRow[0] = uncompressed[1];
        var p1 = lastRow[1] = uncompressed[2];
        var p2 = lastRow[2] = uncompressed[3];
        for (var i = 3; i < rowSize; i += 3) {
            p0 = lastRow[i] = (((p0 & 255) + (uncompressed[i + 1] & 255)) << 24 >> 24);
            p1 = lastRow[i + 1] = (((p1 & 255) + (uncompressed[i + 2] & 255)) << 24 >> 24);
            p2 = lastRow[i + 2] = (((p2 & 255) + (uncompressed[i + 3] & 255)) << 24 >> 24);
        }
    };
    prototype.filterAvg3 = function(uncompressed, lastRow, rowSize) {
        var p0 = lastRow[0] = (((uncompressed[1] & 255) + ((lastRow[0] & 255) >> 1)) << 24 >> 24);
        var p1 = lastRow[1] = (((uncompressed[2] & 255) + ((lastRow[1] & 255) >> 1)) << 24 >> 24);
        var p2 = lastRow[2] = (((uncompressed[3] & 255) + ((lastRow[2] & 255) >> 1)) << 24 >> 24);
        for (var i = 3; i < rowSize; i += 3) {
            p0 = lastRow[i] = (((((lastRow[i] & 255) + (p0 & 255)) >> 1) + (uncompressed[i + 1] & 255)) << 24 >> 24);
            p1 = lastRow[i + 1] = (((((lastRow[i + 1] & 255) + (p1 & 255)) >> 1) + (uncompressed[i + 2] & 255)) << 24 >> 24);
            p2 = lastRow[i + 2] = (((((lastRow[i + 2] & 255) + (p2 & 255)) >> 1) + (uncompressed[i + 3] & 255)) << 24 >> 24);
        }
    };
    prototype.filterSub4 = function(uncompressed, lastRow, rowSize) {
        var p0 = lastRow[0] = uncompressed[1];
        var p1 = lastRow[1] = uncompressed[2];
        var p2 = lastRow[2] = uncompressed[3];
        var p3 = lastRow[3] = uncompressed[4];
        for (var i = 4; i < rowSize; i += 4) {
            p0 = lastRow[i] = (((p0 & 255) + (uncompressed[i + 1] & 255)) << 24 >> 24);
            p1 = lastRow[i + 1] = (((p1 & 255) + (uncompressed[i + 2] & 255)) << 24 >> 24);
            p2 = lastRow[i + 2] = (((p2 & 255) + (uncompressed[i + 3] & 255)) << 24 >> 24);
            p3 = lastRow[i + 3] = (((p3 & 255) + (uncompressed[i + 4] & 255)) << 24 >> 24);
        }
    };
    prototype.filterAvg4 = function(uncompressed, lastRow, rowSize) {
        var p0 = lastRow[0] = (((uncompressed[1] & 255) + ((lastRow[0] & 255) >> 1)) << 24 >> 24);
        var p1 = lastRow[1] = (((uncompressed[2] & 255) + ((lastRow[1] & 255) >> 1)) << 24 >> 24);
        var p2 = lastRow[2] = (((uncompressed[3] & 255) + ((lastRow[2] & 255) >> 1)) << 24 >> 24);
        var p3 = lastRow[3] = (((uncompressed[4] & 255) + ((lastRow[3] & 255) >> 1)) << 24 >> 24);
        for (var i = 4; i < rowSize; i += 4) {
            p0 = lastRow[i] = (((((lastRow[i] & 255) + (p0 & 255)) >> 1) + (uncompressed[i + 1] & 255)) << 24 >> 24);
            p1 = lastRow[i + 1] = (((((lastRow[i + 1] & 255) + (p1 & 255)) >> 1) + (uncompressed[i + 2] & 255)) << 24 >> 24);
            p2 = lastRow[i + 2] = (((((lastRow[i + 2] & 255) + (p2 & 255)) >> 1) + (uncompressed[i + 3] & 255)) << 24 >> 24);
            p3 = lastRow[i + 3] = (((((lastRow[i + 3] & 255) + (p3 & 255)) >> 1) + (uncompressed[i + 4] & 255)) << 24 >> 24);
        }
    };
    constructor.IHDR = function() {};
    constructor.IHDR = stjs.extend(constructor.IHDR, null, [], function(constructor, prototype) {
        prototype.width = 0;
        prototype.height = 0;
        prototype.bitDepth = 0;
        prototype.colorType = 0;
        prototype.compressionType = 0;
        prototype.filterType = 0;
        prototype.interlaceType = 0;
        prototype.parse = function(data) {
            this.width = data.getInt();
            this.height = data.getInt();
            this.bitDepth = data.get();
            this.colorType = data.get();
            this.compressionType = data.get();
            this.filterType = data.get();
            this.interlaceType = data.get();
            data.getInt();
        };
        prototype.rowSize = function() {
            return (this.width * this.getBitsPerPixel() + 7) >> 3;
        };
        prototype.getNBChannels = function() {
            var channels;
            channels = 1;
            if ((this.colorType & (PNGDecoder.PNG_COLOR_MASK_COLOR | PNGDecoder.PNG_COLOR_MASK_PALETTE)) == PNGDecoder.PNG_COLOR_MASK_COLOR) 
                channels = 3;
            if ((this.colorType & PNGDecoder.PNG_COLOR_MASK_ALPHA) != 0) 
                channels++;
            return channels;
        };
        prototype.getBitsPerPixel = function() {
            return this.bitDepth * this.getNBChannels();
        };
        prototype.colorSpace = function() {
            return ColorSpace.RGB;
        };
    }, {}, {});
    /**
     *  Palette descriptor.
     */
    constructor.PLTE = function() {};
    constructor.PLTE = stjs.extend(constructor.PLTE, null, [], function(constructor, prototype) {
        prototype.palette = null;
        prototype.parse = function(data, length) {
            if ((length % 3) != 0 || length > 256 * 3) 
                 throw new RuntimeException("Invalid data");
            var n = stjs.trunc(length / 3);
            this.palette = new Int32Array(n);
            var i = 0;
            for (i = 0; i < n; i++) {
                this.palette[i] = (255 << 24) | ((data.get() & 255) << 16) | ((data.get() & 255) << 8) | (data.get() & 255);
            }
            for (; i < 256; i++) 
                this.palette[i] = (255 << 24);
            data.getInt();
        };
    }, {palette: "Int32Array"}, {});
    /**
     *  Transparency descriptor for paletted data
     */
    constructor.TRNS = function(colorType) {
        this.colorType = colorType;
    };
    constructor.TRNS = stjs.extend(constructor.TRNS, null, [], function(constructor, prototype) {
        prototype.colorType = 0;
        prototype.alphaPal = null;
        prototype.alphaGrey = 0;
        prototype.alphaR = 0;
        prototype.alphaG = 0;
        prototype.alphaB = 0;
        prototype.parse = function(data, length) {
            if (this.colorType == PNGDecoder.PNG_COLOR_TYPE_PALETTE) {
                this.alphaPal = new Int8Array(256);
                data.getBuf3(this.alphaPal, 0, length);
                for (var i = length; i < 256; i++) {
                    this.alphaPal[i] = (255 << 24 >> 24);
                }
            } else if (this.colorType == PNGDecoder.PNG_COLOR_TYPE_GRAY) {
                this.alphaGrey = data.get();
            } else if (this.colorType == PNGDecoder.PNG_COLOR_TYPE_RGB) {
                this.alphaR = data.get();
                this.alphaG = data.get();
                this.alphaG = data.get();
            }
            data.getInt();
        };
    }, {alphaPal: "Int8Array"}, {});
    prototype.getCodecMeta = function(_data) {
        var data = _data.duplicate();
        var sig = data.getLong();
        if (sig != PNGDecoder.PNGSIG && sig != PNGDecoder.MNGSIG) 
             throw new RuntimeException("Not a PNG file.");
         while (data.remaining() >= 8){
            var length = data.getInt();
            var tag = data.getInt();
            if (data.remaining() < length) 
                break;
            switch (tag) {
                case PNGDecoder.TAG_IHDR:
                    var ihdr = new PNGDecoder.IHDR();
                    ihdr.parse(data);
                    return VideoCodecMeta.createSimpleVideoCodecMeta(new Size(ihdr.width, ihdr.height), ColorSpace.RGB);
                default:
                    data.setPosition(data.position() + length + 4);
            }
        }
        return null;
    };
    constructor.probe = function(data) {
        var sig = data.getLong();
        if (sig == PNGDecoder.PNGSIG && sig == PNGDecoder.MNGSIG) 
            return 100;
        return 0;
    };
    constructor.deflate = function(data, inflater) {
        inflater.setInput(data);
        var baos = new ByteArrayOutputStream(data.length);
        var buffer = new Int8Array(1 << 14);
         while (!inflater.needsInput()){
            var count = inflater.inflate(buffer);
            baos.write(buffer, 0, count);
            System.out.println(baos.size());
        }
        return baos.toByteArray();
    };
}, {logPassStep: "Int32Array", logPassRowStep: "Int32Array", passOff: "Int32Array", passRowOff: "Int32Array", ca: "Int8Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Preface = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
Preface = stjs.extend(Preface, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.lastModifiedDate = null;
    prototype.objectModelVersion = 0;
    prototype.op = null;
    prototype.essenceContainers = null;
    prototype.dmSchemes = null;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 15106:
                    this.lastModifiedDate = MXFMetadata.readDate(_bb);
                    break;
                case 15111:
                    this.objectModelVersion = _bb.getInt();
                    break;
                case 15113:
                    this.op = UL.read(_bb);
                    break;
                case 15114:
                    this.essenceContainers = MXFMetadata.readULBatch(_bb);
                    break;
                case 15115:
                    this.dmSchemes = MXFMetadata.readULBatch(_bb);
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getLastModifiedDate = function() {
        return this.lastModifiedDate;
    };
    prototype.getObjectModelVersion = function() {
        return this.objectModelVersion;
    };
    prototype.getOp = function() {
        return this.op;
    };
    prototype.getEssenceContainers = function() {
        return this.essenceContainers;
    };
    prototype.getDmSchemes = function() {
        return this.dmSchemes;
    };
}, {lastModifiedDate: "jsutil.Date", op: "UL", essenceContainers: "Array", dmSchemes: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Reads integer samples from the wav file
 *  
 *  @author Stanislav Vitvitskiy
 */
var WebpDemuxer = function(channel) {
    this.raf = DataReader.createDataReader(channel, ByteOrder.LITTLE_ENDIAN);
    this.vt = new ArrayList();
    this.vt.add(this);
};
WebpDemuxer = stjs.extend(WebpDemuxer, null, [Demuxer, DemuxerTrack], function(constructor, prototype) {
    constructor.FOURCC_RIFF = 1179011410;
    constructor.FOURCC_WEBP = 1346520407;
    constructor.FOURCC_VP8 = 540561494;
    constructor.FOURCC_ICCP = 1346585417;
    constructor.FOURCC_ANIM = 1296649793;
    constructor.FOURCC_ANMF = 1179471425;
    constructor.FOURCC_XMP = 542133592;
    constructor.FOURCC_EXIF = 1179211845;
    constructor.FOURCC_ALPH = 1213221953;
    constructor.FOURCC_VP8L = 1278758998;
    constructor.FOURCC_VP8X = 1480085590;
    prototype.vt = null;
    prototype.headerRead = false;
    prototype.raf = null;
    prototype.done = false;
    prototype.close = function() {
        this.raf.close();
    };
    prototype.nextFrame = function() {
        if (this.done) 
            return null;
        if (!this.headerRead) {
            this.readHeader();
            this.headerRead = true;
        }
        var fourCC = this.raf.readInt();
        var size = this.raf.readInt();
        this.done = true;
        switch (fourCC) {
            case WebpDemuxer.FOURCC_VP8:
                var b = new Int8Array(size);
                this.raf.readFully(b);
                return new Packet(ByteBuffer.wrap(b), 0, 25, 1, 0, Packet.FrameType.KEY, null, 0);
            case WebpDemuxer.FOURCC_ICCP:
            case WebpDemuxer.FOURCC_ANIM:
            case WebpDemuxer.FOURCC_ANMF:
            case WebpDemuxer.FOURCC_XMP:
            case WebpDemuxer.FOURCC_EXIF:
            case WebpDemuxer.FOURCC_ALPH:
            case WebpDemuxer.FOURCC_VP8L:
            case WebpDemuxer.FOURCC_VP8X:
            default:
                Logger.warn("Skipping unsupported chunk: " + WebpDemuxer.dwToFourCC(fourCC) + ".");
                var b1 = new Int8Array(size);
                this.raf.readFully(b1);
        }
        return null;
    };
    prototype.readHeader = function() {
        if (this.raf.readInt() != WebpDemuxer.FOURCC_RIFF) 
             throw new IOException("Invalid RIFF file.");
        var size = this.raf.readInt();
        if (this.raf.readInt() != WebpDemuxer.FOURCC_WEBP) 
             throw new IOException("Not a WEBP file.");
    };
    prototype.getMeta = function() {
        return null;
    };
    prototype.getTracks = function() {
        return this.vt;
    };
    prototype.getVideoTracks = function() {
        return this.vt;
    };
    prototype.getAudioTracks = function() {
        return new ArrayList();
    };
    constructor.probe = function(b_) {
        var b = b_.duplicate();
        if (b.remaining() < 12) 
            return 0;
        b.order(ByteOrder.LITTLE_ENDIAN);
        if (b.getInt() != WebpDemuxer.FOURCC_RIFF) 
            return 0;
        var size = b.getInt();
        if (b.getInt() != WebpDemuxer.FOURCC_WEBP) 
            return 0;
        return 100;
    };
    constructor.dwToFourCC = function(fourCC) {
        var ch = new Uint16Array(4);
        ch[0] = ((((fourCC >> 24) & 255)) & 65535);
        ch[1] = ((((fourCC >> 16) & 255)) & 65535);
        ch[2] = ((((fourCC >> 8) & 255)) & 65535);
        ch[3] = ((((fourCC >> 0) & 255)) & 65535);
        return new String(ch);
    };
}, {vt: {name: "ArrayList", arguments: ["DemuxerTrack"]}, raf: "DataReader"}, {});
/**
 *  Demuxer for MPEG 1/2 audio layer 1,2,3 (MP3).
 *  
 *  Extracts raw MPEG audio frames from the ES.
 *  
 *  See http://mpgedit.org/mpgedit/mpeg_format/mpeghdr.htm for more detail.
 *  
 *  @author Stanislav Vitvitskiy
 */
var MPEGAudioDemuxer = function(ch) {
    this.ch = ch;
    this.readBuffer = ByteBuffer.allocate(1 << 18);
    this.readMoreData();
    if (this.readBuffer.remaining() < 4) {
        this.eof = true;
    } else {
        this.runningFour = this.readBuffer.getInt();
        if (!MPEGAudioDemuxer.validHeader(this.runningFour)) {
            this.eof = this.skipJunk();
        }
        this.extractMeta();
    }
    this.tracks = new ArrayList();
    this.tracks.add(this);
};
MPEGAudioDemuxer = stjs.extend(MPEGAudioDemuxer, null, [Demuxer, DemuxerTrack], function(constructor, prototype) {
    constructor.field = function(off, size) {
        return (((1 << size) - 1) << 16) | off;
    };
    constructor.MAX_FRAME_SIZE = 1728;
    constructor.MIN_FRAME_SIZE = 52;
    constructor.CHANNELS = MPEGAudioDemuxer.field(6, 2);
    constructor.PADDING = MPEGAudioDemuxer.field(9, 1);
    constructor.SAMPLE_RATE = MPEGAudioDemuxer.field(10, 2);
    constructor.BITRATE = MPEGAudioDemuxer.field(12, 4);
    constructor.VERSION = MPEGAudioDemuxer.field(19, 2);
    constructor.LAYER = MPEGAudioDemuxer.field(17, 2);
    constructor.SYNC = MPEGAudioDemuxer.field(21, 11);
    constructor.MPEG1 = 3;
    constructor.MPEG2 = 2;
    constructor.MPEG25 = 0;
    constructor.bitrateTable = [[new Int32Array([0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448]), new Int32Array([0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384]), new Int32Array([0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320])], [new Int32Array([0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256]), new Int32Array([0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160]), new Int32Array([0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160])]];
    constructor.freqTab = new Int32Array([44100, 48000, 32000]);
    constructor.rateReductTab = new Int32Array([2, 0, 1, 0]);
    constructor.getField = function(header, field) {
        return (header >> (field & 65535)) & (field >> 16);
    };
    prototype.ch = null;
    prototype.tracks = null;
    prototype.frameNo = 0;
    prototype.readBuffer = null;
    prototype.runningFour = 0;
    prototype.eof = false;
    prototype.meta = null;
    prototype.sampleRate = 0;
    prototype.extractMeta = function() {
        if (!MPEGAudioDemuxer.validHeader(this.runningFour)) 
            return;
        var layer = 3 - MPEGAudioDemuxer.getField(this.runningFour, MPEGAudioDemuxer.LAYER);
        var channelCount = MPEGAudioDemuxer.getField(this.runningFour, MPEGAudioDemuxer.CHANNELS) == 3 ? 1 : 2;
        var version = MPEGAudioDemuxer.getField(this.runningFour, MPEGAudioDemuxer.VERSION);
        this.sampleRate = MPEGAudioDemuxer.freqTab[MPEGAudioDemuxer.getField(this.runningFour, MPEGAudioDemuxer.SAMPLE_RATE)] >> MPEGAudioDemuxer.rateReductTab[version];
        var codecMeta = AudioCodecMeta.createAudioCodecMeta(".mp3", 16, channelCount, this.sampleRate, ByteOrder.LITTLE_ENDIAN, false, null, null);
        var codec = layer == 2 ? Codec.MP3 : (layer == 1 ? Codec.MP2 : Codec.MP1);
        this.meta = new DemuxerTrackMeta(TrackType.AUDIO, codec, 0, null, 0, null, null, codecMeta);
    };
    prototype.close = function() {
        this.ch.close();
    };
    prototype.getTracks = function() {
        return this.tracks;
    };
    prototype.getVideoTracks = function() {
        return null;
    };
    prototype.getAudioTracks = function() {
        return this.tracks;
    };
    prototype.nextFrame = function() {
        if (this.eof) 
            return null;
        if (!MPEGAudioDemuxer.validHeader(this.runningFour)) {
            this.eof = this.skipJunk();
        }
        var frameSize = MPEGAudioDemuxer.calcFrameSize(this.runningFour);
        var frame = ByteBuffer.allocate(frameSize);
        this.eof = this.readFrame(frame);
        frame.flip();
        var pkt = new Packet(frame, this.frameNo * 1152, this.sampleRate, 1152, this.frameNo, Packet.FrameType.KEY, null, 0);
        ++this.frameNo;
        return pkt;
    };
    constructor.validHeader = function(four) {
        if (MPEGAudioDemuxer.getField(four, MPEGAudioDemuxer.SYNC) != 2047) 
            return false;
        if (MPEGAudioDemuxer.getField(four, MPEGAudioDemuxer.LAYER) == 0) 
            return false;
        if (MPEGAudioDemuxer.getField(four, MPEGAudioDemuxer.SAMPLE_RATE) == 3) 
            return false;
        if (MPEGAudioDemuxer.getField(four, MPEGAudioDemuxer.BITRATE) == 15) 
            return false;
        return true;
    };
    prototype.readMoreData = function() {
        this.readBuffer.clear();
        this.ch.read(this.readBuffer);
        this.readBuffer.flip();
    };
    constructor.calcFrameSize = function(header) {
        var bitrateIdx = MPEGAudioDemuxer.getField(header, MPEGAudioDemuxer.BITRATE);
        var layer = 3 - MPEGAudioDemuxer.getField(header, MPEGAudioDemuxer.LAYER);
        var version = MPEGAudioDemuxer.getField(header, MPEGAudioDemuxer.VERSION);
        var mpeg2 = version != 3 ? 1 : 0;
        var bitRate = MPEGAudioDemuxer.bitrateTable[mpeg2][layer][bitrateIdx] * 1000;
        var sampleRate = MPEGAudioDemuxer.freqTab[MPEGAudioDemuxer.getField(header, MPEGAudioDemuxer.SAMPLE_RATE)] >> MPEGAudioDemuxer.rateReductTab[version];
        var padding = MPEGAudioDemuxer.getField(header, MPEGAudioDemuxer.PADDING);
        var lsf = version == MPEGAudioDemuxer.MPEG25 || version == MPEGAudioDemuxer.MPEG2 ? 1 : 0;
        switch (layer) {
            case 0:
                return (stjs.trunc((bitRate * 12) / sampleRate) + padding) * 4;
            case 1:
                return stjs.trunc((bitRate * 144) / sampleRate) + padding;
            default:
            case 2:
                return stjs.trunc((bitRate * 144) / (sampleRate << lsf)) + padding;
        }
    };
    prototype.readFrame = function(frame) {
        var eof = false;
         while (frame.hasRemaining()){
            frame.put(((this.runningFour >> 24) << 24 >> 24));
            this.runningFour <<= 8;
            if (!this.readBuffer.hasRemaining()) 
                this.readMoreData();
            if (this.readBuffer.hasRemaining()) 
                this.runningFour |= this.readBuffer.get() & 255;
             else 
                eof = true;
        }
        return eof;
    };
    prototype.skipJunk = function() {
        var eof = false;
        var total = 0;
         while (!MPEGAudioDemuxer.validHeader(this.runningFour)){
            if (!this.readBuffer.hasRemaining()) 
                this.readMoreData();
            if (!this.readBuffer.hasRemaining()) {
                eof = true;
                break;
            }
            this.runningFour <<= 8;
            this.runningFour |= this.readBuffer.get() & 255;
            ++total;
        }
        Logger.warn(String.format("[mp3demuxer] Skipped %d bytes of junk", total));
        return eof;
    };
    prototype.getMeta = function() {
        return this.meta;
    };
    /**
     *  Used to auto-detect MPEG Audio (MP3) files
     *  
     *  @param b
     *             Buffer containing a snippet of data
     *  @return Score from 0 to 100
     */
    constructor.probe = function(b) {
        var fork = b.duplicate();
        var valid = 0, total = 0;
        var header = fork.getInt();
        do {
            if (!MPEGAudioDemuxer.validHeader(header)) 
                header = MPEGAudioDemuxer.skipJunkBB(header, fork);
            var size = MPEGAudioDemuxer.calcFrameSize(header);
            if (fork.remaining() < size) 
                break;
            ++total;
            if (size > 0) 
                NIOUtils.skip(fork, size - 4);
             else 
                header = MPEGAudioDemuxer.skipJunkBB(header, fork);
            if (fork.remaining() >= 4) {
                header = fork.getInt();
                if (size >= MPEGAudioDemuxer.MIN_FRAME_SIZE && size <= MPEGAudioDemuxer.MAX_FRAME_SIZE && MPEGAudioDemuxer.validHeader(header)) 
                    valid++;
            }
        } while (fork.remaining() >= 4);
        return stjs.trunc((100 * valid) / total);
    };
    constructor.skipJunkBB = function(header, fork) {
         while (!MPEGAudioDemuxer.validHeader(header) && fork.hasRemaining()){
            header <<= 8;
            header |= fork.get() & 255;
        }
        return header;
    };
}, {bitrateTable: "Array", freqTab: "Int32Array", rateReductTab: "Int32Array", ch: "SeekableByteChannel", tracks: {name: "List", arguments: ["DemuxerTrack"]}, readBuffer: "ByteBuffer", meta: "DemuxerTrackMeta"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Identification = function(ul) {
    MXFInterchangeObject.call(this, ul);
};
Identification = stjs.extend(Identification, MXFInterchangeObject, [], function(constructor, prototype) {
    prototype.thisGenerationUID = null;
    prototype.companyName = null;
    prototype.productName = null;
    prototype.versionString = 0;
    prototype.productUID = null;
    prototype.modificationDate = null;
    prototype.platform = null;
    prototype.read = function(tags) {
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 15369:
                    this.thisGenerationUID = UL.read(_bb);
                    break;
                case 15361:
                    this.companyName = this.readUtf16String(_bb);
                    break;
                case 15362:
                    this.productName = this.readUtf16String(_bb);
                    break;
                case 15364:
                    this.versionString = _bb.getShort();
                    break;
                case 15365:
                    this.productUID = UL.read(_bb);
                    break;
                case 15366:
                    this.modificationDate = MXFMetadata.readDate(_bb);
                    break;
                case 15368:
                    this.platform = this.readUtf16String(_bb);
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getThisGenerationUID = function() {
        return this.thisGenerationUID;
    };
    prototype.getCompanyName = function() {
        return this.companyName;
    };
    prototype.getProductName = function() {
        return this.productName;
    };
    prototype.getVersionString = function() {
        return this.versionString;
    };
    prototype.getProductUID = function() {
        return this.productUID;
    };
    prototype.getModificationDate = function() {
        return this.modificationDate;
    };
    prototype.getPlatform = function() {
        return this.platform;
    };
}, {thisGenerationUID: "UL", productUID: "UL", modificationDate: "jsutil.Date", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  A muxer and muxer track that simply saves each buffer as a file.
 *  @author Stanislav Vitvitskiy
 */
var ImageSequenceMuxer = function(fileNamePattern) {
    this.fileNamePattern = fileNamePattern;
};
ImageSequenceMuxer = stjs.extend(ImageSequenceMuxer, null, [Muxer, MuxerTrack], function(constructor, prototype) {
    prototype.fileNamePattern = null;
    prototype.frameNo = 0;
    prototype.addFrame = function(packet) {
        NIOUtils.writeTo(packet.getData(), MainUtils.tildeExpand(String.format(this.fileNamePattern, this.frameNo++)));
    };
    prototype.addVideoTrack = function(codec, meta) {
        return this;
    };
    prototype.addAudioTrack = function(codec, meta) {
        Logger.warn("Audio is not supported for image sequence muxer.");
        return null;
    };
    prototype.finish = function() {};
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Demuxer for MPEG Program Stream format
 *  
 *  @author The JCodec project
 *  
 */
var MPSDemuxer = function(channel) {
    SegmentReader.call(this, channel, 4096);
    this.streams = new HashMap();
    this.channel = channel;
    this.bufPool = new ArrayList();
    this.findStreams();
};
MPSDemuxer = stjs.extend(MPSDemuxer, SegmentReader, [MPEGDemuxer], function(constructor, prototype) {
    constructor.BUFFER_SIZE = 1048576;
    prototype.streams = null;
    prototype.channel = null;
    prototype.bufPool = null;
    prototype.findStreams = function() {
        for (var i = 0; i == 0 || i < 5 * this.streams.size() && this.streams.size() < 2; i++) {
            var nextPacket = this.nextPacket(this.getBuffer());
            if (nextPacket == null) 
                break;
            this.addToStream(nextPacket);
        }
    };
    prototype.getBuffer = function() {
        {
            if (this.bufPool.size() > 0) {
                return this.bufPool.remove(0);
            }
        }return ByteBuffer.allocate(MPSDemuxer.BUFFER_SIZE);
    };
    prototype.putBack = function(buffer) {
        buffer.clear();
        {
            this.bufPool.add(buffer);
        }};
    constructor.BaseTrack = function(demuxer, streamId, pkt) {
        this._pending = new ArrayList();
        this.demuxer = demuxer;
        this.streamId = streamId;
        this._pending.add(pkt);
    };
    constructor.BaseTrack = stjs.extend(constructor.BaseTrack, null, [MPEGDemuxer.MPEGDemuxerTrack], function(constructor, prototype) {
        prototype.streamId = 0;
        prototype._pending = null;
        prototype.demuxer = null;
        prototype.getSid = function() {
            return this.streamId;
        };
        prototype.pending = function(pkt) {
            if (this._pending != null) 
                this._pending.add(pkt);
             else 
                this.demuxer.putBack(pkt.data);
        };
        prototype.getPending = function() {
            return this._pending;
        };
        prototype.ignore = function() {
            if (this._pending == null) 
                return;
            for (var iterator$pesPacket = this._pending.iterator(); iterator$pesPacket.hasNext(); ) {
                var pesPacket = iterator$pesPacket.next();
                this.demuxer.putBack(pesPacket.data);
            }
            this._pending = null;
        };
    }, {_pending: {name: "List", arguments: ["PESPacket"]}, demuxer: "MPSDemuxer"}, {});
    constructor.MPEGTrack = function(demuxer, streamId, pkt) {
        MPSDemuxer.BaseTrack.call(this, demuxer, streamId, pkt);
        this.es = new MPEGES(this, 4096);
        this.ptsSeen = new LongArrayList(32);
        this.lastSeq = Integer.MIN_VALUE;
        this.lastSeqSeen = Integer.MAX_VALUE - 1000;
        this.seqWrap = Integer.MAX_VALUE - 1000;
        this.durationHistogram = new IntIntHistogram();
    };
    constructor.MPEGTrack = stjs.extend(constructor.MPEGTrack, MPSDemuxer.BaseTrack, [ReadableByteChannel], function(constructor, prototype) {
        prototype.es = null;
        prototype.ptsSeen = null;
        prototype.lastPts = 0;
        prototype.lastSeq = 0;
        prototype.lastSeqSeen = 0;
        prototype.seqWrap = 0;
        prototype.durationHistogram = null;
        prototype.isOpen = function() {
            return true;
        };
        prototype.getES = function() {
            return this.es;
        };
        prototype.close = function() {};
        prototype.read = function(arg0) {
            var pes = this._pending.size() > 0 ? this._pending.remove(0) : this.getPacket();
            if (pes == null || !pes.data.hasRemaining()) 
                return -1;
            var toRead = Math.min(arg0.remaining(), pes.data.remaining());
            arg0.putBuf(NIOUtils.read(pes.data, toRead));
            if (pes.data.hasRemaining()) 
                this._pending.add(0, pes);
             else 
                this.demuxer.putBack(pes.data);
            return toRead;
        };
        prototype.getPacket = function() {
            if (this._pending.size() > 0) 
                return this._pending.remove(0);
            var pkt;
             while ((pkt = this.demuxer.nextPacket(this.demuxer.getBuffer())) != null){
                if (pkt.streamId == this.streamId) {
                    if (pkt.pts != -1) {
                        this.ptsSeen.add(pkt.pts);
                    }
                    return pkt;
                } else {
                    this.demuxer.addToStream(pkt);
                }
            }
            return null;
        };
        prototype.nextFrameWithBuffer = function(buf) {
            return this.es.frame(buf);
        };
        prototype.nextFrame = function() {
            var pkt = this.es.getFrame();
            if (pkt == null) 
                return null;
            var seq = MPEGDecoder.getSequenceNumber(pkt.getData());
            if (seq == 0) 
                this.seqWrap = this.lastSeqSeen + 1;
            this.lastSeqSeen = seq;
            if (this.ptsSeen.size() <= 0) {
                pkt.setPts(Math.min(seq - this.lastSeq, seq - this.lastSeq + this.seqWrap) * this.durationHistogram.max() + this.lastPts);
            } else {
                pkt.setPts(this.ptsSeen.shift());
                if (this.lastSeq >= 0 && seq > this.lastSeq) {
                    this.durationHistogram.increment(stjs.trunc((((pkt.getPts() - this.lastPts)) | 0) / Math.min(seq - this.lastSeq, seq - this.lastSeq + this.seqWrap)));
                }
                this.lastPts = pkt.getPts();
                this.lastSeq = seq;
            }
            pkt.setDuration(this.durationHistogram.max());
            System.out.println(seq);
            return pkt;
        };
        prototype.getMeta = function() {
            return null;
        };
    }, {es: "MPEGES", ptsSeen: "LongArrayList", durationHistogram: "IntIntHistogram", _pending: {name: "List", arguments: ["PESPacket"]}, demuxer: "MPSDemuxer"}, {});
    constructor.PlainTrack = function(demuxer, streamId, pkt) {
        MPSDemuxer.BaseTrack.call(this, demuxer, streamId, pkt);
    };
    constructor.PlainTrack = stjs.extend(constructor.PlainTrack, MPSDemuxer.BaseTrack, [], function(constructor, prototype) {
        prototype.frameNo = 0;
        prototype.lastFrame = null;
        prototype.lastKnownDuration = 3003;
        prototype.isOpen = function() {
            return true;
        };
        prototype.close = function() {};
        prototype.nextFrameWithBuffer = function(buf) {
            var pkt;
            if (this._pending.size() > 0) {
                pkt = this._pending.remove(0);
            } else {
                 while ((pkt = this.demuxer.nextPacket(this.demuxer.getBuffer())) != null && pkt.streamId != this.streamId)
                    this.demuxer.addToStream(pkt);
            }
            return pkt == null ? null : Packet.createPacket(pkt.data, pkt.pts, 90000, 0, this.frameNo++, Packet.FrameType.UNKNOWN, null);
        };
        prototype.nextFrame = function() {
            if (this.lastFrame == null) 
                this.lastFrame = this.nextFrameWithBuffer(null);
            if (this.lastFrame == null) 
                return null;
            var toReturn = this.lastFrame;
            this.lastFrame = this.nextFrameWithBuffer(null);
            if (this.lastFrame != null) {
                this.lastKnownDuration = this.lastFrame.getPts() - toReturn.getPts();
            }
            toReturn.setDuration(this.lastKnownDuration);
            return toReturn;
        };
        prototype.getMeta = function() {
            var t = MPSUtils.videoStream(this.streamId) ? TrackType.VIDEO : (MPSUtils.audioStream(this.streamId) ? TrackType.AUDIO : TrackType.OTHER);
            return null;
        };
    }, {lastFrame: "Packet", _pending: {name: "List", arguments: ["PESPacket"]}, demuxer: "MPSDemuxer"}, {});
    constructor.AACTrack = function(demuxer, streamId, pkt) {
        MPSDemuxer.PlainTrack.call(this, demuxer, streamId, pkt);
        this.audioStash = new ArrayList();
    };
    constructor.AACTrack = stjs.extend(constructor.AACTrack, MPSDemuxer.PlainTrack, [], function(constructor, prototype) {
        prototype.audioStash = null;
        prototype.nextFrame = function() {
            if (this.audioStash.size() == 0) {
                var nextFrame = this.nextFrameWithBuffer(null);
                if (nextFrame != null) {
                    var data = nextFrame.getData();
                    var adts = ADTSParser.read(data.duplicate());
                    var nextPts = nextFrame.getPts();
                     while (data.hasRemaining()){
                        var data2 = NIOUtils.read(data, adts.getSize());
                        var pkt = Packet.createPacketWithData(nextFrame, data2);
                        pkt.setDuration(stjs.trunc((pkt.getTimescale() * 1024) / AACConts.AAC_SAMPLE_RATES[adts.getSamplingIndex()]));
                        pkt.setPts(nextPts);
                        nextPts += pkt.getDuration();
                        this.audioStash.add(pkt);
                        if (data.hasRemaining()) 
                            adts = ADTSParser.read(data.duplicate());
                    }
                }
            }
            if (this.audioStash.size() == 0) 
                return null;
            return this.audioStash.remove(0);
        };
    }, {audioStash: {name: "List", arguments: ["Packet"]}, lastFrame: "Packet", _pending: {name: "List", arguments: ["PESPacket"]}, demuxer: "MPSDemuxer"}, {});
    prototype.reset = function() {
        for (var iterator$track = this.streams.values().iterator(); iterator$track.hasNext(); ) {
            var track = iterator$track.next();
            track._pending.clear();
        }
    };
    prototype.addToStream = function(pkt) {
        var pes = this.streams.get(pkt.streamId);
        if (pes == null) {
            if (this.isMPEG(pkt.data)) 
                pes = new MPSDemuxer.MPEGTrack(this, pkt.streamId, pkt);
             else if (this.isAAC(pkt.data)) {
                pes = new MPSDemuxer.AACTrack(this, pkt.streamId, pkt);
            } else 
                pes = new MPSDemuxer.PlainTrack(this, pkt.streamId, pkt);
            this.streams.put(pkt.streamId, pes);
        } else {
            pes.pending(pkt);
        }
    };
    prototype.nextPacket = function(out) {
        var dup = out.duplicate();
         while (!MPSUtils.psMarker(this.curMarker)){
            if (!this.skipToMarker()) 
                return null;
        }
        var fork = dup.duplicate();
        this.readToNextMarker(dup);
        var pkt = MPSUtils.readPESHeader(fork, this.curPos());
        if (pkt.length == 0) {
             while (!MPSUtils.psMarker(this.curMarker) && this.readToNextMarker(dup))
                ;
        } else {
            this.read(dup, pkt.length - dup.position() + 6);
        }
        fork.setLimit(dup.position());
        pkt.data = fork;
        return pkt;
    };
    prototype.getTracks = function() {
        return new ArrayList(this.streams.values());
    };
    prototype.getVideoTracks = function() {
        var result = new ArrayList();
        for (var iterator$p = this.streams.values().iterator(); iterator$p.hasNext(); ) {
            var p = iterator$p.next();
            if (MPSUtils.videoStream(p.streamId)) 
                result.add(p);
        }
        return result;
    };
    prototype.getAudioTracks = function() {
        var result = new ArrayList();
        for (var iterator$p = this.streams.values().iterator(); iterator$p.hasNext(); ) {
            var p = iterator$p.next();
            if (MPSUtils.audioStream(p.streamId)) 
                result.add(p);
        }
        return result;
    };
    prototype.isAAC = function(_data) {
        var read = ADTSParser.read(_data.duplicate());
        return read != null;
    };
    prototype.isMPEG = function(_data) {
        var b = _data.duplicate();
        var marker = -1;
        var score = 0;
        var hasHeader = false, slicesStarted = false;
         while (b.hasRemaining()){
            var code = b.get() & 255;
            marker = (marker << 8) | code;
            if (marker < 256 || marker > 440) 
                continue;
            if (marker >= 432 && marker <= 440) {
                if ((hasHeader && marker != 437 && marker != 434) || slicesStarted) 
                    break;
                score += 5;
            } else if (marker == 256) {
                if (slicesStarted) 
                    break;
                hasHeader = true;
            } else if (marker > 256 && marker < 432) {
                if (!hasHeader) 
                    break;
                if (!slicesStarted) {
                    score += 50;
                    slicesStarted = true;
                }
                score += 1;
            }
        }
        return score > 50;
    };
    constructor.probe = function(b_) {
        var b = b_.duplicate();
        var marker = -1;
        var sliceSize = 0;
        var videoPes = false;
        var state = 0;
        var errors = 0;
        var inNALUnit = false;
        var nuSeq = new ArrayList();
         while (b.hasRemaining()){
            var code = b.get() & 255;
            if (state >= 3) {
                sliceSize++;
            }
            marker = (marker << 8) | code;
            if (inNALUnit) {
                var nu = NALUnit.read(NIOUtils.asByteBufferInt(code));
                if (nu.type != null) 
                    nuSeq.add(nu);
                inNALUnit = false;
            }
            if (videoPes && marker == 1) {
                inNALUnit = true;
                continue;
            } else if (marker < 256 || marker > 511) 
                continue;
            if (marker >= 442) {
                videoPes = MPSUtils.videoMarker(marker);
                continue;
            }
            if (!videoPes) 
                continue;
            var stop = false;
            switch (state) {
                case 0:
                    if (marker >= 432 && marker <= 440) 
                        state = 1;
                     else if (marker == 256) 
                        state = 2;
                     else 
                        state = 0;
                    break;
                case 1:
                    if (marker == 256) 
                        state = 2;
                     else if (marker >= 432 && marker <= 440) 
                        state = 1;
                     else 
                        errors++;
                    break;
                case 2:
                    if (marker == 257) 
                        state = 3;
                     else if (marker == 437 || marker == 434) 
                        state = 2;
                     else 
                        errors++;
                    break;
                default:
                    if (state > 3 && sliceSize < 1) {
                        errors++;
                    }
                    sliceSize = 0;
                    if (state - 1 == marker - 256) 
                        state = marker - 256 + 2;
                     else if (marker == 256 || marker >= 432) 
                        stop = true;
            }
            if (stop) 
                break;
        }
        return Math.max(MPSDemuxer.rateSeq(nuSeq), state >= 3 ? stjs.trunc(100 / (1 + errors)) : 0);
    };
    constructor.rateSeq = function(nuSeq) {
        var score = 0;
        var hasSps = false, hasPps = false, hasSlice = false;
        for (var iterator$nalUnit = nuSeq.iterator(); iterator$nalUnit.hasNext(); ) {
            var nalUnit = iterator$nalUnit.next();
            if (NALUnitType.SPS == nalUnit.type) {
                if (hasSps && !hasSlice) 
                    score -= 30;
                 else 
                    score += 30;
                hasSps = true;
            } else if (NALUnitType.PPS == nalUnit.type) {
                if (hasPps && !hasSlice) 
                    score -= 30;
                if (hasSps) 
                    score += 20;
                hasPps = true;
            } else if (NALUnitType.IDR_SLICE == nalUnit.type || NALUnitType.NON_IDR_SLICE == nalUnit.type) {
                if (!hasSlice) 
                    score += 20;
                hasSlice = true;
            }
        }
        return score;
    };
    prototype.close = function() {
        this.channel.close();
    };
}, {streams: {name: "Map", arguments: [null, "MPSDemuxer.BaseTrack"]}, channel: "ReadableByteChannel", bufPool: {name: "List", arguments: ["ByteBuffer"]}, channel: "ReadableByteChannel", buf: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  An MP4 file struncture (box).
 *  
 *  @author The JCodec project
 *  
 */
var Box = function(header) {
    this.header = header;
};
Box = stjs.extend(Box, null, [], function(constructor, prototype) {
    prototype.header = null;
    constructor.MAX_BOX_SIZE = 128 * 1024 * 1024;
    prototype.getHeader = function() {
        return this.header;
    };
    prototype.parse = function(buf) {};
    prototype.write = function(buf) {
        var dup = buf.duplicate();
        NIOUtils.skip(buf, 8);
        this.doWrite(buf);
        this.header.setBodySize(buf.position() - dup.position() - 8);
        Preconditions.checkState(this.header.headerSize() == stjs.trunc(8));
        this.header.write(dup);
    };
    prototype.doWrite = function(out) {};
    prototype.estimateSize = function() {};
    prototype.getFourcc = function() {
        return this.header.getFourcc();
    };
    prototype.toString = function() {
        var sb = new StringBuilder();
        this.dump(sb);
        return sb.toString();
    };
    prototype.dump = function(sb) {
        sb.append("{\"tag\":\"" + this.header.getFourcc() + "\"}");
    };
    constructor.terminatorAtom = function() {
        return Box.createLeafBox(new Header(Platform.stringFromBytes(new Int8Array(4))), ByteBuffer.allocate(0));
    };
    constructor.path = function(path) {
        return StringUtils.splitC(path, '.'.charCodeAt(0));
    };
    constructor.createLeafBox = function(atom, data) {
        var leaf = new Box.LeafBox(atom);
        leaf.data = data;
        return leaf;
    };
    constructor.parseBox = function(input, childAtom, factory) {
        var box = factory.newBox(childAtom);
        if (childAtom.getBodySize() < Box.MAX_BOX_SIZE) {
            box.parse(input);
            return box;
        } else {
            return new Box.LeafBox(Header.createHeader("free", 8));
        }
    };
    constructor.asBox = function(class1, box) {
        try {
            var res = Platform.newInstance(class1, [box.getHeader()]);
            var buffer = ByteBuffer.allocate(((box.getHeader().getBodySize()) | 0));
            box.doWrite(buffer);
            buffer.flip();
            res.parse(buffer);
            return res;
        }catch (e) {
             throw new RuntimeException(e);
        }
    };
    constructor.LeafBox = function(atom) {
        Box.call(this, atom);
    };
    constructor.LeafBox = stjs.extend(constructor.LeafBox, Box, [], function(constructor, prototype) {
        prototype.data = null;
        prototype.parse = function(input) {
            this.data = NIOUtils.read(input, ((this.header.getBodySize()) | 0));
        };
        prototype.getData = function() {
            return this.data.duplicate();
        };
        prototype.doWrite = function(out) {
            NIOUtils.write(out, this.data);
        };
        prototype.estimateSize = function() {
            return this.data.remaining() + Header.estimateHeaderSize(this.data.remaining());
        };
    }, {data: "ByteBuffer", header: "Header"}, {});
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Turns a ProRes frame into ProRes proxy frame
 *  
 *  @author The JCodec project
 *  
 */
var ProresToProxy = function(width, height, frameSize) {
    this.qMatLumaTo = ProresConsts.QMAT_LUMA_APCO;
    this.qMatChromaTo = ProresConsts.QMAT_CHROMA_APCO;
    this.frameSize = frameSize;
    var headerBytes = (height >> 4) * (((width >> 4) + 7) >> 3) * 8 + 148;
    var dataBits = (frameSize - headerBytes) << 3;
    this.bitsPer1024 = stjs.trunc((dataBits << 10) / (width * height));
    this.bitsPer1024High = this.bitsPer1024 - stjs.trunc(this.bitsPer1024 / 10);
    this.bitsPer1024Low = this.bitsPer1024 - stjs.trunc(this.bitsPer1024 / 20);
    this.nCoeffs = Math.max(Math.min(stjs.trunc(33000 / (width * height >> 8)), 64), 4);
};
ProresToProxy = stjs.extend(ProresToProxy, null, [], function(constructor, prototype) {
    prototype.qMatLumaTo = null;
    prototype.qMatChromaTo = null;
    prototype.frameSize = 0;
    constructor.START_QP = 6;
    prototype.bitsPer1024 = 0;
    prototype.bitsPer1024High = 0;
    prototype.bitsPer1024Low = 0;
    prototype.nCoeffs = 0;
    prototype.getFrameSize = function() {
        return this.frameSize;
    };
    prototype.requant = function(ib, ob, blocksPerSlice, qMatFrom, qMatTo, scan, mbX, mbY, plane) {
        var out = new Int32Array(blocksPerSlice << 6);
        try {
            ProresDecoder.readDCCoeffs(ib, qMatFrom, out, blocksPerSlice, 64);
            ProresDecoder.readACCoeffs(ib, qMatFrom, out, blocksPerSlice, scan, this.nCoeffs, 6);
        }catch (e) {}
        for (var i = 0; i < out.length; i++) 
            out[i] <<= 2;
        ProresEncoder.writeDCCoeffs(ob, qMatTo, out, blocksPerSlice);
        ProresEncoder.writeACCoeffs(ob, qMatTo, out, blocksPerSlice, scan, this.nCoeffs);
        ob.flush();
    };
    prototype.transcode = function(inBuf, outBuf) {
        var fork = outBuf.duplicate();
        var fh = ProresDecoder.readFrameHeader(inBuf);
        ProresEncoder.writeFrameHeader(outBuf, fh);
        var beforePicture = outBuf.position();
        if (fh.frameType == 0) {
            this.transcodePicture(inBuf, outBuf, fh);
        } else {
            this.transcodePicture(inBuf, outBuf, fh);
            this.transcodePicture(inBuf, outBuf, fh);
        }
        fh.qMatLuma = this.qMatLumaTo;
        fh.qMatChroma = this.qMatChromaTo;
        fh.payloadSize = outBuf.position() - beforePicture;
        ProresEncoder.writeFrameHeader(fork, fh);
    };
    prototype.transcodePicture = function(inBuf, outBuf, fh) {
        var ph = ProresDecoder.readPictureHeader(inBuf);
        ProresEncoder.writePictureHeader(ph.log2SliceMbWidth, ph.sliceSizes.length, outBuf);
        var sliceSizes = outBuf.duplicate();
        outBuf.setPosition(outBuf.position() + (ph.sliceSizes.length << 1));
        var mbX = 0, mbY = 0;
        var mbWidth = (fh.width + 15) >> 4;
        var sliceMbCount = 1 << ph.log2SliceMbWidth;
        var balance = 0, qp = ProresToProxy.START_QP;
        for (var i = 0; i < ph.sliceSizes.length; i++) {
             while (mbWidth - mbX < sliceMbCount)
                sliceMbCount >>= 1;
            var savedPoint = outBuf.position();
            this.transcodeSlice(inBuf, outBuf, fh.qMatLuma, fh.qMatChroma, fh.scan, sliceMbCount, mbX, mbY, ph.sliceSizes[i], qp);
            var encodedSize = (((outBuf.position() - savedPoint)) << 16 >> 16);
            sliceSizes.putShort(encodedSize);
            var max = (sliceMbCount * this.bitsPer1024High >> 5) + 6;
            var low = (sliceMbCount * this.bitsPer1024Low >> 5) + 6;
            if (encodedSize > max && qp < 128) {
                qp++;
                if ((encodedSize > max + balance) && qp < 128) 
                    qp++;
            } else {
                if (encodedSize < low && qp > 2 && balance > 0) 
                    qp--;
            }
            balance += max - encodedSize;
            mbX += sliceMbCount;
            if (mbX == mbWidth) {
                sliceMbCount = 1 << ph.log2SliceMbWidth;
                mbX = 0;
                mbY++;
            }
        }
    };
    prototype.transcodeSlice = function(inBuf, outBuf, qMatLuma, qMatChroma, scan, sliceMbCount, mbX, mbY, sliceSize, qp) {
        var hdrSize = (inBuf.get() & 255) >> 3;
        var qScaleOrig = ProresDecoder.clip(inBuf.get() & 255, 1, 224);
        var qScale = qScaleOrig > 128 ? qScaleOrig - 96 << 2 : qScaleOrig;
        var yDataSize = inBuf.getShort();
        var uDataSize = inBuf.getShort();
        var vDataSize = sliceSize - uDataSize - yDataSize - hdrSize;
        outBuf.put(((6 << 3) << 24 >> 24));
        outBuf.put((qp << 24 >> 24));
        var beforeSizes = outBuf.duplicate();
        outBuf.putInt(0);
        var beforeY = outBuf.position();
        this.requant(ProresDecoder.bitstream(inBuf, yDataSize), new BitWriter(outBuf), sliceMbCount << 2, ProresDecoder.scaleMat(qMatLuma, qScale), ProresDecoder.scaleMat(this.qMatLumaTo, qp), scan, mbX, mbY, 0);
        var beforeCb = outBuf.position();
        this.requant(ProresDecoder.bitstream(inBuf, uDataSize), new BitWriter(outBuf), sliceMbCount << 1, ProresDecoder.scaleMat(qMatChroma, qScale), ProresDecoder.scaleMat(this.qMatChromaTo, qp), scan, mbX, mbY, 1);
        var beforeCr = outBuf.position();
        this.requant(ProresDecoder.bitstream(inBuf, vDataSize), new BitWriter(outBuf), sliceMbCount << 1, ProresDecoder.scaleMat(qMatChroma, qScale), ProresDecoder.scaleMat(this.qMatChromaTo, qp), scan, mbX, mbY, 2);
        beforeSizes.putShort((((beforeCb - beforeY)) << 16 >> 16));
        beforeSizes.putShort((((beforeCr - beforeCb)) << 16 >> 16));
    };
}, {qMatLumaTo: "Int32Array", qMatChromaTo: "Int32Array"}, {});
/**
 *  
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Decodes a ProRes file in low res. Decodes each 8x8 block as a downscaled 2x2
 *  block.
 *  
 *  @author The JCodec project
 *  
 */
var ProresToThumb2x2 = function() {
    ProresDecoder.call(this);
};
ProresToThumb2x2 = stjs.extend(ProresToThumb2x2, ProresDecoder, [], function(constructor, prototype) {
    prototype.decodeOnePlane = function(bits, blocksPerSlice, out, qMat, scan, mbX, mbY, plane) {
        ProresDecoder.readDCCoeffs(bits, qMat, out, blocksPerSlice, 4);
        ProresDecoder.readACCoeffs(bits, qMat, out, blocksPerSlice, scan, 4, 2);
        for (var i = 0; i < blocksPerSlice; i++) {
            IDCT2x2.idct(out, i << 2);
        }
    };
    prototype.decodeFrameHiBD = function(data, target, lowBits) {
        var fh = ProresDecoder.readFrameHeader(data);
        var codedWidth = ((fh.width + 15) & ~15) >> 2;
        var codedHeight = ((fh.height + 15) & ~15) >> 2;
        var lumaSize = codedWidth * codedHeight;
        var chromaSize = lumaSize >> 1;
        if (target == null || target[0].length < lumaSize || target[1].length < chromaSize || target[2].length < chromaSize) {
             throw new RuntimeException("Provided output picture won't fit into provided buffer");
        }
        if (fh.frameType == 0) {
            this.decodePicture(data, target, lowBits, codedWidth, codedHeight, codedWidth >> 2, fh.qMatLuma, fh.qMatChroma, new Int32Array([0, 1, 2, 3]), 0, fh.chromaType);
        } else {
            this.decodePicture(data, target, lowBits, codedWidth, codedHeight >> 1, codedWidth >> 2, fh.qMatLuma, fh.qMatChroma, new Int32Array([0, 2, 1, 3]), fh.topFieldFirst ? 1 : 2, fh.chromaType);
            this.decodePicture(data, target, lowBits, codedWidth, codedHeight >> 1, codedWidth >> 2, fh.qMatLuma, fh.qMatChroma, new Int32Array([0, 2, 1, 3]), fh.topFieldFirst ? 2 : 1, fh.chromaType);
        }
        var color = fh.chromaType == 2 ? ColorSpace.YUV422 : ColorSpace.YUV444;
        return new Picture(codedWidth, codedHeight, target, lowBits, color, lowBits == null ? 0 : 2, new Rect(0, 0, (fh.width >> 2) & color.getWidthMask(), (fh.height >> 2) & color.getHeightMask()));
    };
    prototype.putSlice = function(result, lowBits, lumaStride, mbX, mbY, y, u, v, dist, shift, chromaType, sliceMbCount) {
        var chromaStride = lumaStride >> 1;
        this._putLuma(result[0], lowBits == null ? null : lowBits[0], shift * lumaStride, lumaStride << dist, mbX, mbY, y, sliceMbCount, dist, shift);
        if (chromaType == 2) {
            this._putChroma(result[1], lowBits == null ? null : lowBits[1], shift * chromaStride, chromaStride << dist, mbX, mbY, u, sliceMbCount, dist, shift);
            this._putChroma(result[2], lowBits == null ? null : lowBits[2], shift * chromaStride, chromaStride << dist, mbX, mbY, v, sliceMbCount, dist, shift);
        } else {
            this._putLuma(result[1], lowBits == null ? null : lowBits[1], shift * lumaStride, lumaStride << dist, mbX, mbY, u, sliceMbCount, dist, shift);
            this._putLuma(result[2], lowBits == null ? null : lowBits[2], shift * lumaStride, lumaStride << dist, mbX, mbY, v, sliceMbCount, dist, shift);
        }
    };
    prototype._putLuma = function(y, lowBits, off, stride, mbX, mbY, luma, mbPerSlice, dist, shift) {
        off += (mbX << 2) + (mbY << 2) * stride;
        var tstride = stride * 3;
        for (var k = 0, sOff = 0; k < mbPerSlice; k++) {
            this.putGroup(y, lowBits, off, luma, sOff);
            off += stride;
            this.putGroup(y, lowBits, off, luma, sOff + 2);
            off += stride;
            this.putGroup(y, lowBits, off, luma, sOff + 8);
            off += stride;
            this.putGroup(y, lowBits, off, luma, sOff + 10);
            off += 4 - tstride;
            sOff += 16;
        }
    };
    prototype.putGroup = function(y, lowBits, off, luma, sOff) {
        var round0 = MathUtil.clip((luma[sOff] + 2) >> 2, 1, 255);
        var round1 = MathUtil.clip((luma[sOff + 1] + 2) >> 2, 1, 255);
        var round2 = MathUtil.clip((luma[sOff + 4] + 2) >> 2, 1, 255);
        var round3 = MathUtil.clip((luma[sOff + 5] + 2) >> 2, 1, 255);
        y[off] = ((round0 - 128) << 24 >> 24);
        y[off + 1] = ((round1 - 128) << 24 >> 24);
        y[off + 2] = ((round2 - 128) << 24 >> 24);
        y[off + 3] = ((round3 - 128) << 24 >> 24);
        if (lowBits != null) {
            var val0 = MathUtil.clip(luma[sOff], 4, 1019);
            var val1 = MathUtil.clip(luma[sOff + 1], 4, 1019);
            var val2 = MathUtil.clip(luma[sOff + 4], 4, 1019);
            var val3 = MathUtil.clip(luma[sOff + 5], 4, 1019);
            lowBits[off] = ((val0 - (round0 << 2)) << 24 >> 24);
            lowBits[off + 1] = ((val1 - (round1 << 2)) << 24 >> 24);
            lowBits[off + 2] = ((val2 - (round2 << 2)) << 24 >> 24);
            lowBits[off + 3] = ((val3 - (round3 << 2)) << 24 >> 24);
        }
    };
    prototype._putChroma = function(y, lowBits, off_, stride, mbX, mbY, chroma, mbPerSlice, dist, shift) {
        var off = off_ + (mbX << 1) + (mbY << 2) * stride;
        for (var k = 0, sOff = 0; k < mbPerSlice; k++) {
            for (var row = 0, rowOff = off; row < 4; row++ , rowOff += stride , sOff += 2) {
                var round0 = MathUtil.clip((chroma[sOff] + 2) >> 2, 1, 255);
                var round1 = MathUtil.clip((chroma[sOff + 1] + 2) >> 2, 1, 255);
                y[rowOff] = ((round0 - 128) << 24 >> 24);
                y[rowOff + 1] = ((round1 - 128) << 24 >> 24);
            }
            off += 2;
        }
        if (lowBits != null) {
            off = off_ + (mbX << 1) + (mbY << 2) * stride;
            for (var k = 0, sOff = 0; k < mbPerSlice; k++) {
                for (var row = 0, rowOff = off; row < 4; row++ , rowOff += stride , sOff += 2) {
                    var val0 = MathUtil.clip(chroma[sOff], 4, 1019);
                    var val1 = MathUtil.clip(chroma[sOff + 1], 4, 1019);
                    var round0 = MathUtil.clip((chroma[sOff] + 2) >> 2, 1, 255);
                    var round1 = MathUtil.clip((chroma[sOff + 1] + 2) >> 2, 1, 255);
                    lowBits[rowOff] = ((val0 - (round0 << 2)) << 24 >> 24);
                    lowBits[rowOff + 1] = ((val1 - (round1 << 2)) << 24 >> 24);
                }
                off += 2;
            }
        }
    };
}, {table: "Int32Array", mask: "Int32Array", byteBuffer: "Array"}, {});
/**
 *  
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Decodes a ProRes file in low res. Decodes each 8x8 block as downscaled 4x4
 *  block.
 *  
 *  @author The JCodec project
 *  
 */
var ProresToThumb4x4 = function() {
    ProresDecoder.call(this);
};
ProresToThumb4x4 = stjs.extend(ProresToThumb4x4, ProresDecoder, [], function(constructor, prototype) {
    prototype.decodeOnePlane = function(bits, blocksPerSlice, out, qMat, scan, mbX, mbY, plane) {
        ProresDecoder.readDCCoeffs(bits, qMat, out, blocksPerSlice, 16);
        ProresDecoder.readACCoeffs(bits, qMat, out, blocksPerSlice, scan, 16, 4);
        for (var i = 0; i < blocksPerSlice; i++) {
            IDCT4x4.idct(out, i << 4);
        }
    };
    constructor.progressive_scan_4x4 = new Int32Array([0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 11, 12, 14, 15]);
    constructor.interlaced_scan_4x4 = new Int32Array([0, 4, 1, 5, 8, 12, 9, 13, 2, 6, 3, 7, 10, 14, 11, 15]);
    prototype.decodeFrameHiBD = function(data, target, lowBits) {
        var fh = ProresDecoder.readFrameHeader(data);
        var codedWidth = ((fh.width + 15) & ~15) >> 1;
        var codedHeight = ((fh.height + 15) & ~15) >> 1;
        var lumaSize = codedWidth * codedHeight;
        var chromaSize = lumaSize >> 1;
        if (target == null || target[0].length < lumaSize || target[1].length < chromaSize || target[2].length < chromaSize) {
             throw new RuntimeException("Provided output picture won't fit into provided buffer");
        }
        if (fh.frameType == 0) {
            this.decodePicture(data, target, lowBits, codedWidth, codedHeight, codedWidth >> 3, fh.qMatLuma, fh.qMatChroma, ProresToThumb4x4.progressive_scan_4x4, 0, fh.chromaType);
        } else {
            this.decodePicture(data, target, lowBits, codedWidth, codedHeight >> 1, codedWidth >> 3, fh.qMatLuma, fh.qMatChroma, ProresToThumb4x4.interlaced_scan_4x4, fh.topFieldFirst ? 1 : 2, fh.chromaType);
            this.decodePicture(data, target, lowBits, codedWidth, codedHeight >> 1, codedWidth >> 3, fh.qMatLuma, fh.qMatChroma, ProresToThumb4x4.interlaced_scan_4x4, fh.topFieldFirst ? 2 : 1, fh.chromaType);
        }
        var color = fh.chromaType == 2 ? ColorSpace.YUV422 : ColorSpace.YUV444;
        return new Picture(codedWidth, codedHeight, target, lowBits, color, lowBits == null ? 0 : 2, new Rect(0, 0, (fh.width >> 1) & color.getWidthMask(), (fh.height >> 1) & color.getHeightMask()));
    };
    prototype.putSlice = function(result, lowBits, lumaStride, mbX, mbY, y, u, v, dist, shift, chromaType, sliceMbCount) {
        var chromaStride = lumaStride >> 1;
        this._putLuma(result[0], lowBits == null ? null : lowBits[0], shift * lumaStride, lumaStride << dist, mbX, mbY, y, sliceMbCount, dist, shift);
        if (chromaType == 2) {
            this._putChroma(result[1], lowBits == null ? null : lowBits[1], shift * chromaStride, chromaStride << dist, mbX, mbY, u, sliceMbCount, dist, shift);
            this._putChroma(result[2], lowBits == null ? null : lowBits[2], shift * chromaStride, chromaStride << dist, mbX, mbY, v, sliceMbCount, dist, shift);
        } else {
            this._putLuma(result[1], lowBits == null ? null : lowBits[1], shift * lumaStride, lumaStride << dist, mbX, mbY, u, sliceMbCount, dist, shift);
            this._putLuma(result[2], lowBits == null ? null : lowBits[2], shift * lumaStride, lumaStride << dist, mbX, mbY, v, sliceMbCount, dist, shift);
        }
    };
    constructor.srcIncLuma = new Int32Array([4, 4, 4, 20, 4, 4, 4, 20]);
    prototype._putLuma = function(y, lowBits, fieldOffset, stride, mbX, mbY, luma, mbPerSlice, dist, shift) {
        var mbTopLeftOff = fieldOffset + (mbX << 3) + (mbY << 3) * stride;
        for (var mb = 0, sOff = 0; mb < mbPerSlice; mb++ , mbTopLeftOff += 8) {
            var lineOff = mbTopLeftOff;
            for (var line = 0; line < 8; line++) {
                for (var col = 0; col < 4; col++) {
                    var round = MathUtil.clip((luma[sOff + col] + 2) >> 2, 1, 255);
                    y[lineOff + col] = ((round - 128) << 24 >> 24);
                }
                for (var col = 4; col < 8; col++) {
                    var round = MathUtil.clip((luma[sOff + col + 12] + 2) >> 2, 1, 255);
                    y[lineOff + col] = ((round - 128) << 24 >> 24);
                }
                sOff += ProresToThumb4x4.srcIncLuma[line];
                lineOff += stride;
            }
        }
        if (lowBits != null) {
            mbTopLeftOff = fieldOffset + (mbX << 3) + (mbY << 3) * stride;
            for (var mb = 0, sOff = 0; mb < mbPerSlice; mb++ , mbTopLeftOff += 8) {
                var lineOff = mbTopLeftOff;
                for (var line = 0; line < 4; line++) {
                    for (var col = 0; col < 4; col++) {
                        var val = MathUtil.clip(luma[sOff + col], 4, 1019);
                        var round = MathUtil.clip((luma[sOff + col] + 2) >> 2, 1, 255);
                        lowBits[lineOff + col] = ((val - (round << 2)) << 24 >> 24);
                    }
                    for (var col = 4; col < 8; col++) {
                        var val = MathUtil.clip(luma[sOff + col + 12], 4, 1019);
                        var round = MathUtil.clip((luma[sOff + col] + 2) >> 2, 1, 255);
                        lowBits[lineOff + col] = ((val - (round << 2)) << 24 >> 24);
                    }
                    sOff += ProresToThumb4x4.srcIncLuma[line];
                    lineOff += stride;
                }
            }
        }
    };
    prototype._putChroma = function(y, lowBits, fieldOff, stride, mbX, mbY, chroma, mbPerSlice, dist, shift) {
        var mbTopLeftOff = fieldOff + (mbX << 2) + (mbY << 3) * stride;
        for (var k = 0, sOff = 0; k < mbPerSlice; k++ , mbTopLeftOff += 4) {
            var lineOff = mbTopLeftOff;
            for (var line = 0; line < 8; line++) {
                for (var col = 0; col < 4; col++) {
                    var round = MathUtil.clip((chroma[sOff + col] + 2) >> 2, 1, 255);
                    y[lineOff + col] = ((round - 128) << 24 >> 24);
                }
                sOff += 4;
                lineOff += stride;
            }
        }
        if (lowBits != null) {
            mbTopLeftOff = fieldOff + (mbX << 2) + (mbY << 3) * stride;
            for (var k = 0, sOff = 0; k < mbPerSlice; k++ , mbTopLeftOff += 4) {
                var lineOff = mbTopLeftOff;
                for (var line = 0; line < 8; line++) {
                    for (var col = 0; col < 4; col++) {
                        var val = MathUtil.clip(chroma[sOff + col], 4, 1019);
                        var round = MathUtil.clip((chroma[sOff + col] + 2) >> 2, 1, 255);
                        lowBits[lineOff + col] = ((val - (round << 2)) << 24 >> 24);
                    }
                    sOff += 4;
                    lineOff += stride;
                }
            }
        }
    };
}, {progressive_scan_4x4: "Int32Array", interlaced_scan_4x4: "Int32Array", srcIncLuma: "Int32Array", table: "Int32Array", mask: "Int32Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Rewrites DCT coefficients to new ProRes bitstream concealing errors
 *  
 *  @author The JCodec project
 *  
 */
var ProresFix = function() {};
ProresFix = stjs.extend(ProresFix, null, [], function(constructor, prototype) {
    constructor.readDCCoeffs = function(bits, out, blocksPerSlice) {
        out[0] = ProresDecoder.readCodeword(bits, ProresConsts.firstDCCodebook);
        if (out[0] < 0) {
             throw new RuntimeException("First DC coeff damaged");
        }
        var code = 5, idx = 64;
        for (var i = 1; i < blocksPerSlice; i++ , idx += 64) {
            code = ProresDecoder.readCodeword(bits, ProresConsts.dcCodebooks[Math.min(code, 6)]);
            if (code < 0) {
                 throw new RuntimeException("DC coeff damaged");
            }
            out[idx] = code;
        }
    };
    constructor.readACCoeffs = function(bits, out, blocksPerSlice, scan) {
        var run = 4;
        var level = 2;
        var blockMask = blocksPerSlice - 1;
        var log2BlocksPerSlice = MathUtil.log2(blocksPerSlice);
        var maxCoeffs = 64 << log2BlocksPerSlice;
        var pos = blockMask;
         while (bits.remaining() > 32 || bits.checkNBit(24) != 0){
            run = ProresDecoder.readCodeword(bits, ProresConsts.runCodebooks[Math.min(run, 15)]);
            if (run < 0 || run >= maxCoeffs - pos - 1) {
                 throw new RuntimeException("Run codeword damaged");
            }
            pos += run + 1;
            level = ProresDecoder.readCodeword(bits, ProresConsts.levCodebooks[Math.min(level, 9)]) + 1;
            if (level < 0 || level > 65535) {
                 throw new RuntimeException("Level codeword damaged");
            }
            var sign = -bits.read1Bit();
            var ind = pos >> log2BlocksPerSlice;
            out[((pos & blockMask) << 6) + scan[ind]] = MathUtil.toSigned(level, sign);
        }
    };
    constructor.writeDCCoeffs = function(bits, _in, blocksPerSlice) {
        ProresEncoder.writeCodeword(bits, ProresConsts.firstDCCodebook, _in[0]);
        var code = 5, idx = 64;
        for (var i = 1; i < blocksPerSlice; i++ , idx += 64) {
            ProresEncoder.writeCodeword(bits, ProresConsts.dcCodebooks[Math.min(code, 6)], _in[idx]);
            code = _in[idx];
        }
    };
    constructor.writeACCoeffs = function(bits, _in, blocksPerSlice, scan) {
        var prevRun = 4;
        var prevLevel = 2;
        var run = 0;
        for (var i = 1; i < 64; i++) {
            var indp = scan[i];
            for (var j = 0; j < blocksPerSlice; j++) {
                var val = _in[(j << 6) + indp];
                if (val == 0) 
                    run++;
                 else {
                    ProresEncoder.writeCodeword(bits, ProresConsts.runCodebooks[Math.min(prevRun, 15)], run);
                    prevRun = run;
                    run = 0;
                    var level = ProresEncoder.getLevel(val);
                    ProresEncoder.writeCodeword(bits, ProresConsts.levCodebooks[Math.min(prevLevel, 9)], level - 1);
                    prevLevel = level;
                    bits.write1Bit(MathUtil.sign(val));
                }
            }
        }
    };
    constructor.copyCoeff = function(ib, ob, blocksPerSlice, scan) {
        var out = new Int32Array(blocksPerSlice << 6);
        try {
            ProresFix.readDCCoeffs(ib, out, blocksPerSlice);
            ProresFix.readACCoeffs(ib, out, blocksPerSlice, scan);
        }catch (e) {}
        ProresFix.writeDCCoeffs(ob, out, blocksPerSlice);
        ProresFix.writeACCoeffs(ob, out, blocksPerSlice, scan);
        ob.flush();
    };
    constructor.transcode = function(inBuf, _outBuf) {
        var outBuf = _outBuf.slice();
        var fork = outBuf.duplicate();
        var fh = ProresDecoder.readFrameHeader(inBuf);
        ProresEncoder.writeFrameHeader(outBuf, fh);
        if (fh.frameType == 0) {
            ProresFix.transcodePicture(inBuf, outBuf, fh);
        } else {
            ProresFix.transcodePicture(inBuf, outBuf, fh);
            ProresFix.transcodePicture(inBuf, outBuf, fh);
        }
        ProresEncoder.writeFrameHeader(fork, fh);
        outBuf.flip();
        return outBuf;
    };
    constructor.transcodePicture = function(inBuf, outBuf, fh) {
        var ph = ProresDecoder.readPictureHeader(inBuf);
        ProresEncoder.writePictureHeader(ph.log2SliceMbWidth, ph.sliceSizes.length, outBuf);
        var fork = outBuf.duplicate();
        outBuf.setPosition(outBuf.position() + (ph.sliceSizes.length << 1));
        var mbWidth = (fh.width + 15) >> 4;
        var sliceMbCount = 1 << ph.log2SliceMbWidth;
        var mbX = 0;
        for (var i = 0; i < ph.sliceSizes.length; i++) {
             while (mbWidth - mbX < sliceMbCount)
                sliceMbCount >>= 1;
            var savedPoint = outBuf.position();
            ProresFix.transcodeSlice(inBuf, outBuf, sliceMbCount, ph.sliceSizes[i], fh);
            fork.putShort((((outBuf.position() - savedPoint)) << 16 >> 16));
            mbX += sliceMbCount;
            if (mbX == mbWidth) {
                sliceMbCount = 1 << ph.log2SliceMbWidth;
                mbX = 0;
            }
        }
    };
    constructor.transcodeSlice = function(inBuf, outBuf, sliceMbCount, sliceSize, fh) {
        var hdrSize = (inBuf.get() & 255) >> 3;
        var qScaleOrig = inBuf.get() & 255;
        var yDataSize = inBuf.getShort();
        var uDataSize = inBuf.getShort();
        var vDataSize = sliceSize - uDataSize - yDataSize - hdrSize;
        outBuf.put(((6 << 3) << 24 >> 24));
        outBuf.put((qScaleOrig << 24 >> 24));
        var beforeSizes = outBuf.duplicate();
        outBuf.putInt(0);
        var beforeY = outBuf.position();
        ProresFix.copyCoeff(ProresDecoder.bitstream(inBuf, yDataSize), new BitWriter(outBuf), sliceMbCount << 2, fh.scan);
        var beforeCb = outBuf.position();
        ProresFix.copyCoeff(ProresDecoder.bitstream(inBuf, uDataSize), new BitWriter(outBuf), sliceMbCount << 1, fh.scan);
        var beforeCr = outBuf.position();
        ProresFix.copyCoeff(ProresDecoder.bitstream(inBuf, vDataSize), new BitWriter(outBuf), sliceMbCount << 1, fh.scan);
        beforeSizes.putShort((((beforeCb - beforeY)) << 16 >> 16));
        beforeSizes.putShort((((beforeCr - beforeCb)) << 16 >> 16));
    };
    constructor.check = function(data) {
        var messages = new ArrayList();
        var frameSize = data.getInt();
        if (!"icpf".equals(ProresDecoder.readSig(data))) {
            messages.add("[ERROR] Missing ProRes signature (icpf).");
            return messages;
        }
        var headerSize = data.getShort();
        if (headerSize > 148) {
            messages.add("[ERROR] Wrong ProRes frame header.");
            return messages;
        }
        var version = data.getShort();
        var res1 = data.getInt();
        var width = data.getShort();
        var height = data.getShort();
        if (width < 0 || width > 10000 || height < 0 || height > 10000) {
            messages.add("[ERROR] Wrong ProRes frame header, invalid image size [" + width + "x" + height + "].");
            return messages;
        }
        var flags1 = data.get();
        data.setPosition(data.position() + headerSize - 13);
        if (((flags1 >> 2) & 3) == 0) {
            ProresFix.checkPicture(data, width, height, messages);
        } else {
            ProresFix.checkPicture(data, width, stjs.trunc(height / 2), messages);
            ProresFix.checkPicture(data, width, stjs.trunc(height / 2), messages);
        }
        return messages;
    };
    constructor.checkPicture = function(data, width, height, messages) {
        var ph = ProresDecoder.readPictureHeader(data);
        var mbWidth = (width + 15) >> 4;
        var mbHeight = (height + 15) >> 4;
        var sliceMbCount = 1 << ph.log2SliceMbWidth;
        var mbX = 0, mbY = 0;
        for (var i = 0; i < ph.sliceSizes.length; i++) {
             while (mbWidth - mbX < sliceMbCount)
                sliceMbCount >>= 1;
            try {
                ProresFix.checkSlice(NIOUtils.read(data, ph.sliceSizes[i]), sliceMbCount);
            }catch (e) {
                messages.add("[ERROR] Slice data corrupt: mbX = " + mbX + ", mbY = " + mbY + ". " + e.getMessage());
            }
            mbX += sliceMbCount;
            if (mbX == mbWidth) {
                sliceMbCount = 1 << ph.log2SliceMbWidth;
                mbX = 0;
                mbY++;
            }
        }
    };
    constructor.checkSlice = function(sliceData, sliceMbCount) {
        var sliceSize = sliceData.remaining();
        var hdrSize = (sliceData.get() & 255) >> 3;
        var qScaleOrig = sliceData.get() & 255;
        var yDataSize = sliceData.getShort();
        var uDataSize = sliceData.getShort();
        var vDataSize = sliceSize - uDataSize - yDataSize - hdrSize;
        ProresFix.checkCoeff(ProresDecoder.bitstream(sliceData, yDataSize), sliceMbCount << 2);
        ProresFix.checkCoeff(ProresDecoder.bitstream(sliceData, uDataSize), sliceMbCount << 1);
        ProresFix.checkCoeff(ProresDecoder.bitstream(sliceData, vDataSize), sliceMbCount << 1);
    };
    constructor.checkCoeff = function(ib, blocksPerSlice) {
        var scan = new Int32Array(64);
        var out = new Int32Array(blocksPerSlice << 6);
        ProresFix.readDCCoeffs(ib, out, blocksPerSlice);
        ProresFix.readACCoeffs(ib, out, blocksPerSlice, scan);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Individual Channel Stream info, AAC block
 *  
 *  @author The JCodec project
 *  
 */
var BlockICS = function() {
    Block.call(this);
    this.ff_aac_codebook_vector_vals = [AACTab.codebook_vector0_vals, AACTab.codebook_vector0_vals, AACTab.codebook_vector10_vals, AACTab.codebook_vector10_vals, AACTab.codebook_vector4_vals, AACTab.codebook_vector4_vals, AACTab.codebook_vector10_vals, AACTab.codebook_vector10_vals, AACTab.codebook_vector10_vals, AACTab.codebook_vector10_vals, AACTab.codebook_vector10_vals];
    this.group_len = new Int32Array(8);
    this.band_type = new Int32Array(120);
    this.band_type_run_end = new Int32Array(120);
};
BlockICS = stjs.extend(BlockICS, Block, [], function(constructor, prototype) {
    prototype.commonWindow = false;
    prototype.scaleFlag = false;
    prototype.profile = null;
    prototype.samplingIndex = 0;
    constructor.spectral = null;
    constructor.vlc = null;
    prototype.ff_aac_codebook_vector_vals = null;
    constructor.MAX_LTP_LONG_SFB = 40;
    prototype.windowSequence = 0;
    prototype.num_window_groups = 0;
    prototype.group_len = null;
    prototype.maxSfb = 0;
    prototype.band_type = null;
    prototype.band_type_run_end = null;
    prototype.globalGain = 0;
    constructor.WindowSequence = stjs.enumeration("ONLY_LONG_SEQUENCE", "LONG_START_SEQUENCE", "EIGHT_SHORT_SEQUENCE", "LONG_STOP_SEQUENCE");
    prototype.parseICSInfo = function(_in) {
        _in.read1Bit();
        this.windowSequence = stjs.trunc(_in.readNBit(2));
        var useKbWindow = _in.read1Bit();
        this.num_window_groups = 1;
        this.group_len[0] = 1;
        if (this.windowSequence == BlockICS.WindowSequence.EIGHT_SHORT_SEQUENCE.ordinal()) {
            var max_sfb = stjs.trunc(_in.readNBit(4));
            for (var i = 0; i < 7; i++) {
                if (_in.read1Bit() != 0) {
                    this.group_len[this.num_window_groups - 1]++;
                } else {
                    this.num_window_groups++;
                    this.group_len[this.num_window_groups - 1] = 1;
                }
            }
            this.numSwb = AACTab.ff_aac_num_swb_128[this.samplingIndex];
            this.swbOffset = AACTab.ff_swb_offset_128[this.samplingIndex];
            this.numWindows = 8;
        } else {
            this.maxSfb = stjs.trunc(_in.readNBit(6));
            this.numSwb = AACTab.ff_aac_num_swb_1024[this.samplingIndex];
            this.swbOffset = AACTab.ff_swb_offset_1024[this.samplingIndex];
            this.numWindows = 1;
            var predictor_present = _in.read1Bit();
            if (predictor_present != 0) {
                if (this.profile == Profile.MAIN) {
                    this.decodePrediction(_in, this.maxSfb);
                } else if (this.profile == Profile.LC) {
                     throw new RuntimeException("Prediction is not allowed _in AAC-LC.\n");
                } else {
                    var ltpPresent = _in.read1Bit();
                    if (ltpPresent != 0) 
                        this.decodeLtp(_in, this.maxSfb);
                }
            }
        }
        return 0;
    };
    prototype.decodePrediction = function(_in, maxSfb) {
        if (_in.read1Bit() != 0) {
            var predictorResetGroup = stjs.trunc(_in.readNBit(5));
        }
        for (var sfb = 0; sfb < Math.min(maxSfb, AACTab.maxSfbTab[this.samplingIndex]); sfb++) {
            _in.read1Bit();
        }
    };
    prototype.decodeLtp = function(_in, maxSfb) {
        var lag = stjs.trunc(_in.readNBit(11));
        var coef = AACTab.ltpCoefTab[stjs.trunc(_in.readNBit(3))];
        for (var sfb = 0; sfb < Math.min(maxSfb, BlockICS.MAX_LTP_LONG_SFB); sfb++) 
            _in.read1Bit();
    };
    prototype.decodeBandTypes = function(_in) {
        var g, idx = 0;
        var bits = (this.windowSequence == BlockICS.WindowSequence.EIGHT_SHORT_SEQUENCE.ordinal()) ? 3 : 5;
        for (g = 0; g < this.num_window_groups; g++) {
            var k = 0;
             while (k < this.maxSfb){
                var sect_end = k;
                var sect_len_incr;
                var sect_band_type = stjs.trunc(_in.readNBit(4));
                if (sect_band_type == 12) {
                     throw new RuntimeException("invalid band type");
                }
                 while ((sect_len_incr = stjs.trunc(_in.readNBit(bits))) == (1 << bits) - 1)
                    sect_end += sect_len_incr;
                sect_end += sect_len_incr;
                if (!_in.moreData() || sect_len_incr == (1 << bits) - 1) {
                     throw new RuntimeException("Overread");
                }
                if (sect_end > this.maxSfb) {
                     throw new RuntimeException(String.format("Number of bands (%d) exceeds limit (%d).\n", sect_end, this.maxSfb));
                }
                for (; k < sect_end; k++) {
                    this.band_type[idx] = sect_band_type;
                    this.band_type_run_end[idx++] = sect_end;
                }
            }
        }
    };
    constructor.BandType = stjs.enumeration("ZERO_BT", "BT_1", "BT_2", "BT_3", "BT_4", "FIRST_PAIR_BT", "BT_6", "BT_7", "BT_8", "BT_9", "BT_10", "ESC_BT", "BT_12", "NOISE_BT", "INTENSITY_BT2", "INTENSITY_BT");
    constructor.ff_aac_pow2sf_tab = new Float32Array(428);
    constructor.POW_SF2_ZERO = 200;
    prototype.sfs = null;
    prototype.numSwb = 0;
    prototype.swbOffset = null;
    prototype.numWindows = 0;
    prototype.decodeScalefactors = function(_in) {
        var offset = new Int32Array([this.globalGain, this.globalGain - 90, 0]);
        var clipped_offset;
        var noise_flag = 1;
        var sf_str = ["Global gain", "Noise gain", "Intensity stereo position"];
        var idx = 0;
        for (var g = 0; g < this.num_window_groups; g++) {
            for (var i = 0; i < this.maxSfb; ) {
                var run_end = this.band_type_run_end[idx];
                if (this.band_type[idx] == BlockICS.BandType.ZERO_BT.ordinal()) {
                    for (; i < run_end; i++ , idx++) 
                        this.sfs[idx] = 0.0;
                } else if ((this.band_type[idx] == BlockICS.BandType.INTENSITY_BT.ordinal()) || (this.band_type[idx] == BlockICS.BandType.INTENSITY_BT2.ordinal())) {
                    for (; i < run_end; i++ , idx++) {
                        offset[2] += BlockICS.vlc.readVLC(_in) - 60;
                        clipped_offset = MathUtil.clip(offset[2], -155, 100);
                        if (offset[2] != clipped_offset) {
                            System.out.println(String.format("Intensity stereo position clipped (%d -> %d).\nIf you heard an audible artifact, there may be a bug _in the decoder. ", offset[2], clipped_offset));
                        }
                        this.sfs[idx] = BlockICS.ff_aac_pow2sf_tab[-clipped_offset + BlockICS.POW_SF2_ZERO];
                    }
                } else if (this.band_type[idx] == BlockICS.BandType.NOISE_BT.ordinal()) {
                    for (; i < run_end; i++ , idx++) {
                        if (noise_flag-- > 0) 
                            offset[1] += _in.readNBit(9) - 256;
                         else 
                            offset[1] += BlockICS.vlc.readVLC(_in) - 60;
                        clipped_offset = MathUtil.clip(offset[1], -100, 155);
                        if (offset[1] != clipped_offset) {
                            System.out.println(String.format("Noise gain clipped (%d -> %d).\nIf you heard an audible artifact, there may be a bug _in the decoder. ", offset[1], clipped_offset));
                        }
                        this.sfs[idx] = -BlockICS.ff_aac_pow2sf_tab[clipped_offset + BlockICS.POW_SF2_ZERO];
                    }
                } else {
                    for (; i < run_end; i++ , idx++) {
                        offset[0] += BlockICS.vlc.readVLC(_in) - 60;
                        if (offset[0] > 255) {
                             throw new RuntimeException(String.format("%s (%d) out of range.\n", sf_str[0], offset[0]));
                        }
                        this.sfs[idx] = -BlockICS.ff_aac_pow2sf_tab[offset[0] - 100 + BlockICS.POW_SF2_ZERO];
                    }
                }
            }
        }
    };
    constructor.Pulse = function(numPulse, pos, amp) {
        this.numPulse = numPulse;
        this.pos = pos;
        this.amp = amp;
    };
    constructor.Pulse = stjs.extend(constructor.Pulse, null, [], function(constructor, prototype) {
        prototype.numPulse = 0;
        prototype.pos = null;
        prototype.amp = null;
        prototype.getNumPulse = function() {
            return this.numPulse;
        };
        prototype.getPos = function() {
            return this.pos;
        };
        prototype.getAmp = function() {
            return this.amp;
        };
    }, {pos: "Int32Array", amp: "Int32Array"}, {});
    prototype.decodePulses = function(_in) {
        var pos = new Int32Array(4);
        var amp = new Int32Array(4);
        var numPulse = stjs.trunc(_in.readNBit(2)) + 1;
        var pulseSwb = stjs.trunc(_in.readNBit(6));
        if (pulseSwb >= this.numSwb) 
             throw new RuntimeException("pulseSwb >= numSwb");
        pos[0] = this.swbOffset[pulseSwb];
        pos[0] += stjs.trunc(_in.readNBit(5));
        if (pos[0] > 1023) 
             throw new RuntimeException("pos[0] > 1023");
        amp[0] = stjs.trunc(_in.readNBit(4));
        for (var i = 1; i < numPulse; i++) {
            pos[i] = stjs.trunc(_in.readNBit(5)) + pos[i - 1];
            if (pos[i] > 1023) 
                 throw new RuntimeException("pos[" + i + "] > 1023");
            amp[i] = stjs.trunc(_in.readNBit(5));
        }
        return new BlockICS.Pulse(numPulse, pos, amp);
    };
    constructor.Tns = function(nFilt, length, order, direction, coeff) {
        this.nFilt = nFilt;
        this.length = length;
        this.order = order;
        this.direction = direction;
        this.coeff = coeff;
    };
    constructor.Tns = stjs.extend(constructor.Tns, null, [], function(constructor, prototype) {
        prototype.nFilt = null;
        prototype.length = null;
        prototype.order = null;
        prototype.direction = null;
        prototype.coeff = null;
    }, {nFilt: "Int32Array", length: "Array", order: "Array", direction: "Array", coeff: "Array"}, {});
    prototype.decodeTns = function(_in) {
        var is8 = this.windowSequence == BlockICS.WindowSequence.EIGHT_SHORT_SEQUENCE.ordinal() ? 1 : 0;
        var tns_max_order = is8 != 0 ? 7 : this.profile == Profile.MAIN ? 20 : 12;
        var nFilt = new Int32Array(this.numWindows);
        var length = Array.apply(null, Array(this.numWindows)).map(function() {
            return new Int32Array(2);
        });
        var order = Array.apply(null, Array(this.numWindows)).map(function() {
            return new Int32Array(2);
        });
        var direction = Array.apply(null, Array(this.numWindows)).map(function() {
            return new Int32Array(2);
        });
        var coeff = Array.apply(null, Array(this.numWindows)).map(function() {
            return Array.apply(null, Array(2)).map(function() {
                return new Float32Array(1 << (5 - 2 * is8));
            });
        });
        for (var w = 0; w < this.numWindows; w++) {
            if ((nFilt[w] = stjs.trunc(_in.readNBit(2 - is8))) != 0) {
                var coefRes = _in.read1Bit();
                for (var filt = 0; filt < nFilt[w]; filt++) {
                    var tmp2_idx;
                    length[w][filt] = stjs.trunc(_in.readNBit(6 - 2 * is8));
                    if ((order[w][filt] = stjs.trunc(_in.readNBit(5 - 2 * is8))) > tns_max_order) {
                         throw new RuntimeException(String.format("TNS filter order %d is greater than maximum %d.\n", order[w][filt], tns_max_order));
                    }
                    if (order[w][filt] != 0) {
                        direction[w][filt] = _in.read1Bit();
                        var coefCompress = _in.read1Bit();
                        var coefLen = coefRes + 3 - coefCompress;
                        tmp2_idx = 2 * coefCompress + coefRes;
                        for (var i = 0; i < order[w][filt]; i++) 
                            coeff[w][filt][i] = AACTab.tns_tmp2_map[tmp2_idx][stjs.trunc(_in.readNBit(coefLen))];
                    }
                }
            }
        }
        return new BlockICS.Tns(nFilt, length, order, direction, coeff);
    };
    prototype.VMUL4 = function(result, idx, v, code, scale) {
        result[idx] = v[code & 3] * scale;
        result[idx + 1] = v[code >> 2 & 3] * scale;
        result[idx + 2] = v[code >> 4 & 3] * scale;
        result[idx + 3] = v[code >> 6 & 3] * scale;
    };
    prototype.VMUL4S = function(result, idx, v, code, sign, scale) {
        var nz = code >> 12;
        result[idx + 0] = v[idx & 3] * scale;
        sign <<= nz & 1;
        nz >>= 1;
        result[idx + 1] = v[idx >> 2 & 3] * scale;
        sign <<= nz & 1;
        nz >>= 1;
        result[idx + 2] = v[idx >> 4 & 3] * scale;
        sign <<= nz & 1;
        nz >>= 1;
        result[idx + 3] = v[idx >> 6 & 3] * scale;
    };
    prototype.VMUL2 = function(result, idx, v, code, scale) {
        result[idx] = v[code & 15] * scale;
        result[idx + 1] = v[code >> 4 & 15] * scale;
    };
    prototype.VMUL2S = function(result, idx, v, code, sign, scale) {
        result[idx] = v[code & 15] * scale;
        result[idx + 1] = v[code >> 4 & 15] * scale;
    };
    prototype.decodeSpectrum = function(_in) {
        var coef = new Float32Array(1024);
        var idx = 0;
        for (var g = 0; g < this.num_window_groups; g++) {
            for (var i = 0; i < this.maxSfb; i++ , idx++) {
                var cbt_m1 = this.band_type[idx] - 1;
                if (cbt_m1 < BlockICS.BandType.INTENSITY_BT2.ordinal() - 1 && cbt_m1 != BlockICS.BandType.NOISE_BT.ordinal() - 1) {
                    var vq = this.ff_aac_codebook_vector_vals[cbt_m1];
                    var vlc = BlockICS.spectral[cbt_m1];
                    switch (cbt_m1 >> 1) {
                        case 0:
                            this.readBandType1And2(_in, coef, idx, g, i, vq, vlc);
                            break;
                        case 1:
                            this.readBandType3And4(_in, coef, idx, g, i, vq, vlc);
                            break;
                        case 2:
                            this.readBandType5And6(_in, coef, idx, g, i, vq, vlc);
                            break;
                        case 3:
                        case 4:
                            this.readBandType7Through10(_in, coef, idx, g, i, vq, vlc);
                            break;
                        default:
                            this.readOther(_in, coef, idx, g, i, vq, vlc);
                    }
                }
            }
        }
    };
    prototype.readBandType3And4 = function(_in, coef, idx, g, sfb, vq, vlc) {
        var g_len = this.group_len[g];
        var cfo = this.swbOffset[sfb];
        var off_len = this.swbOffset[sfb + 1] - this.swbOffset[sfb];
        for (var group = 0; group < g_len; group++ , cfo += 128) {
            var cf = cfo;
            var len = off_len;
            do {
                var cb_idx = vlc.readVLC(_in);
                var nnz = cb_idx >> 8 & 15;
                var bits = nnz == 0 ? 0 : _in.readNBit(nnz);
                this.VMUL4S(coef, cf, vq, cb_idx, bits, this.sfs[idx]);
                cf += 4;
                len -= 4;
            } while (len > 0);
        }
    };
    prototype.readBandType7Through10 = function(_in, coef, idx, g, sfb, vq, vlc) {
        var g_len = this.group_len[g];
        var cfo = this.swbOffset[sfb];
        var off_len = this.swbOffset[sfb + 1] - this.swbOffset[sfb];
        for (var group = 0; group < g_len; group++ , cfo += 128) {
            var cf = cfo;
            var len = off_len;
            do {
                var cb_idx = vlc.readVLC(_in);
                var nnz = cb_idx >> 8 & 15;
                var bits = nnz == 0 ? 0 : (_in.readNBit(nnz) << (cb_idx >> 12));
                this.VMUL2S(coef, cf, vq, cb_idx, bits, this.sfs[idx]);
                cf += 2;
                len -= 2;
            } while (len > 0);
        }
    };
    prototype.readOther = function(_in, coef, idx, g, sfb, vq, vlc) {
        var g_len = this.group_len[g];
        var cfo = this.swbOffset[sfb];
        var off_len = this.swbOffset[sfb + 1] - this.swbOffset[sfb];
        for (var group = 0; group < g_len; group++ , cfo += 128) {
            var cf = cfo;
            var len = off_len;
            do {
                var cb_idx = vlc.readVLC(_in);
                if (cb_idx != 0) {
                    var nnz = cb_idx >> 12;
                    var nzt = cb_idx >> 8;
                    var bits = _in.readNBit(nnz) << (32 - nnz);
                    for (var j = 0; j < 2; j++) {
                        if ((nzt & 1 << j) != 0) {
                            var b;
                            var n;
                            b = ProresDecoder.nZeros(~_in.checkNBit(14));
                            if (b > 8) {
                                 throw new RuntimeException("error _in spectral data, ESC overflow\n");
                            }
                            _in.skip(b + 1);
                            b += 4;
                            n = (1 << b) + _in.readNBit(b);
                            coef[cf++] = MathUtil.cubeRoot(n) | (bits & 1 << 31);
                            bits <<= 1;
                        } else {
                            var v = stjs.trunc(vq[cb_idx & 15]);
                            coef[cf++] = (bits & 1 << 31) | v;
                        }
                        cb_idx >>= 4;
                    }
                    cf += 2;
                    len += 2;
                }
            } while (len > 0);
        }
    };
    prototype.readBandType1And2 = function(_in, coef, idx, g, sfb, vq, vlc) {
        var g_len = this.group_len[g];
        var cfo = this.swbOffset[sfb];
        var off_len = this.swbOffset[sfb + 1] - this.swbOffset[sfb];
        for (var group = 0; group < g_len; group++ , cfo += 128) {
            var cf = cfo;
            var len = off_len;
            do {
                var cb_idx = vlc.readVLC(_in);
                this.VMUL4(coef, cf, vq, cb_idx, this.sfs[idx]);
                cf += 4;
                len -= 4;
            } while (len > 0);
        }
    };
    prototype.readBandType5And6 = function(_in, coef, idx, g, sfb, vq, vlc) {
        var g_len = this.group_len[g];
        var cfo = this.swbOffset[sfb];
        var off_len = this.swbOffset[sfb + 1] - this.swbOffset[sfb];
        for (var group = 0; group < g_len; group++ , cfo += 128) {
            var cf = cfo;
            var len = off_len;
            do {
                var cb_idx = vlc.readVLC(_in);
                this.VMUL2(coef, cf, vq, cb_idx, this.sfs[idx]);
                cf += 2;
                len -= 2;
            } while (len > 0);
        }
    };
    prototype.parse = function(_in) {
        this.globalGain = stjs.trunc(_in.readNBit(8));
        if (!this.commonWindow && !this.scaleFlag) {
            this.parseICSInfo(_in);
        }
        this.decodeBandTypes(_in);
        this.decodeScalefactors(_in);
        var pulse_present = 0;
        var tns_present;
        if (!this.scaleFlag) {
            if ((pulse_present = _in.read1Bit()) != 0) {
                if (this.windowSequence == BlockICS.WindowSequence.EIGHT_SHORT_SEQUENCE.ordinal()) {
                     throw new RuntimeException("Pulse tool not allowed _in eight short sequence.");
                }
                this.decodePulses(_in);
            }
            if ((tns_present = _in.read1Bit()) != 0) {
                this.decodeTns(_in);
            }
            if (_in.read1Bit() != 0) {
                 throw new RuntimeException("SSR is not supported");
            }
        }
        this.decodeSpectrum(_in);
    };
}, {profile: {name: "Enum", arguments: ["Profile"]}, spectral: "Array", vlc: "VLC", ff_aac_codebook_vector_vals: "Array", group_len: "Int32Array", band_type: "Int32Array", band_type_run_end: "Int32Array", ff_aac_pow2sf_tab: "Float32Array", sfs: "Float64Array", swbOffset: "Int32Array", type: {name: "Enum", arguments: ["BlockType"]}}, {});
(function() {
    BlockICS.vlc = new VLC(AACTab.ff_aac_scalefactor_code, AACTab.ff_aac_scalefactor_bits);
    BlockICS.spectral = [VLCBuilder.createVLCBuilder(AACTab.codes1, AACTab.bits1, AACTab.codebook_vector02_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes2, AACTab.bits2, AACTab.codebook_vector02_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes3, AACTab.bits3, AACTab.codebook_vector02_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes4, AACTab.bits4, AACTab.codebook_vector02_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes5, AACTab.bits5, AACTab.codebook_vector4_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes6, AACTab.bits6, AACTab.codebook_vector4_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes7, AACTab.bits7, AACTab.codebook_vector6_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes8, AACTab.bits8, AACTab.codebook_vector6_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes9, AACTab.bits9, AACTab.codebook_vector8_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes10, AACTab.bits10, AACTab.codebook_vector8_idx).getVLC(), VLCBuilder.createVLCBuilder(AACTab.codes11, AACTab.bits11, AACTab.codebook_vector10_idx).getVLC()];
})();
(function() {
    var i;
    for (i = 0; i < 428; i++) 
        BlockICS.ff_aac_pow2sf_tab[i] = Math.pow(2, (i - BlockICS.POW_SF2_ZERO) / 4.0);
})();
/**
 *  
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Decodes a ProRes file in low res. Decodes each 8x8 block as 1 pixel.
 *  
 *  @author The JCodec project
 *  
 */
var ProresToThumb = function() {
    ProresDecoder.call(this);
};
ProresToThumb = stjs.extend(ProresToThumb, ProresDecoder, [], function(constructor, prototype) {
    prototype.decodeOnePlane = function(bits, blocksPerSlice, out, qMat, scan, mbX, mbY, plane) {
        try {
            ProresDecoder.readDCCoeffs(bits, qMat, out, blocksPerSlice, 1);
        }catch (e) {
            System.err.println("Suppressing slice error at [" + mbX + ", " + mbY + "].");
        }
        for (var i = 0; i < blocksPerSlice; i++) {
            out[i] >>= 3;
        }
    };
    prototype.decodeFrameHiBD = function(data, target, lowBits) {
        var fh = ProresDecoder.readFrameHeader(data);
        var codedWidth = ((fh.width + 15) & ~15) >> 3;
        var codedHeight = ((fh.height + 15) & ~15) >> 3;
        var lumaSize = codedWidth * codedHeight;
        var chromaSize = lumaSize >> 1;
        if (target == null || target[0].length < lumaSize || target[1].length < chromaSize || target[2].length < chromaSize) {
             throw new RuntimeException("Provided output picture won't fit into provided buffer");
        }
        if (fh.frameType == 0) {
            this.decodePicture(data, target, lowBits, codedWidth, codedHeight, codedWidth >> 1, fh.qMatLuma, fh.qMatChroma, new Int32Array([0]), 0, fh.chromaType);
        } else {
            this.decodePicture(data, target, lowBits, codedWidth, codedHeight >> 1, codedWidth >> 1, fh.qMatLuma, fh.qMatChroma, new Int32Array([0]), fh.topFieldFirst ? 1 : 2, fh.chromaType);
            this.decodePicture(data, target, lowBits, codedWidth, codedHeight >> 1, codedWidth >> 1, fh.qMatLuma, fh.qMatChroma, new Int32Array([0]), fh.topFieldFirst ? 2 : 1, fh.chromaType);
        }
        var color = fh.chromaType == 2 ? ColorSpace.YUV422 : ColorSpace.YUV444;
        return new Picture(codedWidth, codedHeight, target, lowBits, color, lowBits == null ? 0 : 2, new Rect(0, 0, (fh.width >> 3) & color.getWidthMask(), (fh.height >> 3) & color.getHeightMask()));
    };
    prototype.putSlice = function(result, lowBits, lumaStride, mbX, mbY, y, u, v, dist, shift, chromaType, sliceMbCount) {
        var chromaStride = lumaStride >> 1;
        this._putLuma(result[0], lowBits != null ? lowBits[0] : null, shift * lumaStride, lumaStride << dist, mbX, mbY, y, sliceMbCount, dist, shift);
        if (chromaType == 2) {
            this._putChroma(result[1], lowBits != null ? lowBits[1] : null, shift * chromaStride, chromaStride << dist, mbX, mbY, u, sliceMbCount, dist, shift);
            this._putChroma(result[2], lowBits != null ? lowBits[2] : null, shift * chromaStride, chromaStride << dist, mbX, mbY, v, sliceMbCount, dist, shift);
        } else {
            this._putLuma(result[1], lowBits != null ? lowBits[1] : null, shift * lumaStride, lumaStride << dist, mbX, mbY, u, sliceMbCount, dist, shift);
            this._putLuma(result[2], lowBits != null ? lowBits[2] : null, shift * lumaStride, lumaStride << dist, mbX, mbY, v, sliceMbCount, dist, shift);
        }
    };
    prototype._putLuma = function(y, lowBits, _off, stride, mbX, mbY, luma, mbPerSlice, dist, shift) {
        var off = _off + (mbX << 1) + (mbY << 1) * stride;
        for (var k = 0, sOff = 0; k < mbPerSlice; k++) {
            var round0 = MathUtil.clip((luma[sOff] + 2) >> 2, 1, 255);
            y[off] = ((round0 - 128) << 24 >> 24);
            var round1 = MathUtil.clip((luma[sOff + 1] + 2) >> 2, 1, 255);
            y[off + 1] = ((round1 - 128) << 24 >> 24);
            off += stride;
            var round2 = MathUtil.clip((luma[sOff + 2] + 2) >> 2, 1, 255);
            y[off] = ((round2 - 128) << 24 >> 24);
            var round3 = MathUtil.clip((luma[sOff + 3] + 2) >> 2, 1, 255);
            y[off + 1] = ((round3 - 128) << 24 >> 24);
            off += 2 - stride;
            sOff += 4;
        }
        if (lowBits != null) {
            off = _off + (mbX << 1) + (mbY << 1) * stride;
            for (var k = 0, sOff = 0; k < mbPerSlice; k++) {
                var val0 = MathUtil.clip(luma[sOff], 4, 1019);
                var round0 = MathUtil.clip((luma[sOff] + 2) >> 2, 1, 255);
                lowBits[off] = ((val0 - (round0 << 2)) << 24 >> 24);
                var val1 = MathUtil.clip(luma[sOff + 1], 4, 1019);
                var round1 = MathUtil.clip((luma[sOff + 1] + 2) >> 2, 1, 255);
                lowBits[off + 1] = ((val1 - (round1 << 2)) << 24 >> 24);
                off += stride;
                var val2 = MathUtil.clip(luma[sOff + 2], 4, 1019);
                var round2 = MathUtil.clip((luma[sOff + 2] + 2) >> 2, 1, 255);
                lowBits[off] = ((val2 - (round2 << 2)) << 24 >> 24);
                var val3 = MathUtil.clip(luma[sOff + 3], 4, 1019);
                var round3 = MathUtil.clip((luma[sOff + 3] + 2) >> 2, 1, 255);
                lowBits[off + 1] = ((val3 - (round3 << 2)) << 24 >> 24);
                off += 2 - stride;
                sOff += 4;
            }
        }
    };
    prototype._putChroma = function(y, lowBits, _off, stride, mbX, mbY, chroma, mbPerSlice, dist, shift) {
        var off = _off + mbX + (mbY << 1) * stride;
        for (var k = 0, sOff = 0; k < mbPerSlice; k++) {
            var round0 = MathUtil.clip((chroma[sOff] + 2) >> 2, 1, 255);
            y[off] = ((round0 - 128) << 24 >> 24);
            off += stride;
            var round1 = MathUtil.clip((chroma[sOff + 1] + 2) >> 2, 1, 255);
            y[off] = ((round1 - 128) << 24 >> 24);
            off += 1 - stride;
            sOff += 2;
        }
        if (lowBits != null) {
            off = _off + mbX + (mbY << 1) * stride;
            for (var k = 0, sOff = 0; k < mbPerSlice; k++) {
                var val0 = MathUtil.clip(chroma[sOff], 4, 1019);
                var round0 = MathUtil.clip((chroma[sOff] + 2) >> 2, 1, 255);
                lowBits[off] = ((val0 - (round0 << 2)) << 24 >> 24);
                off += stride;
                var val1 = MathUtil.clip(chroma[sOff + 1], 4, 1019);
                var round1 = MathUtil.clip((chroma[sOff + 1] + 2) >> 2, 1, 255);
                lowBits[off] = ((val1 - (round1 << 2)) << 24 >> 24);
                off += 1 - stride;
                sOff += 2;
            }
        }
    };
}, {table: "Int32Array", mask: "Int32Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var ICSInfo = function(frameLength) {
    this.frameLength = frameLength;
    this.windowShape = new Int32Array(2);
    this.windowSequence = ICSInfo.WindowSequence.ONLY_LONG_SEQUENCE;
    this.windowGroupLength = new Int32Array(SyntaxConstants.MAX_WINDOW_GROUP_COUNT);
    this.ltpData1Present = false;
    this.ltpData2Present = false;
};
ICSInfo = stjs.extend(ICSInfo, null, [SyntaxConstants, ScaleFactorBands], function(constructor, prototype) {
    constructor.LTPrediction = function(frameLength) {
        this.frameLength = frameLength;
        this.states = new Int32Array(4 * frameLength);
    };
    constructor.LTPrediction = stjs.extend(constructor.LTPrediction, null, [SyntaxConstants], function(constructor, prototype) {
        constructor.CODEBOOK = new Float32Array([0.570829, 0.696616, 0.813004, 0.911304, 0.9849, 1.067894, 1.194601, 1.369533]);
        prototype.frameLength = 0;
        prototype.states = null;
        prototype.coef = 0;
        prototype.lag = 0;
        prototype.lastBand = 0;
        prototype.lagUpdate = false;
        prototype.shortUsed = null;
        prototype.shortLagPresent = null;
        prototype.longUsed = null;
        prototype.shortLag = null;
        prototype.decode = function(_in, info, profile) {
            this.lag = 0;
            if (profile.equals(Profile.AAC_LD)) {
                this.lagUpdate = _in.readBool();
                if (this.lagUpdate) 
                    this.lag = _in.readBits(10);
            } else 
                this.lag = _in.readBits(11);
            if (this.lag > (this.frameLength << 1)) 
                 throw new AACException("LTP lag too large: " + this.lag);
            this.coef = _in.readBits(3);
            var windowCount = info.getWindowCount();
            if (info.isEightShortFrame()) {
                this.shortUsed = new Int8Array(windowCount);
                this.shortLagPresent = new Int8Array(windowCount);
                this.shortLag = new Int32Array(windowCount);
                for (var w = 0; w < windowCount; w++) {
                    if (this.shortUsed[w] = _in.readBool()) {
                        this.shortLagPresent[w] = _in.readBool();
                        if (this.shortLagPresent[w]) 
                            this.shortLag[w] = _in.readBits(4);
                    }
                }
            } else {
                this.lastBand = Math.min(info.getMaxSFB(), SyntaxConstants.MAX_LTP_SFB);
                this.longUsed = new Int8Array(this.lastBand);
                for (var i = 0; i < this.lastBand; i++) {
                    this.longUsed[i] = _in.readBool();
                }
            }
        };
        prototype.setPredictionUnused = function(sfb) {
            if (this.longUsed != null) 
                this.longUsed[sfb] = false;
        };
        prototype.process = function(ics, data, filterBank, sf) {
            var info = ics.getInfo();
            if (!info.isEightShortFrame()) {
                var samples = this.frameLength << 1;
                var _in = new Float32Array(2048);
                var out = new Float32Array(2048);
                for (var i = 0; i < samples; i++) {
                    _in[i] = this.states[samples + i - this.lag] * ICSInfo.LTPrediction.CODEBOOK[this.coef];
                }
                filterBank.processLTP(info.getWindowSequence(), info.getWindowShape(ICSInfo.CURRENT), info.getWindowShape(ICSInfo.PREVIOUS), _in, out);
                if (ics.isTNSDataPresent()) 
                    ics.getTNS().process(ics, out, sf, true);
                var swbOffsets = info.getSWBOffsets();
                var swbOffsetMax = info.getSWBOffsetMax();
                var low, high, bin;
                for (var sfb = 0; sfb < this.lastBand; sfb++) {
                    if (this.longUsed[sfb]) {
                        low = swbOffsets[sfb];
                        high = Math.min(swbOffsets[sfb + 1], swbOffsetMax);
                        for (bin = low; bin < high; bin++) {
                            data[bin] += out[bin];
                        }
                    }
                }
            }
        };
        prototype.updateState = function(time, overlap, profile) {
            var i;
            if (profile.equals(Profile.AAC_LD)) {
                for (i = 0; i < this.frameLength; i++) {
                    this.states[i] = this.states[i + this.frameLength];
                    this.states[this.frameLength + i] = this.states[i + (this.frameLength * 2)];
                    this.states[(this.frameLength * 2) + i] = Math.round(time[i]);
                    this.states[(this.frameLength * 3) + i] = Math.round(overlap[i]);
                }
            } else {
                for (i = 0; i < this.frameLength; i++) {
                    this.states[i] = this.states[i + this.frameLength];
                    this.states[this.frameLength + i] = Math.round(time[i]);
                    this.states[(this.frameLength * 2) + i] = Math.round(overlap[i]);
                }
            }
        };
        constructor.isLTPProfile = function(profile) {
            return profile.equals(Profile.AAC_LTP) || profile.equals(Profile.ER_AAC_LTP) || profile.equals(Profile.AAC_LD);
        };
        prototype.copy = function(ltp) {
            System.arraycopy(ltp.states, 0, this.states, 0, this.states.length);
            this.coef = ltp.coef;
            this.lag = ltp.lag;
            this.lastBand = ltp.lastBand;
            this.lagUpdate = ltp.lagUpdate;
            this.shortUsed = Platform.copyOfBool(ltp.shortUsed, ltp.shortUsed.length);
            this.shortLagPresent = Platform.copyOfBool(ltp.shortLagPresent, ltp.shortLagPresent.length);
            this.shortLag = Platform.copyOfInt(ltp.shortLag, ltp.shortLag.length);
            this.longUsed = Platform.copyOfBool(ltp.longUsed, ltp.longUsed.length);
        };
    }, {CODEBOOK: "Float32Array", states: "Int32Array", shortUsed: "Int8Array", shortLagPresent: "Int8Array", longUsed: "Int8Array", shortLag: "Int32Array"}, {});
    constructor.WINDOW_SHAPE_SINE = 0;
    constructor.WINDOW_SHAPE_KAISER = 1;
    constructor.PREVIOUS = 0;
    constructor.CURRENT = 1;
    constructor.WindowSequence = stjs.enumeration("ONLY_LONG_SEQUENCE", "LONG_START_SEQUENCE", "EIGHT_SHORT_SEQUENCE", "LONG_STOP_SEQUENCE");
    constructor.windowSequenceFromInt = function(i) {
        var values = ICSInfo.WindowSequence.values();
        if (i >= values.length) {
             throw new AACException("unknown window sequence type");
        }
        return values[i];
    };
    prototype.frameLength = 0;
    prototype.windowSequence = null;
    prototype.windowShape = null;
    prototype.maxSFB = 0;
    prototype.predictionDataPresent = false;
    prototype.icPredict = null;
    prototype.ltpData1Present = false;
    prototype.ltpData2Present = false;
    prototype.ltPredict1 = null;
    prototype.ltPredict2 = null;
    prototype.windowCount = 0;
    prototype.windowGroupCount = 0;
    prototype.windowGroupLength = null;
    prototype.swbCount = 0;
    prototype.swbOffsets = null;
    prototype.decode = function(_in, conf, commonWindow) {
        var sf = conf.getSampleFrequency();
        if (sf.equals(SampleFrequency.SAMPLE_FREQUENCY_NONE)) 
             throw new AACException("invalid sample frequency");
        _in.skipBit();
        this.windowSequence = ICSInfo.windowSequenceFromInt(_in.readBits(2));
        this.windowShape[ICSInfo.PREVIOUS] = this.windowShape[ICSInfo.CURRENT];
        this.windowShape[ICSInfo.CURRENT] = _in.readBit();
        this.windowGroupCount = 1;
        this.windowGroupLength[0] = 1;
        if (this.windowSequence.equals(ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE)) {
            this.maxSFB = _in.readBits(4);
            var i;
            for (i = 0; i < 7; i++) {
                if (_in.readBool()) 
                    this.windowGroupLength[this.windowGroupCount - 1]++;
                 else {
                    this.windowGroupCount++;
                    this.windowGroupLength[this.windowGroupCount - 1] = 1;
                }
            }
            this.windowCount = 8;
            this.swbOffsets = ScaleFactorBands.SWB_OFFSET_SHORT_WINDOW[sf.getIndex()];
            this.swbCount = ScaleFactorBands.SWB_SHORT_WINDOW_COUNT[sf.getIndex()];
            this.predictionDataPresent = false;
        } else {
            this.maxSFB = _in.readBits(6);
            this.windowCount = 1;
            this.swbOffsets = ScaleFactorBands.SWB_OFFSET_LONG_WINDOW[sf.getIndex()];
            this.swbCount = ScaleFactorBands.SWB_LONG_WINDOW_COUNT[sf.getIndex()];
            this.predictionDataPresent = _in.readBool();
            if (this.predictionDataPresent) 
                this.readPredictionData(_in, conf.getProfile(), sf, commonWindow);
        }
    };
    prototype.readPredictionData = function(_in, profile, sf, commonWindow) {
        if (Profile.AAC_MAIN == profile) {
            if (this.icPredict == null) 
                this.icPredict = new ICPrediction();
            this.icPredict.decode(_in, this.maxSFB, sf);
        } else if (Profile.AAC_LTP == profile) {
            if (this.ltpData1Present = _in.readBool()) {
                if (this.ltPredict1 == null) 
                    this.ltPredict1 = new ICSInfo.LTPrediction(this.frameLength);
                this.ltPredict1.decode(_in, this, profile);
            }
            if (commonWindow) {
                if (this.ltpData2Present = _in.readBool()) {
                    if (this.ltPredict2 == null) 
                        this.ltPredict2 = new ICSInfo.LTPrediction(this.frameLength);
                    this.ltPredict2.decode(_in, this, profile);
                }
            }
        } else if (Profile.ER_AAC_LTP == profile) {
            if (!commonWindow) {
                if (this.ltpData1Present = _in.readBool()) {
                    if (this.ltPredict1 == null) 
                        this.ltPredict1 = new ICSInfo.LTPrediction(this.frameLength);
                    this.ltPredict1.decode(_in, this, profile);
                }
            }
        } else {
             throw new AACException("unexpected profile for LTP: " + profile);
        }
    };
    prototype.getMaxSFB = function() {
        return this.maxSFB;
    };
    prototype.getSWBCount = function() {
        return this.swbCount;
    };
    prototype.getSWBOffsets = function() {
        return this.swbOffsets;
    };
    prototype.getSWBOffsetMax = function() {
        return this.swbOffsets[this.swbCount];
    };
    prototype.getWindowCount = function() {
        return this.windowCount;
    };
    prototype.getWindowGroupCount = function() {
        return this.windowGroupCount;
    };
    prototype.getWindowGroupLength = function(g) {
        return this.windowGroupLength[g];
    };
    prototype.getWindowSequence = function() {
        return this.windowSequence;
    };
    prototype.isEightShortFrame = function() {
        return this.windowSequence.equals(ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE);
    };
    prototype.getWindowShape = function(index) {
        return this.windowShape[index];
    };
    prototype.isICPredictionPresent = function() {
        return this.predictionDataPresent;
    };
    prototype.getICPrediction = function() {
        return this.icPredict;
    };
    prototype.isLTPrediction1Present = function() {
        return this.ltpData1Present;
    };
    prototype.getLTPrediction1 = function() {
        return this.ltPredict1;
    };
    prototype.isLTPrediction2Present = function() {
        return this.ltpData2Present;
    };
    prototype.getLTPrediction2 = function() {
        return this.ltPredict2;
    };
    prototype.unsetPredictionSFB = function(sfb) {
        if (this.predictionDataPresent) 
            this.icPredict.setPredictionUnused(sfb);
        if (this.ltpData1Present) 
            this.ltPredict1.setPredictionUnused(sfb);
        if (this.ltpData2Present) 
            this.ltPredict2.setPredictionUnused(sfb);
    };
    prototype.setData = function(info) {
        this.windowSequence = ICSInfo.WindowSequence.valueOf(info.windowSequence.name());
        this.windowShape[ICSInfo.PREVIOUS] = this.windowShape[ICSInfo.CURRENT];
        this.windowShape[ICSInfo.CURRENT] = info.windowShape[ICSInfo.CURRENT];
        this.maxSFB = info.maxSFB;
        this.predictionDataPresent = info.predictionDataPresent;
        if (this.predictionDataPresent) 
            this.icPredict = info.icPredict;
        this.ltpData1Present = info.ltpData1Present;
        if (this.ltpData1Present) {
            this.ltPredict1.copy(info.ltPredict1);
            this.ltPredict2.copy(info.ltPredict2);
        }
        this.windowCount = info.windowCount;
        this.windowGroupCount = info.windowGroupCount;
        this.windowGroupLength = Platform.copyOfInt(info.windowGroupLength, info.windowGroupLength.length);
        this.swbCount = info.swbCount;
        this.swbOffsets = Platform.copyOfInt(info.swbOffsets, info.swbOffsets.length);
    };
}, {windowSequence: {name: "Enum", arguments: ["ICSInfo.WindowSequence"]}, windowShape: "Int32Array", icPredict: "ICPrediction", ltPredict1: "ICSInfo.LTPrediction", ltPredict2: "ICSInfo.LTPrediction", windowGroupLength: "Int32Array", swbOffsets: "Int32Array", SWB_LONG_WINDOW_COUNT: "Int32Array", SWB_OFFSET_1024_96: "Int32Array", SWB_OFFSET_1024_64: "Int32Array", SWB_OFFSET_1024_48: "Int32Array", SWB_OFFSET_1024_32: "Int32Array", SWB_OFFSET_1024_24: "Int32Array", SWB_OFFSET_1024_16: "Int32Array", SWB_OFFSET_1024_8: "Int32Array", SWB_OFFSET_LONG_WINDOW: "Array", SWB_SHORT_WINDOW_COUNT: "Int32Array", SWB_OFFSET_128_96: "Int32Array", SWB_OFFSET_128_64: "Int32Array", SWB_OFFSET_128_48: "Int32Array", SWB_OFFSET_128_24: "Int32Array", SWB_OFFSET_128_16: "Int32Array", SWB_OFFSET_128_8: "Int32Array", SWB_OFFSET_SHORT_WINDOW: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FileDescriptor = function(ul) {
    GenericDescriptor.call(this, ul);
};
FileDescriptor = stjs.extend(FileDescriptor, GenericDescriptor, [], function(constructor, prototype) {
    prototype.linkedTrackId = 0;
    prototype.sampleRate = null;
    prototype.containerDuration = 0;
    prototype.essenceContainer = null;
    prototype.codec = null;
    prototype.read = function(tags) {
        GenericDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 12294:
                    this.linkedTrackId = _bb.getInt();
                    break;
                case 12289:
                    this.sampleRate = new Rational(_bb.getInt(), _bb.getInt());
                    break;
                case 12290:
                    this.containerDuration = _bb.getLong();
                    break;
                case 12292:
                    this.essenceContainer = UL.read(_bb);
                    break;
                case 12293:
                    this.codec = UL.read(_bb);
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getLinkedTrackId = function() {
        return this.linkedTrackId;
    };
    prototype.getSampleRate = function() {
        return this.sampleRate;
    };
    prototype.getContainerDuration = function() {
        return this.containerDuration;
    };
    prototype.getEssenceContainer = function() {
        return this.essenceContainer;
    };
    prototype.getCodec = function() {
        return this.codec;
    };
}, {sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var TimecodeComponent = function(ul) {
    MXFStructuralComponent.call(this, ul);
};
TimecodeComponent = stjs.extend(TimecodeComponent, MXFStructuralComponent, [], function(constructor, prototype) {
    prototype.start = 0;
    prototype.base = 0;
    prototype.dropFrame = 0;
    prototype.read = function(tags) {
        MXFStructuralComponent.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 5377:
                    this.start = _bb.getLong();
                    break;
                case 5378:
                    this.base = _bb.getShort();
                    break;
                case 5379:
                    this.dropFrame = _bb.get();
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getStart = function() {
        return this.start;
    };
    prototype.getBase = function() {
        return this.base;
    };
    prototype.getDropFrame = function() {
        return this.dropFrame;
    };
}, {dataDefinitionUL: "UL", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SourceClip = function(ul) {
    MXFStructuralComponent.call(this, ul);
};
SourceClip = stjs.extend(SourceClip, MXFStructuralComponent, [], function(constructor, prototype) {
    prototype.startPosition = 0;
    prototype.sourceTrackId = 0;
    prototype.sourcePackageUid = null;
    prototype.read = function(tags) {
        MXFStructuralComponent.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 4609:
                    this.startPosition = _bb.getLong();
                    break;
                case 4353:
                    this.sourcePackageUid = UL.read(_bb);
                    break;
                case 4354:
                    this.sourceTrackId = _bb.getInt();
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getSourcePackageUid = function() {
        return this.sourcePackageUid;
    };
    prototype.getStartPosition = function() {
        return this.startPosition;
    };
    prototype.getSourceTrackId = function() {
        return this.sourceTrackId;
    };
}, {sourcePackageUid: "UL", dataDefinitionUL: "UL", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var Sequence = function(ul) {
    MXFStructuralComponent.call(this, ul);
};
Sequence = stjs.extend(Sequence, MXFStructuralComponent, [], function(constructor, prototype) {
    prototype.structuralComponentsRefs = null;
    prototype.read = function(tags) {
        MXFStructuralComponent.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            switch (entry.getKey()) {
                case 4097:
                    this.structuralComponentsRefs = MXFMetadata.readULBatch(entry.getValue());
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getStructuralComponentsRefs = function() {
        return this.structuralComponentsRefs;
    };
}, {structuralComponentsRefs: "Array", dataDefinitionUL: "UL", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Gets media info from MPEG TS file
 *  
 *  @author The JCodec project
 *  
 */
var MTSMediaInfo = function() {};
MTSMediaInfo = stjs.extend(MTSMediaInfo, null, [], function(constructor, prototype) {
    prototype.getMediaInfo = function(f) {
        var ch = null;
        var pmtSections = new ArrayList();
        var pids = new HashMap();
        var result = new ArrayList();
        try {
            ch = NIOUtils.readableChannel(f);
            new (stjs.extend(function MTSMediaInfo$1(x0) {
                MTSUtils.TSReader.call(this, x0);
            }, MTSUtils.TSReader, [], function(constructor, prototype) {
                prototype.pmtBuffer = null;
                prototype.pmtPid = -1;
                prototype.pmtDone = false;
                prototype.onPkt = function(guid, payloadStart, tsBuf, filePos, sectionSyntax, fullPkt) {
                    if (guid == 0) {
                        this.pmtPid = MTSUtils.parsePAT(tsBuf);
                    } else if (guid == this.pmtPid && !this.pmtDone) {
                        if (this.pmtBuffer == null) {
                            this.pmtBuffer = ByteBuffer.allocate(((tsBuf.duplicate().getInt() >> 8) & 1023) + 3);
                        } else if (this.pmtBuffer.hasRemaining()) {
                            NIOUtils.writeL(this.pmtBuffer, tsBuf, Math.min(this.pmtBuffer.remaining(), tsBuf.remaining()));
                        }
                        if (!this.pmtBuffer.hasRemaining()) {
                            this.pmtBuffer.flip();
                            var pmt = MTSUtils.parsePMT(this.pmtBuffer);
                            pmtSections.add(pmt);
                            var streams = pmt.getStreams();
                            for (var i = 0; i < streams.length; i++) {
                                var stream = streams[i];
                                if (!pids.containsKey(stream.getPid())) 
                                    pids.put(stream.getPid(), new MPSMediaInfo());
                            }
                            this.pmtDone = pmt.getSectionNumber() == pmt.getLastSectionNumber();
                            this.pmtBuffer = null;
                        }
                    } else if (pids.containsKey(guid)) {
                        try {
                            pids.get(guid).analyseBuffer(tsBuf, filePos);
                        }catch (e) {
                            result.addAll(pids.get(guid).getInfos());
                            pids.remove(guid);
                            if (pids.size() == 0) 
                                return false;
                        }
                    }
                    return true;
                };
            }, {pmtBuffer: "ByteBuffer"}, {}))(false).readTsFile(ch);
        } finally {
            NIOUtils.closeQuietly(ch);
        }
        return result;
    };
    constructor.main1 = function(args) {
        var info = new MTSMediaInfo().getMediaInfo(new File(args[0]));
        for (var iterator$stream = info.iterator(); iterator$stream.hasNext(); ) {
            var stream = iterator$stream.next();
            System.out.println(stream.codec);
        }
    };
    constructor.extract = function(input) {
        return null;
    };
    prototype.getVideoTrack = function() {
        return null;
    };
    prototype.getAudioTracks = function() {
        return null;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Indexes MPEG PS file for the purpose of quick random access in the future
 *  
 *  @author The JCodec project
 *  
 */
var MPSIndexer = function() {
    BaseIndexer.call(this);
};
MPSIndexer = stjs.extend(MPSIndexer, BaseIndexer, [], function(constructor, prototype) {
    prototype.predFileStart = 0;
    prototype.index = function(source, listener) {
        this.newReader().readFile(source, 65536, listener);
    };
    prototype.indexChannel = function(source, listener) {
        this.newReader().readChannel(source, 65536, listener);
    };
    prototype.newReader = function() {
        return new (stjs.extend(function MPSIndexer$1() {
            NIOUtils.FileReader.call(this);
        }, NIOUtils.FileReader, [], function(constructor, prototype) {
            prototype.data = function(data, filePos) {
                this.analyseBuffer(data, filePos);
            };
            prototype.done = function() {
                this.finishAnalyse();
            };
        }, {}, {}))();
    };
    prototype.pes = function(pesBuffer, start, pesLen, stream) {
        if (!MPSUtils.mediaStream(stream)) 
            return;
        var pesHeader = MPSUtils.readPESHeader(pesBuffer, start);
        var leading = 0;
        if (this.predFileStart != start) {
            leading += (((start - this.predFileStart)) | 0);
        }
        this.predFileStart = start + pesLen;
        this.savePESMeta(stream, MPSIndex.makePESToken(leading, pesLen, pesBuffer.remaining()));
        this.getAnalyser(stream).pkt(pesBuffer, pesHeader);
    };
    constructor.main1 = function(args) {
        var indexer = new MPSIndexer();
        indexer.index(new File(args[0]), new (stjs.extend(function MPSIndexer$2() {}, null, [NIOUtils.FileReaderListener], function(constructor, prototype) {
            prototype.progress = function(percentDone) {
                System.out.println(percentDone);
            };
        }, {}, {}))());
        var index = ByteBuffer.allocate(65536);
        indexer.serialize().serializeTo(index);
        NIOUtils.writeTo(index, new File(args[1]));
    };
}, {analyzers: {name: "Map", arguments: [null, "BaseIndexer.BaseAnalyser"]}, tokens: "LongArrayList", streams: "RunLength.Integer", pesBuffer: "ByteBuffer"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Indexes MPEG TS file for the purpose of quick random access in the future
 *  
 *  @author The JCodec project
 *  
 */
var MTSIndexer = function() {};
MTSIndexer = stjs.extend(MTSIndexer, null, [], function(constructor, prototype) {
    constructor.BUFFER_SIZE = 188 << 9;
    prototype.indexers = null;
    prototype.index = function(source, listener) {
        this.indexReader(listener, MTSUtils.getMediaPids(source)).readFile(source, MTSIndexer.BUFFER_SIZE, listener);
    };
    prototype.indexChannel = function(source, listener) {
        this.indexReader(listener, MTSUtils.getMediaPidsFromChannel(source)).readChannel(source, MTSIndexer.BUFFER_SIZE, listener);
    };
    prototype.indexReader = function(listener, targetGuids) {
        this.indexers = Array(targetGuids.length);
        for (var i = 0; i < targetGuids.length; i++) {
            this.indexers[i] = new MTSIndexer.MTSAnalyser(targetGuids[i]);
        }
        return new MTSIndexer.MTSFileReader(this);
    };
    prototype.serialize = function() {
        var programs = Array(this.indexers.length);
        for (var i = 0; i < this.indexers.length; i++) 
            programs[i] = this.indexers[i].serializeTo();
        return new MTSIndex(programs);
    };
    constructor.MTSFileReader = function(indexer) {
        NIOUtils.FileReader.call(this);
        this.indexer = indexer;
    };
    constructor.MTSFileReader = stjs.extend(constructor.MTSFileReader, NIOUtils.FileReader, [], function(constructor, prototype) {
        prototype.indexer = null;
        prototype.data = function(data, filePos) {
            this.analyseBuffer(data, filePos);
        };
        prototype.analyseBuffer = function(buf, pos) {
             while (buf.hasRemaining()){
                var tsBuf = NIOUtils.read(buf, 188);
                pos += 188;
                Preconditions.checkState(71 == (tsBuf.get() & 255));
                var guidFlags = ((tsBuf.get() & 255) << 8) | (tsBuf.get() & 255);
                var guid = stjs.trunc(guidFlags) & 8191;
                for (var i = 0; i < this.indexer.indexers.length; i++) {
                    if (guid == this.indexer.indexers[i].targetGuid) {
                        var payloadStart = (guidFlags >> 14) & 1;
                        var b0 = tsBuf.get() & 255;
                        var counter = b0 & 15;
                        if ((b0 & 32) != 0) {
                            NIOUtils.skip(tsBuf, tsBuf.get() & 255);
                        }
                        this.indexer.indexers[i].analyseBuffer(tsBuf, pos - tsBuf.remaining());
                    }
                }
            }
        };
        prototype.done = function() {
            for (var index$mtsAnalyser = 0, arr$mtsAnalyser = this.indexer.indexers; index$mtsAnalyser < arr$mtsAnalyser.length; index$mtsAnalyser++) {
                var mtsAnalyser = arr$mtsAnalyser[index$mtsAnalyser];
                mtsAnalyser.finishAnalyse();
            }
        };
    }, {indexer: "MTSIndexer"}, {});
    constructor.MTSAnalyser = function(targetGuid) {
        BaseIndexer.call(this);
        this.targetGuid = targetGuid;
    };
    constructor.MTSAnalyser = stjs.extend(constructor.MTSAnalyser, BaseIndexer, [], function(constructor, prototype) {
        prototype.targetGuid = 0;
        prototype.predFileStartInTsPkt = 0;
        prototype.serializeTo = function() {
            return MTSIndex.createMTSProgram(BaseIndexer.prototype.serialize.call(this), this.targetGuid);
        };
        prototype.pes = function(pesBuffer, start, pesLen, stream) {
            if (!MPSUtils.mediaStream(stream)) 
                return;
            Logger.debug(String.format("PES: %08x, %d", start, pesLen));
            var pesHeader = MPSUtils.readPESHeader(pesBuffer, start);
            var leadingTsPkt = 0;
            if (this.predFileStartInTsPkt != start) {
                leadingTsPkt = (((stjs.trunc(start / 188) - this.predFileStartInTsPkt)) | 0);
            }
            this.predFileStartInTsPkt = stjs.trunc((start + pesLen) / 188);
            var tsPktInPes = (((this.predFileStartInTsPkt - stjs.trunc(start / 188))) | 0);
            this.savePESMeta(stream, MPSIndex.makePESToken(leadingTsPkt, tsPktInPes, pesBuffer.remaining()));
            this.getAnalyser(stream).pkt(pesBuffer, pesHeader);
        };
    }, {analyzers: {name: "Map", arguments: [null, "BaseIndexer.BaseAnalyser"]}, tokens: "LongArrayList", streams: "RunLength.Integer", pesBuffer: "ByteBuffer"}, {});
    constructor.main1 = function(args) {
        var src = new File(args[0]);
        var indexer = new MTSIndexer();
        indexer.index(src, new (stjs.extend(function MTSIndexer$1() {}, null, [NIOUtils.FileReaderListener], function(constructor, prototype) {
            prototype.progress = function(percentDone) {
                System.out.println(percentDone);
            };
        }, {}, {}))());
        var index = indexer.serialize();
        NIOUtils.writeTo(index.serialize(), new File(args[1]));
    };
}, {indexers: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var TimelineTrack = function(ul) {
    GenericTrack.call(this, ul);
};
TimelineTrack = stjs.extend(TimelineTrack, GenericTrack, [], function(constructor, prototype) {
    prototype.editRate = null;
    prototype.origin = 0;
    prototype.read = function(tags) {
        GenericTrack.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 19201:
                    this.editRate = new Rational(_bb.getInt(), _bb.getInt());
                    break;
                case 19202:
                    this.origin = _bb.getLong();
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getEditRate = function() {
        return this.editRate;
    };
    prototype.getOrigin = function() {
        return this.origin;
    };
}, {editRate: "Rational", sequenceRef: "UL", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SourcePackage = function(ul) {
    GenericPackage.call(this, ul);
};
SourcePackage = stjs.extend(SourcePackage, GenericPackage, [], function(constructor, prototype) {
    prototype.trackRefs = null;
    prototype.descriptorRef = null;
    prototype.read = function(tags) {
        GenericPackage.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 18177:
                    this.descriptorRef = UL.read(_bb);
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getTrackRefs = function() {
        return this.trackRefs;
    };
    prototype.getDescriptorRef = function() {
        return this.descriptorRef;
    };
}, {trackRefs: "Array", descriptorRef: "UL", tracks: "Array", packageUID: "UL", packageModifiedDate: "jsutil.Date", packageCreationDate: "jsutil.Date", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MaterialPackage = function(ul) {
    GenericPackage.call(this, ul);
};
MaterialPackage = stjs.extend(MaterialPackage, GenericPackage, [], null, {tracks: "Array", packageUID: "UL", packageModifiedDate: "jsutil.Date", packageCreationDate: "jsutil.Date", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Decodes JPEG in low res taking only first 4 coefficients from each DCT block
 *  ( DCT 4x4 )
 *  
 *  @author The JCodec project
 *  
 */
var JpegToThumb4x4 = function() {
    JpegDecoder.call(this);
};
JpegToThumb4x4 = stjs.extend(JpegToThumb4x4, JpegDecoder, [], function(constructor, prototype) {
    constructor.mapping4x4 = new Int32Array([0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 16, 13, 10, 7, 16, 16, 16, 11, 14, 16, 16, 16, 16, 16, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]);
    prototype.decodeBlock = function(bits, dcPredictor, quant, huff, result, buf, blkX, blkY, plane, chroma, field, step) {
        buf[1] = buf[2] = buf[3] = buf[4] = buf[5] = buf[6] = buf[7] = buf[8] = buf[9] = buf[10] = buf[11] = buf[12] = buf[13] = buf[14] = buf[15] = 0;
        dcPredictor[plane] = buf[0] = this.readDCValue(bits, huff[chroma]) * quant[chroma][0] + dcPredictor[plane];
        this.readACValues(bits, buf, huff[chroma + 2], quant[chroma]);
        IDCT4x4.idct(buf, 0);
        this.putBlock4x4(result.getPlaneData(plane), result.getPlaneWidth(plane), buf, blkX, blkY, field, step);
    };
    prototype.putBlock4x4 = function(plane, stride, patch, x, y, field, step) {
        stride >>= 1;
        var dstride = step * stride;
        var off = field * stride + (y >> 1) * dstride + (x >> 1);
        for (var i = 0; i < 16; i += 4) {
            plane[off] = ((MathUtil.clip(patch[i], 0, 255) - 128) << 24 >> 24);
            plane[off + 1] = ((MathUtil.clip(patch[i + 1], 0, 255) - 128) << 24 >> 24);
            plane[off + 2] = ((MathUtil.clip(patch[i + 2], 0, 255) - 128) << 24 >> 24);
            plane[off + 3] = ((MathUtil.clip(patch[i + 3], 0, 255) - 128) << 24 >> 24);
            off += dstride;
        }
    };
    prototype.readACValues = function(_in, target, table, quantTable) {
        var code;
        var curOff = 1;
        do {
            code = table.readVLC16(_in);
            if (code == 240) {
                curOff += 16;
            } else if (code > 0) {
                var rle = code >> 4;
                curOff += rle;
                var len = code & 15;
                target[JpegToThumb4x4.mapping4x4[curOff]] = JpegDecoder.toValue(_in.readNBit(len), len) * quantTable[curOff];
                curOff++;
            }
        } while (code != 0 && curOff < 19);
        if (code != 0) {
            do {
                code = table.readVLC16(_in);
                if (code == 240) {
                    curOff += 16;
                } else if (code > 0) {
                    var rle = code >> 4;
                    curOff += rle;
                    var len = code & 15;
                    _in.skip(len);
                    curOff++;
                }
            } while (code != 0 && curOff < 64);
        }
    };
    prototype.decodeField = function(data, data2, field, step) {
        var res = JpegDecoder.prototype.decodeField.call(this, data, data2, field, step);
        return new Picture(res.getWidth() >> 1, res.getHeight() >> 1, res.getData(), null, res.getColor(), 0, new Rect(0, 0, res.getCroppedWidth() >> 1, res.getCroppedHeight() >> 1));
    };
}, {mapping4x4: "Int32Array", buf: "Int32Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Decodes JPEG in low res taking only first 4 coefficients from each DCT block
 *  ( DCT 2x2 )
 *  
 *  @author The JCodec project
 *  
 */
var JpegToThumb2x2 = function() {
    JpegDecoder.call(this);
};
JpegToThumb2x2 = stjs.extend(JpegToThumb2x2, JpegDecoder, [], function(constructor, prototype) {
    constructor.mapping2x2 = new Int32Array([0, 1, 2, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]);
    prototype.decodeBlock = function(bits, dcPredictor, quant, huff, result, buf, blkX, blkY, plane, chroma, field, step) {
        buf[1] = buf[2] = buf[3] = 0;
        dcPredictor[plane] = buf[0] = this.readDCValue(bits, huff[chroma]) * quant[chroma][0] + dcPredictor[plane];
        this.readACValues(bits, buf, huff[chroma + 2], quant[chroma]);
        IDCT2x2.idct(buf, 0);
        this.putBlock2x2(result.getPlaneData(plane), result.getPlaneWidth(plane), buf, blkX, blkY, field, step);
    };
    prototype.putBlock2x2 = function(plane, stride, patch, x, y, field, step) {
        stride >>= 2;
        var dstride = stride * step;
        var off = field * stride + (y >> 2) * dstride + (x >> 2);
        plane[off] = ((MathUtil.clip(patch[0], 0, 255) - 128) << 24 >> 24);
        plane[off + 1] = ((MathUtil.clip(patch[1], 0, 255) - 128) << 24 >> 24);
        plane[off + dstride] = ((MathUtil.clip(patch[2], 0, 255) - 128) << 24 >> 24);
        plane[off + dstride + 1] = ((MathUtil.clip(patch[3], 0, 255) - 128) << 24 >> 24);
    };
    prototype.readACValues = function(_in, target, table, quantTable) {
        var code;
        var curOff = 1;
        do {
            code = table.readVLC16(_in);
            if (code == 240) {
                curOff += 16;
            } else if (code > 0) {
                var rle = code >> 4;
                curOff += rle;
                var len = code & 15;
                target[JpegToThumb2x2.mapping2x2[curOff]] = JpegDecoder.toValue(_in.readNBit(len), len) * quantTable[curOff];
                curOff++;
            }
        } while (code != 0 && curOff < 5);
        if (code != 0) {
            do {
                code = table.readVLC16(_in);
                if (code == 240) {
                    curOff += 16;
                } else if (code > 0) {
                    var rle = code >> 4;
                    curOff += rle;
                    var len = code & 15;
                    _in.skip(len);
                    curOff++;
                }
            } while (code != 0 && curOff < 64);
        }
    };
    prototype.decodeField = function(data, data2, field, step) {
        var res = JpegDecoder.prototype.decodeField.call(this, data, data2, field, step);
        return new Picture(res.getWidth() >> 2, res.getHeight() >> 2, res.getData(), null, res.getColor(), 0, new Rect(0, 0, res.getCroppedWidth() >> 2, res.getCroppedHeight() >> 2));
    };
}, {mapping2x2: "Int32Array", buf: "Int32Array", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEG4DecodingContext = function() {
    this.intraMpegQuantMatrix = new Int16Array(64);
    this.interMpegQuantMatrix = new Int16Array(64);
    this.gmcWarps = Array.apply(null, Array(3)).map(function() {
        return new Int32Array(2);
    });
    this.estimation = new MPEG4DecodingContext.Estimation();
};
MPEG4DecodingContext = stjs.extend(MPEG4DecodingContext, null, [], function(constructor, prototype) {
    prototype.width = 0;
    prototype.height = 0;
    prototype.horiz_mc_ref = 0;
    prototype.vert_mc_ref = 0;
    prototype.intraMpegQuantMatrix = null;
    prototype.interMpegQuantMatrix = null;
    prototype.gmcWarps = null;
    prototype.mbWidth = 0;
    prototype.mbHeight = 0;
    prototype.spriteEnable = 0;
    prototype.shape = 0;
    prototype.quant = 0;
    prototype.quantBits = 0;
    prototype.timeIncrementBits = 0;
    prototype.intraDCThreshold = 0;
    prototype.spriteWarpingPoints = 0;
    prototype.reducedResolutionEnable = false;
    prototype.fcodeForward = 0;
    prototype.fcodeBackward = 0;
    prototype.newPredEnable = false;
    prototype.rounding = false;
    prototype.quarterPel = false;
    prototype.cartoonMode = false;
    prototype.lastTimeBase = 0;
    prototype.timeBase = 0;
    prototype.time = 0;
    prototype.lastNonBTime = 0;
    prototype.pframeTs = 0;
    prototype.bframeTs = 0;
    prototype.topFieldFirst = false;
    prototype.alternateVerticalScan = false;
    prototype.volVersionId = 0;
    prototype.timestampMSB = 0;
    prototype.timestampLSB = 0;
    prototype.complexityEstimationDisable = false;
    prototype.interlacing = false;
    prototype.spriteBrightnessChange = false;
    prototype.scalability = false;
    prototype.estimation = null;
    constructor.Estimation = function() {};
    constructor.Estimation = stjs.extend(constructor.Estimation, null, [], function(constructor, prototype) {
        prototype.method = 0;
        prototype.opaque = false;
        prototype.transparent = false;
        prototype.intraCae = false;
        prototype.interCae = false;
        prototype.noUpdate = false;
        prototype.upsampling = false;
        prototype.intraBlocks = false;
        prototype.interBlocks = false;
        prototype.inter4vBlocks = false;
        prototype.notCodedBlocks = false;
        prototype.dctCoefs = false;
        prototype.dctLines = false;
        prototype.vlcSymbols = false;
        prototype.vlcBits = false;
        prototype.apm = false;
        prototype.npm = false;
        prototype.interpolateMcQ = false;
        prototype.forwBackMcQ = false;
        prototype.halfpel2 = false;
        prototype.halfpel4 = false;
        prototype.sadct = false;
        prototype.quarterpel = false;
    }, {}, {});
    constructor.readFromHeaders = function(bb) {
        var ret = new MPEG4DecodingContext();
        if (ret.readHeaders(bb)) 
            return ret;
        return null;
    };
    constructor.VIDOBJ_START_CODE = 256;
    constructor.VIDOBJLAY_START_CODE = 288;
    constructor.VISOBJSEQ_START_CODE = 432;
    constructor.VISOBJSEQ_STOP_CODE = 433;
    constructor.USERDATA_START_CODE = 434;
    constructor.GRPOFVOP_START_CODE = 435;
    constructor.VISOBJ_START_CODE = 437;
    constructor.VISOBJ_TYPE_VIDEO = 1;
    constructor.VIDOBJLAY_AR_EXTPAR = 15;
    constructor.VIDOBJLAY_SHAPE_RECTANGULAR = 0;
    constructor.VIDOBJLAY_SHAPE_BINARY = 1;
    constructor.VIDOBJLAY_SHAPE_BINARY_ONLY = 2;
    constructor.VIDOBJLAY_SHAPE_GRAYSCALE = 3;
    constructor.VOP_START_CODE = 438;
    constructor.VIDOBJ_START_CODE_MASK = 31;
    constructor.VIDOBJLAY_START_CODE_MASK = 15;
    constructor.SPRITE_STATIC = 1;
    constructor.SPRITE_GMC = 2;
    constructor.VLC_CODE = 0;
    constructor.VLC_LEN = 1;
    prototype.timeIncrementResolution = 0;
    prototype.packedMode = false;
    prototype.codingType = 0;
    prototype.quantType = false;
    prototype.bsVersion = 65535;
    constructor.getMatrix = function(br, matrix) {
        var last, value = 0;
        var i = 0;
        do {
            last = value;
            value = br.readNBit(8);
            matrix[MPEG4Consts.SCAN_TABLES[0][i++]] = ((value) << 16 >> 16);
        } while (value != 0 && i < 64);
        i--;
         while (i < 64){
            matrix[MPEG4Consts.SCAN_TABLES[0][i++]] = ((last) << 16 >> 16);
        }
    };
    prototype.readHeaders = function(bb) {
        bb.order(ByteOrder.BIG_ENDIAN);
         while (bb.remaining() >= 4){
            var startCode = bb.getInt();
             while ((startCode & ~255) != 256 && bb.hasRemaining()){
                startCode <<= 8;
                startCode |= bb.get() & 255;
            }
            if (startCode == MPEG4DecodingContext.VISOBJSEQ_START_CODE) {
                var profile;
                profile = bb.get();
            } else if (startCode == MPEG4DecodingContext.VISOBJSEQ_STOP_CODE) {} else if (startCode == MPEG4DecodingContext.VISOBJ_START_CODE) {
                var verId;
                var br = BitReader.createBitReader(bb);
                if (br.readBool()) {
                    verId = br.readNBit(4);
                    br.skip(3);
                } else {
                    verId = 1;
                }
                var visual_object_type = br.readNBit(4);
                if (visual_object_type != MPEG4DecodingContext.VISOBJ_TYPE_VIDEO) {
                    return false;
                }
                if (br.readBool()) {
                    br.skip(3);
                    br.skip(1);
                    if (br.readBool()) {
                        br.skip(8);
                        br.skip(8);
                        br.skip(8);
                    }
                }
                br.terminate();
            } else if ((startCode & ~MPEG4DecodingContext.VIDOBJ_START_CODE_MASK) == MPEG4DecodingContext.VIDOBJ_START_CODE) {} else if ((startCode & ~MPEG4DecodingContext.VIDOBJLAY_START_CODE_MASK) == MPEG4DecodingContext.VIDOBJLAY_START_CODE) {
                var br = BitReader.createBitReader(bb);
                br.skip(1);
                br.skip(8);
                if (br.readBool()) {
                    this.volVersionId = br.readNBit(4);
                    br.skip(3);
                } else {
                    this.volVersionId = 1;
                }
                var aspectRatio = br.readNBit(4);
                if (aspectRatio == MPEG4DecodingContext.VIDOBJLAY_AR_EXTPAR) {
                    br.readNBit(8);
                    br.readNBit(8);
                }
                if (br.readBool()) {
                    br.skip(2);
                    var lowDelay = br.readBool();
                    if (br.readBool()) {
                        var bitrate = br.readNBit(15) << 15;
                        br.skip(1);
                        bitrate |= br.readNBit(15);
                        br.skip(1);
                        var bufferSize = br.readNBit(15) << 3;
                        br.skip(1);
                        bufferSize |= br.readNBit(3);
                        var occupancy = br.readNBit(11) << 15;
                        br.skip(1);
                        occupancy |= br.readNBit(15);
                        br.skip(1);
                    }
                }
                this.shape = br.readNBit(2);
                if (this.shape != MPEG4DecodingContext.VIDOBJLAY_SHAPE_RECTANGULAR) {}
                if (this.shape == MPEG4DecodingContext.VIDOBJLAY_SHAPE_GRAYSCALE && this.volVersionId != 1) {
                    br.skip(4);
                }
                br.skip(1);
                this.timeIncrementResolution = br.readNBit(16);
                if (this.timeIncrementResolution > 0) {
                    this.timeIncrementBits = Math.max(MathUtil.log2(this.timeIncrementResolution - 1) + 1, 1);
                } else {
                    this.timeIncrementBits = 1;
                }
                br.skip(1);
                if (br.readBool()) {
                    br.skip(this.timeIncrementBits);
                }
                if (this.shape != MPEG4DecodingContext.VIDOBJLAY_SHAPE_BINARY_ONLY) {
                    if (this.shape == MPEG4DecodingContext.VIDOBJLAY_SHAPE_RECTANGULAR) {
                        br.skip(1);
                        this.width = br.readNBit(13);
                        br.skip(1);
                        this.height = br.readNBit(13);
                        br.skip(1);
                        this.calcSizes();
                    }
                    this.interlacing = br.readBool();
                    if (!br.readBool()) {}
                    this.spriteEnable = br.readNBit((this.volVersionId == 1 ? 1 : 2));
                    if (this.spriteEnable == MPEG4DecodingContext.SPRITE_STATIC || this.spriteEnable == MPEG4DecodingContext.SPRITE_GMC) {
                        if (this.spriteEnable != MPEG4DecodingContext.SPRITE_GMC) {
                            br.readNBit(13);
                            br.skip(1);
                            br.readNBit(13);
                            br.skip(1);
                            br.readNBit(13);
                            br.skip(1);
                            br.readNBit(13);
                            br.skip(1);
                        }
                        this.spriteWarpingPoints = br.readNBit(6);
                        br.readNBit(2);
                        this.spriteBrightnessChange = br.readBool();
                        if (this.spriteEnable != MPEG4DecodingContext.SPRITE_GMC) {
                            br.readNBit(1);
                        }
                    }
                    if (this.volVersionId != 1 && this.shape != MPEG4DecodingContext.VIDOBJLAY_SHAPE_RECTANGULAR) {
                        br.skip(1);
                    }
                    if (br.readBool()) {
                        this.quantBits = br.readNBit(4);
                        br.skip(4);
                    } else {
                        this.quantBits = 5;
                    }
                    if (this.shape == MPEG4DecodingContext.VIDOBJLAY_SHAPE_GRAYSCALE) {
                        br.skip(1);
                        br.skip(1);
                        br.skip(1);
                    }
                    this.quantType = br.readBool();
                    if (this.quantType) {
                        if (br.readBool()) {
                            MPEG4DecodingContext.getMatrix(br, this.intraMpegQuantMatrix);
                        } else {
                            System.arraycopy(MPEG4Consts.DEFAULT_INTRA_MATRIX, 0, this.intraMpegQuantMatrix, 0, this.intraMpegQuantMatrix.length);
                        }
                        if (br.readBool()) {
                            MPEG4DecodingContext.getMatrix(br, this.interMpegQuantMatrix);
                        } else {
                            System.arraycopy(MPEG4Consts.DEFAULT_INTER_MATRIX, 0, this.interMpegQuantMatrix, 0, this.interMpegQuantMatrix.length);
                        }
                        if (this.shape == MPEG4DecodingContext.VIDOBJLAY_SHAPE_GRAYSCALE) {
                            return false;
                        }
                    }
                    if (this.volVersionId != 1) {
                        this.quarterPel = br.readBool();
                    } else {
                        this.quarterPel = false;
                    }
                    this.complexityEstimationDisable = br.readBool();
                    if (!this.complexityEstimationDisable) {
                        this.readVolComplexityEstimationHeader(br, this.estimation);
                    }
                    br.skip(1);
                    if (br.readBool()) {
                        br.skip(1);
                    }
                    if (this.volVersionId != 1) {
                        this.newPredEnable = br.readBool();
                        if (this.newPredEnable) {
                            br.skip(2);
                            br.skip(1);
                        }
                        this.reducedResolutionEnable = br.readBool();
                    } else {
                        this.newPredEnable = false;
                        this.reducedResolutionEnable = false;
                    }
                    this.scalability = br.readBool();
                    if (this.scalability) {
                        br.skip(1);
                        br.skip(4);
                        br.skip(1);
                        br.skip(5);
                        br.skip(5);
                        br.skip(5);
                        br.skip(5);
                        br.skip(1);
                        if (this.shape == MPEG4DecodingContext.VIDOBJLAY_SHAPE_BINARY) {
                            br.skip(1);
                            br.skip(1);
                            br.skip(5);
                            br.skip(5);
                            br.skip(5);
                            br.skip(5);
                        }
                        return false;
                    }
                } else {
                    if (this.volVersionId != 1) {
                        this.scalability = br.readBool();
                        if (this.scalability) {
                            br.skip(4);
                            br.skip(5);
                            br.skip(5);
                            br.skip(5);
                            br.skip(5);
                            return false;
                        }
                    }
                    br.skip(1);
                }
                br.terminate();
            } else if (startCode == MPEG4DecodingContext.GRPOFVOP_START_CODE) {
                var br = BitReader.createBitReader(bb);
                var hours, minutes, seconds;
                hours = br.readNBit(5);
                minutes = br.readNBit(6);
                br.skip(1);
                seconds = br.readNBit(6);
                br.skip(1);
                br.skip(1);
                br.terminate();
            } else if (startCode == MPEG4DecodingContext.VOP_START_CODE) {
                return true;
            } else if (startCode == MPEG4DecodingContext.USERDATA_START_CODE) {
                var tmp = new Int8Array(256);
                var i = 0;
                tmp[i++] = bb.get();
                for (; (tmp[i] = bb.get()) != 0; i++) 
                    ;
                bb.setPosition(bb.position() - 1);
                var userData = new String(tmp, 0, i);
                if (userData.startsWith("XviD")) {
                    if (tmp[userData.length - 1] == 'C'.charCodeAt(0)) {
                        this.bsVersion = Integer.parseInt(userData.substring(4, userData.length - 1));
                        this.cartoonMode = true;
                    } else {
                        this.bsVersion = Integer.parseInt(userData.substring(4));
                    }
                }
                if (userData.startsWith("DivX")) {
                    var version, build;
                    var packed;
                    var buildIndex = userData.indexOf("Build");
                    if (buildIndex == -1) {
                        buildIndex = userData.indexOf("b");
                    }
                    try {
                        version = Integer.parseInt(userData.substring(4, buildIndex));
                        build = Integer.parseInt(userData.substring(buildIndex + 1, userData.length - 1));
                        packed = userData.charAt(userData.length - 1);
                        this.packedMode = packed == 'p'.charCodeAt(0);
                    }catch (ignored) {}
                }
            } else {
                Logger.debug("Unknown");
            }
        }
        return false;
    };
    prototype.calcSizes = function() {
        this.mbWidth = stjs.trunc((this.width + 15) / 16);
        this.mbHeight = stjs.trunc((this.height + 15) / 16);
    };
    prototype.readVolComplexityEstimationHeader = function(br, estimation) {
        estimation.method = br.readNBit(2);
        if (estimation.method == 0 || estimation.method == 1) {
            if (!br.readBool()) {
                estimation.opaque = br.readBool();
                estimation.transparent = br.readBool();
                estimation.intraCae = br.readBool();
                estimation.interCae = br.readBool();
                estimation.noUpdate = br.readBool();
                estimation.upsampling = br.readBool();
            }
            if (!br.readBool()) {
                estimation.intraBlocks = br.readBool();
                estimation.interBlocks = br.readBool();
                estimation.inter4vBlocks = br.readBool();
                estimation.notCodedBlocks = br.readBool();
            }
        }
        br.skip(1);
        if (!br.readBool()) {
            estimation.dctCoefs = br.readBool();
            estimation.dctLines = br.readBool();
            estimation.vlcSymbols = br.readBool();
            estimation.vlcBits = br.readBool();
        }
        if (!br.readBool()) {
            estimation.apm = br.readBool();
            estimation.npm = br.readBool();
            estimation.interpolateMcQ = br.readBool();
            estimation.forwBackMcQ = br.readBool();
            estimation.halfpel2 = br.readBool();
            estimation.halfpel4 = br.readBool();
        }
        br.skip(1);
        if (estimation.method == 1) {
            if (!br.readBool()) {
                estimation.sadct = br.readBool();
                estimation.quarterpel = br.readBool();
            }
        }
    };
    prototype.readVOPHeader = function(br) {
        this.rounding = false;
        this.quant = 2;
        this.codingType = br.readNBit(2);
         while (br.readBool()){
            this.timestampMSB++;
        }
        br.skip(1);
        if (this.getTimeIncrementBits() != 0) {
            this.timestampLSB = br.readNBit(this.getTimeIncrementBits());
        }
        br.skip(1);
        if (!br.readBool()) {
            return false;
        }
        if (this.newPredEnable) {
            var vopId;
            var vopIdForPrediction;
            vopId = br.readNBit(Math.min(this.getTimeIncrementBits() + 3, 15));
            if (br.readBool()) {
                vopIdForPrediction = br.readNBit(Math.min(this.getTimeIncrementBits() + 3, 15));
            }
            br.skip(1);
        }
        if ((this.shape != MPEG4DecodingContext.VIDOBJLAY_SHAPE_BINARY_ONLY) && ((this.codingType == MPEG4Bitstream.P_VOP) || (this.codingType == MPEG4Bitstream.S_VOP && this.spriteEnable == MPEG4DecodingContext.SPRITE_GMC))) {
            this.rounding = br.readBool();
        }
        if (this.reducedResolutionEnable && this.shape == MPEG4DecodingContext.VIDOBJLAY_SHAPE_RECTANGULAR && (this.codingType == MPEG4Bitstream.P_VOP || this.codingType == MPEG4Bitstream.I_VOP)) {
            if (br.readBool()) {}
        }
        if (this.shape != MPEG4DecodingContext.VIDOBJLAY_SHAPE_RECTANGULAR) {
            if (!(this.spriteEnable == MPEG4DecodingContext.SPRITE_STATIC && this.codingType == MPEG4Bitstream.I_VOP)) {
                this.width = br.readNBit(13);
                br.skip(1);
                this.height = br.readNBit(13);
                br.skip(1);
                this.horiz_mc_ref = br.readNBit(13);
                br.skip(1);
                this.vert_mc_ref = br.readNBit(13);
                br.skip(1);
                this.calcSizes();
            }
            br.skip(1);
            if (br.readBool()) {
                br.skip(8);
            }
        }
        var estimation = new MPEG4DecodingContext.Estimation();
        if (this.shape != MPEG4DecodingContext.VIDOBJLAY_SHAPE_BINARY_ONLY) {
            if (!this.complexityEstimationDisable) {
                this.readVopComplexityEstimationHeader(br, estimation, this.spriteEnable, this.codingType);
            }
            this.intraDCThreshold = MPEG4Consts.INTRA_DC_THRESHOLD_TABLE[br.readNBit(3)];
            if (this.interlacing) {
                this.topFieldFirst = br.readBool();
                this.alternateVerticalScan = br.readBool();
            }
        }
        if ((this.spriteEnable == MPEG4DecodingContext.SPRITE_STATIC || this.spriteEnable == MPEG4DecodingContext.SPRITE_GMC) && this.codingType == MPEG4Bitstream.S_VOP) {
            for (var i = 0; i < this.spriteWarpingPoints; i++) {
                var length;
                var x = 0, y = 0;
                length = this.getSpriteTrajectory(br);
                if (length > 0) {
                    x = br.readNBit(length);
                    if ((x >> (length - 1)) == 0) {
                        x = -(x ^ ((1 << length) - 1));
                    }
                }
                br.skip(1);
                length = this.getSpriteTrajectory(br);
                if (length > 0) {
                    y = br.readNBit(length);
                    if ((y >> (length - 1)) == 0) {
                        y = -(y ^ ((1 << length) - 1));
                    }
                }
                br.skip(1);
                this.gmcWarps[i][0] = x;
                this.gmcWarps[i][1] = y;
            }
            if (this.spriteBrightnessChange) {}
            if (this.spriteEnable == MPEG4DecodingContext.SPRITE_STATIC) {}
        }
        if ((this.quant = br.readNBit(this.quantBits)) < 1) {
            this.quant = 1;
        }
        if (this.codingType != MPEG4Bitstream.I_VOP) {
            this.fcodeForward = br.readNBit(3);
        }
        if (this.codingType == MPEG4Bitstream.B_VOP) {
            this.fcodeBackward = br.readNBit(3);
        }
        if (!this.scalability) {
            if ((this.shape != MPEG4DecodingContext.VIDOBJLAY_SHAPE_RECTANGULAR) && (this.codingType != MPEG4Bitstream.I_VOP)) {
                br.skip(1);
            }
        }
        if (this.codingType != MPEG4Bitstream.B_VOP) {
            this.lastTimeBase = this.timeBase;
            this.timeBase += this.timestampMSB;
            this.time = this.timeBase * this.getTimeIncrementResolution() + this.timestampLSB;
            this.pframeTs = this.time - this.lastNonBTime;
            this.lastNonBTime = this.time;
        } else {
            this.time = (this.lastTimeBase + this.timestampMSB) * this.getTimeIncrementResolution() + this.timestampLSB;
            this.bframeTs = this.pframeTs - (this.lastNonBTime - this.time);
        }
        return true;
    };
    prototype.getSpriteTrajectory = function(br) {
        for (var i = 0; i < 12; i++) {
            if (br.checkNBit(MPEG4Consts.SPRITE_TRAJECTORY_LEN[i][MPEG4DecodingContext.VLC_LEN]) == MPEG4Consts.SPRITE_TRAJECTORY_LEN[i][MPEG4DecodingContext.VLC_CODE]) {
                br.skip(MPEG4Consts.SPRITE_TRAJECTORY_LEN[i][MPEG4DecodingContext.VLC_LEN]);
                return i;
            }
        }
        return -1;
    };
    prototype.readVopComplexityEstimationHeader = function(br, estimation, spriteEnable, codingType) {
        if (estimation.method == 0 || estimation.method == 1) {
            if (codingType == MPEG4Bitstream.I_VOP) {
                if (estimation.opaque) 
                    br.skip(8);
                if (estimation.transparent) 
                    br.skip(8);
                if (estimation.intraCae) 
                    br.skip(8);
                if (estimation.interCae) 
                    br.skip(8);
                if (estimation.noUpdate) 
                    br.skip(8);
                if (estimation.upsampling) 
                    br.skip(8);
                if (estimation.intraBlocks) 
                    br.skip(8);
                if (estimation.notCodedBlocks) 
                    br.skip(8);
                if (estimation.dctCoefs) 
                    br.skip(8);
                if (estimation.dctLines) 
                    br.skip(8);
                if (estimation.vlcSymbols) 
                    br.skip(8);
                if (estimation.vlcBits) 
                    br.skip(8);
                if (estimation.sadct) 
                    br.skip(8);
            }
            if (codingType == MPEG4Bitstream.P_VOP) {
                if (estimation.opaque) 
                    br.skip(8);
                if (estimation.transparent) 
                    br.skip(8);
                if (estimation.intraCae) 
                    br.skip(8);
                if (estimation.interCae) 
                    br.skip(8);
                if (estimation.noUpdate) 
                    br.skip(8);
                if (estimation.upsampling) 
                    br.skip(8);
                if (estimation.intraBlocks) 
                    br.skip(8);
                if (estimation.notCodedBlocks) 
                    br.skip(8);
                if (estimation.dctCoefs) 
                    br.skip(8);
                if (estimation.dctLines) 
                    br.skip(8);
                if (estimation.vlcSymbols) 
                    br.skip(8);
                if (estimation.vlcBits) 
                    br.skip(8);
                if (estimation.interBlocks) 
                    br.skip(8);
                if (estimation.inter4vBlocks) 
                    br.skip(8);
                if (estimation.apm) 
                    br.skip(8);
                if (estimation.npm) 
                    br.skip(8);
                if (estimation.forwBackMcQ) 
                    br.skip(8);
                if (estimation.halfpel2) 
                    br.skip(8);
                if (estimation.halfpel4) 
                    br.skip(8);
                if (estimation.sadct) 
                    br.skip(8);
                if (estimation.quarterpel) 
                    br.skip(8);
            }
            if (codingType == MPEG4Bitstream.B_VOP) {
                if (estimation.opaque) 
                    br.skip(8);
                if (estimation.transparent) 
                    br.skip(8);
                if (estimation.intraCae) 
                    br.skip(8);
                if (estimation.interCae) 
                    br.skip(8);
                if (estimation.noUpdate) 
                    br.skip(8);
                if (estimation.upsampling) 
                    br.skip(8);
                if (estimation.intraBlocks) 
                    br.skip(8);
                if (estimation.notCodedBlocks) 
                    br.skip(8);
                if (estimation.dctCoefs) 
                    br.skip(8);
                if (estimation.dctLines) 
                    br.skip(8);
                if (estimation.vlcSymbols) 
                    br.skip(8);
                if (estimation.vlcBits) 
                    br.skip(8);
                if (estimation.interBlocks) 
                    br.skip(8);
                if (estimation.inter4vBlocks) 
                    br.skip(8);
                if (estimation.apm) 
                    br.skip(8);
                if (estimation.npm) 
                    br.skip(8);
                if (estimation.forwBackMcQ) 
                    br.skip(8);
                if (estimation.halfpel2) 
                    br.skip(8);
                if (estimation.halfpel4) 
                    br.skip(8);
                if (estimation.interpolateMcQ) 
                    br.skip(8);
                if (estimation.sadct) 
                    br.skip(8);
                if (estimation.quarterpel) 
                    br.skip(8);
            }
            if (codingType == MPEG4Bitstream.S_VOP && spriteEnable == MPEG4DecodingContext.SPRITE_STATIC) {
                if (estimation.intraBlocks) 
                    br.skip(8);
                if (estimation.notCodedBlocks) 
                    br.skip(8);
                if (estimation.dctCoefs) 
                    br.skip(8);
                if (estimation.dctLines) 
                    br.skip(8);
                if (estimation.vlcSymbols) 
                    br.skip(8);
                if (estimation.vlcBits) 
                    br.skip(8);
                if (estimation.interBlocks) 
                    br.skip(8);
                if (estimation.inter4vBlocks) 
                    br.skip(8);
                if (estimation.apm) 
                    br.skip(8);
                if (estimation.npm) 
                    br.skip(8);
                if (estimation.forwBackMcQ) 
                    br.skip(8);
                if (estimation.halfpel2) 
                    br.skip(8);
                if (estimation.halfpel4) 
                    br.skip(8);
                if (estimation.interpolateMcQ) 
                    br.skip(8);
            }
        }
    };
    prototype.getPackedMode = function() {
        return this.packedMode;
    };
    prototype.getTimeIncrementBits = function() {
        return this.timeIncrementBits;
    };
    prototype.getTimeIncrementResolution = function() {
        return this.timeIncrementResolution;
    };
}, {intraMpegQuantMatrix: "Int16Array", interMpegQuantMatrix: "Int16Array", gmcWarps: "Array", estimation: "MPEG4DecodingContext.Estimation"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Demuxer frontend for FLV, track based wrapper
 *  
 *  @author The JCodec project
 *  
 */
var FLVTrackDemuxer = function(_in) {
    this.packets = new LinkedList();
    this._in = _in;
    _in.setPosition(0);
    this.demuxer = new FLVReader(_in);
    this.video = new FLVTrackDemuxer.FLVDemuxerTrack(this, FLVTag.Type.VIDEO);
    this.audio = new FLVTrackDemuxer.FLVDemuxerTrack(this, FLVTag.Type.AUDIO);
};
FLVTrackDemuxer = stjs.extend(FLVTrackDemuxer, null, [], function(constructor, prototype) {
    constructor.MAX_CRAWL_DISTANCE_SEC = 10;
    prototype.demuxer = null;
    prototype.video = null;
    prototype.audio = null;
    prototype.packets = null;
    prototype._in = null;
    constructor.FLVDemuxerTrack = function(demuxer, type) {
        this.framePositions = LongArrayList.createLongArrayList();
        this.demuxer = demuxer;
        this.type = type;
        var frame = demuxer.nextFrameI(type, false);
        this.codec = frame.getTagHeader().getCodec();
    };
    constructor.FLVDemuxerTrack = stjs.extend(constructor.FLVDemuxerTrack, null, [SeekableDemuxerTrack], function(constructor, prototype) {
        prototype.type = null;
        prototype.curFrame = 0;
        prototype.codec = null;
        prototype.framePositions = null;
        prototype.codecPrivate = null;
        prototype.demuxer = null;
        prototype.nextFrame = function() {
            var frame = this.demuxer.nextFrameI(this.type, true);
            this.framePositions.add(frame.getPosition());
            return this.toPacket(frame);
        };
        prototype.prevFrame = function() {
            var frame = this.demuxer.prevFrameI(this.type, true);
            return this.toPacket(frame);
        };
        prototype.pickFrame = function() {
            var frame = this.demuxer.nextFrameI(this.type, false);
            return this.toPacket(frame);
        };
        prototype.toPacket = function(frame) {
            return null;
        };
        prototype.getMeta = function() {
            var t = this.type == FLVTag.Type.VIDEO ? TrackType.VIDEO : TrackType.AUDIO;
            return new DemuxerTrackMeta(t, this.codec, 0, null, 0, ByteBuffer.wrap(this.codecPrivate), null, null);
        };
        prototype.gotoFrame = function(i) {
            if (i >= this.framePositions.size()) 
                return false;
            this.demuxer.resetToPosition(this.framePositions.get(((i) | 0)));
            return true;
        };
        prototype.gotoSyncFrame = function(i) {
             throw new RuntimeException();
        };
        prototype.getCurFrame = function() {
            return this.curFrame;
        };
        prototype.seek = function(second) {
            this.demuxer.seekI(second);
        };
    }, {type: {name: "Enum", arguments: ["FLVTag.Type"]}, codec: "Codec", framePositions: "LongArrayList", codecPrivate: "Int8Array", demuxer: "FLVTrackDemuxer"}, {});
    prototype.resetToPosition = function(position) {
        this._in.setPosition(position);
        this.demuxer.reset();
        this.packets.clear();
    };
    prototype.seekI = function(second) {
        this.packets.clear();
        var base;
         while ((base = this.demuxer.readNextPacket()) != null && base.getPtsD() == 0)
            ;
        if (base == null) {
            return;
        }
        this._in.setPosition(base.getPosition() + 1048576);
        this.demuxer.reposition();
        var off = this.demuxer.readNextPacket();
        var byteRate = stjs.trunc(((off.getPosition() - base.getPosition()) / (off.getPtsD() - base.getPtsD())));
        var offset = base.getPosition() + stjs.trunc(((second - base.getPtsD()) * byteRate));
        this._in.setPosition(offset);
        this.demuxer.reposition();
        for (var i = 0; i < 5; ++i) {
            var pkt = this.demuxer.readNextPacket();
            var distance = second - pkt.getPtsD();
            if (distance > 0 && distance < FLVTrackDemuxer.MAX_CRAWL_DISTANCE_SEC) {
                System.out.println("Crawling forward: " + distance);
                var testPkt;
                 while ((testPkt = this.demuxer.readNextPacket()) != null && testPkt.getPtsD() < second)
                    ;
                if (testPkt != null) 
                    this.packets.add(pkt);
                return;
            } else if (distance < 0 && distance > -FLVTrackDemuxer.MAX_CRAWL_DISTANCE_SEC) {
                System.out.println("Overshoot by: " + (-distance));
                this._in.setPosition(pkt.getPosition() + stjs.trunc(((distance - 1) * byteRate)));
                this.demuxer.reposition();
            }
        }
    };
    prototype.nextFrameI = function(type, remove) {
        for (var it = this.packets.iterator(); it.hasNext(); ) {
            var pkt = it.next();
            if (pkt.getType() == type) {
                if (remove) 
                    it.remove();
                return pkt;
            }
        }
        var pkt;
         while ((pkt = this.demuxer.readNextPacket()) != null && pkt.getType() != type)
            this.packets.add(pkt);
        if (!remove) 
            this.packets.add(pkt);
        return pkt;
    };
    prototype.prevFrameI = function(type, remove) {
        for (var it = this.packets.listIterator(); it.hasPrevious(); ) {
            var pkt = it.previous();
            if (pkt.getType() == type) {
                if (remove) 
                    it.remove();
                return pkt;
            }
        }
        var pkt;
         while ((pkt = this.demuxer.readPrevPacket()) != null && pkt.getType() != type)
            this.packets.add(0, pkt);
        if (!remove) 
            this.packets.add(0, pkt);
        return pkt;
    };
    prototype.getTracks = function() {
        return [this.video, this.audio];
    };
    prototype.getVideoTrack = function() {
        return this.video;
    };
    prototype.getAudioTrack = function() {
        return this.video;
    };
}, {demuxer: "FLVReader", video: "FLVTrackDemuxer.FLVDemuxerTrack", audio: "FLVTrackDemuxer.FLVDemuxerTrack", packets: {name: "LinkedList", arguments: ["FLVTag"]}, _in: "SeekableByteChannel"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  DecoderConfig that must be passed to the
 *  <code>Decoder</code> constructor. Typically it is created via one of the
 *  static parsing methods.
 * 
 *  @author in-somnia
 */
var DecoderConfig = function() {
    this.profile = Profile.AAC_MAIN;
    this.extProfile = Profile.UNKNOWN;
    this.sampleFrequency = SampleFrequency.SAMPLE_FREQUENCY_NONE;
    this.channelConfiguration = ChannelConfiguration.CHANNEL_CONFIG_UNSUPPORTED;
    this.frameLengthFlag = false;
    this.sbrPresent = false;
    this.downSampledSBR = false;
    this.sbrEnabled = true;
    this.sectionDataResilience = false;
    this.scalefactorResilience = false;
    this.spectralDataResilience = false;
};
DecoderConfig = stjs.extend(DecoderConfig, null, [SyntaxConstants], function(constructor, prototype) {
    prototype.profile = null;
    prototype.extProfile = null;
    prototype.sampleFrequency = null;
    prototype.channelConfiguration = null;
    prototype.frameLengthFlag = false;
    prototype.dependsOnCoreCoder = false;
    prototype.coreCoderDelay = 0;
    prototype.extensionFlag = false;
    prototype.sbrPresent = false;
    prototype.downSampledSBR = false;
    prototype.sbrEnabled = false;
    prototype.sectionDataResilience = false;
    prototype.scalefactorResilience = false;
    prototype.spectralDataResilience = false;
    prototype.getChannelConfiguration = function() {
        return this.channelConfiguration;
    };
    prototype.setChannelConfiguration = function(channelConfiguration) {
        this.channelConfiguration = channelConfiguration;
    };
    prototype.getCoreCoderDelay = function() {
        return this.coreCoderDelay;
    };
    prototype.setCoreCoderDelay = function(coreCoderDelay) {
        this.coreCoderDelay = coreCoderDelay;
    };
    prototype.isDependsOnCoreCoder = function() {
        return this.dependsOnCoreCoder;
    };
    prototype.setDependsOnCoreCoder = function(dependsOnCoreCoder) {
        this.dependsOnCoreCoder = dependsOnCoreCoder;
    };
    prototype.getExtObjectType = function() {
        return this.extProfile;
    };
    prototype.setExtObjectType = function(extObjectType) {
        this.extProfile = extObjectType;
    };
    prototype.getFrameLength = function() {
        return this.frameLengthFlag ? SyntaxConstants.WINDOW_SMALL_LEN_LONG : SyntaxConstants.WINDOW_LEN_LONG;
    };
    prototype.isSmallFrameUsed = function() {
        return this.frameLengthFlag;
    };
    prototype.setSmallFrameUsed = function(shortFrame) {
        this.frameLengthFlag = shortFrame;
    };
    prototype.getProfile = function() {
        return this.profile;
    };
    prototype.setProfile = function(profile) {
        this.profile = profile;
    };
    prototype.getSampleFrequency = function() {
        return this.sampleFrequency;
    };
    prototype.setSampleFrequency = function(sampleFrequency) {
        this.sampleFrequency = sampleFrequency;
    };
    prototype.isSBRPresent = function() {
        return this.sbrPresent;
    };
    prototype.isSBRDownSampled = function() {
        return this.downSampledSBR;
    };
    prototype.isSBREnabled = function() {
        return this.sbrEnabled;
    };
    prototype.setSBREnabled = function(enabled) {
        this.sbrEnabled = enabled;
    };
    prototype.isScalefactorResilienceUsed = function() {
        return this.scalefactorResilience;
    };
    prototype.isSectionDataResilienceUsed = function() {
        return this.sectionDataResilience;
    };
    prototype.isSpectralDataResilienceUsed = function() {
        return this.spectralDataResilience;
    };
    /**
     *  Parses the input arrays as a DecoderSpecificInfo, as used in MP4
     *  containers.
     *  
     *  @return a DecoderConfig
     */
    constructor.parseMP4DecoderSpecificInfo = function(data) {
        var _in = BitStream.createBitStream(data);
        var config = new DecoderConfig();
        try {
            config.profile = DecoderConfig.readProfile(_in);
            var sf = _in.readBits(4);
            if (sf == 15) 
                config.sampleFrequency = SampleFrequency.forFrequency(_in.readBits(24));
             else 
                config.sampleFrequency = SampleFrequency.forInt(sf);
            config.channelConfiguration = ChannelConfiguration.forInt(_in.readBits(4));
            var cp = config.profile;
            if (Profile.AAC_SBR == cp) {
                config.extProfile = cp;
                config.sbrPresent = true;
                sf = _in.readBits(4);
                config.downSampledSBR = config.sampleFrequency.getIndex() == sf;
                config.sampleFrequency = SampleFrequency.forInt(sf);
                config.profile = DecoderConfig.readProfile(_in);
            } else if (Profile.AAC_MAIN == cp || Profile.AAC_LC == cp || Profile.AAC_SSR == cp || Profile.AAC_LTP == cp || Profile.ER_AAC_LC == cp || Profile.ER_AAC_LTP == cp || Profile.ER_AAC_LD == cp) {
                config.frameLengthFlag = _in.readBool();
                if (config.frameLengthFlag) 
                     throw new AACException("config uses 960-sample frames, not yet supported");
                config.dependsOnCoreCoder = _in.readBool();
                if (config.dependsOnCoreCoder) 
                    config.coreCoderDelay = _in.readBits(14);
                 else 
                    config.coreCoderDelay = 0;
                config.extensionFlag = _in.readBool();
                if (config.extensionFlag) {
                    if (cp.isErrorResilientProfile()) {
                        config.sectionDataResilience = _in.readBool();
                        config.scalefactorResilience = _in.readBool();
                        config.spectralDataResilience = _in.readBool();
                    }
                    _in.skipBit();
                }
                if (config.channelConfiguration == ChannelConfiguration.CHANNEL_CONFIG_NONE) {
                    _in.skipBits(3);
                    var pce = new PCE();
                    pce.decode(_in);
                    config.profile = pce.getProfile();
                    config.sampleFrequency = pce.getSampleFrequency();
                    config.channelConfiguration = ChannelConfiguration.forInt(pce.getChannelCount());
                }
                if (_in.getBitsLeft() > 10) 
                    DecoderConfig.readSyncExtension(_in, config);
            } else {
                 throw new AACException("profile not supported: " + cp.getIndex());
            }
            return config;
        } finally {
            _in.destroy();
        }
    };
    constructor.readProfile = function(_in) {
        var i = _in.readBits(5);
        if (i == 31) 
            i = 32 + _in.readBits(6);
        return Profile.forInt(i);
    };
    constructor.readSyncExtension = function(_in, config) {
        var type = _in.readBits(11);
        switch (type) {
            case 695:
                var profile = Profile.forInt(_in.readBits(5));
                if (profile.equals(Profile.AAC_SBR)) {
                    config.sbrPresent = _in.readBool();
                    if (config.sbrPresent) {
                        config.profile = profile;
                        var tmp = _in.readBits(4);
                        if (tmp == config.sampleFrequency.getIndex()) 
                            config.downSampledSBR = true;
                        if (tmp == 15) {
                             throw new AACException("sample rate specified explicitly, not supported yet!");
                        }
                    }
                }
                break;
        }
    };
}, {profile: "Profile", extProfile: "Profile", sampleFrequency: "SampleFrequency", channelConfiguration: "ChannelConfiguration"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var ADIFHeader = function() {
    this.copyrightID = new Int8Array(9);
};
ADIFHeader = stjs.extend(ADIFHeader, null, [], function(constructor, prototype) {
    constructor.ADIF_ID = 1094994246;
    prototype.id = 0;
    prototype.copyrightIDPresent = false;
    prototype.copyrightID = null;
    prototype.originalCopy = false;
    prototype.home = false;
    prototype.bitstreamType = false;
    prototype.bitrate = 0;
    prototype.pceCount = 0;
    prototype.adifBufferFullness = null;
    prototype.pces = null;
    constructor.isPresent = function(_in) {
        return _in.peekBits(32) == ADIFHeader.ADIF_ID;
    };
    constructor.readHeader = function(_in) {
        var h = new ADIFHeader();
        h.decode(_in);
        return h;
    };
    prototype.decode = function(_in) {
        var i;
        this.id = _in.readBits(32);
        this.copyrightIDPresent = _in.readBool();
        if (this.copyrightIDPresent) {
            for (i = 0; i < 9; i++) {
                this.copyrightID[i] = (_in.readBits(8) << 24 >> 24);
            }
        }
        this.originalCopy = _in.readBool();
        this.home = _in.readBool();
        this.bitstreamType = _in.readBool();
        this.bitrate = _in.readBits(23);
        this.pceCount = _in.readBits(4) + 1;
        this.pces = Array(this.pceCount);
        this.adifBufferFullness = new Int32Array(this.pceCount);
        for (i = 0; i < this.pceCount; i++) {
            if (this.bitstreamType) 
                this.adifBufferFullness[i] = -1;
             else 
                this.adifBufferFullness[i] = _in.readBits(20);
            this.pces[i] = new PCE();
            this.pces[i].decode(_in);
        }
    };
    prototype.getFirstPCE = function() {
        return this.pces[0];
    };
}, {copyrightID: "Int8Array", adifBufferFullness: "Int32Array", pces: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Transcoder core.
 *  
 *  The simplest way to create a transcoder with default options:
 *  Transcoder.newTranscoder(source, sink).create(); The source and the sink are
 *  essential to the transcoder and must be provided.
 *  
 *  @author The JCodec project
 *  
 */
var Transcoder = /**
 *  Use TranscoderBuilder (method newTranscoder below) to create a transcoder
 *  
 *  @param source
 *  @param sink
 *  @param videoCodecCopy
 *  @param audioCodecCopy
 *  @param extraFilters
 */
function(source, sink, videoMappings, audioMappings, extraFilters, seekFrames, maxFrames) {
    this.extraFilters = extraFilters;
    this.videoMappings = videoMappings;
    this.audioMappings = audioMappings;
    this.seekFrames = seekFrames;
    this.maxFrames = maxFrames;
    this.sources = source;
    this.sinks = sink;
};
Transcoder = stjs.extend(Transcoder, null, [], function(constructor, prototype) {
    constructor.REORDER_BUFFER_SIZE = 7;
    prototype.sources = null;
    prototype.sinks = null;
    prototype.extraFilters = null;
    prototype.seekFrames = null;
    prototype.maxFrames = null;
    prototype.videoMappings = null;
    prototype.audioMappings = null;
    constructor.Mapping = function(source, copy) {
        this.source = source;
        this.copy = copy;
    };
    constructor.Mapping = stjs.extend(constructor.Mapping, null, [], function(constructor, prototype) {
        prototype.source = 0;
        prototype.copy = false;
    }, {}, {});
    constructor.Stream = function(sink, videoCopy, audioCopy, extraFilters, pixelStore) {
        this.sink = sink;
        this.videoCopy = videoCopy;
        this.audioCopy = audioCopy;
        this.extraFilters = extraFilters;
        this.pixelStore = pixelStore;
        this.videoQueue = new LinkedList();
        this.audioQueue = new LinkedList();
    };
    constructor.Stream = stjs.extend(constructor.Stream, null, [], function(constructor, prototype) {
        constructor.AUDIO_LEADING_TIME = 0.2;
        prototype.videoQueue = null;
        prototype.audioQueue = null;
        prototype.filters = null;
        prototype.extraFilters = null;
        prototype.sink = null;
        prototype.videoCopy = false;
        prototype.audioCopy = false;
        prototype.pixelStore = null;
        prototype.videoCodecMeta = null;
        prototype.audioCodecMeta = null;
        constructor.REORDER_LENGTH = 5;
        prototype.initColorTransform = function(sourceColor, extraFilters, sink) {
            var filters = new ArrayList();
            for (var iterator$filter = extraFilters.iterator(); iterator$filter.hasNext(); ) {
                var filter = iterator$filter.next();
                var inputColor = filter.getInputColor();
                if (!sourceColor.matches(inputColor)) {
                    filters.add(new ColorTransformFilter(inputColor));
                }
                filters.add(filter);
                if (filter.getOutputColor() != ColorSpace.SAME) 
                    sourceColor = filter.getOutputColor();
            }
            var inputColor = sink.getInputColor();
            if (inputColor != null && inputColor != sourceColor) 
                filters.add(new ColorTransformFilter(inputColor));
            return filters;
        };
        prototype.tryFlushQueues = function() {
            if (this.videoQueue.size() <= 0) 
                return;
            if (this.videoCopy && this.videoQueue.size() < Transcoder.Stream.REORDER_LENGTH) 
                return;
            if (!this.hasLeadingAudio()) 
                return;
            var firstVideoFrame;
            firstVideoFrame = this.videoQueue.get(0);
            if (this.videoCopy) {
                for (var iterator$videoFrame = this.videoQueue.iterator(); iterator$videoFrame.hasNext(); ) {
                    var videoFrame = iterator$videoFrame.next();
                    if (videoFrame.getPacket().getFrameNo() < firstVideoFrame.getPacket().getFrameNo()) 
                        firstVideoFrame = videoFrame;
                }
            }
            var aqSize = this.audioQueue.size();
            for (var af = 0; af < aqSize; af++) {
                var audioFrame = this.audioQueue.get(0);
                if (audioFrame.getPacket().getPtsD() >= firstVideoFrame.getPacket().getPtsD() + 0.2) 
                    break;
                this.audioQueue.remove(0);
                if (this.audioCopy && (stjs.isInstanceOf(this.sink.constructor, PacketSink))) {
                    (this.sink).outputAudioPacket(audioFrame.getPacket(), this.audioCodecMeta);
                } else {
                    this.sink.outputAudioFrame(audioFrame);
                }
            }
            this.videoQueue.remove(firstVideoFrame);
            if (this.videoCopy && (stjs.isInstanceOf(this.sink.constructor, PacketSink))) {
                (this.sink).outputVideoPacket(firstVideoFrame.getPacket(), this.videoCodecMeta);
            } else {
                var frame = this.filterFrame(firstVideoFrame);
                this.sink.outputVideoFrame(new VideoFrameWithPacket(firstVideoFrame.getPacket(), frame));
                this.pixelStore.putBack(frame);
            }
        };
        prototype.filterFrame = function(firstVideoFrame) {
            var frame = firstVideoFrame.getFrame();
            for (var iterator$filter = this.filters.iterator(); iterator$filter.hasNext(); ) {
                var filter = iterator$filter.next();
                var old = frame;
                frame = filter.filter(frame.getPicture(), this.pixelStore);
                if (frame == null) {
                    frame = old;
                } else {
                    this.pixelStore.putBack(old);
                }
            }
            return frame;
        };
        prototype.finalFlushQueues = function() {
            var lastVideoFrame = null;
            for (var iterator$videoFrame = this.videoQueue.iterator(); iterator$videoFrame.hasNext(); ) {
                var videoFrame = iterator$videoFrame.next();
                if (lastVideoFrame == null || videoFrame.getPacket().getPtsD() >= lastVideoFrame.getPacket().getPtsD()) 
                    lastVideoFrame = videoFrame;
            }
            if (lastVideoFrame != null) {
                for (var iterator$audioFrame = this.audioQueue.iterator(); iterator$audioFrame.hasNext(); ) {
                    var audioFrame = iterator$audioFrame.next();
                    if (audioFrame.getPacket().getPtsD() > lastVideoFrame.getPacket().getPtsD()) 
                        break;
                    if (this.audioCopy && (stjs.isInstanceOf(this.sink.constructor, PacketSink))) {
                        (this.sink).outputAudioPacket(audioFrame.getPacket(), this.audioCodecMeta);
                    } else {
                        this.sink.outputAudioFrame(audioFrame);
                    }
                }
                for (var iterator$videoFrame = this.videoQueue.iterator(); iterator$videoFrame.hasNext(); ) {
                    var videoFrame = iterator$videoFrame.next();
                    if (videoFrame != null) {
                        if (this.videoCopy && (stjs.isInstanceOf(this.sink.constructor, PacketSink))) {
                            (this.sink).outputVideoPacket(videoFrame.getPacket(), this.videoCodecMeta);
                        } else {
                            var frame = this.filterFrame(videoFrame);
                            this.sink.outputVideoFrame(new VideoFrameWithPacket(videoFrame.getPacket(), frame));
                            this.pixelStore.putBack(frame);
                        }
                    }
                }
            } else {
                for (var iterator$audioFrame = this.audioQueue.iterator(); iterator$audioFrame.hasNext(); ) {
                    var audioFrame = iterator$audioFrame.next();
                    if (this.audioCopy && (stjs.isInstanceOf(this.sink.constructor, PacketSink))) {
                        (this.sink).outputAudioPacket(audioFrame.getPacket(), this.audioCodecMeta);
                    } else {
                        this.sink.outputAudioFrame(audioFrame);
                    }
                }
            }
        };
        prototype.addVideoPacket = function(videoFrame, meta) {
            if (videoFrame.getFrame() != null) 
                this.pixelStore.retake(videoFrame.getFrame());
            this.videoQueue.add(videoFrame);
            this.videoCodecMeta = meta;
            if (this.filters == null) 
                this.filters = this.initColorTransform(this.videoCodecMeta.getColor(), this.extraFilters, this.sink);
        };
        prototype.addAudioPacket = function(videoFrame, meta) {
            this.audioQueue.add(videoFrame);
            this.audioCodecMeta = meta;
        };
        prototype.needsVideoFrame = function() {
            if (this.videoQueue.size() <= 0) 
                return true;
            if (this.videoCopy && this.videoQueue.size() < Transcoder.Stream.REORDER_LENGTH) 
                return true;
            return false;
        };
        prototype.hasLeadingAudio = function() {
            var firstVideoFrame = this.videoQueue.get(0);
            for (var iterator$audioFrame = this.audioQueue.iterator(); iterator$audioFrame.hasNext(); ) {
                var audioFrame = iterator$audioFrame.next();
                if (audioFrame.getPacket().getPtsD() >= firstVideoFrame.getPacket().getPtsD() + Transcoder.Stream.AUDIO_LEADING_TIME) {
                    return true;
                }
            }
            return false;
        };
    }, {videoQueue: {name: "LinkedList", arguments: ["VideoFrameWithPacket"]}, audioQueue: {name: "LinkedList", arguments: ["AudioFrameWithPacket"]}, filters: {name: "List", arguments: ["Filter"]}, extraFilters: {name: "List", arguments: ["Filter"]}, sink: "Sink", pixelStore: "PixelStore", videoCodecMeta: "VideoCodecMeta", audioCodecMeta: "AudioCodecMeta"}, {});
    prototype.transcode = function() {
        var pixelStore = new PixelStoreImpl();
        var videoStreams = Array(this.sources.length);
        var audioStreams = Array(this.sources.length);
        var decodeVideo = new Int8Array(this.sources.length);
        var decodeAudio = new Int8Array(this.sources.length);
        var finishedVideo = new Int8Array(this.sources.length);
        var finishedAudio = new Int8Array(this.sources.length);
        var allStreams = Array(this.sinks.length);
        var videoFramesRead = new Int32Array(this.sources.length);
        for (var s = 0; s < this.sources.length; s++) {
            videoStreams[s] = new ArrayList();
            audioStreams[s] = new ArrayList();
        }
        for (var i = 0; i < this.sinks.length; i++) 
            this.sinks[i].init();
        for (var i = 0; i < this.sources.length; i++) {
            this.sources[i].init(pixelStore);
            this.sources[i].seekFrames(this.seekFrames[i]);
        }
        for (var s = 0; s < this.sinks.length; s++) {
            var stream = new Transcoder.Stream(this.sinks[s], this.videoMappings[s].copy, this.audioMappings[s].copy, this.extraFilters[s], pixelStore);
            allStreams[s] = stream;
            if (this.sources[this.videoMappings[s].source].isVideo()) {
                videoStreams[this.videoMappings[s].source].add(stream);
                if (!this.videoMappings[s].copy) 
                    decodeVideo[this.videoMappings[s].source] = true;
            } else {
                finishedVideo[this.videoMappings[s].source] = true;
            }
            if (this.sources[this.audioMappings[s].source].isAudio()) {
                audioStreams[this.audioMappings[s].source].add(stream);
                if (!this.audioMappings[s].copy) 
                    decodeAudio[this.audioMappings[s].source] = true;
            } else {
                finishedAudio[this.audioMappings[s].source] = true;
            }
        }
        try {
             while (true){
                for (var s = 0; s < this.sources.length; s++) {
                    var source = this.sources[s];
                    var needsVideoFrame = !finishedVideo[s];
                    for (var iterator$stream = videoStreams[s].iterator(); iterator$stream.hasNext(); ) {
                        var stream = iterator$stream.next();
                        needsVideoFrame &= stream.needsVideoFrame() || stream.hasLeadingAudio() || finishedAudio[s];
                    }
                    if (needsVideoFrame) {
                        var nextVideoFrame;
                        if (videoFramesRead[s] >= this.maxFrames[s]) {
                            nextVideoFrame = null;
                            finishedVideo[s] = true;
                        } else if (decodeVideo[s] || !(stjs.isInstanceOf(source.constructor, PacketSource))) {
                            nextVideoFrame = source.getNextVideoFrame();
                            if (nextVideoFrame == null) {
                                finishedVideo[s] = true;
                            } else {
                                ++videoFramesRead[s];
                                this.printLegend(((nextVideoFrame.getPacket().getFrameNo()) | 0), 0, nextVideoFrame.getPacket());
                            }
                        } else {
                            var packet = (source).inputVideoPacket();
                            if (packet == null) {
                                finishedVideo[s] = true;
                            } else {
                                ++videoFramesRead[s];
                            }
                            nextVideoFrame = new VideoFrameWithPacket(packet, null);
                        }
                        if (finishedVideo[s]) {
                            for (var iterator$stream = videoStreams[s].iterator(); iterator$stream.hasNext(); ) {
                                var stream = iterator$stream.next();
                                for (var ss = 0; ss < audioStreams.length; ss++) {
                                    audioStreams[ss].remove(stream);
                                }
                            }
                            videoStreams[s].clear();
                        }
                        if (nextVideoFrame != null) {
                            for (var iterator$stream = videoStreams[s].iterator(); iterator$stream.hasNext(); ) {
                                var stream = iterator$stream.next();
                                stream.addVideoPacket(nextVideoFrame, source.getVideoCodecMeta());
                            }
                            if (nextVideoFrame.getFrame() != null) 
                                pixelStore.putBack(nextVideoFrame.getFrame());
                        }
                    }
                    if (!audioStreams[s].isEmpty()) {
                        var nextAudioFrame;
                        if (decodeAudio[s] || !(stjs.isInstanceOf(source.constructor, PacketSource))) {
                            nextAudioFrame = source.getNextAudioFrame();
                            if (nextAudioFrame == null) 
                                finishedAudio[s] = true;
                        } else {
                            var packet = (source).inputAudioPacket();
                            if (packet == null) {
                                finishedAudio[s] = true;
                                nextAudioFrame = null;
                            } else {
                                nextAudioFrame = new AudioFrameWithPacket(null, packet);
                            }
                        }
                        if (nextAudioFrame != null) {
                            for (var iterator$stream = audioStreams[s].iterator(); iterator$stream.hasNext(); ) {
                                var stream = iterator$stream.next();
                                stream.addAudioPacket(nextAudioFrame, source.getAudioCodecMeta());
                            }
                        }
                    } else {
                        finishedAudio[s] = true;
                    }
                }
                for (var s = 0; s < allStreams.length; s++) {
                    allStreams[s].tryFlushQueues();
                }
                var allFinished = true;
                for (var s = 0; s < this.sources.length; s++) {
                    allFinished &= finishedVideo[s] & finishedAudio[s];
                }
                if (allFinished) 
                    break;
            }
            for (var s = 0; s < allStreams.length; s++) {
                allStreams[s].finalFlushQueues();
            }
        } finally {
            for (var i = 0; i < this.sources.length; i++) 
                this.sources[0].finish();
            for (var i = 0; i < this.sinks.length; i++) 
                this.sinks[i].finish();
        }
    };
    prototype.printLegend = function(frameNo, maxFrames, inVideoPacket) {
        if (frameNo % 100 == 0) 
            System.out.print(String.format("[%6d]\r", frameNo));
    };
    constructor.TranscoderBuilder = function() {
        this.source = new ArrayList();
        this.sink = new ArrayList();
        this.filters = new ArrayList();
        this.seekFrames = new IntArrayList(20);
        this.maxFrames = new IntArrayList(20);
        this.videoMappings = new ArrayList();
        this.audioMappings = new ArrayList();
    };
    constructor.TranscoderBuilder = stjs.extend(constructor.TranscoderBuilder, null, [], function(constructor, prototype) {
        prototype.source = null;
        prototype.sink = null;
        prototype.filters = null;
        prototype.seekFrames = null;
        prototype.maxFrames = null;
        prototype.videoMappings = null;
        prototype.audioMappings = null;
        prototype.addFilter = function(sink, filter) {
            this.filters.get(sink).add(filter);
            return this;
        };
        prototype.setSeekFrames = function(source, seekFrames) {
            this.seekFrames.set(source, seekFrames);
            return this;
        };
        prototype.setMaxFrames = function(source, maxFrames) {
            this.maxFrames.set(source, maxFrames);
            return this;
        };
        prototype.addSource = function(source) {
            this.source.add(source);
            this.seekFrames.add(0);
            this.maxFrames.add(Integer.MAX_VALUE);
            return this;
        };
        prototype.addSink = function(sink) {
            this.sink.add(sink);
            this.videoMappings.add(new Transcoder.Mapping(0, false));
            this.audioMappings.add(new Transcoder.Mapping(0, false));
            this.filters.add(new ArrayList());
            return this;
        };
        prototype.setVideoMapping = function(src, sink, copy) {
            this.videoMappings.set(sink, new Transcoder.Mapping(src, copy));
            return this;
        };
        prototype.setAudioMapping = function(src, sink, copy) {
            this.audioMappings.set(sink, new Transcoder.Mapping(src, copy));
            return this;
        };
        prototype.create = function() {
            return new Transcoder(this.source.toArray([]), this.sink.toArray([]), this.videoMappings.toArray([]), this.audioMappings.toArray([]), this.filters.toArray(Array(0)), this.seekFrames.toArray(), this.maxFrames.toArray());
        };
    }, {source: {name: "List", arguments: ["Source"]}, sink: {name: "List", arguments: ["Sink"]}, filters: {name: "List", arguments: [{name: "List", arguments: ["Filter"]}]}, seekFrames: "IntArrayList", maxFrames: "IntArrayList", videoMappings: {name: "List", arguments: ["Transcoder.Mapping"]}, audioMappings: {name: "List", arguments: ["Transcoder.Mapping"]}}, {});
    constructor.newTranscoder = function() {
        return new Transcoder.TranscoderBuilder();
    };
}, {sources: "Array", sinks: "Array", extraFilters: "Array", seekFrames: "Int32Array", maxFrames: "Int32Array", videoMappings: "Array", audioMappings: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG TS demuxer
 *  
 *  @author The JCodec project
 *  
 */
var MTSDemuxer = function(src) {
    this.channel = src;
    this.programs = new HashMap();
    for (var iterator$pid = this.findPrograms(src).iterator(); iterator$pid.hasNext(); ) {
        var pid = iterator$pid.next();
        this.programs.put(pid, new MTSDemuxer.ProgramChannel(this));
    }
    src.setPosition(0);
};
MTSDemuxer = stjs.extend(MTSDemuxer, null, [], function(constructor, prototype) {
    prototype.channel = null;
    prototype.programs = null;
    prototype.getPrograms = function() {
        return this.programs.keySet();
    };
    prototype.findPrograms = function(src) {
        var rem = src.position();
        var guids = new HashSet();
        for (var i = 0; guids.size() == 0 || i < guids.size() * 500; i++) {
            var pkt = MTSDemuxer.readPacket(src);
            if (pkt == null) 
                break;
            if (pkt.payload == null) 
                continue;
            var payload = pkt.payload;
            if (!guids.contains(pkt.pid) && (payload.duplicate().getInt() & ~255) == 256) {
                guids.add(pkt.pid);
            }
        }
        src.setPosition(rem);
        return guids;
    };
    prototype.getProgram = function(pid) {
        return this.programs.get(pid);
    };
    constructor.ProgramChannel = function(demuxer) {
        this.demuxer = demuxer;
        this.data = new ArrayList();
    };
    constructor.ProgramChannel = stjs.extend(constructor.ProgramChannel, null, [ReadableByteChannel], function(constructor, prototype) {
        prototype.demuxer = null;
        prototype.data = null;
        prototype.closed = false;
        prototype.isOpen = function() {
            return !this.closed && this.demuxer.channel.isOpen();
        };
        prototype.close = function() {
            this.closed = true;
            this.data.clear();
        };
        prototype.read = function(dst) {
            var bytesRead = 0;
             while (dst.hasRemaining()){
                 while (this.data.size() == 0){
                    if (!this.demuxer.readAndDispatchNextTSPacket()) 
                        return bytesRead > 0 ? bytesRead : -1;
                }
                var first = this.data.get(0);
                var toRead = Math.min(dst.remaining(), first.remaining());
                dst.putBuf(NIOUtils.read(first, toRead));
                if (!first.hasRemaining()) 
                    this.data.remove(0);
                bytesRead += toRead;
            }
            return bytesRead;
        };
        prototype.storePacket = function(pkt) {
            if (this.closed) 
                return;
            this.data.add(pkt.payload);
        };
    }, {demuxer: "MTSDemuxer", data: {name: "List", arguments: ["ByteBuffer"]}}, {});
    prototype.readAndDispatchNextTSPacket = function() {
        var pkt = MTSDemuxer.readPacket(this.channel);
        if (pkt == null) 
            return false;
        var program = this.programs.get(pkt.pid);
        if (program != null) {
            program.storePacket(pkt);
        }
        return true;
    };
    constructor.MTSPacket = function(guid, payloadStart, payload) {
        this.pid = guid;
        this.payloadStart = payloadStart;
        this.payload = payload;
    };
    constructor.MTSPacket = stjs.extend(constructor.MTSPacket, null, [], function(constructor, prototype) {
        prototype.payload = null;
        prototype.payloadStart = false;
        prototype.pid = 0;
    }, {payload: "ByteBuffer"}, {});
    constructor.readPacket = function(channel) {
        var buffer = ByteBuffer.allocate(188);
        if (NIOUtils.readFromChannel(channel, buffer) != 188) 
            return null;
        buffer.flip();
        return MTSDemuxer.parsePacket(buffer);
    };
    constructor.parsePacket = function(buffer) {
        var marker = buffer.get() & 255;
        Preconditions.checkState(71 == marker);
        var guidFlags = buffer.getShort();
        var guid = stjs.trunc(guidFlags) & 8191;
        var payloadStart = (guidFlags >> 14) & 1;
        var b0 = buffer.get() & 255;
        var counter = b0 & 15;
        if ((b0 & 32) != 0) {
            var taken = 0;
            taken = (buffer.get() & 255) + 1;
            NIOUtils.skip(buffer, taken - 1);
        }
        return new MTSDemuxer.MTSPacket(guid, payloadStart == 1, ((b0 & 16) != 0) ? buffer : null);
    };
    constructor.probe = function(b_) {
        var b = b_.duplicate();
        var streams = new IntObjectMap();
         while (true){
            try {
                var sub = NIOUtils.read(b, 188);
                if (sub.remaining() < 188) 
                    break;
                var tsPkt = MTSDemuxer.parsePacket(sub);
                if (tsPkt == null) 
                    break;
                var data = streams.get(tsPkt.pid);
                if (data == null) {
                    data = new ArrayList();
                    streams.put(tsPkt.pid, data);
                }
                if (tsPkt.payload != null) 
                    data.add(tsPkt.payload);
            }catch (t) {
                break;
            }
        }
        var maxScore = 0;
        var keys = streams.keys();
        for (var index$i = 0, arr$i = keys; index$i < arr$i.length; index$i++) {
            var i = arr$i[index$i];
            var packets = streams.get(i);
            var score = MPSDemuxer.probe(NIOUtils.combineBuffers(packets));
            if (score > maxScore) {
                maxScore = score + (packets.size() > 20 ? 50 : 0);
            }
        }
        return maxScore;
    };
}, {channel: "SeekableByteChannel", programs: {name: "Map", arguments: [null, "MTSDemuxer.ProgramChannel"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var DataBox = function(header) {
    Box.call(this, header);
};
DataBox = stjs.extend(DataBox, Box, [], function(constructor, prototype) {
    constructor.FOURCC = "data";
    prototype.type = 0;
    prototype.locale = 0;
    prototype.data = null;
    constructor.createDataBox = function(type, locale, data) {
        var box = new DataBox(Header.createHeader(DataBox.FOURCC, 0));
        box.type = type;
        box.locale = locale;
        box.data = data;
        return box;
    };
    prototype.parse = function(buf) {
        this.type = buf.getInt();
        this.locale = buf.getInt();
        this.data = NIOUtils.toArray(NIOUtils.readBuf(buf));
    };
    prototype.getType = function() {
        return this.type;
    };
    prototype.getLocale = function() {
        return this.locale;
    };
    prototype.getData = function() {
        return this.data;
    };
    prototype.doWrite = function(out) {
        out.putInt(this.type);
        out.putInt(this.locale);
        out.putArr(this.data);
    };
    prototype.estimateSize = function() {
        return 16 + this.data.length;
    };
    constructor.fourcc = function() {
        return DataBox.FOURCC;
    };
}, {data: "Int8Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var EndianBox = function(header) {
    Box.call(this, header);
};
EndianBox = stjs.extend(EndianBox, Box, [], function(constructor, prototype) {
    prototype.endian = null;
    constructor.fourcc = function() {
        return "enda";
    };
    constructor.createEndianBox = function(endian) {
        var endianBox = new EndianBox(new Header(EndianBox.fourcc()));
        endianBox.endian = endian;
        return endianBox;
    };
    prototype.parse = function(input) {
        var end = input.getShort();
        if (end == 1) {
            this.endian = ByteOrder.LITTLE_ENDIAN;
        } else {
            this.endian = ByteOrder.BIG_ENDIAN;
        }
    };
    prototype.doWrite = function(out) {
        out.putShort((((this.endian == ByteOrder.LITTLE_ENDIAN ? 1 : 0)) << 16 >> 16));
    };
    prototype.estimateSize = function() {
        return 2 + 8;
    };
    prototype.getEndian = function() {
        return this.endian;
    };
    prototype.calcSize = function() {
        return 2;
    };
}, {endian: "ByteOrder", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FullBox = function(atom) {
    Box.call(this, atom);
};
FullBox = stjs.extend(FullBox, Box, [], function(constructor, prototype) {
    prototype.version = 0;
    prototype.flags = 0;
    prototype.parse = function(input) {
        var vf = input.getInt();
        this.version = (((vf >> 24) & 255) << 24 >> 24);
        this.flags = vf & 16777215;
    };
    prototype.doWrite = function(out) {
        out.putInt((this.version << 24) | (this.flags & 16777215));
    };
    prototype.getVersion = function() {
        return this.version;
    };
    prototype.getFlags = function() {
        return this.flags;
    };
    prototype.setVersion = function(version) {
        this.version = version;
    };
    prototype.setFlags = function(flags) {
        this.flags = flags;
    };
}, {header: "Header"}, {});
var SimpleBoxFactory = function(boxes) {
    this.boxes = boxes;
};
SimpleBoxFactory = stjs.extend(SimpleBoxFactory, null, [IBoxFactory], function(constructor, prototype) {
    prototype.boxes = null;
    prototype.newBox = function(header) {
        var claz = this.boxes.toClass(header.getFourcc());
        if (claz == null) 
            return new Box.LeafBox(header);
        var box = Platform.newInstance(claz, [header]);
        return box;
    };
}, {boxes: "Boxes"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Default box factory
 *  
 *  @author The JCodec project
 *  
 */
var ColorExtension = function(header) {
    Box.call(this, header);
};
ColorExtension = stjs.extend(ColorExtension, Box, [], function(constructor, prototype) {
    prototype.primariesIndex = 0;
    prototype.transferFunctionIndex = 0;
    prototype.matrixIndex = 0;
    prototype.type = "nclc";
    constructor.RANGE_UNSPECIFIED = 0;
    constructor.AVCOL_RANGE_MPEG = 1;
    constructor.AVCOL_RANGE_JPEG = 2;
    prototype.colorRange = null;
    prototype.setColorRange = function(colorRange) {
        this.colorRange = colorRange;
    };
    prototype.parse = function(input) {
        var dst = new Int8Array(4);
        input.getBuf(dst);
        this.type = Platform.stringFromBytes(dst);
        this.primariesIndex = input.getShort();
        this.transferFunctionIndex = input.getShort();
        this.matrixIndex = input.getShort();
        if (input.hasRemaining()) {
            this.colorRange = input.get();
        }
    };
    prototype.doWrite = function(out) {
        out.putArr(JCodecUtil2.asciiString(this.type));
        out.putShort(this.primariesIndex);
        out.putShort(this.transferFunctionIndex);
        out.putShort(this.matrixIndex);
        if (this.colorRange != null) {
            out.put(this.colorRange);
        }
    };
    prototype.estimateSize = function() {
        return 8 + 8;
    };
    constructor.fourcc = function() {
        return "colr";
    };
    constructor.createColorExtension = function(primariesIndex, transferFunctionIndex, matrixIndex) {
        var c = new ColorExtension(new Header(ColorExtension.fourcc()));
        c.primariesIndex = primariesIndex;
        c.transferFunctionIndex = transferFunctionIndex;
        c.matrixIndex = matrixIndex;
        return c;
    };
    constructor.createColr = function() {
        return new ColorExtension(new Header(ColorExtension.fourcc()));
    };
    prototype.getPrimariesIndex = function() {
        return this.primariesIndex;
    };
    prototype.getTransferFunctionIndex = function() {
        return this.transferFunctionIndex;
    };
    prototype.getMatrixIndex = function() {
        return this.matrixIndex;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  
 *  @author The JCodec project
 *  
 */
var GamaExtension = function(header) {
    Box.call(this, header);
};
GamaExtension = stjs.extend(GamaExtension, Box, [], function(constructor, prototype) {
    prototype.gamma = 0.0;
    constructor.createGamaExtension = function(gamma) {
        var gamaExtension = new GamaExtension(new Header(GamaExtension.fourcc()));
        gamaExtension.gamma = gamma;
        return gamaExtension;
    };
    prototype.parse = function(input) {
        var g = input.getInt();
        this.gamma = g / 65536.0;
    };
    prototype.doWrite = function(out) {
        out.putInt(stjs.trunc((this.gamma * 65536)));
    };
    prototype.getGamma = function() {
        return this.gamma;
    };
    constructor.fourcc = function() {
        return "gama";
    };
    prototype.estimateSize = function() {
        return 12;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Load setting atom
 *  
 *  @author The JCodec project
 *  
 */
var LoadSettingsBox = function(header) {
    Box.call(this, header);
};
LoadSettingsBox = stjs.extend(LoadSettingsBox, Box, [], function(constructor, prototype) {
    prototype.preloadStartTime = 0;
    prototype.preloadDuration = 0;
    prototype.preloadFlags = 0;
    prototype.defaultHints = 0;
    constructor.fourcc = function() {
        return "load";
    };
    prototype.parse = function(input) {
        this.preloadStartTime = input.getInt();
        this.preloadDuration = input.getInt();
        this.preloadFlags = input.getInt();
        this.defaultHints = input.getInt();
    };
    prototype.doWrite = function(out) {
        out.putInt(this.preloadStartTime);
        out.putInt(this.preloadDuration);
        out.putInt(this.preloadFlags);
        out.putInt(this.defaultHints);
    };
    prototype.estimateSize = function() {
        return 24;
    };
    prototype.getPreloadStartTime = function() {
        return this.preloadStartTime;
    };
    prototype.getPreloadDuration = function() {
        return this.preloadDuration;
    };
    prototype.getPreloadFlags = function() {
        return this.preloadFlags;
    };
    prototype.getDefaultHints = function() {
        return this.defaultHints;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MP4ABox = function(header) {
    Box.call(this, header);
};
MP4ABox = stjs.extend(MP4ABox, Box, [], function(constructor, prototype) {
    prototype.val = 0;
    prototype.doWrite = function(out) {
        out.putInt(this.val);
    };
    prototype.parse = function(input) {
        this.val = input.getInt();
    };
    prototype.estimateSize = function() {
        return 12;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ClipRegionBox = function(atom) {
    Box.call(this, atom);
};
ClipRegionBox = stjs.extend(ClipRegionBox, Box, [], function(constructor, prototype) {
    prototype.rgnSize = 0;
    prototype.y = 0;
    prototype.x = 0;
    prototype.height = 0;
    prototype.width = 0;
    constructor.fourcc = function() {
        return "crgn";
    };
    constructor.createClipRegionBox = function(x, y, width, height) {
        var b = new ClipRegionBox(new Header(ClipRegionBox.fourcc()));
        b.rgnSize = 10;
        b.x = x;
        b.y = y;
        b.width = width;
        b.height = height;
        return b;
    };
    prototype.parse = function(input) {
        this.rgnSize = input.getShort();
        this.y = input.getShort();
        this.x = input.getShort();
        this.height = input.getShort();
        this.width = input.getShort();
    };
    prototype.doWrite = function(out) {
        out.putShort(this.rgnSize);
        out.putShort(this.y);
        out.putShort(this.x);
        out.putShort(this.height);
        out.putShort(this.width);
    };
    prototype.estimateSize = function() {
        return 10 + 8;
    };
    prototype.getRgnSize = function() {
        return this.rgnSize;
    };
    prototype.getY = function() {
        return this.y;
    };
    prototype.getX = function() {
        return this.x;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.getWidth = function() {
        return this.width;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  File type box
 *  
 *  
 *  @author The JCodec project
 *  
 */
var FileTypeBox = function(header) {
    Box.call(this, header);
    this.compBrands = new LinkedList();
};
FileTypeBox = stjs.extend(FileTypeBox, Box, [], function(constructor, prototype) {
    prototype.majorBrand = null;
    prototype.minorVersion = 0;
    prototype.compBrands = null;
    constructor.fourcc = function() {
        return "ftyp";
    };
    constructor.createFileTypeBox = function(majorBrand, minorVersion, compBrands) {
        var ftyp = new FileTypeBox(new Header(FileTypeBox.fourcc()));
        ftyp.majorBrand = majorBrand;
        ftyp.minorVersion = minorVersion;
        ftyp.compBrands = compBrands;
        return ftyp;
    };
    prototype.parse = function(input) {
        this.majorBrand = NIOUtils.readString(input, 4);
        this.minorVersion = input.getInt();
        var brand;
         while (input.hasRemaining() && (brand = NIOUtils.readString(input, 4)) != null){
            this.compBrands.add(brand);
        }
    };
    prototype.getMajorBrand = function() {
        return this.majorBrand;
    };
    prototype.getCompBrands = function() {
        return this.compBrands;
    };
    prototype.doWrite = function(out) {
        out.putArr(JCodecUtil2.asciiString(this.majorBrand));
        out.putInt(this.minorVersion);
        for (var iterator$string = this.compBrands.iterator(); iterator$string.hasNext(); ) {
            var string = iterator$string.next();
            out.putArr(JCodecUtil2.asciiString(string));
        }
    };
    prototype.estimateSize = function() {
        var size = 5 + 8;
        for (var iterator$string = this.compBrands.iterator(); iterator$string.hasNext(); ) {
            var string = iterator$string.next();
            size += JCodecUtil2.asciiString(string).length;
        }
        return size;
    };
}, {compBrands: {name: "Collection", arguments: [null]}, header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FormatBox = function(header) {
    Box.call(this, header);
};
FormatBox = stjs.extend(FormatBox, Box, [], function(constructor, prototype) {
    prototype.fmt = null;
    constructor.fourcc = function() {
        return "frma";
    };
    constructor.createFormatBox = function(fmt) {
        var frma = new FormatBox(new Header(FormatBox.fourcc()));
        frma.fmt = fmt;
        return frma;
    };
    prototype.parse = function(input) {
        this.fmt = NIOUtils.readString(input, 4);
    };
    prototype.doWrite = function(out) {
        out.putArr(JCodecUtil2.asciiString(this.fmt));
    };
    prototype.estimateSize = function() {
        return JCodecUtil2.asciiString(this.fmt).length + 8;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var CleanApertureExtension = function(header) {
    Box.call(this, header);
};
CleanApertureExtension = stjs.extend(CleanApertureExtension, Box, [], function(constructor, prototype) {
    prototype.vertOffsetDenominator = 0;
    prototype.vertOffsetNumerator = 0;
    prototype.horizOffsetDenominator = 0;
    prototype.horizOffsetNumerator = 0;
    prototype.apertureHeightDenominator = 0;
    prototype.apertureHeightNumerator = 0;
    prototype.apertureWidthDenominator = 0;
    prototype.apertureWidthNumerator = 0;
    constructor.createCleanApertureExtension = function(apertureWidthN, apertureWidthD, apertureHeightN, apertureHeightD, horizOffN, horizOffD, vertOffN, vertOffD) {
        var clap = new CleanApertureExtension(new Header(CleanApertureExtension.fourcc()));
        clap.apertureWidthNumerator = apertureWidthN;
        clap.apertureWidthDenominator = apertureWidthD;
        clap.apertureHeightNumerator = apertureHeightN;
        clap.apertureHeightDenominator = apertureHeightD;
        clap.horizOffsetNumerator = horizOffN;
        clap.horizOffsetDenominator = horizOffD;
        clap.vertOffsetNumerator = vertOffN;
        clap.vertOffsetDenominator = vertOffD;
        return clap;
    };
    prototype.parse = function(is) {
        this.apertureWidthNumerator = is.getInt();
        this.apertureWidthDenominator = is.getInt();
        this.apertureHeightNumerator = is.getInt();
        this.apertureHeightDenominator = is.getInt();
        this.horizOffsetNumerator = is.getInt();
        this.horizOffsetDenominator = is.getInt();
        this.vertOffsetNumerator = is.getInt();
        this.vertOffsetDenominator = is.getInt();
    };
    constructor.fourcc = function() {
        return "clap";
    };
    prototype.doWrite = function(out) {
        out.putInt(stjs.trunc(this.apertureWidthNumerator));
        out.putInt(stjs.trunc(this.apertureWidthDenominator));
        out.putInt(stjs.trunc(this.apertureHeightNumerator));
        out.putInt(stjs.trunc(this.apertureHeightDenominator));
        out.putInt(stjs.trunc(this.horizOffsetNumerator));
        out.putInt(stjs.trunc(this.horizOffsetDenominator));
        out.putInt(stjs.trunc(this.vertOffsetNumerator));
        out.putInt(stjs.trunc(this.vertOffsetDenominator));
    };
    prototype.estimateSize = function() {
        return 32 + 8;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var NameBox = function(header) {
    Box.call(this, header);
};
NameBox = stjs.extend(NameBox, Box, [], function(constructor, prototype) {
    prototype.name = null;
    constructor.fourcc = function() {
        return "name";
    };
    constructor.createNameBox = function(name) {
        var box = new NameBox(new Header(NameBox.fourcc()));
        box.name = name;
        return box;
    };
    prototype.parse = function(input) {
        this.name = NIOUtils.readNullTermString(input);
    };
    prototype.doWrite = function(out) {
        out.putArr(JCodecUtil2.asciiString(this.name));
        out.putInt(0);
    };
    prototype.estimateSize = function() {
        return 12 + JCodecUtil2.asciiString(this.name).length;
    };
    prototype.getName = function() {
        return this.name;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Creates MP4 file out of a set of samples
 *  
 *  @author The JCodec project
 *  
 */
var AvcCBox = function(header) {
    Box.call(this, header);
    this.spsList = new ArrayList();
    this.ppsList = new ArrayList();
};
AvcCBox = stjs.extend(AvcCBox, Box, [], function(constructor, prototype) {
    prototype.profile = 0;
    prototype.profileCompat = 0;
    prototype.level = 0;
    prototype.nalLengthSize = 0;
    prototype.spsList = null;
    prototype.ppsList = null;
    constructor.fourcc = function() {
        return "avcC";
    };
    constructor.parseAvcCBox = function(buf) {
        var avcCBox = new AvcCBox(new Header(AvcCBox.fourcc()));
        avcCBox.parse(buf);
        return avcCBox;
    };
    constructor.createEmpty = function() {
        return new AvcCBox(new Header(AvcCBox.fourcc()));
    };
    constructor.createAvcCBox = function(profile, profileCompat, level, nalLengthSize, spsList, ppsList) {
        var avcc = new AvcCBox(new Header(AvcCBox.fourcc()));
        avcc.profile = profile;
        avcc.profileCompat = profileCompat;
        avcc.level = level;
        avcc.nalLengthSize = nalLengthSize;
        avcc.spsList = spsList;
        avcc.ppsList = ppsList;
        return avcc;
    };
    prototype.parse = function(input) {
        NIOUtils.skip(input, 1);
        this.profile = input.get() & 255;
        this.profileCompat = input.get() & 255;
        this.level = input.get() & 255;
        var flags = input.get() & 255;
        this.nalLengthSize = (flags & 3) + 1;
        var nSPS = input.get() & 31;
        for (var i = 0; i < nSPS; i++) {
            var spsSize = input.getShort();
            Preconditions.checkState(39 == (input.get() & 63));
            this.spsList.add(NIOUtils.read(input, spsSize - 1));
        }
        var nPPS = input.get() & 255;
        for (var i = 0; i < nPPS; i++) {
            var ppsSize = input.getShort();
            Preconditions.checkState(40 == (input.get() & 63));
            this.ppsList.add(NIOUtils.read(input, ppsSize - 1));
        }
    };
    prototype.doWrite = function(out) {
        out.put((1 << 24 >> 24));
        out.put((this.profile << 24 >> 24));
        out.put((this.profileCompat << 24 >> 24));
        out.put((this.level << 24 >> 24));
        out.put((255 << 24 >> 24));
        out.put(((this.spsList.size() | 224) << 24 >> 24));
        for (var iterator$sps = this.spsList.iterator(); iterator$sps.hasNext(); ) {
            var sps = iterator$sps.next();
            out.putShort((((sps.remaining() + 1)) << 16 >> 16));
            out.put((103 << 24 >> 24));
            NIOUtils.write(out, sps);
        }
        out.put((this.ppsList.size() << 24 >> 24));
        for (var iterator$pps = this.ppsList.iterator(); iterator$pps.hasNext(); ) {
            var pps = iterator$pps.next();
            out.putShort(((pps.remaining() + 1) << 24 >> 24));
            out.put((104 << 24 >> 24));
            NIOUtils.write(out, pps);
        }
    };
    prototype.estimateSize = function() {
        var sz = 17;
        for (var iterator$sps = this.spsList.iterator(); iterator$sps.hasNext(); ) {
            var sps = iterator$sps.next();
            sz += 3 + sps.remaining();
        }
        for (var iterator$pps = this.ppsList.iterator(); iterator$pps.hasNext(); ) {
            var pps = iterator$pps.next();
            sz += 3 + pps.remaining();
        }
        return sz;
    };
    prototype.getProfile = function() {
        return this.profile;
    };
    prototype.getProfileCompat = function() {
        return this.profileCompat;
    };
    prototype.getLevel = function() {
        return this.level;
    };
    prototype.getSpsList = function() {
        return this.spsList;
    };
    prototype.getPpsList = function() {
        return this.ppsList;
    };
    prototype.getNalLengthSize = function() {
        return this.nalLengthSize;
    };
}, {spsList: {name: "List", arguments: ["ByteBuffer"]}, ppsList: {name: "List", arguments: ["ByteBuffer"]}, header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  File type box
 *  
 *  
 *  @author The JCodec project
 *  
 */
var SegmentTypeBox = function(header) {
    Box.call(this, header);
    this.compBrands = new LinkedList();
};
SegmentTypeBox = stjs.extend(SegmentTypeBox, Box, [], function(constructor, prototype) {
    prototype.majorBrand = null;
    prototype.minorVersion = 0;
    prototype.compBrands = null;
    constructor.createSegmentTypeBox = function(majorBrand, minorVersion, compBrands) {
        var styp = new SegmentTypeBox(new Header(SegmentTypeBox.fourcc()));
        styp.majorBrand = majorBrand;
        styp.minorVersion = minorVersion;
        styp.compBrands = compBrands;
        return styp;
    };
    constructor.fourcc = function() {
        return "styp";
    };
    prototype.parse = function(input) {
        this.majorBrand = NIOUtils.readString(input, 4);
        this.minorVersion = input.getInt();
        var brand;
         while (input.hasRemaining() && (brand = NIOUtils.readString(input, 4)) != null){
            this.compBrands.add(brand);
        }
    };
    prototype.getMajorBrand = function() {
        return this.majorBrand;
    };
    prototype.getCompBrands = function() {
        return this.compBrands;
    };
    prototype.doWrite = function(out) {
        out.putArr(JCodecUtil2.asciiString(this.majorBrand));
        out.putInt(this.minorVersion);
        for (var iterator$string = this.compBrands.iterator(); iterator$string.hasNext(); ) {
            var string = iterator$string.next();
            out.putArr(JCodecUtil2.asciiString(string));
        }
    };
    prototype.estimateSize = function() {
        var sz = 13;
        for (var iterator$string = this.compBrands.iterator(); iterator$string.hasNext(); ) {
            var string = iterator$string.next();
            sz += JCodecUtil2.asciiString(string).length;
        }
        return sz;
    };
}, {compBrands: {name: "Collection", arguments: [null]}, header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var FielExtension = function(header) {
    Box.call(this, header);
};
FielExtension = stjs.extend(FielExtension, Box, [], function(constructor, prototype) {
    prototype.type = 0;
    prototype.order = 0;
    constructor.fourcc = function() {
        return "fiel";
    };
    prototype.isInterlaced = function() {
        return this.type == 2;
    };
    prototype.topFieldFirst = function() {
        return this.order == 1 || this.order == 6;
    };
    prototype.getOrderInterpretation = function() {
        if (this.isInterlaced()) 
            switch (this.order) {
                case 1:
                    return "top";
                case 6:
                    return "bottom";
                case 9:
                    return "bottomtop";
                case 14:
                    return "topbottom";
            }
        return "";
    };
    prototype.parse = function(input) {
        this.type = input.get() & 255;
        if (this.isInterlaced()) {
            this.order = input.get() & 255;
        }
    };
    prototype.doWrite = function(out) {
        out.put((this.type << 24 >> 24));
        out.put((this.order << 24 >> 24));
    };
    prototype.estimateSize = function() {
        return 2 + 8;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MdtaBox = function(header) {
    Box.call(this, header);
};
MdtaBox = stjs.extend(MdtaBox, Box, [], function(constructor, prototype) {
    constructor.FOURCC = "mdta";
    prototype.key = null;
    constructor.createMdtaBox = function(key) {
        var box = new MdtaBox(Header.createHeader(MdtaBox.FOURCC, 0));
        box.key = key;
        return box;
    };
    prototype.parse = function(buf) {
        this.key = Platform.stringFromBytes(NIOUtils.toArray(NIOUtils.readBuf(buf)));
    };
    prototype.getKey = function() {
        return this.key;
    };
    prototype.doWrite = function(out) {
        out.putArr(this.key.getBytes());
    };
    prototype.estimateSize = function() {
        return this.key.getBytes().length;
    };
    constructor.fourcc = function() {
        return MdtaBox.FOURCC;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A node box
 *  
 *  A box containing children, no data
 *  
 *  @author The JCodec project
 *  
 */
var NodeBox = function(atom) {
    Box.call(this, atom);
    this.boxes = new LinkedList();
};
NodeBox = stjs.extend(NodeBox, Box, [], function(constructor, prototype) {
    prototype.boxes = null;
    prototype.factory = null;
    prototype.setFactory = function(factory) {
        this.factory = factory;
    };
    prototype.parse = function(input) {
         while (input.remaining() >= 8){
            var child = NodeBox.parseChildBox(input, this.factory);
            if (child != null) 
                this.boxes.add(child);
        }
    };
    constructor.parseChildBox = function(input, factory) {
        var fork = input.duplicate();
         while (input.remaining() >= 4 && fork.getInt() == 0)
            input.getInt();
        if (input.remaining() < 4) 
            return null;
        var ret = null;
        var childAtom = Header.read(input);
        if (childAtom != null && input.remaining() >= childAtom.getBodySize()) {
            ret = Box.parseBox(NIOUtils.read(input, ((childAtom.getBodySize()) | 0)), childAtom, factory);
        }
        return ret;
    };
    prototype.getBoxes = function() {
        return this.boxes;
    };
    prototype.add = function(box) {
        this.boxes.add(box);
    };
    prototype.doWrite = function(out) {
        for (var iterator$box = this.boxes.iterator(); iterator$box.hasNext(); ) {
            var box = iterator$box.next();
            box.write(out);
        }
    };
    prototype.estimateSize = function() {
        var total = 0;
        for (var iterator$box = this.boxes.iterator(); iterator$box.hasNext(); ) {
            var box = iterator$box.next();
            total += box.estimateSize();
        }
        return total + Header.estimateHeaderSize(total);
    };
    prototype.addFirst = function(box) {
        this.boxes.add(0, box);
    };
    prototype.replace = function(fourcc, box) {
        this.removeChildren(fourcc);
        this.add(box);
    };
    prototype.replaceBox = function(box) {
        this.removeChildren(box.getFourcc());
        this.add(box);
    };
    prototype.dump = function(sb) {
        sb.append("{\"tag\":\"" + this.header.getFourcc() + "\",");
        sb.append("\"boxes\": [");
        this.dumpBoxes(sb);
        sb.append("]");
        sb.append("}");
    };
    prototype.dumpBoxes = function(sb) {
        for (var i = 0; i < this.boxes.size(); i++) {
            this.boxes.get(i).dump(sb);
            if (i < this.boxes.size() - 1) 
                sb.append(",");
        }
    };
    prototype.removeChildren = function(_arguments) {
        for (var it = this.boxes.iterator(); it.hasNext(); ) {
            var box = it.next();
            var fcc = box.getFourcc();
            for (var i = 0; i < arguments.length; i++) {
                var cand = arguments[i];
                if (cand.equals(fcc)) {
                    it.remove();
                    break;
                }
            }
        }
    };
    constructor.doCloneBox = function(box, approxSize, bf) {
        var buf = ByteBuffer.allocate(approxSize);
        box.write(buf);
        buf.flip();
        return NodeBox.parseChildBox(buf, bf);
    };
    constructor.cloneBox = function(box, approxSize, bf) {
        return NodeBox.doCloneBox(box, approxSize, bf);
    };
    constructor.findDeep = function(box, class1, name) {
        var storage = new ArrayList();
        NodeBox.findDeepInner(box, class1, name, storage);
        return storage.toArray(jslang.reflect.Array.newInstance(class1, 0));
    };
    constructor.findDeepInner = function(box, class1, name, storage) {
        if (box == null) 
            return;
        if (name.equals(box.getHeader().getFourcc())) {
            storage.add(box);
            return;
        }
        if (stjs.isInstanceOf(box.constructor, NodeBox)) {
            var nb = box;
            for (var iterator$candidate = nb.getBoxes().iterator(); iterator$candidate.hasNext(); ) {
                var candidate = iterator$candidate.next();
                NodeBox.findDeepInner(candidate, class1, name, storage);
            }
        }
    };
    constructor.findAll = function(box, class1, path) {
        return NodeBox.findAllPath(box, class1, [path]);
    };
    constructor.findFirst = function(box, clazz, path) {
        return NodeBox.findFirstPath(box, clazz, [path]);
    };
    constructor.findFirstPath = function(box, clazz, path) {
        var result = NodeBox.findAllPath(box, clazz, path);
        return result.length > 0 ? result[0] : null;
    };
    constructor.findAllPath = function(box, class1, path) {
        var result = new LinkedList();
        NodeBox.findBox(box, new ArrayList(Arrays.asList(path)), result);
        for (var it = result.listIterator(); it.hasNext(); ) {
            var next = it.next();
            if (next == null) {
                it.remove();
            } else if (!Platform.isAssignableFrom(class1, next.getClass())) {
                try {
                    it.set(Box.asBox(class1, next));
                }catch (e) {
                    Logger.warn("Failed to reinterpret box: " + next.getFourcc() + " as: " + class1.getName() + "." + e.getMessage());
                    it.remove();
                }
            }
        }
        return result.toArray(jslang.reflect.Array.newInstance(class1, 0));
    };
    constructor.findBox = function(root, path, result) {
        if (path.size() > 0) {
            var head = path.remove(0);
            if (stjs.isInstanceOf(root.constructor, NodeBox)) {
                var nb = root;
                for (var iterator$candidate = nb.getBoxes().iterator(); iterator$candidate.hasNext(); ) {
                    var candidate = iterator$candidate.next();
                    if (head == null || head.equals(candidate.header.getFourcc())) {
                        NodeBox.findBox(candidate, path, result);
                    }
                }
            }
            path.add(0, head);
        } else {
            result.add(root);
        }
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  Pixel aspect ratio video sample entry extension
 *  
 *  @author The JCodec project
 */
var PixelAspectExt = function(header) {
    Box.call(this, header);
};
PixelAspectExt = stjs.extend(PixelAspectExt, Box, [], function(constructor, prototype) {
    prototype.hSpacing = 0;
    prototype.vSpacing = 0;
    constructor.createPixelAspectExt = function(par) {
        var pasp = new PixelAspectExt(new Header(PixelAspectExt.fourcc()));
        pasp.hSpacing = par.getNum();
        pasp.vSpacing = par.getDen();
        return pasp;
    };
    prototype.parse = function(input) {
        this.hSpacing = input.getInt();
        this.vSpacing = input.getInt();
    };
    prototype.doWrite = function(out) {
        out.putInt(this.hSpacing);
        out.putInt(this.vSpacing);
    };
    prototype.estimateSize = function() {
        return 16;
    };
    prototype.gethSpacing = function() {
        return this.hSpacing;
    };
    prototype.getvSpacing = function() {
        return this.vSpacing;
    };
    prototype.getRational = function() {
        return new Rational(this.hSpacing, this.vSpacing);
    };
    constructor.fourcc = function() {
        return "pasp";
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Coupling_channel_element; reference: table 4.8.
 *  
 *  @author The JCodec project
 *  
 */
var BlockCCE = function(bandType) {
    Block.call(this);
    this.bandType = bandType;
};
BlockCCE = stjs.extend(BlockCCE, Block, [], function(constructor, prototype) {
    prototype.coupling_point = 0;
    prototype.num_coupled = 0;
    prototype.type = null;
    prototype.id_select = null;
    prototype.ch_select = null;
    prototype.sign = 0;
    prototype.scale = null;
    prototype.cce_scale = null;
    prototype.blockICS = null;
    prototype.bandType = null;
    constructor.vlc = null;
    prototype.parse = function(_in) {
        var num_gain = 0;
        this.coupling_point = 2 * _in.read1Bit();
        this.num_coupled = _in.readNBit(3);
        for (var c = 0; c <= this.num_coupled; c++) {
            num_gain++;
            this.type[c] = _in.read1Bit() != 0 ? BlockType.TYPE_CPE : BlockType.TYPE_SCE;
            this.id_select[c] = _in.readNBit(4);
            if (this.type[c] == BlockType.TYPE_CPE) {
                this.ch_select[c] = _in.readNBit(2);
                if (this.ch_select[c] == 3) 
                    num_gain++;
            } else 
                this.ch_select[c] = 2;
        }
        this.coupling_point += _in.read1Bit() | (this.coupling_point >> 1);
        this.sign = _in.read1Bit();
        this.scale = this.cce_scale[_in.readNBit(2)];
        this.blockICS = new BlockICS();
        this.blockICS.parse(_in);
        for (var c = 0; c < num_gain; c++) {
            var idx = 0;
            var cge = 1;
            var gain = 0;
            if (c != 0) {
                cge = this.coupling_point == BlockCCE.CouplingPoint.AFTER_IMDCT.ordinal() ? 1 : _in.read1Bit();
                gain = cge != 0 ? BlockCCE.vlc.readVLC(_in) - 60 : 0;
            }
            if (this.coupling_point != BlockCCE.CouplingPoint.AFTER_IMDCT.ordinal()) {
                for (var g = 0; g < this.blockICS.num_window_groups; g++) {
                    for (var sfb = 0; sfb < this.blockICS.maxSfb; sfb++ , idx++) {
                        if (this.bandType[idx] != BlockICS.BandType.ZERO_BT) {
                            if (cge == 0) {
                                var t = BlockCCE.vlc.readVLC(_in) - 60;
                            }
                        }
                    }
                }
            }
        }
    };
    constructor.CouplingPoint = stjs.enumeration("BEFORE_TNS", "BETWEEN_TNS_AND_IMDCT", "UNDEF", "AFTER_IMDCT");
}, {type: "Array", id_select: "Int32Array", ch_select: "Int32Array", scale: "Object", cce_scale: "Array", blockICS: "BlockICS", bandType: "Array", vlc: "VLC", type: {name: "Enum", arguments: ["BlockType"]}}, {});
(function() {
    BlockCCE.vlc = new VLC(AACTab.ff_aac_scalefactor_code, AACTab.ff_aac_scalefactor_bits);
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Channel pair element; reference: table 4.4.
 *  
 *  @author The JCodec project
 *  
 */
var BlockCPE = function() {
    BlockICS.call(this);
};
BlockCPE = stjs.extend(BlockCPE, BlockICS, [], function(constructor, prototype) {
    prototype.ms_mask = null;
    prototype.parse = function(_in) {
        var common_window = _in.read1Bit();
        if (common_window != 0) {
            this.parseICSInfo(_in);
            var ms_present = _in.readNBit(2);
            if (ms_present == 3) {
                 throw new RuntimeException("ms_present = 3 is reserved.");
            } else if (ms_present != 0) 
                this.decodeMidSideStereo(_in, ms_present, 0, 0);
        }
        var ics1 = new BlockICS();
        ics1.parse(_in);
        var ics2 = new BlockICS();
        ics2.parse(_in);
    };
    prototype.decodeMidSideStereo = function(_in, ms_present, numWindowGroups, maxSfb) {
        if (ms_present == 1) {
            for (var idx = 0; idx < numWindowGroups * maxSfb; idx++) 
                this.ms_mask[idx] = _in.read1Bit();
        }
    };
}, {ms_mask: "Int32Array", profile: {name: "Enum", arguments: ["Profile"]}, spectral: "Array", vlc: "VLC", ff_aac_codebook_vector_vals: "Array", group_len: "Int32Array", band_type: "Int32Array", band_type_run_end: "Int32Array", ff_aac_pow2sf_tab: "Float32Array", sfs: "Float64Array", swbOffset: "Int32Array", type: {name: "Enum", arguments: ["BlockType"]}}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var FilterBank = function(smallFrames, channels) {
    if (smallFrames) {
        this.length = SyntaxConstants.WINDOW_SMALL_LEN_LONG;
        this.shortLen = SyntaxConstants.WINDOW_SMALL_LEN_SHORT;
        this.LONG_WINDOWS = [SineWindows.SINE_960, KBDWindows.KBD_960];
        this.SHORT_WINDOWS = [SineWindows.SINE_120, KBDWindows.KBD_120];
    } else {
        this.length = SyntaxConstants.WINDOW_LEN_LONG;
        this.shortLen = SyntaxConstants.WINDOW_LEN_SHORT;
        this.LONG_WINDOWS = [SineWindows.SINE_1024, KBDWindows.KBD_1024];
        this.SHORT_WINDOWS = [SineWindows.SINE_128, KBDWindows.KBD_128];
    }
    this.mid = stjs.trunc((this.length - this.shortLen) / 2);
    this.trans = stjs.trunc(this.shortLen / 2);
    this.mdctShort = new MDCT(this.shortLen * 2);
    this.mdctLong = new MDCT(this.length * 2);
    this.overlaps = Array.apply(null, Array(channels)).map(function() {
        return new Float32Array(this.length);
    });
    this.buf = new Float32Array(2 * this.length);
};
FilterBank = stjs.extend(FilterBank, null, [SyntaxConstants, SineWindows, KBDWindows], function(constructor, prototype) {
    prototype.LONG_WINDOWS = null;
    prototype.SHORT_WINDOWS = null;
    prototype.length = 0;
    prototype.shortLen = 0;
    prototype.mid = 0;
    prototype.trans = 0;
    prototype.mdctShort = null;
    prototype.mdctLong = null;
    prototype.buf = null;
    prototype.overlaps = null;
    prototype.process = function(windowSequence, windowShape, windowShapePrev, _in, out, channel) {
        var i;
        var overlap = this.overlaps[channel];
        switch (windowSequence) {
            case ICSInfo.WindowSequence.ONLY_LONG_SEQUENCE:
                this.mdctLong.process(_in, 0, this.buf, 0);
                for (i = 0; i < this.length; i++) {
                    out[i] = overlap[i] + (this.buf[i] * this.LONG_WINDOWS[windowShapePrev][i]);
                }
                for (i = 0; i < this.length; i++) {
                    overlap[i] = this.buf[this.length + i] * this.LONG_WINDOWS[windowShape][this.length - 1 - i];
                }
                break;
            case ICSInfo.WindowSequence.LONG_START_SEQUENCE:
                this.mdctLong.process(_in, 0, this.buf, 0);
                for (i = 0; i < this.length; i++) {
                    out[i] = overlap[i] + (this.buf[i] * this.LONG_WINDOWS[windowShapePrev][i]);
                }
                for (i = 0; i < this.mid; i++) {
                    overlap[i] = this.buf[this.length + i];
                }
                for (i = 0; i < this.shortLen; i++) {
                    overlap[this.mid + i] = this.buf[this.length + this.mid + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - i - 1];
                }
                for (i = 0; i < this.mid; i++) {
                    overlap[this.mid + this.shortLen + i] = 0;
                }
                break;
            case ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE:
                for (i = 0; i < 8; i++) {
                    this.mdctShort.process(_in, i * this.shortLen, this.buf, 2 * i * this.shortLen);
                }
                for (i = 0; i < this.mid; i++) {
                    out[i] = overlap[i];
                }
                for (i = 0; i < this.shortLen; i++) {
                    out[this.mid + i] = overlap[this.mid + i] + (this.buf[i] * this.SHORT_WINDOWS[windowShapePrev][i]);
                    out[this.mid + 1 * this.shortLen + i] = overlap[this.mid + this.shortLen * 1 + i] + (this.buf[this.shortLen * 1 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]) + (this.buf[this.shortLen * 2 + i] * this.SHORT_WINDOWS[windowShape][i]);
                    out[this.mid + 2 * this.shortLen + i] = overlap[this.mid + this.shortLen * 2 + i] + (this.buf[this.shortLen * 3 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]) + (this.buf[this.shortLen * 4 + i] * this.SHORT_WINDOWS[windowShape][i]);
                    out[this.mid + 3 * this.shortLen + i] = overlap[this.mid + this.shortLen * 3 + i] + (this.buf[this.shortLen * 5 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]) + (this.buf[this.shortLen * 6 + i] * this.SHORT_WINDOWS[windowShape][i]);
                    if (i < this.trans) 
                        out[this.mid + 4 * this.shortLen + i] = overlap[this.mid + this.shortLen * 4 + i] + (this.buf[this.shortLen * 7 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]) + (this.buf[this.shortLen * 8 + i] * this.SHORT_WINDOWS[windowShape][i]);
                }
                for (i = 0; i < this.shortLen; i++) {
                    if (i >= this.trans) 
                        overlap[this.mid + 4 * this.shortLen + i - this.length] = (this.buf[this.shortLen * 7 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]) + (this.buf[this.shortLen * 8 + i] * this.SHORT_WINDOWS[windowShape][i]);
                    overlap[this.mid + 5 * this.shortLen + i - this.length] = (this.buf[this.shortLen * 9 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]) + (this.buf[this.shortLen * 10 + i] * this.SHORT_WINDOWS[windowShape][i]);
                    overlap[this.mid + 6 * this.shortLen + i - this.length] = (this.buf[this.shortLen * 11 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]) + (this.buf[this.shortLen * 12 + i] * this.SHORT_WINDOWS[windowShape][i]);
                    overlap[this.mid + 7 * this.shortLen + i - this.length] = (this.buf[this.shortLen * 13 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]) + (this.buf[this.shortLen * 14 + i] * this.SHORT_WINDOWS[windowShape][i]);
                    overlap[this.mid + 8 * this.shortLen + i - this.length] = (this.buf[this.shortLen * 15 + i] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i]);
                }
                for (i = 0; i < this.mid; i++) {
                    overlap[this.mid + this.shortLen + i] = 0;
                }
                break;
            case ICSInfo.WindowSequence.LONG_STOP_SEQUENCE:
                this.mdctLong.process(_in, 0, this.buf, 0);
                for (i = 0; i < this.mid; i++) {
                    out[i] = overlap[i];
                }
                for (i = 0; i < this.shortLen; i++) {
                    out[this.mid + i] = overlap[this.mid + i] + (this.buf[this.mid + i] * this.SHORT_WINDOWS[windowShapePrev][i]);
                }
                for (i = 0; i < this.mid; i++) {
                    out[this.mid + this.shortLen + i] = overlap[this.mid + this.shortLen + i] + this.buf[this.mid + this.shortLen + i];
                }
                for (i = 0; i < this.length; i++) {
                    overlap[i] = this.buf[this.length + i] * this.LONG_WINDOWS[windowShape][this.length - 1 - i];
                }
                break;
        }
    };
    prototype.processLTP = function(windowSequence, windowShape, windowShapePrev, _in, out) {
        var i;
        switch (windowSequence) {
            case ICSInfo.WindowSequence.ONLY_LONG_SEQUENCE:
                for (i = this.length - 1; i >= 0; i--) {
                    this.buf[i] = _in[i] * this.LONG_WINDOWS[windowShapePrev][i];
                    this.buf[i + this.length] = _in[i + this.length] * this.LONG_WINDOWS[windowShape][this.length - 1 - i];
                }
                break;
            case ICSInfo.WindowSequence.LONG_START_SEQUENCE:
                for (i = 0; i < this.length; i++) {
                    this.buf[i] = _in[i] * this.LONG_WINDOWS[windowShapePrev][i];
                }
                for (i = 0; i < this.mid; i++) {
                    this.buf[i + this.length] = _in[i + this.length];
                }
                for (i = 0; i < this.shortLen; i++) {
                    this.buf[i + this.length + this.mid] = _in[i + this.length + this.mid] * this.SHORT_WINDOWS[windowShape][this.shortLen - 1 - i];
                }
                for (i = 0; i < this.mid; i++) {
                    this.buf[i + this.length + this.mid + this.shortLen] = 0;
                }
                break;
            case ICSInfo.WindowSequence.LONG_STOP_SEQUENCE:
                for (i = 0; i < this.mid; i++) {
                    this.buf[i] = 0;
                }
                for (i = 0; i < this.shortLen; i++) {
                    this.buf[i + this.mid] = _in[i + this.mid] * this.SHORT_WINDOWS[windowShapePrev][i];
                }
                for (i = 0; i < this.mid; i++) {
                    this.buf[i + this.mid + this.shortLen] = _in[i + this.mid + this.shortLen];
                }
                for (i = 0; i < this.length; i++) {
                    this.buf[i + this.length] = _in[i + this.length] * this.LONG_WINDOWS[windowShape][this.length - 1 - i];
                }
                break;
        }
        this.mdctLong.processForward(this.buf, out);
    };
    prototype.getOverlap = function(channel) {
        return this.overlaps[channel];
    };
}, {LONG_WINDOWS: "Array", SHORT_WINDOWS: "Array", mdctShort: "MDCT", mdctLong: "MDCT", buf: "Float32Array", overlaps: "Array", SINE_1024: "Float32Array", SINE_128: "Float32Array", SINE_960: "Float32Array", SINE_120: "Float32Array", KBD_1024: "Float32Array", KBD_128: "Float32Array", KBD_960: "Float32Array", KBD_120: "Float32Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var IMDCT = function(frameLen) {
    this.frameLen = frameLen;
    this.lbLong = stjs.trunc(frameLen / GCConstants.BANDS);
    this.shortFrameLen = stjs.trunc(frameLen / 8);
    this.lbShort = stjs.trunc(this.shortFrameLen / GCConstants.BANDS);
    this.lbMid = stjs.trunc((this.lbLong - this.lbShort) / 2);
};
IMDCT = stjs.extend(IMDCT, null, [GCConstants, IMDCTTables, Windows], function(constructor, prototype) {
    constructor.LONG_WINDOWS = [Windows.SINE_256, Windows.KBD_256];
    constructor.SHORT_WINDOWS = [Windows.SINE_32, Windows.KBD_32];
    prototype.frameLen = 0;
    prototype.shortFrameLen = 0;
    prototype.lbLong = 0;
    prototype.lbShort = 0;
    prototype.lbMid = 0;
    prototype.process = function(_in, out, winShape, winShapePrev, winSeq) {
        var buf = new Float32Array(this.frameLen);
        var b, j, i;
        if (winSeq.equals(ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE)) {
            for (b = 0; b < GCConstants.BANDS; b++) {
                for (j = 0; j < 8; j++) {
                    for (i = 0; i < this.lbShort; i++) {
                        if (b % 2 == 0) 
                            buf[this.lbLong * b + this.lbShort * j + i] = _in[this.shortFrameLen * j + this.lbShort * b + i];
                         else 
                            buf[this.lbLong * b + this.lbShort * j + i] = _in[this.shortFrameLen * j + this.lbShort * b + this.lbShort - 1 - i];
                    }
                }
            }
        } else {
            for (b = 0; b < GCConstants.BANDS; b++) {
                for (i = 0; i < this.lbLong; i++) {
                    if (b % 2 == 0) 
                        buf[this.lbLong * b + i] = _in[this.lbLong * b + i];
                     else 
                        buf[this.lbLong * b + i] = _in[this.lbLong * b + this.lbLong - 1 - i];
                }
            }
        }
        for (b = 0; b < GCConstants.BANDS; b++) {
            this.process2(buf, out, winSeq, winShape, winShapePrev, b);
        }
    };
    prototype.process2 = function(_in, out, winSeq, winShape, winShapePrev, band) {
        var bufIn = new Float32Array(this.lbLong);
        var bufOut = new Float32Array(this.lbLong * 2);
        var window = new Float32Array(this.lbLong * 2);
        var window1 = new Float32Array(this.lbShort * 2);
        var window2 = new Float32Array(this.lbShort * 2);
        var i;
        switch (winSeq) {
            case ICSInfo.WindowSequence.ONLY_LONG_SEQUENCE:
                for (i = 0; i < this.lbLong; i++) {
                    window[i] = IMDCT.LONG_WINDOWS[winShapePrev][i];
                    window[this.lbLong * 2 - 1 - i] = IMDCT.LONG_WINDOWS[winShape][i];
                }
                break;
            case ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE:
                for (i = 0; i < this.lbShort; i++) {
                    window1[i] = IMDCT.SHORT_WINDOWS[winShapePrev][i];
                    window1[this.lbShort * 2 - 1 - i] = IMDCT.SHORT_WINDOWS[winShape][i];
                    window2[i] = IMDCT.SHORT_WINDOWS[winShape][i];
                    window2[this.lbShort * 2 - 1 - i] = IMDCT.SHORT_WINDOWS[winShape][i];
                }
                break;
            case ICSInfo.WindowSequence.LONG_START_SEQUENCE:
                for (i = 0; i < this.lbLong; i++) {
                    window[i] = IMDCT.LONG_WINDOWS[winShapePrev][i];
                }
                for (i = 0; i < this.lbMid; i++) {
                    window[i + this.lbLong] = 1.0;
                }
                for (i = 0; i < this.lbShort; i++) {
                    window[i + this.lbMid + this.lbLong] = IMDCT.SHORT_WINDOWS[winShape][this.lbShort - 1 - i];
                }
                for (i = 0; i < this.lbMid; i++) {
                    window[i + this.lbMid + this.lbLong + this.lbShort] = 0.0;
                }
                break;
            case ICSInfo.WindowSequence.LONG_STOP_SEQUENCE:
                for (i = 0; i < this.lbMid; i++) {
                    window[i] = 0.0;
                }
                for (i = 0; i < this.lbShort; i++) {
                    window[i + this.lbMid] = IMDCT.SHORT_WINDOWS[winShapePrev][i];
                }
                for (i = 0; i < this.lbMid; i++) {
                    window[i + this.lbMid + this.lbShort] = 1.0;
                }
                for (i = 0; i < this.lbLong; i++) {
                    window[i + this.lbMid + this.lbShort + this.lbMid] = IMDCT.LONG_WINDOWS[winShape][this.lbLong - 1 - i];
                }
                break;
        }
        var j;
        if (winSeq.equals(ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE)) {
            var k;
            for (j = 0; j < 8; j++) {
                for (k = 0; k < this.lbShort; k++) {
                    bufIn[k] = _in[band * this.lbLong + j * this.lbShort + k];
                }
                if (j == 0) 
                    System.arraycopy(window1, 0, window, 0, this.lbShort * 2);
                 else 
                    System.arraycopy(window2, 0, window, 0, this.lbShort * 2);
                this.imdct(bufIn, bufOut, window, this.lbShort);
                for (k = 0; k < this.lbShort * 2; k++) {
                    out[band * this.lbLong * 2 + j * this.lbShort * 2 + k] = bufOut[k] / 32.0;
                }
            }
        } else {
            for (j = 0; j < this.lbLong; j++) {
                bufIn[j] = _in[band * this.lbLong + j];
            }
            this.imdct(bufIn, bufOut, window, this.lbLong);
            for (j = 0; j < this.lbLong * 2; j++) {
                out[band * this.lbLong * 2 + j] = bufOut[j] / 256.0;
            }
        }
    };
    prototype.imdct = function(_in, out, window, n) {
        var n2 = stjs.trunc(n / 2);
        var table, table2;
        if (n == 256) {
            table = IMDCTTables.IMDCT_TABLE_256;
            table2 = IMDCTTables.IMDCT_POST_TABLE_256;
        } else if (n == 32) {
            table = IMDCTTables.IMDCT_TABLE_32;
            table2 = IMDCTTables.IMDCT_POST_TABLE_32;
        } else 
             throw new AACException("gain control: unexpected IMDCT length");
        var tmp = new Float32Array(n);
        var i;
        for (i = 0; i < n2; ++i) {
            tmp[i] = _in[2 * i];
        }
        for (i = n2; i < n; ++i) {
            tmp[i] = -_in[2 * n - 1 - 2 * i];
        }
        var buf = Array.apply(null, Array(n2)).map(function() {
            return new Float32Array(2);
        });
        for (i = 0; i < n2; i++) {
            buf[i][0] = (table[i][0] * tmp[2 * i]) - (table[i][1] * tmp[2 * i + 1]);
            buf[i][1] = (table[i][0] * tmp[2 * i + 1]) + (table[i][1] * tmp[2 * i]);
        }
        FFT.process(buf, n2);
        for (i = 0; i < n2; i++) {
            tmp[i] = table2[i][0] * buf[i][0] + table2[i][1] * buf[n2 - 1 - i][0] + table2[i][2] * buf[i][1] + table2[i][3] * buf[n2 - 1 - i][1];
            tmp[n - 1 - i] = table2[i][2] * buf[i][0] - table2[i][3] * buf[n2 - 1 - i][0] - table2[i][0] * buf[i][1] + table2[i][1] * buf[n2 - 1 - i][1];
        }
        System.arraycopy(tmp, n2, out, 0, n2);
        for (i = n2; i < stjs.trunc(n * 3 / 2); ++i) {
            out[i] = -tmp[stjs.trunc(n * 3 / 2) - 1 - i];
        }
        for (i = stjs.trunc(n * 3 / 2); i < n * 2; ++i) {
            out[i] = -tmp[i - stjs.trunc(n * 3 / 2)];
        }
        for (i = 0; i < n; i++) {
            out[i] *= window[i];
        }
    };
}, {LONG_WINDOWS: "Array", SHORT_WINDOWS: "Array", LN_GAIN: "Int32Array", IMDCT_TABLE_256: "Array", IMDCT_TABLE_32: "Array", IMDCT_POST_TABLE_256: "Array", IMDCT_POST_TABLE_32: "Array", SINE_256: "Float32Array", SINE_32: "Float32Array", KBD_256: "Float32Array", KBD_32: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var GenericPictureEssenceDescriptor = function(ul) {
    FileDescriptor.call(this, ul);
};
GenericPictureEssenceDescriptor = stjs.extend(GenericPictureEssenceDescriptor, FileDescriptor, [], function(constructor, prototype) {
    constructor.LayoutType = stjs.enumeration("FullFrame", "SeparateFields", "OneField", "MixedFields", "SegmentedFrame");
    prototype.signalStandard = 0;
    prototype.frameLayout = null;
    prototype.storedWidth = 0;
    prototype.storedHeight = 0;
    prototype.storedF2Offset = 0;
    prototype.sampledWidth = 0;
    prototype.sampledHeight = 0;
    prototype.sampledXOffset = 0;
    prototype.sampledYOffset = 0;
    prototype.displayHeight = 0;
    prototype.displayWidth = 0;
    prototype.displayXOffset = 0;
    prototype.displayYOffset = 0;
    prototype.displayF2Offset = 0;
    prototype.aspectRatio = null;
    prototype.activeFormatDescriptor = 0;
    prototype.videoLineMap = null;
    prototype.alphaTransparency = 0;
    prototype.transferCharacteristic = null;
    prototype.imageAlignmentOffset = 0;
    prototype.imageStartOffset = 0;
    prototype.imageEndOffset = 0;
    prototype.fieldDominance = 0;
    prototype.pictureEssenceCoding = null;
    prototype.codingEquations = null;
    prototype.colorPrimaries = null;
    prototype.read = function(tags) {
        FileDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 12821:
                    this.signalStandard = _bb.get();
                    break;
                case 12812:
                    this.frameLayout = GenericPictureEssenceDescriptor.LayoutType.values()[_bb.get()];
                    break;
                case 12803:
                    this.storedWidth = _bb.getInt();
                    break;
                case 12802:
                    this.storedHeight = _bb.getInt();
                    break;
                case 12822:
                    this.storedF2Offset = _bb.getInt();
                    break;
                case 12805:
                    this.sampledWidth = _bb.getInt();
                    break;
                case 12804:
                    this.sampledHeight = _bb.getInt();
                    break;
                case 12806:
                    this.sampledXOffset = _bb.getInt();
                    break;
                case 12807:
                    this.sampledYOffset = _bb.getInt();
                    break;
                case 12808:
                    this.displayHeight = _bb.getInt();
                    break;
                case 12809:
                    this.displayWidth = _bb.getInt();
                    break;
                case 12810:
                    this.displayXOffset = _bb.getInt();
                    break;
                case 12811:
                    this.displayYOffset = _bb.getInt();
                    break;
                case 12823:
                    this.displayF2Offset = _bb.getInt();
                    break;
                case 12814:
                    this.aspectRatio = new Rational(_bb.getInt(), _bb.getInt());
                    break;
                case 12824:
                    this.activeFormatDescriptor = _bb.get();
                    break;
                case 12813:
                    this.videoLineMap = MXFMetadata.readInt32Batch(_bb);
                    break;
                case 12815:
                    this.alphaTransparency = _bb.get();
                    break;
                case 12816:
                    this.transferCharacteristic = UL.read(_bb);
                    break;
                case 12817:
                    this.imageAlignmentOffset = _bb.getInt();
                    break;
                case 12819:
                    this.imageStartOffset = _bb.getInt();
                    break;
                case 12820:
                    this.imageEndOffset = _bb.getInt();
                    break;
                case 12818:
                    this.fieldDominance = _bb.get();
                    break;
                case 12801:
                    this.pictureEssenceCoding = UL.read(_bb);
                    break;
                case 12826:
                    this.codingEquations = UL.read(_bb);
                    break;
                case 12825:
                    this.colorPrimaries = UL.read(_bb);
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getSignalStandard = function() {
        return this.signalStandard;
    };
    prototype.getFrameLayout = function() {
        return this.frameLayout;
    };
    prototype.getStoredWidth = function() {
        return this.storedWidth;
    };
    prototype.getStoredHeight = function() {
        return this.storedHeight;
    };
    prototype.getStoredF2Offset = function() {
        return this.storedF2Offset;
    };
    prototype.getSampledWidth = function() {
        return this.sampledWidth;
    };
    prototype.getSampledHeight = function() {
        return this.sampledHeight;
    };
    prototype.getSampledXOffset = function() {
        return this.sampledXOffset;
    };
    prototype.getSampledYOffset = function() {
        return this.sampledYOffset;
    };
    prototype.getDisplayHeight = function() {
        return this.displayHeight;
    };
    prototype.getDisplayWidth = function() {
        return this.displayWidth;
    };
    prototype.getDisplayXOffset = function() {
        return this.displayXOffset;
    };
    prototype.getDisplayYOffset = function() {
        return this.displayYOffset;
    };
    prototype.getDisplayF2Offset = function() {
        return this.displayF2Offset;
    };
    prototype.getAspectRatio = function() {
        return this.aspectRatio;
    };
    prototype.getActiveFormatDescriptor = function() {
        return this.activeFormatDescriptor;
    };
    prototype.getVideoLineMap = function() {
        return this.videoLineMap;
    };
    prototype.getAlphaTransparency = function() {
        return this.alphaTransparency;
    };
    prototype.getTransferCharacteristic = function() {
        return this.transferCharacteristic;
    };
    prototype.getImageAlignmentOffset = function() {
        return this.imageAlignmentOffset;
    };
    prototype.getImageStartOffset = function() {
        return this.imageStartOffset;
    };
    prototype.getImageEndOffset = function() {
        return this.imageEndOffset;
    };
    prototype.getFieldDominance = function() {
        return this.fieldDominance;
    };
    prototype.getPictureEssenceCoding = function() {
        return this.pictureEssenceCoding;
    };
    prototype.getCodingEquations = function() {
        return this.codingEquations;
    };
    prototype.getColorPrimaries = function() {
        return this.colorPrimaries;
    };
}, {frameLayout: {name: "Enum", arguments: ["GenericPictureEssenceDescriptor.LayoutType"]}, aspectRatio: "Rational", videoLineMap: "Int32Array", transferCharacteristic: "UL", pictureEssenceCoding: "UL", codingEquations: "UL", colorPrimaries: "UL", sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var GenericDataEssenceDescriptor = function(ul) {
    FileDescriptor.call(this, ul);
};
GenericDataEssenceDescriptor = stjs.extend(GenericDataEssenceDescriptor, FileDescriptor, [], function(constructor, prototype) {
    prototype.dataEssenceCoding = null;
    prototype.read = function(tags) {
        FileDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 15873:
                    this.dataEssenceCoding = UL.read(_bb);
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ FileDescriptor: " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getDataEssenceCoding = function() {
        return this.dataEssenceCoding;
    };
}, {dataEssenceCoding: "UL", sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var GenericSoundEssenceDescriptor = function(ul) {
    FileDescriptor.call(this, ul);
};
GenericSoundEssenceDescriptor = stjs.extend(GenericSoundEssenceDescriptor, FileDescriptor, [], function(constructor, prototype) {
    prototype.audioSamplingRate = null;
    prototype.locked = 0;
    prototype.audioRefLevel = 0;
    prototype.electroSpatialFormulation = 0;
    prototype.channelCount = 0;
    prototype.quantizationBits = 0;
    prototype.dialNorm = 0;
    prototype.soundEssenceCompression = null;
    prototype.read = function(tags) {
        FileDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 15619:
                    this.audioSamplingRate = new Rational(_bb.getInt(), _bb.getInt());
                    break;
                case 15618:
                    this.locked = _bb.get();
                    break;
                case 15620:
                    this.audioRefLevel = _bb.get();
                    break;
                case 15621:
                    this.electroSpatialFormulation = _bb.get();
                    break;
                case 15623:
                    this.channelCount = _bb.getInt();
                    break;
                case 15617:
                    this.quantizationBits = _bb.getInt();
                    break;
                case 15628:
                    this.dialNorm = _bb.get();
                    break;
                case 15622:
                    this.soundEssenceCompression = UL.read(_bb);
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getAudioSamplingRate = function() {
        return this.audioSamplingRate;
    };
    prototype.getLocked = function() {
        return this.locked;
    };
    prototype.getAudioRefLevel = function() {
        return this.audioRefLevel;
    };
    prototype.getElectroSpatialFormulation = function() {
        return this.electroSpatialFormulation;
    };
    prototype.getChannelCount = function() {
        return this.channelCount;
    };
    prototype.getQuantizationBits = function() {
        return this.quantizationBits;
    };
    prototype.getDialNorm = function() {
        return this.dialNorm;
    };
    prototype.getSoundEssenceCompression = function() {
        return this.soundEssenceCompression;
    };
}, {audioSamplingRate: "Rational", soundEssenceCompression: "UL", sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEG4Decoder = function() {
    VideoDecoder.call(this);
    this.refs = Array(2);
};
MPEG4Decoder = stjs.extend(MPEG4Decoder, VideoDecoder, [], function(constructor, prototype) {
    prototype.refs = null;
    prototype.prevMBs = null;
    prototype.mbs = null;
    prototype.ctx = null;
    prototype.decodeFrame = function(data, buffer) {
        if (this.ctx == null) 
            this.ctx = new MPEG4DecodingContext();
        if (!this.ctx.readHeaders(data)) 
            return null;
        this.ctx.fcodeForward = this.ctx.fcodeBackward = this.ctx.intraDCThreshold = 0;
        var br = BitReader.createBitReader(data);
        if (!this.ctx.readVOPHeader(br)) 
            return null;
        this.mbs = Array(this.ctx.mbWidth * this.ctx.mbHeight);
        for (var i = 0; i < this.mbs.length; i++) {
            this.mbs[i] = new Macroblock();
        }
        var decoded = null;
        if (this.ctx.codingType != MPEG4Bitstream.B_VOP) {
            switch (this.ctx.codingType) {
                case MPEG4Bitstream.I_VOP:
                    decoded = this.decodeIFrame(br, this.ctx, buffer);
                    break;
                case MPEG4Bitstream.P_VOP:
                    decoded = this.decodePFrame(br, this.ctx, buffer, this.ctx.fcodeForward);
                    break;
                case MPEG4Bitstream.S_VOP:
                     throw new RuntimeException("GMC not supported.");
                case MPEG4Bitstream.N_VOP:
                    return null;
            }
            this.refs[1] = this.refs[0];
            this.refs[0] = decoded;
            this.prevMBs = this.mbs;
        } else {
            decoded = this.decodeBFrame(br, this.ctx, buffer, this.ctx.quant, this.ctx.fcodeForward, this.ctx.fcodeBackward);
        }
        br.terminate();
        return decoded;
    };
    prototype.decodeIFrame = function(br, ctx, buffer) {
        var p = new Picture(ctx.mbWidth << 4, ctx.mbHeight << 4, buffer, null, ColorSpace.YUV420, 0, new Rect(0, 0, ctx.width, ctx.height));
        var bound = 0;
        for (var y = 0; y < ctx.mbHeight; y++) {
            for (var x = 0; x < ctx.mbWidth; x++) {
                var mb = this.mbs[y * ctx.mbWidth + x];
                mb.reset(x, y, bound);
                MPEG4Bitstream.readIntraMode(br, ctx, mb);
                var index = x + y * ctx.mbWidth;
                var aboveMb = null;
                var aboveLeftMb = null;
                var leftMb = null;
                var apos = index - ctx.mbWidth;
                var lpos = index - 1;
                var alpos = index - 1 - ctx.mbWidth;
                if (apos >= bound) 
                    aboveMb = this.mbs[apos];
                if (alpos >= bound) 
                    aboveLeftMb = this.mbs[alpos];
                if (x > 0 && lpos >= bound) 
                    leftMb = this.mbs[lpos];
                MPEG4Bitstream.readCoeffIntra(br, ctx, mb, aboveMb, leftMb, aboveLeftMb);
                x = mb.x;
                y = mb.y;
                bound = mb.bound;
                MPEG4Renderer.renderIntra(mb, ctx);
                MPEG4Decoder.putPix(p, mb, x, y);
            }
        }
        return p;
    };
    prototype.decodePFrame = function(br, ctx, buffers, fcode) {
        var bound = 0;
        var mbWidth = ctx.mbWidth;
        var mbHeight = ctx.mbHeight;
        var p = new Picture(ctx.mbWidth << 4, ctx.mbHeight << 4, buffers, null, ColorSpace.YUV420, 0, new Rect(0, 0, ctx.width, ctx.height));
        for (var y = 0; y < mbHeight; y++) {
            for (var x = 0; x < mbWidth; x++) {
                 while (br.checkNBit(10) == 1)
                    br.skip(10);
                if (MPEG4Bitstream.checkResyncMarker(br, fcode - 1)) {
                    bound = MPEG4Bitstream.readVideoPacketHeader(br, ctx, fcode - 1, true, false, true);
                    x = bound % mbWidth;
                    y = stjs.trunc(bound / mbWidth);
                }
                var index = x + y * ctx.mbWidth;
                var aboveMb = null;
                var aboveLeftMb = null;
                var leftMb = null;
                var aboveRightMb = null;
                var apos = index - ctx.mbWidth;
                var lpos = index - 1;
                var alpos = index - 1 - ctx.mbWidth;
                var arpos = index + 1 - ctx.mbWidth;
                if (apos >= bound) 
                    aboveMb = this.mbs[apos];
                if (alpos >= bound) 
                    aboveLeftMb = this.mbs[alpos];
                if (x > 0 && lpos >= bound) 
                    leftMb = this.mbs[lpos];
                if (arpos >= bound && x < ctx.mbWidth - 1) 
                    aboveRightMb = this.mbs[arpos];
                var mb = this.mbs[y * ctx.mbWidth + x];
                mb.reset(x, y, bound);
                MPEG4Bitstream.readInterModeCoeffs(br, ctx, fcode, mb, aboveMb, leftMb, aboveLeftMb, aboveRightMb);
                MPEG4Renderer.renderInter(ctx, this.refs, mb, fcode, 0, false);
                MPEG4Decoder.putPix(p, mb, x, y);
            }
        }
        return p;
    };
    prototype.decodeBFrame = function(br, ctx, buffers, quant, fcodeForward, fcodeBackward) {
        var p = new Picture(ctx.mbWidth << 4, ctx.mbHeight << 4, buffers, null, ColorSpace.YUV420, 0, new Rect(0, 0, ctx.width, ctx.height));
        var pFMV = Macroblock.vec(), pBMV = Macroblock.vec();
        var fcodeMax = (fcodeForward > fcodeBackward) ? fcodeForward : fcodeBackward;
        for (var y = 0; y < ctx.mbHeight; y++) {
            pBMV.x = pBMV.y = pFMV.x = pFMV.y = 0;
            for (var x = 0; x < ctx.mbWidth; x++) {
                var mb = this.mbs[y * ctx.mbWidth + x];
                var lastMB = this.prevMBs[y * ctx.mbWidth + x];
                if (MPEG4Bitstream.checkResyncMarker(br, fcodeMax - 1)) {
                    var bound = MPEG4Bitstream.readVideoPacketHeader(br, ctx, fcodeMax - 1, fcodeForward != 0, fcodeBackward != 0, ctx.intraDCThreshold != 0);
                    x = bound % ctx.mbWidth;
                    y = stjs.trunc(bound / ctx.mbWidth);
                    pBMV.x = pBMV.y = pFMV.x = pFMV.y = 0;
                }
                mb.x = x;
                mb.y = y;
                mb.quant = quant;
                if (lastMB.mode == MPEG4Consts.MODE_NOT_CODED) {
                    mb.cbp = 0;
                    mb.mode = MPEG4Consts.MODE_FORWARD;
                    MPEG4Bitstream.readInterCoeffs(br, ctx, mb);
                    MPEG4Renderer.renderInter(ctx, this.refs, lastMB, fcodeForward, 1, true);
                    MPEG4Decoder.putPix(p, lastMB, x, y);
                    continue;
                }
                MPEG4Bitstream.readBi(br, ctx, fcodeForward, fcodeBackward, mb, lastMB, pFMV, pBMV);
                MPEG4BiRenderer.renderBi(ctx, this.refs, fcodeForward, fcodeBackward, mb);
                MPEG4Decoder.putPix(p, mb, x, y);
            }
        }
        return p;
    };
    constructor.putPix = function(p, mb, x, y) {
        var plane0 = p.getPlaneData(0);
        var dsto0 = ((y << 4)) * p.getWidth() + (x << 4);
        for (var row = 0, srco = 0; row < 16; row++ , dsto0 += p.getWidth()) {
            for (var col = 0; col < 16; col++ , srco++) {
                plane0[dsto0 + col] = mb.pred[0][srco];
            }
        }
        for (var pl = 1; pl < 3; pl++) {
            var plane = p.getPlaneData(pl);
            var dsto = ((y << 3)) * p.getPlaneWidth(pl) + (x << 3);
            for (var row = 0, srco = 0; row < 8; row++ , dsto += p.getPlaneWidth(pl)) {
                for (var col = 0; col < 8; col++ , srco++) {
                    plane[dsto + col] = mb.pred[pl][srco];
                }
            }
        }
    };
    prototype.getCodecMeta = function(data) {
        var ctx = MPEG4DecodingContext.readFromHeaders(data.duplicate());
        if (ctx == null) 
            return null;
        return VideoCodecMeta.createSimpleVideoCodecMeta(new Size(ctx.width, ctx.height), ColorSpace.YUV420J);
    };
    constructor.probe = function(data) {
        var ctx = MPEG4DecodingContext.readFromHeaders(data.duplicate());
        if (ctx == null) 
            return 0;
        return Math.min(ctx.width > 320 ? (ctx.width < 1280 ? 100 : 50) : 50, ctx.height > 240 ? (ctx.height < 720 ? 100 : 50) : 50);
    };
}, {refs: "Array", prevMBs: "Array", mbs: "Array", ctx: "MPEG4DecodingContext", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A handler description box
 *  
 *  @author The JCodec project
 *  
 */
var HandlerBox = function(atom) {
    FullBox.call(this, atom);
};
HandlerBox = stjs.extend(HandlerBox, FullBox, [], function(constructor, prototype) {
    prototype.componentType = null;
    prototype.componentSubType = null;
    prototype.componentManufacturer = null;
    prototype.componentFlags = 0;
    prototype.componentFlagsMask = 0;
    prototype.componentName = null;
    constructor.fourcc = function() {
        return "hdlr";
    };
    constructor.createHandlerBox = function(componentType, componentSubType, componentManufacturer, componentFlags, componentFlagsMask) {
        var hdlr = new HandlerBox(new Header(HandlerBox.fourcc()));
        hdlr.componentType = componentType;
        hdlr.componentSubType = componentSubType;
        hdlr.componentManufacturer = componentManufacturer;
        hdlr.componentFlags = componentFlags;
        hdlr.componentFlagsMask = componentFlagsMask;
        hdlr.componentName = "";
        return hdlr;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.componentType = NIOUtils.readString(input, 4);
        this.componentSubType = NIOUtils.readString(input, 4);
        this.componentManufacturer = NIOUtils.readString(input, 4);
        this.componentFlags = input.getInt();
        this.componentFlagsMask = input.getInt();
        this.componentName = NIOUtils.readString(input, input.remaining());
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putArr(JCodecUtil2.asciiString(this.componentType));
        out.putArr(JCodecUtil2.asciiString(this.componentSubType));
        out.putArr(JCodecUtil2.asciiString(this.componentManufacturer));
        out.putInt(this.componentFlags);
        out.putInt(this.componentFlagsMask);
        if (this.componentName != null) {
            out.putArr(JCodecUtil2.asciiString(this.componentName));
        }
    };
    prototype.estimateSize = function() {
        return 12 + JCodecUtil2.asciiString(this.componentType).length + JCodecUtil2.asciiString(this.componentSubType).length + JCodecUtil2.asciiString(this.componentManufacturer).length + 9;
    };
    prototype.getComponentType = function() {
        return this.componentType;
    };
    prototype.getComponentSubType = function() {
        return this.componentSubType;
    };
    prototype.getComponentManufacturer = function() {
        return this.componentManufacturer;
    };
    prototype.getComponentFlags = function() {
        return this.componentFlags;
    };
    prototype.getComponentFlagsMask = function() {
        return this.componentFlagsMask;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VideoMediaHeaderBox = function(header) {
    FullBox.call(this, header);
};
VideoMediaHeaderBox = stjs.extend(VideoMediaHeaderBox, FullBox, [], function(constructor, prototype) {
    prototype.graphicsMode = 0;
    prototype.rOpColor = 0;
    prototype.gOpColor = 0;
    prototype.bOpColor = 0;
    constructor.fourcc = function() {
        return "vmhd";
    };
    constructor.createVideoMediaHeaderBox = function(graphicsMode, rOpColor, gOpColor, bOpColor) {
        var vmhd = new VideoMediaHeaderBox(new Header(VideoMediaHeaderBox.fourcc()));
        vmhd.graphicsMode = graphicsMode;
        vmhd.rOpColor = rOpColor;
        vmhd.gOpColor = gOpColor;
        vmhd.bOpColor = bOpColor;
        return vmhd;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.graphicsMode = input.getShort();
        this.rOpColor = input.getShort();
        this.gOpColor = input.getShort();
        this.bOpColor = input.getShort();
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putShort(((this.graphicsMode) << 16 >> 16));
        out.putShort(((this.rOpColor) << 16 >> 16));
        out.putShort(((this.gOpColor) << 16 >> 16));
        out.putShort(((this.bOpColor) << 16 >> 16));
    };
    prototype.estimateSize = function() {
        return 20;
    };
    prototype.getGraphicsMode = function() {
        return this.graphicsMode;
    };
    prototype.getrOpColor = function() {
        return this.rOpColor;
    };
    prototype.getgOpColor = function() {
        return this.gOpColor;
    };
    prototype.getbOpColor = function() {
        return this.bOpColor;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 4 elementary stream descriptor
 *  
 *  @author The JCodec project
 *  
 */
var EsdsBox = function(atom) {
    FullBox.call(this, atom);
};
EsdsBox = stjs.extend(EsdsBox, FullBox, [], function(constructor, prototype) {
    prototype.streamInfo = null;
    prototype.objectType = 0;
    prototype.bufSize = 0;
    prototype.maxBitrate = 0;
    prototype.avgBitrate = 0;
    prototype.trackId = 0;
    constructor.fourcc = function() {
        return "esds";
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        if (this.streamInfo != null && this.streamInfo.remaining() > 0) {
            var l = new ArrayList();
            var l1 = new ArrayList();
            l1.add(new DecoderSpecific(this.streamInfo));
            l.add(new DecoderConfig(this.objectType, this.bufSize, this.maxBitrate, this.avgBitrate, l1));
            l.add(new SL());
            new ES(this.trackId, l).write(out);
        } else {
            var l = new ArrayList();
            l.add(new DecoderConfig(this.objectType, this.bufSize, this.maxBitrate, this.avgBitrate, new ArrayList()));
            l.add(new SL());
            new ES(this.trackId, l).write(out);
        }
    };
    prototype.estimateSize = function() {
        return 64;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        var es = DescriptorParser.read(input);
        this.trackId = es.getTrackId();
        var decoderConfig = NodeDescriptor.findByTag(es, DecoderConfig.tag());
        this.objectType = decoderConfig.getObjectType();
        this.bufSize = decoderConfig.getBufSize();
        this.maxBitrate = decoderConfig.getMaxBitrate();
        this.avgBitrate = decoderConfig.getAvgBitrate();
        var decoderSpecific = NodeDescriptor.findByTag(decoderConfig, DecoderSpecific.tag());
        this.streamInfo = decoderSpecific.getData();
    };
    prototype.getStreamInfo = function() {
        return this.streamInfo;
    };
    prototype.getObjectType = function() {
        return this.objectType;
    };
    prototype.getBufSize = function() {
        return this.bufSize;
    };
    prototype.getMaxBitrate = function() {
        return this.maxBitrate;
    };
    prototype.getAvgBitrate = function() {
        return this.avgBitrate;
    };
    prototype.getTrackId = function() {
        return this.trackId;
    };
    constructor.fromADTS = function(hdr) {
        return EsdsBox.createEsdsBox(ADTSParser.adtsToStreamInfo(hdr), hdr.getObjectType() << 5, 0, 210750, 133350, 2);
    };
    constructor.createEsdsBox = function(streamInfo, objectType, bufSize, maxBitrate, avgBitrate, trackId) {
        var esds = new EsdsBox(new Header(EsdsBox.fourcc()));
        esds.objectType = objectType;
        esds.bufSize = bufSize;
        esds.maxBitrate = maxBitrate;
        esds.avgBitrate = avgBitrate;
        esds.trackId = trackId;
        esds.streamInfo = streamInfo;
        return esds;
    };
    constructor.newEsdsBox = function() {
        return new EsdsBox(new Header(EsdsBox.fourcc()));
    };
}, {streamInfo: "ByteBuffer", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A box storing a list of synch samples
 *  
 *  @author The JCodec project
 *  
 */
var SyncSamplesBox = function(header) {
    FullBox.call(this, header);
};
SyncSamplesBox = stjs.extend(SyncSamplesBox, FullBox, [], function(constructor, prototype) {
    constructor.STSS = "stss";
    prototype.syncSamples = null;
    constructor.createSyncSamplesBox = function(array) {
        var stss = new SyncSamplesBox(new Header(SyncSamplesBox.STSS));
        stss.syncSamples = array;
        return stss;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        var len = input.getInt();
        this.syncSamples = new Int32Array(len);
        for (var i = 0; i < len; i++) {
            this.syncSamples[i] = input.getInt();
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.syncSamples.length);
        for (var i = 0; i < this.syncSamples.length; i++) 
            out.putInt(stjs.trunc(this.syncSamples[i]));
    };
    prototype.estimateSize = function() {
        return 16 + this.syncSamples.length * 4;
    };
    prototype.getSyncSamples = function() {
        return this.syncSamples;
    };
}, {syncSamples: "Int32Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  A box to hold chunk offsets
 *  
 *  @author The JCodec project
 *  
 */
var ChunkOffsetsBox = function(atom) {
    FullBox.call(this, atom);
};
ChunkOffsetsBox = stjs.extend(ChunkOffsetsBox, FullBox, [], function(constructor, prototype) {
    prototype.chunkOffsets = null;
    constructor.fourcc = function() {
        return "stco";
    };
    constructor.createChunkOffsetsBox = function(chunkOffsets) {
        var stco = new ChunkOffsetsBox(new Header(ChunkOffsetsBox.fourcc()));
        stco.chunkOffsets = chunkOffsets;
        return stco;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        var length = input.getInt();
        this.chunkOffsets = Array(length);
        for (var i = 0; i < length; i++) {
            this.chunkOffsets[i] = Platform.unsignedInt(input.getInt());
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.chunkOffsets.length);
        for (var i = 0; i < this.chunkOffsets.length; i++) {
            var offset = this.chunkOffsets[i];
            out.putInt(((offset) | 0));
        }
    };
    prototype.estimateSize = function() {
        return 12 + 4 + this.chunkOffsets.length * 4;
    };
    prototype.getChunkOffsets = function() {
        return this.chunkOffsets;
    };
    prototype.setChunkOffsets = function(chunkOffsets) {
        this.chunkOffsets = chunkOffsets;
    };
}, {chunkOffsets: "Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var TimecodeMediaInfoBox = function(atom) {
    FullBox.call(this, atom);
    this.color = new Int16Array(3);
    this.bgcolor = new Int16Array(3);
};
TimecodeMediaInfoBox = stjs.extend(TimecodeMediaInfoBox, FullBox, [], function(constructor, prototype) {
    prototype.font = 0;
    prototype.face = 0;
    prototype.size = 0;
    prototype.color = null;
    prototype.bgcolor = null;
    prototype.name = null;
    constructor.fourcc = function() {
        return "tcmi";
    };
    constructor.createTimecodeMediaInfoBox = function(font, face, size, color, bgcolor, name) {
        var box = new TimecodeMediaInfoBox(new Header(TimecodeMediaInfoBox.fourcc()));
        box.font = font;
        box.face = face;
        box.size = size;
        box.color = color;
        box.bgcolor = bgcolor;
        box.name = name;
        return box;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.font = input.getShort();
        this.face = input.getShort();
        this.size = input.getShort();
        input.getShort();
        this.color[0] = input.getShort();
        this.color[1] = input.getShort();
        this.color[2] = input.getShort();
        this.bgcolor[0] = input.getShort();
        this.bgcolor[1] = input.getShort();
        this.bgcolor[2] = input.getShort();
        this.name = NIOUtils.readPascalString(input);
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putShort(this.font);
        out.putShort(this.face);
        out.putShort(this.size);
        out.putShort(((0) << 16 >> 16));
        out.putShort(this.color[0]);
        out.putShort(this.color[1]);
        out.putShort(this.color[2]);
        out.putShort(this.bgcolor[0]);
        out.putShort(this.bgcolor[1]);
        out.putShort(this.bgcolor[2]);
        NIOUtils.writePascalString(out, this.name);
    };
    prototype.estimateSize = function() {
        return 32 + 1 + NIOUtils.asciiString(this.name).length;
    };
}, {color: "Int16Array", bgcolor: "Int16Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Sample to chunk mapping box
 *  
 *  @author The JCodec project
 *  
 */
var SampleToChunkBox = function(atom) {
    FullBox.call(this, atom);
};
SampleToChunkBox = stjs.extend(SampleToChunkBox, FullBox, [], function(constructor, prototype) {
    constructor.SampleToChunkEntry = function(first, count, entry) {
        this.first = first;
        this.count = count;
        this.entry = entry;
    };
    constructor.SampleToChunkEntry = stjs.extend(constructor.SampleToChunkEntry, null, [], function(constructor, prototype) {
        prototype.first = 0;
        prototype.count = 0;
        prototype.entry = 0;
        prototype.getFirst = function() {
            return this.first;
        };
        prototype.setFirst = function(first) {
            this.first = first;
        };
        prototype.getCount = function() {
            return this.count;
        };
        prototype.getEntry = function() {
            return this.entry;
        };
        prototype.setEntry = function(entry) {
            this.entry = entry;
        };
        prototype.setCount = function(count) {
            this.count = count;
        };
    }, {}, {});
    constructor.fourcc = function() {
        return "stsc";
    };
    constructor.createSampleToChunkBox = function(sampleToChunk) {
        var box = new SampleToChunkBox(new Header(SampleToChunkBox.fourcc()));
        box.sampleToChunk = sampleToChunk;
        return box;
    };
    prototype.sampleToChunk = null;
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        var size = input.getInt();
        this.sampleToChunk = Array(size);
        for (var i = 0; i < size; i++) {
            this.sampleToChunk[i] = new SampleToChunkBox.SampleToChunkEntry(input.getInt(), input.getInt(), input.getInt());
        }
    };
    prototype.getSampleToChunk = function() {
        return this.sampleToChunk;
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.sampleToChunk.length);
        for (var i = 0; i < this.sampleToChunk.length; i++) {
            var stc = this.sampleToChunk[i];
            out.putInt(((stc.getFirst()) | 0));
            out.putInt(stjs.trunc(stc.getCount()));
            out.putInt(stjs.trunc(stc.getEntry()));
        }
    };
    prototype.estimateSize = function() {
        return 16 + this.sampleToChunk.length * 12;
    };
    prototype.setSampleToChunk = function(sampleToChunk) {
        this.sampleToChunk = sampleToChunk;
    };
}, {sampleToChunk: "Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AliasBox = function(atom) {
    FullBox.call(this, atom);
};
AliasBox = stjs.extend(AliasBox, FullBox, [], function(constructor, prototype) {
    constructor.DirectoryName = 0;
    constructor.DirectoryIDs = 1;
    constructor.AbsolutePath = 2;
    constructor.AppleShareZoneName = 3;
    constructor.AppleShareServerName = 4;
    constructor.AppleShareUserName = 5;
    constructor.DriverName = 6;
    constructor.RevisedAppleShare = 9;
    constructor.AppleRemoteAccessDialup = 10;
    constructor.UNIXAbsolutePath = 18;
    constructor.UTF16AbsolutePath = 14;
    constructor.UFT16VolumeName = 15;
    constructor.VolumeMountPoint = 19;
    prototype.type = null;
    prototype.recordSize = 0;
    prototype.version = 0;
    prototype.kind = 0;
    prototype.volumeName = null;
    prototype.volumeCreateDate = 0;
    prototype.volumeSignature = 0;
    prototype.volumeType = 0;
    prototype.parentDirId = 0;
    prototype.fileName = null;
    prototype.fileNumber = 0;
    prototype.createdLocalDate = 0;
    prototype.fileTypeName = null;
    prototype.creatorName = null;
    prototype.nlvlFrom = 0;
    prototype.nlvlTo = 0;
    prototype.volumeAttributes = 0;
    prototype.fsId = 0;
    prototype.extra = null;
    constructor.fourcc = function() {
        return "alis";
    };
    constructor.ExtraField = function(type, len, bs) {
        this.type = type;
        this.len = len;
        this.data = bs;
    };
    constructor.ExtraField = stjs.extend(constructor.ExtraField, null, [], function(constructor, prototype) {
        prototype.type = 0;
        prototype.len = 0;
        prototype.data = null;
        prototype.toString = function() {
            return Platform.stringFromCharset4(this.data, 0, this.len, (this.type == 14 || this.type == 15) ? Platform.UTF_16 : Platform.UTF_8);
        };
    }, {data: "Int8Array"}, {});
    prototype.parse = function(is) {
        FullBox.prototype.parse.call(this, is);
        if ((this.flags & 1) != 0) 
            return;
        this.type = NIOUtils.readString(is, 4);
        this.recordSize = is.getShort();
        this.version = is.getShort();
        this.kind = is.getShort();
        this.volumeName = NIOUtils.readPascalStringL(is, 27);
        this.volumeCreateDate = is.getInt();
        this.volumeSignature = is.getShort();
        this.volumeType = is.getShort();
        this.parentDirId = is.getInt();
        this.fileName = NIOUtils.readPascalStringL(is, 63);
        this.fileNumber = is.getInt();
        this.createdLocalDate = is.getInt();
        this.fileTypeName = NIOUtils.readString(is, 4);
        this.creatorName = NIOUtils.readString(is, 4);
        this.nlvlFrom = is.getShort();
        this.nlvlTo = is.getShort();
        this.volumeAttributes = is.getInt();
        this.fsId = is.getShort();
        NIOUtils.skip(is, 10);
        this.extra = new ArrayList();
         while (true){
            var type = is.getShort();
            if (type == -1) 
                break;
            var len = is.getShort();
            var bs = NIOUtils.toArray(NIOUtils.read(is, (len + 1) & -2));
            if (bs == null) 
                break;
            this.extra.add(new AliasBox.ExtraField(type, len, bs));
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        if ((this.flags & 1) != 0) 
            return;
        out.put3(JCodecUtil2.asciiString(this.type), 0, 4);
        out.putShort(this.recordSize);
        out.putShort(this.version);
        out.putShort(this.kind);
        NIOUtils.writePascalStringL(out, this.volumeName, 27);
        out.putInt(this.volumeCreateDate);
        out.putShort(this.volumeSignature);
        out.putShort(this.volumeType);
        out.putInt(this.parentDirId);
        NIOUtils.writePascalStringL(out, this.fileName, 63);
        out.putInt(this.fileNumber);
        out.putInt(this.createdLocalDate);
        out.put3(JCodecUtil2.asciiString(this.fileTypeName), 0, 4);
        out.put3(JCodecUtil2.asciiString(this.creatorName), 0, 4);
        out.putShort(this.nlvlFrom);
        out.putShort(this.nlvlTo);
        out.putInt(this.volumeAttributes);
        out.putShort(this.fsId);
        out.putArr(new Int8Array(10));
        for (var iterator$extraField = this.extra.iterator(); iterator$extraField.hasNext(); ) {
            var extraField = iterator$extraField.next();
            out.putShort(extraField.type);
            out.putShort(((extraField.len) << 16 >> 16));
            out.putArr(extraField.data);
        }
        out.putShort(((-1) << 16 >> 16));
        out.putShort(((0) << 16 >> 16));
    };
    prototype.estimateSize = function() {
        var sz = 166;
        if ((this.flags & 1) == 0) {
            for (var iterator$extraField = this.extra.iterator(); iterator$extraField.hasNext(); ) {
                var extraField = iterator$extraField.next();
                sz += 4 + extraField.data.length;
            }
        }
        return 12 + sz;
    };
    prototype.getRecordSize = function() {
        return this.recordSize;
    };
    prototype.getFileName = function() {
        return this.fileName;
    };
    prototype.getExtras = function() {
        return this.extra;
    };
    prototype.getExtra = function(type) {
        for (var iterator$extraField = this.extra.iterator(); iterator$extraField.hasNext(); ) {
            var extraField = iterator$extraField.next();
            if (extraField.type == type) 
                return extraField;
        }
        return null;
    };
    prototype.isSelfRef = function() {
        return (this.flags & 1) != 0;
    };
    constructor.createSelfRef = function() {
        var alis = new AliasBox(new Header(AliasBox.fourcc()));
        alis.setFlags(1);
        return alis;
    };
    prototype.getUnixPath = function() {
        var extraField = this.getExtra(AliasBox.UNIXAbsolutePath);
        return extraField == null ? null : "/" + extraField.toString();
    };
}, {extra: {name: "List", arguments: ["AliasBox.ExtraField"]}, header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A media header atom
 *  
 *  @author The JCodec project
 *  
 */
var MediaHeaderBox = function(atom) {
    FullBox.call(this, atom);
};
MediaHeaderBox = stjs.extend(MediaHeaderBox, FullBox, [], function(constructor, prototype) {
    prototype.created = 0;
    prototype.modified = 0;
    prototype.timescale = 0;
    prototype.duration = 0;
    prototype.language = 0;
    prototype.quality = 0;
    constructor.fourcc = function() {
        return "mdhd";
    };
    constructor.createMediaHeaderBox = function(timescale, duration, language, created, modified, quality) {
        var mdhd = new MediaHeaderBox(new Header(MediaHeaderBox.fourcc()));
        mdhd.timescale = timescale;
        mdhd.duration = duration;
        mdhd.language = language;
        mdhd.created = created;
        mdhd.modified = modified;
        mdhd.quality = quality;
        return mdhd;
    };
    prototype.getTimescale = function() {
        return this.timescale;
    };
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getCreated = function() {
        return this.created;
    };
    prototype.getModified = function() {
        return this.modified;
    };
    prototype.getLanguage = function() {
        return this.language;
    };
    prototype.getQuality = function() {
        return this.quality;
    };
    prototype.setDuration = function(duration) {
        this.duration = duration;
    };
    prototype.setTimescale = function(timescale) {
        this.timescale = timescale;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        if (this.version == 0) {
            this.created = TimeUtil.fromMovTime(input.getInt());
            this.modified = TimeUtil.fromMovTime(input.getInt());
            this.timescale = input.getInt();
            this.duration = input.getInt();
        } else if (this.version == 1) {
            this.created = TimeUtil.fromMovTime(((input.getLong()) | 0));
            this.modified = TimeUtil.fromMovTime(((input.getLong()) | 0));
            this.timescale = input.getInt();
            this.duration = input.getLong();
        } else {
             throw new RuntimeException("Unsupported version");
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(TimeUtil.toMovTime(this.created));
        out.putInt(TimeUtil.toMovTime(this.modified));
        out.putInt(this.timescale);
        out.putInt(((this.duration) | 0));
        out.putShort(((this.language) << 16 >> 16));
        out.putShort(((this.quality) << 16 >> 16));
    };
    prototype.estimateSize = function() {
        return 32;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var SampleSizesBox = function(atom) {
    FullBox.call(this, atom);
};
SampleSizesBox = stjs.extend(SampleSizesBox, FullBox, [], function(constructor, prototype) {
    prototype.defaultSize = 0;
    prototype.count = 0;
    prototype.sizes = null;
    constructor.fourcc = function() {
        return "stsz";
    };
    constructor.createSampleSizesBox = function(defaultSize, count) {
        var stsz = new SampleSizesBox(new Header(SampleSizesBox.fourcc()));
        stsz.defaultSize = defaultSize;
        stsz.count = count;
        return stsz;
    };
    constructor.createSampleSizesBox2 = function(sizes) {
        var stsz = new SampleSizesBox(new Header(SampleSizesBox.fourcc()));
        stsz.sizes = sizes;
        stsz.count = sizes.length;
        return stsz;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.defaultSize = input.getInt();
        this.count = input.getInt();
        if (this.defaultSize == 0) {
            this.sizes = new Int32Array(this.count);
            for (var i = 0; i < this.count; i++) {
                this.sizes[i] = input.getInt();
            }
        }
    };
    prototype.getDefaultSize = function() {
        return this.defaultSize;
    };
    prototype.getSizes = function() {
        return this.sizes;
    };
    prototype.getCount = function() {
        return this.count;
    };
    prototype.setCount = function(count) {
        this.count = count;
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(stjs.trunc(this.defaultSize));
        if (this.defaultSize == 0) {
            out.putInt(this.count);
            for (var i = 0; i < this.sizes.length; i++) {
                var size = this.sizes[i];
                out.putInt(((size) | 0));
            }
        } else {
            out.putInt(stjs.trunc(this.count));
        }
    };
    prototype.estimateSize = function() {
        return (this.defaultSize == 0 ? this.sizes.length * 4 : 0) + 20;
    };
    prototype.setSizes = function(sizes) {
        this.sizes = sizes;
        this.count = sizes.length;
    };
}, {sizes: "Int32Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ClearApertureBox = function(atom) {
    FullBox.call(this, atom);
};
ClearApertureBox = stjs.extend(ClearApertureBox, FullBox, [], function(constructor, prototype) {
    constructor.CLEF = "clef";
    prototype.width = 0.0;
    prototype.height = 0.0;
    constructor.createClearApertureBox = function(width, height) {
        var clef = new ClearApertureBox(new Header(ClearApertureBox.CLEF));
        clef.width = width;
        clef.height = height;
        return clef;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.width = input.getInt() / 65536.0;
        this.height = input.getInt() / 65536.0;
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(stjs.trunc((this.width * 65536.0)));
        out.putInt(stjs.trunc((this.height * 65536.0)));
    };
    prototype.estimateSize = function() {
        return 20;
    };
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Track fragment run
 *  
 *  To crate new box:
 *  
 *  <pre>
 *  
 *  Box box = TrunBox
 *          .create(2)
 *          .dataOffset(20)
 *          .sampleCompositionOffset(new int[] { 11, 12 })
 *          .sampleDuration(new int[] { 15, 16 })
 *          .sampleFlags(new int[] { 100, 200 })
 *          .sampleSize(new int[] { 30, 40 })
 *          .create();
 *  
 *  </pre>
 *  
 *  @author The JCodec project
 *  
 */
var TrunBox = function(header) {
    FullBox.call(this, header);
};
TrunBox = stjs.extend(TrunBox, FullBox, [], function(constructor, prototype) {
    constructor.DATA_OFFSET_AVAILABLE = 1;
    constructor.FIRST_SAMPLE_FLAGS_AVAILABLE = 4;
    constructor.SAMPLE_DURATION_AVAILABLE = 256;
    constructor.SAMPLE_SIZE_AVAILABLE = 512;
    constructor.SAMPLE_FLAGS_AVAILABLE = 1024;
    constructor.SAMPLE_COMPOSITION_OFFSET_AVAILABLE = 2048;
    prototype.sampleCount = 0;
    prototype.dataOffset = 0;
    prototype.firstSampleFlags = 0;
    prototype.sampleDuration = null;
    prototype.sampleSize = null;
    prototype.sampleFlags = null;
    prototype.sampleCompositionOffset = null;
    constructor.fourcc = function() {
        return "trun";
    };
    prototype.setDataOffset = function(dataOffset) {
        this.dataOffset = dataOffset;
    };
    constructor.create = function(sampleCount) {
        return new TrunBox.Factory(TrunBox.createTrunBox1(sampleCount));
    };
    constructor.copy = function(other) {
        var box = TrunBox.createTrunBox2(other.sampleCount, other.dataOffset, other.firstSampleFlags, other.sampleDuration, other.sampleSize, other.sampleFlags, other.sampleCompositionOffset);
        box.setFlags(other.getFlags());
        box.setVersion(other.getVersion());
        return new TrunBox.Factory(box);
    };
    constructor.createTrunBox1 = function(sampleCount) {
        var trun = new TrunBox(new Header(TrunBox.fourcc()));
        trun.sampleCount = sampleCount;
        return trun;
    };
    constructor.createTrunBox2 = function(sampleCount, dataOffset, firstSampleFlags, sampleDuration, sampleSize, sampleFlags, sampleCompositionOffset) {
        var trun = new TrunBox(new Header(TrunBox.fourcc()));
        trun.sampleCount = sampleCount;
        trun.dataOffset = dataOffset;
        trun.firstSampleFlags = firstSampleFlags;
        trun.sampleDuration = sampleDuration;
        trun.sampleSize = sampleSize;
        trun.sampleFlags = sampleFlags;
        trun.sampleCompositionOffset = sampleCompositionOffset;
        return trun;
    };
    constructor.Factory = function(box) {
        this.box = box;
    };
    constructor.Factory = stjs.extend(constructor.Factory, null, [], function(constructor, prototype) {
        prototype.box = null;
        prototype.dataOffset = function(dataOffset) {
            this.box.flags |= TrunBox.DATA_OFFSET_AVAILABLE;
            this.box.dataOffset = ((dataOffset) | 0);
            return this;
        };
        prototype.firstSampleFlags = function(firstSampleFlags) {
            if (this.box.isSampleFlagsAvailable()) 
                 throw new IllegalStateException("Sample flags already set on this object");
            this.box.flags |= TrunBox.FIRST_SAMPLE_FLAGS_AVAILABLE;
            this.box.firstSampleFlags = firstSampleFlags;
            return this;
        };
        prototype.sampleDuration = function(sampleDuration) {
            if (sampleDuration.length != this.box.sampleCount) 
                 throw new IllegalArgumentException("Argument array length not equal to sampleCount");
            this.box.flags |= TrunBox.SAMPLE_DURATION_AVAILABLE;
            this.box.sampleDuration = sampleDuration;
            return this;
        };
        prototype.sampleSize = function(sampleSize) {
            if (sampleSize.length != this.box.sampleCount) 
                 throw new IllegalArgumentException("Argument array length not equal to sampleCount");
            this.box.flags |= TrunBox.SAMPLE_SIZE_AVAILABLE;
            this.box.sampleSize = sampleSize;
            return this;
        };
        prototype.sampleFlags = function(sampleFlags) {
            if (sampleFlags.length != this.box.sampleCount) 
                 throw new IllegalArgumentException("Argument array length not equal to sampleCount");
            if (this.box.isFirstSampleFlagsAvailable()) 
                 throw new IllegalStateException("First sample flags already set on this object");
            this.box.flags |= TrunBox.SAMPLE_FLAGS_AVAILABLE;
            this.box.sampleFlags = sampleFlags;
            return this;
        };
        prototype.sampleCompositionOffset = function(sampleCompositionOffset) {
            if (sampleCompositionOffset.length != this.box.sampleCount) 
                 throw new IllegalArgumentException("Argument array length not equal to sampleCount");
            this.box.flags |= TrunBox.SAMPLE_COMPOSITION_OFFSET_AVAILABLE;
            this.box.sampleCompositionOffset = sampleCompositionOffset;
            return this;
        };
        prototype.create = function() {
            try {
                return this.box;
            } finally {
                this.box = null;
            }
        };
    }, {box: "TrunBox"}, {});
    prototype.getSampleCount = function() {
        return Platform.unsignedInt(this.sampleCount);
    };
    prototype.getDataOffset = function() {
        return this.dataOffset;
    };
    prototype.getFirstSampleFlags = function() {
        return this.firstSampleFlags;
    };
    prototype.getSampleDurations = function() {
        return this.sampleDuration;
    };
    prototype.getSampleSizes = function() {
        return this.sampleSize;
    };
    prototype.getSamplesFlags = function() {
        return this.sampleFlags;
    };
    prototype.getSampleCompositionOffsets = function() {
        return this.sampleCompositionOffset;
    };
    prototype.getSampleDuration = function(i) {
        return Platform.unsignedInt(this.sampleDuration[i]);
    };
    prototype.getSampleSize = function(i) {
        return Platform.unsignedInt(this.sampleSize[i]);
    };
    prototype.getSampleFlags = function(i) {
        return this.sampleFlags[i];
    };
    prototype.getSampleCompositionOffset = function(i) {
        return Platform.unsignedInt(this.sampleCompositionOffset[i]);
    };
    prototype.isDataOffsetAvailable = function() {
        return (this.flags & TrunBox.DATA_OFFSET_AVAILABLE) != 0;
    };
    prototype.isSampleCompositionOffsetAvailable = function() {
        return (this.flags & TrunBox.SAMPLE_COMPOSITION_OFFSET_AVAILABLE) != 0;
    };
    prototype.isSampleFlagsAvailable = function() {
        return (this.flags & TrunBox.SAMPLE_FLAGS_AVAILABLE) != 0;
    };
    prototype.isSampleSizeAvailable = function() {
        return (this.flags & TrunBox.SAMPLE_SIZE_AVAILABLE) != 0;
    };
    prototype.isSampleDurationAvailable = function() {
        return (this.flags & TrunBox.SAMPLE_DURATION_AVAILABLE) != 0;
    };
    prototype.isFirstSampleFlagsAvailable = function() {
        return (this.flags & TrunBox.FIRST_SAMPLE_FLAGS_AVAILABLE) != 0;
    };
    constructor.flagsGetSampleDependsOn = function(flags) {
        return (flags >> 6) & 3;
    };
    constructor.flagsGetSampleIsDependedOn = function(flags) {
        return (flags >> 8) & 3;
    };
    constructor.flagsGetSampleHasRedundancy = function(flags) {
        return (flags >> 10) & 3;
    };
    constructor.flagsGetSamplePaddingValue = function(flags) {
        return (flags >> 12) & 7;
    };
    constructor.flagsGetSampleIsDifferentSample = function(flags) {
        return (flags >> 15) & 1;
    };
    constructor.flagsGetSampleDegradationPriority = function(flags) {
        return (flags >> 16) & 65535;
    };
    constructor.createTrunBox = function() {
        return new TrunBox(new Header(TrunBox.fourcc()));
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        if (this.isSampleFlagsAvailable() && this.isFirstSampleFlagsAvailable()) 
             throw new RuntimeException("Broken stream");
        this.sampleCount = input.getInt();
        if (this.isDataOffsetAvailable()) 
            this.dataOffset = input.getInt();
        if (this.isFirstSampleFlagsAvailable()) 
            this.firstSampleFlags = input.getInt();
        if (this.isSampleDurationAvailable()) 
            this.sampleDuration = new Int32Array(this.sampleCount);
        if (this.isSampleSizeAvailable()) 
            this.sampleSize = new Int32Array(this.sampleCount);
        if (this.isSampleFlagsAvailable()) 
            this.sampleFlags = new Int32Array(this.sampleCount);
        if (this.isSampleCompositionOffsetAvailable()) 
            this.sampleCompositionOffset = new Int32Array(this.sampleCount);
        for (var i = 0; i < this.sampleCount; i++) {
            if (this.isSampleDurationAvailable()) 
                this.sampleDuration[i] = input.getInt();
            if (this.isSampleSizeAvailable()) 
                this.sampleSize[i] = input.getInt();
            if (this.isSampleFlagsAvailable()) 
                this.sampleFlags[i] = input.getInt();
            if (this.isSampleCompositionOffsetAvailable()) 
                this.sampleCompositionOffset[i] = input.getInt();
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.sampleCount);
        if (this.isDataOffsetAvailable()) 
            out.putInt(this.dataOffset);
        if (this.isFirstSampleFlagsAvailable()) 
            out.putInt(this.firstSampleFlags);
        for (var i = 0; i < this.sampleCount; i++) {
            if (this.isSampleDurationAvailable()) 
                out.putInt(this.sampleDuration[i]);
            if (this.isSampleSizeAvailable()) 
                out.putInt(this.sampleSize[i]);
            if (this.isSampleFlagsAvailable()) 
                out.putInt(this.sampleFlags[i]);
            if (this.isSampleCompositionOffsetAvailable()) 
                out.putInt(this.sampleCompositionOffset[i]);
        }
    };
    prototype.estimateSize = function() {
        return 24 + this.sampleCount * 16;
    };
}, {sampleDuration: "Int32Array", sampleSize: "Int32Array", sampleFlags: "Int32Array", sampleCompositionOffset: "Int32Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ChannelBox = function(atom) {
    FullBox.call(this, atom);
};
ChannelBox = stjs.extend(ChannelBox, FullBox, [], function(constructor, prototype) {
    prototype.channelLayout = 0;
    prototype.channelBitmap = 0;
    prototype.descriptions = null;
    constructor.ChannelDescription = function(channelLabel, channelFlags, coordinates) {
        this.coordinates = new Float32Array(3);
        this.channelLabel = channelLabel;
        this.channelFlags = channelFlags;
        this.coordinates = coordinates;
    };
    constructor.ChannelDescription = stjs.extend(constructor.ChannelDescription, null, [], function(constructor, prototype) {
        prototype.channelLabel = 0;
        prototype.channelFlags = 0;
        prototype.coordinates = null;
        prototype.getChannelLabel = function() {
            return this.channelLabel;
        };
        prototype.getChannelFlags = function() {
            return this.channelFlags;
        };
        prototype.getCoordinates = function() {
            return this.coordinates;
        };
        prototype.getLabel = function() {
            return Label.getByVal(this.channelLabel);
        };
    }, {coordinates: "Float32Array"}, {});
    constructor.fourcc = function() {
        return "chan";
    };
    constructor.createChannelBox = function() {
        return new ChannelBox(new Header(ChannelBox.fourcc()));
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.channelLayout = input.getInt();
        this.channelBitmap = input.getInt();
        var numDescriptions = input.getInt();
        this.descriptions = Array(numDescriptions);
        for (var i = 0; i < numDescriptions; i++) {
            this.descriptions[i] = new ChannelBox.ChannelDescription(input.getInt(), input.getInt(), new Float32Array([Float.intBitsToFloat(input.getInt()), Float.intBitsToFloat(input.getInt()), Float.intBitsToFloat(input.getInt())]));
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.channelLayout);
        out.putInt(this.channelBitmap);
        out.putInt(this.descriptions.length);
        for (var i = 0; i < this.descriptions.length; i++) {
            var channelDescription = this.descriptions[i];
            out.putInt(channelDescription.getChannelLabel());
            out.putInt(channelDescription.getChannelFlags());
            out.putFloat(channelDescription.getCoordinates()[0]);
            out.putFloat(channelDescription.getCoordinates()[1]);
            out.putFloat(channelDescription.getCoordinates()[2]);
        }
    };
    prototype.estimateSize = function() {
        return 12 + 12 + this.descriptions.length * 20;
    };
    prototype.getChannelLayout = function() {
        return this.channelLayout;
    };
    prototype.getChannelBitmap = function() {
        return this.channelBitmap;
    };
    prototype.getDescriptions = function() {
        return this.descriptions;
    };
    prototype.setChannelLayout = function(channelLayout) {
        this.channelLayout = channelLayout;
    };
    prototype.setDescriptions = function(descriptions) {
        this.descriptions = descriptions;
    };
}, {descriptions: "Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var GenericMediaInfoBox = function(atom) {
    FullBox.call(this, atom);
};
GenericMediaInfoBox = stjs.extend(GenericMediaInfoBox, FullBox, [], function(constructor, prototype) {
    prototype.graphicsMode = 0;
    prototype.rOpColor = 0;
    prototype.gOpColor = 0;
    prototype.bOpColor = 0;
    prototype.balance = 0;
    constructor.fourcc = function() {
        return "gmin";
    };
    constructor.createGenericMediaInfoBox = function() {
        return new GenericMediaInfoBox(new Header(GenericMediaInfoBox.fourcc()));
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.graphicsMode = input.getShort();
        this.rOpColor = input.getShort();
        this.gOpColor = input.getShort();
        this.bOpColor = input.getShort();
        this.balance = input.getShort();
        input.getShort();
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putShort(this.graphicsMode);
        out.putShort(this.rOpColor);
        out.putShort(this.gOpColor);
        out.putShort(this.bOpColor);
        out.putShort(this.balance);
        out.putShort(((0) << 16 >> 16));
    };
    prototype.estimateSize = function() {
        return 24;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var TrackHeaderBox = function(header) {
    FullBox.call(this, header);
};
TrackHeaderBox = stjs.extend(TrackHeaderBox, FullBox, [], function(constructor, prototype) {
    prototype.trackId = 0;
    prototype.duration = 0;
    prototype.width = 0.0;
    prototype.height = 0.0;
    prototype.created = 0;
    prototype.modified = 0;
    prototype.volume = 0.0;
    prototype.layer = 0;
    prototype.altGroup = 0;
    prototype.matrix = null;
    constructor.fourcc = function() {
        return "tkhd";
    };
    constructor.createTrackHeaderBox = function(trackId, duration, width, height, created, modified, volume, layer, altGroup, matrix) {
        var box = new TrackHeaderBox(new Header(TrackHeaderBox.fourcc()));
        box.trackId = trackId;
        box.duration = duration;
        box.width = width;
        box.height = height;
        box.created = created;
        box.modified = modified;
        box.volume = volume;
        box.layer = layer;
        box.altGroup = altGroup;
        box.matrix = matrix;
        return box;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        if (this.version == 0) {
            this.created = TimeUtil.fromMovTime(input.getInt());
            this.modified = TimeUtil.fromMovTime(input.getInt());
        } else {
            this.created = TimeUtil.fromMovTime(((input.getLong()) | 0));
            this.modified = TimeUtil.fromMovTime(((input.getLong()) | 0));
        }
        this.trackId = input.getInt();
        input.getInt();
        if (this.version == 0) {
            this.duration = input.getInt();
        } else {
            this.duration = input.getLong();
        }
        input.getInt();
        input.getInt();
        this.layer = input.getShort();
        this.altGroup = input.getShort();
        this.volume = this.readVolume(input);
        input.getShort();
        this.readMatrix(input);
        this.width = input.getInt() / 65536.0;
        this.height = input.getInt() / 65536.0;
    };
    prototype.readMatrix = function(input) {
        this.matrix = new Int32Array(9);
        for (var i = 0; i < 9; i++) 
            this.matrix[i] = stjs.trunc(input.getInt() / 65536);
    };
    prototype.readVolume = function(input) {
        return (input.getShort() / 256.0);
    };
    prototype.getNo = function() {
        return this.trackId;
    };
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(TimeUtil.toMovTime(this.created));
        out.putInt(TimeUtil.toMovTime(this.modified));
        out.putInt(this.trackId);
        out.putInt(0);
        out.putInt(((this.duration) | 0));
        out.putInt(0);
        out.putInt(0);
        out.putShort(stjs.trunc(this.layer));
        out.putShort(((this.altGroup) << 16 >> 16));
        this.writeVolume(out);
        out.putShort(((0) << 16 >> 16));
        this.writeMatrix(out);
        out.putInt(stjs.trunc((this.width * 65536)));
        out.putInt(stjs.trunc((this.height * 65536)));
    };
    prototype.estimateSize = function() {
        return 92;
    };
    prototype.writeMatrix = function(out) {
        for (var i = 0; i < 9; i++) 
            out.putInt(this.matrix[i]);
    };
    prototype.writeVolume = function(out) {
        out.putShort(stjs.trunc((this.volume * 256.0)));
    };
    prototype.getTrackId = function() {
        return this.trackId;
    };
    prototype.getCreated = function() {
        return this.created;
    };
    prototype.getModified = function() {
        return this.modified;
    };
    prototype.getVolume = function() {
        return this.volume;
    };
    prototype.getLayer = function() {
        return this.layer;
    };
    prototype.getAltGroup = function() {
        return this.altGroup;
    };
    prototype.getMatrix = function() {
        return this.matrix;
    };
    prototype.setWidth = function(width) {
        this.width = width;
    };
    prototype.setHeight = function(height) {
        this.height = height;
    };
    prototype.setDuration = function(duration) {
        this.duration = duration;
    };
    prototype.setNo = function(no) {
        this.trackId = no;
    };
    prototype.isOrientation0 = function() {
        return this.matrix != null && this.matrix[0] == 1 && this.matrix[4] == 1;
    };
    prototype.isOrientation90 = function() {
        return this.matrix != null && this.matrix[1] == 1 && this.matrix[3] == -1;
    };
    prototype.isOrientation180 = function() {
        return this.matrix != null && this.matrix[0] == -1 && this.matrix[4] == -1;
    };
    prototype.isOrientation270 = function() {
        return this.matrix != null && this.matrix[1] == -1 && this.matrix[3] == 1;
    };
}, {matrix: "Int32Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Movie fragment header box
 *  
 *  
 *  @author The JCodec project
 *  
 */
var TrackExtendsBox = function(atom) {
    FullBox.call(this, atom);
};
TrackExtendsBox = stjs.extend(TrackExtendsBox, FullBox, [], function(constructor, prototype) {
    prototype.trackId = 0;
    prototype.defaultSampleDescriptionIndex = 0;
    prototype.defaultSampleDuration = 0;
    prototype.defaultSampleBytes = 0;
    prototype.defaultSampleFlags = 0;
    constructor.fourcc = function() {
        return "trex";
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.trackId = input.getInt();
        this.defaultSampleDescriptionIndex = input.getInt();
        this.defaultSampleDuration = input.getInt();
        this.defaultSampleBytes = input.getInt();
        this.defaultSampleFlags = input.getInt();
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.trackId);
        out.putInt(this.defaultSampleDescriptionIndex);
        out.putInt(this.defaultSampleDuration);
        out.putInt(this.defaultSampleBytes);
        out.putInt(this.defaultSampleFlags);
    };
    prototype.estimateSize = function() {
        return 32;
    };
    prototype.getTrackId = function() {
        return this.trackId;
    };
    prototype.setTrackId = function(trackId) {
        this.trackId = trackId;
    };
    prototype.getDefaultSampleDescriptionIndex = function() {
        return this.defaultSampleDescriptionIndex;
    };
    prototype.setDefaultSampleDescriptionIndex = function(defaultSampleDescriptionIndex) {
        this.defaultSampleDescriptionIndex = defaultSampleDescriptionIndex;
    };
    prototype.getDefaultSampleDuration = function() {
        return this.defaultSampleDuration;
    };
    prototype.setDefaultSampleDuration = function(defaultSampleDuration) {
        this.defaultSampleDuration = defaultSampleDuration;
    };
    prototype.getDefaultSampleBytes = function() {
        return this.defaultSampleBytes;
    };
    prototype.setDefaultSampleBytes = function(defaultSampleBytes) {
        this.defaultSampleBytes = defaultSampleBytes;
    };
    prototype.getDefaultSampleFlags = function() {
        return this.defaultSampleFlags;
    };
    prototype.setDefaultSampleFlags = function(defaultSampleFlags) {
        this.defaultSampleFlags = defaultSampleFlags;
    };
    constructor.createTrackExtendsBox = function() {
        return new TrackExtendsBox(new Header(TrackExtendsBox.fourcc()));
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Sound media header
 *  
 *  @author The JCodec project
 *  
 */
var SoundMediaHeaderBox = function(atom) {
    FullBox.call(this, atom);
};
SoundMediaHeaderBox = stjs.extend(SoundMediaHeaderBox, FullBox, [], function(constructor, prototype) {
    prototype.balance = 0;
    constructor.fourcc = function() {
        return "smhd";
    };
    constructor.createSoundMediaHeaderBox = function() {
        return new SoundMediaHeaderBox(new Header(SoundMediaHeaderBox.fourcc()));
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.balance = input.getShort();
        input.getShort();
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putShort(this.balance);
        out.putShort(((0) << 16 >> 16));
    };
    prototype.estimateSize = function() {
        return 16;
    };
    prototype.getBalance = function() {
        return this.balance;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  The Track Fragment Base Media Decode Time Box provides the absolute decode
 *  time, measured on the media timeline, of the first sample in decode order in
 *  the track fragment. This can be useful, for example, when performing random
 *  access in a file; it is not necessary to sum the sample durations of all
 *  preceding samples in previous fragments to find this value (where the sample
 *  durations are the deltas in the Decoding Time to Sample Box and the
 *  sample_durations in the preceding track runs). The Track Fragment Base Media
 *  Decode Time Box, if present, shall be positioned after the Track Fragment
 *  Header Box and before the first Track Fragment Run box.
 *  
 *  @author The JCodec project
 *  
 */
var TrackFragmentBaseMediaDecodeTimeBox = function(atom) {
    FullBox.call(this, atom);
};
TrackFragmentBaseMediaDecodeTimeBox = stjs.extend(TrackFragmentBaseMediaDecodeTimeBox, FullBox, [], function(constructor, prototype) {
    prototype.baseMediaDecodeTime = 0;
    constructor.createTrackFragmentBaseMediaDecodeTimeBox = function(baseMediaDecodeTime) {
        var box = new TrackFragmentBaseMediaDecodeTimeBox(new Header(TrackFragmentBaseMediaDecodeTimeBox.fourcc()));
        box.baseMediaDecodeTime = baseMediaDecodeTime;
        if (box.baseMediaDecodeTime > Integer.MAX_VALUE) {
            box.version = 1;
        }
        return box;
    };
    constructor.fourcc = function() {
        return "tfdt";
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        if (this.version == 0) {
            this.baseMediaDecodeTime = input.getInt();
        } else if (this.version == 1) {
            this.baseMediaDecodeTime = input.getLong();
        } else 
             throw new RuntimeException("Unsupported tfdt version");
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        if (this.version == 0) {
            out.putInt(((this.baseMediaDecodeTime) | 0));
        } else if (this.version == 1) {
            out.putLong(this.baseMediaDecodeTime);
        } else 
             throw new RuntimeException("Unsupported tfdt version");
    };
    prototype.estimateSize = function() {
        return 20;
    };
    prototype.getBaseMediaDecodeTime = function() {
        return this.baseMediaDecodeTime;
    };
    prototype.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {
        this.baseMediaDecodeTime = baseMediaDecodeTime;
    };
    constructor.copy = function(other) {
        return new TrackFragmentBaseMediaDecodeTimeBox.Factory(other);
    };
    constructor.Factory = function(other) {
        this.box = TrackFragmentBaseMediaDecodeTimeBox.createTrackFragmentBaseMediaDecodeTimeBox(other.baseMediaDecodeTime);
        this.box.version = other.version;
        this.box.flags = other.flags;
    };
    constructor.Factory = stjs.extend(constructor.Factory, null, [], function(constructor, prototype) {
        prototype.box = null;
        prototype.baseMediaDecodeTime = function(val) {
            this.box.baseMediaDecodeTime = val;
            return this;
        };
        prototype.create = function() {
            try {
                return this.box;
            } finally {
                this.box = null;
            }
        };
    }, {box: "TrackFragmentBaseMediaDecodeTimeBox"}, {});
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var EditListBox = function(atom) {
    FullBox.call(this, atom);
};
EditListBox = stjs.extend(EditListBox, FullBox, [], function(constructor, prototype) {
    prototype.edits = null;
    constructor.fourcc = function() {
        return "elst";
    };
    constructor.createEditListBox = function(edits) {
        var elst = new EditListBox(new Header(EditListBox.fourcc()));
        elst.edits = edits;
        return elst;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.edits = new ArrayList();
        var num = input.getInt();
        for (var i = 0; i < num; i++) {
            var duration = input.getInt();
            var mediaTime = input.getInt();
            var rate = input.getInt() / 65536.0;
            this.edits.add(new Edit(duration, mediaTime, rate));
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.edits.size());
        for (var iterator$edit = this.edits.iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            out.putInt(((edit.getDuration()) | 0));
            out.putInt(((edit.getMediaTime()) | 0));
            out.putInt(stjs.trunc((edit.getRate() * 65536)));
        }
    };
    prototype.estimateSize = function() {
        return 12 + 4 + this.edits.size() * 12;
    };
    prototype.getEdits = function() {
        return this.edits;
    };
}, {edits: {name: "List", arguments: ["Edit"]}, header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Movie fragment header box
 *  
 *  @author The JCodec project
 *  
 */
var MovieExtendsHeaderBox = function(atom) {
    FullBox.call(this, atom);
};
MovieExtendsHeaderBox = stjs.extend(MovieExtendsHeaderBox, FullBox, [], function(constructor, prototype) {
    prototype.fragmentDuration = 0;
    constructor.fourcc = function() {
        return "mehd";
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.fragmentDuration = input.getInt();
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.fragmentDuration);
    };
    prototype.estimateSize = function() {
        return 16;
    };
    prototype.getFragmentDuration = function() {
        return this.fragmentDuration;
    };
    prototype.setFragmentDuration = function(fragmentDuration) {
        this.fragmentDuration = fragmentDuration;
    };
    constructor.createMovieExtendsHeaderBox = function() {
        return new MovieExtendsHeaderBox(new Header(MovieExtendsHeaderBox.fourcc()));
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  Box type
 *  
 *  @author The JCodec project
 *  
 */
var ChunkOffsets64Box = function(atom) {
    FullBox.call(this, atom);
};
ChunkOffsets64Box = stjs.extend(ChunkOffsets64Box, FullBox, [], function(constructor, prototype) {
    prototype.chunkOffsets = null;
    constructor.fourcc = function() {
        return "co64";
    };
    constructor.createChunkOffsets64Box = function(offsets) {
        var co64 = new ChunkOffsets64Box(Header.createHeader(ChunkOffsets64Box.fourcc(), 0));
        co64.chunkOffsets = offsets;
        return co64;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        var length = input.getInt();
        this.chunkOffsets = Array(length);
        for (var i = 0; i < length; i++) {
            this.chunkOffsets[i] = input.getLong();
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.chunkOffsets.length);
        for (var i = 0; i < this.chunkOffsets.length; i++) {
            var offset = this.chunkOffsets[i];
            out.putLong(offset);
        }
    };
    prototype.estimateSize = function() {
        return 12 + 4 + this.chunkOffsets.length * 8;
    };
    prototype.getChunkOffsets = function() {
        return this.chunkOffsets;
    };
    prototype.setChunkOffsets = function(chunkOffsets) {
        this.chunkOffsets = chunkOffsets;
    };
}, {chunkOffsets: "Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A box containing sample presentation time information
 *  
 *  @author The JCodec project
 *  
 */
var TimeToSampleBox = function(atom) {
    FullBox.call(this, atom);
};
TimeToSampleBox = stjs.extend(TimeToSampleBox, FullBox, [], function(constructor, prototype) {
    constructor.TimeToSampleEntry = function(sampleCount, sampleDuration) {
        this.sampleCount = sampleCount;
        this.sampleDuration = sampleDuration;
    };
    constructor.TimeToSampleEntry = stjs.extend(constructor.TimeToSampleEntry, null, [], function(constructor, prototype) {
        prototype.sampleCount = 0;
        prototype.sampleDuration = 0;
        prototype.getSampleCount = function() {
            return this.sampleCount;
        };
        prototype.getSampleDuration = function() {
            return this.sampleDuration;
        };
        prototype.setSampleDuration = function(sampleDuration) {
            this.sampleDuration = sampleDuration;
        };
        prototype.setSampleCount = function(sampleCount) {
            this.sampleCount = sampleCount;
        };
        prototype.getSegmentDuration = function() {
            return this.sampleCount * this.sampleDuration;
        };
    }, {}, {});
    constructor.fourcc = function() {
        return "stts";
    };
    constructor.createTimeToSampleBox = function(timeToSamples) {
        var box = new TimeToSampleBox(new Header(TimeToSampleBox.fourcc()));
        box.entries = timeToSamples;
        return box;
    };
    prototype.entries = null;
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        var foo = input.getInt();
        this.entries = Array(foo);
        for (var i = 0; i < foo; i++) {
            this.entries[i] = new TimeToSampleBox.TimeToSampleEntry(input.getInt(), input.getInt());
        }
    };
    prototype.getEntries = function() {
        return this.entries;
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.entries.length);
        for (var i = 0; i < this.entries.length; i++) {
            var timeToSampleEntry = this.entries[i];
            out.putInt(timeToSampleEntry.getSampleCount());
            out.putInt(timeToSampleEntry.getSampleDuration());
        }
    };
    prototype.estimateSize = function() {
        return 16 + this.entries.length * 8;
    };
    prototype.setEntries = function(entries) {
        this.entries = entries;
    };
}, {entries: "Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Default box factory
 *  
 *  @author The JCodec project
 *  
 */
var CompositionOffsetsBox = function(header) {
    FullBox.call(this, header);
};
CompositionOffsetsBox = stjs.extend(CompositionOffsetsBox, FullBox, [], function(constructor, prototype) {
    prototype.entries = null;
    constructor.Entry = function(count, offset) {
        this.count = count;
        this.offset = offset;
    };
    constructor.Entry = stjs.extend(constructor.Entry, null, [], function(constructor, prototype) {
        prototype.count = 0;
        prototype.offset = 0;
        prototype.getCount = function() {
            return this.count;
        };
        prototype.getOffset = function() {
            return this.offset;
        };
    }, {}, {});
    constructor.LongEntry = function(count, offset) {
        this.count = count;
        this.offset = offset;
    };
    constructor.LongEntry = stjs.extend(constructor.LongEntry, null, [], function(constructor, prototype) {
        prototype.count = 0;
        prototype.offset = 0;
        prototype.getCount = function() {
            return this.count;
        };
        prototype.getOffset = function() {
            return this.offset;
        };
    }, {}, {});
    constructor.fourcc = function() {
        return "ctts";
    };
    constructor.createCompositionOffsetsBox = function(entries) {
        var ctts = new CompositionOffsetsBox(new Header(CompositionOffsetsBox.fourcc()));
        ctts.entries = entries;
        return ctts;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        var num = input.getInt();
        this.entries = Array(num);
        for (var i = 0; i < num; i++) {
            this.entries[i] = new CompositionOffsetsBox.Entry(input.getInt(), input.getInt());
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.entries.length);
        for (var i = 0; i < this.entries.length; i++) {
            out.putInt(this.entries[i].count);
            out.putInt(this.entries[i].offset);
        }
    };
    prototype.estimateSize = function() {
        return 12 + 4 + this.entries.length * 8;
    };
    prototype.getEntries = function() {
        return this.entries;
    };
}, {entries: "Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A movie header box
 *  
 *  @author The JCodec project
 *  
 */
var MovieHeaderBox = function(header) {
    FullBox.call(this, header);
};
MovieHeaderBox = stjs.extend(MovieHeaderBox, FullBox, [], function(constructor, prototype) {
    prototype.timescale = 0;
    prototype.duration = 0;
    prototype.rate = 0.0;
    prototype.volume = 0.0;
    prototype.created = 0;
    prototype.modified = 0;
    prototype.matrix = null;
    prototype.nextTrackId = 0;
    constructor.fourcc = function() {
        return "mvhd";
    };
    constructor.createMovieHeaderBox = function(timescale, duration, rate, volume, created, modified, matrix, nextTrackId) {
        var mvhd = new MovieHeaderBox(new Header(MovieHeaderBox.fourcc()));
        mvhd.timescale = timescale;
        mvhd.duration = duration;
        mvhd.rate = rate;
        mvhd.volume = volume;
        mvhd.created = created;
        mvhd.modified = modified;
        mvhd.matrix = matrix;
        mvhd.nextTrackId = nextTrackId;
        return mvhd;
    };
    prototype.getTimescale = function() {
        return this.timescale;
    };
    prototype.getDuration = function() {
        return this.duration;
    };
    prototype.getNextTrackId = function() {
        return this.nextTrackId;
    };
    prototype.getRate = function() {
        return this.rate;
    };
    prototype.getVolume = function() {
        return this.volume;
    };
    prototype.getCreated = function() {
        return this.created;
    };
    prototype.getModified = function() {
        return this.modified;
    };
    prototype.getMatrix = function() {
        return this.matrix;
    };
    prototype.setTimescale = function(newTs) {
        this.timescale = newTs;
    };
    prototype.setDuration = function(duration) {
        this.duration = duration;
    };
    prototype.setNextTrackId = function(nextTrackId) {
        this.nextTrackId = nextTrackId;
    };
    prototype.readMatrix = function(input) {
        var matrix = new Int32Array(9);
        for (var i = 0; i < 9; i++) 
            matrix[i] = input.getInt();
        return matrix;
    };
    prototype.readVolume = function(input) {
        return input.getShort() / 256.0;
    };
    prototype.readRate = function(input) {
        return input.getInt() / 65536.0;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        if (this.version == 0) {
            this.created = TimeUtil.fromMovTime(input.getInt());
            this.modified = TimeUtil.fromMovTime(input.getInt());
            this.timescale = input.getInt();
            this.duration = input.getInt();
        } else if (this.version == 1) {
            this.created = TimeUtil.fromMovTime(((input.getLong()) | 0));
            this.modified = TimeUtil.fromMovTime(((input.getLong()) | 0));
            this.timescale = input.getInt();
            this.duration = input.getLong();
        } else {
             throw new RuntimeException("Unsupported version");
        }
        this.rate = this.readRate(input);
        this.volume = this.readVolume(input);
        NIOUtils.skip(input, 10);
        this.matrix = this.readMatrix(input);
        NIOUtils.skip(input, 24);
        this.nextTrackId = input.getInt();
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(TimeUtil.toMovTime(this.created));
        out.putInt(TimeUtil.toMovTime(this.modified));
        out.putInt(this.timescale);
        out.putInt(((this.duration) | 0));
        this.writeFixed1616(out, this.rate);
        this.writeFixed88(out, this.volume);
        out.putArr(new Int8Array(10));
        this.writeMatrix(out);
        out.putArr(new Int8Array(24));
        out.putInt(this.nextTrackId);
    };
    prototype.estimateSize = function() {
        return 144;
    };
    prototype.writeMatrix = function(out) {
        for (var i = 0; i < Math.min(9, this.matrix.length); i++) 
            out.putInt(this.matrix[i]);
        for (var i = Math.min(9, this.matrix.length); i < 9; i++) 
            out.putInt(0);
    };
    prototype.writeFixed88 = function(out, volume) {
        out.putShort(stjs.trunc((volume * 256.0)));
    };
    prototype.writeFixed1616 = function(out, rate) {
        out.putInt(stjs.trunc((rate * 65536.0)));
    };
}, {matrix: "Int32Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var SegmentIndexBox = function(atom) {
    FullBox.call(this, atom);
};
SegmentIndexBox = stjs.extend(SegmentIndexBox, FullBox, [], function(constructor, prototype) {
    constructor.createSegmentIndexBox = function() {
        return new SegmentIndexBox(new Header(SegmentIndexBox.fourcc()));
    };
    prototype.reference_ID = 0;
    prototype.timescale = 0;
    prototype.earliest_presentation_time = 0;
    prototype.first_offset = 0;
    prototype.reserved = 0;
    prototype.reference_count = 0;
    prototype.references = null;
    constructor.Reference = function() {};
    constructor.Reference = stjs.extend(constructor.Reference, null, [], function(constructor, prototype) {
        prototype.reference_type = false;
        prototype.referenced_size = 0;
        prototype.subsegment_duration = 0;
        prototype.starts_with_SAP = false;
        prototype.SAP_type = 0;
        prototype.SAP_delta_time = 0;
        prototype.toString = function() {
            return "Reference [reference_type=" + this.reference_type + ", referenced_size=" + this.referenced_size + ", subsegment_duration=" + this.subsegment_duration + ", starts_with_SAP=" + this.starts_with_SAP + ", SAP_type=" + this.SAP_type + ", SAP_delta_time=" + this.SAP_delta_time + "]";
        };
    }, {}, {});
    constructor.fourcc = function() {
        return "sidx";
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.reference_ID = Platform.unsignedInt(input.getInt());
        this.timescale = Platform.unsignedInt(input.getInt());
        if (this.version == 0) {
            this.earliest_presentation_time = Platform.unsignedInt(input.getInt());
            this.first_offset = Platform.unsignedInt(input.getInt());
        } else {
            this.earliest_presentation_time = input.getLong();
            this.first_offset = input.getLong();
        }
        this.reserved = input.getShort();
        this.reference_count = input.getShort() & 65535;
        this.references = Array(this.reference_count);
        for (var i = 0; i < this.reference_count; i++) {
            var i0 = Platform.unsignedInt(input.getInt());
            var i1 = Platform.unsignedInt(input.getInt());
            var i2 = Platform.unsignedInt(input.getInt());
            var ref = new SegmentIndexBox.Reference();
            ref.reference_type = (i0 >> 31) == 1;
            ref.referenced_size = i0 & 2147483647;
            ref.subsegment_duration = i1;
            ref.starts_with_SAP = (i2 >> 31) == 1;
            ref.SAP_type = ((((i2 >> 28) & 7)) | 0);
            ref.SAP_delta_time = i2 & 268435455;
            this.references[i] = ref;
        }
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(((this.reference_ID) | 0));
        out.putInt(((this.timescale) | 0));
        if (this.version == 0) {
            out.putInt(((this.earliest_presentation_time) | 0));
            out.putInt(((this.first_offset) | 0));
        } else {
            out.putLong(this.earliest_presentation_time);
            out.putLong(this.first_offset);
        }
        out.putShort(((this.reserved) << 16 >> 16));
        out.putShort(((this.reference_count) << 16 >> 16));
        for (var i = 0; i < this.reference_count; i++) {
            var ref = this.references[i];
            var i0 = (((((ref.reference_type ? 1 : 0) << 31) | ref.referenced_size)) | 0);
            var i1 = ((ref.subsegment_duration) | 0);
            var i2 = 0;
            if (ref.starts_with_SAP) {
                i2 |= (1 << 31);
            }
            i2 |= ((ref.SAP_type & 7) << 28);
            i2 |= (ref.SAP_delta_time & 268435455);
            out.putInt(i0);
            out.putInt(i1);
            out.putInt(i2);
        }
    };
    prototype.estimateSize = function() {
        return 40 + this.reference_count * 12;
    };
    prototype.toString = function() {
        return "SegmentIndexBox [reference_ID=" + this.reference_ID + ", timescale=" + this.timescale + ", earliest_presentation_time=" + this.earliest_presentation_time + ", first_offset=" + this.first_offset + ", reserved=" + this.reserved + ", reference_count=" + this.reference_count + ", references=" + Platform.arrayToString(this.references) + ", version=" + this.version + ", flags=" + this.flags + ", header=" + this.header + "]";
    };
}, {references: "Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var UrlBox = function(atom) {
    FullBox.call(this, atom);
};
UrlBox = stjs.extend(UrlBox, FullBox, [], function(constructor, prototype) {
    prototype.url = null;
    constructor.fourcc = function() {
        return "url ";
    };
    constructor.createUrlBox = function(url) {
        var urlBox = new UrlBox(new Header(UrlBox.fourcc()));
        urlBox.url = url;
        return urlBox;
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        if ((this.flags & 1) != 0) 
            return;
        this.url = NIOUtils.readNullTermStringCharset(input, Platform.UTF_8);
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        if (this.url != null) {
            NIOUtils.write(out, ByteBuffer.wrap(Platform.getBytesForCharset(this.url, Platform.UTF_8)));
            out.put((0 << 24 >> 24));
        }
    };
    prototype.estimateSize = function() {
        var sz = 13;
        if (this.url != null) {
            sz += Platform.getBytesForCharset(this.url, Platform.UTF_8).length;
        }
        return sz;
    };
    prototype.getUrl = function() {
        return this.url;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Movie fragment header box
 *  
 *  
 *  @author The JCodec project
 *  
 */
var MovieFragmentHeaderBox = function(atom) {
    FullBox.call(this, atom);
};
MovieFragmentHeaderBox = stjs.extend(MovieFragmentHeaderBox, FullBox, [], function(constructor, prototype) {
    prototype.sequenceNumber = 0;
    constructor.fourcc = function() {
        return "mfhd";
    };
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.sequenceNumber = input.getInt();
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.sequenceNumber);
    };
    prototype.estimateSize = function() {
        return 16;
    };
    prototype.getSequenceNumber = function() {
        return this.sequenceNumber;
    };
    prototype.setSequenceNumber = function(sequenceNumber) {
        this.sequenceNumber = sequenceNumber;
    };
    constructor.createMovieFragmentHeaderBox = function() {
        return new MovieFragmentHeaderBox(new Header(MovieFragmentHeaderBox.fourcc()));
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Track fragment header box
 *  
 *  @author The JCodec project
 *  
 */
var TrackFragmentHeaderBox = function(atom) {
    FullBox.call(this, atom);
};
TrackFragmentHeaderBox = stjs.extend(TrackFragmentHeaderBox, FullBox, [], function(constructor, prototype) {
    constructor.FLAG_BASE_DATA_OFFSET = 1;
    constructor.FLAG_SAMPLE_DESCRIPTION_INDEX = 2;
    constructor.FLAG_DEFAILT_SAMPLE_DURATION = 8;
    constructor.FLAG_DEFAULT_SAMPLE_SIZE = 16;
    constructor.FLAG_DEFAILT_SAMPLE_FLAGS = 32;
    prototype.trackId = 0;
    prototype.baseDataOffset = 0;
    prototype.sampleDescriptionIndex = 0;
    prototype.defaultSampleDuration = 0;
    prototype.defaultSampleSize = 0;
    prototype.defaultSampleFlags = 0;
    constructor.fourcc = function() {
        return "tfhd";
    };
    constructor.tfhd = function(trackId, baseDataOffset, sampleDescriptionIndex, defaultSampleDuration, defaultSampleSize, defaultSampleFlags) {
        var box = new TrackFragmentHeaderBox(new Header(TrackFragmentHeaderBox.fourcc()));
        box.trackId = trackId;
        box.baseDataOffset = baseDataOffset;
        box.sampleDescriptionIndex = sampleDescriptionIndex;
        box.defaultSampleDuration = defaultSampleDuration;
        box.defaultSampleSize = defaultSampleSize;
        box.defaultSampleFlags = defaultSampleFlags;
        return box;
    };
    constructor.create = function(trackId) {
        return new TrackFragmentHeaderBox.Factory(TrackFragmentHeaderBox.createTrackFragmentHeaderBoxWithId(trackId));
    };
    constructor.copy = function(other) {
        var box = TrackFragmentHeaderBox.tfhd(other.trackId, other.baseDataOffset, other.sampleDescriptionIndex, other.defaultSampleDuration, other.defaultSampleSize, other.defaultSampleFlags);
        box.setFlags(other.getFlags());
        box.setVersion(other.getVersion());
        return new TrackFragmentHeaderBox.Factory(box);
    };
    constructor.createTrackFragmentHeaderBoxWithId = function(trackId) {
        var box = new TrackFragmentHeaderBox(new Header(TrackFragmentHeaderBox.fourcc()));
        box.trackId = trackId;
        return box;
    };
    constructor.Factory = function(box) {
        this.box = box;
    };
    constructor.Factory = stjs.extend(constructor.Factory, null, [], function(constructor, prototype) {
        prototype.box = null;
        prototype.baseDataOffset = function(baseDataOffset) {
            this.box.flags |= TrackFragmentHeaderBox.FLAG_BASE_DATA_OFFSET;
            this.box.baseDataOffset = ((baseDataOffset) | 0);
            return this;
        };
        prototype.sampleDescriptionIndex = function(sampleDescriptionIndex) {
            this.box.flags |= TrackFragmentHeaderBox.FLAG_SAMPLE_DESCRIPTION_INDEX;
            this.box.sampleDescriptionIndex = ((sampleDescriptionIndex) | 0);
            return this;
        };
        prototype.defaultSampleDuration = function(defaultSampleDuration) {
            this.box.flags |= TrackFragmentHeaderBox.FLAG_DEFAILT_SAMPLE_DURATION;
            this.box.defaultSampleDuration = ((defaultSampleDuration) | 0);
            return this;
        };
        prototype.defaultSampleSize = function(defaultSampleSize) {
            this.box.flags |= TrackFragmentHeaderBox.FLAG_DEFAULT_SAMPLE_SIZE;
            this.box.defaultSampleSize = ((defaultSampleSize) | 0);
            return this;
        };
        prototype.defaultSampleFlags = function(defaultSampleFlags) {
            this.box.flags |= TrackFragmentHeaderBox.FLAG_DEFAILT_SAMPLE_FLAGS;
            this.box.defaultSampleFlags = ((defaultSampleFlags) | 0);
            return this;
        };
        prototype.create = function() {
            try {
                return this.box;
            } finally {
                this.box = null;
            }
        };
    }, {box: "TrackFragmentHeaderBox"}, {});
    prototype.parse = function(input) {
        FullBox.prototype.parse.call(this, input);
        this.trackId = input.getInt();
        if (this.isBaseDataOffsetAvailable()) 
            this.baseDataOffset = input.getLong();
        if (this.isSampleDescriptionIndexAvailable()) 
            this.sampleDescriptionIndex = input.getInt();
        if (this.isDefaultSampleDurationAvailable()) 
            this.defaultSampleDuration = input.getInt();
        if (this.isDefaultSampleSizeAvailable()) 
            this.defaultSampleSize = input.getInt();
        if (this.isDefaultSampleFlagsAvailable()) 
            this.defaultSampleFlags = input.getInt();
    };
    prototype.doWrite = function(out) {
        FullBox.prototype.doWrite.call(this, out);
        out.putInt(this.trackId);
        if (this.isBaseDataOffsetAvailable()) 
            out.putLong(this.baseDataOffset);
        if (this.isSampleDescriptionIndexAvailable()) 
            out.putInt(this.sampleDescriptionIndex);
        if (this.isDefaultSampleDurationAvailable()) 
            out.putInt(this.defaultSampleDuration);
        if (this.isDefaultSampleSizeAvailable()) 
            out.putInt(this.defaultSampleSize);
        if (this.isDefaultSampleFlagsAvailable()) 
            out.putInt(this.defaultSampleFlags);
    };
    prototype.estimateSize = function() {
        return 40;
    };
    prototype.getTrackId = function() {
        return this.trackId;
    };
    prototype.getBaseDataOffset = function() {
        return this.baseDataOffset;
    };
    prototype.getSampleDescriptionIndex = function() {
        return this.sampleDescriptionIndex;
    };
    prototype.getDefaultSampleDuration = function() {
        return this.defaultSampleDuration;
    };
    prototype.getDefaultSampleSize = function() {
        return this.defaultSampleSize;
    };
    prototype.getDefaultSampleFlags = function() {
        return this.defaultSampleFlags;
    };
    prototype.isBaseDataOffsetAvailable = function() {
        return (this.flags & TrackFragmentHeaderBox.FLAG_BASE_DATA_OFFSET) != 0;
    };
    prototype.isSampleDescriptionIndexAvailable = function() {
        return (this.flags & TrackFragmentHeaderBox.FLAG_SAMPLE_DESCRIPTION_INDEX) != 0;
    };
    prototype.isDefaultSampleDurationAvailable = function() {
        return (this.flags & TrackFragmentHeaderBox.FLAG_DEFAILT_SAMPLE_DURATION) != 0;
    };
    prototype.isDefaultSampleSizeAvailable = function() {
        return (this.flags & TrackFragmentHeaderBox.FLAG_DEFAULT_SAMPLE_SIZE) != 0;
    };
    prototype.isDefaultSampleFlagsAvailable = function() {
        return (this.flags & TrackFragmentHeaderBox.FLAG_DEFAILT_SAMPLE_FLAGS) != 0;
    };
    prototype.setTrackId = function(trackId) {
        this.trackId = trackId;
    };
    prototype.setDefaultSampleFlags = function(defaultSampleFlags) {
        this.defaultSampleFlags = defaultSampleFlags;
    };
    constructor.createTrackFragmentHeaderBox = function() {
        return new TrackFragmentHeaderBox(new Header(TrackFragmentHeaderBox.fourcc()));
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var IListBox = function(atom) {
    Box.call(this, atom);
    this.factory = new SimpleBoxFactory(new IListBox.LocalBoxes());
    this.values = new LinkedHashMap();
};
IListBox = stjs.extend(IListBox, Box, [], function(constructor, prototype) {
    constructor.FOURCC = "ilst";
    prototype.values = null;
    prototype.factory = null;
    constructor.LocalBoxes = function() {
        Boxes.call(this);
        this.mappings.put(DataBox.fourcc(), DataBox);
    };
    constructor.LocalBoxes = stjs.extend(constructor.LocalBoxes, Boxes, [], null, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
    constructor.createIListBox = function(values) {
        var box = new IListBox(Header.createHeader(IListBox.FOURCC, 0));
        box.values = values;
        return box;
    };
    prototype.parse = function(input) {
         while (input.remaining() >= 4){
            var size = input.getInt();
            var local = NIOUtils.read(input, size - 4);
            var index = local.getInt();
            var children = new ArrayList();
            this.values.put(index, children);
             while (local.hasRemaining()){
                var childAtom = Header.read(local);
                if (childAtom != null && local.remaining() >= childAtom.getBodySize()) {
                    var box = Box.parseBox(NIOUtils.read(local, ((childAtom.getBodySize()) | 0)), childAtom, this.factory);
                    children.add(box);
                }
            }
        }
    };
    prototype.getValues = function() {
        return this.values;
    };
    prototype.doWrite = function(out) {
        for (var iterator$entry = this.values.entrySet().iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            var fork = out.duplicate();
            out.putInt(0);
            out.putInt(entry.getKey());
            for (var iterator$box = entry.getValue().iterator(); iterator$box.hasNext(); ) {
                var box = iterator$box.next();
                box.write(out);
            }
            fork.putInt(out.position() - fork.position());
        }
    };
    prototype.estimateSize = function() {
        var sz = 8;
        for (var iterator$entry = this.values.entrySet().iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            for (var iterator$box = entry.getValue().iterator(); iterator$box.hasNext(); ) {
                var box = iterator$box.next();
                sz += 8 + box.estimateSize();
            }
        }
        return sz;
    };
    constructor.fourcc = function() {
        return IListBox.FOURCC;
    };
}, {values: {name: "Map", arguments: [null, {name: "List", arguments: ["Box"]}]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var Brand = function(majorBrand, version, compatible) {
    this.ftyp = FileTypeBox.createFileTypeBox(majorBrand, version, Arrays.asList(compatible));
};
Brand = stjs.extend(Brand, null, [], function(constructor, prototype) {
    constructor.MOV = new Brand("qt  ", 512, ["qt  "]);
    constructor.MP4 = new Brand("isom", 512, ["isom", "iso2", "avc1", "mp41"]);
    prototype.ftyp = null;
    prototype.getFileTypeBox = function() {
        return this.ftyp;
    };
}, {MOV: "Brand", MP4: "Brand", ftyp: "FileTypeBox"}, {});
var WaveExtBoxes = function() {
    Boxes.call(this);
    this.mappings.put(FormatBox.fourcc(), FormatBox);
    this.mappings.put(EndianBox.fourcc(), EndianBox);
};
WaveExtBoxes = stjs.extend(WaveExtBoxes, Boxes, [], null, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var DataRefBox = function(atom) {
    NodeBox.call(this, atom);
};
DataRefBox = stjs.extend(DataRefBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "dref";
    };
    constructor.createDataRefBox = function() {
        return new DataRefBox(new Header(DataRefBox.fourcc()));
    };
    prototype.parse = function(input) {
        input.getInt();
        input.getInt();
        NodeBox.prototype.parse.call(this, input);
    };
    prototype.doWrite = function(out) {
        out.putInt(0);
        out.putInt(this.boxes.size());
        NodeBox.prototype.doWrite.call(this, out);
    };
    prototype.estimateSize = function() {
        return 8 + NodeBox.prototype.estimateSize.call(this);
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Creates MP4 file out of a set of samples
 *  
 *  @author The JCodec project
 *  
 */
var SampleEntry = function(header) {
    NodeBox.call(this, header);
};
SampleEntry = stjs.extend(SampleEntry, NodeBox, [], function(constructor, prototype) {
    prototype.drefInd = 0;
    prototype.parse = function(input) {
        input.getInt();
        input.getShort();
        this.drefInd = input.getShort();
    };
    prototype.parseExtensions = function(input) {
        NodeBox.prototype.parse.call(this, input);
    };
    prototype.doWrite = function(out) {
        out.putArr(new Int8Array([0, 0, 0, 0, 0, 0]));
        out.putShort(this.drefInd);
    };
    prototype.writeExtensions = function(out) {
        NodeBox.prototype.doWrite.call(this, out);
    };
    prototype.getDrefInd = function() {
        return this.drefInd;
    };
    prototype.setDrefInd = function(ind) {
        this.drefInd = ind;
    };
    prototype.setMediaType = function(mediaType) {
        this.header = new Header(mediaType);
    };
    prototype.estimateSize = function() {
        return 8 + NodeBox.prototype.estimateSize.call(this);
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MovieExtendsBox = function(atom) {
    NodeBox.call(this, atom);
};
MovieExtendsBox = stjs.extend(MovieExtendsBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "mvex";
    };
    constructor.createMovieExtendsBox = function() {
        return new MovieExtendsBox(new Header(MovieExtendsBox.fourcc()));
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Wave extension to audio sample entry
 *  
 *  @author The JCodec project
 *  
 */
var WaveExtension = function(atom) {
    NodeBox.call(this, atom);
};
WaveExtension = stjs.extend(WaveExtension, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "wave";
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 * 
 *  @author The JCodec project
 */
var SampleDescriptionBox = function(header) {
    NodeBox.call(this, header);
};
SampleDescriptionBox = stjs.extend(SampleDescriptionBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "stsd";
    };
    constructor.createSampleDescriptionBox = function(_arguments) {
        var box = new SampleDescriptionBox(new Header(SampleDescriptionBox.fourcc()));
        for (var i = 0; i < arguments.length; i++) {
            var e = arguments[i];
            box.boxes.add(e);
        }
        return box;
    };
    prototype.parse = function(input) {
        input.getInt();
        input.getInt();
        NodeBox.prototype.parse.call(this, input);
    };
    prototype.doWrite = function(out) {
        out.putInt(0);
        out.putInt(Math.max(1, this.boxes.size()));
        NodeBox.prototype.doWrite.call(this, out);
    };
    prototype.estimateSize = function() {
        return 8 + NodeBox.prototype.estimateSize.call(this);
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
var BoxUtil = function() {};
BoxUtil = stjs.extend(BoxUtil, null, [], function(constructor, prototype) {
    constructor.parseBox = function(input, childAtom, factory) {
        var box = factory.newBox(childAtom);
        if (childAtom.getBodySize() < Box.MAX_BOX_SIZE) {
            box.parse(input);
            return box;
        } else {
            return new Box.LeafBox(Header.createHeader("free", 8));
        }
    };
    constructor.parseChildBox = function(input, factory) {
        var fork = input.duplicate();
         while (input.remaining() >= 4 && fork.getInt() == 0)
            input.getInt();
        if (input.remaining() < 4) 
            return null;
        var childAtom = Header.read(input);
        if (childAtom != null && input.remaining() >= childAtom.getBodySize()) 
            return BoxUtil.parseBox(NIOUtils.read(input, ((childAtom.getBodySize()) | 0)), childAtom, factory);
         else 
            return null;
    };
    constructor.as = function(class1, box) {
        try {
            var res = Platform.newInstance(class1, [box.getHeader()]);
            res.parse(box.getData().duplicate());
            return res;
        }catch (e) {
             throw new RuntimeException(e);
        }
    };
    constructor.containsBox = function(box, path) {
        var b = NodeBox.findFirstPath(box, Box, [path]);
        return b != null;
    };
    constructor.containsBox2 = function(box, path1, path2) {
        var b = NodeBox.findFirstPath(box, Box, [path1, path2]);
        return b != null;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var KeysBox = function(atom) {
    NodeBox.call(this, atom);
    this.factory = new SimpleBoxFactory(new KeysBox.LocalBoxes());
};
KeysBox = stjs.extend(KeysBox, NodeBox, [], function(constructor, prototype) {
    constructor.FOURCC = "keys";
    constructor.LocalBoxes = function() {
        Boxes.call(this);
        this.mappings.put(MdtaBox.fourcc(), MdtaBox);
    };
    constructor.LocalBoxes = stjs.extend(constructor.LocalBoxes, Boxes, [], null, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
    constructor.createKeysBox = function() {
        return new KeysBox(Header.createHeader(KeysBox.FOURCC, 0));
    };
    prototype.parse = function(input) {
        var vf = input.getInt();
        var cnt = input.getInt();
        NodeBox.prototype.parse.call(this, input);
    };
    prototype.doWrite = function(out) {
        out.putInt(0);
        out.putInt(this.boxes.size());
        NodeBox.prototype.doWrite.call(this, out);
    };
    constructor.fourcc = function() {
        return KeysBox.FOURCC;
    };
    prototype.estimateSize = function() {
        return 8 + NodeBox.prototype.estimateSize.call(this);
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
var VideoBoxes = function() {
    Boxes.call(this);
    this.mappings.put(PixelAspectExt.fourcc(), PixelAspectExt);
    this.mappings.put(AvcCBox.fourcc(), AvcCBox);
    this.mappings.put(ColorExtension.fourcc(), ColorExtension);
    this.mappings.put(GamaExtension.fourcc(), GamaExtension);
    this.mappings.put(CleanApertureExtension.fourcc(), CleanApertureExtension);
    this.mappings.put(FielExtension.fourcc(), FielExtension);
};
VideoBoxes = stjs.extend(VideoBoxes, Boxes, [], null, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var GainControl = function(frameLen) {
    this.frameLen = frameLen;
    this.lbLong = stjs.trunc(frameLen / GCConstants.BANDS);
    this.lbShort = stjs.trunc(this.lbLong / 8);
    this.imdct = new IMDCT(frameLen);
    this.ipqf = new IPQF();
    this.levelPrev = Array(0);
    this.locationPrev = Array(0);
    this.buffer1 = new Float32Array(stjs.trunc(frameLen / 2));
    this.buffer2 = Array.apply(null, Array(GCConstants.BANDS)).map(function() {
        return new Float32Array(this.lbLong);
    });
    this._function = new Float32Array(this.lbLong * 2);
    this.overlap = Array.apply(null, Array(GCConstants.BANDS)).map(function() {
        return new Float32Array(this.lbLong * 2);
    });
};
GainControl = stjs.extend(GainControl, null, [GCConstants], function(constructor, prototype) {
    prototype.frameLen = 0;
    prototype.lbLong = 0;
    prototype.lbShort = 0;
    prototype.imdct = null;
    prototype.ipqf = null;
    prototype.buffer1 = null;
    prototype._function = null;
    prototype.buffer2 = null;
    prototype.overlap = null;
    prototype.maxBand = 0;
    prototype.level = null;
    prototype.levelPrev = null;
    prototype.location = null;
    prototype.locationPrev = null;
    prototype.decode = function(_in, winSeq) {
        this.maxBand = _in.readBits(2) + 1;
        var wdLen, locBits, locBits2 = 0;
        switch (winSeq) {
            case ICSInfo.WindowSequence.ONLY_LONG_SEQUENCE:
                wdLen = 1;
                locBits = 5;
                locBits2 = 5;
                break;
            case ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE:
                wdLen = 8;
                locBits = 2;
                locBits2 = 2;
                break;
            case ICSInfo.WindowSequence.LONG_START_SEQUENCE:
                wdLen = 2;
                locBits = 4;
                locBits2 = 2;
                break;
            case ICSInfo.WindowSequence.LONG_STOP_SEQUENCE:
                wdLen = 2;
                locBits = 4;
                locBits2 = 5;
                break;
            default:
                return;
        }
        this.level = Array.apply(null, Array(this.maxBand)).map(function() {
            return Array(wdLen);
        });
        this.location = Array.apply(null, Array(this.maxBand)).map(function() {
            return Array(wdLen);
        });
        var wd, k, len, bits;
        for (var bd = 1; bd < this.maxBand; bd++) {
            for (wd = 0; wd < wdLen; wd++) {
                len = _in.readBits(3);
                this.level[bd][wd] = new Int32Array(len);
                this.location[bd][wd] = new Int32Array(len);
                for (k = 0; k < len; k++) {
                    this.level[bd][wd][k] = _in.readBits(4);
                    bits = (wd == 0) ? locBits : locBits2;
                    this.location[bd][wd][k] = _in.readBits(bits);
                }
            }
        }
    };
    prototype.process = function(data, winShape, winShapePrev, winSeq) {
        this.imdct.process(data, this.buffer1, winShape, winShapePrev, winSeq);
        for (var i = 0; i < GCConstants.BANDS; i++) {
            this.compensate(this.buffer1, this.buffer2, winSeq, i);
        }
        this.ipqf.process(this.buffer2, this.frameLen, this.maxBand, data);
    };
    /**
     *  gain compensation and overlap-add:
     *  - the gain control function is calculated
     *  - the gain control function applies to IMDCT output samples as a another IMDCT window
     *  - the reconstructed time domain signal produces by overlap-add
     */
    prototype.compensate = function(_in, out, winSeq, band) {
        var j;
        if (winSeq.equals(ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE)) {
            var a, b;
            for (var k = 0; k < 8; k++) {
                this.calculateFunctionData(this.lbShort * 2, band, winSeq, k);
                for (j = 0; j < this.lbShort * 2; j++) {
                    a = band * this.lbLong * 2 + k * this.lbShort * 2 + j;
                    _in[a] *= this._function[j];
                }
                for (j = 0; j < this.lbShort; j++) {
                    a = j + stjs.trunc(this.lbLong * 7 / 16) + this.lbShort * k;
                    b = band * this.lbLong * 2 + k * this.lbShort * 2 + j;
                    this.overlap[band][a] += _in[b];
                }
                for (j = 0; j < this.lbShort; j++) {
                    a = j + stjs.trunc(this.lbLong * 7 / 16) + this.lbShort * (k + 1);
                    b = band * this.lbLong * 2 + k * this.lbShort * 2 + this.lbShort + j;
                    this.overlap[band][a] = _in[b];
                }
                this.locationPrev[band][0] = Platform.copyOfInt(this.location[band][k], this.location[band][k].length);
                this.levelPrev[band][0] = Platform.copyOfInt(this.level[band][k], this.level[band][k].length);
            }
            System.arraycopy(this.overlap[band], 0, out[band], 0, this.lbLong);
            System.arraycopy(this.overlap[band], this.lbLong, this.overlap[band], 0, this.lbLong);
        } else {
            this.calculateFunctionData(this.lbLong * 2, band, winSeq, 0);
            for (j = 0; j < this.lbLong * 2; j++) {
                _in[band * this.lbLong * 2 + j] *= this._function[j];
            }
            for (j = 0; j < this.lbLong; j++) {
                out[band][j] = this.overlap[band][j] + _in[band * this.lbLong * 2 + j];
            }
            for (j = 0; j < this.lbLong; j++) {
                this.overlap[band][j] = _in[band * this.lbLong * 2 + this.lbLong + j];
            }
            var lastBlock = winSeq.equals(ICSInfo.WindowSequence.ONLY_LONG_SEQUENCE) ? 1 : 0;
            this.locationPrev[band][0] = Platform.copyOfInt(this.location[band][lastBlock], this.location[band][lastBlock].length);
            this.levelPrev[band][0] = Platform.copyOfInt(this.level[band][lastBlock], this.level[band][lastBlock].length);
        }
    };
    prototype.calculateFunctionData = function(samples, band, winSeq, blockID) {
        var locA = new Int32Array(10);
        var levA = new Float32Array(10);
        var modFunc = new Float32Array(samples);
        var buf1 = new Float32Array(stjs.trunc(samples / 2));
        var buf2 = new Float32Array(stjs.trunc(samples / 2));
        var buf3 = new Float32Array(stjs.trunc(samples / 2));
        var maxLocGain0 = 0, maxLocGain1 = 0, maxLocGain2 = 0;
        switch (winSeq) {
            case ICSInfo.WindowSequence.ONLY_LONG_SEQUENCE:
            case ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE:
                maxLocGain0 = maxLocGain1 = stjs.trunc(samples / 2);
                maxLocGain2 = 0;
                break;
            case ICSInfo.WindowSequence.LONG_START_SEQUENCE:
                maxLocGain0 = stjs.trunc(samples / 2);
                maxLocGain1 = stjs.trunc(samples * 7 / 32);
                maxLocGain2 = stjs.trunc(samples / 16);
                break;
            case ICSInfo.WindowSequence.LONG_STOP_SEQUENCE:
                maxLocGain0 = stjs.trunc(samples / 16);
                maxLocGain1 = stjs.trunc(samples * 7 / 32);
                maxLocGain2 = stjs.trunc(samples / 2);
                break;
        }
        this.calculateFMD(band, 0, true, maxLocGain0, samples, locA, levA, buf1);
        var block = (winSeq.equals(ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE)) ? blockID : 0;
        var secLevel = this.calculateFMD(band, block, false, maxLocGain1, samples, locA, levA, buf2);
        if (winSeq.equals(ICSInfo.WindowSequence.LONG_START_SEQUENCE) || winSeq.equals(ICSInfo.WindowSequence.LONG_STOP_SEQUENCE)) {
            this.calculateFMD(band, 1, false, maxLocGain2, samples, locA, levA, buf3);
        }
        var i;
        var flatLen = 0;
        if (winSeq.equals(ICSInfo.WindowSequence.LONG_STOP_SEQUENCE)) {
            flatLen = stjs.trunc(samples / 2) - maxLocGain0 - maxLocGain1;
            for (i = 0; i < flatLen; i++) {
                modFunc[i] = 1.0;
            }
        }
        if (winSeq.equals(ICSInfo.WindowSequence.ONLY_LONG_SEQUENCE) || winSeq.equals(ICSInfo.WindowSequence.EIGHT_SHORT_SEQUENCE)) 
            levA[0] = 1.0;
        for (i = 0; i < maxLocGain0; i++) {
            modFunc[i + flatLen] = levA[0] * secLevel * buf1[i];
        }
        for (i = 0; i < maxLocGain1; i++) {
            modFunc[i + flatLen + maxLocGain0] = levA[0] * buf2[i];
        }
        if (winSeq.equals(ICSInfo.WindowSequence.LONG_START_SEQUENCE)) {
            for (i = 0; i < maxLocGain2; i++) {
                modFunc[i + maxLocGain0 + maxLocGain1] = buf3[i];
            }
            flatLen = stjs.trunc(samples / 2) - maxLocGain1 - maxLocGain2;
            for (i = 0; i < flatLen; i++) {
                modFunc[i + maxLocGain0 + maxLocGain1 + maxLocGain2] = 1.0;
            }
        } else if (winSeq.equals(ICSInfo.WindowSequence.LONG_STOP_SEQUENCE)) {
            for (i = 0; i < maxLocGain2; i++) {
                modFunc[i + flatLen + maxLocGain0 + maxLocGain1] = buf3[i];
            }
        }
        for (i = 0; i < samples; i++) {
            this._function[i] = 1.0 / modFunc[i];
        }
    };
    prototype.calculateFMD = function(bd, wd, prev, maxLocGain, samples, loc, lev, fmd) {
        var m = new Int32Array(stjs.trunc(samples / 2));
        var lct = prev ? this.locationPrev[bd][wd] : this.location[bd][wd];
        var lvl = prev ? this.levelPrev[bd][wd] : this.level[bd][wd];
        var length = lct.length;
        var lngain;
        var i;
        for (i = 0; i < length; i++) {
            loc[i + 1] = 8 * lct[i];
            lngain = this.getGainChangePointID(lvl[i]);
            if (lngain < 0) 
                lev[i + 1] = 1.0 / Math.pow(2, -lngain);
             else 
                lev[i + 1] = Math.pow(2, lngain);
        }
        loc[0] = 0;
        if (length == 0) 
            lev[0] = 1.0;
         else 
            lev[0] = lev[1];
        var secLevel = lev[0];
        loc[length + 1] = maxLocGain;
        lev[length + 1] = 1.0;
        var j;
        for (i = 0; i < maxLocGain; i++) {
            m[i] = 0;
            for (j = 0; j <= length + 1; j++) {
                if (loc[j] <= i) 
                    m[i] = j;
            }
        }
        for (i = 0; i < maxLocGain; i++) {
            if ((i >= loc[m[i]]) && (i <= loc[m[i]] + 7)) 
                fmd[i] = this.interpolateGain(lev[m[i]], lev[m[i] + 1], i - loc[m[i]]);
             else 
                fmd[i] = lev[m[i] + 1];
        }
        return secLevel;
    };
    /**
     *  transformes the exponent value of the gain to the id of the gain change
     *  point
     */
    prototype.getGainChangePointID = function(lngain) {
        for (var i = 0; i < GCConstants.ID_GAIN; i++) {
            if (lngain == GCConstants.LN_GAIN[i]) 
                return i;
        }
        return 0;
    };
    /**
     *  calculates a fragment modification function
     *  the interpolated gain value between the gain values of two gain change
     *  positions is calculated by the formula:
     *  f(a,b,j) = 2^(((8-j)log2(a)+j*log2(b))/8)
     */
    prototype.interpolateGain = function(alev0, alev1, iloc) {
        var a0 = (Math.log(alev0) / Math.log(2));
        var a1 = (Math.log(alev1) / Math.log(2));
        return Math.pow(2.0, (((8 - iloc) * a0 + iloc * a1) / 8));
    };
}, {imdct: "IMDCT", ipqf: "IPQF", buffer1: "Float32Array", _function: "Float32Array", buffer2: "Array", overlap: "Array", level: "Array", levelPrev: "Array", location: "Array", locationPrev: "Array", LN_GAIN: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var RGBAEssenceDescriptor = function(ul) {
    GenericPictureEssenceDescriptor.call(this, ul);
};
RGBAEssenceDescriptor = stjs.extend(RGBAEssenceDescriptor, GenericPictureEssenceDescriptor, [], function(constructor, prototype) {
    prototype.componentMaxRef = 0;
    prototype.componentMinRef = 0;
    prototype.alphaMaxRef = 0;
    prototype.alphaMinRef = 0;
    prototype.scanningDirection = 0;
    prototype.pixelLayout = null;
    prototype.palette = null;
    prototype.paletteLayout = null;
    prototype.read = function(tags) {
        GenericPictureEssenceDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 13318:
                    this.componentMaxRef = _bb.getInt();
                    break;
                case 13319:
                    this.componentMinRef = _bb.getInt();
                    break;
                case 13320:
                    this.alphaMaxRef = _bb.getInt();
                    break;
                case 13321:
                    this.alphaMinRef = _bb.getInt();
                    break;
                case 13317:
                    this.scanningDirection = _bb.get();
                    break;
                case 13313:
                    this.pixelLayout = _bb;
                    break;
                case 13315:
                    this.palette = _bb;
                    break;
                case 13316:
                    this.paletteLayout = _bb;
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getComponentMaxRef = function() {
        return this.componentMaxRef;
    };
    prototype.getComponentMinRef = function() {
        return this.componentMinRef;
    };
    prototype.getAlphaMaxRef = function() {
        return this.alphaMaxRef;
    };
    prototype.getAlphaMinRef = function() {
        return this.alphaMinRef;
    };
    prototype.getScanningDirection = function() {
        return this.scanningDirection;
    };
    prototype.getPixelLayout = function() {
        return this.pixelLayout;
    };
    prototype.getPalette = function() {
        return this.palette;
    };
    prototype.getPaletteLayout = function() {
        return this.paletteLayout;
    };
}, {pixelLayout: "ByteBuffer", palette: "ByteBuffer", paletteLayout: "ByteBuffer", frameLayout: {name: "Enum", arguments: ["GenericPictureEssenceDescriptor.LayoutType"]}, aspectRatio: "Rational", videoLineMap: "Int32Array", transferCharacteristic: "UL", pictureEssenceCoding: "UL", codingEquations: "UL", colorPrimaries: "UL", sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var CDCIEssenceDescriptor = function(ul) {
    GenericPictureEssenceDescriptor.call(this, ul);
};
CDCIEssenceDescriptor = stjs.extend(CDCIEssenceDescriptor, GenericPictureEssenceDescriptor, [], function(constructor, prototype) {
    prototype.componentDepth = 0;
    prototype.horizontalSubsampling = 0;
    prototype.verticalSubsampling = 0;
    prototype.colorSiting = 0;
    prototype.reversedByteOrder = 0;
    prototype.paddingBits = 0;
    prototype.alphaSampleDepth = 0;
    prototype.blackRefLevel = 0;
    prototype.whiteReflevel = 0;
    prototype.colorRange = 0;
    prototype.read = function(tags) {
        GenericPictureEssenceDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 13057:
                    this.componentDepth = _bb.getInt();
                    break;
                case 13058:
                    this.horizontalSubsampling = _bb.getInt();
                    break;
                case 13064:
                    this.verticalSubsampling = _bb.getInt();
                    break;
                case 13059:
                    this.colorSiting = _bb.get();
                    break;
                case 13067:
                    this.reversedByteOrder = _bb.get();
                    break;
                case 13063:
                    this.paddingBits = _bb.getShort();
                    break;
                case 13065:
                    this.alphaSampleDepth = _bb.getInt();
                    break;
                case 13060:
                    this.blackRefLevel = _bb.getInt();
                    break;
                case 13061:
                    this.whiteReflevel = _bb.getInt();
                    break;
                case 13062:
                    this.colorRange = _bb.getInt();
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getComponentDepth = function() {
        return this.componentDepth;
    };
    prototype.getHorizontalSubsampling = function() {
        return this.horizontalSubsampling;
    };
    prototype.getVerticalSubsampling = function() {
        return this.verticalSubsampling;
    };
    prototype.getColorSiting = function() {
        return this.colorSiting;
    };
    prototype.getReversedByteOrder = function() {
        return this.reversedByteOrder;
    };
    prototype.getPaddingBits = function() {
        return this.paddingBits;
    };
    prototype.getAlphaSampleDepth = function() {
        return this.alphaSampleDepth;
    };
    prototype.getBlackRefLevel = function() {
        return this.blackRefLevel;
    };
    prototype.getWhiteReflevel = function() {
        return this.whiteReflevel;
    };
    prototype.getColorRange = function() {
        return this.colorRange;
    };
}, {frameLayout: {name: "Enum", arguments: ["GenericPictureEssenceDescriptor.LayoutType"]}, aspectRatio: "Rational", videoLineMap: "Int32Array", transferCharacteristic: "UL", pictureEssenceCoding: "UL", codingEquations: "UL", colorPrimaries: "UL", sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var WaveAudioDescriptor = function(ul) {
    GenericSoundEssenceDescriptor.call(this, ul);
};
WaveAudioDescriptor = stjs.extend(WaveAudioDescriptor, GenericSoundEssenceDescriptor, [], function(constructor, prototype) {
    prototype.blockAlign = 0;
    prototype.sequenceOffset = 0;
    prototype.avgBps = 0;
    prototype.channelAssignment = null;
    prototype.peakEnvelopeVersion = 0;
    prototype.peakEnvelopeFormat = 0;
    prototype.pointsPerPeakValue = 0;
    prototype.peakEnvelopeBlockSize = 0;
    prototype.peakChannels = 0;
    prototype.peakFrames = 0;
    prototype.peakOfPeaksPosition = null;
    prototype.peakEnvelopeTimestamp = null;
    prototype.peakEnvelopeData = null;
    prototype.read = function(tags) {
        GenericSoundEssenceDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 15626:
                    this.blockAlign = _bb.getShort();
                    break;
                case 15627:
                    this.sequenceOffset = _bb.get();
                    break;
                case 15625:
                    this.avgBps = _bb.getInt();
                    break;
                case 15666:
                    this.channelAssignment = UL.read(_bb);
                    break;
                case 15657:
                    this.peakEnvelopeVersion = _bb.getInt();
                    break;
                case 15658:
                    this.peakEnvelopeFormat = _bb.getInt();
                    break;
                case 15659:
                    this.pointsPerPeakValue = _bb.getInt();
                    break;
                case 15660:
                    this.peakEnvelopeBlockSize = _bb.getInt();
                    break;
                case 15661:
                    this.peakChannels = _bb.getInt();
                    break;
                case 15662:
                    this.peakFrames = _bb.getInt();
                    break;
                case 15663:
                    this.peakOfPeaksPosition = _bb;
                    break;
                case 15664:
                    this.peakEnvelopeTimestamp = _bb;
                    break;
                case 15665:
                    this.peakEnvelopeData = _bb;
                    break;
                default:
                    System.out.println(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getBlockAlign = function() {
        return this.blockAlign;
    };
    prototype.getSequenceOffset = function() {
        return this.sequenceOffset;
    };
    prototype.getAvgBps = function() {
        return this.avgBps;
    };
    prototype.getChannelAssignment = function() {
        return this.channelAssignment;
    };
    prototype.getPeakEnvelopeVersion = function() {
        return this.peakEnvelopeVersion;
    };
    prototype.getPeakEnvelopeFormat = function() {
        return this.peakEnvelopeFormat;
    };
    prototype.getPointsPerPeakValue = function() {
        return this.pointsPerPeakValue;
    };
    prototype.getPeakEnvelopeBlockSize = function() {
        return this.peakEnvelopeBlockSize;
    };
    prototype.getPeakChannels = function() {
        return this.peakChannels;
    };
    prototype.getPeakFrames = function() {
        return this.peakFrames;
    };
    prototype.getPeakOfPeaksPosition = function() {
        return this.peakOfPeaksPosition;
    };
    prototype.getPeakEnvelopeTimestamp = function() {
        return this.peakEnvelopeTimestamp;
    };
    prototype.getPeakEnvelopeData = function() {
        return this.peakEnvelopeData;
    };
}, {channelAssignment: "UL", peakOfPeaksPosition: "ByteBuffer", peakEnvelopeTimestamp: "ByteBuffer", peakEnvelopeData: "ByteBuffer", audioSamplingRate: "Rational", soundEssenceCompression: "UL", sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A box storing a list of synch samples
 *  
 *  @author The JCodec project
 *  
 */
var PartialSyncSamplesBox = function(header) {
    SyncSamplesBox.call(this, header);
};
PartialSyncSamplesBox = stjs.extend(PartialSyncSamplesBox, SyncSamplesBox, [], function(constructor, prototype) {
    constructor.STPS = "stps";
}, {syncSamples: "Int32Array", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ProductionApertureBox = function(atom) {
    ClearApertureBox.call(this, atom);
};
ProductionApertureBox = stjs.extend(ProductionApertureBox, ClearApertureBox, [], function(constructor, prototype) {
    constructor.PROF = "prof";
    constructor.createProductionApertureBox = function(width, height) {
        var prof = new ProductionApertureBox(new Header(ProductionApertureBox.PROF));
        prof.width = width;
        prof.height = height;
        return prof;
    };
}, {header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var EncodedPixelBox = function(atom) {
    ClearApertureBox.call(this, atom);
};
EncodedPixelBox = stjs.extend(EncodedPixelBox, ClearApertureBox, [], function(constructor, prototype) {
    constructor.ENOF = "enof";
    constructor.createEncodedPixelBox = function(width, height) {
        var enof = new EncodedPixelBox(new Header(EncodedPixelBox.ENOF));
        enof.width = width;
        enof.height = height;
        return enof;
    };
}, {header: "Header"}, {});
var DataBoxes = function() {
    Boxes.call(this);
    this.mappings.put(UrlBox.fourcc(), UrlBox);
    this.mappings.put(AliasBox.fourcc(), AliasBox);
    this.mappings.put("cios", AliasBox);
};
DataBoxes = stjs.extend(DataBoxes, Boxes, [], null, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Track fragment box
 *  
 *  Contains routines dedicated to simplify working with track fragments
 *  
 *  @author The JCodec project
 *  
 */
var TrackFragmentBox = function(atom) {
    NodeBox.call(this, atom);
};
TrackFragmentBox = stjs.extend(TrackFragmentBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "traf";
    };
    prototype.getTrackId = function() {
        var tfhd = NodeBox.findFirst(this, TrackFragmentHeaderBox, TrackFragmentHeaderBox.fourcc());
        if (tfhd == null) 
             throw new RuntimeException("Corrupt track fragment, no header atom found");
        return tfhd.getTrackId();
    };
    constructor.createTrackFragmentBox = function() {
        return new TrackFragmentBox(new Header(TrackFragmentBox.fourcc()));
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Creates MP4 file out of a set of samples
 *  
 *  @author The JCodec project
 */
var DataInfoBox = function(atom) {
    NodeBox.call(this, atom);
};
DataInfoBox = stjs.extend(DataInfoBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "dinf";
    };
    constructor.createDataInfoBox = function() {
        return new DataInfoBox(new Header(DataInfoBox.fourcc()));
    };
    prototype.getDref = function() {
        return NodeBox.findFirst(this, DataRefBox, "dref");
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Describes video payload sample
 *  
 *  @author The JCodec project
 *  
 */
var VideoSampleEntry = function(atom) {
    SampleEntry.call(this, atom);
};
VideoSampleEntry = stjs.extend(VideoSampleEntry, SampleEntry, [], function(constructor, prototype) {
    constructor.videoSampleEntry = function(fourcc, size, encoderName) {
        return VideoSampleEntry.createVideoSampleEntry(new Header(fourcc), ((0) << 16 >> 16), ((0) << 16 >> 16), "jcod", 0, 768, ((size.getWidth()) << 16 >> 16), ((size.getHeight()) << 16 >> 16), 72, 72, ((1) << 16 >> 16), encoderName != null ? encoderName : "jcodec", ((24) << 16 >> 16), ((1) << 16 >> 16), ((-1) << 16 >> 16));
    };
    constructor.createVideoSampleEntry = function(atom, version, revision, vendor, temporalQual, spacialQual, width, height, hRes, vRes, frameCount, compressorName, depth, drefInd, clrTbl) {
        var e = new VideoSampleEntry(atom);
        e.drefInd = drefInd;
        e.version = version;
        e.revision = revision;
        e.vendor = vendor;
        e.temporalQual = temporalQual;
        e.spacialQual = spacialQual;
        e.width = width;
        e.height = height;
        e.hRes = hRes;
        e.vRes = vRes;
        e.frameCount = frameCount;
        e.compressorName = compressorName;
        e.depth = depth;
        e.clrTbl = clrTbl;
        return e;
    };
    prototype.version = 0;
    prototype.revision = 0;
    prototype.vendor = null;
    prototype.temporalQual = 0;
    prototype.spacialQual = 0;
    prototype.width = 0;
    prototype.height = 0;
    prototype.hRes = 0.0;
    prototype.vRes = 0.0;
    prototype.frameCount = 0;
    prototype.compressorName = null;
    prototype.depth = 0;
    prototype.clrTbl = 0;
    prototype.parse = function(input) {
        SampleEntry.prototype.parse.call(this, input);
        this.version = input.getShort();
        this.revision = input.getShort();
        this.vendor = NIOUtils.readString(input, 4);
        this.temporalQual = input.getInt();
        this.spacialQual = input.getInt();
        this.width = input.getShort();
        this.height = input.getShort();
        this.hRes = input.getInt() / 65536.0;
        this.vRes = input.getInt() / 65536.0;
        input.getInt();
        this.frameCount = input.getShort();
        this.compressorName = NIOUtils.readPascalStringL(input, 31);
        this.depth = input.getShort();
        this.clrTbl = input.getShort();
        this.parseExtensions(input);
    };
    prototype.doWrite = function(out) {
        SampleEntry.prototype.doWrite.call(this, out);
        out.putShort(this.version);
        out.putShort(this.revision);
        out.put3(JCodecUtil2.asciiString(this.vendor), 0, 4);
        out.putInt(this.temporalQual);
        out.putInt(this.spacialQual);
        out.putShort(stjs.trunc(this.width));
        out.putShort(stjs.trunc(this.height));
        out.putInt(stjs.trunc((this.hRes * 65536)));
        out.putInt(stjs.trunc((this.vRes * 65536)));
        out.putInt(0);
        out.putShort(this.frameCount);
        NIOUtils.writePascalStringL(out, this.compressorName, 31);
        out.putShort(this.depth);
        out.putShort(this.clrTbl);
        this.writeExtensions(out);
    };
    prototype.getWidth = function() {
        return this.width;
    };
    prototype.getHeight = function() {
        return this.height;
    };
    prototype.gethRes = function() {
        return this.hRes;
    };
    prototype.getvRes = function() {
        return this.vRes;
    };
    prototype.getFrameCount = function() {
        return this.frameCount;
    };
    prototype.getCompressorName = function() {
        return this.compressorName;
    };
    prototype.getDepth = function() {
        return this.depth;
    };
    prototype.getVendor = function() {
        return this.vendor;
    };
    prototype.getVersion = function() {
        return this.version;
    };
    prototype.getRevision = function() {
        return this.revision;
    };
    prototype.getTemporalQual = function() {
        return this.temporalQual;
    };
    prototype.getSpacialQual = function() {
        return this.spacialQual;
    };
    prototype.getClrTbl = function() {
        return this.clrTbl;
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Describes timecode payload sample
 *  
 *  @author The JCodec project
 *  
 */
var TimecodeSampleEntry = function(header) {
    SampleEntry.call(this, header);
};
TimecodeSampleEntry = stjs.extend(TimecodeSampleEntry, SampleEntry, [], function(constructor, prototype) {
    constructor.TMCD = "tmcd";
    constructor.FLAG_DROPFRAME = 1;
    constructor.FLAG_24HOURMAX = 2;
    constructor.FLAG_NEGATIVETIMEOK = 4;
    constructor.FLAG_COUNTER = 8;
    constructor.createTimecodeSampleEntry = function(flags, timescale, frameDuration, numFrames) {
        var tmcd = new TimecodeSampleEntry(new Header(TimecodeSampleEntry.TMCD));
        tmcd.flags = flags;
        tmcd.timescale = timescale;
        tmcd.frameDuration = frameDuration;
        tmcd.numFrames = (numFrames << 24 >> 24);
        return tmcd;
    };
    prototype.flags = 0;
    prototype.timescale = 0;
    prototype.frameDuration = 0;
    prototype.numFrames = 0;
    prototype.parse = function(input) {
        SampleEntry.prototype.parse.call(this, input);
        NIOUtils.skip(input, 4);
        this.flags = input.getInt();
        this.timescale = input.getInt();
        this.frameDuration = input.getInt();
        this.numFrames = input.get();
        NIOUtils.skip(input, 1);
    };
    prototype.doWrite = function(out) {
        SampleEntry.prototype.doWrite.call(this, out);
        out.putInt(0);
        out.putInt(this.flags);
        out.putInt(this.timescale);
        out.putInt(this.frameDuration);
        out.put(this.numFrames);
        out.put((207 << 24 >> 24));
    };
    prototype.getFlags = function() {
        return this.flags;
    };
    prototype.getTimescale = function() {
        return this.timescale;
    };
    prototype.getFrameDuration = function() {
        return this.frameDuration;
    };
    prototype.getNumFrames = function() {
        return this.numFrames;
    };
    prototype.isDropFrame = function() {
        return (this.flags & TimecodeSampleEntry.FLAG_DROPFRAME) != 0;
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
var AudioBoxes = function() {
    Boxes.call(this);
    this.mappings.put(WaveExtension.fourcc(), WaveExtension);
    this.mappings.put(ChannelBox.fourcc(), ChannelBox);
    this.mappings.put("esds", Box.LeafBox);
};
AudioBoxes = stjs.extend(AudioBoxes, Boxes, [], null, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Describes audio payload sample
 *  
 *  @author The JCodec project
 *  
 */
var AudioSampleEntry = function(atom) {
    SampleEntry.call(this, atom);
};
AudioSampleEntry = stjs.extend(AudioSampleEntry, SampleEntry, [], function(constructor, prototype) {
    constructor.kAudioFormatFlagIsFloat = 1;
    constructor.kAudioFormatFlagIsBigEndian = 2;
    constructor.kAudioFormatFlagIsSignedInteger = 4;
    constructor.kAudioFormatFlagIsPacked = 8;
    constructor.kAudioFormatFlagIsAlignedHigh = 16;
    constructor.kAudioFormatFlagIsNonInterleaved = 32;
    constructor.kAudioFormatFlagIsNonMixable = 64;
    constructor.createAudioSampleEntry = function(header, drefInd, channelCount, sampleSize, sampleRate, revision, vendor, compressionId, pktSize, samplesPerPkt, bytesPerPkt, bytesPerFrame, bytesPerSample, version) {
        var audio = new AudioSampleEntry(header);
        audio.drefInd = drefInd;
        audio.channelCount = channelCount;
        audio.sampleSize = sampleSize;
        audio.sampleRate = sampleRate;
        audio.revision = revision;
        audio.vendor = vendor;
        audio.compressionId = compressionId;
        audio.pktSize = pktSize;
        audio.samplesPerPkt = samplesPerPkt;
        audio.bytesPerPkt = bytesPerPkt;
        audio.bytesPerFrame = bytesPerFrame;
        audio.bytesPerSample = bytesPerSample;
        audio.version = version;
        return audio;
    };
    prototype.channelCount = 0;
    prototype.sampleSize = 0;
    prototype.sampleRate = 0.0;
    prototype.revision = 0;
    prototype.vendor = 0;
    prototype.compressionId = 0;
    prototype.pktSize = 0;
    prototype.samplesPerPkt = 0;
    prototype.bytesPerPkt = 0;
    prototype.bytesPerFrame = 0;
    prototype.bytesPerSample = 0;
    prototype.version = 0;
    prototype.lpcmFlags = 0;
    constructor.MONO = Arrays.asList(Label.Mono);
    constructor.STEREO = Arrays.asList(Label.Left, Label.Right);
    constructor.MATRIX_STEREO = Arrays.asList(Label.LeftTotal, Label.RightTotal);
    constructor.EMPTY = Array(0);
    prototype.parse = function(input) {
        SampleEntry.prototype.parse.call(this, input);
        this.version = input.getShort();
        this.revision = input.getShort();
        this.vendor = input.getInt();
        this.channelCount = input.getShort();
        this.sampleSize = input.getShort();
        this.compressionId = input.getShort();
        this.pktSize = input.getShort();
        var sr = Platform.unsignedInt(input.getInt());
        this.sampleRate = sr / 65536.0;
        if (this.version == 1) {
            this.samplesPerPkt = input.getInt();
            this.bytesPerPkt = input.getInt();
            this.bytesPerFrame = input.getInt();
            this.bytesPerSample = input.getInt();
        } else if (this.version == 2) {
            input.getInt();
            this.sampleRate = Double.longBitsToDouble(input.getLong());
            this.channelCount = ((input.getInt()) << 16 >> 16);
            input.getInt();
            this.sampleSize = ((input.getInt()) << 16 >> 16);
            this.lpcmFlags = stjs.trunc(input.getInt());
            this.bytesPerFrame = stjs.trunc(input.getInt());
            this.samplesPerPkt = stjs.trunc(input.getInt());
        }
        this.parseExtensions(input);
    };
    prototype.doWrite = function(out) {
        SampleEntry.prototype.doWrite.call(this, out);
        out.putShort(this.version);
        out.putShort(this.revision);
        out.putInt(this.vendor);
        if (this.version < 2) {
            out.putShort(this.channelCount);
            if (this.version == 0) 
                out.putShort(this.sampleSize);
             else 
                out.putShort(((16) << 16 >> 16));
            out.putShort(((this.compressionId) << 16 >> 16));
            out.putShort(((this.pktSize) << 16 >> 16));
            out.putInt(((Math.round(this.sampleRate * 65536.0)) | 0));
            if (this.version == 1) {
                out.putInt(this.samplesPerPkt);
                out.putInt(this.bytesPerPkt);
                out.putInt(this.bytesPerFrame);
                out.putInt(this.bytesPerSample);
            }
        } else if (this.version == 2) {
            out.putShort(((3) << 16 >> 16));
            out.putShort(((16) << 16 >> 16));
            out.putShort(((-2) << 16 >> 16));
            out.putShort(((0) << 16 >> 16));
            out.putInt(65536);
            out.putInt(72);
            out.putLong(Double.doubleToLongBits(this.sampleRate));
            out.putInt(this.channelCount);
            out.putInt(2130706432);
            out.putInt(this.sampleSize);
            out.putInt(this.lpcmFlags);
            out.putInt(this.bytesPerFrame);
            out.putInt(this.samplesPerPkt);
        }
        this.writeExtensions(out);
    };
    prototype.getChannelCount = function() {
        return this.channelCount;
    };
    prototype.calcFrameSize = function() {
        if (this.version == 0 || this.bytesPerFrame == 0) 
            return (this.sampleSize >> 3) * this.channelCount;
         else 
            return this.bytesPerFrame;
    };
    prototype.calcSampleSize = function() {
        return stjs.trunc(this.calcFrameSize() / this.channelCount);
    };
    prototype.getSampleSize = function() {
        return this.sampleSize;
    };
    prototype.getSampleRate = function() {
        return this.sampleRate;
    };
    prototype.getBytesPerFrame = function() {
        return this.bytesPerFrame;
    };
    prototype.getBytesPerSample = function() {
        return this.bytesPerSample;
    };
    prototype.getVersion = function() {
        return this.version;
    };
    prototype.getEndian = function() {
        var endianBox = NodeBox.findFirstPath(this, EndianBox, [WaveExtension.fourcc(), EndianBox.fourcc()]);
        if (endianBox == null) {
            if ("twos".equals(this.header.getFourcc())) 
                return ByteOrder.BIG_ENDIAN;
             else if ("lpcm".equals(this.header.getFourcc())) 
                return (this.lpcmFlags & AudioSampleEntry.kAudioFormatFlagIsBigEndian) != 0 ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;
             else if ("sowt".equals(this.header.getFourcc())) 
                return ByteOrder.LITTLE_ENDIAN;
             else 
                return ByteOrder.BIG_ENDIAN;
        }
        return endianBox.getEndian();
    };
    prototype.isFloat = function() {
        return "fl32".equals(this.header.getFourcc()) || "fl64".equals(this.header.getFourcc()) || ("lpcm".equals(this.header.getFourcc()) && (this.lpcmFlags & AudioSampleEntry.kAudioFormatFlagIsFloat) != 0);
    };
    constructor.pcms = new HashSet();
    prototype.isPCM = function() {
        return AudioSampleEntry.pcms.contains(this.header.getFourcc());
    };
    prototype.getFormat = function() {
        return new AudioFormat(stjs.trunc(this.sampleRate), this.calcSampleSize() << 3, this.channelCount, true, this.getEndian() == ByteOrder.BIG_ENDIAN);
    };
    prototype.getLabels = function() {
        var channelBox = NodeBox.findFirst(this, ChannelBox, "chan");
        if (channelBox != null) {
            var labels = AudioSampleEntry.getLabelsFromChan(channelBox);
            if (this.channelCount == 2) 
                return this.translate(AudioSampleEntry.translationStereo, labels);
             else 
                return this.translate(AudioSampleEntry.translationSurround, labels);
        } else {
            switch (this.channelCount) {
                case 1:
                    return [ChannelLabel.MONO];
                case 2:
                    return [ChannelLabel.STEREO_LEFT, ChannelLabel.STEREO_RIGHT];
                case 6:
                    return [ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.CENTER, ChannelLabel.LFE, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT];
                default:
                    var lbl = Array(this.channelCount);
                    Arrays.fill(lbl, ChannelLabel.MONO);
                    return lbl;
            }
        }
    };
    prototype.translate = function(translation, labels) {
        var result = Array(labels.length);
        var i = 0;
        for (var j = 0; j < labels.length; j++) {
            var label = labels[j];
            result[i++] = translation.get(label);
        }
        return result;
    };
    constructor.compressedAudioSampleEntry = function(fourcc, drefId, sampleSize, channels, sampleRate, samplesPerPacket, bytesPerPacket, bytesPerFrame) {
        var ase = AudioSampleEntry.createAudioSampleEntry(Header.createHeader(fourcc, 0), ((drefId) << 16 >> 16), ((channels) << 16 >> 16), ((16) << 16 >> 16), sampleRate, ((0) << 16 >> 16), 0, 65534, 0, samplesPerPacket, bytesPerPacket, bytesPerFrame, stjs.trunc(16 / 8), ((0) << 16 >> 16));
        return ase;
    };
    constructor.audioSampleEntry = function(fourcc, drefId, sampleSize, channels, sampleRate, endian) {
        var ase = AudioSampleEntry.createAudioSampleEntry(Header.createHeader(fourcc, 0), ((drefId) << 16 >> 16), ((channels) << 16 >> 16), ((16) << 16 >> 16), sampleRate, ((0) << 16 >> 16), 0, 65535, 0, 1, sampleSize, channels * sampleSize, sampleSize, ((1) << 16 >> 16));
        var wave = new NodeBox(new Header("wave"));
        ase.add(wave);
        wave.add(FormatBox.createFormatBox(fourcc));
        wave.add(EndianBox.createEndianBox(endian));
        wave.add(Box.terminatorAtom());
        return ase;
    };
    constructor.lookupFourcc = function(format) {
        if (format.getSampleSizeInBits() == 16 && !format.isBigEndian()) 
            return "sowt";
         else if (format.getSampleSizeInBits() == 24) 
            return "in24";
         else 
             throw new NotSupportedException("Audio format " + format + " is not supported.");
    };
    constructor.audioSampleEntryPCM = function(format) {
        return AudioSampleEntry.audioSampleEntry(AudioSampleEntry.lookupFourcc(format), 1, format.getSampleSizeInBits() >> 3, format.getChannels(), stjs.trunc(format.getSampleRate()), format.isBigEndian() ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN);
    };
    constructor.translationStereo = new HashMap();
    constructor.translationSurround = new HashMap();
    constructor.getLabelsFromSampleEntry = function(se) {
        var channel = NodeBox.findFirst(se, ChannelBox, "chan");
        if (channel != null) 
            return AudioSampleEntry.getLabelsFromChan(channel);
         else {
            var channelCount = se.getChannelCount();
            switch (channelCount) {
                case 1:
                    return [Label.Mono];
                case 2:
                    return [Label.Left, Label.Right];
                case 3:
                    return [Label.Left, Label.Right, Label.Center];
                case 4:
                    return [Label.Left, Label.Right, Label.LeftSurround, Label.RightSurround];
                case 5:
                    return [Label.Left, Label.Right, Label.Center, Label.LeftSurround, Label.RightSurround];
                case 6:
                    return [Label.Left, Label.Right, Label.Center, Label.LFEScreen, Label.LeftSurround, Label.RightSurround];
                default:
                    var res = Array(channelCount);
                    Arrays.fill(res, Label.Mono);
                    return res;
            }
        }
    };
    constructor.getLabelsFromTrack = function(trakBox) {
        return AudioSampleEntry.getLabelsFromSampleEntry(trakBox.getSampleEntries()[0]);
    };
    constructor.setLabel = function(trakBox, channel, label) {
        var labels = AudioSampleEntry.getLabelsFromTrack(trakBox);
        labels[channel] = label;
        AudioSampleEntry._setLabels(trakBox, labels);
    };
    constructor._setLabels = function(trakBox, labels) {
        var channel = NodeBox.findFirstPath(trakBox, ChannelBox, ["mdia", "minf", "stbl", "stsd", null, "chan"]);
        if (channel == null) {
            channel = ChannelBox.createChannelBox();
            NodeBox.findFirstPath(trakBox, SampleEntry, ["mdia", "minf", "stbl", "stsd", null]).add(channel);
        }
        AudioSampleEntry.setLabels(labels, channel);
    };
    constructor.setLabels = function(labels, channel) {
        channel.setChannelLayout(ChannelLayout.kCAFChannelLayoutTag_UseChannelDescriptions.getCode());
        var list = Array(labels.length);
        for (var i = 0; i < labels.length; i++) 
            list[i] = new ChannelBox.ChannelDescription(labels[i].getVal(), 0, new Float32Array([0, 0, 0]));
        channel.setDescriptions(list);
    };
    /**
     *  <code>
     *         enum
     *         {
     *             kCAFChannelBit_Left                 = (1<<0),
     *             kCAFChannelBit_Right                = (1<<1),
     *             kCAFChannelBit_Center               = (1<<2),
     *             kCAFChannelBit_LFEScreen            = (1<<3),
     *             kCAFChannelBit_LeftSurround         = (1<<4),   // WAVE: "Back Left"
     *             kCAFChannelBit_RightSurround        = (1<<5),   // WAVE: "Back Right"
     *             kCAFChannelBit_LeftCenter           = (1<<6),
     *             kCAFChannelBit_RightCenter          = (1<<7),
     *             kCAFChannelBit_CenterSurround       = (1<<8),   // WAVE: "Back Center"
     *             kCAFChannelBit_LeftSurroundDirect   = (1<<9),   // WAVE: "Side Left"
     *             kCAFChannelBit_RightSurroundDirect  = (1<<10), // WAVE: "Side Right"
     *             kCAFChannelBit_TopCenterSurround    = (1<<11),
     *             kCAFChannelBit_VerticalHeightLeft   = (1<<12), // WAVE: "Top Front Left"
     *             kCAFChannelBit_VerticalHeightCenter = (1<<13), // WAVE: "Top Front Center"
     *             kCAFChannelBit_VerticalHeightRight  = (1<<14), // WAVE: "Top Front Right"
     *             kCAFChannelBit_TopBackLeft          = (1<<15),
     *             kCAFChannelBit_TopBackCenter        = (1<<16),
     *             kCAFChannelBit_TopBackRight         = (1<<17)
     *         };
     *         </code>
     *  
     *  @param channelBitmap
     *  @return
     */
    constructor.getLabelsByBitmap = function(channelBitmap) {
        var result = new ArrayList();
        var values = Label.values();
        for (var i = 0; i < values.length; i++) {
            var label = values[i];
            if ((label.bitmapVal & channelBitmap) != 0) 
                result.add(label);
        }
        return result.toArray(Array(0));
    };
    constructor.extractLabels = function(descriptions) {
        var result = Array(descriptions.length);
        for (var i = 0; i < descriptions.length; i++) 
            result[i] = descriptions[i].getLabel();
        return result;
    };
    constructor.getLabelsFromChan = function(box) {
        var tag = box.getChannelLayout();
        if ((tag >> 16) == 147) {
            var n = ((tag) | 0) & 65535;
            var res = Array(n);
            for (var i = 0; i < n; i++) 
                res[i] = Label.getByVal((1 << 16) | i);
            return res;
        }
        var values = ChannelLayout.values();
        for (var i = 0; i < values.length; i++) {
            var layout = values[i];
            if (layout.getCode() == tag) {
                if (layout == ChannelLayout.kCAFChannelLayoutTag_UseChannelDescriptions) {
                    return AudioSampleEntry.extractLabels(box.getDescriptions());
                } else if (layout == ChannelLayout.kCAFChannelLayoutTag_UseChannelBitmap) {
                    return AudioSampleEntry.getLabelsByBitmap(box.getChannelBitmap());
                } else {
                    return layout.getLabels();
                }
            }
        }
        return AudioSampleEntry.EMPTY;
    };
}, {MONO: {name: "List", arguments: ["Label"]}, STEREO: {name: "List", arguments: ["Label"]}, MATRIX_STEREO: {name: "List", arguments: ["Label"]}, EMPTY: "Array", pcms: {name: "Set", arguments: [null]}, translationStereo: {name: "Map", arguments: ["Label", {name: "Enum", arguments: ["ChannelLabel"]}]}, translationSurround: {name: "Map", arguments: ["Label", {name: "Enum", arguments: ["ChannelLabel"]}]}, boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
(function() {
    AudioSampleEntry.pcms.add("raw ");
    AudioSampleEntry.pcms.add("twos");
    AudioSampleEntry.pcms.add("sowt");
    AudioSampleEntry.pcms.add("fl32");
    AudioSampleEntry.pcms.add("fl64");
    AudioSampleEntry.pcms.add("in24");
    AudioSampleEntry.pcms.add("in32");
    AudioSampleEntry.pcms.add("lpcm");
})();
(function() {
    AudioSampleEntry.translationStereo.put(Label.Left, ChannelLabel.STEREO_LEFT);
    AudioSampleEntry.translationStereo.put(Label.Right, ChannelLabel.STEREO_RIGHT);
    AudioSampleEntry.translationStereo.put(Label.HeadphonesLeft, ChannelLabel.STEREO_LEFT);
    AudioSampleEntry.translationStereo.put(Label.HeadphonesRight, ChannelLabel.STEREO_RIGHT);
    AudioSampleEntry.translationStereo.put(Label.LeftTotal, ChannelLabel.STEREO_LEFT);
    AudioSampleEntry.translationStereo.put(Label.RightTotal, ChannelLabel.STEREO_RIGHT);
    AudioSampleEntry.translationStereo.put(Label.LeftWide, ChannelLabel.STEREO_LEFT);
    AudioSampleEntry.translationStereo.put(Label.RightWide, ChannelLabel.STEREO_RIGHT);
    AudioSampleEntry.translationSurround.put(Label.Left, ChannelLabel.FRONT_LEFT);
    AudioSampleEntry.translationSurround.put(Label.Right, ChannelLabel.FRONT_RIGHT);
    AudioSampleEntry.translationSurround.put(Label.LeftCenter, ChannelLabel.FRONT_CENTER_LEFT);
    AudioSampleEntry.translationSurround.put(Label.RightCenter, ChannelLabel.FRONT_CENTER_RIGHT);
    AudioSampleEntry.translationSurround.put(Label.Center, ChannelLabel.CENTER);
    AudioSampleEntry.translationSurround.put(Label.CenterSurround, ChannelLabel.REAR_CENTER);
    AudioSampleEntry.translationSurround.put(Label.CenterSurroundDirect, ChannelLabel.REAR_CENTER);
    AudioSampleEntry.translationSurround.put(Label.LeftSurround, ChannelLabel.REAR_LEFT);
    AudioSampleEntry.translationSurround.put(Label.LeftSurroundDirect, ChannelLabel.REAR_LEFT);
    AudioSampleEntry.translationSurround.put(Label.RightSurround, ChannelLabel.REAR_RIGHT);
    AudioSampleEntry.translationSurround.put(Label.RightSurroundDirect, ChannelLabel.REAR_RIGHT);
    AudioSampleEntry.translationSurround.put(Label.RearSurroundLeft, ChannelLabel.SIDE_LEFT);
    AudioSampleEntry.translationSurround.put(Label.RearSurroundRight, ChannelLabel.SIDE_RIGHT);
    AudioSampleEntry.translationSurround.put(Label.LFE2, ChannelLabel.LFE);
    AudioSampleEntry.translationSurround.put(Label.LFEScreen, ChannelLabel.LFE);
    AudioSampleEntry.translationSurround.put(Label.LeftTotal, ChannelLabel.STEREO_LEFT);
    AudioSampleEntry.translationSurround.put(Label.RightTotal, ChannelLabel.STEREO_RIGHT);
    AudioSampleEntry.translationSurround.put(Label.LeftWide, ChannelLabel.STEREO_LEFT);
    AudioSampleEntry.translationSurround.put(Label.RightWide, ChannelLabel.STEREO_RIGHT);
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Cut on ref movies
 *  
 *  @author The JCodec project
 *  
 */
var Util = function() {};
Util = stjs.extend(Util, null, [], function(constructor, prototype) {
    constructor.Pair = function(a, b) {
        this.a = a;
        this.b = b;
    };
    constructor.Pair = stjs.extend(constructor.Pair, null, [], function(constructor, prototype) {
        prototype.a = null;
        prototype.b = null;
        prototype.getA = function() {
            return this.a;
        };
        prototype.getB = function() {
            return this.b;
        };
    }, {}, {});
    constructor.splitEdits = function(edits, trackByMv, tvMv) {
        var total = 0;
        var l = new ArrayList();
        var r = new ArrayList();
        var lit = edits.listIterator();
         while (lit.hasNext()){
            var edit = lit.next();
            if (total + edit.getDuration() > tvMv) {
                var leftDurMV = (((tvMv - total)) | 0);
                var leftDurMedia = trackByMv.multiplyS(leftDurMV);
                var left = new Edit(leftDurMV, edit.getMediaTime(), 1.0);
                var right = new Edit(edit.getDuration() - leftDurMV, leftDurMedia + edit.getMediaTime(), 1.0);
                lit.remove();
                if (left.getDuration() > 0) {
                    lit.add(left);
                    l.add(left);
                }
                if (right.getDuration() > 0) {
                    lit.add(right);
                    r.add(right);
                }
                break;
            } else {
                l.add(edit);
            }
            total += edit.getDuration();
        }
         while (lit.hasNext()){
            r.add(lit.next());
        }
        return new Util.Pair(l, r);
    };
    /**
     *  Splits track on the timevalue specified
     *  
     *  @param movie
     *  @param track
     *  @param tvMv
     *  @return
     */
    constructor.split = function(movie, track, tvMv) {
        return Util.splitEdits(track.getEdits(), new Rational(track.getTimescale(), movie.getTimescale()), tvMv);
    };
    constructor.spread = function(movie, track, tvMv, durationMv) {
        var split = Util.split(movie, track, tvMv);
        track.getEdits().add(split.getA().size(), new Edit(durationMv, -1, 1.0));
    };
    constructor.shift = function(movie, track, tvMv) {
        track.getEdits().add(0, new Edit(tvMv, -1, 1.0));
    };
    constructor.getTimevalues = function(track) {
        var stts = track.getStts();
        var count = 0;
        var tts = stts.getEntries();
        for (var i = 0; i < tts.length; i++) 
            count += tts[i].getSampleCount();
        var tv = Array(count + 1);
        var k = 0;
        for (var i = 0; i < tts.length; i++) {
            for (var j = 0; j < tts[i].getSampleCount(); j++ , k++) {
                tv[k + 1] = tv[k] + tts[i].getSampleDuration();
            }
        }
        return tv;
    };
    constructor.appendToInternal = function(movie, dest, src) {
        var off = Util.appendEntries(dest, src);
        Util.appendChunkOffsets(dest, src);
        Util.appendTimeToSamples(dest, src);
        Util.appendSampleToChunk(dest, src, off);
        Util.appendSampleSizes(dest, src);
    };
    constructor.updateDuration = function(dest, src) {
        var mdhd1 = NodeBox.findFirstPath(dest, MediaHeaderBox, Box.path("mdia.mdhd"));
        var mdhd2 = NodeBox.findFirstPath(src, MediaHeaderBox, Box.path("mdia.mdhd"));
        mdhd1.setDuration(mdhd1.getDuration() + mdhd2.getDuration());
    };
    constructor.appendTo = function(movie, dest, src) {
        Util.appendToInternal(movie, dest, src);
        Util.appendEdits(dest, src, dest.getEdits().size());
        Util.updateDuration(dest, src);
    };
    constructor.insertTo = function(movie, dest, src, tvMv) {
        Util.appendToInternal(movie, dest, src);
        Util.insertEdits(movie, dest, src, tvMv);
        Util.updateDuration(dest, src);
    };
    constructor.insertEdits = function(movie, dest, src, tvMv) {
        var split = Util.split(movie, dest, tvMv);
        Util.appendEdits(dest, src, split.getA().size());
    };
    constructor.appendEdits = function(dest, src, ind) {
        for (var iterator$edit = src.getEdits().iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            edit.shift(dest.getMediaDuration());
        }
        dest.getEdits().addAllAt(ind, src.getEdits());
        dest.setEdits(dest.getEdits());
    };
    constructor.appendSampleSizes = function(trakBox1, trakBox2) {
        var stsz1 = trakBox1.getStsz();
        var stsz2 = trakBox2.getStsz();
        if (stsz1.getDefaultSize() != stsz2.getDefaultSize()) 
             throw new IllegalArgumentException("Can't append to track that has different default sample size");
        var stszr;
        if (stsz1.getDefaultSize() > 0) {
            stszr = SampleSizesBox.createSampleSizesBox(stsz1.getDefaultSize(), stsz1.getCount() + stsz2.getCount());
        } else {
            stszr = SampleSizesBox.createSampleSizesBox2(ArrayUtil.addAllInt(stsz1.getSizes(), stsz2.getSizes()));
        }
        NodeBox.findFirstPath(trakBox1, NodeBox, Box.path("mdia.minf.stbl")).replace("stsz", stszr);
    };
    constructor.appendSampleToChunk = function(trakBox1, trakBox2, off) {
        var stsc1 = trakBox1.getStsc();
        var stsc2 = trakBox2.getStsc();
        var orig = stsc2.getSampleToChunk();
        var shifted = Array(orig.length);
        for (var i = 0; i < orig.length; i++) {
            shifted[i] = new SampleToChunkBox.SampleToChunkEntry(orig[i].getFirst() + stsc1.getSampleToChunk().length, orig[i].getCount(), orig[i].getEntry() + off);
        }
        NodeBox.findFirstPath(trakBox1, NodeBox, Box.path("mdia.minf.stbl")).replace("stsc", SampleToChunkBox.createSampleToChunkBox(ArrayUtil.addAllObj(stsc1.getSampleToChunk(), shifted)));
    };
    constructor.appendEntries = function(trakBox1, trakBox2) {
        Util.appendDrefs(trakBox1, trakBox2);
        var ent1 = trakBox1.getSampleEntries();
        var ent2 = trakBox2.getSampleEntries();
        var stsd = SampleDescriptionBox.createSampleDescriptionBox(ent1);
        for (var i = 0; i < ent2.length; i++) {
            var se = ent2[i];
            se.setDrefInd((((se.getDrefInd() + ent1.length)) << 16 >> 16));
            stsd.add(se);
        }
        NodeBox.findFirstPath(trakBox1, NodeBox, Box.path("mdia.minf.stbl")).replace("stsd", stsd);
        return ent1.length;
    };
    constructor.appendDrefs = function(trakBox1, trakBox2) {
        var dref1 = NodeBox.findFirstPath(trakBox1, DataRefBox, Box.path("mdia.minf.dinf.dref"));
        var dref2 = NodeBox.findFirstPath(trakBox2, DataRefBox, Box.path("mdia.minf.dinf.dref"));
        dref1.getBoxes().addAll(dref2.getBoxes());
    };
    constructor.appendTimeToSamples = function(trakBox1, trakBox2) {
        var stts1 = trakBox1.getStts();
        var stts2 = trakBox2.getStts();
        var sttsNew = TimeToSampleBox.createTimeToSampleBox(ArrayUtil.addAllObj(stts1.getEntries(), stts2.getEntries()));
        NodeBox.findFirstPath(trakBox1, NodeBox, Box.path("mdia.minf.stbl")).replace("stts", sttsNew);
    };
    constructor.appendChunkOffsets = function(trakBox1, trakBox2) {
        var stco1 = trakBox1.getStco();
        var co641 = trakBox1.getCo64();
        var stco2 = trakBox2.getStco();
        var co642 = trakBox2.getCo64();
        var off1 = stco1 == null ? co641.getChunkOffsets() : stco1.getChunkOffsets();
        var off2 = stco2 == null ? co642.getChunkOffsets() : stco2.getChunkOffsets();
        var stbl1 = NodeBox.findFirstPath(trakBox1, NodeBox, Box.path("mdia.minf.stbl"));
        stbl1.removeChildren("stco", "co64");
        stbl1.add(co641 == null && co642 == null ? ChunkOffsetsBox.createChunkOffsetsBox(ArrayUtil.addAllLong(off1, off2)) : ChunkOffsets64Box.createChunkOffsets64Box(ArrayUtil.addAllLong(off1, off2)));
    };
    constructor.forceEditList = function(movie, trakBox) {
        var edits = trakBox.getEdits();
        if (edits == null || edits.size() == 0) {
            var mvhd = NodeBox.findFirst(movie, MovieHeaderBox, "mvhd");
            edits = new ArrayList();
            trakBox.setEdits(edits);
            edits.add(new Edit(((mvhd.getDuration()) | 0), 0, 1.0));
            trakBox.setEdits(edits);
        }
    };
    constructor.forceEditListMov = function(movie) {
        var tracks = movie.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            Util.forceEditList(movie, trakBox);
        }
    };
    constructor.editsOnEdits = function(mvByTrack, lower, higher) {
        var result = new ArrayList();
        var next = new ArrayList(lower);
        for (var iterator$edit = higher.iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            var startMv = mvByTrack.multiplyLong(edit.getMediaTime());
            var split = Util.splitEdits(next, mvByTrack.flip(), startMv);
            var split2 = Util.splitEdits(split.getB(), mvByTrack.flip(), startMv + edit.getDuration());
            result.addAll(split2.getA());
            next = split2.getB();
        }
        return result;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AACUtils = function() {};
AACUtils = stjs.extend(AACUtils, null, [], function(constructor, prototype) {
    constructor.AACMetadata = function(format, labels) {
        this.format = format;
        this.labels = labels;
    };
    constructor.AACMetadata = stjs.extend(constructor.AACMetadata, null, [], function(constructor, prototype) {
        prototype.format = null;
        prototype.labels = null;
        prototype.getFormat = function() {
            return this.format;
        };
        prototype.getLabels = function() {
            return this.labels;
        };
    }, {format: "AudioFormat", labels: "Array"}, {});
    constructor.getObjectType = function(reader) {
        var objectType = reader.readNBit(5);
        if (objectType == ObjectType.AOT_ESCAPE.ordinal()) 
            objectType = 32 + reader.readNBit(6);
        return objectType;
    };
    constructor.AAC_DEFAULT_CONFIGS = [null, [ChannelLabel.MONO], [ChannelLabel.STEREO_LEFT, ChannelLabel.STEREO_RIGHT], [ChannelLabel.CENTER, ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT], [ChannelLabel.CENTER, ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.REAR_CENTER], [ChannelLabel.CENTER, ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT], [ChannelLabel.CENTER, ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT, ChannelLabel.LFE], [ChannelLabel.CENTER, ChannelLabel.FRONT_LEFT, ChannelLabel.FRONT_RIGHT, ChannelLabel.SIDE_LEFT, ChannelLabel.SIDE_RIGHT, ChannelLabel.REAR_LEFT, ChannelLabel.REAR_RIGHT, ChannelLabel.LFE]];
    constructor.parseAudioInfo = function(privData) {
        var reader = BitReader.createBitReader(privData);
        var objectType = AACUtils.getObjectType(reader);
        var index = reader.readNBit(4);
        var sampleRate = index == 15 ? reader.readNBit(24) : AACConts.AAC_SAMPLE_RATES[index];
        var channelConfig = reader.readNBit(4);
        if (channelConfig == 0 || channelConfig >= AACUtils.AAC_DEFAULT_CONFIGS.length) 
            return null;
        var channels = AACUtils.AAC_DEFAULT_CONFIGS[channelConfig];
        return new AACUtils.AACMetadata(new AudioFormat(sampleRate, 16, channels.length, true, false), channels);
    };
    constructor.getMetadata = function(mp4a) {
        if (!"mp4a".equals(mp4a.getFourcc())) 
             throw new IllegalArgumentException("Not mp4a sample entry");
        var b = AACUtils.getCodecPrivate(mp4a);
        if (b == null) 
            return null;
        return AACUtils.parseAudioInfo(b);
    };
    constructor.getCodecPrivate = function(mp4a) {
        var b = NodeBox.findFirst(mp4a, Box.LeafBox, "esds");
        if (b == null) {
            b = NodeBox.findFirstPath(mp4a, Box.LeafBox, [null, "esds"]);
        }
        if (b == null) 
            return null;
        var esds = BoxUtil.as(EsdsBox, b);
        return esds.getStreamInfo();
    };
    constructor.streamInfoToADTS = function(si, crcAbsent, numAACFrames, frameSize) {
        var rd = BitReader.createBitReader(si.duplicate());
        var objectType = rd.readNBit(5);
        var samplingIndex = rd.readNBit(4);
        var chanConfig = rd.readNBit(4);
        return new ADTSParser.Header(objectType, chanConfig, crcAbsent ? 1 : 0, numAACFrames, samplingIndex, 7 + frameSize);
    };
}, {AAC_DEFAULT_CONFIGS: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MetaBox = function(atom) {
    NodeBox.call(this, atom);
};
MetaBox = stjs.extend(MetaBox, NodeBox, [], function(constructor, prototype) {
    constructor.FOURCC = "meta";
    constructor.createMetaBox = function() {
        return new MetaBox(Header.createHeader(MetaBox.fourcc(), 0));
    };
    prototype.getKeyedMeta = function() {
        var result = new LinkedHashMap();
        var ilst = NodeBox.findFirst(this, IListBox, IListBox.fourcc());
        var keys = NodeBox.findAllPath(this, MdtaBox, [KeysBox.fourcc(), MdtaBox.fourcc()]);
        if (ilst == null || keys.length == 0) 
            return result;
        for (var iterator$entry = ilst.getValues().entrySet().iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            var index = entry.getKey();
            if (index == null) 
                continue;
            var db = this.getDataBox(entry.getValue());
            if (db == null) 
                continue;
            var value = MetaValue.createOtherWithLocale(db.getType(), db.getLocale(), db.getData());
            if (index > 0 && index <= keys.length) {
                result.put(keys[index - 1].getKey(), value);
            }
        }
        return result;
    };
    prototype.getDataBox = function(value) {
        for (var iterator$box = value.iterator(); iterator$box.hasNext(); ) {
            var box = iterator$box.next();
            if (stjs.isInstanceOf(box.constructor, DataBox)) {
                return box;
            }
        }
        return null;
    };
    prototype.getItunesMeta = function() {
        var result = new LinkedHashMap();
        var ilst = NodeBox.findFirst(this, IListBox, IListBox.fourcc());
        if (ilst == null) 
            return result;
        for (var iterator$entry = ilst.getValues().entrySet().iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            var index = entry.getKey();
            if (index == null) 
                continue;
            var db = this.getDataBox(entry.getValue());
            if (db == null) 
                continue;
            var value = MetaValue.createOtherWithLocale(db.getType(), db.getLocale(), db.getData());
            result.put(index, value);
        }
        return result;
    };
    prototype.setKeyedMeta = function(map) {
        if (map.isEmpty()) 
            return;
        var keys = KeysBox.createKeysBox();
        var data = new LinkedHashMap();
        var i = 1;
        for (var iterator$entry = map.entrySet().iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            keys.add(MdtaBox.createMdtaBox(entry.getKey()));
            var v = entry.getValue();
            var children = new ArrayList();
            children.add(DataBox.createDataBox(v.getType(), v.getLocale(), v.getData()));
            data.put(i, children);
            ++i;
        }
        var ilst = IListBox.createIListBox(data);
        this.replaceBox(keys);
        this.replaceBox(ilst);
    };
    prototype.setItunesMeta = function(map) {
        if (map.isEmpty()) 
            return;
        var copy = new LinkedHashMap();
        copy.putAll(map);
        var ilst = NodeBox.findFirst(this, IListBox, IListBox.fourcc());
        var data;
        if (ilst == null) {
            data = new LinkedHashMap();
        } else {
            data = ilst.getValues();
            for (var iterator$entry = data.entrySet().iterator(); iterator$entry.hasNext(); ) {
                var entry = iterator$entry.next();
                var index = entry.getKey();
                var v = copy.get(index);
                if (v != null) {
                    var dataBox = DataBox.createDataBox(v.getType(), v.getLocale(), v.getData());
                    this.dropChildBox(entry.getValue(), DataBox.fourcc());
                    entry.getValue().add(dataBox);
                    copy.remove(index);
                }
            }
        }
        for (var iterator$entry = copy.entrySet().iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            var index = entry.getKey();
            var v = entry.getValue();
            var dataBox = DataBox.createDataBox(v.getType(), v.getLocale(), v.getData());
            var children = new ArrayList();
            data.put(index, children);
            children.add(dataBox);
        }
        var keySet = new HashSet(data.keySet());
        keySet.removeAll(map.keySet());
        for (var iterator$dropped = keySet.iterator(); iterator$dropped.hasNext(); ) {
            var dropped = iterator$dropped.next();
            data.remove(dropped);
        }
        this.replaceBox(IListBox.createIListBox(data));
    };
    prototype.dropChildBox = function(children, fourcc2) {
        var listIterator = children.listIterator();
         while (listIterator.hasNext()){
            var next = listIterator.next();
            if (fourcc2.equals(next.getFourcc())) {
                listIterator.remove();
            }
        }
    };
    constructor.fourcc = function() {
        return MetaBox.FOURCC;
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var ICStream = function(frameLength) {
    this.frameLength = frameLength;
    this.info = new ICSInfo(frameLength);
    this.sfbCB = new Int32Array(SyntaxConstants.MAX_SECTIONS);
    this.sectEnd = new Int32Array(SyntaxConstants.MAX_SECTIONS);
    this.data = new Float32Array(frameLength);
    this.scaleFactors = new Float32Array(SyntaxConstants.MAX_SECTIONS);
};
ICStream = stjs.extend(ICStream, null, [SyntaxConstants, HCB, ScaleFactorTable, IQTable], function(constructor, prototype) {
    constructor.SF_DELTA = 60;
    constructor.SF_OFFSET = 200;
    constructor.randomState = 523124044;
    prototype.frameLength = 0;
    prototype.info = null;
    prototype.sfbCB = null;
    prototype.sectEnd = null;
    prototype.data = null;
    prototype.scaleFactors = null;
    prototype.globalGain = 0;
    prototype.pulseDataPresent = false;
    prototype.tnsDataPresent = false;
    prototype.gainControlPresent = false;
    prototype.tns = null;
    prototype.gainControl = null;
    prototype.pulseOffset = null;
    prototype.pulseAmp = null;
    prototype.pulseCount = 0;
    prototype.pulseStartSWB = 0;
    prototype.noiseUsed = false;
    prototype.reorderedSpectralDataLen = 0;
    prototype.longestCodewordLen = 0;
    prototype.rvlc = null;
    prototype.decode = function(_in, commonWindow, conf) {
        if (conf.isScalefactorResilienceUsed() && this.rvlc == null) 
            this.rvlc = new RVLC();
        var er = conf.getProfile().isErrorResilientProfile();
        this.globalGain = _in.readBits(8);
        if (!commonWindow) 
            this.info.decode(_in, conf, commonWindow);
        this.decodeSectionData(_in, conf.isSectionDataResilienceUsed());
        this.decodeScaleFactors(_in);
        this.pulseDataPresent = _in.readBool();
        if (this.pulseDataPresent) {
            if (this.info.isEightShortFrame()) 
                 throw new AACException("pulse data not allowed for short frames");
            Logger.debug("PULSE");
            this.decodePulseData(_in);
        }
        this.tnsDataPresent = _in.readBool();
        if (this.tnsDataPresent && !er) {
            if (this.tns == null) 
                this.tns = new TNS();
            this.tns.decode(_in, this.info);
        }
        this.gainControlPresent = _in.readBool();
        if (this.gainControlPresent) {
            if (this.gainControl == null) 
                this.gainControl = new GainControl(this.frameLength);
            Logger.debug("GAIN");
            this.gainControl.decode(_in, this.info.getWindowSequence());
        }
        if (conf.isSpectralDataResilienceUsed()) {
            var max = (conf.getChannelConfiguration() == ChannelConfiguration.CHANNEL_CONFIG_STEREO) ? 6144 : 12288;
            this.reorderedSpectralDataLen = Math.max(_in.readBits(14), max);
            this.longestCodewordLen = Math.max(_in.readBits(6), 49);
        } else 
            this.decodeSpectralData(_in);
    };
    prototype.decodeSectionData = function(_in, sectionDataResilienceUsed) {
        Arrays.fill(this.sfbCB, 0);
        Arrays.fill(this.sectEnd, 0);
        var bits = this.info.isEightShortFrame() ? 3 : 5;
        var escVal = (1 << bits) - 1;
        var windowGroupCount = this.info.getWindowGroupCount();
        var maxSFB = this.info.getMaxSFB();
        var end, cb, incr;
        var idx = 0;
        for (var g = 0; g < windowGroupCount; g++) {
            var k = 0;
             while (k < maxSFB){
                end = k;
                cb = _in.readBits(4);
                if (cb == 12) 
                     throw new AACException("invalid huffman codebook: 12");
                 while ((incr = _in.readBits(bits)) == escVal){
                    end += incr;
                }
                end += incr;
                if (end > maxSFB) 
                     throw new AACException("too many bands: " + end + ", allowed: " + maxSFB);
                for (; k < end; k++) {
                    this.sfbCB[idx] = cb;
                    this.sectEnd[idx++] = end;
                }
            }
        }
    };
    prototype.decodePulseData = function(_in) {
        this.pulseCount = _in.readBits(2) + 1;
        this.pulseStartSWB = _in.readBits(6);
        if (this.pulseStartSWB >= this.info.getSWBCount()) 
             throw new AACException("pulse SWB out of range: " + this.pulseStartSWB + " > " + this.info.getSWBCount());
        if (this.pulseOffset == null || this.pulseCount != this.pulseOffset.length) {
            this.pulseOffset = new Int32Array(this.pulseCount);
            this.pulseAmp = new Int32Array(this.pulseCount);
        }
        this.pulseOffset[0] = this.info.getSWBOffsets()[this.pulseStartSWB];
        this.pulseOffset[0] += _in.readBits(5);
        this.pulseAmp[0] = _in.readBits(4);
        for (var i = 1; i < this.pulseCount; i++) {
            this.pulseOffset[i] = _in.readBits(5) + this.pulseOffset[i - 1];
            if (this.pulseOffset[i] > 1023) 
                 throw new AACException("pulse offset out of range: " + this.pulseOffset[0]);
            this.pulseAmp[i] = _in.readBits(4);
        }
    };
    prototype.decodeScaleFactors = function(_in) {
        var windowGroups = this.info.getWindowGroupCount();
        var maxSFB = this.info.getMaxSFB();
        var offset = new Int32Array([this.globalGain, this.globalGain - 90, 0]);
        var tmp;
        var noiseFlag = true;
        var sfb, idx = 0;
        for (var g = 0; g < windowGroups; g++) {
            for (sfb = 0; sfb < maxSFB; ) {
                var end = this.sectEnd[idx];
                switch (this.sfbCB[idx]) {
                    case HCB.ZERO_HCB:
                        for (; sfb < end; sfb++ , idx++) {
                            this.scaleFactors[idx] = 0;
                        }
                        break;
                    case HCB.INTENSITY_HCB:
                    case HCB.INTENSITY_HCB2:
                        for (; sfb < end; sfb++ , idx++) {
                            offset[2] += Huffman.decodeScaleFactor(_in) - ICStream.SF_DELTA;
                            tmp = Math.min(Math.max(offset[2], -155), 100);
                            this.scaleFactors[idx] = ScaleFactorTable.SCALEFACTOR_TABLE[-tmp + ICStream.SF_OFFSET];
                        }
                        break;
                    case HCB.NOISE_HCB:
                        for (; sfb < end; sfb++ , idx++) {
                            if (noiseFlag) {
                                offset[1] += _in.readBits(9) - 256;
                                noiseFlag = false;
                            } else 
                                offset[1] += Huffman.decodeScaleFactor(_in) - ICStream.SF_DELTA;
                            tmp = Math.min(Math.max(offset[1], -100), 155);
                            this.scaleFactors[idx] = -ScaleFactorTable.SCALEFACTOR_TABLE[tmp + ICStream.SF_OFFSET];
                        }
                        break;
                    default:
                        for (; sfb < end; sfb++ , idx++) {
                            offset[0] += Huffman.decodeScaleFactor(_in) - ICStream.SF_DELTA;
                            if (offset[0] > 255) 
                                 throw new AACException("scalefactor out of range: " + offset[0]);
                            this.scaleFactors[idx] = ScaleFactorTable.SCALEFACTOR_TABLE[offset[0] - 100 + ICStream.SF_OFFSET];
                        }
                        break;
                }
            }
        }
    };
    prototype.decodeSpectralData = function(_in) {
        Arrays.fill(this.data, 0);
        var maxSFB = this.info.getMaxSFB();
        var windowGroups = this.info.getWindowGroupCount();
        var offsets = this.info.getSWBOffsets();
        var buf = new Int32Array(4);
        var sfb, j, k, w, hcb, off, width, num;
        var groupOff = 0, idx = 0;
        for (var g = 0; g < windowGroups; g++) {
            var groupLen = this.info.getWindowGroupLength(g);
            for (sfb = 0; sfb < maxSFB; sfb++ , idx++) {
                hcb = this.sfbCB[idx];
                off = groupOff + offsets[sfb];
                width = offsets[sfb + 1] - offsets[sfb];
                if (hcb == HCB.ZERO_HCB || hcb == HCB.INTENSITY_HCB || hcb == HCB.INTENSITY_HCB2) {
                    for (w = 0; w < groupLen; w++ , off += 128) {
                        Arrays.fillRange(this.data, off, off + width, 0);
                    }
                } else if (hcb == HCB.NOISE_HCB) {
                    for (w = 0; w < groupLen; w++ , off += 128) {
                        var energy = 0;
                        for (k = 0; k < width; k++) {
                            ICStream.randomState *= 1664525 + 1013904223;
                            this.data[off + k] = ICStream.randomState;
                            energy += this.data[off + k] * this.data[off + k];
                        }
                        var scale = (this.scaleFactors[idx] / Math.sqrt(energy));
                        for (k = 0; k < width; k++) {
                            this.data[off + k] *= scale;
                        }
                    }
                } else {
                    for (w = 0; w < groupLen; w++ , off += 128) {
                        num = (hcb >= HCB.FIRST_PAIR_HCB) ? 2 : 4;
                        for (k = 0; k < width; k += num) {
                            Huffman.decodeSpectralData(_in, hcb, buf, 0);
                            for (j = 0; j < num; j++) {
                                this.data[off + k + j] = (buf[j] > 0) ? IQTable.IQ_TABLE[buf[j]] : -IQTable.IQ_TABLE[-buf[j]];
                                this.data[off + k + j] *= this.scaleFactors[idx];
                            }
                        }
                    }
                }
            }
            groupOff += groupLen << 7;
        }
    };
    /**
     *  Does inverse quantization and applies the scale factors on the decoded
     *  data. After this the noiseless decoding is finished and the decoded data
     *  is returned.
     *  @return the inverse quantized and scaled data
     */
    prototype.getInvQuantData = function() {
        return this.data;
    };
    prototype.getInfo = function() {
        return this.info;
    };
    prototype.getSectEnd = function() {
        return this.sectEnd;
    };
    prototype.getSfbCB = function() {
        return this.sfbCB;
    };
    prototype.getScaleFactors = function() {
        return this.scaleFactors;
    };
    prototype.isTNSDataPresent = function() {
        return this.tnsDataPresent;
    };
    prototype.getTNS = function() {
        return this.tns;
    };
    prototype.getGlobalGain = function() {
        return this.globalGain;
    };
    prototype.isNoiseUsed = function() {
        return this.noiseUsed;
    };
    prototype.getLongestCodewordLength = function() {
        return this.longestCodewordLen;
    };
    prototype.getReorderedSpectralDataLength = function() {
        return this.reorderedSpectralDataLen;
    };
    prototype.isGainControlPresent = function() {
        return this.gainControlPresent;
    };
    prototype.getGainControl = function() {
        return this.gainControl;
    };
}, {info: "ICSInfo", sfbCB: "Int32Array", sectEnd: "Int32Array", data: "Float32Array", scaleFactors: "Float32Array", tns: "TNS", gainControl: "GainControl", pulseOffset: "Int32Array", pulseAmp: "Int32Array", rvlc: "RVLC", SCALEFACTOR_TABLE: "Float32Array", IQ_TABLE: "Float32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MPEG2VideoDescriptor = function(ul) {
    CDCIEssenceDescriptor.call(this, ul);
};
MPEG2VideoDescriptor = stjs.extend(MPEG2VideoDescriptor, CDCIEssenceDescriptor, [], function(constructor, prototype) {
    prototype.singleSequence = 0;
    prototype.constantBFrames = 0;
    prototype.codedContentType = 0;
    prototype.lowDelay = 0;
    prototype.closedGOP = 0;
    prototype.identicalGOP = 0;
    prototype.maxGOP = 0;
    prototype.bPictureCount = 0;
    prototype.bitRate = 0;
    prototype.profileAndLevel = 0;
    prototype.read = function(tags) {
        CDCIEssenceDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 32768:
                    this.singleSequence = _bb.get();
                    break;
                case 32769:
                    this.constantBFrames = _bb.get();
                    break;
                case 32770:
                    this.codedContentType = _bb.get();
                    break;
                case 32771:
                    this.lowDelay = _bb.get();
                    break;
                case 32772:
                    this.closedGOP = _bb.get();
                    break;
                case 32773:
                    this.identicalGOP = _bb.get();
                    break;
                case 32774:
                    this.maxGOP = _bb.getShort();
                    break;
                case 32775:
                    this.bPictureCount = (((_bb.get() & 255)) << 16 >> 16);
                    break;
                case 32776:
                    this.bitRate = _bb.getInt();
                    break;
                case 32777:
                    this.profileAndLevel = _bb.get();
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x + (" + _bb.remaining() + ")", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getSingleSequence = function() {
        return this.singleSequence;
    };
    prototype.getConstantBFrames = function() {
        return this.constantBFrames;
    };
    prototype.getCodedContentType = function() {
        return this.codedContentType;
    };
    prototype.getLowDelay = function() {
        return this.lowDelay;
    };
    prototype.getClosedGOP = function() {
        return this.closedGOP;
    };
    prototype.getIdenticalGOP = function() {
        return this.identicalGOP;
    };
    prototype.getMaxGOP = function() {
        return this.maxGOP;
    };
    prototype.getbPictureCount = function() {
        return this.bPictureCount;
    };
    prototype.getBitRate = function() {
        return this.bitRate;
    };
    prototype.getProfileAndLevel = function() {
        return this.profileAndLevel;
    };
}, {frameLayout: {name: "Enum", arguments: ["GenericPictureEssenceDescriptor.LayoutType"]}, aspectRatio: "Rational", videoLineMap: "Int32Array", transferCharacteristic: "UL", pictureEssenceCoding: "UL", codingEquations: "UL", colorPrimaries: "UL", sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AES3PCMDescriptor = function(ul) {
    WaveAudioDescriptor.call(this, ul);
};
AES3PCMDescriptor = stjs.extend(AES3PCMDescriptor, WaveAudioDescriptor, [], function(constructor, prototype) {
    prototype.emphasis = 0;
    prototype.blockStartOffset = 0;
    prototype.auxBitsMode = 0;
    prototype.channelStatusMode = null;
    prototype.fixedChannelStatusData = null;
    prototype.userDataMode = null;
    prototype.fixedUserData = null;
    prototype.read = function(tags) {
        WaveAudioDescriptor.prototype.read.call(this, tags);
        for (var it = tags.entrySet().iterator(); it.hasNext(); ) {
            var entry = it.next();
            var _bb = entry.getValue();
            switch (entry.getKey()) {
                case 15629:
                    this.emphasis = _bb.get();
                    break;
                case 15631:
                    this.blockStartOffset = _bb.getShort();
                    break;
                case 15624:
                    this.auxBitsMode = _bb.get();
                    break;
                case 15632:
                    this.channelStatusMode = _bb;
                    break;
                case 15633:
                    this.fixedChannelStatusData = _bb;
                    break;
                case 15634:
                    this.userDataMode = _bb;
                    break;
                case 15635:
                    this.fixedUserData = _bb;
                    break;
                default:
                    Logger.warn(String.format("Unknown tag [ " + this.ul + "]: %04x", entry.getKey()));
                    continue;
            }
            it.remove();
        }
    };
    prototype.getEmphasis = function() {
        return this.emphasis;
    };
    prototype.getBlockStartOffset = function() {
        return this.blockStartOffset;
    };
    prototype.getAuxBitsMode = function() {
        return this.auxBitsMode;
    };
    prototype.getChannelStatusMode = function() {
        return this.channelStatusMode;
    };
    prototype.getFixedChannelStatusData = function() {
        return this.fixedChannelStatusData;
    };
    prototype.getUserDataMode = function() {
        return this.userDataMode;
    };
    prototype.getFixedUserData = function() {
        return this.fixedUserData;
    };
}, {channelStatusMode: "ByteBuffer", fixedChannelStatusData: "ByteBuffer", userDataMode: "ByteBuffer", fixedUserData: "ByteBuffer", channelAssignment: "UL", peakOfPeaksPosition: "ByteBuffer", peakEnvelopeTimestamp: "ByteBuffer", peakEnvelopeData: "ByteBuffer", audioSamplingRate: "Rational", soundEssenceCompression: "UL", sampleRate: "Rational", essenceContainer: "UL", codec: "UL", locators: "Array", subDescriptors: "Array", generationUID: "UL", objectClass: "UL", ul: "UL", uid: "UL"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Movie fragment box and dedicated routines
 *  
 *  @author The JCodec project
 *  
 */
var MovieFragmentBox = function(atom) {
    NodeBox.call(this, atom);
};
MovieFragmentBox = stjs.extend(MovieFragmentBox, NodeBox, [], function(constructor, prototype) {
    prototype.moov = null;
    constructor.fourcc = function() {
        return "moof";
    };
    prototype.getMovie = function() {
        return this.moov;
    };
    prototype.setMovie = function(moov) {
        this.moov = moov;
    };
    prototype.getTracks = function() {
        return NodeBox.findAll(this, TrackFragmentBox, TrackFragmentBox.fourcc());
    };
    prototype.getSequenceNumber = function() {
        var mfhd = NodeBox.findFirst(this, MovieFragmentHeaderBox, MovieFragmentHeaderBox.fourcc());
        if (mfhd == null) 
             throw new RuntimeException("Corrupt movie fragment, no header atom found");
        return mfhd.getSequenceNumber();
    };
    constructor.createMovieFragmentBox = function() {
        return new MovieFragmentBox(new Header(MovieFragmentBox.fourcc()));
    };
}, {moov: "MovieBox", boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ChunkWriter = function(trak, inputs, out) {
    this.buf = new Int8Array(8092);
    this.entries = trak.getSampleEntries();
    var stco = trak.getStco();
    var co64 = trak.getCo64();
    var size;
    if (stco != null) 
        size = stco.getChunkOffsets().length;
     else 
        size = co64.getChunkOffsets().length;
    this.inputs = inputs;
    this.offsets = Array(size);
    this.out = out;
    this.trak = trak;
};
ChunkWriter = stjs.extend(ChunkWriter, null, [], function(constructor, prototype) {
    prototype.offsets = null;
    prototype.entries = null;
    prototype.inputs = null;
    prototype.curChunk = 0;
    prototype.out = null;
    prototype.buf = null;
    prototype.trak = null;
    prototype.apply = function() {
        var stbl = NodeBox.findFirstPath(this.trak, NodeBox, Box.path("mdia.minf.stbl"));
        stbl.removeChildren("stco", "co64");
        stbl.add(ChunkOffsets64Box.createChunkOffsets64Box(this.offsets));
        this.cleanDrefs(this.trak);
    };
    prototype.cleanDrefs = function(trak) {
        var minf = trak.getMdia().getMinf();
        var dinf = trak.getMdia().getMinf().getDinf();
        if (dinf == null) {
            dinf = DataInfoBox.createDataInfoBox();
            minf.add(dinf);
        }
        var dref = dinf.getDref();
        if (dref == null) {
            dref = DataRefBox.createDataRefBox();
            dinf.add(dref);
        }
        dref.getBoxes().clear();
        dref.add(AliasBox.createSelfRef());
        var sampleEntries = trak.getSampleEntries();
        for (var i = 0; i < sampleEntries.length; i++) {
            var entry = sampleEntries[i];
            entry.setDrefInd(((1) << 16 >> 16));
        }
    };
    prototype.getInput = function(chunk) {
        var se = this.entries[chunk.getEntry() - 1];
        return this.inputs[se.getDrefInd() - 1];
    };
    prototype.write = function(chunk) {
        var input = this.getInput(chunk);
        input.setPosition(chunk.getOffset());
        var pos = this.out.position();
        this.out.write(NIOUtils.fetchFromChannel(input, ((chunk.getSize()) | 0)));
        this.offsets[this.curChunk++] = pos;
    };
}, {offsets: "Array", entries: "Array", inputs: "Array", out: "SeekableByteChannel", buf: "Int8Array", trak: "TrakBox"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Creates MP4 file out of a set of samples
 *  
 *  @author The JCodec project
 *  
 */
var MediaInfoBox = function(atom) {
    NodeBox.call(this, atom);
};
MediaInfoBox = stjs.extend(MediaInfoBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "minf";
    };
    constructor.createMediaInfoBox = function() {
        return new MediaInfoBox(new Header(MediaInfoBox.fourcc()));
    };
    prototype.getDinf = function() {
        return NodeBox.findFirst(this, DataInfoBox, "dinf");
    };
    prototype.getStbl = function() {
        return NodeBox.findFirst(this, NodeBox, "stbl");
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var AbstractMP4MuxerTrack = function(trackId, type) {
    this.curChunk = new ArrayList();
    this.samplesInChunks = new ArrayList();
    this.sampleEntries = new ArrayList();
    this.trackId = trackId;
    this.type = type;
    this._timescale = AbstractMP4MuxerTrack.NO_TIMESCALE_SET;
};
AbstractMP4MuxerTrack = stjs.extend(AbstractMP4MuxerTrack, null, [MuxerTrack], function(constructor, prototype) {
    constructor.NO_TIMESCALE_SET = -1;
    prototype.trackId = 0;
    prototype.type = null;
    prototype._timescale = 0;
    prototype.tgtChunkDuration = null;
    prototype.tgtChunkDurationUnit = null;
    prototype.chunkDuration = 0;
    prototype.curChunk = null;
    prototype.samplesInChunks = null;
    prototype.samplesInLastChunk = -1;
    prototype.chunkNo = 0;
    prototype.finished = false;
    prototype.sampleEntries = null;
    prototype.edits = null;
    prototype.name = null;
    prototype.out = null;
    prototype.setOut = function(out) {
        this.out = out;
        return this;
    };
    prototype.setTgtChunkDuration = function(duration, unit) {
        this.tgtChunkDuration = duration;
        this.tgtChunkDurationUnit = unit;
    };
    prototype.getTrackTotalDuration = function() {};
    prototype.finish = function(mvhd) {};
    prototype.isVideo = function() {
        return this.type == MP4TrackType.VIDEO;
    };
    prototype.isTimecode = function() {
        return this.type == MP4TrackType.TIMECODE;
    };
    prototype.isAudio = function() {
        return this.type == MP4TrackType.SOUND;
    };
    prototype.getType = function() {
        return this.type;
    };
    prototype.getTrackId = function() {
        return this.trackId;
    };
    prototype.getDisplayDimensions = function() {
        var width = 0, height = 0;
        if (this.sampleEntries != null && !this.sampleEntries.isEmpty() && stjs.isInstanceOf(this.sampleEntries.get(0).constructor, VideoSampleEntry)) {
            var vse = this.sampleEntries.get(0);
            var paspBox = NodeBox.findFirst(vse, PixelAspectExt, PixelAspectExt.fourcc());
            var pasp = paspBox != null ? paspBox.getRational() : new Rational(1, 1);
            width = stjs.trunc(pasp.getNum() * vse.getWidth() / pasp.getDen());
            height = vse.getHeight();
        }
        return new Size(width, height);
    };
    prototype.tapt = function(trak) {
        var dd = this.getDisplayDimensions();
        if (this.type == MP4TrackType.VIDEO) {
            var tapt = new NodeBox(new Header("tapt"));
            tapt.add(ClearApertureBox.createClearApertureBox(dd.getWidth(), dd.getHeight()));
            tapt.add(ProductionApertureBox.createProductionApertureBox(dd.getWidth(), dd.getHeight()));
            tapt.add(EncodedPixelBox.createEncodedPixelBox(dd.getWidth(), dd.getHeight()));
            trak.add(tapt);
        }
    };
    prototype.addSampleEntry = function(se) {
        Preconditions.checkState(!this.finished, "The muxer track has finished muxing");
        this.sampleEntries.add(se);
        return this;
    };
    prototype.getEntries = function() {
        return this.sampleEntries;
    };
    prototype.setEdits = function(edits) {
        this.edits = edits;
    };
    prototype.putEdits = function(trak) {
        if (this.edits != null) {
            var edts = new NodeBox(new Header("edts"));
            edts.add(EditListBox.createEditListBox(this.edits));
            trak.add(edts);
        }
    };
    prototype.setName = function(name) {
        this.name = name;
    };
    prototype.putName = function(trak) {
        if (this.name != null) {
            var udta = new NodeBox(new Header("udta"));
            udta.add(NameBox.createNameBox(this.name));
            trak.add(udta);
        }
    };
    prototype.mediaHeader = function(minf, type) {
        if (MP4TrackType.VIDEO == type) {
            var vmhd = VideoMediaHeaderBox.createVideoMediaHeaderBox(0, 0, 0, 0);
            vmhd.setFlags(1);
            minf.add(vmhd);
        } else if (MP4TrackType.SOUND == type) {
            var smhd = SoundMediaHeaderBox.createSoundMediaHeaderBox();
            smhd.setFlags(1);
            minf.add(smhd);
        } else if (MP4TrackType.TIMECODE == type) {
            var gmhd = new NodeBox(new Header("gmhd"));
            gmhd.add(GenericMediaInfoBox.createGenericMediaInfoBox());
            var tmcd = new NodeBox(new Header("tmcd"));
            gmhd.add(tmcd);
            tmcd.add(TimecodeMediaInfoBox.createTimecodeMediaInfoBox(((0) << 16 >> 16), ((0) << 16 >> 16), ((12) << 16 >> 16), new Int16Array([0, 0, 0]), new Int16Array([255, 255, 255]), "Lucida Grande"));
            minf.add(gmhd);
        } else if (MP4TrackType.DATA == type) {} else {
             throw new UnhandledStateException("Handler " + type.getHandler() + " not supported");
        }
    };
    prototype.addDref = function(minf) {
        var dinf = DataInfoBox.createDataInfoBox();
        minf.add(dinf);
        var dref = DataRefBox.createDataRefBox();
        dinf.add(dref);
        dref.add(Box.LeafBox.createLeafBox(Header.createHeader("alis", 0), ByteBuffer.wrap(new Int8Array([0, 0, 0, 1]))));
    };
    prototype.getTimescale = function() {
        return this._timescale;
    };
}, {type: "MP4TrackType", tgtChunkDuration: "Rational", tgtChunkDurationUnit: {name: "Enum", arguments: ["Unit"]}, curChunk: {name: "List", arguments: ["ByteBuffer"]}, samplesInChunks: {name: "List", arguments: ["SampleToChunkBox.SampleToChunkEntry"]}, sampleEntries: {name: "List", arguments: ["SampleEntry"]}, edits: {name: "List", arguments: ["Edit"]}, out: "SeekableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var H264Utils = function() {};
H264Utils = stjs.extend(H264Utils, null, [], function(constructor, prototype) {
    constructor.nextNALUnit = function(buf) {
        H264Utils.skipToNALUnit(buf);
        if (buf.hasArray()) 
            return H264Utils.gotoNALUnitWithArray(buf);
         else 
            return H264Utils.gotoNALUnit(buf);
    };
    constructor.skipToNALUnit = function(buf) {
        if (!buf.hasRemaining()) 
            return;
        var val = -1;
         while (buf.hasRemaining()){
            val <<= 8;
            val |= (buf.get() & 255);
            if ((val & 16777215) == 1) {
                buf.setPosition(buf.position());
                break;
            }
        }
    };
    /**
     *  Finds next Nth H.264 bitstream NAL unit (0x00000001) and returns the data
     *  that preceeds it as a ByteBuffer slice
     *  
     *  Segment byte order is always little endian
     *  
     *  TODO: emulation prevention
     *  
     *  @param buf
     *  @return
     */
    constructor.gotoNALUnit = function(buf) {
        if (!buf.hasRemaining()) 
            return null;
        var from = buf.position();
        var result = buf.slice();
        result.order(ByteOrder.BIG_ENDIAN);
        var val = -1;
         while (buf.hasRemaining()){
            val <<= 8;
            val |= (buf.get() & 255);
            if ((val & 16777215) == 1) {
                buf.setPosition(buf.position() - (val == 1 ? 4 : 3));
                result.setLimit(buf.position() - from);
                break;
            }
        }
        return result;
    };
    /**
     *  Finds next Nth H.264 bitstream NAL unit (0x00000001) and returns the data
     *  that preceeds it as a ByteBuffer slice
     * 
     *  Segment byte order is always little endian
     * 
     *  @param buf
     *  @return data
     */
    constructor.gotoNALUnitWithArray = function(buf) {
        if (!buf.hasRemaining()) 
            return null;
        var from = buf.position();
        var result = buf.slice();
        result.order(ByteOrder.BIG_ENDIAN);
        var arr = buf.array();
        var pos = from + buf.arrayOffset();
        var posFrom = pos;
        var lim = buf.limit() + buf.arrayOffset();
         while (pos < lim){
            var b = arr[pos];
            if ((b & 254) == 0) {
                 while (b == 0 && ++pos < lim)
                    b = arr[pos];
                if (b == 1) {
                    if (pos - posFrom >= 2 && arr[pos - 1] == 0 && arr[pos - 2] == 0) {
                        var lenSize = (pos - posFrom >= 3 && arr[pos - 3] == 0) ? 4 : 3;
                        buf.setPosition(pos + 1 - buf.arrayOffset() - lenSize);
                        result.setLimit(buf.position() - from);
                        return result;
                    }
                }
            }
            pos += 3;
        }
        buf.setPosition(buf.limit());
        return result;
    };
    constructor.unescapeNAL = function(_buf) {
        if (_buf.remaining() < 2) 
            return;
        var _in = _buf.duplicate();
        var out = _buf.duplicate();
        var p1 = _in.get();
        out.put(p1);
        var p2 = _in.get();
        out.put(p2);
         while (_in.hasRemaining()){
            var b = _in.get();
            if (p1 != 0 || p2 != 0 || b != 3) 
                out.put(b);
            p1 = p2;
            p2 = b;
        }
        _buf.setLimit(out.position());
    };
    constructor.escapeNALinplace = function(src) {
        var loc = H264Utils.searchEscapeLocations(src);
        var old = src.limit();
        src.setLimit(src.limit() + loc.length);
        for (var newPos = src.limit() - 1, oldPos = old - 1, locIdx = loc.length - 1; newPos >= src.position(); newPos-- , oldPos--) {
            src.putAt(newPos, src.getAt(oldPos));
            if (locIdx >= 0 && loc[locIdx] == oldPos) {
                newPos--;
                src.putAt(newPos, (3 << 24 >> 24));
                locIdx--;
            }
        }
    };
    constructor.searchEscapeLocations = function(src) {
        var points = IntArrayList.createIntArrayList();
        var search = src.duplicate();
        var p = search.getShort();
         while (search.hasRemaining()){
            var b = search.get();
            if (p == 0 && (b & ~3) == 0) {
                points.add(search.position() - 1);
                p = 3;
            }
            p <<= 8;
            p |= b & 255;
        }
        var array = points.toArray();
        return array;
    };
    constructor.escapeNAL = function(src, dst) {
        var p1 = src.get(), p2 = src.get();
        dst.put(p1);
        dst.put(p2);
         while (src.hasRemaining()){
            var b = src.get();
            if (p1 == 0 && p2 == 0 && (b & 255) <= 3) {
                dst.put((3 << 24 >> 24));
                p1 = p2;
                p2 = 3;
            }
            dst.put(b);
            p1 = p2;
            p2 = b;
        }
    };
    constructor.splitMOVPacket = function(buf, avcC) {
        var result = new ArrayList();
        var nls = avcC.getNalLengthSize();
        var dup = buf.duplicate();
         while (dup.remaining() >= nls){
            var len = H264Utils.readLen(dup, nls);
            if (len == 0) 
                break;
            result.add(NIOUtils.read(dup, len));
        }
        return result;
    };
    constructor.readLen = function(dup, nls) {
        switch (nls) {
            case 1:
                return dup.get() & 255;
            case 2:
                return dup.getShort() & 65535;
            case 3:
                return ((dup.getShort() & 65535) << 8) | (dup.get() & 255);
            case 4:
                return dup.getInt();
            default:
                 throw new IllegalArgumentException("NAL Unit length size can not be " + nls);
        }
    };
    /**
     *  Encodes AVC frame in ISO BMF format. Takes Annex B format.
     *  
     *  Scans the packet for each NAL Unit starting with 00 00 00 01 and replaces
     *  this 4 byte sequence with 4 byte integer representing this NAL unit
     *  length.
     *  
     *  @param avcFrame
     *             AVC frame encoded in Annex B NAL unit format
     */
    constructor.encodeMOVPacketInplace = function(avcFrame) {
        var dup = avcFrame.duplicate();
        var d1 = avcFrame.duplicate();
        for (var tot = d1.position(); ; ) {
            var buf = H264Utils.nextNALUnit(dup);
            if (buf == null) 
                break;
            d1.setPosition(tot);
            d1.putInt(buf.remaining());
            tot += buf.remaining() + 4;
        }
    };
    /**
     *  Encodes AVC frame in ISO BMF format. Takes Annex B format.
     *  
     *  Scans the packet for each NAL Unit starting with 00 00 00 01 and replaces
     *  this 4 byte sequence with 4 byte integer representing this NAL unit
     *  length.
     *  
     *  @param avcFrame
     *             AVC frame encoded in Annex B NAL unit format
     */
    constructor.encodeMOVPacket = function(avcFrame) {
        var dup = avcFrame.duplicate();
        var list = new ArrayList();
        var buf;
        var totalLen = 0;
         while ((buf = H264Utils.nextNALUnit(dup)) != null){
            list.add(buf);
            totalLen += buf.remaining();
        }
        var result = ByteBuffer.allocate(list.size() * 4 + totalLen);
        for (var iterator$byteBuffer = list.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            result.putInt(byteBuffer.remaining());
            result.putBuf(byteBuffer);
        }
        result.flip();
        return result;
    };
    /**
     *  Decodes AVC packet in ISO BMF format into Annex B format.
     *  
     *  Replaces NAL unit size integers with 00 00 00 01 start codes. If the
     *  space allows the transformation is done inplace.
     *  
     *  @param result
     */
    constructor.decodeMOVPacket = function(result, avcC) {
        if (avcC.getNalLengthSize() == 4) {
            H264Utils.decodeMOVPacketInplace(result, avcC);
            return result;
        }
        return H264Utils.joinNALUnits(H264Utils.splitMOVPacket(result, avcC));
    };
    /**
     *  Decodes AVC packet in ISO BMF format into Annex B format.
     *  
     *  Inplace replaces NAL unit size integers with 00 00 00 01 start codes.
     *  
     *  @param result
     */
    constructor.decodeMOVPacketInplace = function(result, avcC) {
        if (avcC.getNalLengthSize() != 4) 
             throw new IllegalArgumentException("Can only inplace decode AVC MOV packet with nal_length_size = 4.");
        var dup = result.duplicate();
         while (dup.remaining() >= 4){
            var size = dup.getInt();
            dup.setPosition(dup.position() - 4);
            dup.putInt(1);
            dup.setPosition(dup.position() + size);
        }
    };
    /**
     *  Wipes AVC parameter sets ( SPS/PPS ) from the packet
     *  
     *  @param in
     *             AVC frame encoded in Annex B NAL unit format
     *  @param out
     *             Buffer where packet without PS will be put
     *  @param spsList
     *             Storage for leading SPS structures ( can be null, then all
     *             leading SPSs are discarded ).
     *  @param ppsList
     *             Storage for leading PPS structures ( can be null, then all
     *             leading PPSs are discarded ).
     */
    constructor.wipePS = function(_in, out, spsList, ppsList) {
        var dup = _in.duplicate();
         while (dup.hasRemaining()){
            var buf = H264Utils.nextNALUnit(dup);
            if (buf == null) 
                break;
            var nu = NALUnit.read(buf.duplicate());
            if (nu.type == NALUnitType.PPS) {
                if (ppsList != null) 
                    ppsList.add(NIOUtils.duplicate(buf));
            } else if (nu.type == NALUnitType.SPS) {
                if (spsList != null) 
                    spsList.add(NIOUtils.duplicate(buf));
            } else if (out != null) {
                out.putInt(1);
                out.putBuf(buf);
            }
        }
        if (out != null) 
            out.flip();
    };
    /**
     *  Wipes AVC parameter sets ( SPS/PPS ) from the packet ( inplace operation
     *  )
     *  
     *  @param in
     *             AVC frame encoded in Annex B NAL unit format
     *  @param spsList
     *             Storage for leading SPS structures ( can be null, then all
     *             leading SPSs are discarded ).
     *  @param ppsList
     *             Storage for leading PPS structures ( can be null, then all
     *             leading PPSs are discarded ).
     */
    constructor.wipePSinplace = function(_in, spsList, ppsList) {
        var dup = _in.duplicate();
         while (dup.hasRemaining()){
            var buf = H264Utils.nextNALUnit(dup);
            if (buf == null) 
                break;
            var nu = NALUnit.read(buf);
            if (nu.type == NALUnitType.PPS) {
                if (ppsList != null) 
                    ppsList.add(NIOUtils.duplicate(buf));
                _in.setPosition(dup.position());
            } else if (nu.type == NALUnitType.SPS) {
                if (spsList != null) 
                    spsList.add(NIOUtils.duplicate(buf));
                _in.setPosition(dup.position());
            } else if (nu.type == NALUnitType.IDR_SLICE || nu.type == NALUnitType.NON_IDR_SLICE) 
                break;
        }
    };
    constructor.createAvcC = function(sps, pps, nalLengthSize) {
        var serialSps = ByteBuffer.allocate(512);
        sps.write(serialSps);
        serialSps.flip();
        H264Utils.escapeNALinplace(serialSps);
        var serialPps = ByteBuffer.allocate(512);
        pps.write(serialPps);
        serialPps.flip();
        H264Utils.escapeNALinplace(serialPps);
        var avcC = AvcCBox.createAvcCBox(sps.profileIdc, 0, sps.levelIdc, nalLengthSize, Arrays.asList(serialSps), Arrays.asList(serialPps));
        return avcC;
    };
    constructor.createAvcCFromList = function(initSPS, initPPS, nalLengthSize) {
        var serialSps = H264Utils.saveSPS(initSPS);
        var serialPps = H264Utils.savePPS(initPPS);
        var sps = initSPS.get(0);
        return AvcCBox.createAvcCBox(sps.profileIdc, 0, sps.levelIdc, nalLengthSize, serialSps, serialPps);
    };
    /**
     *  @param initPPS
     *  @return
     */
    constructor.savePPS = function(initPPS) {
        var serialPps = new ArrayList();
        for (var iterator$pps = initPPS.iterator(); iterator$pps.hasNext(); ) {
            var pps = iterator$pps.next();
            var bb1 = ByteBuffer.allocate(512);
            pps.write(bb1);
            bb1.flip();
            H264Utils.escapeNALinplace(bb1);
            serialPps.add(bb1);
        }
        return serialPps;
    };
    /**
     *  @param initSPS
     *  @return
     */
    constructor.saveSPS = function(initSPS) {
        var serialSps = new ArrayList();
        for (var iterator$sps = initSPS.iterator(); iterator$sps.hasNext(); ) {
            var sps = iterator$sps.next();
            var bb1 = ByteBuffer.allocate(512);
            sps.write(bb1);
            bb1.flip();
            H264Utils.escapeNALinplace(bb1);
            serialSps.add(bb1);
        }
        return serialSps;
    };
    /**
     *  Creates a MP4 sample entry given AVC/H.264 codec private.
     *  
     *  @param codecPrivate
     *             Array containing AnnexB delimited (00 00 00 01) SPS/PPS NAL
     *             units.
     *  @return MP4 sample entry
     */
    constructor.createMOVSampleEntryFromBytes = function(codecPrivate) {
        var rawSPS = H264Utils.getRawSPS(codecPrivate.duplicate());
        var rawPPS = H264Utils.getRawPPS(codecPrivate.duplicate());
        return H264Utils.createMOVSampleEntryFromSpsPpsList(rawSPS, rawPPS, 4);
    };
    constructor.createMOVSampleEntryFromSpsPpsList = function(spsList, ppsList, nalLengthSize) {
        var avcC = H264Utils.createAvcCFromPS(spsList, ppsList, nalLengthSize);
        return H264Utils.createMOVSampleEntryFromAvcC(avcC);
    };
    /**
     *  Creates a MP4 sample entry given AVC/H.264 codec private.
     *  
     *  @param codecPrivate
     *             Array containing AnnexB delimited (00 00 00 01) SPS/PPS NAL
     *             units.
     *  @return MP4 sample entry
     */
    constructor.createAvcCFromBytes = function(codecPrivate) {
        var rawSPS = H264Utils.getRawSPS(codecPrivate.duplicate());
        var rawPPS = H264Utils.getRawPPS(codecPrivate.duplicate());
        return H264Utils.createAvcCFromPS(rawSPS, rawPPS, 4);
    };
    constructor.createAvcCFromPS = function(spsList, ppsList, nalLengthSize) {
        var sps = H264Utils.readSPS(NIOUtils.duplicate(spsList.get(0)));
        return AvcCBox.createAvcCBox(sps.profileIdc, 0, sps.levelIdc, nalLengthSize, spsList, ppsList);
    };
    constructor.createMOVSampleEntryFromAvcC = function(avcC) {
        var sps = SeqParameterSet.read(avcC.getSpsList().get(0).duplicate());
        var codedWidth = (sps.picWidthInMbsMinus1 + 1) << 4;
        var codedHeight = SeqParameterSet.getPicHeightInMbs(sps) << 4;
        var se = VideoSampleEntry.videoSampleEntry("avc1", H264Utils.getPicSize(sps), "JCodec");
        se.add(avcC);
        return se;
    };
    constructor.createMOVSampleEntryFromSpsPps = function(initSPS, initPPS, nalLengthSize) {
        var bb1 = ByteBuffer.allocate(512), bb2 = ByteBuffer.allocate(512);
        initSPS.write(bb1);
        initPPS.write(bb2);
        bb1.flip();
        bb2.flip();
        return H264Utils.createMOVSampleEntryFromBuffer(bb1, bb2, nalLengthSize);
    };
    constructor.createMOVSampleEntryFromBuffer = function(sps, pps, nalLengthSize) {
        return H264Utils.createMOVSampleEntryFromSpsPpsList(Arrays.asList([sps]), Arrays.asList([pps]), nalLengthSize);
    };
    constructor.iFrame = function(_data) {
        var data = _data.duplicate();
        var segment;
         while ((segment = H264Utils.nextNALUnit(data)) != null){
            var type = NALUnit.read(segment).type;
            if (type == NALUnitType.IDR_SLICE || type == NALUnitType.NON_IDR_SLICE) {
                H264Utils.unescapeNAL(segment);
                var reader = BitReader.createBitReader(segment);
                var part1 = SliceHeaderReader.readPart1(reader);
                return part1.sliceType == SliceType.I;
            }
        }
        return false;
    };
    constructor.isByteBufferIDRSlice = function(_data) {
        var data = _data.duplicate();
        var segment;
         while ((segment = H264Utils.nextNALUnit(data)) != null){
            if (NALUnit.read(segment).type == NALUnitType.IDR_SLICE) 
                return true;
        }
        return false;
    };
    constructor.idrSlice = function(_data) {
        for (var iterator$segment = _data.iterator(); iterator$segment.hasNext(); ) {
            var segment = iterator$segment.next();
            if (NALUnit.read(segment.duplicate()).type == NALUnitType.IDR_SLICE) 
                return true;
        }
        return false;
    };
    constructor.saveRawFrame = function(data, avcC, f) {
        var raw = NIOUtils.writableChannel(f);
        H264Utils.saveStreamParams(avcC, raw);
        raw.write(data.duplicate());
        raw.close();
    };
    constructor.saveStreamParams = function(avcC, raw) {
        var bb = ByteBuffer.allocate(1024);
        for (var iterator$byteBuffer = avcC.getSpsList().iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            raw.write(ByteBuffer.wrap(new Int8Array([0, 0, 0, 1, 103])));
            H264Utils.escapeNAL(byteBuffer.duplicate(), bb);
            bb.flip();
            raw.write(bb);
            bb.clear();
        }
        for (var iterator$byteBuffer = avcC.getPpsList().iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            raw.write(ByteBuffer.wrap(new Int8Array([0, 0, 0, 1, 104])));
            H264Utils.escapeNAL(byteBuffer.duplicate(), bb);
            bb.flip();
            raw.write(bb);
            bb.clear();
        }
    };
    constructor.splitFrame = function(frame) {
        var result = new ArrayList();
        var segment;
         while ((segment = H264Utils.nextNALUnit(frame)) != null){
            result.add(segment);
        }
        return result;
    };
    /**
     *  Joins buffers containing individual NAL units into a single AnnexB
     *  delimited buffer. Each NAL unit will be separated with 00 00 00 01
     *  markers. Allocates a new byte buffer and writes data into it.
     *  
     *  @param nalUnits
     *  @param out
     */
    constructor.joinNALUnits = function(nalUnits) {
        var size = 0;
        for (var iterator$nal = nalUnits.iterator(); iterator$nal.hasNext(); ) {
            var nal = iterator$nal.next();
            size += 4 + nal.remaining();
        }
        var allocate = ByteBuffer.allocate(size);
        H264Utils.joinNALUnitsToBuffer(nalUnits, allocate);
        return allocate;
    };
    /**
     *  Joins buffers containing individual NAL units into a single AnnexB
     *  delimited buffer. Each NAL unit will be separated with 00 00 00 01
     *  markers.
     *  
     *  @param nalUnits
     *  @param out
     */
    constructor.joinNALUnitsToBuffer = function(nalUnits, out) {
        for (var iterator$nal = nalUnits.iterator(); iterator$nal.hasNext(); ) {
            var nal = iterator$nal.next();
            out.putInt(1);
            out.putBuf(nal.duplicate());
        }
    };
    constructor.getAvcCData = function(avcC) {
        var bb = ByteBuffer.allocate(2048);
        avcC.doWrite(bb);
        bb.flip();
        return bb;
    };
    constructor.parseAVCC = function(vse) {
        var lb = NodeBox.findFirst(vse, Box, "avcC");
        if (stjs.isInstanceOf(lb.constructor, AvcCBox)) 
            return lb;
         else {
            return H264Utils.parseAVCCFromBuffer((lb).getData().duplicate());
        }
    };
    constructor.saveCodecPrivate = function(spsList, ppsList) {
        var totalCodecPrivateSize = 0;
        for (var iterator$byteBuffer = spsList.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            totalCodecPrivateSize += byteBuffer.remaining() + 5;
        }
        for (var iterator$byteBuffer = ppsList.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            totalCodecPrivateSize += byteBuffer.remaining() + 5;
        }
        var bb = ByteBuffer.allocate(totalCodecPrivateSize);
        for (var iterator$byteBuffer = spsList.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            bb.putInt(1);
            bb.put((103 << 24 >> 24));
            bb.putBuf(byteBuffer.duplicate());
        }
        for (var iterator$byteBuffer = ppsList.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            bb.putInt(1);
            bb.put((104 << 24 >> 24));
            bb.putBuf(byteBuffer.duplicate());
        }
        bb.flip();
        return bb;
    };
    constructor.avcCToAnnexB = function(avcC) {
        return H264Utils.saveCodecPrivate(avcC.getSpsList(), avcC.getPpsList());
    };
    constructor.parseAVCCFromBuffer = function(bb) {
        return AvcCBox.parseAvcCBox(bb);
    };
    constructor.writeSPS = function(sps, approxSize) {
        var output = ByteBuffer.allocate(approxSize + 8);
        sps.write(output);
        output.flip();
        H264Utils.escapeNALinplace(output);
        return output;
    };
    constructor.readSPS = function(data) {
        var input = NIOUtils.duplicate(data);
        H264Utils.unescapeNAL(input);
        var sps = SeqParameterSet.read(input);
        return sps;
    };
    constructor.writePPS = function(pps, approxSize) {
        var output = ByteBuffer.allocate(approxSize + 8);
        pps.write(output);
        output.flip();
        H264Utils.escapeNALinplace(output);
        return output;
    };
    constructor.readPPS = function(data) {
        var input = NIOUtils.duplicate(data);
        H264Utils.unescapeNAL(input);
        var pps = PictureParameterSet.read(input);
        return pps;
    };
    constructor.findPPS = function(ppss, id) {
        for (var iterator$pps = ppss.iterator(); iterator$pps.hasNext(); ) {
            var pps = iterator$pps.next();
            if (pps.picParameterSetId == id) 
                return pps;
        }
        return null;
    };
    constructor.findSPS = function(spss, id) {
        for (var iterator$sps = spss.iterator(); iterator$sps.hasNext(); ) {
            var sps = iterator$sps.next();
            if (sps.seqParameterSetId == id) 
                return sps;
        }
        return null;
    };
    constructor.SliceHeaderTweaker = function() {};
    constructor.SliceHeaderTweaker = stjs.extend(constructor.SliceHeaderTweaker, null, [], function(constructor, prototype) {
        prototype.sps = null;
        prototype.pps = null;
        prototype.tweak = function(sh) {};
        prototype.run = function(is, os, nu) {
            var nal = os.duplicate();
            H264Utils.unescapeNAL(is);
            var reader = BitReader.createBitReader(is);
            var sh = SliceHeaderReader.readPart1(reader);
            var pp = H264Utils.findPPS(this.pps, sh.picParameterSetId);
            return this.part2(is, os, nu, H264Utils.findSPS(this.sps, pp.picParameterSetId), pp, nal, reader, sh);
        };
        prototype.runSpsPps = function(is, os, nu, sps, pps) {
            var nal = os.duplicate();
            H264Utils.unescapeNAL(is);
            var reader = BitReader.createBitReader(is);
            var sh = SliceHeaderReader.readPart1(reader);
            return this.part2(is, os, nu, sps, pps, nal, reader, sh);
        };
        prototype.part2 = function(is, os, nu, sps, pps, nal, reader, sh) {
            var writer = new BitWriter(os);
            SliceHeaderReader.readPart2(sh, nu, sps, pps, reader);
            this.tweak(sh);
            SliceHeaderWriter.write(sh, nu.type == NALUnitType.IDR_SLICE, nu.nal_ref_idc, writer);
            if (pps.entropyCodingModeFlag) 
                this.copyDataCABAC(is, os, reader, writer);
             else 
                this.copyDataCAVLC(is, os, reader, writer);
            nal.setLimit(os.position());
            H264Utils.escapeNALinplace(nal);
            os.setPosition(nal.limit());
            return sh;
        };
        prototype.copyDataCAVLC = function(is, os, reader, writer) {
            var wLeft = 8 - writer.curBit();
            if (wLeft != 0) 
                writer.writeNBit(reader.readNBit(wLeft), wLeft);
            writer.flush();
            var shift = reader.curBit();
            if (shift != 0) {
                var mShift = 8 - shift;
                var inp = reader.readNBit(mShift);
                reader.stop();
                 while (is.hasRemaining()){
                    var out = inp << shift;
                    inp = is.get() & 255;
                    out |= inp >> mShift;
                    os.put((out << 24 >> 24));
                }
                os.put(((inp << shift) << 24 >> 24));
            } else {
                reader.stop();
                os.putBuf(is);
            }
        };
        prototype.copyDataCABAC = function(is, os, reader, writer) {
            var bp = reader.curBit();
            if (bp != 0) {
                var rem = reader.readNBit(8 - ((bp) | 0));
                if ((1 << (8 - bp)) - 1 != rem) 
                     throw new RuntimeException("Invalid CABAC padding");
            }
            if (writer.curBit() != 0) 
                writer.writeNBit(255, 8 - writer.curBit());
            writer.flush();
            reader.stop();
            os.putBuf(is);
        };
    }, {sps: {name: "List", arguments: ["SeqParameterSet"]}, pps: {name: "List", arguments: ["PictureParameterSet"]}}, {});
    constructor.getPicSize = function(sps) {
        var w = (sps.picWidthInMbsMinus1 + 1) << 4;
        var h = SeqParameterSet.getPicHeightInMbs(sps) << 4;
        if (sps.frameCroppingFlag) {
            w -= (sps.frameCropLeftOffset + sps.frameCropRightOffset) << sps.chromaFormatIdc.compWidth[1];
            h -= (sps.frameCropTopOffset + sps.frameCropBottomOffset) << sps.chromaFormatIdc.compHeight[1];
        }
        return new Size(w, h);
    };
    constructor.readSPSFromBufferList = function(spsList) {
        var result = new ArrayList();
        for (var iterator$byteBuffer = spsList.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            result.add(H264Utils.readSPS(NIOUtils.duplicate(byteBuffer)));
        }
        return result;
    };
    constructor.readPPSFromBufferList = function(ppsList) {
        var result = new ArrayList();
        for (var iterator$byteBuffer = ppsList.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            result.add(H264Utils.readPPS(NIOUtils.duplicate(byteBuffer)));
        }
        return result;
    };
    constructor.writePPSList = function(allPps) {
        var result = new ArrayList();
        for (var iterator$pps = allPps.iterator(); iterator$pps.hasNext(); ) {
            var pps = iterator$pps.next();
            result.add(H264Utils.writePPS(pps, 64));
        }
        return result;
    };
    constructor.writeSPSList = function(allSps) {
        var result = new ArrayList();
        for (var iterator$sps = allSps.iterator(); iterator$sps.hasNext(); ) {
            var sps = iterator$sps.next();
            result.add(H264Utils.writeSPS(sps, 256));
        }
        return result;
    };
    constructor.dumpFrame = function(ch, values, values2, nalUnits) {
        for (var i = 0; i < values.length; i++) {
            var sps = values[i];
            NIOUtils.writeInt(ch, 1);
            NIOUtils.writeByte(ch, (103 << 24 >> 24));
            ch.write(H264Utils.writeSPS(sps, 128));
        }
        for (var i = 0; i < values2.length; i++) {
            var pps = values2[i];
            NIOUtils.writeInt(ch, 1);
            NIOUtils.writeByte(ch, (104 << 24 >> 24));
            ch.write(H264Utils.writePPS(pps, 256));
        }
        for (var iterator$byteBuffer = nalUnits.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            NIOUtils.writeInt(ch, 1);
            ch.write(byteBuffer.duplicate());
        }
    };
    constructor.toNAL = function(codecPrivate, sps, pps) {
        var bb1 = ByteBuffer.allocate(512), bb2 = ByteBuffer.allocate(512);
        sps.write(bb1);
        pps.write(bb2);
        bb1.flip();
        bb2.flip();
        H264Utils.putNAL(codecPrivate, bb1, 103);
        H264Utils.putNAL(codecPrivate, bb2, 104);
    };
    constructor.toNALList = function(codecPrivate, spsList2, ppsList2) {
        for (var iterator$byteBuffer = spsList2.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            H264Utils.putNAL(codecPrivate, byteBuffer, 103);
        }
        for (var iterator$byteBuffer = ppsList2.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            H264Utils.putNAL(codecPrivate, byteBuffer, 104);
        }
    };
    constructor.putNAL = function(codecPrivate, byteBuffer, nalType) {
        var dst = ByteBuffer.allocate(byteBuffer.remaining() * 2);
        H264Utils.escapeNAL(byteBuffer, dst);
        dst.flip();
        codecPrivate.putInt(1);
        codecPrivate.put((nalType << 24 >> 24));
        codecPrivate.putBuf(dst);
    };
    /**
     *  Parses a list of SPS NAL units out of the codec private array.
     *  
     *  @param codecPrivate
     *             An AnnexB formatted set of SPS/PPS NAL units.
     *  @return A list of ByteBuffers containing PPS NAL units.
     */
    constructor.getRawPPS = function(codecPrivate) {
        return H264Utils.getRawNALUnitsOfType(codecPrivate, NALUnitType.PPS);
    };
    /**
     *  Parses a list of SPS NAL units out of the codec private array.
     *  
     *  @param codecPrivate
     *             An AnnexB formatted set of SPS/PPS NAL units.
     *  @return A list of ByteBuffers containing SPS NAL units.
     */
    constructor.getRawSPS = function(codecPrivate) {
        return H264Utils.getRawNALUnitsOfType(codecPrivate, NALUnitType.SPS);
    };
    constructor.getRawNALUnitsOfType = function(codecPrivate, type) {
        var result = new ArrayList();
        for (var iterator$bb = H264Utils.splitFrame(codecPrivate.duplicate()).iterator(); iterator$bb.hasNext(); ) {
            var bb = iterator$bb.next();
            var nu = NALUnit.read(bb);
            if (nu.type == type) {
                result.add(bb);
            }
        }
        return result;
    };
    /**
     *  A collection of functions to work with a compact representation of a motion vector.
     *  
     *  Motion vector is represented as long:
     *  
     *  ||rrrrrr|vvvvvvvvvvvv|hhhhhhhhhhhhhh||
     *  
     */
    constructor.Mv = function() {};
    constructor.Mv = stjs.extend(constructor.Mv, null, [], function(constructor, prototype) {
        constructor.mvX = function(mv) {
            return (mv << 18) >> 18;
        };
        constructor.mvY = function(mv) {
            return ((mv << 6) >> 20);
        };
        constructor.mvRef = function(mv) {
            return (mv >> 26);
        };
        constructor.packMv = function(mvx, mvy, r) {
            return ((r & 63) << 26) | ((mvy & 4095) << 14) | (mvx & 16383);
        };
        constructor.mvC = function(mv, comp) {
            return comp == 0 ? H264Utils.Mv.mvX(mv) : H264Utils.Mv.mvY(mv);
        };
    }, {}, {});
    /**
     *  A collection of functions to work with a compact representation of a
     *  motion vector list.
     *  
     *  Motion vector list contains interleaved pairs of forward and backward
     *  motion vectors packed into integers.
     *  
     */
    constructor.MvList = function(size) {
        this.list = new Int32Array(size << 1);
        this.clear();
    };
    constructor.MvList = stjs.extend(constructor.MvList, null, [], function(constructor, prototype) {
        prototype.list = null;
        constructor.NA = H264Utils.Mv.packMv(0, 0, -1);
        prototype.clear = function() {
            for (var i = 0; i < this.list.length; i += 2) {
                this.list[i] = this.list[i + 1] = H264Utils.MvList.NA;
            }
        };
        prototype.mv0X = function(off) {
            return H264Utils.Mv.mvX(this.list[off << 1]);
        };
        prototype.mv0Y = function(off) {
            return H264Utils.Mv.mvY(this.list[off << 1]);
        };
        prototype.mv0R = function(off) {
            return H264Utils.Mv.mvRef(this.list[off << 1]);
        };
        prototype.mv1X = function(off) {
            return H264Utils.Mv.mvX(this.list[(off << 1) + 1]);
        };
        prototype.mv1Y = function(off) {
            return H264Utils.Mv.mvY(this.list[(off << 1) + 1]);
        };
        prototype.mv1R = function(off) {
            return H264Utils.Mv.mvRef(this.list[(off << 1) + 1]);
        };
        prototype.getMv = function(off, forward) {
            return this.list[(off << 1) + forward];
        };
        prototype.setMv = function(off, forward, mv) {
            this.list[(off << 1) + forward] = mv;
        };
        prototype.setPair = function(off, mv0, mv1) {
            this.list[(off << 1)] = mv0;
            this.list[(off << 1) + 1] = mv1;
        };
        prototype.copyPair = function(off, other, otherOff) {
            this.list[(off << 1)] = other.list[otherOff << 1];
            this.list[(off << 1) + 1] = other.list[(otherOff << 1) + 1];
        };
    }, {list: "Int32Array"}, {});
    constructor.MvList2D = function(width, height) {
        this.list = new Int32Array((width << 1) * height);
        this.stride = width << 1;
        this.width = width;
        this.height = height;
        this.clear();
    };
    constructor.MvList2D = stjs.extend(constructor.MvList2D, null, [], function(constructor, prototype) {
        prototype.list = null;
        prototype.stride = 0;
        prototype.width = 0;
        prototype.height = 0;
        constructor.NA = H264Utils.Mv.packMv(0, 0, -1);
        prototype.clear = function() {
            for (var i = 0; i < this.list.length; i += 2) {
                this.list[i] = this.list[i + 1] = H264Utils.MvList2D.NA;
            }
        };
        prototype.mv0X = function(offX, offY) {
            return H264Utils.Mv.mvX(this.list[(offX << 1) + this.stride * offY]);
        };
        prototype.mv0Y = function(offX, offY) {
            return H264Utils.Mv.mvY(this.list[(offX << 1) + this.stride * offY]);
        };
        prototype.mv0R = function(offX, offY) {
            return H264Utils.Mv.mvRef(this.list[(offX << 1) + this.stride * offY]);
        };
        prototype.mv1X = function(offX, offY) {
            return H264Utils.Mv.mvX(this.list[(offX << 1) + this.stride * offY + 1]);
        };
        prototype.mv1Y = function(offX, offY) {
            return H264Utils.Mv.mvY(this.list[(offX << 1) + this.stride * offY + 1]);
        };
        prototype.mv1R = function(offX, offY) {
            return H264Utils.Mv.mvRef(this.list[(offX << 1) + this.stride * offY + 1]);
        };
        prototype.getMv = function(offX, offY, forward) {
            return this.list[(offX << 1) + this.stride * offY + forward];
        };
        prototype.setMv = function(offX, offY, forward, mv) {
            this.list[(offX << 1) + this.stride * offY + forward] = mv;
        };
        prototype.getHeight = function() {
            return this.height;
        };
        prototype.getWidth = function() {
            return this.width;
        };
    }, {list: "Int32Array"}, {});
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org )
 *  This software is distributed under FreeBSD License
 *  
 *  @author The JCodec project
 */
var AVC1Box = function() {
    VideoSampleEntry.call(this, new Header("avc1"));
};
AVC1Box = stjs.extend(AVC1Box, VideoSampleEntry, [], null, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Quicktime time conversion utilities
 *  
 *  @author The JCodec project
 *  
 */
var QTTimeUtil = function() {};
QTTimeUtil = stjs.extend(QTTimeUtil, null, [], function(constructor, prototype) {
    /**
     *  Calculates track duration considering edits
     *  
     *  @param track
     *  @return
     */
    constructor.getEditedDuration = function(track) {
        var edits = track.getEdits();
        if (edits == null) 
            return track.getDuration();
        var duration = 0;
        for (var iterator$edit = edits.iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            duration += edit.getDuration();
        }
        return duration;
    };
    /**
     *  Finds timevalue of a frame number
     *  
     *  might be an expensive operation sinse it traverses compressed time to
     *  sample table
     *  
     *  @param frameNumber
     *  @return
     */
    constructor.frameToTimevalue = function(trak, frameNumber) {
        var stts = NodeBox.findFirstPath(trak, TimeToSampleBox, Box.path("mdia.minf.stbl.stts"));
        var timeToSamples = stts.getEntries();
        var pts = 0;
        var sttsInd = 0, sttsSubInd = frameNumber;
         while (sttsSubInd >= timeToSamples[sttsInd].getSampleCount()){
            sttsSubInd -= timeToSamples[sttsInd].getSampleCount();
            pts += timeToSamples[sttsInd].getSampleCount() * timeToSamples[sttsInd].getSampleDuration();
            sttsInd++;
        }
        return pts + timeToSamples[sttsInd].getSampleDuration() * sttsSubInd;
    };
    /**
     *  Finds frame by timevalue
     *  
     *  @param tv
     *  @return
     */
    constructor.timevalueToFrame = function(trak, tv) {
        var tts = NodeBox.findFirstPath(trak, TimeToSampleBox, Box.path("mdia.minf.stbl.stts")).getEntries();
        var frame = 0;
        for (var i = 0; tv > 0 && i < tts.length; i++) {
            var rem = stjs.trunc(tv / tts[i].getSampleDuration());
            tv -= tts[i].getSampleCount() * tts[i].getSampleDuration();
            frame += tv > 0 ? tts[i].getSampleCount() : rem;
        }
        return frame;
    };
    /**
     *  Converts media timevalue to edited timevalue
     *  
     *  @param trak
     *  @param mediaTv
     *  @param movieTimescale
     *  @return
     */
    constructor.mediaToEdited = function(trak, mediaTv, movieTimescale) {
        if (trak.getEdits() == null) 
            return mediaTv;
        var accum = 0;
        for (var iterator$edit = trak.getEdits().iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            if (mediaTv < edit.getMediaTime()) 
                return accum;
            var duration = trak.rescale(edit.getDuration(), movieTimescale);
            if (edit.getMediaTime() != -1 && (mediaTv >= edit.getMediaTime() && mediaTv < edit.getMediaTime() + duration)) {
                accum += mediaTv - edit.getMediaTime();
                break;
            }
            accum += duration;
        }
        return accum;
    };
    /**
     *  Converts edited timevalue to media timevalue
     *  
     *  @param trak
     *  @param mediaTv
     *  @param movieTimescale
     *  @return
     */
    constructor.editedToMedia = function(trak, editedTv, movieTimescale) {
        if (trak.getEdits() == null) 
            return editedTv;
        var accum = 0;
        for (var iterator$edit = trak.getEdits().iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            var duration = trak.rescale(edit.getDuration(), movieTimescale);
            if (accum + duration > editedTv) {
                return edit.getMediaTime() + editedTv - accum;
            }
            accum += duration;
        }
        return accum;
    };
    /**
     *  Calculates frame number as it shows in quicktime player
     *  
     *  @param movie
     *  @param mediaFrameNo
     *  @return
     */
    constructor.qtPlayerFrameNo = function(movie, mediaFrameNo) {
        var videoTrack = movie.getVideoTrack();
        var editedTv = QTTimeUtil.mediaToEdited(videoTrack, QTTimeUtil.frameToTimevalue(videoTrack, mediaFrameNo), movie.getTimescale());
        return QTTimeUtil.tv2QTFrameNo(movie, editedTv);
    };
    constructor.tv2QTFrameNo = function(movie, tv) {
        var videoTrack = movie.getVideoTrack();
        var timecodeTrack = movie.getTimecodeTrack();
        if (timecodeTrack != null && BoxUtil.containsBox2(videoTrack, "tref", "tmcd")) {
            return QTTimeUtil.timevalueToTimecodeFrame(timecodeTrack, new RationalLarge(tv, videoTrack.getTimescale()), movie.getTimescale());
        } else {
            return QTTimeUtil.timevalueToFrame(videoTrack, tv);
        }
    };
    /**
     *  Calculates and formats standard time as in Quicktime player
     *  
     *  @param movie
     *  @param mediaFrameNo
     *  @return
     */
    constructor.qtPlayerTime = function(movie, mediaFrameNo) {
        var videoTrack = movie.getVideoTrack();
        var editedTv = QTTimeUtil.mediaToEdited(videoTrack, QTTimeUtil.frameToTimevalue(videoTrack, mediaFrameNo), movie.getTimescale());
        var sec = (((stjs.trunc(editedTv / videoTrack.getTimescale()))) | 0);
        return String.format("%02d", stjs.trunc(sec / 3600)) + "_" + String.format("%02d", stjs.trunc((sec % 3600) / 60)) + "_" + String.format("%02d", sec % 60);
    };
    /**
     *  Calculates and formats tape timecode as in Quicktime player
     *  
     *  @param timecodeTrack
     *  @param tv
     *  @param startCounter
     *  @return
     *  @throws IOException
     */
    constructor.qtPlayerTimecodeFromMovie = function(movie, timecodeTrack, mediaFrameNo) {
        var videoTrack = movie.getVideoTrack();
        var editedTv = QTTimeUtil.mediaToEdited(videoTrack, QTTimeUtil.frameToTimevalue(videoTrack, mediaFrameNo), movie.getTimescale());
        var tt = timecodeTrack.getBox();
        var ttTimescale = tt.getTimescale();
        var ttTv = QTTimeUtil.editedToMedia(tt, stjs.trunc(editedTv * ttTimescale / videoTrack.getTimescale()), movie.getTimescale());
        return QTTimeUtil.formatTimecode(timecodeTrack.getBox(), timecodeTrack.getStartTimecode() + QTTimeUtil.timevalueToTimecodeFrame(timecodeTrack.getBox(), new RationalLarge(ttTv, ttTimescale), movie.getTimescale()));
    };
    /**
     *  Calculates and formats tape timecode as in Quicktime player
     *  
     *  @param timecodeTrack
     *  @param tv
     *  @param startCounter
     *  @return
     *  @throws IOException
     */
    constructor.qtPlayerTimecode = function(timecodeTrack, tv, movieTimescale) {
        var tt = timecodeTrack.getBox();
        var ttTimescale = tt.getTimescale();
        var ttTv = QTTimeUtil.editedToMedia(tt, tv.multiplyS(ttTimescale), movieTimescale);
        return QTTimeUtil.formatTimecode(timecodeTrack.getBox(), timecodeTrack.getStartTimecode() + QTTimeUtil.timevalueToTimecodeFrame(timecodeTrack.getBox(), new RationalLarge(ttTv, ttTimescale), movieTimescale));
    };
    /**
     *  Converts timevalue to frame number based on timecode track
     *  
     *  @param timecodeTrack
     *  @param tv
     *  @return
     */
    constructor.timevalueToTimecodeFrame = function(timecodeTrack, tv, movieTimescale) {
        var se = timecodeTrack.getSampleEntries()[0];
        return stjs.trunc(((((stjs.trunc(2 * tv.multiplyS(se.getTimescale()) / se.getFrameDuration())) + 1)) | 0) / 2);
    };
    /**
     *  Formats tape timecode based on frame counter
     *  
     *  @param timecodeTrack
     *  @param counter
     *  @return
     */
    constructor.formatTimecode = function(timecodeTrack, counter) {
        var tmcd = NodeBox.findFirstPath(timecodeTrack, TimecodeSampleEntry, Box.path("mdia.minf.stbl.stsd.tmcd"));
        var nf = tmcd.getNumFrames();
        var tc = String.format("%02d", counter % nf);
        counter = stjs.trunc(counter / (nf));
        tc = String.format("%02d", counter % 60) + ":" + tc;
        counter = stjs.trunc(counter / (60));
        tc = String.format("%02d", counter % 60) + ":" + tc;
        counter = stjs.trunc(counter / (60));
        tc = String.format("%02d", counter) + ":" + tc;
        return tc;
    };
}, {}, {});
var SampleBoxes = function() {
    Boxes.call(this);
    this.clear();
    this.override("ap4h", VideoSampleEntry);
    this.override("apch", VideoSampleEntry);
    this.override("apcn", VideoSampleEntry);
    this.override("apcs", VideoSampleEntry);
    this.override("apco", VideoSampleEntry);
    this.override("avc1", VideoSampleEntry);
    this.override("cvid", VideoSampleEntry);
    this.override("jpeg", VideoSampleEntry);
    this.override("smc ", VideoSampleEntry);
    this.override("rle ", VideoSampleEntry);
    this.override("rpza", VideoSampleEntry);
    this.override("kpcd", VideoSampleEntry);
    this.override("png ", VideoSampleEntry);
    this.override("mjpa", VideoSampleEntry);
    this.override("mjpb", VideoSampleEntry);
    this.override("SVQ1", VideoSampleEntry);
    this.override("SVQ3", VideoSampleEntry);
    this.override("mp4v", VideoSampleEntry);
    this.override("dvc ", VideoSampleEntry);
    this.override("dvcp", VideoSampleEntry);
    this.override("gif ", VideoSampleEntry);
    this.override("h263", VideoSampleEntry);
    this.override("tiff", VideoSampleEntry);
    this.override("raw ", VideoSampleEntry);
    this.override("2vuY", VideoSampleEntry);
    this.override("yuv2", VideoSampleEntry);
    this.override("v308", VideoSampleEntry);
    this.override("v408", VideoSampleEntry);
    this.override("v216", VideoSampleEntry);
    this.override("v410", VideoSampleEntry);
    this.override("v210", VideoSampleEntry);
    this.override("m2v1", VideoSampleEntry);
    this.override("m1v1", VideoSampleEntry);
    this.override("xd5b", VideoSampleEntry);
    this.override("dv5n", VideoSampleEntry);
    this.override("jp2h", VideoSampleEntry);
    this.override("mjp2", VideoSampleEntry);
    this.override("ac-3", AudioSampleEntry);
    this.override("cac3", AudioSampleEntry);
    this.override("ima4", AudioSampleEntry);
    this.override("aac ", AudioSampleEntry);
    this.override("celp", AudioSampleEntry);
    this.override("hvxc", AudioSampleEntry);
    this.override("twvq", AudioSampleEntry);
    this.override(".mp1", AudioSampleEntry);
    this.override(".mp2", AudioSampleEntry);
    this.override("midi", AudioSampleEntry);
    this.override("apvs", AudioSampleEntry);
    this.override("alac", AudioSampleEntry);
    this.override("aach", AudioSampleEntry);
    this.override("aacl", AudioSampleEntry);
    this.override("aace", AudioSampleEntry);
    this.override("aacf", AudioSampleEntry);
    this.override("aacp", AudioSampleEntry);
    this.override("aacs", AudioSampleEntry);
    this.override("samr", AudioSampleEntry);
    this.override("AUDB", AudioSampleEntry);
    this.override("ilbc", AudioSampleEntry);
    this.override(Platform.stringFromBytes(new Int8Array([109, 115, 0, 17])), AudioSampleEntry);
    this.override(Platform.stringFromBytes(new Int8Array([109, 115, 0, 49])), AudioSampleEntry);
    this.override("aes3", AudioSampleEntry);
    this.override("NONE", AudioSampleEntry);
    this.override("raw ", AudioSampleEntry);
    this.override("twos", AudioSampleEntry);
    this.override("sowt", AudioSampleEntry);
    this.override("MAC3 ", AudioSampleEntry);
    this.override("MAC6 ", AudioSampleEntry);
    this.override("ima4", AudioSampleEntry);
    this.override("fl32", AudioSampleEntry);
    this.override("fl64", AudioSampleEntry);
    this.override("in24", AudioSampleEntry);
    this.override("in32", AudioSampleEntry);
    this.override("ulaw", AudioSampleEntry);
    this.override("alaw", AudioSampleEntry);
    this.override("dvca", AudioSampleEntry);
    this.override("QDMC", AudioSampleEntry);
    this.override("QDM2", AudioSampleEntry);
    this.override("Qclp", AudioSampleEntry);
    this.override(".mp3", AudioSampleEntry);
    this.override("mp4a", AudioSampleEntry);
    this.override("lpcm", AudioSampleEntry);
    this.override("tmcd", TimecodeSampleEntry);
    this.override("time", TimecodeSampleEntry);
    this.override("c608", SampleEntry);
    this.override("c708", SampleEntry);
    this.override("text", SampleEntry);
    this.override("fdsc", SampleEntry);
};
SampleBoxes = stjs.extend(SampleBoxes, Boxes, [], null, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 */
var ChunkReader = function(trakBox) {
    var stts = trakBox.getStts();
    this.tts = stts.getEntries();
    var stco = trakBox.getStco();
    var co64 = trakBox.getCo64();
    this.stsz = trakBox.getStsz();
    var stsc = trakBox.getStsc();
    if (stco != null) 
        this.chunkOffsets = stco.getChunkOffsets();
     else 
        this.chunkOffsets = co64.getChunkOffsets();
    this.sampleToChunk = stsc.getSampleToChunk();
    this.stsd = trakBox.getStsd();
};
ChunkReader = stjs.extend(ChunkReader, null, [], function(constructor, prototype) {
    prototype.curChunk = 0;
    prototype.sampleNo = 0;
    prototype.s2cIndex = 0;
    prototype.ttsInd = 0;
    prototype.ttsSubInd = 0;
    prototype.chunkTv = 0;
    prototype.chunkOffsets = null;
    prototype.sampleToChunk = null;
    prototype.stsz = null;
    prototype.tts = null;
    prototype.stsd = null;
    prototype.hasNext = function() {
        return this.curChunk < this.chunkOffsets.length;
    };
    prototype.next = function() {
        if (this.curChunk >= this.chunkOffsets.length) 
            return null;
        if (this.s2cIndex + 1 < this.sampleToChunk.length && this.curChunk + 1 == this.sampleToChunk[this.s2cIndex + 1].getFirst()) 
            this.s2cIndex++;
        var sampleCount = this.sampleToChunk[this.s2cIndex].getCount();
        var samplesDur = null;
        var sampleDur = 0;
        if (this.ttsSubInd + sampleCount <= this.tts[this.ttsInd].getSampleCount()) {
            sampleDur = this.tts[this.ttsInd].getSampleDuration();
            this.ttsSubInd += sampleCount;
        } else {
            samplesDur = new Int32Array(sampleCount);
            for (var i = 0; i < sampleCount; i++) {
                if (this.ttsSubInd >= this.tts[this.ttsInd].getSampleCount() && this.ttsInd < this.tts.length - 1) {
                    this.ttsSubInd = 0;
                    ++this.ttsInd;
                }
                samplesDur[i] = this.tts[this.ttsInd].getSampleDuration();
                ++this.ttsSubInd;
            }
        }
        var size = 0;
        var sizes = null;
        if (this.stsz.getDefaultSize() > 0) {
            size = this.getFrameSize();
        } else {
            sizes = Platform.copyOfRangeI(this.stsz.getSizes(), this.sampleNo, this.sampleNo + sampleCount);
        }
        var dref = this.sampleToChunk[this.s2cIndex].getEntry();
        var chunk = new Chunk(this.chunkOffsets[this.curChunk], this.chunkTv, sampleCount, size, sizes, sampleDur, samplesDur, dref);
        this.chunkTv += chunk.getDuration();
        this.sampleNo += sampleCount;
        ++this.curChunk;
        return chunk;
    };
    prototype.getFrameSize = function() {
        var size = this.stsz.getDefaultSize();
        var box = this.stsd.getBoxes().get(this.sampleToChunk[this.s2cIndex].getEntry() - 1);
        if (stjs.isInstanceOf(box.constructor, AudioSampleEntry)) {
            return (box).calcFrameSize();
        }
        return size;
    };
    prototype.size = function() {
        return this.chunkOffsets.length;
    };
}, {chunkOffsets: "Array", sampleToChunk: "Array", stsz: "SampleSizesBox", tts: "Array", stsd: "SampleDescriptionBox"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  The meata box inside 'udta'
 *  
 *  @author The JCodec project
 *  
 */
var UdtaMetaBox = function(atom) {
    MetaBox.call(this, atom);
};
UdtaMetaBox = stjs.extend(UdtaMetaBox, MetaBox, [], function(constructor, prototype) {
    constructor.createUdtaMetaBox = function() {
        return new UdtaMetaBox(Header.createHeader(MetaBox.fourcc(), 0));
    };
    prototype.parse = function(input) {
        input.getInt();
        NodeBox.prototype.parse.call(this, input);
    };
    prototype.doWrite = function(out) {
        out.putInt(0);
        NodeBox.prototype.doWrite.call(this, out);
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var CCE = function(frameLength) {
    Element.call(this);
    this.ics = new ICStream(frameLength);
    this.channelPair = new Int8Array(8);
    this.idSelect = new Int32Array(8);
    this.chSelect = new Int32Array(8);
    this.gain = Array.apply(null, Array(16)).map(function() {
        return new Float32Array(120);
    });
};
CCE = stjs.extend(CCE, Element, [SyntaxConstants], function(constructor, prototype) {
    constructor.BEFORE_TNS = 0;
    constructor.AFTER_TNS = 1;
    constructor.AFTER_IMDCT = 2;
    constructor.CCE_SCALE = new Float32Array([1.0905077, 1.1892071, 1.4142135, 2.0]);
    prototype.ics = null;
    prototype.iqData = null;
    prototype.couplingPoint = 0;
    prototype.coupledCount = 0;
    prototype.channelPair = null;
    prototype.idSelect = null;
    prototype.chSelect = null;
    prototype.gain = null;
    prototype.getCouplingPoint = function() {
        return this.couplingPoint;
    };
    prototype.getCoupledCount = function() {
        return this.coupledCount;
    };
    prototype.isChannelPair = function(index) {
        return this.channelPair[index];
    };
    prototype.getIDSelect = function(index) {
        return this.idSelect[index];
    };
    prototype.getCHSelect = function(index) {
        return this.chSelect[index];
    };
    prototype.decode = function(_in, conf) {
        this.couplingPoint = 2 * _in.readBit();
        this.coupledCount = _in.readBits(3);
        var gainCount = 0;
        var i;
        for (i = 0; i <= this.coupledCount; i++) {
            gainCount++;
            this.channelPair[i] = _in.readBool();
            this.idSelect[i] = _in.readBits(4);
            if (this.channelPair[i]) {
                this.chSelect[i] = _in.readBits(2);
                if (this.chSelect[i] == 3) 
                    gainCount++;
            } else 
                this.chSelect[i] = 2;
        }
        this.couplingPoint += _in.readBit();
        this.couplingPoint |= (this.couplingPoint >> 1);
        var sign = _in.readBool();
        var scale = CCE.CCE_SCALE[_in.readBits(2)];
        this.ics.decode(_in, false, conf);
        var info = this.ics.getInfo();
        var windowGroupCount = info.getWindowGroupCount();
        var maxSFB = info.getMaxSFB();
        var sfbCB = [new Int32Array()];
        for (i = 0; i < gainCount; i++) {
            var idx = 0;
            var cge = 1;
            var xg = 0;
            var gainCache = 1.0;
            if (i > 0) {
                cge = this.couplingPoint == 2 ? 1 : _in.readBit();
                xg = cge == 0 ? 0 : Huffman.decodeScaleFactor(_in) - 60;
                gainCache = Math.pow(scale, -xg);
            }
            if (this.couplingPoint == 2) 
                this.gain[i][0] = gainCache;
             else {
                var sfb;
                for (var g = 0; g < windowGroupCount; g++) {
                    for (sfb = 0; sfb < maxSFB; sfb++ , idx++) {
                        if (sfbCB[g][sfb] != HCB.ZERO_HCB) {
                            if (cge == 0) {
                                var t = Huffman.decodeScaleFactor(_in) - 60;
                                if (t != 0) {
                                    var s = 1;
                                    t = xg += t;
                                    if (!sign) {
                                        s -= 2 * (t & 1);
                                        t >>= 1;
                                    }
                                    gainCache = (Math.pow(scale, -t) * s);
                                }
                            }
                            this.gain[i][idx] = gainCache;
                        }
                    }
                }
            }
        }
    };
    prototype.process = function() {
        this.iqData = this.ics.getInvQuantData();
    };
    prototype.applyIndependentCoupling = function(index, data) {
        var g = this.gain[index][0];
        for (var i = 0; i < data.length; i++) {
            data[i] += g * this.iqData[i];
        }
    };
    prototype.applyDependentCoupling = function(index, data) {
        var info = this.ics.getInfo();
        var swbOffsets = info.getSWBOffsets();
        var windowGroupCount = info.getWindowGroupCount();
        var maxSFB = info.getMaxSFB();
        var sfbCB = [new Int32Array()];
        var srcOff = 0;
        var dstOff = 0;
        var len, sfb, group, k, idx = 0;
        var x;
        for (var g = 0; g < windowGroupCount; g++) {
            len = info.getWindowGroupLength(g);
            for (sfb = 0; sfb < maxSFB; sfb++ , idx++) {
                if (sfbCB[g][sfb] != HCB.ZERO_HCB) {
                    x = this.gain[index][idx];
                    for (group = 0; group < len; group++) {
                        for (k = swbOffsets[sfb]; k < swbOffsets[sfb + 1]; k++) {
                            data[dstOff + group * 128 + k] += x * this.iqData[srcOff + group * 128 + k];
                        }
                    }
                }
            }
            dstOff += len * 128;
            srcOff += len * 128;
        }
    };
}, {CCE_SCALE: "Float32Array", ics: "ICStream", iqData: "Float32Array", channelPair: "Int8Array", idSelect: "Int32Array", chSelect: "Int32Array", gain: "Array", sbr: "SBR"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  @author in-somnia
 */
var SCE_LFE = function(frameLength) {
    Element.call(this);
    this.ics = new ICStream(frameLength);
};
SCE_LFE = stjs.extend(SCE_LFE, Element, [], function(constructor, prototype) {
    prototype.ics = null;
    prototype.decode = function(_in, conf) {
        this.readElementInstanceTag(_in);
        this.ics.decode(_in, false, conf);
    };
    prototype.getICStream = function() {
        return this.ics;
    };
}, {ics: "ICStream", sbr: "SBR"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var CPE = function(frameLength) {
    Element.call(this);
    this.msUsed = new Int8Array(SyntaxConstants.MAX_MS_MASK);
    this.icsL = new ICStream(frameLength);
    this.icsR = new ICStream(frameLength);
};
CPE = stjs.extend(CPE, Element, [SyntaxConstants], function(constructor, prototype) {
    prototype.msMask = null;
    prototype.msUsed = null;
    prototype.commonWindow = false;
    prototype.icsL = null;
    prototype.icsR = null;
    prototype.decode = function(_in, conf) {
        var profile = conf.getProfile();
        var sf = conf.getSampleFrequency();
        if (sf.equals(SampleFrequency.SAMPLE_FREQUENCY_NONE)) 
             throw new AACException("invalid sample frequency");
        this.readElementInstanceTag(_in);
        this.commonWindow = _in.readBool();
        var info = this.icsL.getInfo();
        if (this.commonWindow) {
            info.decode(_in, conf, this.commonWindow);
            this.icsR.getInfo().setData(info);
            this.msMask = CPE.msMaskFromInt(_in.readBits(2));
            if (this.msMask.equals(MSMask.TYPE_USED)) {
                var maxSFB = info.getMaxSFB();
                var windowGroupCount = info.getWindowGroupCount();
                for (var idx = 0; idx < windowGroupCount * maxSFB; idx++) {
                    this.msUsed[idx] = _in.readBool();
                }
            } else if (this.msMask.equals(MSMask.TYPE_ALL_1)) 
                Arrays.fill(this.msUsed, true);
             else if (this.msMask.equals(MSMask.TYPE_ALL_0)) 
                Arrays.fill(this.msUsed, false);
             else 
                 throw new AACException("reserved MS mask type used");
        } else {
            this.msMask = MSMask.TYPE_ALL_0;
            Arrays.fill(this.msUsed, false);
        }
        if (profile.isErrorResilientProfile() && (info.isLTPrediction1Present())) {
            if (info.ltpData2Present = _in.readBool()) 
                info.getLTPrediction2().decode(_in, info, profile);
        }
        this.icsL.decode(_in, this.commonWindow, conf);
        this.icsR.decode(_in, this.commonWindow, conf);
    };
    prototype.getLeftChannel = function() {
        return this.icsL;
    };
    prototype.getRightChannel = function() {
        return this.icsR;
    };
    prototype.getMSMask = function() {
        return this.msMask;
    };
    prototype.isMSUsed = function(off) {
        return this.msUsed[off];
    };
    prototype.isMSMaskPresent = function() {
        return !this.msMask.equals(MSMask.TYPE_ALL_0);
    };
    prototype.isCommonWindow = function() {
        return this.commonWindow;
    };
    constructor.msMaskFromInt = function(i) {
        var values = MSMask.values();
        if (i >= values.length) {
             throw new AACException("unknown MS mask type");
        }
        return values[i];
    };
}, {msMask: {name: "Enum", arguments: ["MSMask"]}, msUsed: "Int8Array", icsL: "ICStream", icsR: "ICStream", sbr: "SBR"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MXFConst = function() {};
MXFConst = stjs.extend(MXFConst, null, [], function(constructor, prototype) {
    constructor.HEADER_PARTITION_KLV = UL.newUL("06.0e.2b.34.02.05.01.01.0d.01.02.01.01.02");
    constructor.INDEX_KLV = UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.02.01.01.10.01.00");
    constructor.GENERIC_DESCRIPTOR_KLV = UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.01.01.01.01");
    constructor.klMetadata = new HashMap();
    constructor.KLVFill = function(ul) {
        MXFMetadata.call(this, ul);
    };
    constructor.KLVFill = stjs.extend(constructor.KLVFill, MXFMetadata, [], function(constructor, prototype) {
        prototype.readBuf = function(bb) {};
    }, {ul: "UL", uid: "UL"}, {});
}, {HEADER_PARTITION_KLV: "UL", INDEX_KLV: "UL", GENERIC_DESCRIPTOR_KLV: "UL", klMetadata: {name: "Map", arguments: ["UL", {name: "Class", arguments: ["Object"]}]}}, {});
(function() {
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.01.01.01.01.18.00"), ContentStorage);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.01.01.01.01.37.00"), SourcePackage);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.01.01.01.01.0F.00"), Sequence);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0D.01.01.01.01.01.2F.00"), Preface);
    MXFConst.klMetadata.put(UL.newUL("06.0e.2b.34.02.53.01.01.0d.01.01.01.01.01.30.00"), Identification);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.01.01.01.01.11.00"), SourceClip);
    MXFConst.klMetadata.put(UL.newUL("06.0e.2b.34.02.53.01.01.0d.01.01.01.01.01.23.00"), EssenceContainerData);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.01.01.01.01.3A.00"), TimelineTrack);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.01.01.01.01.3B.00"), TimelineTrack);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.01.01.01.01.36.00"), MaterialPackage);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.02.01.01.10.01.00"), IndexSegment);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.01.01.01.01.44.00"), GenericDescriptor);
    MXFConst.klMetadata.put(UL.newUL("06.0e.2b.34.02.53.01.01.0d.01.01.01.01.01.5b.00"), GenericDataEssenceDescriptor);
    MXFConst.klMetadata.put(UL.newUL("06.0e.2b.34.02.53.01.01.0d.01.01.01.01.01.5b.00"), GenericDataEssenceDescriptor);
    MXFConst.klMetadata.put(UL.newUL("06.0e.2b.34.02.53.01.01.0d.01.01.01.01.01.5c.00"), GenericDataEssenceDescriptor);
    MXFConst.klMetadata.put(UL.newUL("06.0e.2b.34.02.53.01.01.0d.01.01.01.01.01.43.00"), GenericDataEssenceDescriptor);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.01.01.01.01.42.00"), GenericSoundEssenceDescriptor);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.01.01.01.01.28.00"), CDCIEssenceDescriptor);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.01.01.01.01.29.00"), RGBAEssenceDescriptor);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.01.01.01.01.51.00"), MPEG2VideoDescriptor);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.01.01.01.01.48.00"), WaveAudioDescriptor);
    MXFConst.klMetadata.put(UL.newUL("06.0e.2b.34.02.53.01.01.0d.01.01.01.01.01.25.00"), FileDescriptor);
    MXFConst.klMetadata.put(UL.newUL("06.0e.2b.34.02.53.01.01.0d.01.01.01.01.01.27.00"), GenericPictureEssenceDescriptor);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0d.01.01.01.01.01.47.00"), AES3PCMDescriptor);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.05.01.01.0d.01.02.01.01.05.01.00"), MXFPartitionPack);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.05.01.01.0d.01.02.01.01.02.01.00"), MXFPartitionPack);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.05.01.01.0d.01.02.01.01.02.02.00"), MXFPartitionPack);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.05.01.01.0d.01.02.01.01.02.03.00"), MXFPartitionPack);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.05.01.01.0d.01.02.01.01.02.04.00"), MXFPartitionPack);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.05.01.01.0d.01.02.01.01.03.01.00"), MXFPartitionPack);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.05.01.01.0d.01.02.01.01.03.02.00"), MXFPartitionPack);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.05.01.01.0d.01.02.01.01.03.03.00"), MXFPartitionPack);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.05.01.01.0d.01.02.01.01.03.04.00"), MXFPartitionPack);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.05.01.01.0d.01.02.01.01.04.02.00"), MXFPartitionPack);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.05.01.01.0d.01.02.01.01.04.04.00"), MXFPartitionPack);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.02.53.01.01.0D.01.01.01.01.01.14.00"), TimecodeComponent);
    MXFConst.klMetadata.put(UL.newUL("06.0E.2B.34.01.01.01.02.03.01.02.10.01.00.00.00"), MXFConst.KLVFill);
    MXFConst.klMetadata.put(UL.newUL("06.0e.2b.34.02.53.01.01.0d.01.01.01.01.01.5a.00"), J2KPictureDescriptor);
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MediaBox = function(atom) {
    NodeBox.call(this, atom);
};
MediaBox = stjs.extend(MediaBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "mdia";
    };
    constructor.createMediaBox = function() {
        return new MediaBox(new Header(MediaBox.fourcc()));
    };
    prototype.getMinf = function() {
        return NodeBox.findFirst(this, MediaInfoBox, "minf");
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MKVDemuxer = function(fileChannelWrapper) {
    this.channel = fileChannelWrapper;
    this.aTracks = new ArrayList();
    var parser = new MKVParser(this.channel);
    this.t = parser.parse();
    this.demux();
};
MKVDemuxer = stjs.extend(MKVDemuxer, null, [Demuxer], function(constructor, prototype) {
    prototype.vTrack = null;
    prototype.aTracks = null;
    prototype.t = null;
    prototype.channel = null;
    prototype.timescale = 1;
    prototype.pictureWidth = 0;
    prototype.pictureHeight = 0;
    constructor.codecMapping = new HashMap();
    prototype.demux = function() {
        var path = [MKVType.Segment, MKVType.Info, MKVType.TimecodeScale];
        var ts = MKVType.findFirstTree(this.t, path);
        if (ts != null) 
            this.timescale = ((ts.getUint()) | 0);
        var path9 = [MKVType.Segment, MKVType.Tracks, MKVType.TrackEntry];
        for (var iterator$aTrack = MKVType.findList(this.t, EbmlMaster, path9).iterator(); iterator$aTrack.hasNext(); ) {
            var aTrack = iterator$aTrack.next();
            var path1 = [MKVType.TrackEntry, MKVType.TrackType];
            var type = (MKVType.findFirst(aTrack, path1)).getUint();
            var path2 = [MKVType.TrackEntry, MKVType.TrackNumber];
            var id = (MKVType.findFirst(aTrack, path2)).getUint();
            if (type == 1) {
                if (this.vTrack != null) 
                     throw new RuntimeException("More then 1 video track, can not compute...");
                var path3 = [MKVType.TrackEntry, MKVType.CodecPrivate];
                var path10 = [MKVType.TrackEntry, MKVType.CodecID];
                var codecId = MKVType.findFirst(aTrack, path10);
                var codec = MKVDemuxer.codecMapping.get(codecId.getString());
                var videoCodecState = MKVType.findFirst(aTrack, path3);
                var state = null;
                if (videoCodecState != null) 
                    state = videoCodecState.data;
                var path4 = [MKVType.TrackEntry, MKVType.Video, MKVType.PixelWidth];
                var width = MKVType.findFirst(aTrack, path4);
                var path5 = [MKVType.TrackEntry, MKVType.Video, MKVType.PixelHeight];
                var height = MKVType.findFirst(aTrack, path5);
                var path6 = [MKVType.TrackEntry, MKVType.Video, MKVType.DisplayWidth];
                var dwidth = MKVType.findFirst(aTrack, path6);
                var path7 = [MKVType.TrackEntry, MKVType.Video, MKVType.DisplayHeight];
                var dheight = MKVType.findFirst(aTrack, path7);
                var path8 = [MKVType.TrackEntry, MKVType.Video, MKVType.DisplayUnit];
                var unit = MKVType.findFirst(aTrack, path8);
                if (width != null && height != null) {
                    this.pictureWidth = ((width.getUint()) | 0);
                    this.pictureHeight = ((height.getUint()) | 0);
                } else if (dwidth != null && dheight != null) {
                    if (unit == null || unit.getUint() == 0) {
                        this.pictureHeight = ((dheight.getUint()) | 0);
                        this.pictureWidth = ((dwidth.getUint()) | 0);
                    } else {
                         throw new RuntimeException("DisplayUnits other then 0 are not implemented yet");
                    }
                }
                this.vTrack = new MKVDemuxer.VideoTrack(this, ((id) | 0), state, codec);
            } else if (type == 2) {
                var audioTrack = new MKVDemuxer.AudioTrack(((id) | 0), this);
                var path3 = [MKVType.TrackEntry, MKVType.Audio, MKVType.SamplingFrequency];
                var sf = MKVType.findFirst(aTrack, path3);
                if (sf != null) 
                    audioTrack.samplingFrequency = sf.getDouble();
                this.aTracks.add(audioTrack);
            }
        }
        var path2 = [MKVType.Segment, MKVType.Cluster];
        for (var iterator$aCluster = MKVType.findList(this.t, EbmlMaster, path2).iterator(); iterator$aCluster.hasNext(); ) {
            var aCluster = iterator$aCluster.next();
            var path1 = [MKVType.Cluster, MKVType.Timecode];
            var baseTimecode = (MKVType.findFirst(aCluster, path1)).getUint();
            for (var iterator$child = aCluster.children.iterator(); iterator$child.hasNext(); ) {
                var child = iterator$child.next();
                if (MKVType.SimpleBlock.equals(child.type)) {
                    var b = child;
                    b.absoluteTimecode = b.timecode + baseTimecode;
                    this.putIntoRightBasket(b);
                } else if (MKVType.BlockGroup.equals(child.type)) {
                    var group = child;
                    for (var iterator$grandChild = group.children.iterator(); iterator$grandChild.hasNext(); ) {
                        var grandChild = iterator$grandChild.next();
                        if (grandChild.type == MKVType.Block) {
                            var b = child;
                            b.absoluteTimecode = b.timecode + baseTimecode;
                            this.putIntoRightBasket(b);
                        }
                    }
                }
            }
        }
    };
    prototype.putIntoRightBasket = function(b) {
        if (b.trackNumber == this.vTrack.trackNo) {
            this.vTrack.blocks.add(b);
        } else {
            for (var i = 0; i < this.aTracks.size(); i++) {
                var audio = this.aTracks.get(i);
                if (b.trackNumber == audio.trackNo) {
                    audio.blocks.add(MKVDemuxer.IndexedBlock.make(audio.framesCount, b));
                    audio.framesCount += b.frameSizes.length;
                }
            }
        }
    };
    constructor.VideoTrack = function(demuxer, trackNo, state, codec) {
        this.blocks = new ArrayList();
        this.demuxer = demuxer;
        this.trackNo = trackNo;
        this.codec = codec;
        if (codec == Codec.H264) {
            this.avcC = H264Utils.parseAVCCFromBuffer(state);
            this.state = H264Utils.avcCToAnnexB(this.avcC);
        } else {
            this.state = state;
        }
    };
    constructor.VideoTrack = stjs.extend(constructor.VideoTrack, null, [SeekableDemuxerTrack], function(constructor, prototype) {
        prototype.state = null;
        prototype.trackNo = 0;
        prototype.frameIdx = 0;
        prototype.blocks = null;
        prototype.demuxer = null;
        prototype.codec = null;
        prototype.avcC = null;
        prototype.nextFrame = function() {
            if (this.frameIdx >= this.blocks.size()) 
                return null;
            var b = this.blocks.get(this.frameIdx);
            if (b == null) 
                 throw new RuntimeException("Something somewhere went wrong.");
            this.frameIdx++;
            this.demuxer.channel.setPosition(b.dataOffset);
            var data = ByteBuffer.allocate(b.dataLen);
            this.demuxer.channel.read(data);
            data.flip();
            b.readFrames(data.duplicate());
            var duration = 1;
            if (this.frameIdx < this.blocks.size()) 
                duration = this.blocks.get(this.frameIdx).absoluteTimecode - b.absoluteTimecode;
            var result = b.frames[0].duplicate();
            if (this.codec == Codec.H264) {
                result = H264Utils.decodeMOVPacket(result, this.avcC);
            }
            return Packet.createPacket(result, b.absoluteTimecode, this.demuxer.timescale, duration, this.frameIdx - 1, b._keyFrame ? Packet.FrameType.KEY : Packet.FrameType.INTER, TapeTimecode.ZERO_TAPE_TIMECODE);
        };
        prototype.gotoFrame = function(i) {
            if (i > Integer.MAX_VALUE) 
                return false;
            if (i > this.blocks.size()) 
                return false;
            this.frameIdx = ((i) | 0);
            return true;
        };
        prototype.getCurFrame = function() {
            return this.frameIdx;
        };
        prototype.seek = function(second) {
             throw new RuntimeException("Not implemented yet");
        };
        prototype.getFrameCount = function() {
            return this.blocks.size();
        };
        prototype.getCodecState = function() {
            return this.state;
        };
        prototype.getMeta = function() {
            return new DemuxerTrackMeta(TrackType.VIDEO, this.codec, 0, null, 0, this.state, VideoCodecMeta.createSimpleVideoCodecMeta(new Size(this.demuxer.pictureWidth, this.demuxer.pictureHeight), ColorSpace.YUV420), null);
        };
        prototype.gotoSyncFrame = function(i) {
             throw new RuntimeException("Unsupported");
        };
    }, {state: "ByteBuffer", blocks: {name: "List", arguments: ["MkvBlock"]}, demuxer: "MKVDemuxer", codec: "Codec", avcC: "AvcCBox"}, {});
    constructor.IndexedBlock = function() {};
    constructor.IndexedBlock = stjs.extend(constructor.IndexedBlock, null, [], function(constructor, prototype) {
        prototype.firstFrameNo = 0;
        prototype.block = null;
        constructor.make = function(no, b) {
            var ib = new MKVDemuxer.IndexedBlock();
            ib.firstFrameNo = no;
            ib.block = b;
            return ib;
        };
    }, {block: "MkvBlock"}, {});
    constructor.AudioTrack = function(trackNo, demuxer) {
        this.blocks = new ArrayList();
        this.trackNo = trackNo;
        this.demuxer = demuxer;
    };
    constructor.AudioTrack = stjs.extend(constructor.AudioTrack, null, [SeekableDemuxerTrack], function(constructor, prototype) {
        prototype.samplingFrequency = 0.0;
        prototype.trackNo = 0;
        prototype.blocks = null;
        prototype.framesCount = 0;
        prototype.frameIdx = 0;
        prototype.blockIdx = 0;
        prototype.frameInBlockIdx = 0;
        prototype.demuxer = null;
        prototype.nextFrame = function() {
            if (this.frameIdx > this.blocks.size()) 
                return null;
            var b = this.blocks.get(this.blockIdx).block;
            if (b == null) 
                 throw new RuntimeException("Something somewhere went wrong.");
            if (b.frames == null || b.frames.length == 0) {
                this.demuxer.channel.setPosition(b.dataOffset);
                var data = ByteBuffer.allocate(b.dataLen);
                this.demuxer.channel.read(data);
                b.readFrames(data);
            }
            var data = b.frames[this.frameInBlockIdx].duplicate();
            this.frameInBlockIdx++;
            this.frameIdx++;
            if (this.frameInBlockIdx >= b.frames.length) {
                this.blockIdx++;
                this.frameInBlockIdx = 0;
            }
            return Packet.createPacket(data, b.absoluteTimecode, ((Math.round(this.samplingFrequency)) | 0), 1, 0, Packet.FrameType.KEY, TapeTimecode.ZERO_TAPE_TIMECODE);
        };
        prototype.gotoFrame = function(i) {
            if (i > Integer.MAX_VALUE) 
                return false;
            if (i > this.framesCount) 
                return false;
            var frameBlockIdx = this.findBlockIndex(i);
            if (frameBlockIdx == -1) 
                return false;
            this.frameIdx = ((i) | 0);
            this.blockIdx = frameBlockIdx;
            this.frameInBlockIdx = ((i) | 0) - this.blocks.get(this.blockIdx).firstFrameNo;
            return true;
        };
        prototype.findBlockIndex = function(i) {
            for (var blockIndex = 0; blockIndex < this.blocks.size(); blockIndex++) {
                if (i < this.blocks.get(blockIndex).block.frameSizes.length) 
                    return blockIndex;
                i -= this.blocks.get(blockIndex).block.frameSizes.length;
            }
            return -1;
        };
        prototype.getCurFrame = function() {
            return this.frameIdx;
        };
        prototype.seek = function(second) {
             throw new RuntimeException("Not implemented yet");
        };
        /**
         *  Get multiple frames
         *  
         *  @param count
         *  @return
         */
        prototype.getFrames = function(count) {
            if (count + this.frameIdx >= this.framesCount) 
                return null;
            var packetFrames = new ArrayList();
            var firstBlockInAPacket = this.blocks.get(this.blockIdx).block;
             while (count > 0){
                var b = this.blocks.get(this.blockIdx).block;
                if (b.frames == null || b.frames.length == 0) {
                    try {
                        this.demuxer.channel.setPosition(b.dataOffset);
                        var data = ByteBuffer.allocate(b.dataLen);
                        this.demuxer.channel.read(data);
                        b.readFrames(data);
                    }catch (ioe) {
                         throw new RuntimeException("while reading frames of a Block at offset 0x" + Long.toHexString(b.dataOffset).toUpperCase() + ")", ioe);
                    }
                }
                packetFrames.add(b.frames[this.frameInBlockIdx].duplicate());
                this.frameIdx++;
                this.frameInBlockIdx++;
                if (this.frameInBlockIdx >= b.frames.length) {
                    this.frameInBlockIdx = 0;
                    this.blockIdx++;
                }
                count--;
            }
            var size = 0;
            for (var iterator$aFrame = packetFrames.iterator(); iterator$aFrame.hasNext(); ) {
                var aFrame = iterator$aFrame.next();
                size += aFrame.limit();
            }
            var data = ByteBuffer.allocate(size);
            for (var iterator$aFrame = packetFrames.iterator(); iterator$aFrame.hasNext(); ) {
                var aFrame = iterator$aFrame.next();
                data.putBuf(aFrame);
            }
            return Packet.createPacket(data, firstBlockInAPacket.absoluteTimecode, ((Math.round(this.samplingFrequency)) | 0), packetFrames.size(), 0, Packet.FrameType.KEY, TapeTimecode.ZERO_TAPE_TIMECODE);
        };
        prototype.getMeta = function() {
            return null;
        };
        prototype.gotoSyncFrame = function(frame) {
            return this.gotoFrame(frame);
        };
    }, {blocks: {name: "List", arguments: ["MKVDemuxer.IndexedBlock"]}, demuxer: "MKVDemuxer"}, {});
    prototype.getPictureWidth = function() {
        return this.pictureWidth;
    };
    prototype.getPictureHeight = function() {
        return this.pictureHeight;
    };
    prototype.getAudioTracks = function() {
        return this.aTracks;
    };
    prototype.getTracks = function() {
        var tracks = new ArrayList(this.aTracks);
        tracks.add(this.vTrack);
        return tracks;
    };
    prototype.getVideoTracks = function() {
        var tracks = new ArrayList();
        tracks.add(this.vTrack);
        return tracks;
    };
    prototype.getTree = function() {
        return this.t;
    };
    prototype.close = function() {
        this.channel.close();
    };
}, {vTrack: "MKVDemuxer.VideoTrack", aTracks: {name: "List", arguments: ["DemuxerTrack"]}, t: {name: "List", arguments: ["EbmlMaster"]}, channel: "SeekableByteChannel", codecMapping: {name: "Map", arguments: [null, "Codec"]}}, {});
(function() {
    MKVDemuxer.codecMapping.put("V_VP8", Codec.VP8);
    MKVDemuxer.codecMapping.put("V_VP9", Codec.VP9);
    MKVDemuxer.codecMapping.put("V_MPEG4/ISO/AVC", Codec.H264);
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A filter that removes DCT artifacts on block boundaries.
 *  
 *  It's operation is dependant on QP and is designed the way that the strenth is
 *  adjusted to the likelyhood of appearence of blocking artifacts on the
 *  specific edges.
 *  
 *  Builds a parameter for deblocking filter based on the properties of specific
 *  macroblocks.
 *  
 *  A parameter specifies the behavior of deblocking filter on each of 8 edges
 *  that need to filtered for a macroblock.
 *  
 *  For each edge the following things are evaluated on it's both sides: presence
 *  of DCT coded residual; motion vector difference; spatial location.
 *  
 *  
 *  @author The JCodec project
 *  
 */
var DeblockingFilter = function(bitDepthLuma, bitDepthChroma, di) {
    this.di = di;
};
DeblockingFilter = stjs.extend(DeblockingFilter, null, [], function(constructor, prototype) {
    constructor.alphaTab = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 5, 6, 7, 8, 9, 10, 12, 13, 15, 17, 20, 22, 25, 28, 32, 36, 40, 45, 50, 56, 63, 71, 80, 90, 101, 113, 127, 144, 162, 182, 203, 226, 255, 255]);
    constructor.betaTab = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18]);
    constructor.tcs = [new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 6, 6, 7, 8, 9, 10, 11, 13]), new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 6, 7, 8, 8, 10, 11, 12, 13, 15, 17]), new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 6, 6, 7, 8, 9, 10, 11, 13, 14, 16, 18, 20, 23, 25])];
    prototype.di = null;
    prototype.deblockFrame = function(result) {
        var color = result.getColor();
        var bsV = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(4);
        }), bsH = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(4);
        });
        for (var i = 0; i < this.di.shs.length; i++) {
            this.calcBsH(result, i, bsH);
            this.calcBsV(result, i, bsV);
            for (var c = 0; c < color.nComp; c++) {
                this.fillVerticalEdge(result, c, i, bsV);
                this.fillHorizontalEdge(result, c, i, bsH);
            }
        }
    };
    constructor.inverse = new Int32Array([0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15]);
    prototype.calcBoundaryStrenth = function(atMbBoundary, leftIntra, rightIntra, leftCoeff, rightCoeff, mvA0, mvB0, mvA1, mvB1, mbAddrA, mbAddrB) {
        if (atMbBoundary && (leftIntra || rightIntra)) 
            return 4;
         else if (leftIntra || rightIntra) 
            return 3;
         else {
            if (leftCoeff > 0 || rightCoeff > 0) 
                return 2;
            var nA = (H264Utils.Mv.mvRef(mvA0) == -1 ? 0 : 1) + (H264Utils.Mv.mvRef(mvA1) == -1 ? 0 : 1);
            var nB = (H264Utils.Mv.mvRef(mvB0) == -1 ? 0 : 1) + (H264Utils.Mv.mvRef(mvB1) == -1 ? 0 : 1);
            if (nA != nB) 
                return 1;
            var ra0 = H264Utils.Mv.mvRef(mvA0) < 0 ? null : this.di.refsUsed[mbAddrA][0][H264Utils.Mv.mvRef(mvA0)];
            var ra1 = H264Utils.Mv.mvRef(mvA1) < 0 ? null : this.di.refsUsed[mbAddrA][1][H264Utils.Mv.mvRef(mvA1)];
            var rb0 = H264Utils.Mv.mvRef(mvB0) < 0 ? null : this.di.refsUsed[mbAddrB][0][H264Utils.Mv.mvRef(mvB0)];
            var rb1 = H264Utils.Mv.mvRef(mvB1) < 0 ? null : this.di.refsUsed[mbAddrB][1][H264Utils.Mv.mvRef(mvB1)];
            if (ra0 != rb0 && ra0 != rb1 || ra1 != rb0 && ra1 != rb1 || rb0 != ra0 && rb0 != ra1 || rb1 != ra0 && rb1 != ra1) 
                return 1;
            if (ra0 == ra1 && ra1 == rb0 && rb0 == rb1) {
                return ra0 != null && (this.mvThresh(mvA0, mvB0) || this.mvThresh(mvA1, mvB0) || this.mvThresh(mvA0, mvB1) || this.mvThresh(mvA1, mvB1)) ? 1 : 0;
            } else if (ra0 == rb0 && ra1 == rb1) {
                return ra0 != null && this.mvThresh(mvA0, mvB0) || ra1 != null && this.mvThresh(mvA1, mvB1) ? 1 : 0;
            } else if (ra0 == rb1 && ra1 == rb0) {
                return ra0 != null && this.mvThresh(mvA0, mvB1) || ra1 != null && this.mvThresh(mvA1, mvB0) ? 1 : 0;
            }
        }
        return 0;
    };
    prototype.mvThresh = function(v0, v1) {
        return Math.abs(H264Utils.Mv.mvX(v0) - H264Utils.Mv.mvX(v1)) >= 4 || Math.abs(H264Utils.Mv.mvY(v0) - H264Utils.Mv.mvY(v1)) >= 4;
    };
    constructor.getIdxBeta = function(sliceBetaOffset, avgQp) {
        return MathUtil.clip(avgQp + sliceBetaOffset, 0, 51);
    };
    constructor.getIdxAlpha = function(sliceAlphaC0Offset, avgQp) {
        return MathUtil.clip(avgQp + sliceAlphaC0Offset, 0, 51);
    };
    prototype.calcBsH = function(pic, mbAddr, bs) {
        var sh = this.di.shs[mbAddr];
        var mbWidth = sh.sps.picWidthInMbsMinus1 + 1;
        var mbX = mbAddr % mbWidth;
        var mbY = stjs.trunc(mbAddr / mbWidth);
        var topAvailable = mbY > 0 && (sh.disableDeblockingFilterIdc != 2 || this.di.shs[mbAddr - mbWidth] == sh);
        var thisIntra = this.di.mbTypes[mbAddr] != null && this.di.mbTypes[mbAddr].isIntra();
        if (topAvailable) {
            var topIntra = this.di.mbTypes[mbAddr - mbWidth] != null && this.di.mbTypes[mbAddr - mbWidth].isIntra();
            for (var blkX = 0; blkX < 4; blkX++) {
                var thisBlkX = (mbX << 2) + blkX;
                var thisBlkY = (mbY << 2);
                bs[0][blkX] = this.calcBoundaryStrenth(true, topIntra, thisIntra, this.di.nCoeff[thisBlkY][thisBlkX], this.di.nCoeff[thisBlkY - 1][thisBlkX], this.di.mvs.getMv(thisBlkX, thisBlkY, 0), this.di.mvs.getMv(thisBlkX, thisBlkY - 1, 0), this.di.mvs.getMv(thisBlkX, thisBlkY, 1), this.di.mvs.getMv(thisBlkX, thisBlkY - 1, 1), mbAddr, mbAddr - mbWidth);
            }
        }
        for (var blkY = 1; blkY < 4; blkY++) {
            for (var blkX = 0; blkX < 4; blkX++) {
                var thisBlkX = (mbX << 2) + blkX;
                var thisBlkY = (mbY << 2) + blkY;
                bs[blkY][blkX] = this.calcBoundaryStrenth(false, thisIntra, thisIntra, this.di.nCoeff[thisBlkY][thisBlkX], this.di.nCoeff[thisBlkY - 1][thisBlkX], this.di.mvs.getMv(thisBlkX, thisBlkY, 0), this.di.mvs.getMv(thisBlkX, thisBlkY - 1, 0), this.di.mvs.getMv(thisBlkX, thisBlkY, 1), this.di.mvs.getMv(thisBlkX, thisBlkY - 1, 1), mbAddr, mbAddr);
            }
        }
    };
    prototype.fillHorizontalEdge = function(pic, comp, mbAddr, bs) {
        var sh = this.di.shs[mbAddr];
        var mbWidth = sh.sps.picWidthInMbsMinus1 + 1;
        var alpha = sh.sliceAlphaC0OffsetDiv2 << 1;
        var beta = sh.sliceBetaOffsetDiv2 << 1;
        var mbX = mbAddr % mbWidth;
        var mbY = stjs.trunc(mbAddr / mbWidth);
        var topAvailable = mbY > 0 && (sh.disableDeblockingFilterIdc != 2 || this.di.shs[mbAddr - mbWidth] == sh);
        var curQp = this.di.mbQps[comp][mbAddr];
        var cW = 2 - pic.getColor().compWidth[comp];
        var cH = 2 - pic.getColor().compHeight[comp];
        if (topAvailable) {
            var topQp = this.di.mbQps[comp][mbAddr - mbWidth];
            var avgQp = (topQp + curQp + 1) >> 1;
            for (var blkX = 0; blkX < 4; blkX++) {
                var thisBlkX = (mbX << 2) + blkX;
                var thisBlkY = (mbY << 2);
                this.filterBlockEdgeHoris(pic, comp, thisBlkX << cW, thisBlkY << cH, DeblockingFilter.getIdxAlpha(alpha, avgQp), DeblockingFilter.getIdxBeta(beta, avgQp), bs[0][blkX], 1 << cW);
            }
        }
        var skip4x4 = comp == 0 && this.di.tr8x8Used[mbAddr] || cH == 1;
        for (var blkY = 1; blkY < 4; blkY++) {
            if (skip4x4 && (blkY & 1) == 1) 
                continue;
            for (var blkX = 0; blkX < 4; blkX++) {
                var thisBlkX = (mbX << 2) + blkX;
                var thisBlkY = (mbY << 2) + blkY;
                this.filterBlockEdgeHoris(pic, comp, thisBlkX << cW, thisBlkY << cH, DeblockingFilter.getIdxAlpha(alpha, curQp), DeblockingFilter.getIdxBeta(beta, curQp), bs[blkY][blkX], 1 << cW);
            }
        }
    };
    prototype.calcBsV = function(pic, mbAddr, bs) {
        var sh = this.di.shs[mbAddr];
        var mbWidth = sh.sps.picWidthInMbsMinus1 + 1;
        var mbX = mbAddr % mbWidth;
        var mbY = stjs.trunc(mbAddr / mbWidth);
        var leftAvailable = mbX > 0 && (sh.disableDeblockingFilterIdc != 2 || this.di.shs[mbAddr - 1] == sh);
        var thisIntra = this.di.mbTypes[mbAddr] != null && this.di.mbTypes[mbAddr].isIntra();
        if (leftAvailable) {
            var leftIntra = this.di.mbTypes[mbAddr - 1] != null && this.di.mbTypes[mbAddr - 1].isIntra();
            for (var blkY = 0; blkY < 4; blkY++) {
                var thisBlkX = (mbX << 2);
                var thisBlkY = (mbY << 2) + blkY;
                bs[blkY][0] = this.calcBoundaryStrenth(true, leftIntra, thisIntra, this.di.nCoeff[thisBlkY][thisBlkX], this.di.nCoeff[thisBlkY][thisBlkX - 1], this.di.mvs.getMv(thisBlkX, thisBlkY, 0), this.di.mvs.getMv(thisBlkX - 1, thisBlkY, 0), this.di.mvs.getMv(thisBlkX, thisBlkY, 1), this.di.mvs.getMv(thisBlkX - 1, thisBlkY, 1), mbAddr, mbAddr - 1);
            }
        }
        for (var blkX = 1; blkX < 4; blkX++) {
            for (var blkY = 0; blkY < (1 << 2); blkY++) {
                var thisBlkX = (mbX << 2) + blkX;
                var thisBlkY = (mbY << 2) + blkY;
                bs[blkY][blkX] = this.calcBoundaryStrenth(false, thisIntra, thisIntra, this.di.nCoeff[thisBlkY][thisBlkX], this.di.nCoeff[thisBlkY][thisBlkX - 1], this.di.mvs.getMv(thisBlkX, thisBlkY, 0), this.di.mvs.getMv(thisBlkX - 1, thisBlkY, 0), this.di.mvs.getMv(thisBlkX, thisBlkY, 1), this.di.mvs.getMv(thisBlkX - 1, thisBlkY, 1), mbAddr, mbAddr);
            }
        }
    };
    prototype.fillVerticalEdge = function(pic, comp, mbAddr, bs) {
        var sh = this.di.shs[mbAddr];
        var mbWidth = sh.sps.picWidthInMbsMinus1 + 1;
        var alpha = sh.sliceAlphaC0OffsetDiv2 << 1;
        var beta = sh.sliceBetaOffsetDiv2 << 1;
        var mbX = mbAddr % mbWidth;
        var mbY = stjs.trunc(mbAddr / mbWidth);
        var leftAvailable = mbX > 0 && (sh.disableDeblockingFilterIdc != 2 || this.di.shs[mbAddr - 1] == sh);
        var curQp = this.di.mbQps[comp][mbAddr];
        var cW = 2 - pic.getColor().compWidth[comp];
        var cH = 2 - pic.getColor().compHeight[comp];
        if (leftAvailable) {
            var leftQp = this.di.mbQps[comp][mbAddr - 1];
            var avgQpV = (leftQp + curQp + 1) >> 1;
            for (var blkY = 0; blkY < 4; blkY++) {
                var thisBlkX = (mbX << 2);
                var thisBlkY = (mbY << 2) + blkY;
                this.filterBlockEdgeVert(pic, comp, thisBlkX << cW, thisBlkY << cH, DeblockingFilter.getIdxAlpha(alpha, avgQpV), DeblockingFilter.getIdxBeta(beta, avgQpV), bs[blkY][0], 1 << cH);
            }
        }
        var skip4x4 = comp == 0 && this.di.tr8x8Used[mbAddr] || cW == 1;
        for (var blkX = 1; blkX < 4; blkX++) {
            if (skip4x4 && (blkX & 1) == 1) 
                continue;
            for (var blkY = 0; blkY < 4; blkY++) {
                var thisBlkX = (mbX << 2) + blkX;
                var thisBlkY = (mbY << 2) + blkY;
                this.filterBlockEdgeVert(pic, comp, thisBlkX << cW, thisBlkY << cH, DeblockingFilter.getIdxAlpha(alpha, curQp), DeblockingFilter.getIdxBeta(beta, curQp), bs[blkY][blkX], 1 << cH);
            }
        }
    };
    prototype.filterBlockEdgeHoris = function(pic, comp, x, y, indexAlpha, indexBeta, bs, blkW) {
        var stride = pic.getPlaneWidth(comp);
        var offset = y * stride + x;
        for (var pixOff = 0; pixOff < blkW; pixOff++) {
            var p2Idx = offset - 3 * stride + pixOff;
            var p1Idx = offset - 2 * stride + pixOff;
            var p0Idx = offset - stride + pixOff;
            var q0Idx = offset + pixOff;
            var q1Idx = offset + stride + pixOff;
            var q2Idx = offset + 2 * stride + pixOff;
            if (bs == 4) {
                var p3Idx = offset - 4 * stride + pixOff;
                var q3Idx = offset + 3 * stride + pixOff;
                DeblockingFilter.filterBs4(indexAlpha, indexBeta, pic.getPlaneData(comp), pic.getPlaneData(comp), p3Idx, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, q3Idx, comp != 0);
            } else if (bs > 0) {
                DeblockingFilter.filterBs(bs, indexAlpha, indexBeta, pic.getPlaneData(comp), pic.getPlaneData(comp), p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, comp != 0);
            }
        }
    };
    prototype.filterBlockEdgeVert = function(pic, comp, x, y, indexAlpha, indexBeta, bs, blkH) {
        var stride = pic.getPlaneWidth(comp);
        for (var i = 0; i < blkH; i++) {
            var offsetQ = (y + i) * stride + x;
            var p2Idx = offsetQ - 3;
            var p1Idx = offsetQ - 2;
            var p0Idx = offsetQ - 1;
            var q0Idx = offsetQ;
            var q1Idx = offsetQ + 1;
            var q2Idx = offsetQ + 2;
            if (bs == 4) {
                var p3Idx = offsetQ - 4;
                var q3Idx = offsetQ + 3;
                DeblockingFilter.filterBs4(indexAlpha, indexBeta, pic.getPlaneData(comp), pic.getPlaneData(comp), p3Idx, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, q3Idx, comp != 0);
            } else if (bs > 0) {
                DeblockingFilter.filterBs(bs, indexAlpha, indexBeta, pic.getPlaneData(comp), pic.getPlaneData(comp), p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, comp != 0);
            }
        }
    };
    constructor.filterBs = function(bs, indexAlpha, indexBeta, pelsP, pelsQ, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, isChroma) {
        var p1 = pelsP[p1Idx];
        var p0 = pelsP[p0Idx];
        var q0 = pelsQ[q0Idx];
        var q1 = pelsQ[q1Idx];
        var alphaThresh = DeblockingFilter.alphaTab[indexAlpha];
        var betaThresh = DeblockingFilter.betaTab[indexBeta];
        var filterEnabled = Math.abs(p0 - q0) < alphaThresh && Math.abs(p1 - p0) < betaThresh && Math.abs(q1 - q0) < betaThresh;
        if (!filterEnabled) 
            return;
        var tC0 = DeblockingFilter.tcs[bs - 1][indexAlpha];
        var conditionP, conditionQ;
        var tC;
        if (!isChroma) {
            var ap = Math.abs(pelsP[p2Idx] - p0);
            var aq = Math.abs(pelsQ[q2Idx] - q0);
            tC = tC0 + ((ap < betaThresh) ? 1 : 0) + ((aq < betaThresh) ? 1 : 0);
            conditionP = ap < betaThresh;
            conditionQ = aq < betaThresh;
        } else {
            tC = tC0 + 1;
            conditionP = false;
            conditionQ = false;
        }
        var sigma = ((((q0 - p0) << 2) + (p1 - q1) + 4) >> 3);
        sigma = sigma < -tC ? -tC : (sigma > tC ? tC : sigma);
        var p0n = p0 + sigma;
        p0n = p0n < -128 ? -128 : p0n;
        var q0n = q0 - sigma;
        q0n = q0n < -128 ? -128 : q0n;
        if (conditionP) {
            var p2 = pelsP[p2Idx];
            var diff = (p2 + ((p0 + q0 + 1) >> 1) - (p1 << 1)) >> 1;
            diff = diff < -tC0 ? -tC0 : (diff > tC0 ? tC0 : diff);
            var p1n = p1 + diff;
            pelsP[p1Idx] = (MathUtil.clip(p1n, -128, 127) << 24 >> 24);
        }
        if (conditionQ) {
            var q2 = pelsQ[q2Idx];
            var diff = (q2 + ((p0 + q0 + 1) >> 1) - (q1 << 1)) >> 1;
            diff = diff < -tC0 ? -tC0 : (diff > tC0 ? tC0 : diff);
            var q1n = q1 + diff;
            pelsQ[q1Idx] = (MathUtil.clip(q1n, -128, 127) << 24 >> 24);
        }
        pelsQ[q0Idx] = (MathUtil.clip(q0n, -128, 127) << 24 >> 24);
        pelsP[p0Idx] = (MathUtil.clip(p0n, -128, 127) << 24 >> 24);
    };
    constructor.filterBs4 = function(indexAlpha, indexBeta, pelsP, pelsQ, p3Idx, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, q3Idx, isChroma) {
        var p0 = pelsP[p0Idx];
        var q0 = pelsQ[q0Idx];
        var p1 = pelsP[p1Idx];
        var q1 = pelsQ[q1Idx];
        var alphaThresh = DeblockingFilter.alphaTab[indexAlpha];
        var betaThresh = DeblockingFilter.betaTab[indexBeta];
        var filterEnabled = Math.abs(p0 - q0) < alphaThresh && Math.abs(p1 - p0) < betaThresh && Math.abs(q1 - q0) < betaThresh;
        if (!filterEnabled) 
            return;
        var conditionP, conditionQ;
        if (isChroma) {
            conditionP = false;
            conditionQ = false;
        } else {
            var ap = Math.abs(pelsP[p2Idx] - p0);
            var aq = Math.abs(pelsQ[q2Idx] - q0);
            conditionP = ap < betaThresh && Math.abs(p0 - q0) < ((alphaThresh >> 2) + 2);
            conditionQ = aq < betaThresh && Math.abs(p0 - q0) < ((alphaThresh >> 2) + 2);
        }
        if (conditionP) {
            var p3 = pelsP[p3Idx];
            var p2 = pelsP[p2Idx];
            var p0n = (p2 + 2 * p1 + 2 * p0 + 2 * q0 + q1 + 4) >> 3;
            var p1n = (p2 + p1 + p0 + q0 + 2) >> 2;
            var p2n = (2 * p3 + 3 * p2 + p1 + p0 + q0 + 4) >> 3;
            pelsP[p0Idx] = (MathUtil.clip(p0n, -128, 127) << 24 >> 24);
            pelsP[p1Idx] = (MathUtil.clip(p1n, -128, 127) << 24 >> 24);
            pelsP[p2Idx] = (MathUtil.clip(p2n, -128, 127) << 24 >> 24);
        } else {
            var p0n = (2 * p1 + p0 + q1 + 2) >> 2;
            pelsP[p0Idx] = (MathUtil.clip(p0n, -128, 127) << 24 >> 24);
        }
        if (conditionQ && !isChroma) {
            var q2 = pelsQ[q2Idx];
            var q3 = pelsQ[q3Idx];
            var q0n = (p1 + 2 * p0 + 2 * q0 + 2 * q1 + q2 + 4) >> 3;
            var q1n = (p0 + q0 + q1 + q2 + 2) >> 2;
            var q2n = (2 * q3 + 3 * q2 + q1 + q0 + p0 + 4) >> 3;
            pelsQ[q0Idx] = (MathUtil.clip(q0n, -128, 127) << 24 >> 24);
            pelsQ[q1Idx] = (MathUtil.clip(q1n, -128, 127) << 24 >> 24);
            pelsQ[q2Idx] = (MathUtil.clip(q2n, -128, 127) << 24 >> 24);
        } else {
            var q0n = (2 * q1 + q0 + p1 + 2) >> 2;
            pelsQ[q0Idx] = (MathUtil.clip(q0n, -128, 127) << 24 >> 24);
        }
    };
}, {alphaTab: "Int32Array", betaTab: "Int32Array", tcs: "Array", di: "DeblockerInput", inverse: "Int32Array"}, {});
var MP4DemuxerTrackMeta = function() {};
MP4DemuxerTrackMeta = stjs.extend(MP4DemuxerTrackMeta, null, [], function(constructor, prototype) {
    constructor.fromTrack = function(track) {
        var trak = track.getBox();
        var stss = NodeBox.findFirstPath(trak, SyncSamplesBox, Box.path("mdia.minf.stbl.stss"));
        var syncSamples = stss == null ? null : stss.getSyncSamples();
        var seekFrames;
        if (syncSamples == null) {
            seekFrames = new Int32Array(((track.getFrameCount()) | 0));
            for (var i = 0; i < seekFrames.length; i++) {
                seekFrames[i] = i;
            }
        } else {
            seekFrames = Platform.copyOfInt(syncSamples, syncSamples.length);
            for (var i = 0; i < seekFrames.length; i++) 
                seekFrames[i]--;
        }
        var type = track.getType();
        var t = type == MP4TrackType.VIDEO ? TrackType.VIDEO : (type == MP4TrackType.SOUND ? TrackType.AUDIO : TrackType.OTHER);
        var videoCodecMeta = null;
        var audioCodecMeta = null;
        if (type == MP4TrackType.VIDEO) {
            videoCodecMeta = VideoCodecMeta.createSimpleVideoCodecMeta(trak.getCodedSize(), MP4DemuxerTrackMeta.getColorInfo(track));
            var pasp = NodeBox.findFirst(track.getSampleEntries()[0], PixelAspectExt, "pasp");
            if (pasp != null) 
                videoCodecMeta.setPixelAspectRatio(pasp.getRational());
        } else if (type == MP4TrackType.SOUND) {
            var ase = track.getSampleEntries()[0];
            audioCodecMeta = AudioCodecMeta.fromAudioFormat(ase.getFormat());
        }
        var duration = track.getDuration();
        var sec = duration.getNum() / duration.getDen();
        var frameCount = Ints.checkedCast(track.getFrameCount());
        var meta = new DemuxerTrackMeta(t, Codec.codecByFourcc(track.getFourcc()), sec, seekFrames, frameCount, MP4DemuxerTrackMeta.getCodecPrivate(track), videoCodecMeta, audioCodecMeta);
        if (type == MP4TrackType.VIDEO) {
            var tkhd = NodeBox.findFirstPath(trak, TrackHeaderBox, Box.path("tkhd"));
            var orientation;
            if (tkhd.isOrientation90()) 
                orientation = DemuxerTrackMeta.Orientation.D_90;
             else if (tkhd.isOrientation180()) 
                orientation = DemuxerTrackMeta.Orientation.D_180;
             else if (tkhd.isOrientation270()) 
                orientation = DemuxerTrackMeta.Orientation.D_270;
             else 
                orientation = DemuxerTrackMeta.Orientation.D_0;
            meta.setOrientation(orientation);
        }
        return meta;
    };
    constructor.getColorInfo = function(track) {
        var codec = Codec.codecByFourcc(track.getFourcc());
        if (codec == Codec.H264) {
            var avcC = H264Utils.parseAVCC(track.getSampleEntries()[0]);
            var spsList = avcC.getSpsList();
            if (spsList.size() > 0) {
                var sps = SeqParameterSet.read(spsList.get(0).duplicate());
                return sps.getChromaFormatIdc();
            }
        }
        return null;
    };
    constructor.getCodecPrivate = function(track) {
        var codec = Codec.codecByFourcc(track.getFourcc());
        if (codec == Codec.H264) {
            var avcC = H264Utils.parseAVCC(track.getSampleEntries()[0]);
            return H264Utils.avcCToAnnexB(avcC);
        } else if (codec == Codec.AAC) {
            return AACUtils.getCodecPrivate(track.getSampleEntries()[0]);
        }
        return null;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A codec macroblock
 *  
 *  @author The JCodec project
 *  
 */
var MBlock = function(chromaFormat) {
    this.pb8x8 = new MBlock.PB8x8();
    this.pb16x16 = new MBlock.PB16x16();
    this.pb168x168 = new MBlock.PB168x168();
    this.dc = new Int32Array(16);
    this.ac = [Array.apply(null, Array(16)).map(function() {
        return new Int32Array(64);
    }), Array.apply(null, Array(4)).map(function() {
        return new Int32Array(16);
    }), Array.apply(null, Array(4)).map(function() {
        return new Int32Array(16);
    })];
    this.lumaModes = new Int32Array(16);
    this.nCoeff = new Int32Array(16);
    this.dc1 = new Int32Array((16 >> chromaFormat.compWidth[1]) >> chromaFormat.compHeight[1]);
    this.dc2 = new Int32Array((16 >> chromaFormat.compWidth[2]) >> chromaFormat.compHeight[2]);
    this.ipcm = new MBlock.IPCM(chromaFormat);
    this.x = new H264Utils.MvList(16);
    this.partPreds = Array(4);
};
MBlock = stjs.extend(MBlock, null, [], function(constructor, prototype) {
    prototype.chromaPredictionMode = 0;
    prototype.mbQPDelta = 0;
    prototype.dc = null;
    prototype.ac = null;
    prototype.transform8x8Used = false;
    prototype.lumaModes = null;
    prototype.dc1 = null;
    prototype.dc2 = null;
    prototype._cbp = 0;
    prototype.mbType = 0;
    prototype.curMbType = null;
    prototype.pb16x16 = null;
    prototype.pb168x168 = null;
    prototype.pb8x8 = null;
    prototype.ipcm = null;
    prototype.mbIdx = 0;
    prototype.fieldDecoding = false;
    prototype.prevMbType = null;
    prototype.luma16x16Mode = 0;
    prototype.x = null;
    prototype.partPreds = null;
    prototype.skipped = false;
    prototype.nCoeff = null;
    prototype.cbpLuma = function() {
        return this._cbp & 15;
    };
    prototype.cbpChroma = function() {
        return this._cbp >> 4;
    };
    prototype.cbp = function(cbpLuma, cbpChroma) {
        this._cbp = (cbpLuma & 15) | (cbpChroma << 4);
    };
    constructor.PB16x16 = function() {
        this.refIdx = new Int32Array(2);
        this.mvdX = new Int32Array(2);
        this.mvdY = new Int32Array(2);
    };
    constructor.PB16x16 = stjs.extend(constructor.PB16x16, null, [], function(constructor, prototype) {
        prototype.refIdx = null;
        prototype.mvdX = null;
        prototype.mvdY = null;
        prototype.clean = function() {
            this.refIdx[0] = this.refIdx[1] = 0;
            this.mvdX[0] = this.mvdX[1] = 0;
            this.mvdY[0] = this.mvdY[1] = 0;
        };
    }, {refIdx: "Int32Array", mvdX: "Int32Array", mvdY: "Int32Array"}, {});
    constructor.PB168x168 = function() {
        this.refIdx1 = new Int32Array(2);
        this.refIdx2 = new Int32Array(2);
        this.mvdX1 = new Int32Array(2);
        this.mvdY1 = new Int32Array(2);
        this.mvdX2 = new Int32Array(2);
        this.mvdY2 = new Int32Array(2);
    };
    constructor.PB168x168 = stjs.extend(constructor.PB168x168, null, [], function(constructor, prototype) {
        prototype.refIdx1 = null;
        prototype.refIdx2 = null;
        prototype.mvdX1 = null;
        prototype.mvdY1 = null;
        prototype.mvdX2 = null;
        prototype.mvdY2 = null;
        prototype.clean = function() {
            this.refIdx1[0] = this.refIdx1[1] = 0;
            this.refIdx2[0] = this.refIdx2[1] = 0;
            this.mvdX1[0] = this.mvdX1[1] = 0;
            this.mvdY1[0] = this.mvdY1[1] = 0;
            this.mvdX2[0] = this.mvdX2[1] = 0;
            this.mvdY2[0] = this.mvdY2[1] = 0;
        };
    }, {refIdx1: "Int32Array", refIdx2: "Int32Array", mvdX1: "Int32Array", mvdY1: "Int32Array", mvdX2: "Int32Array", mvdY2: "Int32Array"}, {});
    constructor.PB8x8 = function() {
        this.refIdx = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
        this.subMbTypes = new Int32Array(4);
        this.mvdX1 = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
        this.mvdY1 = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
        this.mvdX2 = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
        this.mvdY2 = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
        this.mvdX3 = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
        this.mvdY3 = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
        this.mvdX4 = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
        this.mvdY4 = Array.apply(null, Array(2)).map(function() {
            return new Int32Array(4);
        });
    };
    constructor.PB8x8 = stjs.extend(constructor.PB8x8, null, [], function(constructor, prototype) {
        prototype.refIdx = null;
        prototype.subMbTypes = null;
        prototype.mvdX1 = null;
        prototype.mvdY1 = null;
        prototype.mvdX2 = null;
        prototype.mvdY2 = null;
        prototype.mvdX3 = null;
        prototype.mvdY3 = null;
        prototype.mvdX4 = null;
        prototype.mvdY4 = null;
        prototype.clean = function() {
            this.mvdX1[0][0] = this.mvdX1[0][1] = this.mvdX1[0][2] = this.mvdX1[0][3] = 0;
            this.mvdX2[0][0] = this.mvdX2[0][1] = this.mvdX2[0][2] = this.mvdX2[0][3] = 0;
            this.mvdX3[0][0] = this.mvdX3[0][1] = this.mvdX3[0][2] = this.mvdX3[0][3] = 0;
            this.mvdX4[0][0] = this.mvdX4[0][1] = this.mvdX4[0][2] = this.mvdX4[0][3] = 0;
            this.mvdY1[0][0] = this.mvdY1[0][1] = this.mvdY1[0][2] = this.mvdY1[0][3] = 0;
            this.mvdY2[0][0] = this.mvdY2[0][1] = this.mvdY2[0][2] = this.mvdY2[0][3] = 0;
            this.mvdY3[0][0] = this.mvdY3[0][1] = this.mvdY3[0][2] = this.mvdY3[0][3] = 0;
            this.mvdY4[0][0] = this.mvdY4[0][1] = this.mvdY4[0][2] = this.mvdY4[0][3] = 0;
            this.mvdX1[1][0] = this.mvdX1[1][1] = this.mvdX1[1][2] = this.mvdX1[1][3] = 0;
            this.mvdX2[1][0] = this.mvdX2[1][1] = this.mvdX2[1][2] = this.mvdX2[1][3] = 0;
            this.mvdX3[1][0] = this.mvdX3[1][1] = this.mvdX3[1][2] = this.mvdX3[1][3] = 0;
            this.mvdX4[1][0] = this.mvdX4[1][1] = this.mvdX4[1][2] = this.mvdX4[1][3] = 0;
            this.mvdY1[1][0] = this.mvdY1[1][1] = this.mvdY1[1][2] = this.mvdY1[1][3] = 0;
            this.mvdY2[1][0] = this.mvdY2[1][1] = this.mvdY2[1][2] = this.mvdY2[1][3] = 0;
            this.mvdY3[1][0] = this.mvdY3[1][1] = this.mvdY3[1][2] = this.mvdY3[1][3] = 0;
            this.mvdY4[1][0] = this.mvdY4[1][1] = this.mvdY4[1][2] = this.mvdY4[1][3] = 0;
            this.subMbTypes[0] = this.subMbTypes[1] = this.subMbTypes[2] = this.subMbTypes[3] = 0;
            this.refIdx[0][0] = this.refIdx[0][1] = this.refIdx[0][2] = this.refIdx[0][3] = 0;
            this.refIdx[1][0] = this.refIdx[1][1] = this.refIdx[1][2] = this.refIdx[1][3] = 0;
        };
    }, {refIdx: "Array", subMbTypes: "Int32Array", mvdX1: "Array", mvdY1: "Array", mvdX2: "Array", mvdY2: "Array", mvdX3: "Array", mvdY3: "Array", mvdX4: "Array", mvdY4: "Array"}, {});
    constructor.IPCM = function(chromaFormat) {
        this.samplesLuma = new Int32Array(256);
        var MbWidthC = 16 >> chromaFormat.compWidth[1];
        var MbHeightC = 16 >> chromaFormat.compHeight[1];
        this.samplesChroma = new Int32Array(2 * MbWidthC * MbHeightC);
    };
    constructor.IPCM = stjs.extend(constructor.IPCM, null, [], function(constructor, prototype) {
        prototype.samplesLuma = null;
        prototype.samplesChroma = null;
        prototype.clean = function() {
            Arrays.fill(this.samplesLuma, 0);
            Arrays.fill(this.samplesChroma, 0);
        };
    }, {samplesLuma: "Int32Array", samplesChroma: "Int32Array"}, {});
    prototype.clear = function() {
        this.chromaPredictionMode = 0;
        this.mbQPDelta = 0;
        Arrays.fill(this.dc, 0);
        for (var i = 0; i < this.ac.length; i++) {
            var aci = this.ac[i];
            for (var j = 0; j < aci.length; j++) {
                Arrays.fill(aci[j], 0);
            }
        }
        this.transform8x8Used = false;
        Arrays.fill(this.lumaModes, 0);
        Arrays.fill(this.dc1, 0);
        Arrays.fill(this.dc2, 0);
        Arrays.fill(this.nCoeff, 0);
        this._cbp = 0;
        this.mbType = 0;
        this.pb16x16.clean();
        this.pb168x168.clean();
        this.pb8x8.clean();
        if (this.curMbType == MBType.I_PCM) 
            this.ipcm.clean();
        this.mbIdx = 0;
        this.fieldDecoding = false;
        this.prevMbType = null;
        this.luma16x16Mode = 0;
        this.skipped = false;
        this.curMbType = null;
        this.x.clear();
        this.partPreds[0] = this.partPreds[1] = this.partPreds[2] = this.partPreds[3] = null;
    };
}, {dc: "Int32Array", ac: "Array", lumaModes: "Int32Array", dc1: "Int32Array", dc2: "Int32Array", curMbType: "MBType", pb16x16: "MBlock.PB16x16", pb168x168: "MBlock.PB168x168", pb8x8: "MBlock.PB8x8", ipcm: "MBlock.IPCM", prevMbType: "MBType", x: "H264Utils.MvList", partPreds: "Array", nCoeff: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Base macroblock decoder that contains routines shared by many decoders
 *  
 *  @author The JCodec project
 *  
 */
var MBlockDecoderBase = function(sh, di, poc, decoderState) {
    this.interpolator = new BlockInterpolator();
    this.s = decoderState;
    this.sh = sh;
    this.di = di;
    this.poc = poc;
    this.mbb = [Picture.create(16, 16, this.s.chromaFormat), Picture.create(16, 16, this.s.chromaFormat)];
    this.scalingMatrix = MBlockDecoderBase.initScalingMatrix(sh);
};
MBlockDecoderBase = stjs.extend(MBlockDecoderBase, null, [], function(constructor, prototype) {
    prototype.s = null;
    prototype.sh = null;
    prototype.di = null;
    prototype.poc = 0;
    prototype.interpolator = null;
    prototype.mbb = null;
    prototype.scalingMatrix = null;
    prototype.residualLuma = function(mBlock, leftAvailable, topAvailable, mbX, mbY) {
        if (!mBlock.transform8x8Used) {
            this.residualLuma4x4(mBlock);
        } else if (this.sh.pps.entropyCodingModeFlag) {
            this.residualLuma8x8CABAC(mBlock);
        } else {
            this.residualLuma8x8CAVLC(mBlock);
        }
    };
    prototype.residualLuma4x4 = function(mBlock) {
        for (var i = 0; i < 16; i++) {
            if ((mBlock.cbpLuma() & (1 << (i >> 2))) == 0) {
                continue;
            }
            CoeffTransformer.dequantizeAC(mBlock.ac[0][i], this.s.qp, this.getScalingList(mBlock.curMbType.intra ? 0 : 3));
            CoeffTransformer.idct4x4(mBlock.ac[0][i]);
        }
    };
    prototype.getScalingList = function(which) {
        if (this.scalingMatrix == null) 
            return null;
        return this.scalingMatrix[which];
    };
    constructor.initScalingMatrix = function(sh2) {
        if (sh2.sps.scalingMatrix == null && (sh2.pps.extended == null || sh2.pps.extended.scalingMatrix == null)) 
            return null;
        var merged = [H264Const.defaultScalingList4x4Intra, null, null, H264Const.defaultScalingList4x4Inter, null, null, H264Const.defaultScalingList8x8Intra, H264Const.defaultScalingList8x8Inter, null, null, null, null];
        for (var i = 0; i < 8; i++) {
            if (sh2.sps.scalingMatrix != null && sh2.sps.scalingMatrix[i] != null) 
                merged[i] = sh2.sps.scalingMatrix[i];
            if (sh2.pps.extended != null && sh2.pps.extended.scalingMatrix != null && sh2.pps.extended.scalingMatrix[i] != null) 
                merged[i] = sh2.pps.extended.scalingMatrix[i];
        }
        if (merged[1] == null) 
            merged[1] = merged[0];
        if (merged[2] == null) 
            merged[2] = merged[0];
        if (merged[4] == null) 
            merged[4] = merged[3];
        if (merged[5] == null) 
            merged[5] = merged[3];
        if (merged[8] == null) 
            merged[8] = merged[6];
        if (merged[10] == null) 
            merged[10] = merged[6];
        if (merged[9] == null) 
            merged[9] = merged[7];
        if (merged[11] == null) 
            merged[11] = merged[7];
        return merged;
    };
    prototype.residualLuma8x8CABAC = function(mBlock) {
        for (var i = 0; i < 4; i++) {
            if ((mBlock.cbpLuma() & (1 << i)) == 0) {
                continue;
            }
            CoeffTransformer.dequantizeAC8x8(mBlock.ac[0][i], this.s.qp, this.getScalingList(mBlock.curMbType.intra ? 6 : 7));
            CoeffTransformer.idct8x8(mBlock.ac[0][i]);
        }
    };
    prototype.residualLuma8x8CAVLC = function(mBlock) {
        for (var i = 0; i < 4; i++) {
            if ((mBlock.cbpLuma() & (1 << i)) == 0) {
                continue;
            }
            CoeffTransformer.dequantizeAC8x8(mBlock.ac[0][i], this.s.qp, this.getScalingList(mBlock.curMbType.intra ? 6 : 7));
            CoeffTransformer.idct8x8(mBlock.ac[0][i]);
        }
    };
    prototype.decodeChroma = function(mBlock, mbX, mbY, leftAvailable, topAvailable, mb, qp) {
        if (this.s.chromaFormat == ColorSpace.MONO) {
            Arrays.fill(mb.getPlaneData(1), (0 << 24 >> 24));
            Arrays.fill(mb.getPlaneData(2), (0 << 24 >> 24));
            return;
        }
        var qp1 = MBlockDecoderBase.calcQpChroma(qp, this.s.chromaQpOffset[0]);
        var qp2 = MBlockDecoderBase.calcQpChroma(qp, this.s.chromaQpOffset[1]);
        if (mBlock.cbpChroma() != 0) {
            this.decodeChromaResidual(mBlock, leftAvailable, topAvailable, mbX, mbY, qp1, qp2);
        }
        var addr = mbY * (this.sh.sps.picWidthInMbsMinus1 + 1) + mbX;
        this.di.mbQps[1][addr] = qp1;
        this.di.mbQps[2][addr] = qp2;
        ChromaPredictionBuilder.predictWithMode(mBlock.ac[1], mBlock.chromaPredictionMode, mbX, leftAvailable, topAvailable, this.s.leftRow[1], this.s.topLine[1], this.s.topLeft[1], mb.getPlaneData(1));
        ChromaPredictionBuilder.predictWithMode(mBlock.ac[2], mBlock.chromaPredictionMode, mbX, leftAvailable, topAvailable, this.s.leftRow[2], this.s.topLine[2], this.s.topLeft[2], mb.getPlaneData(2));
    };
    prototype.decodeChromaResidual = function(mBlock, leftAvailable, topAvailable, mbX, mbY, crQp1, crQp2) {
        if (mBlock.cbpChroma() != 0) {
            if ((mBlock.cbpChroma() & 3) > 0) {
                this.chromaDC(mbX, leftAvailable, topAvailable, mBlock.dc1, 1, crQp1, mBlock.curMbType);
                this.chromaDC(mbX, leftAvailable, topAvailable, mBlock.dc2, 2, crQp2, mBlock.curMbType);
            }
            this.chromaAC(leftAvailable, topAvailable, mbX, mbY, mBlock.dc1, 1, crQp1, mBlock.curMbType, (mBlock.cbpChroma() & 2) > 0, mBlock.ac[1]);
            this.chromaAC(leftAvailable, topAvailable, mbX, mbY, mBlock.dc2, 2, crQp2, mBlock.curMbType, (mBlock.cbpChroma() & 2) > 0, mBlock.ac[2]);
        }
    };
    prototype.chromaDC = function(mbX, leftAvailable, topAvailable, dc, comp, crQp, curMbType) {
        CoeffTransformer.invDC2x2(dc);
        CoeffTransformer.dequantizeDC2x2(dc, crQp, this.getScalingList((curMbType.intra ? 6 : 7) + comp * 2));
    };
    prototype.chromaAC = function(leftAvailable, topAvailable, mbX, mbY, dc, comp, crQp, curMbType, codedAC, residualOut) {
        for (var i = 0; i < dc.length; i++) {
            var ac = residualOut[i];
            if (codedAC) {
                CoeffTransformer.dequantizeAC(ac, crQp, this.getScalingList((curMbType.intra ? 0 : 3) + comp));
            }
            ac[0] = dc[i];
            CoeffTransformer.idct4x4(ac);
        }
    };
    constructor.calcQpChroma = function(qp, crQpOffset) {
        return H264Const.QP_SCALE_CR[MathUtil.clip(qp + crQpOffset, 0, 51)];
    };
    prototype.predictChromaInter = function(refs, vectors, x, y, comp, mb, predType) {
        for (var blk8x8 = 0; blk8x8 < 4; blk8x8++) {
            for (var list = 0; list < 2; list++) {
                if (!H264Const.usesList(predType[blk8x8], list)) 
                    continue;
                for (var blk4x4 = 0; blk4x4 < 4; blk4x4++) {
                    var i = H264Const.BLK_INV_MAP[(blk8x8 << 2) + blk4x4];
                    var mv = vectors.getMv(i, list);
                    var ref = refs[list][H264Utils.Mv.mvRef(mv)];
                    var blkPox = (i & 3) << 1;
                    var blkPoy = (i >> 2) << 1;
                    var xx = ((x + blkPox) << 3) + H264Utils.Mv.mvX(mv);
                    var yy = ((y + blkPoy) << 3) + H264Utils.Mv.mvY(mv);
                    BlockInterpolator.getBlockChroma(ref.getPlaneData(comp), ref.getPlaneWidth(comp), ref.getPlaneHeight(comp), this.mbb[list].getPlaneData(comp), blkPoy * mb.getPlaneWidth(comp) + blkPox, mb.getPlaneWidth(comp), xx, yy, 2, 2);
                }
            }
            var blk4x4 = H264Const.BLK8x8_BLOCKS[blk8x8][0];
            PredictionMerger.mergePrediction(this.sh, vectors.mv0R(blk4x4), vectors.mv1R(blk4x4), predType[blk8x8], comp, this.mbb[0].getPlaneData(comp), this.mbb[1].getPlaneData(comp), H264Const.BLK_8x8_MB_OFF_CHROMA[blk8x8], mb.getPlaneWidth(comp), 4, 4, mb.getPlaneData(comp), refs, this.poc);
        }
    };
}, {s: "DecoderState", sh: "SliceHeader", di: "DeblockerInput", interpolator: "BlockInterpolator", mbb: "Array", scalingMatrix: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Current state of the decoder, this data is accessed from many methods
 *  
 *  @author The JCodec project
 *  
 */
var DecoderState = function(sh) {
    var mbWidth = sh.sps.picWidthInMbsMinus1 + 1;
    this.chromaQpOffset = new Int32Array([sh.pps.chromaQpIndexOffset, sh.pps.extended != null ? sh.pps.extended.secondChromaQpIndexOffset : sh.pps.chromaQpIndexOffset]);
    this.chromaFormat = sh.sps.chromaFormatIdc;
    this.mvTop = new H264Utils.MvList((mbWidth << 2) + 1);
    this.mvLeft = new H264Utils.MvList(4);
    this.mvTopLeft = new H264Utils.MvList(1);
    this.leftRow = Array.apply(null, Array(3)).map(function() {
        return new Int8Array(16);
    });
    this.topLeft = Array.apply(null, Array(3)).map(function() {
        return new Int8Array(4);
    });
    this.topLine = Array.apply(null, Array(3)).map(function() {
        return new Int8Array(mbWidth << 4);
    });
    this.qp = sh.pps.picInitQpMinus26 + 26 + sh.sliceQpDelta;
};
DecoderState = stjs.extend(DecoderState, null, [], function(constructor, prototype) {
    prototype.chromaQpOffset = null;
    prototype.qp = 0;
    prototype.leftRow = null;
    prototype.topLine = null;
    prototype.topLeft = null;
    prototype.chromaFormat = null;
    prototype.mvTop = null;
    prototype.mvLeft = null;
    prototype.mvTopLeft = null;
}, {chromaQpOffset: "Int32Array", leftRow: "Array", topLine: "Array", topLeft: "Array", chromaFormat: "ColorSpace", mvTop: "H264Utils.MvList", mvLeft: "H264Utils.MvList", mvTopLeft: "H264Utils.MvList"}, {});
var DumpMvFilter = function(js) {
    this.js = js;
};
DumpMvFilter = stjs.extend(DumpMvFilter, null, [Filter], function(constructor, prototype) {
    prototype.js = false;
    prototype.filter = function(picture, pixelStore) {
        var dec = picture;
        if (!this.js) 
            this.dumpMvTxt(dec);
         else 
            this.dumpMvJs(dec);
        return null;
    };
    prototype.dumpMvTxt = function(dec) {
        System.err.println("FRAME ================================================================");
        if (dec.getFrameType() == SliceType.I) 
            return;
        var mvs = dec.getMvs();
        for (var i = 0; i < 2; i++) {
            System.err.println((i == 0 ? "BCK" : "FWD") + " ===========================================================================");
            for (var blkY = 0; blkY < mvs.getHeight(); ++blkY) {
                var line0 = new StringBuilder();
                var line1 = new StringBuilder();
                var line2 = new StringBuilder();
                var line3 = new StringBuilder();
                line0.append("+");
                line1.append("|");
                line2.append("|");
                line3.append("|");
                for (var blkX = 0; blkX < mvs.getWidth(); ++blkX) {
                    line0.append("------+");
                    line1.append(String.format("%6d|", H264Utils.Mv.mvX(mvs.getMv(blkX, blkY, i))));
                    line2.append(String.format("%6d|", H264Utils.Mv.mvY(mvs.getMv(blkX, blkY, i))));
                    line3.append(String.format("    %2d|", H264Utils.Mv.mvRef(mvs.getMv(blkX, blkY, i))));
                }
                System.err.println(line0.toString());
                System.err.println(line1.toString());
                System.err.println(line2.toString());
                System.err.println(line3.toString());
            }
            if (dec.getFrameType() != SliceType.B) 
                break;
        }
    };
    prototype.dumpMvJs = function(dec) {
        System.err.println("{");
        if (dec.getFrameType() == SliceType.I) 
            return;
        var mvs = dec.getMvs();
        for (var i = 0; i < 2; i++) {
            System.err.println((i == 0 ? "backRef" : "forwardRef") + ": [");
            for (var blkY = 0; blkY < mvs.getHeight(); ++blkY) {
                for (var blkX = 0; blkX < mvs.getWidth(); ++blkX) {
                    System.err.println("{x: " + blkX + ", y: " + blkY + ", mx: " + H264Utils.Mv.mvX(mvs.getMv(blkX, blkY, i)) + ", my: " + H264Utils.Mv.mvY(mvs.getMv(blkX, blkY, i)) + ", ridx:" + H264Utils.Mv.mvRef(mvs.getMv(blkX, blkY, i)) + "},");
                }
            }
            System.err.println("],");
            if (dec.getFrameType() != SliceType.B) 
                break;
        }
        System.err.println("}");
    };
    prototype.getInputColor = function() {
        return null;
    };
    prototype.getOutputColor = function() {
        return null;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Extracts H.264 frames out H.264 Elementary stream ( according to Annex B )
 *  
 *  @author The JCodec project
 *  
 */
var BufferH264ES = function(bb) {
    this.pps = new IntObjectMap();
    this.sps = new IntObjectMap();
    this.bb = bb;
    this.frameNo = 0;
};
BufferH264ES = stjs.extend(BufferH264ES, null, [DemuxerTrack, Demuxer], function(constructor, prototype) {
    prototype.bb = null;
    prototype.pps = null;
    prototype.sps = null;
    prototype.prevFrameNumOffset = 0;
    prototype.prevFrameNum = 0;
    prototype.prevPicOrderCntMsb = 0;
    prototype.prevPicOrderCntLsb = 0;
    prototype.frameNo = 0;
    prototype.nextFrame = function() {
        var result = this.bb.duplicate();
        var prevNu = null;
        var prevSh = null;
         while (true){
            this.bb.mark();
            var buf = H264Utils.nextNALUnit(this.bb);
            if (buf == null) 
                break;
            var nu = NALUnit.read(buf);
            if (nu.type == NALUnitType.IDR_SLICE || nu.type == NALUnitType.NON_IDR_SLICE) {
                var sh = this.readSliceHeader(buf, nu);
                if (prevNu != null && prevSh != null && !this.sameFrame(prevNu, nu, prevSh, sh)) {
                    this.bb.reset();
                    break;
                }
                prevSh = sh;
                prevNu = nu;
            } else if (nu.type == NALUnitType.PPS) {
                var read = PictureParameterSet.read(buf);
                this.pps.put(read.picParameterSetId, read);
            } else if (nu.type == NALUnitType.SPS) {
                var read = SeqParameterSet.read(buf);
                this.sps.put(read.seqParameterSetId, read);
            }
        }
        result.setLimit(this.bb.position());
        return prevSh == null ? null : this.detectPoc(result, prevNu, prevSh);
    };
    prototype.readSliceHeader = function(buf, nu) {
        var br = BitReader.createBitReader(buf);
        var sh = SliceHeaderReader.readPart1(br);
        var pp = this.pps.get(sh.picParameterSetId);
        SliceHeaderReader.readPart2(sh, nu, this.sps.get(pp.seqParameterSetId), pp, br);
        return sh;
    };
    prototype.sameFrame = function(nu1, nu2, sh1, sh2) {
        if (sh1.picParameterSetId != sh2.picParameterSetId) 
            return false;
        if (sh1.frameNum != sh2.frameNum) 
            return false;
        var sps = sh1.sps;
        if (sps.picOrderCntType == 0 && sh1.picOrderCntLsb != sh2.picOrderCntLsb) 
            return false;
        if (sps.picOrderCntType == 1 && (sh1.deltaPicOrderCnt[0] != sh2.deltaPicOrderCnt[0] || sh1.deltaPicOrderCnt[1] != sh2.deltaPicOrderCnt[1])) 
            return false;
        if ((nu1.nal_ref_idc == 0 || nu2.nal_ref_idc == 0) && nu1.nal_ref_idc != nu2.nal_ref_idc) 
            return false;
        if ((nu1.type == NALUnitType.IDR_SLICE) != (nu2.type == NALUnitType.IDR_SLICE)) 
            return false;
        if (sh1.idrPicId != sh2.idrPicId) 
            return false;
        return true;
    };
    prototype.detectPoc = function(result, nu, sh) {
        var maxFrameNum = 1 << (sh.sps.log2MaxFrameNumMinus4 + 4);
        if (this.detectGap(sh, maxFrameNum)) {
            this.issueNonExistingPic(sh, maxFrameNum);
        }
        var absFrameNum = this.updateFrameNumber(sh.frameNum, maxFrameNum, this.detectMMCO5(sh.refPicMarkingNonIDR));
        var poc = 0;
        if (nu.type == NALUnitType.NON_IDR_SLICE) {
            poc = this.calcPoc(absFrameNum, nu, sh);
        }
        return new Packet(result, absFrameNum, 1, 1, this.frameNo++, nu.type == NALUnitType.IDR_SLICE ? Packet.FrameType.KEY : Packet.FrameType.INTER, null, poc);
    };
    prototype.updateFrameNumber = function(frameNo, maxFrameNum, mmco5) {
        var frameNumOffset;
        if (this.prevFrameNum > frameNo) 
            frameNumOffset = this.prevFrameNumOffset + maxFrameNum;
         else 
            frameNumOffset = this.prevFrameNumOffset;
        var absFrameNum = frameNumOffset + frameNo;
        this.prevFrameNum = mmco5 ? 0 : frameNo;
        this.prevFrameNumOffset = frameNumOffset;
        return absFrameNum;
    };
    prototype.issueNonExistingPic = function(sh, maxFrameNum) {
        var nextFrameNum = (this.prevFrameNum + 1) % maxFrameNum;
        this.prevFrameNum = nextFrameNum;
    };
    prototype.detectGap = function(sh, maxFrameNum) {
        return sh.frameNum != this.prevFrameNum && sh.frameNum != ((this.prevFrameNum + 1) % maxFrameNum);
    };
    prototype.calcPoc = function(absFrameNum, nu, sh) {
        if (sh.sps.picOrderCntType == 0) {
            return this.calcPOC0(nu, sh);
        } else if (sh.sps.picOrderCntType == 1) {
            return this.calcPOC1(absFrameNum, nu, sh);
        } else {
            return this.calcPOC2(absFrameNum, nu, sh);
        }
    };
    prototype.calcPOC2 = function(absFrameNum, nu, sh) {
        if (nu.nal_ref_idc == 0) 
            return 2 * absFrameNum - 1;
         else 
            return 2 * absFrameNum;
    };
    prototype.calcPOC1 = function(absFrameNum, nu, sh) {
        if (sh.sps.numRefFramesInPicOrderCntCycle == 0) 
            absFrameNum = 0;
        if (nu.nal_ref_idc == 0 && absFrameNum > 0) 
            absFrameNum = absFrameNum - 1;
        var expectedDeltaPerPicOrderCntCycle = 0;
        for (var i = 0; i < sh.sps.numRefFramesInPicOrderCntCycle; i++) 
            expectedDeltaPerPicOrderCntCycle += sh.sps.offsetForRefFrame[i];
        var expectedPicOrderCnt;
        if (absFrameNum > 0) {
            var picOrderCntCycleCnt = stjs.trunc((absFrameNum - 1) / sh.sps.numRefFramesInPicOrderCntCycle);
            var frameNumInPicOrderCntCycle = (absFrameNum - 1) % sh.sps.numRefFramesInPicOrderCntCycle;
            expectedPicOrderCnt = picOrderCntCycleCnt * expectedDeltaPerPicOrderCntCycle;
            for (var i = 0; i <= frameNumInPicOrderCntCycle; i++) 
                expectedPicOrderCnt = expectedPicOrderCnt + sh.sps.offsetForRefFrame[i];
        } else {
            expectedPicOrderCnt = 0;
        }
        if (nu.nal_ref_idc == 0) 
            expectedPicOrderCnt = expectedPicOrderCnt + sh.sps.offsetForNonRefPic;
        return expectedPicOrderCnt + sh.deltaPicOrderCnt[0];
    };
    prototype.calcPOC0 = function(nu, sh) {
        var pocCntLsb = sh.picOrderCntLsb;
        var maxPicOrderCntLsb = 1 << (sh.sps.log2MaxPicOrderCntLsbMinus4 + 4);
        var picOrderCntMsb;
        if ((pocCntLsb < this.prevPicOrderCntLsb) && ((this.prevPicOrderCntLsb - pocCntLsb) >= (stjs.trunc(maxPicOrderCntLsb / 2)))) 
            picOrderCntMsb = this.prevPicOrderCntMsb + maxPicOrderCntLsb;
         else if ((pocCntLsb > this.prevPicOrderCntLsb) && ((pocCntLsb - this.prevPicOrderCntLsb) > (stjs.trunc(maxPicOrderCntLsb / 2)))) 
            picOrderCntMsb = this.prevPicOrderCntMsb - maxPicOrderCntLsb;
         else 
            picOrderCntMsb = this.prevPicOrderCntMsb;
        if (nu.nal_ref_idc != 0) {
            this.prevPicOrderCntMsb = picOrderCntMsb;
            this.prevPicOrderCntLsb = pocCntLsb;
        }
        return picOrderCntMsb + pocCntLsb;
    };
    prototype.detectMMCO5 = function(refPicMarkingNonIDR) {
        if (refPicMarkingNonIDR == null) 
            return false;
        var instructions = refPicMarkingNonIDR.getInstructions();
        for (var i = 0; i < instructions.length; i++) {
            var instr = instructions[i];
            if (instr.getType() == RefPicMarking.InstrType.CLEAR) {
                return true;
            }
        }
        return false;
    };
    prototype.getSps = function() {
        return this.sps.values(Array(0));
    };
    prototype.getPps = function() {
        return this.pps.values(Array(0));
    };
    prototype.getMeta = function() {
        return null;
    };
    prototype.close = function() {};
    prototype.getTracks = function() {
        return this.getVideoTracks();
    };
    prototype.getVideoTracks = function() {
        var tracks = new ArrayList();
        tracks.add(this);
        return tracks;
    };
    prototype.getAudioTracks = function() {
        var tracks = new ArrayList();
        return tracks;
    };
}, {bb: "ByteBuffer", pps: {name: "IntObjectMap", arguments: ["PictureParameterSet"]}, sps: {name: "IntObjectMap", arguments: ["SeqParameterSet"]}}, {});
var MBlockDecoderUtils = function() {};
MBlockDecoderUtils = stjs.extend(MBlockDecoderUtils, null, [], function(constructor, prototype) {
    constructor.debug = false;
    constructor.NULL_VECTOR = H264Utils.Mv.packMv(0, 0, -1);
    constructor.debugPrint = function(_arguments) {
        if (MBlockDecoderUtils.debug && arguments.length > 0) {
            if (arguments.length == 1) {
                Logger.debug("" + arguments[0]);
            } else {
                var fmt = arguments[0];
                ArrayUtil.shiftLeft1(arguments);
                Logger.debug(String.format(fmt, arguments));
            }
        }
    };
    constructor.collectPredictors = function(sharedState, outMB, mbX) {
        sharedState.topLeft[0][0] = sharedState.topLine[0][(mbX << 4) + 15];
        sharedState.topLeft[0][1] = outMB.getPlaneData(0)[63];
        sharedState.topLeft[0][2] = outMB.getPlaneData(0)[127];
        sharedState.topLeft[0][3] = outMB.getPlaneData(0)[191];
        System.arraycopy(outMB.getPlaneData(0), 240, sharedState.topLine[0], mbX << 4, 16);
        MBlockDecoderUtils.copyCol(outMB.getPlaneData(0), 16, 15, 16, sharedState.leftRow[0]);
        MBlockDecoderUtils.collectChromaPredictors(sharedState, outMB, mbX);
    };
    constructor.collectChromaPredictors = function(sharedState, outMB, mbX) {
        sharedState.topLeft[1][0] = sharedState.topLine[1][(mbX << 3) + 7];
        sharedState.topLeft[2][0] = sharedState.topLine[2][(mbX << 3) + 7];
        System.arraycopy(outMB.getPlaneData(1), 56, sharedState.topLine[1], mbX << 3, 8);
        System.arraycopy(outMB.getPlaneData(2), 56, sharedState.topLine[2], mbX << 3, 8);
        MBlockDecoderUtils.copyCol(outMB.getPlaneData(1), 8, 7, 8, sharedState.leftRow[1]);
        MBlockDecoderUtils.copyCol(outMB.getPlaneData(2), 8, 7, 8, sharedState.leftRow[2]);
    };
    constructor.copyCol = function(planeData, n, off, stride, out) {
        for (var i = 0; i < n; i++ , off += stride) {
            out[i] = planeData[off];
        }
    };
    constructor.saveMvsIntra = function(di, mbX, mbY) {
        for (var j = 0, blkOffY = mbY << 2, blkInd = 0; j < 4; j++ , blkOffY++) {
            for (var i = 0, blkOffX = mbX << 2; i < 4; i++ , blkOffX++ , blkInd++) {
                di.mvs.setMv(blkOffX, blkOffY, 0, MBlockDecoderUtils.NULL_VECTOR);
                di.mvs.setMv(blkOffX, blkOffY, 1, MBlockDecoderUtils.NULL_VECTOR);
            }
        }
    };
    constructor.mergeResidual = function(mb, residual, blockLUT, posLUT) {
        for (var comp = 0; comp < 3; comp++) {
            var to = mb.getPlaneData(comp);
            for (var i = 0; i < to.length; i++) {
                to[i] = (MathUtil.clip(to[i] + residual[comp][blockLUT[comp][i]][posLUT[comp][i]], -128, 127) << 24 >> 24);
            }
        }
    };
    constructor.saveVect = function(mv, list, from, to, vect) {
        for (var i = from; i < to; i++) {
            mv.setMv(i, list, vect);
        }
    };
    /**
     *  Calculates median prediction 
     *  @param a, b, c and d are packed motion vectors
     */
    constructor.calcMVPredictionMedian = function(a, b, c, d, aAvb, bAvb, cAvb, dAvb, ref, comp) {
        if (!cAvb) {
            c = d;
            cAvb = dAvb;
        }
        if (aAvb && !bAvb && !cAvb) {
            b = c = a;
            bAvb = cAvb = aAvb;
        }
        a = aAvb ? a : MBlockDecoderUtils.NULL_VECTOR;
        b = bAvb ? b : MBlockDecoderUtils.NULL_VECTOR;
        c = cAvb ? c : MBlockDecoderUtils.NULL_VECTOR;
        if (H264Utils.Mv.mvRef(a) == ref && H264Utils.Mv.mvRef(b) != ref && H264Utils.Mv.mvRef(c) != ref) 
            return H264Utils.Mv.mvC(a, comp);
         else if (H264Utils.Mv.mvRef(b) == ref && H264Utils.Mv.mvRef(a) != ref && H264Utils.Mv.mvRef(c) != ref) 
            return H264Utils.Mv.mvC(b, comp);
         else if (H264Utils.Mv.mvRef(c) == ref && H264Utils.Mv.mvRef(a) != ref && H264Utils.Mv.mvRef(b) != ref) 
            return H264Utils.Mv.mvC(c, comp);
        return H264Utils.Mv.mvC(a, comp) + H264Utils.Mv.mvC(b, comp) + H264Utils.Mv.mvC(c, comp) - MBlockDecoderUtils.min(H264Utils.Mv.mvC(a, comp), H264Utils.Mv.mvC(b, comp), H264Utils.Mv.mvC(c, comp)) - MBlockDecoderUtils.max(H264Utils.Mv.mvC(a, comp), H264Utils.Mv.mvC(b, comp), H264Utils.Mv.mvC(c, comp));
    };
    constructor.max = function(x, x2, x3) {
        return x > x2 ? (x > x3 ? x : x3) : (x2 > x3 ? x2 : x3);
    };
    constructor.min = function(x, x2, x3) {
        return x < x2 ? (x < x3 ? x : x3) : (x2 < x3 ? x2 : x3);
    };
    constructor.saveMvs = function(di, x, mbX, mbY) {
        for (var j = 0, blkOffY = mbY << 2, blkInd = 0; j < 4; j++ , blkOffY++) {
            for (var i = 0, blkOffX = mbX << 2; i < 4; i++ , blkOffX++ , blkInd++) {
                di.mvs.setMv(blkOffX, blkOffY, 0, x.getMv(blkInd, 0));
                di.mvs.setMv(blkOffX, blkOffY, 1, x.getMv(blkInd, 1));
            }
        }
    };
    constructor.savePrediction8x8 = function(sharedState, mbX, x) {
        sharedState.mvTopLeft.copyPair(0, sharedState.mvTop, (mbX << 2) + 3);
        sharedState.mvLeft.copyPair(0, x, 3);
        sharedState.mvLeft.copyPair(1, x, 7);
        sharedState.mvLeft.copyPair(2, x, 11);
        sharedState.mvLeft.copyPair(3, x, 15);
        sharedState.mvTop.copyPair(mbX << 2, x, 12);
        sharedState.mvTop.copyPair((mbX << 2) + 1, x, 13);
        sharedState.mvTop.copyPair((mbX << 2) + 2, x, 14);
        sharedState.mvTop.copyPair((mbX << 2) + 3, x, 15);
    };
    constructor.saveVectIntra = function(sharedState, mbX) {
        var xx = mbX << 2;
        sharedState.mvTopLeft.copyPair(0, sharedState.mvTop, xx + 3);
        MBlockDecoderUtils.saveVect(sharedState.mvTop, 0, xx, xx + 4, MBlockDecoderUtils.NULL_VECTOR);
        MBlockDecoderUtils.saveVect(sharedState.mvLeft, 0, 0, 4, MBlockDecoderUtils.NULL_VECTOR);
        MBlockDecoderUtils.saveVect(sharedState.mvTop, 1, xx, xx + 4, MBlockDecoderUtils.NULL_VECTOR);
        MBlockDecoderUtils.saveVect(sharedState.mvLeft, 1, 0, 4, MBlockDecoderUtils.NULL_VECTOR);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 * 
 *  Contains an input for deblocking filter
 *  
 *  @author The JCodec project
 *  
 */
var DeblockerInput = function(activeSps) {
    var picWidthInMbs = activeSps.picWidthInMbsMinus1 + 1;
    var picHeightInMbs = SeqParameterSet.getPicHeightInMbs(activeSps);
    this.nCoeff = Array.apply(null, Array(picHeightInMbs << 2)).map(function() {
        return new Int32Array(picWidthInMbs << 2);
    });
    this.mvs = new H264Utils.MvList2D(picWidthInMbs << 2, picHeightInMbs << 2);
    this.mbTypes = Array(picHeightInMbs * picWidthInMbs);
    this.tr8x8Used = new Int8Array(picHeightInMbs * picWidthInMbs);
    this.mbQps = Array.apply(null, Array(3)).map(function() {
        return new Int32Array(picHeightInMbs * picWidthInMbs);
    });
    this.shs = Array(picHeightInMbs * picWidthInMbs);
    this.refsUsed = Array(picHeightInMbs * picWidthInMbs);
};
DeblockerInput = stjs.extend(DeblockerInput, null, [], function(constructor, prototype) {
    prototype.nCoeff = null;
    prototype.mvs = null;
    prototype.mbTypes = null;
    prototype.mbQps = null;
    prototype.tr8x8Used = null;
    prototype.refsUsed = null;
    prototype.shs = null;
}, {nCoeff: "Array", mvs: "H264Utils.MvList2D", mbTypes: "Array", mbQps: "Array", tr8x8Used: "Int8Array", refsUsed: "Array", shs: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Makes a clip out of an FLV
 *  
 *  @author Stanislav Vitvitskyy
 *  
 */
var FLVTool = function() {};
FLVTool = stjs.extend(FLVTool, null, [], function(constructor, prototype) {
    constructor.processors = new HashMap();
    constructor.FLAG_MAX_PACKETS = MainUtils.Flag.flag("max-packets", "m", "Maximum number of packets to process");
    constructor.main1 = function(args) {
        if (args.length < 1) {
            FLVTool.printGenericHelp();
            return;
        }
        var command = args[0];
        var processorFactory = FLVTool.processors.get(command);
        if (processorFactory == null) {
            System.err.println("Unknown command: " + command);
            FLVTool.printGenericHelp();
            return;
        }
        var cmd = MainUtils.parseArguments(Platform.copyOfRangeO(args, 1, args.length), processorFactory.getFlags());
        if (cmd.args.length < 1) {
            MainUtils.printHelpCmd(command, processorFactory.getFlags(), Arrays.asList("file in", "?file out"));
            return;
        }
        var processor = processorFactory.newPacketProcessor(cmd);
        var maxPackets = cmd.getIntegerFlagD(FLVTool.FLAG_MAX_PACKETS, Integer.MAX_VALUE);
        var _in = null;
        var out = null;
        try {
            _in = NIOUtils.readableChannel(new File(cmd.getArg(0)));
            if (processor.hasOutput()) 
                out = NIOUtils.writableChannel(new File(cmd.getArg(1)));
            var demuxer = new FLVReader(_in);
            var muxer = new FLVWriter(out);
            var pkt = null;
            for (var i = 0; i < maxPackets && (pkt = demuxer.readNextPacket()) != null; i++) {
                if (!processor.processPacket(pkt, muxer)) 
                    break;
            }
            processor.finish(muxer);
            if (processor.hasOutput()) 
                muxer.finish();
        } finally {
            IOUtils.closeQuietly(_in);
            IOUtils.closeQuietly(out);
        }
    };
    constructor.printGenericHelp = function() {
        System.err.println("Syntax: <command> [flags] <file in> [file out]\nWhere command is: [" + StringUtils.joinS(FLVTool.processors.keySet().toArray(Array(0)), ", ") + "].");
    };
    constructor.getProcessor = function(command, cmd) {
        var factory = FLVTool.processors.get(command);
        if (factory == null) 
            return null;
        return factory.newPacketProcessor(cmd);
    };
    constructor.PacketProcessor = function() {};
    constructor.PacketProcessor = stjs.extend(constructor.PacketProcessor, null, [], function(constructor, prototype) {
        prototype.processPacket = function(pkt, writer) {};
        prototype.hasOutput = function() {};
        prototype.finish = function(muxer) {};
    }, {}, {});
    constructor.PacketProcessorFactory = function() {};
    constructor.PacketProcessorFactory = stjs.extend(constructor.PacketProcessorFactory, null, [], function(constructor, prototype) {
        prototype.newPacketProcessor = function(flags) {};
        prototype.getFlags = function() {};
    }, {}, {});
    /**
     *  A packet processor that clips the flv between the given timestamps
     *  
     */
    constructor.ClipPacketProcessor = function(from, to) {
        this.from = from;
        this.to = to;
    };
    constructor.ClipPacketProcessor = stjs.extend(constructor.ClipPacketProcessor, null, [FLVTool.PacketProcessor], function(constructor, prototype) {
        constructor.h264Config = null;
        prototype.copying = false;
        prototype.from = null;
        prototype.to = null;
        constructor.FLAG_FROM = MainUtils.Flag.flag("from", null, "From timestamp (in seconds, i.e 67.49)");
        constructor.FLAG_TO = MainUtils.Flag.flag("to", null, "To timestamp");
        constructor.Factory = function() {};
        constructor.Factory = stjs.extend(constructor.Factory, null, [FLVTool.PacketProcessorFactory], function(constructor, prototype) {
            prototype.newPacketProcessor = function(flags) {
                return new FLVTool.ClipPacketProcessor(flags.getDoubleFlag(FLVTool.ClipPacketProcessor.FLAG_FROM), flags.getDoubleFlag(FLVTool.ClipPacketProcessor.FLAG_TO));
            };
            prototype.getFlags = function() {
                return [FLVTool.ClipPacketProcessor.FLAG_FROM, FLVTool.ClipPacketProcessor.FLAG_TO];
            };
        }, {}, {});
        prototype.processPacket = function(pkt, writer) {
            if (pkt.getType() == FLVTag.Type.VIDEO && pkt.getTagHeader().getCodec() == Codec.H264) {
                if ((pkt.getTagHeader()).getAvcPacketType() == 0) {
                    FLVTool.ClipPacketProcessor.h264Config = pkt;
                    System.out.println("GOT AVCC");
                }
            }
            if (!this.copying && (this.from == null || pkt.getPtsD() > this.from) && pkt.getType() == FLVTag.Type.VIDEO && pkt.isKeyFrame() && FLVTool.ClipPacketProcessor.h264Config != null) {
                System.out.println("Starting at packet: " + Platform.toJSON(pkt));
                this.copying = true;
                FLVTool.ClipPacketProcessor.h264Config.setPts(pkt.getPts());
                writer.addPacket(FLVTool.ClipPacketProcessor.h264Config);
            }
            if (this.to != null && pkt.getPtsD() >= this.to) {
                System.out.println("Stopping at packet: " + Platform.toJSON(pkt));
                return false;
            }
            if (this.copying) 
                writer.addPacket(pkt);
            return true;
        };
        prototype.finish = function(muxer) {};
        prototype.hasOutput = function() {
            return true;
        };
    }, {h264Config: "FLVTag", FLAG_FROM: "MainUtils.Flag", FLAG_TO: "MainUtils.Flag"}, {});
    /**
     *  A packet processor that forces a certain FPS
     *  
     */
    constructor.FixPtsProcessor = function() {
        this.tags = new ArrayList();
    };
    constructor.FixPtsProcessor = stjs.extend(constructor.FixPtsProcessor, null, [FLVTool.PacketProcessor], function(constructor, prototype) {
        prototype.lastPtsAudio = 0;
        prototype.lastPtsVideo = 0;
        prototype.tags = null;
        prototype.audioTagsInQueue = 0;
        prototype.videoTagsInQueue = 0;
        constructor.CORRECTION_PACE = 0.33;
        constructor.Factory = function() {};
        constructor.Factory = stjs.extend(constructor.Factory, null, [FLVTool.PacketProcessorFactory], function(constructor, prototype) {
            prototype.newPacketProcessor = function(flags) {
                return new FLVTool.FixPtsProcessor();
            };
            prototype.getFlags = function() {
                return [];
            };
        }, {}, {});
        prototype.processPacket = function(pkt, writer) {
            this.tags.add(pkt);
            if (pkt.getType() == FLVTag.Type.AUDIO) {
                ++this.audioTagsInQueue;
            } else if (pkt.getType() == FLVTag.Type.VIDEO) {
                ++this.videoTagsInQueue;
            }
            if (this.tags.size() < 600) 
                return true;
            this.processOneTag(writer);
            return true;
        };
        prototype.processOneTag = function(writer) {
            var tag = this.tags.remove(0);
            if (tag.getType() == FLVTag.Type.AUDIO) {
                tag.setPts(((Math.round(this.lastPtsAudio * 1000)) | 0));
                this.lastPtsAudio += this.audioFrameDuration((tag.getTagHeader()));
                --this.audioTagsInQueue;
            } else if (tag.getType() == FLVTag.Type.VIDEO) {
                var duration = ((1024 * this.audioTagsInQueue) / (48000 * this.videoTagsInQueue));
                tag.setPts(((Math.round(this.lastPtsVideo * 1000)) | 0));
                this.lastPtsVideo += Math.min((1 + FLVTool.FixPtsProcessor.CORRECTION_PACE) * duration, Math.max((1 - FLVTool.FixPtsProcessor.CORRECTION_PACE) * duration, duration + Math.min(1, Math.abs(this.lastPtsAudio - this.lastPtsVideo)) * (this.lastPtsAudio - this.lastPtsVideo)));
                --this.videoTagsInQueue;
                System.out.println(this.lastPtsVideo + " - " + this.lastPtsAudio);
            } else {
                tag.setPts(((Math.round(this.lastPtsVideo * 1000)) | 0));
            }
            writer.addPacket(tag);
        };
        prototype.audioFrameDuration = function(audioTagHeader) {
            if (Codec.AAC == audioTagHeader.getCodec()) {
                return (1024) / audioTagHeader.getAudioFormat().getSampleRate();
            } else if (Codec.MP3 == audioTagHeader.getCodec()) {
                return (1152) / audioTagHeader.getAudioFormat().getSampleRate();
            }
             throw new RuntimeException("Audio codec:" + audioTagHeader.getCodec() + " is not supported.");
        };
        prototype.finish = function(muxer) {
             while (this.tags.size() > 0){
                this.processOneTag(muxer);
            }
        };
        prototype.hasOutput = function() {
            return true;
        };
    }, {tags: {name: "List", arguments: ["FLVTag"]}}, {});
    /**
     *  A packet processor that just dumps info
     *  
     */
    constructor.InfoPacketProcessor = function(checkOnly, streamType) {
        this.checkOnly = checkOnly;
        this.streamType = streamType;
    };
    constructor.InfoPacketProcessor = stjs.extend(constructor.InfoPacketProcessor, null, [FLVTool.PacketProcessor], function(constructor, prototype) {
        prototype.prevVideoTag = null;
        prototype.prevAudioTag = null;
        constructor.Factory = function() {};
        constructor.Factory = stjs.extend(constructor.Factory, null, [FLVTool.PacketProcessorFactory], function(constructor, prototype) {
            constructor.FLAG_CHECK = MainUtils.Flag.flag("check", null, "Check sanity and report errors only, no packet dump will be generated.");
            constructor.FLAG_STREAM = MainUtils.Flag.flag("stream", null, "Stream selector, can be one of: ['video', 'audio', 'script'].");
            prototype.newPacketProcessor = function(flags) {
                return new FLVTool.InfoPacketProcessor(flags.getBooleanFlagD(FLVTool.InfoPacketProcessor.Factory.FLAG_CHECK, false), flags.getEnumFlagD(FLVTool.InfoPacketProcessor.Factory.FLAG_STREAM, null, FLVTag.Type));
            };
            prototype.getFlags = function() {
                return [FLVTool.InfoPacketProcessor.Factory.FLAG_CHECK, FLVTool.InfoPacketProcessor.Factory.FLAG_STREAM];
            };
        }, {FLAG_CHECK: "MainUtils.Flag", FLAG_STREAM: "MainUtils.Flag"}, {});
        prototype.checkOnly = false;
        prototype.streamType = null;
        prototype.processPacket = function(pkt, writer) {
            if (this.checkOnly) 
                return true;
            if (pkt.getType() == FLVTag.Type.VIDEO) {
                if (this.streamType == FLVTag.Type.VIDEO || this.streamType == null) {
                    if (this.prevVideoTag != null) 
                        this.dumpOnePacket(this.prevVideoTag, pkt.getPts() - this.prevVideoTag.getPts());
                    this.prevVideoTag = pkt;
                }
            } else if (pkt.getType() == FLVTag.Type.AUDIO) {
                if (this.streamType == FLVTag.Type.AUDIO || this.streamType == null) {
                    if (this.prevAudioTag != null) 
                        this.dumpOnePacket(this.prevAudioTag, pkt.getPts() - this.prevAudioTag.getPts());
                    this.prevAudioTag = pkt;
                }
            } else {
                this.dumpOnePacket(pkt, 0);
            }
            return true;
        };
        prototype.dumpOnePacket = function(pkt, duration) {
            System.out.print("T=" + this.typeString(pkt.getType()) + "|PTS=" + pkt.getPts() + "|DUR=" + duration + "|" + (pkt.isKeyFrame() ? "K" : " ") + "|POS=" + pkt.getPosition());
            if (stjs.isInstanceOf(pkt.getTagHeader().constructor, FLVTag.VideoTagHeader)) {
                var vt = pkt.getTagHeader();
                System.out.print("|C=" + vt.getCodec() + "|FT=" + vt.getFrameType());
                if (stjs.isInstanceOf(vt.constructor, FLVTag.AvcVideoTagHeader)) {
                    var avct = vt;
                    System.out.print("|PKT_TYPE=" + avct.getAvcPacketType() + "|COMP_OFF=" + avct.getCompOffset());
                    if (avct.getAvcPacketType() == 0) {
                        var frameData = pkt.getData().duplicate();
                        FLVReader.parseVideoTagHeader(frameData);
                        var avcc = H264Utils.parseAVCCFromBuffer(frameData);
                        for (var iterator$sps = H264Utils.readSPSFromBufferList(avcc.getSpsList()).iterator(); iterator$sps.hasNext(); ) {
                            var sps = iterator$sps.next();
                            System.out.println();
                            System.out.print("  SPS[" + sps.getSeqParameterSetId() + "]:" + Platform.toJSON(sps));
                        }
                        for (var iterator$pps = H264Utils.readPPSFromBufferList(avcc.getPpsList()).iterator(); iterator$pps.hasNext(); ) {
                            var pps = iterator$pps.next();
                            System.out.println();
                            System.out.print("  PPS[" + pps.getPicParameterSetId() + "]:" + Platform.toJSON(pps));
                        }
                    }
                }
            } else if (stjs.isInstanceOf(pkt.getTagHeader().constructor, FLVTag.AudioTagHeader)) {
                var at = pkt.getTagHeader();
                var format = at.getAudioFormat();
                System.out.print("|C=" + at.getCodec() + "|SR=" + format.getSampleRate() + "|SS=" + (format.getSampleSizeInBits() >> 3) + "|CH=" + format.getChannels());
            } else if (pkt.getType() == FLVTag.Type.SCRIPT) {
                var metadata = FLVReader.parseMetadata(pkt.getData().duplicate());
                if (metadata != null) {
                    System.out.println();
                    System.out.print("  Metadata:" + Platform.toJSON(metadata));
                }
            }
            System.out.println();
        };
        prototype.typeString = function(type) {
            return type.toString().substring(0, 1);
        };
        prototype.finish = function(muxer) {
            if (this.prevVideoTag != null) 
                this.dumpOnePacket(this.prevVideoTag, 0);
            if (this.prevAudioTag != null) 
                this.dumpOnePacket(this.prevAudioTag, 0);
        };
        prototype.hasOutput = function() {
            return false;
        };
    }, {prevVideoTag: "FLVTag", prevAudioTag: "FLVTag", streamType: {name: "Enum", arguments: ["FLVTag.Type"]}}, {});
    /**
     *  A packet processor shifts pts
     *  
     */
    constructor.ShiftPtsProcessor = function(shiftTo, shiftBy, expectWrapAround) {
        this.savedTags = new LinkedList();
        this.shiftTo = shiftTo;
        this.shiftBy = shiftBy;
        this.expectWrapAround = true;
    };
    constructor.ShiftPtsProcessor = stjs.extend(constructor.ShiftPtsProcessor, null, [FLVTool.PacketProcessor], function(constructor, prototype) {
        constructor.WRAP_AROUND_VALUE = 2147483648;
        constructor.HALF_WRAP_AROUND_VALUE = 1073741824;
        constructor.FLAG_TO = MainUtils.Flag.flag("to", null, "Shift first pts to this value, and all subsequent pts accordingly.");
        constructor.FLAG_BY = MainUtils.Flag.flag("by", null, "Shift all pts by this value.");
        constructor.FLAG_WRAP_AROUND = MainUtils.Flag.flag("wrap-around", null, "Expect wrap around of timestamps.");
        constructor.Factory = function() {};
        constructor.Factory = stjs.extend(constructor.Factory, null, [FLVTool.PacketProcessorFactory], function(constructor, prototype) {
            prototype.newPacketProcessor = function(flags) {
                return new FLVTool.ShiftPtsProcessor(flags.getIntegerFlagD(FLVTool.ShiftPtsProcessor.FLAG_TO, 0), flags.getIntegerFlag(FLVTool.ShiftPtsProcessor.FLAG_BY), flags.getBooleanFlagD(FLVTool.ShiftPtsProcessor.FLAG_WRAP_AROUND, false));
            };
            prototype.getFlags = function() {
                return [FLVTool.ShiftPtsProcessor.FLAG_TO, FLVTool.ShiftPtsProcessor.FLAG_BY, FLVTool.ShiftPtsProcessor.FLAG_WRAP_AROUND];
            };
        }, {}, {});
        prototype.shiftTo = 0;
        prototype.shiftBy = null;
        prototype.ptsDelta = 0;
        prototype.firstPtsSeen = false;
        prototype.savedTags = null;
        prototype.expectWrapAround = false;
        prototype.prevPts = 0;
        prototype.processPacket = function(pkt, writer) {
            var avcPrivatePacket = pkt.getType() == FLVTag.Type.VIDEO && (pkt.getTagHeader()).getCodec() == Codec.H264 && (pkt.getTagHeader()).getAvcPacketType() == 0;
            var aacPrivatePacket = pkt.getType() == FLVTag.Type.AUDIO && (pkt.getTagHeader()).getCodec() == Codec.AAC && (pkt.getTagHeader()).getPacketType() == 0;
            var validPkt = pkt.getType() != FLVTag.Type.SCRIPT && !avcPrivatePacket && !aacPrivatePacket;
            if (this.expectWrapAround && validPkt && pkt.getPts() < this.prevPts && (stjs.trunc(this.prevPts) - pkt.getPts() > FLVTool.ShiftPtsProcessor.HALF_WRAP_AROUND_VALUE)) {
                Logger.warn("Wrap around detected: " + this.prevPts + " -> " + pkt.getPts());
                if (pkt.getPts() < -FLVTool.ShiftPtsProcessor.HALF_WRAP_AROUND_VALUE) {
                    this.ptsDelta += (FLVTool.ShiftPtsProcessor.WRAP_AROUND_VALUE << 1);
                } else if (pkt.getPts() >= 0) {
                    this.ptsDelta += FLVTool.ShiftPtsProcessor.WRAP_AROUND_VALUE;
                }
            }
            if (validPkt) 
                this.prevPts = pkt.getPts();
            if (this.firstPtsSeen) {
                this.writePacket(pkt, writer);
            } else {
                if (!validPkt) {
                    this.savedTags.add(pkt);
                } else {
                    if (this.shiftBy != null) {
                        this.ptsDelta = this.shiftBy;
                        if (this.ptsDelta + pkt.getPts() < 0) 
                            this.ptsDelta = -pkt.getPts();
                    } else {
                        this.ptsDelta = this.shiftTo - pkt.getPts();
                    }
                    this.firstPtsSeen = true;
                    this.emptySavedTags(writer);
                    this.writePacket(pkt, writer);
                }
            }
            return true;
        };
        prototype.writePacket = function(pkt, writer) {
            var newPts = pkt.getPts() + this.ptsDelta;
            if (newPts < 0) {
                Logger.warn("Preventing negative pts for tag @" + pkt.getPosition());
                if (this.shiftBy != null) 
                    newPts = 0;
                 else 
                    newPts = this.shiftTo;
            } else if (newPts >= FLVTool.ShiftPtsProcessor.WRAP_AROUND_VALUE) {
                Logger.warn("PTS wrap around @" + pkt.getPosition());
                newPts -= FLVTool.ShiftPtsProcessor.WRAP_AROUND_VALUE;
                this.ptsDelta = newPts - pkt.getPts();
            }
            pkt.setPts(((newPts) | 0));
            writer.addPacket(pkt);
        };
        prototype.emptySavedTags = function(muxer) {
             while (this.savedTags.size() > 0){
                this.writePacket(this.savedTags.remove(0), muxer);
            }
        };
        prototype.finish = function(muxer) {
            this.emptySavedTags(muxer);
        };
        prototype.hasOutput = function() {
            return true;
        };
    }, {FLAG_TO: "MainUtils.Flag", FLAG_BY: "MainUtils.Flag", FLAG_WRAP_AROUND: "MainUtils.Flag", savedTags: {name: "List", arguments: ["FLVTag"]}}, {});
}, {processors: {name: "Map", arguments: [null, "FLVTool.PacketProcessorFactory"]}, FLAG_MAX_PACKETS: "MainUtils.Flag"}, {});
(function() {
    FLVTool.processors.put("clip", new FLVTool.ClipPacketProcessor.Factory());
    FLVTool.processors.put("fix_pts", new FLVTool.FixPtsProcessor.Factory());
    FLVTool.processors.put("info", new FLVTool.InfoPacketProcessor.Factory());
    FLVTool.processors.put("shift_pts", new FLVTool.ShiftPtsProcessor.Factory());
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Timecode track, provides timecode information for video track
 *  
 *  @author The JCodec project
 *  
 */
var TimecodeMP4DemuxerTrack = function(movie, trak, input) {
    this.box = trak;
    this.input = input;
    this.movie = movie;
    var stbl = trak.getMdia().getMinf().getStbl();
    var stts = NodeBox.findFirst(stbl, TimeToSampleBox, "stts");
    var stsc = NodeBox.findFirst(stbl, SampleToChunkBox, "stsc");
    var stco = NodeBox.findFirst(stbl, ChunkOffsetsBox, "stco");
    var co64 = NodeBox.findFirst(stbl, ChunkOffsets64Box, "co64");
    this.timeToSamples = stts.getEntries();
    this.chunkOffsets = stco != null ? stco.getChunkOffsets() : co64.getChunkOffsets();
    this.sampleToChunks = stsc.getSampleToChunk();
    if (this.chunkOffsets.length == 1) {
        this.cacheSamples(this.sampleToChunks, this.chunkOffsets);
    }
    this.tse = this.box.getSampleEntries()[0];
};
TimecodeMP4DemuxerTrack = stjs.extend(TimecodeMP4DemuxerTrack, null, [], function(constructor, prototype) {
    prototype.box = null;
    prototype.timeToSamples = null;
    prototype.sampleCache = null;
    prototype.tse = null;
    prototype.input = null;
    prototype.movie = null;
    prototype.chunkOffsets = null;
    prototype.sampleToChunks = null;
    prototype.getTimecode = function(pkt) {
        var tv = QTTimeUtil.editedToMedia(this.box, this.box.rescale(pkt.getPts(), pkt.getTimescale()), this.movie.getTimescale());
        var sample;
        var ttsInd = 0, ttsSubInd = 0;
        for (sample = 0; sample < this.sampleCache.length - 1; sample++) {
            var dur = this.timeToSamples[ttsInd].getSampleDuration();
            if (tv < dur) 
                break;
            tv -= dur;
            ttsSubInd++;
            if (ttsInd < this.timeToSamples.length - 1 && ttsSubInd >= this.timeToSamples[ttsInd].getSampleCount()) 
                ttsInd++;
        }
        var frameNo = stjs.trunc(((((stjs.trunc((stjs.trunc((2 * tv * this.tse.getTimescale()) / this.box.getTimescale())) / this.tse.getFrameDuration())) + 1)) | 0) / 2);
        return MP4Packet.createMP4PacketWithTimecode(pkt, TimecodeMP4DemuxerTrack._getTimecode(this.getTimecodeSample(sample), frameNo, this.tse));
    };
    prototype.getTimecodeSample = function(sample) {
        if (this.sampleCache != null) 
            return this.sampleCache[sample];
         else {
            {
                var stscInd, stscSubInd;
                for (stscInd = 0 , stscSubInd = sample; stscInd < this.sampleToChunks.length && stscSubInd >= this.sampleToChunks[stscInd].getCount(); stscSubInd -= this.sampleToChunks[stscInd].getCount() , stscInd++) 
                    ;
                var offset = this.chunkOffsets[stscInd] + (Math.min(stscSubInd, this.sampleToChunks[stscInd].getCount() - 1) << 2);
                if (this.input.position() != offset) 
                    this.input.setPosition(offset);
                var buf = NIOUtils.fetchFromChannel(this.input, 4);
                return buf.getInt();
            }}
    };
    constructor._getTimecode = function(startCounter, frameNo, entry) {
        return TapeTimecode.tapeTimecode(frameNo + startCounter, entry.isDropFrame(), entry.getNumFrames() & 255);
    };
    prototype.cacheSamples = function(sampleToChunks, chunkOffsets) {
        {
            var stscInd = 0;
            var ss = IntArrayList.createIntArrayList();
            for (var chunkNo = 0; chunkNo < chunkOffsets.length; chunkNo++) {
                var nSamples = sampleToChunks[stscInd].getCount();
                if (stscInd < sampleToChunks.length - 1 && chunkNo + 1 >= sampleToChunks[stscInd + 1].getFirst()) 
                    stscInd++;
                var offset = chunkOffsets[chunkNo];
                this.input.setPosition(offset);
                var buf = NIOUtils.fetchFromChannel(this.input, nSamples * 4);
                for (var i = 0; i < nSamples; i++) {
                    ss.add(buf.getInt());
                }
            }
            this.sampleCache = ss.toArray();
        }};
    /**
     *  
     *  @return
     *  @throws IOException 
     *  @deprecated Use getTimecode to automatically populate tape timecode for
     *              each frame
     */
    prototype.getStartTimecode = function() {
        return this.getTimecodeSample(0);
    };
    prototype.getBox = function() {
        return this.box;
    };
    prototype.parseTimecode = function(tc) {
        var split = tc.split(":");
        var tmcd = NodeBox.findFirstPath(this.box, TimecodeSampleEntry, Box.path("mdia.minf.stbl.stsd.tmcd"));
        var nf = tmcd.getNumFrames();
        return Integer.parseInt(split[3]) + Integer.parseInt(split[2]) * nf + Integer.parseInt(split[1]) * 60 * nf + Integer.parseInt(split[0]) * 3600 * nf;
    };
    prototype.timeCodeToFrameNo = function(timeCode) {
        if (TimecodeMP4DemuxerTrack.isValidTimeCode(timeCode)) {
            var movieFrame = this.parseTimecode(timeCode.trim()) - this.sampleCache[0];
            var frameRate = this.tse.getNumFrames();
            var framesInTimescale = movieFrame * this.tse.getTimescale();
            var mediaToEdited = QTTimeUtil.mediaToEdited(this.box, stjs.trunc(framesInTimescale / frameRate), this.movie.getTimescale()) * frameRate;
            return (((stjs.trunc(mediaToEdited / this.box.getTimescale()))) | 0);
        }
        return -1;
    };
    constructor.isValidTimeCode = function(input) {
        var p = Pattern.compile("[0-9][0-9]:[0-5][0-9]:[0-5][0-9]:[0-2][0-9]");
        var m = p.matcher(input);
        if (input != null && !input.trim().equals("") && m.matches()) {
            return true;
        }
        return false;
    };
}, {box: "TrakBox", timeToSamples: "Array", sampleCache: "Int32Array", tse: "TimecodeSampleEntry", input: "SeekableByteChannel", movie: "MovieBox", chunkOffsets: "Array", sampleToChunks: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var UdtaBox = function(atom) {
    NodeBox.call(this, atom);
};
UdtaBox = stjs.extend(UdtaBox, NodeBox, [], function(constructor, prototype) {
    constructor.FOURCC = "udta";
    constructor.createUdtaBox = function() {
        return new UdtaBox(Header.createHeader(UdtaBox.fourcc(), 0));
    };
    prototype.setFactory = function(_factory) {
        this.factory = new (stjs.extend(function UdtaBox$1() {}, null, [IBoxFactory], function(constructor, prototype) {
            prototype.newBox = function(header) {
                if (header.getFourcc().equals(UdtaMetaBox.fourcc())) {
                    var box = new UdtaMetaBox(header);
                    box.setFactory(_factory);
                    return box;
                }
                return _factory.newBox(header);
            };
        }, {}, {}))();
    };
    prototype.meta = function() {
        return NodeBox.findFirst(this, MetaBox, MetaBox.fourcc());
    };
    constructor.fourcc = function() {
        return UdtaBox.FOURCC;
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 * 
 *  @author in-somnia
 */
var FIL = function(downSampledSBR) {
    Element.call(this);
    this.downSampledSBR = downSampledSBR;
};
FIL = stjs.extend(FIL, Element, [SyntaxConstants], function(constructor, prototype) {
    constructor.DynamicRangeInfo = function() {
        this.excludeMask = new Int8Array(FIL.DynamicRangeInfo.MAX_NBR_BANDS);
        this.additionalExcludedChannels = new Int8Array(FIL.DynamicRangeInfo.MAX_NBR_BANDS);
    };
    constructor.DynamicRangeInfo = stjs.extend(constructor.DynamicRangeInfo, null, [], function(constructor, prototype) {
        constructor.MAX_NBR_BANDS = 7;
        prototype.excludeMask = null;
        prototype.additionalExcludedChannels = null;
        prototype.pceTagPresent = false;
        prototype.pceInstanceTag = 0;
        prototype.tagReservedBits = 0;
        prototype.excludedChannelsPresent = false;
        prototype.bandsPresent = false;
        prototype.bandsIncrement = 0;
        prototype.interpolationScheme = 0;
        prototype.bandTop = null;
        prototype.progRefLevelPresent = false;
        prototype.progRefLevel = 0;
        prototype.progRefLevelReservedBits = 0;
        prototype.dynRngSgn = null;
        prototype.dynRngCtl = null;
    }, {excludeMask: "Int8Array", additionalExcludedChannels: "Int8Array", bandTop: "Int32Array", dynRngSgn: "Int8Array", dynRngCtl: "Int32Array"}, {});
    constructor.TYPE_FILL = 0;
    constructor.TYPE_FILL_DATA = 1;
    constructor.TYPE_EXT_DATA_ELEMENT = 2;
    constructor.TYPE_DYNAMIC_RANGE = 11;
    constructor.TYPE_SBR_DATA = 13;
    constructor.TYPE_SBR_DATA_CRC = 14;
    prototype.downSampledSBR = false;
    prototype.dri = null;
    prototype.decode = function(_in, prev, sf, sbrEnabled, smallFrames) {
        var count = _in.readBits(4);
        if (count == 15) 
            count += _in.readBits(8) - 1;
        count *= 8;
        var cpy = count;
        var pos = _in.getPosition();
         while (count > 0){
            count = this.decodeExtensionPayload(_in, count, prev, sf, sbrEnabled, smallFrames);
        }
        var pos2 = _in.getPosition() - pos;
        var bitsLeft = cpy - pos2;
        if (bitsLeft > 0) 
            _in.skipBits(pos2);
         else if (bitsLeft < 0) 
             throw new AACException("FIL element overread: " + bitsLeft);
    };
    prototype.decodeExtensionPayload = function(_in, count, prev, sf, sbrEnabled, smallFrames) {
        var type = _in.readBits(4);
        var ret = count - 4;
        switch (type) {
            case FIL.TYPE_DYNAMIC_RANGE:
                ret = this.decodeDynamicRangeInfo(_in, ret);
                break;
            case FIL.TYPE_SBR_DATA:
            case FIL.TYPE_SBR_DATA_CRC:
                if (sbrEnabled) {
                    if (stjs.isInstanceOf(prev.constructor, SCE_LFE) || stjs.isInstanceOf(prev.constructor, CPE) || stjs.isInstanceOf(prev.constructor, CCE)) {
                        prev.decodeSBR(_in, sf, ret, (stjs.isInstanceOf(prev.constructor, CPE)), (type == FIL.TYPE_SBR_DATA_CRC), this.downSampledSBR, smallFrames);
                        ret = 0;
                        break;
                    } else 
                         throw new AACException("SBR applied on unexpected element: " + prev);
                } else {
                    _in.skipBits(ret);
                    ret = 0;
                }
            case FIL.TYPE_FILL:
            case FIL.TYPE_FILL_DATA:
            case FIL.TYPE_EXT_DATA_ELEMENT:
            default:
                _in.skipBits(ret);
                ret = 0;
                break;
        }
        return ret;
    };
    prototype.decodeDynamicRangeInfo = function(_in, count) {
        if (this.dri == null) 
            this.dri = new FIL.DynamicRangeInfo();
        var ret = count;
        var bandCount = 1;
        if (this.dri.pceTagPresent = _in.readBool()) {
            this.dri.pceInstanceTag = _in.readBits(4);
            this.dri.tagReservedBits = _in.readBits(4);
        }
        if (this.dri.excludedChannelsPresent = _in.readBool()) {
            ret -= this.decodeExcludedChannels(_in);
        }
        if (this.dri.bandsPresent = _in.readBool()) {
            this.dri.bandsIncrement = _in.readBits(4);
            this.dri.interpolationScheme = _in.readBits(4);
            ret -= 8;
            bandCount += this.dri.bandsIncrement;
            this.dri.bandTop = new Int32Array(bandCount);
            for (var i = 0; i < bandCount; i++) {
                this.dri.bandTop[i] = _in.readBits(8);
                ret -= 8;
            }
        }
        if (this.dri.progRefLevelPresent = _in.readBool()) {
            this.dri.progRefLevel = _in.readBits(7);
            this.dri.progRefLevelReservedBits = _in.readBits(1);
            ret -= 8;
        }
        this.dri.dynRngSgn = new Int8Array(bandCount);
        this.dri.dynRngCtl = new Int32Array(bandCount);
        for (var i = 0; i < bandCount; i++) {
            this.dri.dynRngSgn[i] = _in.readBool();
            this.dri.dynRngCtl[i] = _in.readBits(7);
            ret -= 8;
        }
        return ret;
    };
    prototype.decodeExcludedChannels = function(_in) {
        var i;
        var exclChs = 0;
        do {
            for (i = 0; i < 7; i++) {
                this.dri.excludeMask[exclChs] = _in.readBool();
                exclChs++;
            }
        } while (exclChs < 57 && _in.readBool());
        return (stjs.trunc(exclChs / 7)) * 8;
    };
}, {dri: "FIL.DynamicRangeInfo", sbr: "SBR"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MXF demuxer
 *  
 *  @author The JCodec project
 *  
 */
var MXFDemuxer = function(ch) {
    this.ch = ch;
    ch.setPosition(0);
    this.parseHeader(ch);
    this.findIndex();
    this.tracks = this.findTracks();
    this.timecode = MXFUtil.findMeta(this.metadata, TimecodeComponent);
};
MXFDemuxer = stjs.extend(MXFDemuxer, null, [], function(constructor, prototype) {
    prototype.metadata = null;
    prototype.header = null;
    prototype.partitions = null;
    prototype.indexSegments = null;
    prototype.ch = null;
    prototype.tracks = null;
    prototype.totalFrames = 0;
    prototype.duration = 0.0;
    prototype.timecode = null;
    constructor.OP = function(major, minor) {
        this.major = major;
        this.minor = minor;
    };
    constructor.OP = stjs.extend(constructor.OP, null, [], function(constructor, prototype) {
        constructor.OP1a = new MXFDemuxer.OP(1, 1);
        constructor.OP1b = new MXFDemuxer.OP(1, 2);
        constructor.OP1c = new MXFDemuxer.OP(1, 3);
        constructor.OP2a = new MXFDemuxer.OP(2, 1);
        constructor.OP2b = new MXFDemuxer.OP(2, 2);
        constructor.OP2c = new MXFDemuxer.OP(2, 3);
        constructor.OP3a = new MXFDemuxer.OP(3, 1);
        constructor.OP3b = new MXFDemuxer.OP(3, 2);
        constructor.OP3c = new MXFDemuxer.OP(3, 3);
        constructor.OPAtom = new MXFDemuxer.OP(16, 0);
        constructor._values = [MXFDemuxer.OP.OP1a, MXFDemuxer.OP.OP1b, MXFDemuxer.OP.OP1c, MXFDemuxer.OP.OP2a, MXFDemuxer.OP.OP2b, MXFDemuxer.OP.OP2c, MXFDemuxer.OP.OP3a, MXFDemuxer.OP.OP3b, MXFDemuxer.OP.OP3c, MXFDemuxer.OP.OPAtom];
        prototype.major = 0;
        prototype.minor = 0;
        constructor.values = function() {
            return MXFDemuxer.OP._values;
        };
    }, {OP1a: "MXFDemuxer.OP", OP1b: "MXFDemuxer.OP", OP1c: "MXFDemuxer.OP", OP2a: "MXFDemuxer.OP", OP2b: "MXFDemuxer.OP", OP2c: "MXFDemuxer.OP", OP3a: "MXFDemuxer.OP", OP3b: "MXFDemuxer.OP", OP3c: "MXFDemuxer.OP", OPAtom: "MXFDemuxer.OP", _values: "Array"}, {});
    prototype.getOp = function() {
        var op = this.header.getPack().getOp();
        var values = MXFDemuxer.OP.values();
        for (var i = 0; i < values.length; i++) {
            var op2 = values[i];
            if (op.get(12) == op2.major && op.get(13) == op2.minor) 
                return op2;
        }
        return MXFDemuxer.OP.OPAtom;
    };
    prototype.findTracks = function() {
        var _tracks = MXFUtil.findAllMeta(this.metadata, TimelineTrack);
        var descriptors = MXFUtil.findAllMeta(this.metadata, FileDescriptor);
        var tracks = new LinkedHashMap();
        for (var iterator$track = _tracks.iterator(); iterator$track.hasNext(); ) {
            var track = iterator$track.next();
            if (track.getTrackId() == 0 || track.getTrackNumber() == 0) {
                Logger.warn("trackId == 0 || trackNumber == 0");
                continue;
            }
            var trackId = track.getTrackId();
            if (tracks.containsKey(trackId)) {
                Logger.warn("duplicate trackId " + trackId);
                continue;
            }
            var descriptor = MXFDemuxer.findDescriptor(descriptors, track.getTrackId());
            if (descriptor == null) {
                Logger.warn("No generic descriptor for track: " + track.getTrackId());
                if (descriptors.size() == 1 && descriptors.get(0).getLinkedTrackId() == 0) {
                    descriptor = descriptors.get(0);
                }
            }
            if (descriptor == null) {
                Logger.warn("Track without descriptor: " + track.getTrackId());
                continue;
            }
            var trackNumber = track.getTrackNumber();
            var ul = UL.newULFromInts(6, 14, 43, 52, 1, 2, 1, 1, 13, 1, 3, 1, (trackNumber >>> 24) & 255, (trackNumber >>> 16) & 255, (trackNumber >>> 8) & 255, trackNumber & 255);
            var dt = this.createTrack(ul, track, descriptor);
            if (dt.getCodec() != null || (stjs.isInstanceOf(descriptor.constructor, WaveAudioDescriptor))) {
                tracks.put(trackId, dt);
            }
        }
        return tracks.values().toArray(Array(tracks.size()));
    };
    constructor.findDescriptor = function(descriptors, trackId) {
        for (var iterator$descriptor = descriptors.iterator(); iterator$descriptor.hasNext(); ) {
            var descriptor = iterator$descriptor.next();
            if (descriptor.getLinkedTrackId() == trackId) {
                return descriptor;
            }
        }
        return null;
    };
    prototype.createTrack = function(ul, track, descriptor) {
        return new MXFDemuxer.MXFDemuxerTrack(this, ul, track, descriptor);
    };
    prototype.getIndexes = function() {
        return this.indexSegments;
    };
    prototype.getEssencePartitions = function() {
        return this.partitions;
    };
    prototype.getTimecode = function() {
        return this.timecode;
    };
    prototype.parseHeader = function(ff) {
        var kl;
        this.header = MXFDemuxer.readHeaderPartition(ff);
        this.metadata = new ArrayList();
        this.partitions = new ArrayList();
        var nextPartition = ff.size();
        ff.setPosition(this.header.getPack().getFooterPartition());
        do {
            var thisPartition = ff.position();
            kl = KLV.readKL(ff);
            var fetchFrom = NIOUtils.fetchFromChannel(ff, ((kl.len) | 0));
            this.header = MXFPartition.read(kl.key, fetchFrom, ff.position() - kl.offset, nextPartition);
            if (this.header.getPack().getNbEssenceContainers() > 0) 
                this.partitions.add(0, this.header);
            this.metadata.addAllAt(0, MXFDemuxer.readPartitionMeta(ff, this.header));
            ff.setPosition(this.header.getPack().getPrevPartition());
            nextPartition = thisPartition;
        } while (this.header.getPack().getThisPartition() != 0);
    };
    constructor.readPartitionMeta = function(ff, header) {
        var kl;
        var basePos = ff.position();
        var local = new ArrayList();
        var metaBuffer = NIOUtils.fetchFromChannel(ff, ((Math.max(0, header.getEssenceFilePos() - basePos)) | 0));
         while (metaBuffer.hasRemaining() && (kl = KLV.readKLFromBuffer(metaBuffer, basePos)) != null){
            if (metaBuffer.remaining() >= kl.len) {
                var meta = MXFDemuxer.parseMeta(kl.key, NIOUtils.read(metaBuffer, ((kl.len) | 0)));
                if (meta != null) 
                    local.add(meta);
            } else {
                break;
            }
        }
        return local;
    };
    constructor.readHeaderPartition = function(ff) {
        var kl;
        var header = null;
         while ((kl = KLV.readKL(ff)) != null){
            if (MXFConst.HEADER_PARTITION_KLV.equals(kl.key)) {
                var data = NIOUtils.fetchFromChannel(ff, ((kl.len) | 0));
                header = MXFPartition.read(kl.key, data, ff.position() - kl.offset, 0);
                break;
            } else {
                ff.setPosition(ff.position() + kl.len);
            }
        }
        return header;
    };
    constructor.parseMeta = function(ul, _bb) {
        var class1 = MXFConst.klMetadata.get(ul);
        if (class1 == null) {
            Logger.warn("Unknown metadata piece: " + ul);
            return null;
        }
        try {
            var meta = Platform.newInstance(class1, [ul]);
            meta.readBuf(_bb);
            return meta;
        }catch (e) {}
        Logger.warn("Unknown metadata piece: " + ul);
        return null;
    };
    prototype.findIndex = function() {
        this.indexSegments = new ArrayList();
        for (var iterator$meta = this.metadata.iterator(); iterator$meta.hasNext(); ) {
            var meta = iterator$meta.next();
            if (stjs.isInstanceOf(meta.constructor, IndexSegment)) {
                var is = meta;
                this.indexSegments.add(is);
                this.totalFrames += is.getIndexDuration();
                this.duration += (is.getIndexEditRateDen() * is.getIndexDuration()) / is.getIndexEditRateNum();
            }
        }
    };
    prototype.getTracks = function() {
        return this.tracks;
    };
    prototype.getVideoTrack = function() {
        for (var index$track = 0, arr$track = this.tracks; index$track < arr$track.length; index$track++) {
            var track = arr$track[index$track];
            if (track.isVideo()) 
                return track;
        }
        return null;
    };
    prototype.getAudioTracks = function() {
        var audio = new ArrayList();
        for (var index$track = 0, arr$track = this.tracks; index$track < arr$track.length; index$track++) {
            var track = arr$track[index$track];
            if (track.isAudio()) 
                audio.add(track);
        }
        return audio.toArray(Array(0));
    };
    constructor.MXFDemuxerTrack = function(demuxer, essenceUL, track, descriptor) {
        this.demuxer = demuxer;
        this.essenceUL = essenceUL;
        this.track = track;
        this.descriptor = descriptor;
        if (stjs.isInstanceOf(descriptor.constructor, GenericPictureEssenceDescriptor)) 
            this.video = true;
         else if (stjs.isInstanceOf(descriptor.constructor, GenericSoundEssenceDescriptor)) 
            this.audio = true;
        this.codec = this.resolveCodec();
        if (this.codec != null || (stjs.isInstanceOf(descriptor.constructor, WaveAudioDescriptor))) {
            Logger.warn("Track type: " + this.video + ", " + this.audio);
            if (this.audio && (stjs.isInstanceOf(descriptor.constructor, WaveAudioDescriptor))) {
                var wave = descriptor;
                this.cacheAudioFrameSizes(demuxer.ch);
                this.audioFrameDuration = stjs.trunc(this.dataLen / ((wave.getQuantizationBits() >> 3) * wave.getChannelCount()));
                this.audioTimescale = stjs.trunc(wave.getAudioSamplingRate().scalar());
            }
        }
    };
    constructor.MXFDemuxerTrack = stjs.extend(constructor.MXFDemuxerTrack, null, [SeekableDemuxerTrack], function(constructor, prototype) {
        prototype.essenceUL = null;
        prototype.dataLen = 0;
        prototype.indexSegmentIdx = 0;
        prototype.indexSegmentSubIdx = 0;
        prototype.frameNo = 0;
        prototype.pts = 0;
        prototype.partIdx = 0;
        prototype.partEssenceOffset = 0;
        prototype.descriptor = null;
        prototype.track = null;
        prototype.video = false;
        prototype.audio = false;
        prototype.codec = null;
        prototype.audioFrameDuration = 0;
        prototype.audioTimescale = 0;
        prototype.demuxer = null;
        prototype.isAudio = function() {
            return this.audio;
        };
        prototype.isVideo = function() {
            return this.video;
        };
        prototype.getDuration = function() {
            return this.demuxer.duration;
        };
        prototype.getNumFrames = function() {
            return this.demuxer.totalFrames;
        };
        prototype.getName = function() {
            return this.track.getName();
        };
        prototype.cacheAudioFrameSizes = function(ch) {
            for (var iterator$mxfPartition = this.demuxer.partitions.iterator(); iterator$mxfPartition.hasNext(); ) {
                var mxfPartition = iterator$mxfPartition.next();
                if (mxfPartition.getEssenceLength() > 0) {
                    ch.setPosition(mxfPartition.getEssenceFilePos());
                    var kl;
                    do {
                        kl = KLV.readKL(ch);
                        if (kl == null) 
                            break;
                        ch.setPosition(ch.position() + kl.len);
                    } while (!this.essenceUL.equals(kl.key));
                    if (kl != null && this.essenceUL.equals(kl.key)) {
                        this.dataLen = ((kl.len) | 0);
                        break;
                    }
                }
            }
        };
        prototype.nextFrame = function() {
            if (this.indexSegmentIdx >= this.demuxer.indexSegments.size()) 
                return null;
            var seg = this.demuxer.indexSegments.get(this.indexSegmentIdx);
            var off = seg.getIe().getFileOff();
            var erDen = seg.getIndexEditRateNum();
            var erNum = seg.getIndexEditRateDen();
            var frameEssenceOffset = off[this.indexSegmentSubIdx];
            var toff = seg.getIe().getDisplayOff()[this.indexSegmentSubIdx];
            var kf = seg.getIe().getKeyFrameOff()[this.indexSegmentSubIdx] == 0;
             while (frameEssenceOffset >= this.partEssenceOffset + this.demuxer.partitions.get(this.partIdx).getEssenceLength() && this.partIdx < this.demuxer.partitions.size() - 1){
                this.partEssenceOffset += this.demuxer.partitions.get(this.partIdx).getEssenceLength();
                this.partIdx++;
            }
            var frameFileOffset = frameEssenceOffset - this.partEssenceOffset + this.demuxer.partitions.get(this.partIdx).getEssenceFilePos();
            var result;
            if (!this.audio) {
                result = this.readPacket(frameFileOffset, this.dataLen, this.pts + erNum * toff, erDen, erNum, this.frameNo++, kf);
                this.pts += erNum;
            } else {
                result = this.readPacket(frameFileOffset, this.dataLen, this.pts, this.audioTimescale, this.audioFrameDuration, this.frameNo++, kf);
                this.pts += this.audioFrameDuration;
            }
            this.indexSegmentSubIdx++;
            if (this.indexSegmentSubIdx >= off.length) {
                this.indexSegmentIdx++;
                this.indexSegmentSubIdx = 0;
                if (this.dataLen == 0 && this.indexSegmentIdx < this.demuxer.indexSegments.size()) {
                    var nseg = this.demuxer.indexSegments.get(this.indexSegmentIdx);
                    this.pts = stjs.trunc(this.pts * nseg.getIndexEditRateNum() / erDen);
                }
            }
            return result;
        };
        prototype.readPacket = function(off, len, pts, timescale, duration, frameNo, kf) {
            var ch = this.demuxer.ch;
            {
                ch.setPosition(off);
                var kl = KLV.readKL(ch);
                 while (kl != null && !this.essenceUL.equals(kl.key)){
                    ch.setPosition(ch.position() + kl.len);
                    kl = KLV.readKL(ch);
                }
                return kl != null && this.essenceUL.equals(kl.key) ? new MXFDemuxer.MXFPacket(NIOUtils.fetchFromChannel(ch, ((kl.len) | 0)), pts, timescale, duration, frameNo, kf ? Packet.FrameType.KEY : Packet.FrameType.INTER, null, off, len) : null;
            }};
        prototype.gotoFrame = function(frameNo) {
            if (frameNo == this.frameNo) 
                return true;
            this.indexSegmentSubIdx = ((frameNo) | 0);
            for (this.indexSegmentIdx = 0; this.indexSegmentIdx < this.demuxer.indexSegments.size() && this.indexSegmentSubIdx >= this.demuxer.indexSegments.get(this.indexSegmentIdx).getIndexDuration(); this.indexSegmentIdx++) {
                this.indexSegmentSubIdx -= this.demuxer.indexSegments.get(this.indexSegmentIdx).getIndexDuration();
            }
            this.indexSegmentSubIdx = Math.min(this.indexSegmentSubIdx, ((this.demuxer.indexSegments.get(this.indexSegmentIdx).getIndexDuration()) | 0));
            return true;
        };
        prototype.gotoSyncFrame = function(frameNo) {
            if (!this.gotoFrame(frameNo)) 
                return false;
            var seg = this.demuxer.indexSegments.get(this.indexSegmentIdx);
            var kfOff = seg.getIe().getKeyFrameOff()[this.indexSegmentSubIdx];
            return this.gotoFrame(frameNo + kfOff);
        };
        prototype.getCurFrame = function() {
            return this.frameNo;
        };
        prototype.seek = function(second) {
             throw new NotSupportedException();
        };
        prototype.getEssenceUL = function() {
            return this.essenceUL;
        };
        prototype.getDescriptor = function() {
            return this.descriptor;
        };
        prototype.getCodec = function() {
            return this.codec;
        };
        prototype.resolveCodec = function() {
            var codecUL;
            if (this.video) 
                codecUL = (this.descriptor).getPictureEssenceCoding();
             else if (this.audio) 
                codecUL = (this.descriptor).getSoundEssenceCompression();
             else 
                return null;
            var values = MXFCodec.values();
            for (var i = 0; i < values.length; i++) {
                var codec = values[i];
                if (codec.getUl().equals(codecUL)) 
                    return codec;
            }
            Logger.warn("Unknown codec: " + codecUL);
            return null;
        };
        prototype.getTrackId = function() {
            return this.track.getTrackId();
        };
        prototype.getMeta = function() {
            var size = null;
            if (this.video) {
                var pd = this.descriptor;
                size = new Size(pd.getStoredWidth(), pd.getStoredHeight());
            }
            var t = this.video ? TrackType.VIDEO : (this.audio ? TrackType.AUDIO : TrackType.OTHER);
            return new DemuxerTrackMeta(t, this.getCodec().getCodec(), this.demuxer.duration, null, this.demuxer.totalFrames, null, VideoCodecMeta.createSimpleVideoCodecMeta(size, ColorSpace.YUV420), null);
        };
        prototype.getEditRate = function() {
            return this.track.getEditRate();
        };
    }, {essenceUL: "UL", descriptor: "GenericDescriptor", track: "TimelineTrack", codec: "MXFCodec", demuxer: "MXFDemuxer"}, {});
    constructor.MXFPacket = function(data, pts, timescale, duration, frameNo, frameType, tapeTimecode, offset, len) {
        Packet.call(this, data, pts, timescale, duration, frameNo, frameType, tapeTimecode, 0);
        this.offset = offset;
        this.len = len;
    };
    constructor.MXFPacket = stjs.extend(constructor.MXFPacket, Packet, [], function(constructor, prototype) {
        prototype.offset = 0;
        prototype.len = 0;
        prototype.getOffset = function() {
            return this.offset;
        };
        prototype.getLen = function() {
            return this.len;
        };
    }, {data: "ByteBuffer", frameType: {name: "Enum", arguments: ["Packet.FrameType"]}, tapeTimecode: "TapeTimecode", FRAME_ASC: {name: "Comparator", arguments: ["Packet"]}}, {});
    /**
     *  Fast loading version of demuxer, doesn't search for metadata in ALL the
     *  partitions, only the header and footer are being inspected
     */
    constructor.Fast = function(ch) {
        MXFDemuxer.call(this, ch);
    };
    constructor.Fast = stjs.extend(constructor.Fast, MXFDemuxer, [], function(constructor, prototype) {
        prototype.parseHeader = function(ff) {
            this.partitions = new ArrayList();
            this.metadata = new ArrayList();
            this.header = MXFDemuxer.readHeaderPartition(ff);
            this.metadata.addAll(MXFDemuxer.readPartitionMeta(ff, this.header));
            this.partitions.add(this.header);
            ff.setPosition(this.header.getPack().getFooterPartition());
            var kl = KLV.readKL(ff);
            if (kl != null) {
                var fetchFrom = NIOUtils.fetchFromChannel(ff, ((kl.len) | 0));
                var footer = MXFPartition.read(kl.key, fetchFrom, ff.position() - kl.offset, ff.size());
                this.metadata.addAll(MXFDemuxer.readPartitionMeta(ff, footer));
            }
        };
    }, {metadata: {name: "List", arguments: ["MXFMetadata"]}, header: "MXFPartition", partitions: {name: "List", arguments: ["MXFPartition"]}, indexSegments: {name: "List", arguments: ["IndexSegment"]}, ch: "SeekableByteChannel", tracks: "Array", timecode: "TimecodeComponent"}, {});
    prototype.getSourceClips = function(trackId) {
        var trackFound = true;
        var clips = new ArrayList();
        for (var iterator$m = this.metadata.iterator(); iterator$m.hasNext(); ) {
            var m = iterator$m.next();
            if (stjs.isInstanceOf(m.constructor, TimelineTrack)) {
                var tt = m;
                var trackId2 = tt.getTrackId();
                trackFound = (trackId2 == trackId);
            }
            if (trackFound && stjs.isInstanceOf(m.constructor, SourceClip)) {
                var clip = m;
                if (clip.getSourceTrackId() == trackId) {
                    clips.add(clip);
                }
            }
        }
        return clips;
    };
    constructor.readTapeTimecode = function(mxf) {
        var read = NIOUtils.readableChannel(mxf);
        try {
            var fast = new MXFDemuxer.Fast(read);
            var track = fast.getVideoTrack();
            var timecode = fast.getTimecode();
            var sourceClips = fast.getSourceClips(track.getTrackId());
            var tc = 0;
            var dropFrame = false;
            var editRate = null;
            if (timecode != null) {
                editRate = track.getEditRate();
                dropFrame = timecode.getDropFrame() != 0;
                tc = timecode.getStart();
            }
            for (var iterator$sourceClip = sourceClips.iterator(); iterator$sourceClip.hasNext(); ) {
                var sourceClip = iterator$sourceClip.next();
                tc += sourceClip.getStartPosition();
            }
            if (editRate != null) {
                return TapeTimecode.tapeTimecode(tc, dropFrame, stjs.trunc(Math.ceil(editRate.toDouble())));
            }
            return null;
        } finally {
            read.close();
        }
    };
    prototype.getMetadata = function() {
        return Collections.unmodifiableList(this.metadata);
    };
}, {metadata: {name: "List", arguments: ["MXFMetadata"]}, header: "MXFPartition", partitions: {name: "List", arguments: ["MXFPartition"]}, indexSegments: {name: "List", arguments: ["IndexSegment"]}, ch: "SeekableByteChannel", tracks: "Array", timecode: "TimecodeComponent"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Creates MP4 file out of a set of samples
 *  
 *  @author The JCodec project
 *  
 */
var TrakBox = function(atom) {
    NodeBox.call(this, atom);
};
TrakBox = stjs.extend(TrakBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "trak";
    };
    constructor.createTrakBox = function() {
        return new TrakBox(new Header(TrakBox.fourcc()));
    };
    prototype.setDataRef = function(url) {
        var minf = this.getMdia().getMinf();
        var dinf = minf.getDinf();
        if (dinf == null) {
            dinf = DataInfoBox.createDataInfoBox();
            minf.add(dinf);
        }
        var dref = dinf.getDref();
        var urlBox = UrlBox.createUrlBox(url);
        if (dref == null) {
            dref = DataRefBox.createDataRefBox();
            dinf.add(dref);
            dref.add(urlBox);
        } else {
            var lit = dref.boxes.listIterator();
             while (lit.hasNext()){
                var box = lit.next();
                if ((box.getFlags() & 1) != 0) 
                    lit.set(urlBox);
            }
        }
    };
    prototype.getMdia = function() {
        return NodeBox.findFirst(this, MediaBox, "mdia");
    };
    prototype.getTrackHeader = function() {
        return NodeBox.findFirst(this, TrackHeaderBox, "tkhd");
    };
    prototype.getEdits = function() {
        var elst = NodeBox.findFirstPath(this, EditListBox, Box.path("edts.elst"));
        if (elst == null) 
            return null;
        return elst.getEdits();
    };
    prototype.setEdits = function(edits) {
        var edts = NodeBox.findFirst(this, NodeBox, "edts");
        if (edts == null) {
            edts = new NodeBox(new Header("edts"));
            this.add(edts);
        }
        edts.removeChildren("elst");
        edts.add(EditListBox.createEditListBox(edits));
        this.getTrackHeader().setDuration(TrakBox.getEditedDuration(this));
    };
    prototype.isVideo = function() {
        return "vide".equals(this.getHandlerType());
    };
    prototype.isTimecode = function() {
        return "tmcd".equals(this.getHandlerType());
    };
    prototype.getHandlerType = function() {
        var handlerBox = NodeBox.findFirstPath(this, HandlerBox, Box.path("mdia.hdlr"));
        if (handlerBox == null) 
            return null;
        var type = handlerBox.getComponentSubType();
        return type;
    };
    prototype.isAudio = function() {
        return "soun".equals(this.getHandlerType());
    };
    /**
     *  Gets 'media timescale' of this track. This is the timescale used to
     *  represent the durations of samples inside mdia/minf/stbl/stts box.
     *  
     *  @return 'media timescale' of the track.
     */
    prototype.getTimescale = function() {
        return NodeBox.findFirstPath(this, MediaHeaderBox, Box.path("mdia.mdhd")).getTimescale();
    };
    /**
     *  Sets the 'media timescale' of this track. This is the time timescale used
     *  to represent sample durations.
     *  
     *  @param timescale
     *             A new 'media timescale' of this track.
     */
    prototype.setTimescale = function(timescale) {
        NodeBox.findFirstPath(this, MediaHeaderBox, Box.path("mdia.mdhd")).setTimescale(timescale);
    };
    prototype.rescale = function(tv, ts) {
        return stjs.trunc((tv * this.getTimescale()) / ts);
    };
    prototype.setDuration = function(duration) {
        this.getTrackHeader().setDuration(duration);
    };
    prototype.getDuration = function() {
        return this.getTrackHeader().getDuration();
    };
    prototype.getMediaDuration = function() {
        return NodeBox.findFirstPath(this, MediaHeaderBox, Box.path("mdia.mdhd")).getDuration();
    };
    prototype.isPureRef = function() {
        var minf = this.getMdia().getMinf();
        var dinf = minf.getDinf();
        if (dinf == null) {
            return false;
        }
        var dref = dinf.getDref();
        if (dref == null) 
            return false;
        for (var iterator$box = dref.boxes.iterator(); iterator$box.hasNext(); ) {
            var box = iterator$box.next();
            if (((box).getFlags() & 1) != 0) 
                return false;
        }
        return true;
    };
    prototype.hasDataRef = function() {
        var dinf = this.getMdia().getMinf().getDinf();
        if (dinf == null) {
            return false;
        }
        var dref = dinf.getDref();
        if (dref == null) 
            return false;
        var result = false;
        for (var iterator$box = dref.boxes.iterator(); iterator$box.hasNext(); ) {
            var box = iterator$box.next();
            result |= ((box).getFlags() & 1) != 1;
        }
        return result;
    };
    prototype.getPAR = function() {
        var pasp = NodeBox.findFirstPath(this, PixelAspectExt, ["mdia", "minf", "stbl", "stsd", null, "pasp"]);
        return pasp == null ? new Rational(1, 1) : pasp.getRational();
    };
    prototype.setPAR = function(par) {
        var sampleEntries = this.getSampleEntries();
        for (var i = 0; i < sampleEntries.length; i++) {
            var sampleEntry = sampleEntries[i];
            sampleEntry.removeChildren("pasp");
            sampleEntry.add(PixelAspectExt.createPixelAspectExt(par));
        }
    };
    prototype.getSampleEntries = function() {
        return NodeBox.findAllPath(this, SampleEntry, ["mdia", "minf", "stbl", "stsd", null]);
    };
    prototype.setClipRect = function(x, y, width, height) {
        var clip = NodeBox.findFirst(this, NodeBox, "clip");
        if (clip == null) {
            clip = new NodeBox(new Header("clip"));
            this.add(clip);
        }
        clip.replace("crgn", ClipRegionBox.createClipRegionBox(x, y, width, height));
    };
    prototype.getSampleCount = function() {
        return NodeBox.findFirstPath(this, SampleSizesBox, Box.path("mdia.minf.stbl.stsz")).getCount();
    };
    prototype.setAperture = function(sar, dar) {
        this.removeChildren("tapt");
        var tapt = new NodeBox(new Header("tapt"));
        tapt.add(ClearApertureBox.createClearApertureBox(dar.getWidth(), dar.getHeight()));
        tapt.add(ProductionApertureBox.createProductionApertureBox(dar.getWidth(), dar.getHeight()));
        tapt.add(EncodedPixelBox.createEncodedPixelBox(sar.getWidth(), sar.getHeight()));
        this.add(tapt);
    };
    prototype.setDimensions = function(dd) {
        this.getTrackHeader().setWidth(dd.getWidth());
        this.getTrackHeader().setHeight(dd.getHeight());
    };
    prototype.getFrameCount = function() {
        var stsz = NodeBox.findFirstPath(this, SampleSizesBox, Box.path("mdia.minf.stbl.stsz"));
        return stsz.getDefaultSize() != 0 ? stsz.getCount() : stsz.getSizes().length;
    };
    prototype.getName = function() {
        var nb = NodeBox.findFirstPath(this, NameBox, Box.path("udta.name"));
        return nb == null ? null : nb.getName();
    };
    prototype.fixMediaTimescale = function(ts) {
        var mdhd = NodeBox.findFirstPath(this, MediaHeaderBox, Box.path("mdia.mdhd"));
        var oldTs = mdhd.getTimescale();
        mdhd.setTimescale(ts);
        mdhd.setDuration(stjs.trunc((ts * mdhd.getDuration()) / oldTs));
        var edits = this.getEdits();
        if (edits != null) {
            for (var iterator$edit = edits.iterator(); iterator$edit.hasNext(); ) {
                var edit = iterator$edit.next();
                edit.setMediaTime(stjs.trunc((ts * edit.getMediaTime()) / oldTs));
            }
        }
        var tts = NodeBox.findFirstPath(this, TimeToSampleBox, Box.path("mdia.minf.stbl.stts"));
        var entries = tts.getEntries();
        for (var i = 0; i < entries.length; i++) {
            var tte = entries[i];
            tte.setSampleDuration(stjs.trunc((ts * tte.getSampleDuration()) / oldTs));
        }
    };
    prototype.setName = function(string) {
        var udta = NodeBox.findFirst(this, NodeBox, "udta");
        if (udta == null) {
            udta = new NodeBox(new Header("udta"));
            this.add(udta);
        }
        udta.removeChildren("name");
        udta.add(NameBox.createNameBox(string));
    };
    /**
     *  Retrieves coded size of this video track.
     *  
     *  Note: May be different from video display dimension.
     *  
     *  @return
     */
    prototype.getCodedSize = function() {
        var se = this.getSampleEntries()[0];
        if (!(stjs.isInstanceOf(se.constructor, VideoSampleEntry))) 
             throw new IllegalArgumentException("Not a video track");
        var vse = se;
        return new Size(vse.getWidth(), vse.getHeight());
    };
    prototype.getStts = function() {
        return NodeBox.findFirstPath(this, TimeToSampleBox, Box.path("mdia.minf.stbl.stts"));
    };
    prototype.getStco = function() {
        return NodeBox.findFirstPath(this, ChunkOffsetsBox, Box.path("mdia.minf.stbl.stco"));
    };
    prototype.getCo64 = function() {
        return NodeBox.findFirstPath(this, ChunkOffsets64Box, Box.path("mdia.minf.stbl.co64"));
    };
    prototype.getStsz = function() {
        return NodeBox.findFirstPath(this, SampleSizesBox, Box.path("mdia.minf.stbl.stsz"));
    };
    prototype.getStsc = function() {
        return NodeBox.findFirstPath(this, SampleToChunkBox, Box.path("mdia.minf.stbl.stsc"));
    };
    prototype.getStsd = function() {
        return NodeBox.findFirstPath(this, SampleDescriptionBox, Box.path("mdia.minf.stbl.stsd"));
    };
    prototype.getStss = function() {
        return NodeBox.findFirstPath(this, SyncSamplesBox, Box.path("mdia.minf.stbl.stss"));
    };
    prototype.getCtts = function() {
        return NodeBox.findFirstPath(this, CompositionOffsetsBox, Box.path("mdia.minf.stbl.ctts"));
    };
    constructor.getTrackType = function(trak) {
        var handler = NodeBox.findFirstPath(trak, HandlerBox, Box.path("mdia.hdlr"));
        return handler == null ? null : MP4TrackType.fromHandler(handler.getComponentSubType());
    };
    /**
     *  Calculates track duration considering edits
     *  
     *  @param track
     *  @return
     */
    constructor.getEditedDuration = function(track) {
        var edits = track.getEdits();
        if (edits == null) 
            return track.getDuration();
        var duration = 0;
        for (var iterator$edit = edits.iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            duration += edit.getDuration();
        }
        return duration;
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Contains various deblocking filter routines for deblocking on MB bases
 *  
 *  @author Stan Vitvitskyy
 *  
 */
var MBDeblocker = function() {};
MBDeblocker = stjs.extend(MBDeblocker, null, [], function(constructor, prototype) {
    constructor.LOOKUP_IDX_P_V = [new Int32Array([3, 7, 11, 15]), new Int32Array([0, 4, 8, 12]), new Int32Array([1, 5, 9, 13]), new Int32Array([2, 6, 10, 14])];
    constructor.LOOKUP_IDX_Q_V = [new Int32Array([0, 4, 8, 12]), new Int32Array([1, 5, 9, 13]), new Int32Array([2, 6, 10, 14]), new Int32Array([3, 7, 11, 15])];
    constructor.LOOKUP_IDX_P_H = [new Int32Array([12, 13, 14, 15]), new Int32Array([0, 1, 2, 3]), new Int32Array([4, 5, 6, 7]), new Int32Array([8, 9, 10, 11])];
    constructor.LOOKUP_IDX_Q_H = [new Int32Array([0, 1, 2, 3]), new Int32Array([4, 5, 6, 7]), new Int32Array([8, 9, 10, 11]), new Int32Array([12, 13, 14, 15])];
    constructor.BS_I = [new Int32Array([4, 4, 4, 4]), new Int32Array([3, 3, 3, 3]), new Int32Array([3, 3, 3, 3]), new Int32Array([3, 3, 3, 3])];
    /**
     *  Deblocks bottom edge of topOutMB, right edge of leftOutMB and left/top
     *  and inner block edges of outMB
     *  
     *  @param curPix
     *             Pixels of the current MB
     *  @param leftPix
     *             Pixels of the leftMB
     *  @param topPix
     *             Pixels of the tipMB
     *  
     *  @param vertStrength
     *             Border strengths for vertical edges (filtered first)
     *  @param horizStrength
     *             Border strengths for the horizontal edges
     *  
     *  @param curQp
     *             Current MB's qp
     *  @param leftQp
     *             Left MB's qp
     *  @param topQp
     *             Top MB's qp
     */
    prototype.deblockMBGeneric = function(curMB, leftMB, topMB, vertStrength, horizStrength) {
        var curPix = curMB.getPixels();
        if (leftMB != null) {
            var leftPix = leftMB.getPixels();
            var avgQp = MathUtil.clip((leftMB.getQp() + curMB.getQp() + 1) >> 1, 0, 51);
            this.deblockBorder(vertStrength[0], avgQp, leftPix.getPlaneData(0), 3, curPix.getPlaneData(0), 0, MBDeblocker.P_POS_V, MBDeblocker.Q_POS_V, false);
            this.deblockBorderChroma(vertStrength[0], avgQp, leftPix.getPlaneData(1), 3, curPix.getPlaneData(1), 0, MBDeblocker.P_POS_V_CHR, MBDeblocker.Q_POS_V_CHR, false);
            this.deblockBorderChroma(vertStrength[0], avgQp, leftPix.getPlaneData(2), 3, curPix.getPlaneData(2), 0, MBDeblocker.P_POS_V_CHR, MBDeblocker.Q_POS_V_CHR, false);
        }
        for (var i = 0; i < 3; i++) {
            this.deblockBorder(vertStrength[i + 1], curMB.getQp(), curPix.getPlaneData(0), i, curPix.getPlaneData(0), i + 1, MBDeblocker.P_POS_V, MBDeblocker.Q_POS_V, false);
            this.deblockBorderChroma(vertStrength[i + 1], curMB.getQp(), curPix.getPlaneData(1), i, curPix.getPlaneData(1), i + 1, MBDeblocker.P_POS_V_CHR, MBDeblocker.Q_POS_V_CHR, false);
            this.deblockBorderChroma(vertStrength[i + 1], curMB.getQp(), curPix.getPlaneData(2), i, curPix.getPlaneData(2), i + 1, MBDeblocker.P_POS_V_CHR, MBDeblocker.Q_POS_V_CHR, false);
        }
        if (topMB != null) {
            var topPix = topMB.getPixels();
            var avgQp = MathUtil.clip((topMB.getQp() + curMB.getQp() + 1) >> 1, 0, 51);
            this.deblockBorder(horizStrength[0], avgQp, topPix.getPlaneData(0), 3, curPix.getPlaneData(0), 0, MBDeblocker.P_POS_H, MBDeblocker.Q_POS_H, true);
            this.deblockBorderChroma(horizStrength[0], avgQp, topPix.getPlaneData(1), 3, curPix.getPlaneData(1), 0, MBDeblocker.P_POS_H_CHR, MBDeblocker.Q_POS_H_CHR, true);
            this.deblockBorderChroma(horizStrength[0], avgQp, topPix.getPlaneData(2), 3, curPix.getPlaneData(2), 0, MBDeblocker.P_POS_H_CHR, MBDeblocker.Q_POS_H_CHR, true);
        }
        for (var i = 0; i < 3; i++) {
            this.deblockBorder(horizStrength[i + 1], curMB.getQp(), curPix.getPlaneData(0), i, curPix.getPlaneData(0), i + 1, MBDeblocker.P_POS_H, MBDeblocker.Q_POS_H, true);
            this.deblockBorderChroma(horizStrength[i + 1], curMB.getQp(), curPix.getPlaneData(1), i, curPix.getPlaneData(1), i + 1, MBDeblocker.P_POS_H_CHR, MBDeblocker.Q_POS_H_CHR, true);
            this.deblockBorderChroma(horizStrength[i + 1], curMB.getQp(), curPix.getPlaneData(2), i, curPix.getPlaneData(2), i + 1, MBDeblocker.P_POS_H_CHR, MBDeblocker.Q_POS_H_CHR, true);
        }
    };
    prototype.deblockMBI = function(outMB, leftOutMB, topOutMB) {
        this.deblockMBGeneric(outMB, leftOutMB, topOutMB, MBDeblocker.BS_I, MBDeblocker.BS_I);
    };
    /**
     *  Deblocks P-macroblock
     *  
     *  @param cur
     *             Pixels and parameters of encoded and reconstructed current
     *             macroblock
     *  @param left
     *             Pixels and parameters of encoded and reconstructed left
     *             macroblock
     *  @param top
     *             Pixels and parameters of encoded and reconstructed top
     *             macroblock
     */
    prototype.deblockMBP = function(cur, left, top) {
        var vertStrength = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(4);
        });
        var horizStrength = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(4);
        });
        MBDeblocker.calcStrengthForBlocks(cur, left, vertStrength, MBDeblocker.LOOKUP_IDX_P_V, MBDeblocker.LOOKUP_IDX_Q_V);
        MBDeblocker.calcStrengthForBlocks(cur, top, horizStrength, MBDeblocker.LOOKUP_IDX_P_H, MBDeblocker.LOOKUP_IDX_Q_H);
        this.deblockMBGeneric(cur, left, top, vertStrength, horizStrength);
    };
    prototype.deblockBorder = function(boundary, qp, p, pi, q, qi, pTab, qTab, horiz) {
        var inc1 = horiz ? 16 : 1, inc2 = inc1 * 2, inc3 = inc1 * 3;
        for (var b = 0; b < 4; b++) {
            if (boundary[b] == 4) {
                for (var i = 0, ii = b << 2; i < 4; ++i , ++ii) 
                    this.filterBs4(qp, qp, p, q, pTab[pi][ii] - inc3, pTab[pi][ii] - inc2, pTab[pi][ii] - inc1, pTab[pi][ii], qTab[qi][ii], qTab[qi][ii] + inc1, qTab[qi][ii] + inc2, qTab[qi][ii] + inc3);
            } else if (boundary[b] > 0) {
                for (var i = 0, ii = b << 2; i < 4; ++i , ++ii) 
                    this.filterBs(boundary[b], qp, qp, p, q, pTab[pi][ii] - inc2, pTab[pi][ii] - inc1, pTab[pi][ii], qTab[qi][ii], qTab[qi][ii] + inc1, qTab[qi][ii] + inc2);
            }
        }
    };
    prototype.filterBs4Chr = function(indexAlpha, indexBeta, pelsP, pelsQ, p1Idx, p0Idx, q0Idx, q1Idx) {
        this._filterBs4(indexAlpha, indexBeta, pelsP, pelsQ, -1, -1, p1Idx, p0Idx, q0Idx, q1Idx, -1, -1, true);
    };
    prototype.filterBsChr = function(bs, indexAlpha, indexBeta, pelsP, pelsQ, p1Idx, p0Idx, q0Idx, q1Idx) {
        this._filterBs(bs, indexAlpha, indexBeta, pelsP, pelsQ, -1, p1Idx, p0Idx, q0Idx, q1Idx, -1, true);
    };
    prototype.filterBs4 = function(indexAlpha, indexBeta, pelsP, pelsQ, p3Idx, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, q3Idx) {
        this._filterBs4(indexAlpha, indexBeta, pelsP, pelsQ, p3Idx, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, q3Idx, false);
    };
    prototype.filterBs = function(bs, indexAlpha, indexBeta, pelsP, pelsQ, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx) {
        this._filterBs(bs, indexAlpha, indexBeta, pelsP, pelsQ, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, false);
    };
    prototype._filterBs4 = function(indexAlpha, indexBeta, pelsP, pelsQ, p3Idx, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, q3Idx, isChroma) {
        var p0 = pelsP[p0Idx];
        var q0 = pelsQ[q0Idx];
        var p1 = pelsP[p1Idx];
        var q1 = pelsQ[q1Idx];
        var alphaThresh = DeblockingFilter.alphaTab[indexAlpha];
        var betaThresh = DeblockingFilter.betaTab[indexBeta];
        var filterEnabled = Math.abs(p0 - q0) < alphaThresh && Math.abs(p1 - p0) < betaThresh && Math.abs(q1 - q0) < betaThresh;
        if (!filterEnabled) 
            return;
        var conditionP, conditionQ;
        if (isChroma) {
            conditionP = false;
            conditionQ = false;
        } else {
            var ap = Math.abs(pelsP[p2Idx] - p0);
            var aq = Math.abs(pelsQ[q2Idx] - q0);
            conditionP = ap < betaThresh && Math.abs(p0 - q0) < ((alphaThresh >> 2) + 2);
            conditionQ = aq < betaThresh && Math.abs(p0 - q0) < ((alphaThresh >> 2) + 2);
        }
        if (conditionP) {
            var p3 = pelsP[p3Idx];
            var p2 = pelsP[p2Idx];
            var p0n = (p2 + 2 * p1 + 2 * p0 + 2 * q0 + q1 + 4) >> 3;
            var p1n = (p2 + p1 + p0 + q0 + 2) >> 2;
            var p2n = (2 * p3 + 3 * p2 + p1 + p0 + q0 + 4) >> 3;
            pelsP[p0Idx] = (MathUtil.clip(p0n, -128, 127) << 24 >> 24);
            pelsP[p1Idx] = (MathUtil.clip(p1n, -128, 127) << 24 >> 24);
            pelsP[p2Idx] = (MathUtil.clip(p2n, -128, 127) << 24 >> 24);
        } else {
            var p0n = (2 * p1 + p0 + q1 + 2) >> 2;
            pelsP[p0Idx] = (MathUtil.clip(p0n, -128, 127) << 24 >> 24);
        }
        if (conditionQ && !isChroma) {
            var q2 = pelsQ[q2Idx];
            var q3 = pelsQ[q3Idx];
            var q0n = (p1 + 2 * p0 + 2 * q0 + 2 * q1 + q2 + 4) >> 3;
            var q1n = (p0 + q0 + q1 + q2 + 2) >> 2;
            var q2n = (2 * q3 + 3 * q2 + q1 + q0 + p0 + 4) >> 3;
            pelsQ[q0Idx] = (MathUtil.clip(q0n, -128, 127) << 24 >> 24);
            pelsQ[q1Idx] = (MathUtil.clip(q1n, -128, 127) << 24 >> 24);
            pelsQ[q2Idx] = (MathUtil.clip(q2n, -128, 127) << 24 >> 24);
        } else {
            var q0n = (2 * q1 + q0 + p1 + 2) >> 2;
            pelsQ[q0Idx] = (MathUtil.clip(q0n, -128, 127) << 24 >> 24);
        }
    };
    prototype._filterBs = function(bs, indexAlpha, indexBeta, pelsP, pelsQ, p2Idx, p1Idx, p0Idx, q0Idx, q1Idx, q2Idx, isChroma) {
        var p1 = pelsP[p1Idx];
        var p0 = pelsP[p0Idx];
        var q0 = pelsQ[q0Idx];
        var q1 = pelsQ[q1Idx];
        var alphaThresh = DeblockingFilter.alphaTab[indexAlpha];
        var betaThresh = DeblockingFilter.betaTab[indexBeta];
        var filterEnabled = Math.abs(p0 - q0) < alphaThresh && Math.abs(p1 - p0) < betaThresh && Math.abs(q1 - q0) < betaThresh;
        if (!filterEnabled) 
            return;
        var tC0 = DeblockingFilter.tcs[bs - 1][indexAlpha];
        var conditionP, conditionQ;
        var tC;
        if (!isChroma) {
            var ap = Math.abs(pelsP[p2Idx] - p0);
            var aq = Math.abs(pelsQ[q2Idx] - q0);
            tC = tC0 + ((ap < betaThresh) ? 1 : 0) + ((aq < betaThresh) ? 1 : 0);
            conditionP = ap < betaThresh;
            conditionQ = aq < betaThresh;
        } else {
            tC = tC0 + 1;
            conditionP = false;
            conditionQ = false;
        }
        var sigma = ((((q0 - p0) << 2) + (p1 - q1) + 4) >> 3);
        sigma = sigma < -tC ? -tC : (sigma > tC ? tC : sigma);
        var p0n = p0 + sigma;
        p0n = p0n < -128 ? -128 : p0n;
        var q0n = q0 - sigma;
        q0n = q0n < -128 ? -128 : q0n;
        if (conditionP) {
            var p2 = pelsP[p2Idx];
            var diff = (p2 + ((p0 + q0 + 1) >> 1) - (p1 << 1)) >> 1;
            diff = diff < -tC0 ? -tC0 : (diff > tC0 ? tC0 : diff);
            var p1n = p1 + diff;
            pelsP[p1Idx] = (MathUtil.clip(p1n, -128, 127) << 24 >> 24);
        }
        if (conditionQ) {
            var q2 = pelsQ[q2Idx];
            var diff = (q2 + ((p0 + q0 + 1) >> 1) - (q1 << 1)) >> 1;
            diff = diff < -tC0 ? -tC0 : (diff > tC0 ? tC0 : diff);
            var q1n = q1 + diff;
            pelsQ[q1Idx] = (MathUtil.clip(q1n, -128, 127) << 24 >> 24);
        }
        pelsQ[q0Idx] = (MathUtil.clip(q0n, -128, 127) << 24 >> 24);
        pelsP[p0Idx] = (MathUtil.clip(p0n, -128, 127) << 24 >> 24);
    };
    prototype.deblockBorderChroma = function(boundary, qp, p, pi, q, qi, pTab, qTab, horiz) {
        var inc1 = horiz ? 8 : 1;
        for (var b = 0; b < 4; b++) {
            if (boundary[b] == 4) {
                for (var i = 0, ii = b << 1; i < 2; ++i , ++ii) 
                    this.filterBs4Chr(qp, qp, p, q, pTab[pi][ii] - inc1, pTab[pi][ii], qTab[qi][ii], qTab[qi][ii] + inc1);
            } else if (boundary[b] > 0) {
                for (var i = 0, ii = b << 1; i < 2; ++i , ++ii) 
                    this.filterBsChr(boundary[b], qp, qp, p, q, pTab[pi][ii] - inc1, pTab[pi][ii], qTab[qi][ii], qTab[qi][ii] + inc1);
            }
        }
    };
    constructor.buildPPosH = function() {
        var qPos = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(16);
        });
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 16; j++) {
                qPos[i][j] = j + (i << 6) + 48;
            }
        }
        return qPos;
    };
    constructor.buildQPosH = function() {
        var pPos = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(16);
        });
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 16; j++) {
                pPos[i][j] = j + (i << 6);
            }
        }
        return pPos;
    };
    constructor.buildPPosV = function() {
        var qPos = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(16);
        });
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 16; j++) {
                qPos[i][j] = (j << 4) + (i << 2) + 3;
            }
        }
        return qPos;
    };
    constructor.buildQPosV = function() {
        var pPos = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(16);
        });
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 16; j++) {
                pPos[i][j] = (j << 4) + (i << 2);
            }
        }
        return pPos;
    };
    constructor.buildPPosHChr = function() {
        var qPos = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(8);
        });
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 8; j++) {
                qPos[i][j] = j + (i << 4) + 8;
            }
        }
        return qPos;
    };
    constructor.buildQPosHChr = function() {
        var pPos = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(8);
        });
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 8; j++) {
                pPos[i][j] = j + (i << 4);
            }
        }
        return pPos;
    };
    constructor.buildPPosVChr = function() {
        var qPos = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(8);
        });
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 8; j++) {
                qPos[i][j] = (j << 3) + (i << 1) + 1;
            }
        }
        return qPos;
    };
    constructor.buildQPosVChr = function() {
        var pPos = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(8);
        });
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 8; j++) {
                pPos[i][j] = (j << 3) + (i << 1);
            }
        }
        return pPos;
    };
    constructor.calcStrengthForBlocks = function(cur, other, outStrength, LOOKUP_IDX_P, LOOKUP_IDX_Q) {
        if (other != null) {
            for (var i = 0; i < 4; ++i) {
                outStrength[0][i] = other.getType().isIntra() ? 4 : MathUtil.max3(MBDeblocker.strengthMv(other.getMx()[LOOKUP_IDX_P[0][i]], cur.getMx()[LOOKUP_IDX_Q[0][i]]), MBDeblocker.strengthMv(other.getMy()[LOOKUP_IDX_P[0][i]], cur.getMy()[LOOKUP_IDX_Q[0][i]]), MBDeblocker.strengthNc(other.getNc()[LOOKUP_IDX_P[0][i]], cur.getNc()[LOOKUP_IDX_Q[0][i]]));
            }
        }
        for (var i = 1; i < 4; i++) {
            for (var j = 0; j < 4; ++j) {
                outStrength[i][j] = MathUtil.max3(MBDeblocker.strengthMv(cur.getMx()[LOOKUP_IDX_P[i][j]], cur.getMx()[LOOKUP_IDX_Q[i][j]]), MBDeblocker.strengthMv(cur.getMy()[LOOKUP_IDX_P[i][j]], cur.getMy()[LOOKUP_IDX_Q[i][j]]), MBDeblocker.strengthNc(cur.getNc()[LOOKUP_IDX_P[i][j]], cur.getNc()[LOOKUP_IDX_Q[i][j]]));
            }
        }
    };
    constructor.strengthNc = function(ncA, ncB) {
        return ncA > 0 || ncB > 0 ? 2 : 0;
    };
    constructor.strengthMv = function(v0, v1) {
        return Math.abs(v0 - v1) >= 4 ? 1 : 0;
    };
    constructor.P_POS_V = MBDeblocker.buildPPosV();
    constructor.Q_POS_V = MBDeblocker.buildQPosV();
    constructor.P_POS_H = MBDeblocker.buildPPosH();
    constructor.Q_POS_H = MBDeblocker.buildQPosH();
    constructor.P_POS_V_CHR = MBDeblocker.buildPPosVChr();
    constructor.Q_POS_V_CHR = MBDeblocker.buildQPosVChr();
    constructor.P_POS_H_CHR = MBDeblocker.buildPPosHChr();
    constructor.Q_POS_H_CHR = MBDeblocker.buildQPosHChr();
}, {LOOKUP_IDX_P_V: "Array", LOOKUP_IDX_Q_V: "Array", LOOKUP_IDX_P_H: "Array", LOOKUP_IDX_Q_H: "Array", BS_I: "Array", P_POS_V: "Array", Q_POS_V: "Array", P_POS_H: "Array", Q_POS_H: "Array", P_POS_V_CHR: "Array", Q_POS_V_CHR: "Array", P_POS_H_CHR: "Array", Q_POS_H_CHR: "Array"}, {});
/**
 *  A decoder for Intra PCM macroblocks
 *  
 *  @author The JCodec project
 */
var MBlockDecoderIPCM = function(mapper, decoderState) {
    this.mapper = mapper;
    this.s = decoderState;
};
MBlockDecoderIPCM = stjs.extend(MBlockDecoderIPCM, null, [], function(constructor, prototype) {
    prototype.mapper = null;
    prototype.s = null;
    prototype.decode = function(mBlock, mb) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        MBlockDecoderUtils.collectPredictors(this.s, mb, mbX);
        MBlockDecoderUtils.saveVectIntra(this.s, this.mapper.getMbX(mBlock.mbIdx));
    };
}, {mapper: "Mapper", s: "DecoderState"}, {});
/**
 *  A decoder for I16x16 macroblocks
 *  
 *  @author The JCodec project
 */
var MBlockDecoderIntra16x16 = function(mapper, sh, di, poc, decoderState) {
    MBlockDecoderBase.call(this, sh, di, poc, decoderState);
    this.mapper = mapper;
};
MBlockDecoderIntra16x16 = stjs.extend(MBlockDecoderIntra16x16, MBlockDecoderBase, [], function(constructor, prototype) {
    prototype.mapper = null;
    prototype.decode = function(mBlock, mb) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var address = this.mapper.getAddress(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        this.s.qp = (this.s.qp + mBlock.mbQPDelta + 52) % 52;
        this.di.mbQps[0][address] = this.s.qp;
        this.residualLumaI16x16(mBlock, leftAvailable, topAvailable, mbX, mbY);
        Intra16x16PredictionBuilder.predictWithMode(mBlock.luma16x16Mode, mBlock.ac[0], leftAvailable, topAvailable, this.s.leftRow[0], this.s.topLine[0], this.s.topLeft[0], mbX << 4, mb.getPlaneData(0));
        this.decodeChroma(mBlock, mbX, mbY, leftAvailable, topAvailable, mb, this.s.qp);
        this.di.mbTypes[address] = mBlock.curMbType;
        MBlockDecoderUtils.collectPredictors(this.s, mb, mbX);
        MBlockDecoderUtils.saveMvsIntra(this.di, mbX, mbY);
        MBlockDecoderUtils.saveVectIntra(this.s, this.mapper.getMbX(mBlock.mbIdx));
    };
    prototype.residualLumaI16x16 = function(mBlock, leftAvailable, topAvailable, mbX, mbY) {
        CoeffTransformer.invDC4x4(mBlock.dc);
        var scalingList = this.getScalingList(0);
        CoeffTransformer.dequantizeDC4x4(mBlock.dc, this.s.qp, scalingList);
        CoeffTransformer.reorderDC4x4(mBlock.dc);
        for (var i = 0; i < 16; i++) {
            if ((mBlock.cbpLuma() & (1 << (i >> 2))) != 0) {
                CoeffTransformer.dequantizeAC(mBlock.ac[0][i], this.s.qp, scalingList);
            }
            mBlock.ac[0][i][0] = mBlock.dc[i];
            CoeffTransformer.idct4x4(mBlock.ac[0][i]);
        }
    };
}, {mapper: "Mapper", s: "DecoderState", sh: "SliceHeader", di: "DeblockerInput", interpolator: "BlockInterpolator", mbb: "Array", scalingMatrix: "Array"}, {});
/**
 *  A decoder for I16x16 macroblocks
 *  
 *  @author The JCodec project
 */
var MBlockDecoderIntraNxN = function(mapper, sh, di, poc, decoderState) {
    MBlockDecoderBase.call(this, sh, di, poc, decoderState);
    this.mapper = mapper;
    this.prediction8x8Builder = new Intra8x8PredictionBuilder();
};
MBlockDecoderIntraNxN = stjs.extend(MBlockDecoderIntraNxN, MBlockDecoderBase, [], function(constructor, prototype) {
    prototype.mapper = null;
    prototype.prediction8x8Builder = null;
    prototype.decode = function(mBlock, mb) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var mbAddr = this.mapper.getAddress(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        var topLeftAvailable = this.mapper.topLeftAvailable(mBlock.mbIdx);
        var topRightAvailable = this.mapper.topRightAvailable(mBlock.mbIdx);
        if (mBlock.cbpLuma() > 0 || mBlock.cbpChroma() > 0) {
            this.s.qp = (this.s.qp + mBlock.mbQPDelta + 52) % 52;
        }
        this.di.mbQps[0][mbAddr] = this.s.qp;
        this.residualLuma(mBlock, leftAvailable, topAvailable, mbX, mbY);
        if (!mBlock.transform8x8Used) {
            for (var i = 0; i < 16; i++) {
                var blkX = (i & 3) << 2;
                var blkY = i & ~3;
                var bi = H264Const.BLK_INV_MAP[i];
                var trAvailable = ((bi == 0 || bi == 1 || bi == 4) && topAvailable) || (bi == 5 && topRightAvailable) || bi == 2 || bi == 6 || bi == 8 || bi == 9 || bi == 10 || bi == 12 || bi == 14;
                Intra4x4PredictionBuilder.predictWithMode(mBlock.lumaModes[bi], mBlock.ac[0][bi], blkX == 0 ? leftAvailable : true, blkY == 0 ? topAvailable : true, trAvailable, this.s.leftRow[0], this.s.topLine[0], this.s.topLeft[0], (mbX << 4), blkX, blkY, mb.getPlaneData(0));
            }
        } else {
            for (var i = 0; i < 4; i++) {
                var blkX = (i & 1) << 1;
                var blkY = i & 2;
                var trAvailable = (i == 0 && topAvailable) || (i == 1 && topRightAvailable) || i == 2;
                var tlAvailable = i == 0 ? topLeftAvailable : (i == 1 ? topAvailable : (i == 2 ? leftAvailable : true));
                this.prediction8x8Builder.predictWithMode(mBlock.lumaModes[i], mBlock.ac[0][i], blkX == 0 ? leftAvailable : true, blkY == 0 ? topAvailable : true, tlAvailable, trAvailable, this.s.leftRow[0], this.s.topLine[0], this.s.topLeft[0], (mbX << 4), blkX << 2, blkY << 2, mb.getPlaneData(0));
            }
        }
        this.decodeChroma(mBlock, mbX, mbY, leftAvailable, topAvailable, mb, this.s.qp);
        this.di.mbTypes[mbAddr] = mBlock.curMbType;
        this.di.tr8x8Used[mbAddr] = mBlock.transform8x8Used;
        MBlockDecoderUtils.collectChromaPredictors(this.s, mb, mbX);
        MBlockDecoderUtils.saveMvsIntra(this.di, mbX, mbY);
        MBlockDecoderUtils.saveVectIntra(this.s, this.mapper.getMbX(mBlock.mbIdx));
    };
}, {mapper: "Mapper", prediction8x8Builder: "Intra8x8PredictionBuilder", s: "DecoderState", sh: "SliceHeader", di: "DeblockerInput", interpolator: "BlockInterpolator", mbb: "Array", scalingMatrix: "Array"}, {});
/**
 *  A decoder for Inter 16x16, 16x8 and 8x16 macroblocks
 *  
 *  @author The JCodec project
 */
var MBlockDecoderInter8x8 = function(mapper, bDirectDecoder, sh, di, poc, decoderState) {
    MBlockDecoderBase.call(this, sh, di, poc, decoderState);
    this.mapper = mapper;
    this.bDirectDecoder = bDirectDecoder;
};
MBlockDecoderInter8x8 = stjs.extend(MBlockDecoderInter8x8, MBlockDecoderBase, [], function(constructor, prototype) {
    prototype.mapper = null;
    prototype.bDirectDecoder = null;
    prototype.decode = function(mBlock, references, mb, sliceType, ref0) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        var mbAddr = this.mapper.getAddress(mBlock.mbIdx);
        var topLeftAvailable = this.mapper.topLeftAvailable(mBlock.mbIdx);
        var topRightAvailable = this.mapper.topRightAvailable(mBlock.mbIdx);
        if (sliceType == SliceType.P) {
            this.predict8x8P(mBlock, references[0], mb, ref0, mbX, mbY, leftAvailable, topAvailable, topLeftAvailable, topRightAvailable, mBlock.x, mBlock.partPreds);
        } else {
            this.predict8x8B(mBlock, references, mb, ref0, mbX, mbY, leftAvailable, topAvailable, topLeftAvailable, topRightAvailable, mBlock.x, mBlock.partPreds);
        }
        this.predictChromaInter(references, mBlock.x, mbX << 3, mbY << 3, 1, mb, mBlock.partPreds);
        this.predictChromaInter(references, mBlock.x, mbX << 3, mbY << 3, 2, mb, mBlock.partPreds);
        if (mBlock.cbpLuma() > 0 || mBlock.cbpChroma() > 0) {
            this.s.qp = (this.s.qp + mBlock.mbQPDelta + 52) % 52;
        }
        this.di.mbQps[0][mbAddr] = this.s.qp;
        this.residualLuma(mBlock, leftAvailable, topAvailable, mbX, mbY);
        MBlockDecoderUtils.saveMvs(this.di, mBlock.x, mbX, mbY);
        var qp1 = MBlockDecoderBase.calcQpChroma(this.s.qp, this.s.chromaQpOffset[0]);
        var qp2 = MBlockDecoderBase.calcQpChroma(this.s.qp, this.s.chromaQpOffset[1]);
        this.decodeChromaResidual(mBlock, leftAvailable, topAvailable, mbX, mbY, qp1, qp2);
        this.di.mbQps[1][mbAddr] = qp1;
        this.di.mbQps[2][mbAddr] = qp2;
        MBlockDecoderUtils.mergeResidual(mb, mBlock.ac, mBlock.transform8x8Used ? H264Const.COMP_BLOCK_8x8_LUT : H264Const.COMP_BLOCK_4x4_LUT, mBlock.transform8x8Used ? H264Const.COMP_POS_8x8_LUT : H264Const.COMP_POS_4x4_LUT);
        MBlockDecoderUtils.collectPredictors(this.s, mb, mbX);
        this.di.mbTypes[mbAddr] = mBlock.curMbType;
        this.di.tr8x8Used[mbAddr] = mBlock.transform8x8Used;
    };
    prototype.predict8x8P = function(mBlock, references, mb, ref0, mbX, mbY, leftAvailable, topAvailable, tlAvailable, topRightAvailable, x, pp) {
        this.decodeSubMb8x8(mBlock, 0, mBlock.pb8x8.subMbTypes[0], references, mbX << 6, mbY << 6, this.s.mvTopLeft.getMv(0, 0), this.s.mvTop.getMv(mbX << 2, 0), this.s.mvTop.getMv((mbX << 2) + 1, 0), this.s.mvTop.getMv((mbX << 2) + 2, 0), this.s.mvLeft.getMv(0, 0), this.s.mvLeft.getMv(1, 0), tlAvailable, topAvailable, topAvailable, leftAvailable, mBlock.x, 0, 1, 4, 5, mBlock.pb8x8.refIdx[0][0], mb, 0, 0);
        this.decodeSubMb8x8(mBlock, 1, mBlock.pb8x8.subMbTypes[1], references, (mbX << 6) + 32, mbY << 6, this.s.mvTop.getMv((mbX << 2) + 1, 0), this.s.mvTop.getMv((mbX << 2) + 2, 0), this.s.mvTop.getMv((mbX << 2) + 3, 0), this.s.mvTop.getMv((mbX << 2) + 4, 0), x.getMv(1, 0), x.getMv(5, 0), topAvailable, topAvailable, topRightAvailable, true, x, 2, 3, 6, 7, mBlock.pb8x8.refIdx[0][1], mb, 8, 0);
        this.decodeSubMb8x8(mBlock, 2, mBlock.pb8x8.subMbTypes[2], references, mbX << 6, (mbY << 6) + 32, this.s.mvLeft.getMv(1, 0), x.getMv(4, 0), x.getMv(5, 0), x.getMv(6, 0), this.s.mvLeft.getMv(2, 0), this.s.mvLeft.getMv(3, 0), leftAvailable, true, true, leftAvailable, x, 8, 9, 12, 13, mBlock.pb8x8.refIdx[0][2], mb, 128, 0);
        this.decodeSubMb8x8(mBlock, 3, mBlock.pb8x8.subMbTypes[3], references, (mbX << 6) + 32, (mbY << 6) + 32, x.getMv(5, 0), x.getMv(6, 0), x.getMv(7, 0), MBlockDecoderUtils.NULL_VECTOR, x.getMv(9, 0), x.getMv(13, 0), true, true, false, true, x, 10, 11, 14, 15, mBlock.pb8x8.refIdx[0][3], mb, 136, 0);
        for (var i = 0; i < 4; i++) {
            var blk4x4 = H264Const.BLK8x8_BLOCKS[i][0];
            PredictionMerger.weightPrediction(this.sh, x.mv0R(blk4x4), 0, mb.getPlaneData(0), H264Const.BLK_8x8_MB_OFF_LUMA[i], 16, 8, 8, mb.getPlaneData(0));
        }
        MBlockDecoderUtils.savePrediction8x8(this.s, mbX, x);
        Arrays.fill(pp, H264Const.PartPred.L0);
    };
    prototype.predict8x8B = function(mBlock, refs, mb, ref0, mbX, mbY, leftAvailable, topAvailable, tlAvailable, topRightAvailable, x, p) {
        for (var i = 0; i < 4; i++) {
            p[i] = H264Const.bPartPredModes[mBlock.pb8x8.subMbTypes[i]];
        }
        for (var i = 0; i < 4; i++) {
            if (p[i] == H264Const.PartPred.Direct) 
                this.bDirectDecoder.predictBDirect(refs, mbX, mbY, leftAvailable, topAvailable, tlAvailable, topRightAvailable, x, p, mb, H264Const.ARRAY[i]);
        }
        for (var list = 0; list < 2; list++) {
            if (H264Const.usesList(H264Const.bPartPredModes[mBlock.pb8x8.subMbTypes[0]], list)) {
                this.decodeSubMb8x8(mBlock, 0, H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[0]], refs[list], mbX << 6, mbY << 6, this.s.mvTopLeft.getMv(0, list), this.s.mvTop.getMv(mbX << 2, list), this.s.mvTop.getMv((mbX << 2) + 1, list), this.s.mvTop.getMv((mbX << 2) + 2, list), this.s.mvLeft.getMv(0, list), this.s.mvLeft.getMv(1, list), tlAvailable, topAvailable, topAvailable, leftAvailable, x, 0, 1, 4, 5, mBlock.pb8x8.refIdx[list][0], this.mbb[list], 0, list);
            }
            if (H264Const.usesList(H264Const.bPartPredModes[mBlock.pb8x8.subMbTypes[1]], list)) {
                this.decodeSubMb8x8(mBlock, 1, H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[1]], refs[list], (mbX << 6) + 32, mbY << 6, this.s.mvTop.getMv((mbX << 2) + 1, list), this.s.mvTop.getMv((mbX << 2) + 2, list), this.s.mvTop.getMv((mbX << 2) + 3, list), this.s.mvTop.getMv((mbX << 2) + 4, list), x.getMv(1, list), x.getMv(5, list), topAvailable, topAvailable, topRightAvailable, true, x, 2, 3, 6, 7, mBlock.pb8x8.refIdx[list][1], this.mbb[list], 8, list);
            }
            if (H264Const.usesList(H264Const.bPartPredModes[mBlock.pb8x8.subMbTypes[2]], list)) {
                this.decodeSubMb8x8(mBlock, 2, H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[2]], refs[list], mbX << 6, (mbY << 6) + 32, this.s.mvLeft.getMv(1, list), x.getMv(4, list), x.getMv(5, list), x.getMv(6, list), this.s.mvLeft.getMv(2, list), this.s.mvLeft.getMv(3, list), leftAvailable, true, true, leftAvailable, x, 8, 9, 12, 13, mBlock.pb8x8.refIdx[list][2], this.mbb[list], 128, list);
            }
            if (H264Const.usesList(H264Const.bPartPredModes[mBlock.pb8x8.subMbTypes[3]], list)) {
                this.decodeSubMb8x8(mBlock, 3, H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[3]], refs[list], (mbX << 6) + 32, (mbY << 6) + 32, x.getMv(5, list), x.getMv(6, list), x.getMv(7, list), MBlockDecoderUtils.NULL_VECTOR, x.getMv(9, list), x.getMv(13, list), true, true, false, true, x, 10, 11, 14, 15, mBlock.pb8x8.refIdx[list][3], this.mbb[list], 136, list);
            }
        }
        for (var i = 0; i < 4; i++) {
            var blk4x4 = H264Const.BLK8x8_BLOCKS[i][0];
            PredictionMerger.mergePrediction(this.sh, x.mv0R(blk4x4), x.mv1R(blk4x4), H264Const.bPartPredModes[mBlock.pb8x8.subMbTypes[i]], 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), H264Const.BLK_8x8_MB_OFF_LUMA[i], 16, 8, 8, mb.getPlaneData(0), refs, this.poc);
        }
        MBlockDecoderUtils.savePrediction8x8(this.s, mbX, x);
    };
    prototype.decodeSubMb8x8 = function(mBlock, partNo, subMbType, references, offX, offY, tl, t0, t1, tr, l0, l1, tlAvb, tAvb, trAvb, lAvb, x, i00, i01, i10, i11, refIdx, mb, off, list) {
        switch (subMbType) {
            case 3:
                this.decodeSub4x4(mBlock, partNo, references, offX, offY, tl, t0, t1, tr, l0, l1, tlAvb, tAvb, trAvb, lAvb, x, i00, i01, i10, i11, refIdx, mb, off, list);
                break;
            case 2:
                this.decodeSub4x8(mBlock, partNo, references, offX, offY, tl, t0, t1, tr, l0, tlAvb, tAvb, trAvb, lAvb, x, i00, i01, i10, i11, refIdx, mb, off, list);
                break;
            case 1:
                this.decodeSub8x4(mBlock, partNo, references, offX, offY, tl, t0, tr, l0, l1, tlAvb, tAvb, trAvb, lAvb, x, i00, i01, i10, i11, refIdx, mb, off, list);
                break;
            case 0:
                this.decodeSub8x8(mBlock, partNo, references, offX, offY, tl, t0, tr, l0, tlAvb, tAvb, trAvb, lAvb, x, i00, i01, i10, i11, refIdx, mb, off, list);
        }
    };
    prototype.decodeSub8x8 = function(mBlock, partNo, references, offX, offY, tl, t0, tr, l0, tlAvb, tAvb, trAvb, lAvb, x, i00, i01, i10, i11, refIdx, mb, off, list) {
        var mvpX = MBlockDecoderUtils.calcMVPredictionMedian(l0, t0, tr, tl, lAvb, tAvb, trAvb, tlAvb, refIdx, 0);
        var mvpY = MBlockDecoderUtils.calcMVPredictionMedian(l0, t0, tr, tl, lAvb, tAvb, trAvb, tlAvb, refIdx, 1);
        var mv = H264Utils.Mv.packMv(mBlock.pb8x8.mvdX1[list][partNo] + mvpX, mBlock.pb8x8.mvdY1[list][partNo] + mvpY, refIdx);
        x.setMv(i00, list, mv);
        x.setMv(i01, list, mv);
        x.setMv(i10, list, mv);
        x.setMv(i11, list, mv);
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX, mvpY, mBlock.pb8x8.mvdX1[list][partNo], mBlock.pb8x8.mvdY1[list][partNo], H264Utils.Mv.mvX(mv), H264Utils.Mv.mvY(mv), refIdx);
        this.interpolator.getBlockLuma(references[refIdx], mb, off, offX + H264Utils.Mv.mvX(mv), offY + H264Utils.Mv.mvY(mv), 8, 8);
    };
    prototype.decodeSub8x4 = function(mBlock, partNo, references, offX, offY, tl, t0, tr, l0, l1, tlAvb, tAvb, trAvb, lAvb, x, i00, i01, i10, i11, refIdx, mb, off, list) {
        var mvpX1 = MBlockDecoderUtils.calcMVPredictionMedian(l0, t0, tr, tl, lAvb, tAvb, trAvb, tlAvb, refIdx, 0);
        var mvpY1 = MBlockDecoderUtils.calcMVPredictionMedian(l0, t0, tr, tl, lAvb, tAvb, trAvb, tlAvb, refIdx, 1);
        var mv1 = H264Utils.Mv.packMv(mBlock.pb8x8.mvdX1[list][partNo] + mvpX1, mBlock.pb8x8.mvdY1[list][partNo] + mvpY1, refIdx);
        x.setMv(i00, list, mv1);
        x.setMv(i01, list, mv1);
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX1, mvpY1, mBlock.pb8x8.mvdX1[list][partNo], mBlock.pb8x8.mvdY1[list][partNo], H264Utils.Mv.mvX(mv1), H264Utils.Mv.mvY(mv1), refIdx);
        var mvpX2 = MBlockDecoderUtils.calcMVPredictionMedian(l1, mv1, MBlockDecoderUtils.NULL_VECTOR, l0, lAvb, true, false, lAvb, refIdx, 0);
        var mvpY2 = MBlockDecoderUtils.calcMVPredictionMedian(l1, mv1, MBlockDecoderUtils.NULL_VECTOR, l0, lAvb, true, false, lAvb, refIdx, 1);
        var mv2 = H264Utils.Mv.packMv(mBlock.pb8x8.mvdX2[list][partNo] + mvpX2, mBlock.pb8x8.mvdY2[list][partNo] + mvpY2, refIdx);
        x.setMv(i10, list, mv2);
        x.setMv(i11, list, mv2);
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX2, mvpY2, mBlock.pb8x8.mvdX2[list][partNo], mBlock.pb8x8.mvdY2[list][partNo], H264Utils.Mv.mvX(mv2), H264Utils.Mv.mvY(mv2), refIdx);
        this.interpolator.getBlockLuma(references[refIdx], mb, off, offX + H264Utils.Mv.mvX(mv1), offY + H264Utils.Mv.mvY(mv1), 8, 4);
        this.interpolator.getBlockLuma(references[refIdx], mb, off + mb.getWidth() * 4, offX + H264Utils.Mv.mvX(mv2), offY + H264Utils.Mv.mvY(mv2) + 16, 8, 4);
    };
    prototype.decodeSub4x8 = function(mBlock, partNo, references, offX, offY, tl, t0, t1, tr, l0, tlAvb, tAvb, trAvb, lAvb, x, i00, i01, i10, i11, refIdx, mb, off, list) {
        var mvpX1 = MBlockDecoderUtils.calcMVPredictionMedian(l0, t0, t1, tl, lAvb, tAvb, tAvb, tlAvb, refIdx, 0);
        var mvpY1 = MBlockDecoderUtils.calcMVPredictionMedian(l0, t0, t1, tl, lAvb, tAvb, tAvb, tlAvb, refIdx, 1);
        var mv1 = H264Utils.Mv.packMv(mBlock.pb8x8.mvdX1[list][partNo] + mvpX1, mBlock.pb8x8.mvdY1[list][partNo] + mvpY1, refIdx);
        x.setMv(i00, list, mv1);
        x.setMv(i10, list, mv1);
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX1, mvpY1, mBlock.pb8x8.mvdX1[list][partNo], mBlock.pb8x8.mvdY1[list][partNo], H264Utils.Mv.mvX(mv1), H264Utils.Mv.mvY(mv1), refIdx);
        var mvpX2 = MBlockDecoderUtils.calcMVPredictionMedian(mv1, t1, tr, t0, true, tAvb, trAvb, tAvb, refIdx, 0);
        var mvpY2 = MBlockDecoderUtils.calcMVPredictionMedian(mv1, t1, tr, t0, true, tAvb, trAvb, tAvb, refIdx, 1);
        var mv2 = H264Utils.Mv.packMv(mBlock.pb8x8.mvdX2[list][partNo] + mvpX2, mBlock.pb8x8.mvdY2[list][partNo] + mvpY2, refIdx);
        x.setMv(i01, list, mv2);
        x.setMv(i11, list, mv2);
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX2, mvpY2, mBlock.pb8x8.mvdX2[list][partNo], mBlock.pb8x8.mvdY2[list][partNo], H264Utils.Mv.mvX(mv2), H264Utils.Mv.mvY(mv2), refIdx);
        this.interpolator.getBlockLuma(references[refIdx], mb, off, offX + H264Utils.Mv.mvX(mv1), offY + H264Utils.Mv.mvY(mv1), 4, 8);
        this.interpolator.getBlockLuma(references[refIdx], mb, off + 4, offX + H264Utils.Mv.mvX(mv2) + 16, offY + H264Utils.Mv.mvY(mv2), 4, 8);
    };
    prototype.decodeSub4x4 = function(mBlock, partNo, references, offX, offY, tl, t0, t1, tr, l0, l1, tlAvb, tAvb, trAvb, lAvb, x, i00, i01, i10, i11, refIdx, mb, off, list) {
        var mvpX1 = MBlockDecoderUtils.calcMVPredictionMedian(l0, t0, t1, tl, lAvb, tAvb, tAvb, tlAvb, refIdx, 0);
        var mvpY1 = MBlockDecoderUtils.calcMVPredictionMedian(l0, t0, t1, tl, lAvb, tAvb, tAvb, tlAvb, refIdx, 1);
        var mv1 = H264Utils.Mv.packMv(mBlock.pb8x8.mvdX1[list][partNo] + mvpX1, mBlock.pb8x8.mvdY1[list][partNo] + mvpY1, refIdx);
        x.setMv(i00, list, mv1);
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX1, mvpY1, mBlock.pb8x8.mvdX1[list][partNo], mBlock.pb8x8.mvdY1[list][partNo], H264Utils.Mv.mvX(mv1), H264Utils.Mv.mvY(mv1), refIdx);
        var mvpX2 = MBlockDecoderUtils.calcMVPredictionMedian(mv1, t1, tr, t0, true, tAvb, trAvb, tAvb, refIdx, 0);
        var mvpY2 = MBlockDecoderUtils.calcMVPredictionMedian(mv1, t1, tr, t0, true, tAvb, trAvb, tAvb, refIdx, 1);
        var mv2 = H264Utils.Mv.packMv(mBlock.pb8x8.mvdX2[list][partNo] + mvpX2, mBlock.pb8x8.mvdY2[list][partNo] + mvpY2, refIdx);
        x.setMv(i01, list, mv2);
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX2, mvpY2, mBlock.pb8x8.mvdX2[list][partNo], mBlock.pb8x8.mvdY2[list][partNo], H264Utils.Mv.mvX(mv2), H264Utils.Mv.mvY(mv2), refIdx);
        var mvpX3 = MBlockDecoderUtils.calcMVPredictionMedian(l1, mv1, mv2, l0, lAvb, true, true, lAvb, refIdx, 0);
        var mvpY3 = MBlockDecoderUtils.calcMVPredictionMedian(l1, mv1, mv2, l0, lAvb, true, true, lAvb, refIdx, 1);
        var mv3 = H264Utils.Mv.packMv(mBlock.pb8x8.mvdX3[list][partNo] + mvpX3, mBlock.pb8x8.mvdY3[list][partNo] + mvpY3, refIdx);
        x.setMv(i10, list, mv3);
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX3, mvpY3, mBlock.pb8x8.mvdX3[list][partNo], mBlock.pb8x8.mvdY3[list][partNo], H264Utils.Mv.mvX(mv3), H264Utils.Mv.mvY(mv3), refIdx);
        var mvpX4 = MBlockDecoderUtils.calcMVPredictionMedian(mv3, mv2, MBlockDecoderUtils.NULL_VECTOR, mv1, true, true, false, true, refIdx, 0);
        var mvpY4 = MBlockDecoderUtils.calcMVPredictionMedian(mv3, mv2, MBlockDecoderUtils.NULL_VECTOR, mv1, true, true, false, true, refIdx, 1);
        var mv4 = H264Utils.Mv.packMv(mBlock.pb8x8.mvdX4[list][partNo] + mvpX4, mBlock.pb8x8.mvdY4[list][partNo] + mvpY4, refIdx);
        x.setMv(i11, list, mv4);
        MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX4, mvpY4, mBlock.pb8x8.mvdX4[list][partNo], mBlock.pb8x8.mvdY4[list][partNo], H264Utils.Mv.mvX(mv4), H264Utils.Mv.mvY(mv4), refIdx);
        this.interpolator.getBlockLuma(references[refIdx], mb, off, offX + H264Utils.Mv.mvX(mv1), offY + H264Utils.Mv.mvY(mv1), 4, 4);
        this.interpolator.getBlockLuma(references[refIdx], mb, off + 4, offX + H264Utils.Mv.mvX(mv2) + 16, offY + H264Utils.Mv.mvY(mv2), 4, 4);
        this.interpolator.getBlockLuma(references[refIdx], mb, off + mb.getWidth() * 4, offX + H264Utils.Mv.mvX(mv3), offY + H264Utils.Mv.mvY(mv3) + 16, 4, 4);
        this.interpolator.getBlockLuma(references[refIdx], mb, off + mb.getWidth() * 4 + 4, offX + H264Utils.Mv.mvX(mv4) + 16, offY + H264Utils.Mv.mvY(mv4) + 16, 4, 4);
    };
}, {mapper: "Mapper", bDirectDecoder: "MBlockDecoderBDirect", s: "DecoderState", sh: "SliceHeader", di: "DeblockerInput", interpolator: "BlockInterpolator", mbb: "Array", scalingMatrix: "Array"}, {});
/**
 *  Contains reference picture list management logic
 *  
 *  @author The JCodec Project
 */
var RefListManager = function(sh, sRefs, lRefs, frameOut) {
    this.sh = sh;
    this.sRefs = sRefs;
    this.lRefs = lRefs;
    if (sh.numRefIdxActiveOverrideFlag) 
        this.numRef = new Int32Array([sh.numRefIdxActiveMinus1[0] + 1, sh.numRefIdxActiveMinus1[1] + 1]);
     else 
        this.numRef = new Int32Array([sh.pps.numRefIdxActiveMinus1[0] + 1, sh.pps.numRefIdxActiveMinus1[1] + 1]);
    this.frameOut = frameOut;
};
RefListManager = stjs.extend(RefListManager, null, [], function(constructor, prototype) {
    prototype.sh = null;
    prototype.numRef = null;
    prototype.sRefs = null;
    prototype.lRefs = null;
    prototype.frameOut = null;
    prototype.getRefList = function() {
        var refList = null;
        if (this.sh.sliceType == SliceType.P) {
            refList = [this.buildRefListP(), null];
        } else if (this.sh.sliceType == SliceType.B) {
            refList = this.buildRefListB();
        }
        MBlockDecoderUtils.debugPrint("------");
        if (refList != null) {
            for (var l = 0; l < 2; l++) {
                if (refList[l] != null) 
                    for (var i = 0; i < refList[l].length; i++) 
                        if (refList[l][i] != null) 
                            MBlockDecoderUtils.debugPrint("REF[%d][%d]: ", l, i, (refList[l][i]).getPOC());
            }
        }
        return refList;
    };
    prototype.buildRefListP = function() {
        var frame_num = this.sh.frameNum;
        var maxFrames = 1 << (this.sh.sps.log2MaxFrameNumMinus4 + 4);
        var result = Array(this.numRef[0]);
        var refs = 0;
        for (var i = frame_num - 1; i >= frame_num - maxFrames && refs < this.numRef[0]; i--) {
            var fn = i < 0 ? i + maxFrames : i;
            if (this.sRefs[fn] != null) {
                result[refs] = this.sRefs[fn] == H264Const.NO_PIC ? null : this.sRefs[fn];
                ++refs;
            }
        }
        var keys = this.lRefs.keys();
        Arrays.sort(keys);
        for (var i = 0; i < keys.length && refs < this.numRef[0]; i++) {
            result[refs++] = this.lRefs.get(keys[i]);
        }
        this.reorder(result, 0);
        return result;
    };
    prototype.buildRefListB = function() {
        var l0 = this.buildList(Frame.POCDesc, Frame.POCAsc);
        var l1 = this.buildList(Frame.POCAsc, Frame.POCDesc);
        if (Platform.arrayEqualsObj(l0, l1) && this.count(l1) > 1) {
            var frame = l1[1];
            l1[1] = l1[0];
            l1[0] = frame;
        }
        var result = [Platform.copyOfObj(l0, this.numRef[0]), Platform.copyOfObj(l1, this.numRef[1])];
        this.reorder(result[0], 0);
        this.reorder(result[1], 1);
        return result;
    };
    prototype.buildList = function(cmpFwd, cmpInv) {
        var refs = Array(this.sRefs.length + this.lRefs.size());
        var fwd = this.copySort(cmpFwd, this.frameOut);
        var inv = this.copySort(cmpInv, this.frameOut);
        var nFwd = this.count(fwd);
        var nInv = this.count(inv);
        var ref = 0;
        for (var i = 0; i < nFwd; i++ , ref++) 
            refs[ref] = fwd[i];
        for (var i = 0; i < nInv; i++ , ref++) 
            refs[ref] = inv[i];
        var keys = this.lRefs.keys();
        Arrays.sort(keys);
        for (var i = 0; i < keys.length; i++ , ref++) 
            refs[ref] = this.lRefs.get(keys[i]);
        return refs;
    };
    prototype.count = function(arr) {
        for (var nn = 0; nn < arr.length; nn++) 
            if (arr[nn] == null) 
                return nn;
        return arr.length;
    };
    prototype.copySort = function(fwd, dummy) {
        var copyOf = Platform.copyOfObj(this.sRefs, this.sRefs.length);
        for (var i = 0; i < copyOf.length; i++) 
            if (fwd.compare(dummy, copyOf[i]) > 0) 
                copyOf[i] = null;
        Arrays.sort(copyOf, fwd);
        return copyOf;
    };
    prototype.reorder = function(result, list) {
        if (this.sh.refPicReordering[list] == null) 
            return;
        var predict = this.sh.frameNum;
        var maxFrames = 1 << (this.sh.sps.log2MaxFrameNumMinus4 + 4);
        for (var ind = 0; ind < this.sh.refPicReordering[list][0].length; ind++) {
            switch (this.sh.refPicReordering[list][0][ind]) {
                case 0:
                    predict = MathUtil.wrap(predict - this.sh.refPicReordering[list][1][ind] - 1, maxFrames);
                    break;
                case 1:
                    predict = MathUtil.wrap(predict + this.sh.refPicReordering[list][1][ind] + 1, maxFrames);
                    break;
                case 2:
                     throw new RuntimeException("long term");
            }
            for (var i = this.numRef[list] - 1; i > ind; i--) 
                result[i] = result[i - 1];
            result[ind] = this.sRefs[predict];
            for (var i = ind + 1, j = i; i < this.numRef[list] && result[i] != null; i++) {
                if (result[i] != this.sRefs[predict]) 
                    result[j++] = result[i];
            }
        }
    };
}, {sh: "SliceHeader", numRef: "Int32Array", sRefs: "Array", lRefs: {name: "IntObjectMap", arguments: ["Frame"]}, frameOut: "Frame"}, {});
/**
 *  Contains methods for reading high-level symbols out of H.264 bitstream
 *  
 *  @author The JCodec Project
 */
var SliceReader = function(activePps, cabac, cavlc, mDecoder, reader, mapper, sh, nalUnit) {
    this.activePps = activePps;
    this.cabac = cabac;
    this.mDecoder = mDecoder;
    this.cavlc = cavlc;
    this.reader = reader;
    this.mapper = mapper;
    this.sh = sh;
    this.nalUnit = nalUnit;
    var mbWidth = sh.sps.picWidthInMbsMinus1 + 1;
    this.topMBType = Array(mbWidth);
    this.topCBPLuma = new Int32Array(mbWidth);
    this.topCBPChroma = new Int32Array(mbWidth);
    this.chromaFormat = sh.sps.chromaFormatIdc;
    this.transform8x8 = sh.pps.extended == null ? false : sh.pps.extended.transform8x8ModeFlag;
    if (sh.numRefIdxActiveOverrideFlag) 
        this.numRef = new Int32Array([sh.numRefIdxActiveMinus1[0] + 1, sh.numRefIdxActiveMinus1[1] + 1]);
     else 
        this.numRef = new Int32Array([sh.pps.numRefIdxActiveMinus1[0] + 1, sh.pps.numRefIdxActiveMinus1[1] + 1]);
    this.tf8x8Top = new Int8Array(mbWidth);
    this.predModeLeft = Array(2);
    this.predModeTop = Array(mbWidth << 1);
    this.i4x4PredLeft = new Int32Array(4);
    this.i4x4PredTop = new Int32Array(mbWidth << 2);
};
SliceReader = stjs.extend(SliceReader, null, [], function(constructor, prototype) {
    prototype.activePps = null;
    prototype.cabac = null;
    prototype.mDecoder = null;
    prototype.cavlc = null;
    prototype.reader = null;
    prototype.mapper = null;
    prototype.sh = null;
    prototype.nalUnit = null;
    prototype.prevMbSkipped = false;
    prototype.mbIdx = 0;
    prototype.prevMBType = null;
    prototype.mbSkipRun = 0;
    prototype.endOfData = false;
    prototype.topMBType = null;
    prototype.leftMBType = null;
    prototype.leftCBPLuma = 0;
    prototype.topCBPLuma = null;
    prototype.leftCBPChroma = 0;
    prototype.topCBPChroma = null;
    prototype.chromaFormat = null;
    prototype.transform8x8 = false;
    prototype.numRef = null;
    prototype.tf8x8Left = false;
    prototype.tf8x8Top = null;
    prototype.i4x4PredTop = null;
    prototype.i4x4PredLeft = null;
    prototype.predModeLeft = null;
    prototype.predModeTop = null;
    prototype.readMacroblock = function(mBlock) {
        var mbWidth = this.sh.sps.picWidthInMbsMinus1 + 1;
        var mbHeight = this.sh.sps.picHeightInMapUnitsMinus1 + 1;
        if (this.endOfData && this.mbSkipRun == 0 || this.mbIdx >= mbWidth * mbHeight) 
            return false;
        mBlock.mbIdx = this.mbIdx;
        mBlock.prevMbType = this.prevMBType;
        var mbaffFrameFlag = (this.sh.sps.mbAdaptiveFrameFieldFlag && !this.sh.fieldPicFlag);
        if (this.sh.sliceType.isInter() && !this.activePps.entropyCodingModeFlag) {
            if (!this.prevMbSkipped && this.mbSkipRun == 0) {
                this.mbSkipRun = CAVLCReader.readUEtrace(this.reader, "mb_skip_run");
                if (!CAVLCReader.moreRBSPData(this.reader)) {
                    this.endOfData = true;
                }
            }
            if (this.mbSkipRun > 0) {
                --this.mbSkipRun;
                var mbAddr = this.mapper.getAddress(this.mbIdx);
                this.prevMbSkipped = true;
                this.prevMBType = null;
                MBlockDecoderUtils.debugPrint("---------------------- MB (%d,%d) ---------------------", (mbAddr % mbWidth), (stjs.trunc(mbAddr / mbWidth)));
                mBlock.skipped = true;
                var mbX = this.mapper.getMbX(mBlock.mbIdx);
                this.topMBType[mbX] = this.leftMBType = null;
                var blk8x8X = mbX << 1;
                this.predModeLeft[0] = this.predModeLeft[1] = this.predModeTop[blk8x8X] = this.predModeTop[blk8x8X + 1] = H264Const.PartPred.L0;
                ++this.mbIdx;
                return true;
            } else {
                this.prevMbSkipped = false;
            }
        }
        var mbAddr = this.mapper.getAddress(this.mbIdx);
        var mbX = mbAddr % mbWidth;
        var mbY = stjs.trunc(mbAddr / mbWidth);
        MBlockDecoderUtils.debugPrint("---------------------- MB (%d,%d) ---------------------", mbX, mbY);
        if (this.sh.sliceType.isIntra() || (!this.activePps.entropyCodingModeFlag || !this.readMBSkipFlag(this.sh.sliceType, this.mapper.leftAvailable(this.mbIdx), this.mapper.topAvailable(this.mbIdx), mbX))) {
            var mb_field_decoding_flag = false;
            if (mbaffFrameFlag && (this.mbIdx % 2 == 0 || (this.mbIdx % 2 == 1 && this.prevMbSkipped))) {
                mb_field_decoding_flag = CAVLCReader.readBool(this.reader, "mb_field_decoding_flag");
            }
            mBlock.fieldDecoding = mb_field_decoding_flag;
            this.readMBlock(mBlock, this.sh.sliceType);
            this.prevMBType = mBlock.curMbType;
        } else {
            this.prevMBType = null;
            this.prevMbSkipped = true;
            mBlock.skipped = true;
            var blk8x8X = mbX << 1;
            this.predModeLeft[0] = this.predModeLeft[1] = this.predModeTop[blk8x8X] = this.predModeTop[blk8x8X + 1] = H264Const.PartPred.L0;
        }
        this.endOfData = (this.activePps.entropyCodingModeFlag && this.mDecoder.decodeFinalBin() == 1) || (!this.activePps.entropyCodingModeFlag && !CAVLCReader.moreRBSPData(this.reader));
        ++this.mbIdx;
        this.topMBType[this.mapper.getMbX(mBlock.mbIdx)] = this.leftMBType = mBlock.curMbType;
        return true;
    };
    prototype.readMBQpDelta = function(prevMbType) {
        var mbQPDelta;
        if (!this.activePps.entropyCodingModeFlag) {
            mbQPDelta = CAVLCReader.readSE(this.reader, "mb_qp_delta");
        } else {
            mbQPDelta = this.cabac.readMBQpDelta(this.mDecoder, prevMbType);
        }
        return mbQPDelta;
    };
    prototype.readChromaPredMode = function(mbX, leftAvailable, topAvailable) {
        var chromaPredictionMode;
        if (!this.activePps.entropyCodingModeFlag) {
            chromaPredictionMode = CAVLCReader.readUEtrace(this.reader, "MBP: intra_chroma_pred_mode");
        } else {
            chromaPredictionMode = this.cabac.readIntraChromaPredMode(this.mDecoder, mbX, this.leftMBType, this.topMBType[mbX], leftAvailable, topAvailable);
        }
        return chromaPredictionMode;
    };
    prototype.readTransform8x8Flag = function(leftAvailable, topAvailable, leftType, topType, is8x8Left, is8x8Top) {
        if (!this.activePps.entropyCodingModeFlag) 
            return CAVLCReader.readBool(this.reader, "transform_size_8x8_flag");
         else 
            return this.cabac.readTransform8x8Flag(this.mDecoder, leftAvailable, topAvailable, leftType, topType, is8x8Left, is8x8Top);
    };
    prototype.readCodedBlockPatternIntra = function(leftAvailable, topAvailable, leftCBP, topCBP, leftMB, topMB) {
        if (!this.activePps.entropyCodingModeFlag) 
            return H264Const.CODED_BLOCK_PATTERN_INTRA_COLOR[CAVLCReader.readUEtrace(this.reader, "coded_block_pattern")];
         else 
            return this.cabac.codedBlockPatternIntra(this.mDecoder, leftAvailable, topAvailable, leftCBP, topCBP, leftMB, topMB);
    };
    prototype.readCodedBlockPatternInter = function(leftAvailable, topAvailable, leftCBP, topCBP, leftMB, topMB) {
        if (!this.activePps.entropyCodingModeFlag) {
            var code = CAVLCReader.readUEtrace(this.reader, "coded_block_pattern");
            return H264Const.CODED_BLOCK_PATTERN_INTER_COLOR[code];
        } else 
            return this.cabac.codedBlockPatternIntra(this.mDecoder, leftAvailable, topAvailable, leftCBP, topCBP, leftMB, topMB);
    };
    prototype.readRefIdx = function(leftAvailable, topAvailable, leftType, topType, leftPred, topPred, curPred, mbX, partX, partY, partW, partH, list) {
        if (!this.activePps.entropyCodingModeFlag) 
            return CAVLCReader.readTE(this.reader, this.numRef[list] - 1);
         else 
            return this.cabac.readRefIdx(this.mDecoder, leftAvailable, topAvailable, leftType, topType, leftPred, topPred, curPred, mbX, partX, partY, partW, partH, list);
    };
    prototype.readMVD = function(comp, leftAvailable, topAvailable, leftType, topType, leftPred, topPred, curPred, mbX, partX, partY, partW, partH, list) {
        if (!this.activePps.entropyCodingModeFlag) 
            return CAVLCReader.readSE(this.reader, "mvd_l0_x");
         else 
            return this.cabac.readMVD(this.mDecoder, comp, leftAvailable, topAvailable, leftType, topType, leftPred, topPred, curPred, mbX, partX, partY, partW, partH, list);
    };
    prototype.readPredictionI4x4Block = function(leftAvailable, topAvailable, leftMBType, topMBType, blkX, blkY, mbX) {
        var mode = 2;
        if ((leftAvailable || blkX > 0) && (topAvailable || blkY > 0)) {
            var predModeB = topMBType == MBType.I_NxN || blkY > 0 ? this.i4x4PredTop[(mbX << 2) + blkX] : 2;
            var predModeA = leftMBType == MBType.I_NxN || blkX > 0 ? this.i4x4PredLeft[blkY] : 2;
            mode = Math.min(predModeB, predModeA);
        }
        if (!this.prev4x4PredMode()) {
            var rem_intra4x4_pred_mode = this.rem4x4PredMode();
            mode = rem_intra4x4_pred_mode + (rem_intra4x4_pred_mode < mode ? 0 : 1);
        }
        this.i4x4PredTop[(mbX << 2) + blkX] = this.i4x4PredLeft[blkY] = mode;
        return mode;
    };
    prototype.rem4x4PredMode = function() {
        if (!this.activePps.entropyCodingModeFlag) 
            return CAVLCReader.readNBit(this.reader, 3, "MB: rem_intra4x4_pred_mode");
         else 
            return this.cabac.rem4x4PredMode(this.mDecoder);
    };
    prototype.prev4x4PredMode = function() {
        if (!this.activePps.entropyCodingModeFlag) 
            return CAVLCReader.readBool(this.reader, "MBP: prev_intra4x4_pred_mode_flag");
         else 
            return this.cabac.prev4x4PredModeFlag(this.mDecoder);
    };
    prototype.read16x16DC = function(leftAvailable, topAvailable, mbX, dc) {
        if (!this.activePps.entropyCodingModeFlag) 
            this.cavlc[0].readLumaDCBlock(this.reader, dc, mbX, leftAvailable, this.leftMBType, topAvailable, this.topMBType[mbX], CoeffTransformer.zigzag4x4);
         else {
            if (this.cabac.readCodedBlockFlagLumaDC(this.mDecoder, mbX, this.leftMBType, this.topMBType[mbX], leftAvailable, topAvailable, MBType.I_16x16) == 1) 
                this.cabac.readCoeffs(this.mDecoder, CABAC.BlockType.LUMA_16_DC, dc, 0, 16, CoeffTransformer.zigzag4x4, H264Const.identityMapping16, H264Const.identityMapping16);
        }
    };
    /**
     *  Reads AC block of macroblock encoded as I_16x16, returns number of
     *  non-zero coefficients
     *  
     *  @return
     */
    prototype.read16x16AC = function(leftAvailable, topAvailable, mbX, cbpLuma, ac, blkOffLeft, blkOffTop, blkX, blkY) {
        if (!this.activePps.entropyCodingModeFlag) {
            return this.cavlc[0].readACBlock(this.reader, ac, blkX, blkOffTop, blkOffLeft != 0 || leftAvailable, blkOffLeft == 0 ? this.leftMBType : MBType.I_16x16, blkOffTop != 0 || topAvailable, blkOffTop == 0 ? this.topMBType[mbX] : MBType.I_16x16, 1, 15, CoeffTransformer.zigzag4x4);
        } else {
            if (this.cabac.readCodedBlockFlagLumaAC(this.mDecoder, CABAC.BlockType.LUMA_15_AC, blkX, blkOffTop, 0, this.leftMBType, this.topMBType[mbX], leftAvailable, topAvailable, this.leftCBPLuma, this.topCBPLuma[mbX], cbpLuma, MBType.I_16x16) == 1) 
                return this.cabac.readCoeffs(this.mDecoder, CABAC.BlockType.LUMA_15_AC, ac, 1, 15, CoeffTransformer.zigzag4x4, H264Const.identityMapping16, H264Const.identityMapping16);
        }
        return 0;
    };
    /**
     *  Reads AC block of a macroblock, return number of non-zero coefficients
     *  
     *  @return
     */
    prototype.readResidualAC = function(leftAvailable, topAvailable, mbX, curMbType, cbpLuma, blkOffLeft, blkOffTop, blkX, blkY, ac) {
        if (!this.activePps.entropyCodingModeFlag) {
            if (this.reader.remaining() <= 0) 
                return 0;
            return this.cavlc[0].readACBlock(this.reader, ac, blkX, blkOffTop, blkOffLeft != 0 || leftAvailable, blkOffLeft == 0 ? this.leftMBType : curMbType, blkOffTop != 0 || topAvailable, blkOffTop == 0 ? this.topMBType[mbX] : curMbType, 0, 16, CoeffTransformer.zigzag4x4);
        } else {
            if (this.cabac.readCodedBlockFlagLumaAC(this.mDecoder, CABAC.BlockType.LUMA_16, blkX, blkOffTop, 0, this.leftMBType, this.topMBType[mbX], leftAvailable, topAvailable, this.leftCBPLuma, this.topCBPLuma[mbX], cbpLuma, curMbType) == 1) 
                return this.cabac.readCoeffs(this.mDecoder, CABAC.BlockType.LUMA_16, ac, 0, 16, CoeffTransformer.zigzag4x4, H264Const.identityMapping16, H264Const.identityMapping16);
        }
        return 0;
    };
    prototype.setZeroCoeff = function(comp, blkX, blkOffTop) {
        this.cavlc[comp].setZeroCoeff(blkX, blkOffTop);
    };
    prototype.savePrevCBP = function(codedBlockPattern) {
        if (this.activePps.entropyCodingModeFlag) 
            this.cabac.setPrevCBP(codedBlockPattern);
    };
    prototype.readLumaAC = function(leftAvailable, topAvailable, mbX, curMbType, blkX, j, ac16, blkOffLeft, blkOffTop) {
        return this.cavlc[0].readACBlock(this.reader, ac16, blkX + (j & 1), blkOffTop, blkOffLeft != 0 || leftAvailable, blkOffLeft == 0 ? this.leftMBType : curMbType, blkOffTop != 0 || topAvailable, blkOffTop == 0 ? this.topMBType[mbX] : curMbType, 0, 16, H264Const.identityMapping16);
    };
    /**
     *  Reads luma AC coeffiecients for 8x8 blocks, returns number of non-zero
     *  coefficients
     *  
     *  @return
     */
    prototype.readLumaAC8x8 = function(blkX, blkY, ac) {
        var readCoeffs = this.cabac.readCoeffs(this.mDecoder, CABAC.BlockType.LUMA_64, ac, 0, 64, CoeffTransformer.zigzag8x8, H264Const.sig_coeff_map_8x8, H264Const.last_sig_coeff_map_8x8);
        this.cabac.setCodedBlock(blkX, blkY);
        this.cabac.setCodedBlock(blkX + 1, blkY);
        this.cabac.setCodedBlock(blkX, blkY + 1);
        this.cabac.setCodedBlock(blkX + 1, blkY + 1);
        return readCoeffs;
    };
    prototype.readSubMBTypeP = function() {
        if (!this.activePps.entropyCodingModeFlag) 
            return CAVLCReader.readUEtrace(this.reader, "SUB: sub_mb_type");
         else 
            return this.cabac.readSubMbTypeP(this.mDecoder);
    };
    prototype.readSubMBTypeB = function() {
        if (!this.activePps.entropyCodingModeFlag) 
            return CAVLCReader.readUEtrace(this.reader, "SUB: sub_mb_type");
         else 
            return this.cabac.readSubMbTypeB(this.mDecoder);
    };
    prototype.readChromaDC = function(mbX, leftAvailable, topAvailable, dc, comp, curMbType) {
        if (!this.activePps.entropyCodingModeFlag) 
            this.cavlc[comp].readChromaDCBlock(this.reader, dc, leftAvailable, topAvailable);
         else {
            if (this.cabac.readCodedBlockFlagChromaDC(this.mDecoder, mbX, comp, this.leftMBType, this.topMBType[mbX], leftAvailable, topAvailable, this.leftCBPChroma, this.topCBPChroma[mbX], curMbType) == 1) 
                this.cabac.readCoeffs(this.mDecoder, CABAC.BlockType.CHROMA_DC, dc, 0, 4, H264Const.identityMapping16, H264Const.identityMapping16, H264Const.identityMapping16);
        }
    };
    prototype.readChromaAC = function(leftAvailable, topAvailable, mbX, comp, curMbType, ac, blkOffLeft, blkOffTop, blkX) {
        if (!this.activePps.entropyCodingModeFlag) {
            if (this.reader.remaining() <= 0) 
                return;
            this.cavlc[comp].readACBlock(this.reader, ac, blkX, blkOffTop, blkOffLeft != 0 || leftAvailable, blkOffLeft == 0 ? this.leftMBType : curMbType, blkOffTop != 0 || topAvailable, blkOffTop == 0 ? this.topMBType[mbX] : curMbType, 1, 15, CoeffTransformer.zigzag4x4);
        } else {
            if (this.cabac.readCodedBlockFlagChromaAC(this.mDecoder, blkX, blkOffTop, comp, this.leftMBType, this.topMBType[mbX], leftAvailable, topAvailable, this.leftCBPChroma, this.topCBPChroma[mbX], curMbType) == 1) 
                this.cabac.readCoeffs(this.mDecoder, CABAC.BlockType.CHROMA_AC, ac, 1, 15, CoeffTransformer.zigzag4x4, H264Const.identityMapping16, H264Const.identityMapping16);
        }
    };
    prototype.decodeMBTypeI = function(mbIdx, leftAvailable, topAvailable, leftMBType, topMBType) {
        var mbType;
        if (!this.activePps.entropyCodingModeFlag) 
            mbType = CAVLCReader.readUEtrace(this.reader, "MB: mb_type");
         else 
            mbType = this.cabac.readMBTypeI(this.mDecoder, leftMBType, topMBType, leftAvailable, topAvailable);
        return mbType;
    };
    prototype.readMBTypeP = function() {
        var mbType;
        if (!this.activePps.entropyCodingModeFlag) 
            mbType = CAVLCReader.readUEtrace(this.reader, "MB: mb_type");
         else 
            mbType = this.cabac.readMBTypeP(this.mDecoder);
        return mbType;
    };
    prototype.readMBTypeB = function(mbIdx, leftAvailable, topAvailable, leftMBType, topMBType) {
        var mbType;
        if (!this.activePps.entropyCodingModeFlag) 
            mbType = CAVLCReader.readUEtrace(this.reader, "MB: mb_type");
         else 
            mbType = this.cabac.readMBTypeB(this.mDecoder, leftMBType, topMBType, leftAvailable, topAvailable);
        return mbType;
    };
    prototype.readMBSkipFlag = function(slType, leftAvailable, topAvailable, mbX) {
        return this.cabac.readMBSkipFlag(this.mDecoder, slType, leftAvailable, topAvailable, mbX);
    };
    prototype.readIntra16x16 = function(mbType, mBlock) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        mBlock.cbp((stjs.trunc(mbType / 12)) * 15, (stjs.trunc(mbType / 4)) % 3);
        mBlock.luma16x16Mode = mbType % 4;
        mBlock.chromaPredictionMode = this.readChromaPredMode(mbX, leftAvailable, topAvailable);
        mBlock.mbQPDelta = this.readMBQpDelta(mBlock.prevMbType);
        this.read16x16DC(leftAvailable, topAvailable, mbX, mBlock.dc);
        for (var i = 0; i < 16; i++) {
            var blkOffLeft = H264Const.MB_BLK_OFF_LEFT[i];
            var blkOffTop = H264Const.MB_BLK_OFF_TOP[i];
            var blkX = (mbX << 2) + blkOffLeft;
            var blkY = (mbY << 2) + blkOffTop;
            if ((mBlock.cbpLuma() & (1 << (i >> 2))) != 0) {
                mBlock.nCoeff[i] = this.read16x16AC(leftAvailable, topAvailable, mbX, mBlock.cbpLuma(), mBlock.ac[0][i], blkOffLeft, blkOffTop, blkX, blkY);
            } else {
                if (!this.sh.pps.entropyCodingModeFlag) 
                    this.setZeroCoeff(0, blkX, blkOffTop);
            }
        }
        if (this.chromaFormat != ColorSpace.MONO) {
            this.readChromaResidual(mBlock, leftAvailable, topAvailable, mbX);
        }
    };
    prototype.readMBlockBDirect = function(mBlock) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var lAvb = this.mapper.leftAvailable(mBlock.mbIdx);
        var tAvb = this.mapper.topAvailable(mBlock.mbIdx);
        mBlock._cbp = this.readCodedBlockPatternInter(lAvb, tAvb, this.leftCBPLuma | (this.leftCBPChroma << 4), this.topCBPLuma[mbX] | (this.topCBPChroma[mbX] << 4), this.leftMBType, this.topMBType[mbX]);
        mBlock.transform8x8Used = false;
        if (this.transform8x8 && mBlock.cbpLuma() != 0 && this.sh.sps.direct8x8InferenceFlag) {
            mBlock.transform8x8Used = this.readTransform8x8Flag(lAvb, tAvb, this.leftMBType, this.topMBType[mbX], this.tf8x8Left, this.tf8x8Top[mbX]);
        }
        if (mBlock.cbpLuma() > 0 || mBlock.cbpChroma() > 0) {
            mBlock.mbQPDelta = this.readMBQpDelta(mBlock.prevMbType);
        }
        this.readResidualLuma(mBlock, lAvb, tAvb, mbX, mbY);
        this.readChromaResidual(mBlock, lAvb, tAvb, mbX);
        this.predModeTop[mbX << 1] = this.predModeTop[(mbX << 1) + 1] = this.predModeLeft[0] = this.predModeLeft[1] = H264Const.PartPred.Direct;
    };
    prototype.readInter16x16 = function(p0, mBlock) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        for (var list = 0; list < 2; list++) {
            if (H264Const.usesList(p0, list) && this.numRef[list] > 1) 
                mBlock.pb16x16.refIdx[list] = this.readRefIdx(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[(mbX << 1)], p0, mbX, 0, 0, 4, 4, list);
        }
        for (var list = 0; list < 2; list++) {
            this.readPredictionInter16x16(mBlock, mbX, leftAvailable, topAvailable, list, p0);
        }
        this.readResidualInter(mBlock, leftAvailable, topAvailable, mbX, mbY);
        this.predModeLeft[0] = this.predModeLeft[1] = this.predModeTop[mbX << 1] = this.predModeTop[(mbX << 1) + 1] = p0;
    };
    prototype.readPredInter8x16 = function(mBlock, mbX, leftAvailable, topAvailable, list, p0, p1) {
        var blk8x8X = (mbX << 1);
        if (H264Const.usesList(p0, list)) {
            mBlock.pb168x168.mvdX1[list] = this.readMVD(0, leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[blk8x8X], p0, mbX, 0, 0, 2, 4, list);
            mBlock.pb168x168.mvdY1[list] = this.readMVD(1, leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[blk8x8X], p0, mbX, 0, 0, 2, 4, list);
        }
        if (H264Const.usesList(p1, list)) {
            mBlock.pb168x168.mvdX2[list] = this.readMVD(0, true, topAvailable, MBType.P_8x16, this.topMBType[mbX], p0, this.predModeTop[blk8x8X + 1], p1, mbX, 2, 0, 2, 4, list);
            mBlock.pb168x168.mvdY2[list] = this.readMVD(1, true, topAvailable, MBType.P_8x16, this.topMBType[mbX], p0, this.predModeTop[blk8x8X + 1], p1, mbX, 2, 0, 2, 4, list);
        }
    };
    prototype.readPredictionInter16x8 = function(mBlock, mbX, leftAvailable, topAvailable, p0, p1, list) {
        var blk8x8X = mbX << 1;
        if (H264Const.usesList(p0, list)) {
            mBlock.pb168x168.mvdX1[list] = this.readMVD(0, leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[blk8x8X], p0, mbX, 0, 0, 4, 2, list);
            mBlock.pb168x168.mvdY1[list] = this.readMVD(1, leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[blk8x8X], p0, mbX, 0, 0, 4, 2, list);
        }
        if (H264Const.usesList(p1, list)) {
            mBlock.pb168x168.mvdX2[list] = this.readMVD(0, leftAvailable, true, this.leftMBType, MBType.P_16x8, this.predModeLeft[1], p0, p1, mbX, 0, 2, 4, 2, list);
            mBlock.pb168x168.mvdY2[list] = this.readMVD(1, leftAvailable, true, this.leftMBType, MBType.P_16x8, this.predModeLeft[1], p0, p1, mbX, 0, 2, 4, 2, list);
        }
    };
    prototype.readInter16x8 = function(p0, p1, mBlock) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        for (var list = 0; list < 2; list++) {
            if (H264Const.usesList(p0, list) && this.numRef[list] > 1) 
                mBlock.pb168x168.refIdx1[list] = this.readRefIdx(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[(mbX << 1)], p0, mbX, 0, 0, 4, 2, list);
            if (H264Const.usesList(p1, list) && this.numRef[list] > 1) 
                mBlock.pb168x168.refIdx2[list] = this.readRefIdx(leftAvailable, true, this.leftMBType, mBlock.curMbType, this.predModeLeft[1], p0, p1, mbX, 0, 2, 4, 2, list);
        }
        for (var list = 0; list < 2; list++) {
            this.readPredictionInter16x8(mBlock, mbX, leftAvailable, topAvailable, p0, p1, list);
        }
        this.readResidualInter(mBlock, leftAvailable, topAvailable, mbX, mbY);
        this.predModeLeft[0] = p0;
        this.predModeLeft[1] = this.predModeTop[mbX << 1] = this.predModeTop[(mbX << 1) + 1] = p1;
    };
    prototype.readIntra8x16 = function(p0, p1, mBlock) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        for (var list = 0; list < 2; list++) {
            if (H264Const.usesList(p0, list) && this.numRef[list] > 1) 
                mBlock.pb168x168.refIdx1[list] = this.readRefIdx(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[mbX << 1], p0, mbX, 0, 0, 2, 4, list);
            if (H264Const.usesList(p1, list) && this.numRef[list] > 1) 
                mBlock.pb168x168.refIdx2[list] = this.readRefIdx(true, topAvailable, mBlock.curMbType, this.topMBType[mbX], p0, this.predModeTop[(mbX << 1) + 1], p1, mbX, 2, 0, 2, 4, list);
        }
        for (var list = 0; list < 2; list++) {
            this.readPredInter8x16(mBlock, mbX, leftAvailable, topAvailable, list, p0, p1);
        }
        this.readResidualInter(mBlock, leftAvailable, topAvailable, mbX, mbY);
        this.predModeTop[mbX << 1] = p0;
        this.predModeTop[(mbX << 1) + 1] = this.predModeLeft[0] = this.predModeLeft[1] = p1;
    };
    prototype.readPredictionInter16x16 = function(mBlock, mbX, leftAvailable, topAvailable, list, curPred) {
        var blk8x8X = (mbX << 1);
        if (H264Const.usesList(curPred, list)) {
            mBlock.pb16x16.mvdX[list] = this.readMVD(0, leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[blk8x8X], curPred, mbX, 0, 0, 4, 4, list);
            mBlock.pb16x16.mvdY[list] = this.readMVD(1, leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[blk8x8X], curPred, mbX, 0, 0, 4, 4, list);
        }
    };
    prototype.readResidualInter = function(mBlock, leftAvailable, topAvailable, mbX, mbY) {
        mBlock._cbp = this.readCodedBlockPatternInter(leftAvailable, topAvailable, this.leftCBPLuma | (this.leftCBPChroma << 4), this.topCBPLuma[mbX] | (this.topCBPChroma[mbX] << 4), this.leftMBType, this.topMBType[mbX]);
        mBlock.transform8x8Used = false;
        if (mBlock.cbpLuma() != 0 && this.transform8x8) {
            mBlock.transform8x8Used = this.readTransform8x8Flag(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.tf8x8Left, this.tf8x8Top[mbX]);
        }
        if (mBlock.cbpLuma() > 0 || mBlock.cbpChroma() > 0) {
            mBlock.mbQPDelta = this.readMBQpDelta(mBlock.prevMbType);
        }
        this.readResidualLuma(mBlock, leftAvailable, topAvailable, mbX, mbY);
        if (this.chromaFormat != ColorSpace.MONO) {
            this.readChromaResidual(mBlock, leftAvailable, topAvailable, mbX);
        }
    };
    prototype.readMBlock8x8 = function(mBlock) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        var noSubMBLessThen8x8;
        if (mBlock.curMbType == MBType.P_8x8 || mBlock.curMbType == MBType.P_8x8ref0) {
            this.readPrediction8x8P(mBlock, mbX, leftAvailable, topAvailable);
            noSubMBLessThen8x8 = mBlock.pb8x8.subMbTypes[0] == 0 && mBlock.pb8x8.subMbTypes[1] == 0 && mBlock.pb8x8.subMbTypes[2] == 0 && mBlock.pb8x8.subMbTypes[3] == 0;
        } else {
            this.readPrediction8x8B(mBlock, mbX, leftAvailable, topAvailable);
            noSubMBLessThen8x8 = H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[0]] == 0 && H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[1]] == 0 && H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[2]] == 0 && H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[3]] == 0;
        }
        mBlock._cbp = this.readCodedBlockPatternInter(leftAvailable, topAvailable, this.leftCBPLuma | (this.leftCBPChroma << 4), this.topCBPLuma[mbX] | (this.topCBPChroma[mbX] << 4), this.leftMBType, this.topMBType[mbX]);
        mBlock.transform8x8Used = false;
        if (this.transform8x8 && mBlock.cbpLuma() != 0 && noSubMBLessThen8x8) {
            mBlock.transform8x8Used = this.readTransform8x8Flag(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.tf8x8Left, this.tf8x8Top[mbX]);
        }
        if (mBlock.cbpLuma() > 0 || mBlock.cbpChroma() > 0) {
            mBlock.mbQPDelta = this.readMBQpDelta(mBlock.prevMbType);
        }
        this.readResidualLuma(mBlock, leftAvailable, topAvailable, mbX, mbY);
        this.readChromaResidual(mBlock, leftAvailable, topAvailable, mbX);
    };
    prototype.readPrediction8x8P = function(mBlock, mbX, leftAvailable, topAvailable) {
        for (var i = 0; i < 4; i++) {
            mBlock.pb8x8.subMbTypes[i] = this.readSubMBTypeP();
        }
        if (this.numRef[0] > 1 && mBlock.curMbType != MBType.P_8x8ref0) {
            mBlock.pb8x8.refIdx[0][0] = this.readRefIdx(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, mbX, 0, 0, 2, 2, 0);
            mBlock.pb8x8.refIdx[0][1] = this.readRefIdx(true, topAvailable, MBType.P_8x8, this.topMBType[mbX], H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, mbX, 2, 0, 2, 2, 0);
            mBlock.pb8x8.refIdx[0][2] = this.readRefIdx(leftAvailable, true, this.leftMBType, MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, mbX, 0, 2, 2, 2, 0);
            mBlock.pb8x8.refIdx[0][3] = this.readRefIdx(true, true, MBType.P_8x8, MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, mbX, 2, 2, 2, 2, 0);
        }
        this.readSubMb8x8(mBlock, 0, mBlock.pb8x8.subMbTypes[0], topAvailable, leftAvailable, 0, 0, mbX, this.leftMBType, this.topMBType[mbX], MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0);
        this.readSubMb8x8(mBlock, 1, mBlock.pb8x8.subMbTypes[1], topAvailable, true, 2, 0, mbX, MBType.P_8x8, this.topMBType[mbX], MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0);
        this.readSubMb8x8(mBlock, 2, mBlock.pb8x8.subMbTypes[2], true, leftAvailable, 0, 2, mbX, this.leftMBType, MBType.P_8x8, MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0);
        this.readSubMb8x8(mBlock, 3, mBlock.pb8x8.subMbTypes[3], true, true, 2, 2, mbX, MBType.P_8x8, MBType.P_8x8, MBType.P_8x8, H264Const.PartPred.L0, H264Const.PartPred.L0, H264Const.PartPred.L0, 0);
        var blk8x8X = mbX << 1;
        this.predModeLeft[0] = this.predModeLeft[1] = this.predModeTop[blk8x8X] = this.predModeTop[blk8x8X + 1] = H264Const.PartPred.L0;
    };
    prototype.readPrediction8x8B = function(mBlock, mbX, leftAvailable, topAvailable) {
        var p = Array(4);
        for (var i = 0; i < 4; i++) {
            mBlock.pb8x8.subMbTypes[i] = this.readSubMBTypeB();
            p[i] = H264Const.bPartPredModes[mBlock.pb8x8.subMbTypes[i]];
        }
        for (var list = 0; list < 2; list++) {
            if (this.numRef[list] <= 1) 
                continue;
            if (H264Const.usesList(p[0], list)) 
                mBlock.pb8x8.refIdx[list][0] = this.readRefIdx(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.predModeLeft[0], this.predModeTop[mbX << 1], p[0], mbX, 0, 0, 2, 2, list);
            if (H264Const.usesList(p[1], list)) 
                mBlock.pb8x8.refIdx[list][1] = this.readRefIdx(true, topAvailable, MBType.B_8x8, this.topMBType[mbX], p[0], this.predModeTop[(mbX << 1) + 1], p[1], mbX, 2, 0, 2, 2, list);
            if (H264Const.usesList(p[2], list)) 
                mBlock.pb8x8.refIdx[list][2] = this.readRefIdx(leftAvailable, true, this.leftMBType, MBType.B_8x8, this.predModeLeft[1], p[0], p[2], mbX, 0, 2, 2, 2, list);
            if (H264Const.usesList(p[3], list)) 
                mBlock.pb8x8.refIdx[list][3] = this.readRefIdx(true, true, MBType.B_8x8, MBType.B_8x8, p[2], p[1], p[3], mbX, 2, 2, 2, 2, list);
        }
        MBlockDecoderUtils.debugPrint("Pred: " + p[0] + ", " + p[1] + ", " + p[2] + ", " + p[3]);
        var blk8x8X = mbX << 1;
        for (var list = 0; list < 2; list++) {
            if (H264Const.usesList(p[0], list)) {
                this.readSubMb8x8(mBlock, 0, H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[0]], topAvailable, leftAvailable, 0, 0, mbX, this.leftMBType, this.topMBType[mbX], MBType.B_8x8, this.predModeLeft[0], this.predModeTop[blk8x8X], p[0], list);
            }
            if (H264Const.usesList(p[1], list)) {
                this.readSubMb8x8(mBlock, 1, H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[1]], topAvailable, true, 2, 0, mbX, MBType.B_8x8, this.topMBType[mbX], MBType.B_8x8, p[0], this.predModeTop[blk8x8X + 1], p[1], list);
            }
            if (H264Const.usesList(p[2], list)) {
                this.readSubMb8x8(mBlock, 2, H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[2]], true, leftAvailable, 0, 2, mbX, this.leftMBType, MBType.B_8x8, MBType.B_8x8, this.predModeLeft[1], p[0], p[2], list);
            }
            if (H264Const.usesList(p[3], list)) {
                this.readSubMb8x8(mBlock, 3, H264Const.bSubMbTypes[mBlock.pb8x8.subMbTypes[3]], true, true, 2, 2, mbX, MBType.B_8x8, MBType.B_8x8, MBType.B_8x8, p[2], p[1], p[3], list);
            }
        }
        this.predModeLeft[0] = p[1];
        this.predModeTop[blk8x8X] = p[2];
        this.predModeLeft[1] = this.predModeTop[blk8x8X + 1] = p[3];
    };
    prototype.readSubMb8x8 = function(mBlock, partNo, subMbType, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, curMBType, leftPred, topPred, partPred, list) {
        switch (subMbType) {
            case 3:
                this.readSub4x4(mBlock, partNo, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, curMBType, leftPred, topPred, partPred, list);
                break;
            case 2:
                this.readSub4x8(mBlock, partNo, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, curMBType, leftPred, topPred, partPred, list);
                break;
            case 1:
                this.readSub8x4(mBlock, partNo, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, curMBType, leftPred, topPred, partPred, list);
                break;
            case 0:
                this.readSub8x8(mBlock, partNo, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, leftPred, topPred, partPred, list);
        }
    };
    prototype.readSub8x8 = function(mBlock, partNo, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, leftPred, topPred, partPred, list) {
        mBlock.pb8x8.mvdX1[list][partNo] = this.readMVD(0, lAvb, tAvb, leftMBType, topMBType, leftPred, topPred, partPred, mbX, blk8x8X, blk8x8Y, 2, 2, list);
        mBlock.pb8x8.mvdY1[list][partNo] = this.readMVD(1, lAvb, tAvb, leftMBType, topMBType, leftPred, topPred, partPred, mbX, blk8x8X, blk8x8Y, 2, 2, list);
        MBlockDecoderUtils.debugPrint("mvd: (%d, %d)", mBlock.pb8x8.mvdX1[list][partNo], mBlock.pb8x8.mvdY1[list][partNo]);
    };
    prototype.readSub8x4 = function(mBlock, partNo, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, curMBType, leftPred, topPred, partPred, list) {
        mBlock.pb8x8.mvdX1[list][partNo] = this.readMVD(0, lAvb, tAvb, leftMBType, topMBType, leftPred, topPred, partPred, mbX, blk8x8X, blk8x8Y, 2, 1, list);
        mBlock.pb8x8.mvdY1[list][partNo] = this.readMVD(1, lAvb, tAvb, leftMBType, topMBType, leftPred, topPred, partPred, mbX, blk8x8X, blk8x8Y, 2, 1, list);
        mBlock.pb8x8.mvdX2[list][partNo] = this.readMVD(0, lAvb, true, leftMBType, curMBType, leftPred, partPred, partPred, mbX, blk8x8X, blk8x8Y + 1, 2, 1, list);
        mBlock.pb8x8.mvdY2[list][partNo] = this.readMVD(1, lAvb, true, leftMBType, curMBType, leftPred, partPred, partPred, mbX, blk8x8X, blk8x8Y + 1, 2, 1, list);
    };
    prototype.readSub4x8 = function(mBlock, partNo, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, curMBType, leftPred, topPred, partPred, list) {
        mBlock.pb8x8.mvdX1[list][partNo] = this.readMVD(0, lAvb, tAvb, leftMBType, topMBType, leftPred, topPred, partPred, mbX, blk8x8X, blk8x8Y, 1, 2, list);
        mBlock.pb8x8.mvdY1[list][partNo] = this.readMVD(1, lAvb, tAvb, leftMBType, topMBType, leftPred, topPred, partPred, mbX, blk8x8X, blk8x8Y, 1, 2, list);
        mBlock.pb8x8.mvdX2[list][partNo] = this.readMVD(0, true, tAvb, curMBType, topMBType, partPred, topPred, partPred, mbX, blk8x8X + 1, blk8x8Y, 1, 2, list);
        mBlock.pb8x8.mvdY2[list][partNo] = this.readMVD(1, true, tAvb, curMBType, topMBType, partPred, topPred, partPred, mbX, blk8x8X + 1, blk8x8Y, 1, 2, list);
    };
    prototype.readSub4x4 = function(mBlock, partNo, tAvb, lAvb, blk8x8X, blk8x8Y, mbX, leftMBType, topMBType, curMBType, leftPred, topPred, partPred, list) {
        mBlock.pb8x8.mvdX1[list][partNo] = this.readMVD(0, lAvb, tAvb, leftMBType, topMBType, leftPred, topPred, partPred, mbX, blk8x8X, blk8x8Y, 1, 1, list);
        mBlock.pb8x8.mvdY1[list][partNo] = this.readMVD(1, lAvb, tAvb, leftMBType, topMBType, leftPred, topPred, partPred, mbX, blk8x8X, blk8x8Y, 1, 1, list);
        mBlock.pb8x8.mvdX2[list][partNo] = this.readMVD(0, true, tAvb, curMBType, topMBType, partPred, topPred, partPred, mbX, blk8x8X + 1, blk8x8Y, 1, 1, list);
        mBlock.pb8x8.mvdY2[list][partNo] = this.readMVD(1, true, tAvb, curMBType, topMBType, partPred, topPred, partPred, mbX, blk8x8X + 1, blk8x8Y, 1, 1, list);
        mBlock.pb8x8.mvdX3[list][partNo] = this.readMVD(0, lAvb, true, leftMBType, curMBType, leftPred, partPred, partPred, mbX, blk8x8X, blk8x8Y + 1, 1, 1, list);
        mBlock.pb8x8.mvdY3[list][partNo] = this.readMVD(1, lAvb, true, leftMBType, curMBType, leftPred, partPred, partPred, mbX, blk8x8X, blk8x8Y + 1, 1, 1, list);
        mBlock.pb8x8.mvdX4[list][partNo] = this.readMVD(0, true, true, curMBType, curMBType, partPred, partPred, partPred, mbX, blk8x8X + 1, blk8x8Y + 1, 1, 1, list);
        mBlock.pb8x8.mvdY4[list][partNo] = this.readMVD(1, true, true, curMBType, curMBType, partPred, partPred, partPred, mbX, blk8x8X + 1, blk8x8Y + 1, 1, 1, list);
    };
    prototype.readIntraNxN = function(mBlock) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        mBlock.transform8x8Used = false;
        if (this.transform8x8) {
            mBlock.transform8x8Used = this.readTransform8x8Flag(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], this.tf8x8Left, this.tf8x8Top[mbX]);
        }
        if (!mBlock.transform8x8Used) {
            for (var i = 0; i < 16; i++) {
                var blkX = H264Const.MB_BLK_OFF_LEFT[i];
                var blkY = H264Const.MB_BLK_OFF_TOP[i];
                mBlock.lumaModes[i] = this.readPredictionI4x4Block(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], blkX, blkY, mbX);
            }
        } else {
            for (var i = 0; i < 4; i++) {
                var blkX = (i & 1) << 1;
                var blkY = i & 2;
                mBlock.lumaModes[i] = this.readPredictionI4x4Block(leftAvailable, topAvailable, this.leftMBType, this.topMBType[mbX], blkX, blkY, mbX);
                this.i4x4PredLeft[blkY + 1] = this.i4x4PredLeft[blkY];
                this.i4x4PredTop[(mbX << 2) + blkX + 1] = this.i4x4PredTop[(mbX << 2) + blkX];
            }
        }
        mBlock.chromaPredictionMode = this.readChromaPredMode(mbX, leftAvailable, topAvailable);
        mBlock._cbp = this.readCodedBlockPatternIntra(leftAvailable, topAvailable, this.leftCBPLuma | (this.leftCBPChroma << 4), this.topCBPLuma[mbX] | (this.topCBPChroma[mbX] << 4), this.leftMBType, this.topMBType[mbX]);
        if (mBlock.cbpLuma() > 0 || mBlock.cbpChroma() > 0) {
            mBlock.mbQPDelta = this.readMBQpDelta(mBlock.prevMbType);
        }
        this.readResidualLuma(mBlock, leftAvailable, topAvailable, mbX, mbY);
        if (this.chromaFormat != ColorSpace.MONO) {
            this.readChromaResidual(mBlock, leftAvailable, topAvailable, mbX);
        }
    };
    prototype.readResidualLuma = function(mBlock, leftAvailable, topAvailable, mbX, mbY) {
        if (!mBlock.transform8x8Used) {
            this.readLuma(mBlock, leftAvailable, topAvailable, mbX, mbY);
        } else if (this.sh.pps.entropyCodingModeFlag) {
            this.readLuma8x8CABAC(mBlock, mbX, mbY);
        } else {
            this.readLuma8x8CAVLC(mBlock, leftAvailable, topAvailable, mbX, mbY);
        }
    };
    prototype.readLuma = function(mBlock, leftAvailable, topAvailable, mbX, mbY) {
        for (var i = 0; i < 16; i++) {
            var blkOffLeft = H264Const.MB_BLK_OFF_LEFT[i];
            var blkOffTop = H264Const.MB_BLK_OFF_TOP[i];
            var blkX = (mbX << 2) + blkOffLeft;
            var blkY = (mbY << 2) + blkOffTop;
            if ((mBlock.cbpLuma() & (1 << (i >> 2))) == 0) {
                if (!this.sh.pps.entropyCodingModeFlag) 
                    this.setZeroCoeff(0, blkX, blkOffTop);
                continue;
            }
            mBlock.nCoeff[i] = this.readResidualAC(leftAvailable, topAvailable, mbX, mBlock.curMbType, mBlock.cbpLuma(), blkOffLeft, blkOffTop, blkX, blkY, mBlock.ac[0][i]);
        }
        this.savePrevCBP(mBlock._cbp);
    };
    prototype.readLuma8x8CABAC = function(mBlock, mbX, mbY) {
        for (var i = 0; i < 4; i++) {
            var blkOffLeft = (i & 1) << 1;
            var blkOffTop = i & 2;
            var blkX = (mbX << 2) + blkOffLeft;
            var blkY = (mbY << 2) + blkOffTop;
            if ((mBlock.cbpLuma() & (1 << i)) == 0) {
                continue;
            }
            var nCoeff = this.readLumaAC8x8(blkX, blkY, mBlock.ac[0][i]);
            var blk4x4Offset = i << 2;
            mBlock.nCoeff[blk4x4Offset] = mBlock.nCoeff[blk4x4Offset + 1] = mBlock.nCoeff[blk4x4Offset + 2] = mBlock.nCoeff[blk4x4Offset + 3] = nCoeff;
        }
        this.savePrevCBP(mBlock._cbp);
    };
    prototype.readLuma8x8CAVLC = function(mBlock, leftAvailable, topAvailable, mbX, mbY) {
        for (var i = 0; i < 4; i++) {
            var blk8x8OffLeft = (i & 1) << 1;
            var blk8x8OffTop = i & 2;
            var blkX = (mbX << 2) + blk8x8OffLeft;
            var blkY = (mbY << 2) + blk8x8OffTop;
            if ((mBlock.cbpLuma() & (1 << i)) == 0) {
                this.setZeroCoeff(0, blkX, blk8x8OffTop);
                this.setZeroCoeff(0, blkX + 1, blk8x8OffTop);
                this.setZeroCoeff(0, blkX, blk8x8OffTop + 1);
                this.setZeroCoeff(0, blkX + 1, blk8x8OffTop + 1);
                continue;
            }
            var coeffs = 0;
            for (var j = 0; j < 4; j++) {
                var ac16 = new Int32Array(16);
                var blkOffLeft = blk8x8OffLeft + (j & 1);
                var blkOffTop = blk8x8OffTop + (j >> 1);
                coeffs += this.readLumaAC(leftAvailable, topAvailable, mbX, mBlock.curMbType, blkX, j, ac16, blkOffLeft, blkOffTop);
                for (var k = 0; k < 16; k++) 
                    mBlock.ac[0][i][CoeffTransformer.zigzag8x8[(k << 2) + j]] = ac16[k];
            }
            var blk4x4Offset = i << 2;
            mBlock.nCoeff[blk4x4Offset] = mBlock.nCoeff[blk4x4Offset + 1] = mBlock.nCoeff[blk4x4Offset + 2] = mBlock.nCoeff[blk4x4Offset + 3] = coeffs;
        }
    };
    prototype.readChromaResidual = function(mBlock, leftAvailable, topAvailable, mbX) {
        if (mBlock.cbpChroma() != 0) {
            if ((mBlock.cbpChroma() & 3) > 0) {
                this.readChromaDC(mbX, leftAvailable, topAvailable, mBlock.dc1, 1, mBlock.curMbType);
                this.readChromaDC(mbX, leftAvailable, topAvailable, mBlock.dc2, 2, mBlock.curMbType);
            }
            this._readChromaAC(leftAvailable, topAvailable, mbX, mBlock.dc1, 1, mBlock.curMbType, (mBlock.cbpChroma() & 2) > 0, mBlock.ac[1]);
            this._readChromaAC(leftAvailable, topAvailable, mbX, mBlock.dc2, 2, mBlock.curMbType, (mBlock.cbpChroma() & 2) > 0, mBlock.ac[2]);
        } else if (!this.sh.pps.entropyCodingModeFlag) {
            this.setZeroCoeff(1, mbX << 1, 0);
            this.setZeroCoeff(1, (mbX << 1) + 1, 1);
            this.setZeroCoeff(2, mbX << 1, 0);
            this.setZeroCoeff(2, (mbX << 1) + 1, 1);
        }
    };
    prototype._readChromaAC = function(leftAvailable, topAvailable, mbX, dc, comp, curMbType, codedAC, residualOut) {
        for (var i = 0; i < dc.length; i++) {
            var ac = residualOut[i];
            var blkOffLeft = H264Const.MB_BLK_OFF_LEFT[i];
            var blkOffTop = H264Const.MB_BLK_OFF_TOP[i];
            var blkX = (mbX << 1) + blkOffLeft;
            if (codedAC) {
                this.readChromaAC(leftAvailable, topAvailable, mbX, comp, curMbType, ac, blkOffLeft, blkOffTop, blkX);
            } else {
                if (!this.sh.pps.entropyCodingModeFlag) 
                    this.setZeroCoeff(comp, blkX, blkOffTop);
            }
        }
    };
    prototype.readIPCM = function(mBlock) {
        this.reader.align();
        for (var i = 0; i < 256; i++) {
            mBlock.ipcm.samplesLuma[i] = this.reader.readNBit(8);
        }
        var MbWidthC = 16 >> this.chromaFormat.compWidth[1];
        var MbHeightC = 16 >> this.chromaFormat.compHeight[1];
        for (var i = 0; i < 2 * MbWidthC * MbHeightC; i++) {
            mBlock.ipcm.samplesChroma[i] = this.reader.readNBit(8);
        }
    };
    prototype.readMBlock = function(mBlock, sliceType) {
        if (sliceType == SliceType.I) {
            this.readMBlockI(mBlock);
        } else if (sliceType == SliceType.P) {
            this.readMBlockP(mBlock);
        } else {
            this.readMBlockB(mBlock);
        }
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        this.topCBPLuma[mbX] = this.leftCBPLuma = mBlock.cbpLuma();
        this.topCBPChroma[mbX] = this.leftCBPChroma = mBlock.cbpChroma();
        this.tf8x8Left = this.tf8x8Top[mbX] = mBlock.transform8x8Used;
    };
    prototype.readMBlockI = function(mBlock) {
        mBlock.mbType = this.decodeMBTypeI(mBlock.mbIdx, this.mapper.leftAvailable(mBlock.mbIdx), this.mapper.topAvailable(mBlock.mbIdx), this.leftMBType, this.topMBType[this.mapper.getMbX(mBlock.mbIdx)]);
        this.readMBlockIInt(mBlock, mBlock.mbType);
    };
    prototype.readMBlockIInt = function(mBlock, mbType) {
        if (mbType == 0) {
            mBlock.curMbType = MBType.I_NxN;
            this.readIntraNxN(mBlock);
        } else if (mbType >= 1 && mbType <= 24) {
            mBlock.curMbType = MBType.I_16x16;
            this.readIntra16x16(mbType - 1, mBlock);
        } else {
            Logger.warn("IPCM macroblock found. Not tested, may cause unpredictable behavior.");
            mBlock.curMbType = MBType.I_PCM;
            this.readIPCM(mBlock);
        }
    };
    prototype.readMBlockP = function(mBlock) {
        mBlock.mbType = this.readMBTypeP();
        switch (mBlock.mbType) {
            case 0:
                mBlock.curMbType = MBType.P_16x16;
                this.readInter16x16(H264Const.PartPred.L0, mBlock);
                break;
            case 1:
                mBlock.curMbType = MBType.P_16x8;
                this.readInter16x8(H264Const.PartPred.L0, H264Const.PartPred.L0, mBlock);
                break;
            case 2:
                mBlock.curMbType = MBType.P_8x16;
                this.readIntra8x16(H264Const.PartPred.L0, H264Const.PartPred.L0, mBlock);
                break;
            case 3:
                mBlock.curMbType = MBType.P_8x8;
                this.readMBlock8x8(mBlock);
                break;
            case 4:
                mBlock.curMbType = MBType.P_8x8ref0;
                this.readMBlock8x8(mBlock);
                break;
            default:
                this.readMBlockIInt(mBlock, mBlock.mbType - 5);
        }
    };
    prototype.readMBlockB = function(mBlock) {
        mBlock.mbType = this.readMBTypeB(mBlock.mbIdx, this.mapper.leftAvailable(mBlock.mbIdx), this.mapper.topAvailable(mBlock.mbIdx), this.leftMBType, this.topMBType[this.mapper.getMbX(mBlock.mbIdx)]);
        if (mBlock.mbType >= 23) {
            this.readMBlockIInt(mBlock, mBlock.mbType - 23);
        } else {
            mBlock.curMbType = H264Const.bMbTypes[mBlock.mbType];
            if (mBlock.mbType == 0) {
                this.readMBlockBDirect(mBlock);
            } else if (mBlock.mbType <= 3) {
                this.readInter16x16(H264Const.bPredModes[mBlock.mbType][0], mBlock);
            } else if (mBlock.mbType == 22) {
                this.readMBlock8x8(mBlock);
            } else if ((mBlock.mbType & 1) == 0) {
                this.readInter16x8(H264Const.bPredModes[mBlock.mbType][0], H264Const.bPredModes[mBlock.mbType][1], mBlock);
            } else {
                this.readIntra8x16(H264Const.bPredModes[mBlock.mbType][0], H264Const.bPredModes[mBlock.mbType][1], mBlock);
            }
        }
    };
    prototype.getSliceHeader = function() {
        return this.sh;
    };
    prototype.getNALUnit = function() {
        return this.nalUnit;
    };
}, {activePps: "PictureParameterSet", cabac: "CABAC", mDecoder: "MDecoder", cavlc: "Array", reader: "BitReader", mapper: "Mapper", sh: "SliceHeader", nalUnit: "NALUnit", prevMBType: "MBType", topMBType: "Array", leftMBType: "MBType", topCBPLuma: "Int32Array", topCBPChroma: "Int32Array", chromaFormat: "ColorSpace", numRef: "Int32Array", tf8x8Top: "Int8Array", i4x4PredTop: "Int32Array", i4x4PredLeft: "Int32Array", predModeLeft: "Array", predModeTop: "Array"}, {});
/**
 *  A decoder for P skip macroblocks
 *  
 *  @author The JCodec project
 */
var MBlockSkipDecoder = function(mapper, bDirectDecoder, sh, di, poc, sharedState) {
    MBlockDecoderBase.call(this, sh, di, poc, sharedState);
    this.mapper = mapper;
    this.bDirectDecoder = bDirectDecoder;
};
MBlockSkipDecoder = stjs.extend(MBlockSkipDecoder, MBlockDecoderBase, [], function(constructor, prototype) {
    prototype.mapper = null;
    prototype.bDirectDecoder = null;
    prototype.decodeSkip = function(mBlock, refs, mb, sliceType) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var mbAddr = this.mapper.getAddress(mBlock.mbIdx);
        if (sliceType == SliceType.P) {
            this.predictPSkip(refs, mbX, mbY, this.mapper.leftAvailable(mBlock.mbIdx), this.mapper.topAvailable(mBlock.mbIdx), this.mapper.topLeftAvailable(mBlock.mbIdx), this.mapper.topRightAvailable(mBlock.mbIdx), mBlock.x, mb);
            Arrays.fill(mBlock.partPreds, H264Const.PartPred.L0);
        } else {
            this.bDirectDecoder.predictBDirect(refs, mbX, mbY, this.mapper.leftAvailable(mBlock.mbIdx), this.mapper.topAvailable(mBlock.mbIdx), this.mapper.topLeftAvailable(mBlock.mbIdx), this.mapper.topRightAvailable(mBlock.mbIdx), mBlock.x, mBlock.partPreds, mb, H264Const.identityMapping4);
            MBlockDecoderUtils.savePrediction8x8(this.s, mbX, mBlock.x);
        }
        this.decodeChromaSkip(refs, mBlock.x, mBlock.partPreds, mbX, mbY, mb);
        MBlockDecoderUtils.collectPredictors(this.s, mb, mbX);
        MBlockDecoderUtils.saveMvs(this.di, mBlock.x, mbX, mbY);
        this.di.mbTypes[mbAddr] = mBlock.curMbType;
        this.di.mbQps[0][mbAddr] = this.s.qp;
        this.di.mbQps[1][mbAddr] = MBlockDecoderBase.calcQpChroma(this.s.qp, this.s.chromaQpOffset[0]);
        this.di.mbQps[2][mbAddr] = MBlockDecoderBase.calcQpChroma(this.s.qp, this.s.chromaQpOffset[1]);
    };
    prototype.predictPSkip = function(refs, mbX, mbY, lAvb, tAvb, tlAvb, trAvb, x, mb) {
        var mvX = 0, mvY = 0;
        if (lAvb && tAvb) {
            var b = this.s.mvTop.getMv(mbX << 2, 0);
            var a = this.s.mvLeft.getMv(0, 0);
            if ((a != 0) && (b != 0)) {
                mvX = MBlockDecoderUtils.calcMVPredictionMedian(a, b, this.s.mvTop.getMv((mbX << 2) + 4, 0), this.s.mvTopLeft.getMv(0, 0), lAvb, tAvb, trAvb, tlAvb, 0, 0);
                mvY = MBlockDecoderUtils.calcMVPredictionMedian(a, b, this.s.mvTop.getMv((mbX << 2) + 4, 0), this.s.mvTopLeft.getMv(0, 0), lAvb, tAvb, trAvb, tlAvb, 0, 1);
            }
        }
        var xx = mbX << 2;
        this.s.mvTopLeft.copyPair(0, this.s.mvTop, xx + 3);
        MBlockDecoderUtils.saveVect(this.s.mvTop, 0, xx, xx + 4, H264Utils.Mv.packMv(mvX, mvY, 0));
        MBlockDecoderUtils.saveVect(this.s.mvLeft, 0, 0, 4, H264Utils.Mv.packMv(mvX, mvY, 0));
        MBlockDecoderUtils.saveVect(this.s.mvTop, 1, xx, xx + 4, MBlockDecoderUtils.NULL_VECTOR);
        MBlockDecoderUtils.saveVect(this.s.mvLeft, 1, 0, 4, MBlockDecoderUtils.NULL_VECTOR);
        for (var i = 0; i < 16; i++) {
            x.setMv(i, 0, H264Utils.Mv.packMv(mvX, mvY, 0));
        }
        this.interpolator.getBlockLuma(refs[0][0], mb, 0, (mbX << 6) + mvX, (mbY << 6) + mvY, 16, 16);
        PredictionMerger.mergePrediction(this.sh, 0, 0, H264Const.PartPred.L0, 0, mb.getPlaneData(0), null, 0, 16, 16, 16, mb.getPlaneData(0), refs, this.poc);
    };
    prototype.decodeChromaSkip = function(reference, vectors, pp, mbX, mbY, mb) {
        this.predictChromaInter(reference, vectors, mbX << 3, mbY << 3, 1, mb, pp);
        this.predictChromaInter(reference, vectors, mbX << 3, mbY << 3, 2, mb, pp);
    };
}, {mapper: "Mapper", bDirectDecoder: "MBlockDecoderBDirect", s: "DecoderState", sh: "SliceHeader", di: "DeblockerInput", interpolator: "BlockInterpolator", mbb: "Array", scalingMatrix: "Array"}, {});
/**
 *  A decoder for Inter 16x16, 16x8 and 8x16 macroblocks
 *  
 *  @author The JCodec project
 */
var MBlockDecoderInter = function(mapper, sh, di, poc, decoderState) {
    MBlockDecoderBase.call(this, sh, di, poc, decoderState);
    this.mapper = mapper;
};
MBlockDecoderInter = stjs.extend(MBlockDecoderInter, MBlockDecoderBase, [], function(constructor, prototype) {
    prototype.mapper = null;
    prototype.decode16x16 = function(mBlock, mb, refs, p0) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        var topLeftAvailable = this.mapper.topLeftAvailable(mBlock.mbIdx);
        var topRightAvailable = this.mapper.topRightAvailable(mBlock.mbIdx);
        var address = this.mapper.getAddress(mBlock.mbIdx);
        var xx = mbX << 2;
        for (var list = 0; list < 2; list++) {
            this.predictInter16x16(mBlock, this.mbb[list], refs, mbX, mbY, leftAvailable, topAvailable, topLeftAvailable, topRightAvailable, mBlock.x, xx, list, p0);
        }
        PredictionMerger.mergePrediction(this.sh, mBlock.x.mv0R(0), mBlock.x.mv1R(0), p0, 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), 0, 16, 16, 16, mb.getPlaneData(0), refs, this.poc);
        mBlock.partPreds[0] = mBlock.partPreds[1] = mBlock.partPreds[2] = mBlock.partPreds[3] = p0;
        this.predictChromaInter(refs, mBlock.x, mbX << 3, mbY << 3, 1, mb, mBlock.partPreds);
        this.predictChromaInter(refs, mBlock.x, mbX << 3, mbY << 3, 2, mb, mBlock.partPreds);
        this.residualInter(mBlock, refs, leftAvailable, topAvailable, mbX, mbY, this.mapper.getAddress(mBlock.mbIdx));
        MBlockDecoderUtils.saveMvs(this.di, mBlock.x, mbX, mbY);
        MBlockDecoderUtils.mergeResidual(mb, mBlock.ac, mBlock.transform8x8Used ? H264Const.COMP_BLOCK_8x8_LUT : H264Const.COMP_BLOCK_4x4_LUT, mBlock.transform8x8Used ? H264Const.COMP_POS_8x8_LUT : H264Const.COMP_POS_4x4_LUT);
        MBlockDecoderUtils.collectPredictors(this.s, mb, mbX);
        this.di.mbTypes[address] = mBlock.curMbType;
    };
    prototype.predictInter8x16 = function(mBlock, mb, references, mbX, mbY, leftAvailable, topAvailable, tlAvailable, trAvailable, x, list, p0, p1) {
        var xx = mbX << 2;
        var mvX1 = 0, mvY1 = 0, r1 = -1, mvX2 = 0, mvY2 = 0, r2 = -1;
        if (H264Const.usesList(p0, list)) {
            var mvpX1 = this.calcMVPrediction8x16Left(this.s.mvLeft.getMv(0, list), this.s.mvTop.getMv(mbX << 2, list), this.s.mvTop.getMv((mbX << 2) + 2, list), this.s.mvTopLeft.getMv(0, list), leftAvailable, topAvailable, topAvailable, tlAvailable, mBlock.pb168x168.refIdx1[list], 0);
            var mvpY1 = this.calcMVPrediction8x16Left(this.s.mvLeft.getMv(0, list), this.s.mvTop.getMv(mbX << 2, list), this.s.mvTop.getMv((mbX << 2) + 2, list), this.s.mvTopLeft.getMv(0, list), leftAvailable, topAvailable, topAvailable, tlAvailable, mBlock.pb168x168.refIdx1[list], 1);
            mvX1 = mBlock.pb168x168.mvdX1[list] + mvpX1;
            mvY1 = mBlock.pb168x168.mvdY1[list] + mvpY1;
            MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX1, mvpY1, mBlock.pb168x168.mvdX1[list], mBlock.pb168x168.mvdY1[list], mvX1, mvY1, mBlock.pb168x168.refIdx1[list]);
            this.interpolator.getBlockLuma(references[list][mBlock.pb168x168.refIdx1[list]], mb, 0, (mbX << 6) + mvX1, (mbY << 6) + mvY1, 8, 16);
            r1 = mBlock.pb168x168.refIdx1[list];
        }
        var v1 = H264Utils.Mv.packMv(mvX1, mvY1, r1);
        if (H264Const.usesList(p1, list)) {
            var mvpX2 = this.calcMVPrediction8x16Right(v1, this.s.mvTop.getMv((mbX << 2) + 2, list), this.s.mvTop.getMv((mbX << 2) + 4, list), this.s.mvTop.getMv((mbX << 2) + 1, list), true, topAvailable, trAvailable, topAvailable, mBlock.pb168x168.refIdx2[list], 0);
            var mvpY2 = this.calcMVPrediction8x16Right(v1, this.s.mvTop.getMv((mbX << 2) + 2, list), this.s.mvTop.getMv((mbX << 2) + 4, list), this.s.mvTop.getMv((mbX << 2) + 1, list), true, topAvailable, trAvailable, topAvailable, mBlock.pb168x168.refIdx2[list], 1);
            mvX2 = mBlock.pb168x168.mvdX2[list] + mvpX2;
            mvY2 = mBlock.pb168x168.mvdY2[list] + mvpY2;
            MBlockDecoderUtils.debugPrint("MVP: (" + mvpX2 + ", " + mvpY2 + "), MVD: (" + mBlock.pb168x168.mvdX2[list] + ", " + mBlock.pb168x168.mvdY2[list] + "), MV: (" + mvX2 + "," + mvY2 + "," + mBlock.pb168x168.refIdx2[list] + ")");
            this.interpolator.getBlockLuma(references[list][mBlock.pb168x168.refIdx2[list]], mb, 8, (mbX << 6) + 32 + mvX2, (mbY << 6) + mvY2, 8, 16);
            r2 = mBlock.pb168x168.refIdx2[list];
        }
        var v2 = H264Utils.Mv.packMv(mvX2, mvY2, r2);
        this.s.mvTopLeft.setMv(0, list, this.s.mvTop.getMv(xx + 3, list));
        MBlockDecoderUtils.saveVect(this.s.mvTop, list, xx, xx + 2, v1);
        MBlockDecoderUtils.saveVect(this.s.mvTop, list, xx + 2, xx + 4, v2);
        MBlockDecoderUtils.saveVect(this.s.mvLeft, list, 0, 4, v2);
        for (var i = 0; i < 16; i += 4) {
            x.setMv(i, list, v1);
            x.setMv(i + 1, list, v1);
            x.setMv(i + 2, list, v2);
            x.setMv(i + 3, list, v2);
        }
    };
    prototype.predictInter16x8 = function(mBlock, mb, references, mbX, mbY, leftAvailable, topAvailable, tlAvailable, trAvailable, xx, x, p0, p1, list) {
        var mvX1 = 0, mvY1 = 0, mvX2 = 0, mvY2 = 0, r1 = -1, r2 = -1;
        if (H264Const.usesList(p0, list)) {
            var mvpX1 = this.calcMVPrediction16x8Top(this.s.mvLeft.getMv(0, list), this.s.mvTop.getMv(mbX << 2, list), this.s.mvTop.getMv((mbX << 2) + 4, list), this.s.mvTopLeft.getMv(0, list), leftAvailable, topAvailable, trAvailable, tlAvailable, mBlock.pb168x168.refIdx1[list], 0);
            var mvpY1 = this.calcMVPrediction16x8Top(this.s.mvLeft.getMv(0, list), this.s.mvTop.getMv(mbX << 2, list), this.s.mvTop.getMv((mbX << 2) + 4, list), this.s.mvTopLeft.getMv(0, list), leftAvailable, topAvailable, trAvailable, tlAvailable, mBlock.pb168x168.refIdx1[list], 1);
            mvX1 = mBlock.pb168x168.mvdX1[list] + mvpX1;
            mvY1 = mBlock.pb168x168.mvdY1[list] + mvpY1;
            MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX1, mvpY1, mBlock.pb168x168.mvdX1[list], mBlock.pb168x168.mvdY1[list], mvX1, mvY1, mBlock.pb168x168.refIdx1[list]);
            this.interpolator.getBlockLuma(references[list][mBlock.pb168x168.refIdx1[list]], mb, 0, (mbX << 6) + mvX1, (mbY << 6) + mvY1, 16, 8);
            r1 = mBlock.pb168x168.refIdx1[list];
        }
        var v1 = H264Utils.Mv.packMv(mvX1, mvY1, r1);
        if (H264Const.usesList(p1, list)) {
            var mvpX2 = this.calcMVPrediction16x8Bottom(this.s.mvLeft.getMv(2, list), v1, MBlockDecoderUtils.NULL_VECTOR, this.s.mvLeft.getMv(1, list), leftAvailable, true, false, leftAvailable, mBlock.pb168x168.refIdx2[list], 0);
            var mvpY2 = this.calcMVPrediction16x8Bottom(this.s.mvLeft.getMv(2, list), v1, MBlockDecoderUtils.NULL_VECTOR, this.s.mvLeft.getMv(1, list), leftAvailable, true, false, leftAvailable, mBlock.pb168x168.refIdx2[list], 1);
            mvX2 = mBlock.pb168x168.mvdX2[list] + mvpX2;
            mvY2 = mBlock.pb168x168.mvdY2[list] + mvpY2;
            MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX2, mvpY2, mBlock.pb168x168.mvdX2[list], mBlock.pb168x168.mvdY2[list], mvX2, mvY2, mBlock.pb168x168.refIdx2[list]);
            this.interpolator.getBlockLuma(references[list][mBlock.pb168x168.refIdx2[list]], mb, 128, (mbX << 6) + mvX2, (mbY << 6) + 32 + mvY2, 16, 8);
            r2 = mBlock.pb168x168.refIdx2[list];
        }
        var v2 = H264Utils.Mv.packMv(mvX2, mvY2, r2);
        this.s.mvTopLeft.setMv(0, list, this.s.mvTop.getMv(xx + 3, list));
        MBlockDecoderUtils.saveVect(this.s.mvLeft, list, 0, 2, v1);
        MBlockDecoderUtils.saveVect(this.s.mvLeft, list, 2, 4, v2);
        MBlockDecoderUtils.saveVect(this.s.mvTop, list, xx, xx + 4, v2);
        for (var i = 0; i < 8; i++) {
            x.setMv(i, list, v1);
        }
        for (var i = 8; i < 16; i++) {
            x.setMv(i, list, v2);
        }
    };
    prototype.decode16x8 = function(mBlock, mb, refs, p0, p1) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        var topLeftAvailable = this.mapper.topLeftAvailable(mBlock.mbIdx);
        var topRightAvailable = this.mapper.topRightAvailable(mBlock.mbIdx);
        var address = this.mapper.getAddress(mBlock.mbIdx);
        var xx = mbX << 2;
        for (var list = 0; list < 2; list++) {
            this.predictInter16x8(mBlock, this.mbb[list], refs, mbX, mbY, leftAvailable, topAvailable, topLeftAvailable, topRightAvailable, xx, mBlock.x, p0, p1, list);
        }
        PredictionMerger.mergePrediction(this.sh, mBlock.x.mv0R(0), mBlock.x.mv1R(0), p0, 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), 0, 16, 16, 8, mb.getPlaneData(0), refs, this.poc);
        PredictionMerger.mergePrediction(this.sh, mBlock.x.mv0R(8), mBlock.x.mv1R(8), p1, 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), 128, 16, 16, 8, mb.getPlaneData(0), refs, this.poc);
        mBlock.partPreds[0] = mBlock.partPreds[1] = p0;
        mBlock.partPreds[2] = mBlock.partPreds[3] = p1;
        this.predictChromaInter(refs, mBlock.x, mbX << 3, mbY << 3, 1, mb, mBlock.partPreds);
        this.predictChromaInter(refs, mBlock.x, mbX << 3, mbY << 3, 2, mb, mBlock.partPreds);
        this.residualInter(mBlock, refs, leftAvailable, topAvailable, mbX, mbY, this.mapper.getAddress(mBlock.mbIdx));
        MBlockDecoderUtils.saveMvs(this.di, mBlock.x, mbX, mbY);
        MBlockDecoderUtils.mergeResidual(mb, mBlock.ac, mBlock.transform8x8Used ? H264Const.COMP_BLOCK_8x8_LUT : H264Const.COMP_BLOCK_4x4_LUT, mBlock.transform8x8Used ? H264Const.COMP_POS_8x8_LUT : H264Const.COMP_POS_4x4_LUT);
        MBlockDecoderUtils.collectPredictors(this.s, mb, mbX);
        this.di.mbTypes[address] = mBlock.curMbType;
    };
    prototype.decode8x16 = function(mBlock, mb, refs, p0, p1) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var leftAvailable = this.mapper.leftAvailable(mBlock.mbIdx);
        var topAvailable = this.mapper.topAvailable(mBlock.mbIdx);
        var topLeftAvailable = this.mapper.topLeftAvailable(mBlock.mbIdx);
        var topRightAvailable = this.mapper.topRightAvailable(mBlock.mbIdx);
        var address = this.mapper.getAddress(mBlock.mbIdx);
        for (var list = 0; list < 2; list++) {
            this.predictInter8x16(mBlock, this.mbb[list], refs, mbX, mbY, leftAvailable, topAvailable, topLeftAvailable, topRightAvailable, mBlock.x, list, p0, p1);
        }
        PredictionMerger.mergePrediction(this.sh, mBlock.x.mv0R(0), mBlock.x.mv1R(0), p0, 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), 0, 16, 8, 16, mb.getPlaneData(0), refs, this.poc);
        PredictionMerger.mergePrediction(this.sh, mBlock.x.mv0R(2), mBlock.x.mv1R(2), p1, 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), 8, 16, 8, 16, mb.getPlaneData(0), refs, this.poc);
        mBlock.partPreds[0] = mBlock.partPreds[2] = p0;
        mBlock.partPreds[1] = mBlock.partPreds[3] = p1;
        this.predictChromaInter(refs, mBlock.x, mbX << 3, mbY << 3, 1, mb, mBlock.partPreds);
        this.predictChromaInter(refs, mBlock.x, mbX << 3, mbY << 3, 2, mb, mBlock.partPreds);
        this.residualInter(mBlock, refs, leftAvailable, topAvailable, mbX, mbY, this.mapper.getAddress(mBlock.mbIdx));
        MBlockDecoderUtils.saveMvs(this.di, mBlock.x, mbX, mbY);
        MBlockDecoderUtils.mergeResidual(mb, mBlock.ac, mBlock.transform8x8Used ? H264Const.COMP_BLOCK_8x8_LUT : H264Const.COMP_BLOCK_4x4_LUT, mBlock.transform8x8Used ? H264Const.COMP_POS_8x8_LUT : H264Const.COMP_POS_4x4_LUT);
        MBlockDecoderUtils.collectPredictors(this.s, mb, mbX);
        this.di.mbTypes[address] = mBlock.curMbType;
    };
    prototype.predictInter16x16 = function(mBlock, mb, references, mbX, mbY, leftAvailable, topAvailable, tlAvailable, trAvailable, x, xx, list, curPred) {
        var mvX = 0, mvY = 0, r = -1;
        if (H264Const.usesList(curPred, list)) {
            var mvpX = MBlockDecoderUtils.calcMVPredictionMedian(this.s.mvLeft.getMv(0, list), this.s.mvTop.getMv(mbX << 2, list), this.s.mvTop.getMv((mbX << 2) + 4, list), this.s.mvTopLeft.getMv(0, list), leftAvailable, topAvailable, trAvailable, tlAvailable, mBlock.pb16x16.refIdx[list], 0);
            var mvpY = MBlockDecoderUtils.calcMVPredictionMedian(this.s.mvLeft.getMv(0, list), this.s.mvTop.getMv(mbX << 2, list), this.s.mvTop.getMv((mbX << 2) + 4, list), this.s.mvTopLeft.getMv(0, list), leftAvailable, topAvailable, trAvailable, tlAvailable, mBlock.pb16x16.refIdx[list], 1);
            mvX = mBlock.pb16x16.mvdX[list] + mvpX;
            mvY = mBlock.pb16x16.mvdY[list] + mvpY;
            MBlockDecoderUtils.debugPrint("MVP: (%d, %d), MVD: (%d, %d), MV: (%d,%d,%d)", mvpX, mvpY, mBlock.pb16x16.mvdX[list], mBlock.pb16x16.mvdY[list], mvX, mvY, mBlock.pb16x16.refIdx[list]);
            r = mBlock.pb16x16.refIdx[list];
            this.interpolator.getBlockLuma(references[list][r], mb, 0, (mbX << 6) + mvX, (mbY << 6) + mvY, 16, 16);
        }
        var v = H264Utils.Mv.packMv(mvX, mvY, r);
        this.s.mvTopLeft.setMv(0, list, this.s.mvTop.getMv(xx + 3, list));
        MBlockDecoderUtils.saveVect(this.s.mvTop, list, xx, xx + 4, v);
        MBlockDecoderUtils.saveVect(this.s.mvLeft, list, 0, 4, v);
        for (var i = 0; i < 16; i++) {
            x.setMv(i, list, v);
        }
    };
    prototype.residualInter = function(mBlock, refs, leftAvailable, topAvailable, mbX, mbY, mbAddr) {
        if (mBlock.cbpLuma() > 0 || mBlock.cbpChroma() > 0) {
            this.s.qp = (this.s.qp + mBlock.mbQPDelta + 52) % 52;
        }
        this.di.mbQps[0][mbAddr] = this.s.qp;
        this.residualLuma(mBlock, leftAvailable, topAvailable, mbX, mbY);
        if (this.s.chromaFormat != ColorSpace.MONO) {
            var qp1 = MBlockDecoderBase.calcQpChroma(this.s.qp, this.s.chromaQpOffset[0]);
            var qp2 = MBlockDecoderBase.calcQpChroma(this.s.qp, this.s.chromaQpOffset[1]);
            this.decodeChromaResidual(mBlock, leftAvailable, topAvailable, mbX, mbY, qp1, qp2);
            this.di.mbQps[1][mbAddr] = qp1;
            this.di.mbQps[2][mbAddr] = qp2;
        }
        this.di.tr8x8Used[mbAddr] = mBlock.transform8x8Used;
    };
    prototype.calcMVPrediction16x8Top = function(a, b, c, d, aAvb, bAvb, cAvb, dAvb, refIdx, comp) {
        if (bAvb && H264Utils.Mv.mvRef(b) == refIdx) 
            return H264Utils.Mv.mvC(b, comp);
         else 
            return MBlockDecoderUtils.calcMVPredictionMedian(a, b, c, d, aAvb, bAvb, cAvb, dAvb, refIdx, comp);
    };
    prototype.calcMVPrediction16x8Bottom = function(a, b, c, d, aAvb, bAvb, cAvb, dAvb, refIdx, comp) {
        if (aAvb && H264Utils.Mv.mvRef(a) == refIdx) 
            return H264Utils.Mv.mvC(a, comp);
         else 
            return MBlockDecoderUtils.calcMVPredictionMedian(a, b, c, d, aAvb, bAvb, cAvb, dAvb, refIdx, comp);
    };
    prototype.calcMVPrediction8x16Left = function(a, b, c, d, aAvb, bAvb, cAvb, dAvb, refIdx, comp) {
        if (aAvb && H264Utils.Mv.mvRef(a) == refIdx) 
            return H264Utils.Mv.mvC(a, comp);
         else 
            return MBlockDecoderUtils.calcMVPredictionMedian(a, b, c, d, aAvb, bAvb, cAvb, dAvb, refIdx, comp);
    };
    prototype.calcMVPrediction8x16Right = function(a, b, c, d, aAvb, bAvb, cAvb, dAvb, refIdx, comp) {
        var lc = cAvb ? c : (dAvb ? d : MBlockDecoderUtils.NULL_VECTOR);
        if (H264Utils.Mv.mvRef(lc) == refIdx) 
            return H264Utils.Mv.mvC(lc, comp);
         else 
            return MBlockDecoderUtils.calcMVPredictionMedian(a, b, c, d, aAvb, bAvb, cAvb, dAvb, refIdx, comp);
    };
}, {mapper: "Mapper", s: "DecoderState", sh: "SliceHeader", di: "DeblockerInput", interpolator: "BlockInterpolator", mbb: "Array", scalingMatrix: "Array"}, {});
/**
 *  A decoder for B direct macroblocks
 *  
 *  @author The JCodec project
 */
var MBlockDecoderBDirect = function(mapper, sh, di, poc, decoderState) {
    MBlockDecoderBase.call(this, sh, di, poc, decoderState);
    this.mapper = mapper;
};
MBlockDecoderBDirect = stjs.extend(MBlockDecoderBDirect, MBlockDecoderBase, [], function(constructor, prototype) {
    prototype.mapper = null;
    prototype.decode = function(mBlock, mb, references) {
        var mbX = this.mapper.getMbX(mBlock.mbIdx);
        var mbY = this.mapper.getMbY(mBlock.mbIdx);
        var lAvb = this.mapper.leftAvailable(mBlock.mbIdx);
        var tAvb = this.mapper.topAvailable(mBlock.mbIdx);
        var mbAddr = this.mapper.getAddress(mBlock.mbIdx);
        var tlAvb = this.mapper.topLeftAvailable(mBlock.mbIdx);
        var trAvb = this.mapper.topRightAvailable(mBlock.mbIdx);
        this.predictBDirect(references, mbX, mbY, lAvb, tAvb, tlAvb, trAvb, mBlock.x, mBlock.partPreds, mb, H264Const.identityMapping4);
        this.predictChromaInter(references, mBlock.x, mbX << 3, mbY << 3, 1, mb, mBlock.partPreds);
        this.predictChromaInter(references, mBlock.x, mbX << 3, mbY << 3, 2, mb, mBlock.partPreds);
        if (mBlock.cbpLuma() > 0 || mBlock.cbpChroma() > 0) {
            this.s.qp = (this.s.qp + mBlock.mbQPDelta + 52) % 52;
        }
        this.di.mbQps[0][mbAddr] = this.s.qp;
        this.residualLuma(mBlock, lAvb, tAvb, mbX, mbY);
        MBlockDecoderUtils.savePrediction8x8(this.s, mbX, mBlock.x);
        MBlockDecoderUtils.saveMvs(this.di, mBlock.x, mbX, mbY);
        var qp1 = MBlockDecoderBase.calcQpChroma(this.s.qp, this.s.chromaQpOffset[0]);
        var qp2 = MBlockDecoderBase.calcQpChroma(this.s.qp, this.s.chromaQpOffset[1]);
        this.decodeChromaResidual(mBlock, lAvb, tAvb, mbX, mbY, qp1, qp2);
        this.di.mbQps[1][mbAddr] = qp1;
        this.di.mbQps[2][mbAddr] = qp2;
        MBlockDecoderUtils.mergeResidual(mb, mBlock.ac, mBlock.transform8x8Used ? H264Const.COMP_BLOCK_8x8_LUT : H264Const.COMP_BLOCK_4x4_LUT, mBlock.transform8x8Used ? H264Const.COMP_POS_8x8_LUT : H264Const.COMP_POS_4x4_LUT);
        MBlockDecoderUtils.collectPredictors(this.s, mb, mbX);
        this.di.mbTypes[mbAddr] = mBlock.curMbType;
        this.di.tr8x8Used[mbAddr] = mBlock.transform8x8Used;
    };
    prototype.predictBDirect = function(refs, mbX, mbY, lAvb, tAvb, tlAvb, trAvb, x, pp, mb, blocks) {
        if (this.sh.directSpatialMvPredFlag) 
            this.predictBSpatialDirect(refs, mbX, mbY, lAvb, tAvb, tlAvb, trAvb, x, pp, mb, blocks);
         else 
            this.predictBTemporalDirect(refs, mbX, mbY, lAvb, tAvb, tlAvb, trAvb, x, pp, mb, blocks);
    };
    prototype.predictBTemporalDirect = function(refs, mbX, mbY, lAvb, tAvb, tlAvb, trAvb, x, pp, mb, blocks8x8) {
        for (var i = 0; i < blocks8x8.length; i++) {
            var blk8x8 = blocks8x8[i];
            var blk4x4_0 = H264Const.BLK8x8_BLOCKS[blk8x8][0];
            pp[blk8x8] = H264Const.PartPred.Bi;
            if (!this.sh.sps.direct8x8InferenceFlag) {
                var js = H264Const.BLK8x8_BLOCKS[blk8x8];
                for (var j = 0; j < js.length; j++) {
                    var blk4x4 = js[j];
                    this.predTemp4x4(refs, mbX, mbY, x, blk4x4);
                    var blkIndX = blk4x4 & 3;
                    var blkIndY = blk4x4 >> 2;
                    MBlockDecoderUtils.debugPrint("DIRECT_4x4 [%d, %d]: (%d,%d,%d), (%d,%d,%d)", blkIndY, blkIndX, x.mv0X(blk4x4), x.mv0Y(blk4x4), x.mv0R(blk4x4), x.mv1X(blk4x4), x.mv1Y(blk4x4), x.mv1R(blk4x4));
                    var blkPredX = (mbX << 6) + (blkIndX << 4);
                    var blkPredY = (mbY << 6) + (blkIndY << 4);
                    this.interpolator.getBlockLuma(refs[0][x.mv0R(blk4x4)], this.mbb[0], H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4], blkPredX + x.mv0X(blk4x4), blkPredY + x.mv0Y(blk4x4), 4, 4);
                    this.interpolator.getBlockLuma(refs[1][0], this.mbb[1], H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4], blkPredX + x.mv1X(blk4x4), blkPredY + x.mv1Y(blk4x4), 4, 4);
                }
            } else {
                var blk4x4Pred = H264Const.BLK_INV_MAP[blk8x8 * 5];
                this.predTemp4x4(refs, mbX, mbY, x, blk4x4Pred);
                this.propagatePred(x, blk8x8, blk4x4Pred);
                var blkIndX = blk4x4_0 & 3;
                var blkIndY = blk4x4_0 >> 2;
                MBlockDecoderUtils.debugPrint("DIRECT_8x8 [%d, %d]: (%d,%d,%d), (%d,%d)", blkIndY, blkIndX, x.mv0X(blk4x4_0), x.mv0Y(blk4x4_0), x.mv0R(blk4x4_0), x.mv1X(blk4x4_0), x.mv1Y(blk4x4_0), x.mv1R(blk4x4_0));
                var blkPredX = (mbX << 6) + (blkIndX << 4);
                var blkPredY = (mbY << 6) + (blkIndY << 4);
                this.interpolator.getBlockLuma(refs[0][x.mv0R(blk4x4_0)], this.mbb[0], H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4_0], blkPredX + x.mv0X(blk4x4_0), blkPredY + x.mv0Y(blk4x4_0), 8, 8);
                this.interpolator.getBlockLuma(refs[1][0], this.mbb[1], H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4_0], blkPredX + x.mv1X(blk4x4_0), blkPredY + x.mv1Y(blk4x4_0), 8, 8);
            }
            PredictionMerger.mergePrediction(this.sh, x.mv0R(blk4x4_0), x.mv1R(blk4x4_0), H264Const.PartPred.Bi, 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4_0], 16, 8, 8, mb.getPlaneData(0), refs, this.poc);
        }
    };
    prototype.predTemp4x4 = function(refs, mbX, mbY, x, blk4x4) {
        var mbWidth = this.sh.sps.picWidthInMbsMinus1 + 1;
        var picCol = refs[1][0];
        var blkIndX = blk4x4 & 3;
        var blkIndY = blk4x4 >> 2;
        var blkPosX = (mbX << 2) + blkIndX;
        var blkPosY = (mbY << 2) + blkIndY;
        var mvCol = picCol.getMvs().getMv(blkPosX, blkPosY, 0);
        var refL0;
        var refIdxL0;
        if (H264Utils.Mv.mvRef(mvCol) == -1) {
            mvCol = picCol.getMvs().getMv(blkPosX, blkPosY, 1);
            if (H264Utils.Mv.mvRef(mvCol) == -1) {
                refIdxL0 = 0;
                refL0 = refs[0][0];
            } else {
                refL0 = picCol.getRefsUsed()[mbY * mbWidth + mbX][1][H264Utils.Mv.mvRef(mvCol)];
                refIdxL0 = this.findPic(refs[0], refL0);
            }
        } else {
            refL0 = picCol.getRefsUsed()[mbY * mbWidth + mbX][0][H264Utils.Mv.mvRef(mvCol)];
            refIdxL0 = this.findPic(refs[0], refL0);
        }
        var td = MathUtil.clip(picCol.getPOC() - refL0.getPOC(), -128, 127);
        if (!refL0.isShortTerm() || td == 0) {
            x.setPair(blk4x4, H264Utils.Mv.packMv(H264Utils.Mv.mvX(mvCol), H264Utils.Mv.mvY(mvCol), refIdxL0), 0);
        } else {
            var tb = MathUtil.clip(this.poc - refL0.getPOC(), -128, 127);
            var tx = stjs.trunc((16384 + Math.abs(stjs.trunc(td / 2))) / td);
            var dsf = MathUtil.clip((tb * tx + 32) >> 6, -1024, 1023);
            x.setPair(blk4x4, H264Utils.Mv.packMv((dsf * H264Utils.Mv.mvX(mvCol) + 128) >> 8, (dsf * H264Utils.Mv.mvY(mvCol) + 128) >> 8, refIdxL0), H264Utils.Mv.packMv((x.mv0X(blk4x4) - H264Utils.Mv.mvX(mvCol)), (x.mv0Y(blk4x4) - H264Utils.Mv.mvY(mvCol)), 0));
        }
    };
    prototype.findPic = function(frames, refL0) {
        for (var i = 0; i < frames.length; i++) 
            if (frames[i] == refL0) 
                return i;
        Logger.error("RefPicList0 shall contain refPicCol");
        return 0;
    };
    prototype.predictBSpatialDirect = function(refs, mbX, mbY, lAvb, tAvb, tlAvb, trAvb, x, pp, mb, blocks8x8) {
        var a0 = this.s.mvLeft.getMv(0, 0), a1 = this.s.mvLeft.getMv(0, 1);
        var b0 = this.s.mvTop.getMv(mbX << 2, 0), b1 = this.s.mvTop.getMv(mbX << 2, 1);
        var c0 = this.s.mvTop.getMv((mbX << 2) + 4, 0), c1 = this.s.mvTop.getMv((mbX << 2) + 4, 1);
        var d0 = this.s.mvTopLeft.getMv(0, 0);
        var d1 = this.s.mvTopLeft.getMv(0, 1);
        var refIdxL0 = this.calcRef(a0, b0, c0, d0, lAvb, tAvb, tlAvb, trAvb, mbX);
        var refIdxL1 = this.calcRef(a1, b1, c1, d1, lAvb, tAvb, tlAvb, trAvb, mbX);
        if (refIdxL0 < 0 && refIdxL1 < 0) {
            for (var i = 0; i < blocks8x8.length; i++) {
                var blk8x8 = blocks8x8[i];
                var js = H264Const.BLK8x8_BLOCKS[blk8x8];
                for (var j = 0; j < js.length; j++) {
                    var blk4x4 = js[j];
                    x.setPair(blk4x4, 0, 0);
                }
                pp[blk8x8] = H264Const.PartPred.Bi;
                var blkOffX = (blk8x8 & 1) << 5;
                var blkOffY = (blk8x8 >> 1) << 5;
                this.interpolator.getBlockLuma(refs[0][0], this.mbb[0], H264Const.BLK_8x8_MB_OFF_LUMA[blk8x8], (mbX << 6) + blkOffX, (mbY << 6) + blkOffY, 8, 8);
                this.interpolator.getBlockLuma(refs[1][0], this.mbb[1], H264Const.BLK_8x8_MB_OFF_LUMA[blk8x8], (mbX << 6) + blkOffX, (mbY << 6) + blkOffY, 8, 8);
                PredictionMerger.mergePrediction(this.sh, 0, 0, H264Const.PartPred.Bi, 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), H264Const.BLK_8x8_MB_OFF_LUMA[blk8x8], 16, 8, 8, mb.getPlaneData(0), refs, this.poc);
                MBlockDecoderUtils.debugPrint("DIRECT_8x8 [%d, %d]: (0,0,0), (0,0,0)", (blk8x8 & 2), ((blk8x8 << 1) & 2));
            }
            return;
        }
        var mvX0 = MBlockDecoderUtils.calcMVPredictionMedian(a0, b0, c0, d0, lAvb, tAvb, trAvb, tlAvb, refIdxL0, 0);
        var mvY0 = MBlockDecoderUtils.calcMVPredictionMedian(a0, b0, c0, d0, lAvb, tAvb, trAvb, tlAvb, refIdxL0, 1);
        var mvX1 = MBlockDecoderUtils.calcMVPredictionMedian(a1, b1, c1, d1, lAvb, tAvb, trAvb, tlAvb, refIdxL1, 0);
        var mvY1 = MBlockDecoderUtils.calcMVPredictionMedian(a1, b1, c1, d1, lAvb, tAvb, trAvb, tlAvb, refIdxL1, 1);
        var col = refs[1][0];
        var partPred = refIdxL0 >= 0 && refIdxL1 >= 0 ? H264Const.PartPred.Bi : (refIdxL0 >= 0 ? H264Const.PartPred.L0 : H264Const.PartPred.L1);
        for (var i = 0; i < blocks8x8.length; i++) {
            var blk8x8 = blocks8x8[i];
            var blk4x4_0 = H264Const.BLK8x8_BLOCKS[blk8x8][0];
            if (!this.sh.sps.direct8x8InferenceFlag) {
                var js = H264Const.BLK8x8_BLOCKS[blk8x8];
                for (var j = 0; j < js.length; j++) {
                    var blk4x4 = js[j];
                    this.pred4x4(mbX, mbY, x, pp, refIdxL0, refIdxL1, mvX0, mvY0, mvX1, mvY1, col, partPred, blk4x4);
                    var blkIndX = blk4x4 & 3;
                    var blkIndY = blk4x4 >> 2;
                    MBlockDecoderUtils.debugPrint("DIRECT_4x4 [%d, %d]: (%d,%d,%d), (%d,%d," + refIdxL1 + ")", blkIndY, blkIndX, x.mv0X(blk4x4), x.mv0Y(blk4x4), refIdxL0, x.mv1X(blk4x4), x.mv1Y(blk4x4));
                    var blkPredX = (mbX << 6) + (blkIndX << 4);
                    var blkPredY = (mbY << 6) + (blkIndY << 4);
                    if (refIdxL0 >= 0) 
                        this.interpolator.getBlockLuma(refs[0][refIdxL0], this.mbb[0], H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4], blkPredX + x.mv0X(blk4x4), blkPredY + x.mv0Y(blk4x4), 4, 4);
                    if (refIdxL1 >= 0) 
                        this.interpolator.getBlockLuma(refs[1][refIdxL1], this.mbb[1], H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4], blkPredX + x.mv1X(blk4x4), blkPredY + x.mv1Y(blk4x4), 4, 4);
                }
            } else {
                var blk4x4Pred = H264Const.BLK_INV_MAP[blk8x8 * 5];
                this.pred4x4(mbX, mbY, x, pp, refIdxL0, refIdxL1, mvX0, mvY0, mvX1, mvY1, col, partPred, blk4x4Pred);
                this.propagatePred(x, blk8x8, blk4x4Pred);
                var blkIndX = blk4x4_0 & 3;
                var blkIndY = blk4x4_0 >> 2;
                MBlockDecoderUtils.debugPrint("DIRECT_8x8 [%d, %d]: (%d,%d,%d), (%d,%d,%d)", blkIndY, blkIndX, x.mv0X(blk4x4_0), x.mv0Y(blk4x4_0), refIdxL0, x.mv1X(blk4x4_0), x.mv1Y(blk4x4_0), refIdxL1);
                var blkPredX = (mbX << 6) + (blkIndX << 4);
                var blkPredY = (mbY << 6) + (blkIndY << 4);
                if (refIdxL0 >= 0) 
                    this.interpolator.getBlockLuma(refs[0][refIdxL0], this.mbb[0], H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4_0], blkPredX + x.mv0X(blk4x4_0), blkPredY + x.mv0Y(blk4x4_0), 8, 8);
                if (refIdxL1 >= 0) 
                    this.interpolator.getBlockLuma(refs[1][refIdxL1], this.mbb[1], H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4_0], blkPredX + x.mv1X(blk4x4_0), blkPredY + x.mv1Y(blk4x4_0), 8, 8);
            }
            PredictionMerger.mergePrediction(this.sh, x.mv0R(blk4x4_0), x.mv1R(blk4x4_0), refIdxL0 >= 0 ? (refIdxL1 >= 0 ? H264Const.PartPred.Bi : H264Const.PartPred.L0) : H264Const.PartPred.L1, 0, this.mbb[0].getPlaneData(0), this.mbb[1].getPlaneData(0), H264Const.BLK_4x4_MB_OFF_LUMA[blk4x4_0], 16, 8, 8, mb.getPlaneData(0), refs, this.poc);
        }
    };
    prototype.calcRef = function(a0, b0, c0, d0, lAvb, tAvb, tlAvb, trAvb, mbX) {
        return this.minPos(this.minPos(lAvb ? H264Utils.Mv.mvRef(a0) : -1, tAvb ? H264Utils.Mv.mvRef(b0) : -1), trAvb ? H264Utils.Mv.mvRef(c0) : (tlAvb ? H264Utils.Mv.mvRef(d0) : -1));
    };
    prototype.propagatePred = function(x, blk8x8, blk4x4Pred) {
        var b0 = H264Const.BLK8x8_BLOCKS[blk8x8][0];
        var b1 = H264Const.BLK8x8_BLOCKS[blk8x8][1];
        var b2 = H264Const.BLK8x8_BLOCKS[blk8x8][2];
        var b3 = H264Const.BLK8x8_BLOCKS[blk8x8][3];
        x.copyPair(b0, x, blk4x4Pred);
        x.copyPair(b1, x, blk4x4Pred);
        x.copyPair(b2, x, blk4x4Pred);
        x.copyPair(b3, x, blk4x4Pred);
    };
    prototype.pred4x4 = function(mbX, mbY, x, pp, refL0, refL1, mvX0, mvY0, mvX1, mvY1, col, partPred, blk4x4) {
        var blkIndX = blk4x4 & 3;
        var blkIndY = blk4x4 >> 2;
        var blkPosX = (mbX << 2) + blkIndX;
        var blkPosY = (mbY << 2) + blkIndY;
        var mvCol = col.getMvs().getMv(blkPosX, blkPosY, 0);
        if (H264Utils.Mv.mvRef(mvCol) == -1) 
            mvCol = col.getMvs().getMv(blkPosX, blkPosY, 1);
        var colZero = col.isShortTerm() && H264Utils.Mv.mvRef(mvCol) == 0 && (MathUtil.abs(H264Utils.Mv.mvX(mvCol)) >> 1) == 0 && (MathUtil.abs(H264Utils.Mv.mvY(mvCol)) >> 1) == 0;
        var x0 = H264Utils.Mv.packMv(0, 0, refL0), x1 = H264Utils.Mv.packMv(0, 0, refL1);
        if (refL0 > 0 || !colZero) {
            x0 = H264Utils.Mv.packMv(mvX0, mvY0, refL0);
        }
        if (refL1 > 0 || !colZero) {
            x1 = H264Utils.Mv.packMv(mvX1, mvY1, refL1);
        }
        x.setPair(blk4x4, x0, x1);
        pp[H264Const.BLK_8x8_IND[blk4x4]] = partPred;
    };
    prototype.minPos = function(a, b) {
        return a >= 0 && b >= 0 ? Math.min(a, b) : Math.max(a, b);
    };
}, {mapper: "Mapper", s: "DecoderState", sh: "SliceHeader", di: "DeblockerInput", interpolator: "BlockInterpolator", mbb: "Array", scalingMatrix: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license. 
 *  
 *  @author in-somnia
 */
var SyntacticElements = function(config) {
    this.config = config;
    this.pce = new PCE();
    this.elements = Array(4 * SyntaxConstants.MAX_ELEMENTS);
    this.cces = Array(SyntaxConstants.MAX_ELEMENTS);
    this.dses = Array(SyntaxConstants.MAX_ELEMENTS);
    this.fils = Array(SyntaxConstants.MAX_ELEMENTS);
    this.startNewFrame();
};
SyntacticElements = stjs.extend(SyntacticElements, null, [SyntaxConstants], function(constructor, prototype) {
    prototype.config = null;
    prototype.sbrPresent = false;
    prototype.psPresent = false;
    prototype.bitsRead = 0;
    prototype.pce = null;
    prototype.elements = null;
    prototype.cces = null;
    prototype.dses = null;
    prototype.fils = null;
    prototype.curElem = 0;
    prototype.curCCE = 0;
    prototype.curDSE = 0;
    prototype.curFIL = 0;
    prototype.data = null;
    prototype.startNewFrame = function() {
        this.curElem = 0;
        this.curCCE = 0;
        this.curDSE = 0;
        this.curFIL = 0;
        this.sbrPresent = false;
        this.psPresent = false;
        this.bitsRead = 0;
    };
    prototype.decode = function(_in) {
        var start = _in.getPosition();
        var type;
        var prev = null;
        var content = true;
        if (!this.config.getProfile().isErrorResilientProfile()) {
             while (content && (type = _in.readBits(3)) != SyntaxConstants.ELEMENT_END){
                switch (type) {
                    case SyntaxConstants.ELEMENT_SCE:
                    case SyntaxConstants.ELEMENT_LFE:
                        Logger.debug("SCE");
                        prev = this.decodeSCE_LFE(_in);
                        break;
                    case SyntaxConstants.ELEMENT_CPE:
                        Logger.debug("CPE");
                        prev = this.decodeCPE(_in);
                        break;
                    case SyntaxConstants.ELEMENT_CCE:
                        Logger.debug("CCE");
                        this.decodeCCE(_in);
                        prev = null;
                        break;
                    case SyntaxConstants.ELEMENT_DSE:
                        Logger.debug("DSE");
                        this.decodeDSE(_in);
                        prev = null;
                        break;
                    case SyntaxConstants.ELEMENT_PCE:
                        Logger.debug("PCE");
                        this.decodePCE(_in);
                        prev = null;
                        break;
                    case SyntaxConstants.ELEMENT_FIL:
                        Logger.debug("FIL");
                        this.decodeFIL(_in, prev);
                        prev = null;
                        break;
                }
            }
            Logger.debug("END");
            content = false;
            prev = null;
        } else {
            var cc = this.config.getChannelConfiguration();
            if (ChannelConfiguration.CHANNEL_CONFIG_MONO == cc) {
                this.decodeSCE_LFE(_in);
            } else if (ChannelConfiguration.CHANNEL_CONFIG_STEREO == cc) {
                this.decodeCPE(_in);
            } else if (ChannelConfiguration.CHANNEL_CONFIG_STEREO_PLUS_CENTER == cc) {
                this.decodeSCE_LFE(_in);
                this.decodeCPE(_in);
            } else if (ChannelConfiguration.CHANNEL_CONFIG_STEREO_PLUS_CENTER_PLUS_REAR_MONO == cc) {
                this.decodeSCE_LFE(_in);
                this.decodeCPE(_in);
                this.decodeSCE_LFE(_in);
            } else if (ChannelConfiguration.CHANNEL_CONFIG_FIVE == cc) {
                this.decodeSCE_LFE(_in);
                this.decodeCPE(_in);
                this.decodeCPE(_in);
            } else if (ChannelConfiguration.CHANNEL_CONFIG_FIVE_PLUS_ONE == cc) {
                this.decodeSCE_LFE(_in);
                this.decodeCPE(_in);
                this.decodeCPE(_in);
                this.decodeSCE_LFE(_in);
            } else if (ChannelConfiguration.CHANNEL_CONFIG_SEVEN_PLUS_ONE == cc) {
                this.decodeSCE_LFE(_in);
                this.decodeCPE(_in);
                this.decodeCPE(_in);
                this.decodeCPE(_in);
                this.decodeSCE_LFE(_in);
            } else {
                 throw new AACException("unsupported channel configuration for error resilience: " + cc);
            }
        }
        _in.byteAlign();
        this.bitsRead = _in.getPosition() - start;
    };
    prototype.decodeSCE_LFE = function(_in) {
        if (this.elements[this.curElem] == null) 
            this.elements[this.curElem] = new SCE_LFE(this.config.getFrameLength());
        (this.elements[this.curElem]).decode(_in, this.config);
        this.curElem++;
        return this.elements[this.curElem - 1];
    };
    prototype.decodeCPE = function(_in) {
        if (this.elements[this.curElem] == null) 
            this.elements[this.curElem] = new CPE(this.config.getFrameLength());
        (this.elements[this.curElem]).decode(_in, this.config);
        this.curElem++;
        return this.elements[this.curElem - 1];
    };
    prototype.decodeCCE = function(_in) {
        if (this.curCCE == SyntaxConstants.MAX_ELEMENTS) 
             throw new AACException("too much CCE elements");
        if (this.cces[this.curCCE] == null) 
            this.cces[this.curCCE] = new CCE(this.config.getFrameLength());
        this.cces[this.curCCE].decode(_in, this.config);
        this.curCCE++;
    };
    prototype.decodeDSE = function(_in) {
        if (this.curDSE == SyntaxConstants.MAX_ELEMENTS) 
             throw new AACException("too much CCE elements");
        if (this.dses[this.curDSE] == null) 
            this.dses[this.curDSE] = new DSE();
        this.dses[this.curDSE].decode(_in);
        this.curDSE++;
    };
    prototype.decodePCE = function(_in) {
        this.pce.decode(_in);
        this.config.setProfile(this.pce.getProfile());
        this.config.setSampleFrequency(this.pce.getSampleFrequency());
        this.config.setChannelConfiguration(ChannelConfiguration.forInt(this.pce.getChannelCount()));
    };
    prototype.decodeFIL = function(_in, prev) {
        if (this.curFIL == SyntaxConstants.MAX_ELEMENTS) 
             throw new AACException("too much FIL elements");
        if (this.fils[this.curFIL] == null) 
            this.fils[this.curFIL] = new FIL(this.config.isSBRDownSampled());
        this.fils[this.curFIL].decode(_in, prev, this.config.getSampleFrequency(), this.config.isSBREnabled(), this.config.isSmallFrameUsed());
        this.curFIL++;
        if (prev != null && prev.isSBRPresent()) {
            this.sbrPresent = true;
            if (!this.psPresent && prev.getSBR().isPSUsed()) 
                this.psPresent = true;
        }
    };
    prototype.process = function(filterBank) {
        var profile = this.config.getProfile();
        var sf = this.config.getSampleFrequency();
        var chs = this.config.getChannelConfiguration().getChannelCount();
        if (chs == 1 && this.psPresent) 
            chs++;
        var mult = this.sbrPresent ? 2 : 1;
        if (this.data == null || chs != this.data.length || (mult * this.config.getFrameLength()) != this.data[0].length) 
            this.data = Array.apply(null, Array(chs)).map(function() {
                return new Float32Array(mult * this.config.getFrameLength());
            });
        var channel = 0;
        var e;
        var scelfe;
        var cpe;
        for (var i = 0; i < this.elements.length && channel < chs; i++) {
            e = this.elements[i];
            if (e == null) 
                continue;
            if (stjs.isInstanceOf(e.constructor, SCE_LFE)) {
                scelfe = e;
                channel += this.processSingle(scelfe, filterBank, channel, profile, sf);
            } else if (stjs.isInstanceOf(e.constructor, CPE)) {
                cpe = e;
                this.processPair(cpe, filterBank, channel, profile, sf);
                channel += 2;
            } else if (stjs.isInstanceOf(e.constructor, CCE)) {
                (e).process();
                channel++;
            }
        }
    };
    prototype.processSingle = function(scelfe, filterBank, channel, profile, sf) {
        var ics = scelfe.getICStream();
        var info = ics.getInfo();
        var ltp = info.getLTPrediction1();
        var elementID = scelfe.getElementInstanceTag();
        var iqData = ics.getInvQuantData();
        if (profile.equals(Profile.AAC_MAIN) && info.isICPredictionPresent()) 
            info.getICPrediction().process(ics, iqData, sf);
        if (ICSInfo.LTPrediction.isLTPProfile(profile) && info.isLTPrediction1Present()) 
            ltp.process(ics, iqData, filterBank, sf);
        this.processDependentCoupling(false, elementID, CCE.BEFORE_TNS, iqData, null);
        if (ics.isTNSDataPresent()) 
            ics.getTNS().process(ics, iqData, sf, false);
        this.processDependentCoupling(false, elementID, CCE.AFTER_TNS, iqData, null);
        filterBank.process(info.getWindowSequence(), info.getWindowShape(ICSInfo.CURRENT), info.getWindowShape(ICSInfo.PREVIOUS), iqData, this.data[channel], channel);
        if (ICSInfo.LTPrediction.isLTPProfile(profile)) 
            ltp.updateState(this.data[channel], filterBank.getOverlap(channel), profile);
        this.processIndependentCoupling(false, elementID, this.data[channel], null);
        if (ics.isGainControlPresent()) 
            ics.getGainControl().process(iqData, info.getWindowShape(ICSInfo.CURRENT), info.getWindowShape(ICSInfo.PREVIOUS), info.getWindowSequence());
        var chs = 1;
        if (this.sbrPresent && this.config.isSBREnabled()) {
            if (this.data[channel].length == this.config.getFrameLength()) 
                Logger.warn("SBR data present, but buffer has normal size!");
            var sbr = scelfe.getSBR();
            if (sbr.isPSUsed()) {
                chs = 2;
                scelfe.getSBR()._process(this.data[channel], this.data[channel + 1], false);
            } else 
                scelfe.getSBR().process(this.data[channel], false);
        }
        return chs;
    };
    prototype.processPair = function(cpe, filterBank, channel, profile, sf) {
        var ics1 = cpe.getLeftChannel();
        var ics2 = cpe.getRightChannel();
        var info1 = ics1.getInfo();
        var info2 = ics2.getInfo();
        var ltp1 = info1.getLTPrediction1();
        var ltp2 = cpe.isCommonWindow() ? info1.getLTPrediction2() : info2.getLTPrediction1();
        var elementID = cpe.getElementInstanceTag();
        var iqData1 = ics1.getInvQuantData();
        var iqData2 = ics2.getInvQuantData();
        if (cpe.isCommonWindow() && cpe.isMSMaskPresent()) 
            MS.process(cpe, iqData1, iqData2);
        if (profile.equals(Profile.AAC_MAIN)) {
            if (info1.isICPredictionPresent()) 
                info1.getICPrediction().process(ics1, iqData1, sf);
            if (info2.isICPredictionPresent()) 
                info2.getICPrediction().process(ics2, iqData2, sf);
        }
        IS.process(cpe, iqData1, iqData2);
        if (ICSInfo.LTPrediction.isLTPProfile(profile)) {
            if (info1.isLTPrediction1Present()) 
                ltp1.process(ics1, iqData1, filterBank, sf);
            if (cpe.isCommonWindow() && info1.isLTPrediction2Present()) 
                ltp2.process(ics2, iqData2, filterBank, sf);
             else if (info2.isLTPrediction1Present()) 
                ltp2.process(ics2, iqData2, filterBank, sf);
        }
        this.processDependentCoupling(true, elementID, CCE.BEFORE_TNS, iqData1, iqData2);
        if (ics1.isTNSDataPresent()) 
            ics1.getTNS().process(ics1, iqData1, sf, false);
        if (ics2.isTNSDataPresent()) 
            ics2.getTNS().process(ics2, iqData2, sf, false);
        this.processDependentCoupling(true, elementID, CCE.AFTER_TNS, iqData1, iqData2);
        filterBank.process(info1.getWindowSequence(), info1.getWindowShape(ICSInfo.CURRENT), info1.getWindowShape(ICSInfo.PREVIOUS), iqData1, this.data[channel], channel);
        filterBank.process(info2.getWindowSequence(), info2.getWindowShape(ICSInfo.CURRENT), info2.getWindowShape(ICSInfo.PREVIOUS), iqData2, this.data[channel + 1], channel + 1);
        if (ICSInfo.LTPrediction.isLTPProfile(profile)) {
            ltp1.updateState(this.data[channel], filterBank.getOverlap(channel), profile);
            ltp2.updateState(this.data[channel + 1], filterBank.getOverlap(channel + 1), profile);
        }
        this.processIndependentCoupling(true, elementID, this.data[channel], this.data[channel + 1]);
        if (ics1.isGainControlPresent()) 
            ics1.getGainControl().process(iqData1, info1.getWindowShape(ICSInfo.CURRENT), info1.getWindowShape(ICSInfo.PREVIOUS), info1.getWindowSequence());
        if (ics2.isGainControlPresent()) 
            ics2.getGainControl().process(iqData2, info2.getWindowShape(ICSInfo.CURRENT), info2.getWindowShape(ICSInfo.PREVIOUS), info2.getWindowSequence());
        if (this.sbrPresent && this.config.isSBREnabled()) {
            if (this.data[channel].length == this.config.getFrameLength()) 
                Logger.warn("SBR data present, but buffer has normal size!");
            cpe.getSBR()._process(this.data[channel], this.data[channel + 1], false);
        }
    };
    prototype.processIndependentCoupling = function(channelPair, elementID, data1, data2) {
        var index, c, chSelect;
        var cce;
        for (var i = 0; i < this.cces.length; i++) {
            cce = this.cces[i];
            index = 0;
            if (cce != null && cce.getCouplingPoint() == CCE.AFTER_IMDCT) {
                for (c = 0; c <= cce.getCoupledCount(); c++) {
                    chSelect = cce.getCHSelect(c);
                    if (cce.isChannelPair(c) == channelPair && cce.getIDSelect(c) == elementID) {
                        if (chSelect != 1) {
                            cce.applyIndependentCoupling(index, data1);
                            if (chSelect != 0) 
                                index++;
                        }
                        if (chSelect != 2) {
                            cce.applyIndependentCoupling(index, data2);
                            index++;
                        }
                    } else 
                        index += 1 + ((chSelect == 3) ? 1 : 0);
                }
            }
        }
    };
    prototype.processDependentCoupling = function(channelPair, elementID, couplingPoint, data1, data2) {
        var index, c, chSelect;
        var cce;
        for (var i = 0; i < this.cces.length; i++) {
            cce = this.cces[i];
            index = 0;
            if (cce != null && cce.getCouplingPoint() == couplingPoint) {
                for (c = 0; c <= cce.getCoupledCount(); c++) {
                    chSelect = cce.getCHSelect(c);
                    if (cce.isChannelPair(c) == channelPair && cce.getIDSelect(c) == elementID) {
                        if (chSelect != 1) {
                            cce.applyDependentCoupling(index, data1);
                            if (chSelect != 0) 
                                index++;
                        }
                        if (chSelect != 2) {
                            cce.applyDependentCoupling(index, data2);
                            index++;
                        }
                    } else 
                        index += 1 + ((chSelect == 3) ? 1 : 0);
                }
            }
        }
    };
    prototype.sendToOutput = function(buffer) {
        var be = buffer.isBigEndian();
        var chs = this.data.length;
        var mult = (this.sbrPresent && this.config.isSBREnabled()) ? 2 : 1;
        var length = mult * this.config.getFrameLength();
        var freq = mult * this.config.getSampleFrequency().getFrequency();
        var b = buffer.getData();
        if (b.length != chs * length * 2) 
            b = new Int8Array(chs * length * 2);
        var cur;
        var i, j, off;
        var s;
        for (i = 0; i < chs; i++) {
            cur = this.data[i];
            for (j = 0; j < length; j++) {
                s = ((Math.max(Math.min(Math.round(cur[j]), Short.MAX_VALUE), Short.MIN_VALUE)) << 16 >> 16);
                off = (j * chs + i) * 2;
                if (be) {
                    b[off] = (((s >> 8) & SyntaxConstants.BYTE_MASK) << 24 >> 24);
                    b[off + 1] = ((s & SyntaxConstants.BYTE_MASK) << 24 >> 24);
                } else {
                    b[off + 1] = (((s >> 8) & SyntaxConstants.BYTE_MASK) << 24 >> 24);
                    b[off] = ((s & SyntaxConstants.BYTE_MASK) << 24 >> 24);
                }
            }
        }
        buffer.setData(b, freq, chs, 16, this.bitsRead);
    };
}, {config: "DecoderConfig", pce: "PCE", elements: "Array", cces: "Array", dses: "Array", fils: "Array", data: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MP4MuxerTrack = function(trackId, type) {
    AbstractMP4MuxerTrack.call(this, trackId, type);
    this.sampleDurations = new ArrayList();
    this.chunkOffsets = LongArrayList.createLongArrayList();
    this.sampleSizes = IntArrayList.createIntArrayList();
    this.iframes = IntArrayList.createIntArrayList();
    this.compositionOffsets = new ArrayList();
    this.setTgtChunkDuration(new Rational(1, 1), Unit.FRAME);
};
MP4MuxerTrack = stjs.extend(MP4MuxerTrack, AbstractMP4MuxerTrack, [], function(constructor, prototype) {
    prototype.sampleDurations = null;
    prototype.sameDurCount = 0;
    prototype.curDuration = -1;
    prototype.chunkOffsets = null;
    prototype.sampleSizes = null;
    prototype.iframes = null;
    prototype.compositionOffsets = null;
    prototype.lastCompositionOffset = 0;
    prototype.lastCompositionSamples = 0;
    prototype.ptsEstimate = 0;
    prototype.lastEntry = -1;
    prototype.trackTotalDuration = 0;
    prototype.curFrame = 0;
    prototype.allIframes = true;
    prototype.timecodeTrack = null;
    prototype.addFrame = function(pkt) {
        this.addFrameInternal(pkt, 1);
        this.processTimecode(pkt);
    };
    prototype.addFrameInternal = function(pkt, entryNo) {
        if (this.finished) 
             throw new IllegalStateException("The muxer track has finished muxing");
        if (this._timescale == AbstractMP4MuxerTrack.NO_TIMESCALE_SET) {
            this._timescale = pkt.getTimescale();
        }
        if (this._timescale != pkt.getTimescale()) {
            pkt.setPts(stjs.trunc((pkt.getPts() * this._timescale) / pkt.getTimescale()));
            pkt.setDuration(stjs.trunc((pkt.getPts() * this._timescale) / pkt.getDuration()));
        }
        if (this.type == MP4TrackType.VIDEO) {
            var compositionOffset = pkt.getPts() - this.ptsEstimate;
            if (compositionOffset != this.lastCompositionOffset) {
                if (this.lastCompositionSamples > 0) 
                    this.compositionOffsets.add(new CompositionOffsetsBox.LongEntry(this.lastCompositionSamples, this.lastCompositionOffset));
                this.lastCompositionOffset = compositionOffset;
                this.lastCompositionSamples = 0;
            }
            this.lastCompositionSamples++;
            this.ptsEstimate += pkt.getDuration();
        }
        if (this.lastEntry != -1 && this.lastEntry != entryNo) {
            this.outChunk(this.lastEntry);
            this.samplesInLastChunk = -1;
        }
        this.curChunk.add(pkt.getData());
        if (pkt.isKeyFrame()) 
            this.iframes.add(this.curFrame + 1);
         else 
            this.allIframes = false;
        this.curFrame++;
        this.chunkDuration += pkt.getDuration();
        if (this.curDuration != -1 && pkt.getDuration() != this.curDuration) {
            this.sampleDurations.add(new TimeToSampleBox.TimeToSampleEntry(((this.sameDurCount) | 0), ((this.curDuration) | 0)));
            this.sameDurCount = 0;
        }
        this.curDuration = pkt.getDuration();
        this.sameDurCount++;
        this.trackTotalDuration += pkt.getDuration();
        this.outChunkIfNeeded(entryNo);
        this.lastEntry = entryNo;
    };
    prototype.processTimecode = function(pkt) {
        if (this.timecodeTrack != null) 
            this.timecodeTrack.addTimecode(pkt);
    };
    prototype.outChunkIfNeeded = function(entryNo) {
        Preconditions.checkState(this.tgtChunkDurationUnit == Unit.FRAME || this.tgtChunkDurationUnit == Unit.SEC);
        if (this.tgtChunkDurationUnit == Unit.FRAME && this.curChunk.size() * this.tgtChunkDuration.getDen() == this.tgtChunkDuration.getNum()) {
            this.outChunk(entryNo);
        } else if (this.tgtChunkDurationUnit == Unit.SEC && this.chunkDuration > 0 && this.chunkDuration * this.tgtChunkDuration.getDen() >= this.tgtChunkDuration.getNum() * this._timescale) {
            this.outChunk(entryNo);
        }
    };
    prototype.outChunk = function(entryNo) {
        if (this.curChunk.size() == 0) 
            return;
        this.chunkOffsets.add(this.out.position());
        for (var iterator$bs = this.curChunk.iterator(); iterator$bs.hasNext(); ) {
            var bs = iterator$bs.next();
            this.sampleSizes.add(bs.remaining());
            this.out.write(bs);
        }
        if (this.samplesInLastChunk == -1 || this.samplesInLastChunk != this.curChunk.size()) {
            this.samplesInChunks.add(new SampleToChunkBox.SampleToChunkEntry(this.chunkNo + 1, this.curChunk.size(), entryNo));
        }
        this.samplesInLastChunk = this.curChunk.size();
        this.chunkNo++;
        this.chunkDuration = 0;
        this.curChunk.clear();
    };
    prototype.finish = function(mvhd) {
        Preconditions.checkState(!this.finished, "The muxer track has finished muxing");
        this.outChunk(this.lastEntry);
        if (this.sameDurCount > 0) {
            this.sampleDurations.add(new TimeToSampleBox.TimeToSampleEntry(((this.sameDurCount) | 0), ((this.curDuration) | 0)));
        }
        this.finished = true;
        var trak = TrakBox.createTrakBox();
        var dd = this.getDisplayDimensions();
        var tkhd = TrackHeaderBox.createTrackHeaderBox(this.trackId, stjs.trunc((mvhd.getTimescale() * this.trackTotalDuration) / this._timescale), dd.getWidth(), dd.getHeight(), new jsutil.Date().getTime(), new jsutil.Date().getTime(), 1.0, ((0) << 16 >> 16), 0, new Int32Array([65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]));
        tkhd.setFlags(15);
        trak.add(tkhd);
        this.tapt(trak);
        var media = MediaBox.createMediaBox();
        trak.add(media);
        media.add(MediaHeaderBox.createMediaHeaderBox(this._timescale, this.trackTotalDuration, 0, new jsutil.Date().getTime(), new jsutil.Date().getTime(), 0));
        var hdlr = HandlerBox.createHandlerBox("mhlr", this.type.getHandler(), "appl", 0, 0);
        media.add(hdlr);
        var minf = MediaInfoBox.createMediaInfoBox();
        media.add(minf);
        this.mediaHeader(minf, this.type);
        minf.add(HandlerBox.createHandlerBox("dhlr", "url ", "appl", 0, 0));
        this.addDref(minf);
        var stbl = new NodeBox(new Header("stbl"));
        minf.add(stbl);
        this.putCompositionOffsets(stbl);
        this.putEdits(trak);
        this.putName(trak);
        stbl.add(SampleDescriptionBox.createSampleDescriptionBox(this.sampleEntries.toArray(Array(0))));
        stbl.add(SampleToChunkBox.createSampleToChunkBox(this.samplesInChunks.toArray(Array(0))));
        stbl.add(SampleSizesBox.createSampleSizesBox2(this.sampleSizes.toArray()));
        stbl.add(TimeToSampleBox.createTimeToSampleBox(this.sampleDurations.toArray([])));
        stbl.add(ChunkOffsets64Box.createChunkOffsets64Box(this.chunkOffsets.toArray()));
        if (!this.allIframes && this.iframes.size() > 0) 
            stbl.add(SyncSamplesBox.createSyncSamplesBox(this.iframes.toArray()));
        return trak;
    };
    prototype.putCompositionOffsets = function(stbl) {
        if (this.compositionOffsets.size() > 0) {
            this.compositionOffsets.add(new CompositionOffsetsBox.LongEntry(this.lastCompositionSamples, this.lastCompositionOffset));
            var min = MP4MuxerTrack.minLongOffset(this.compositionOffsets);
            if (min > 0) {
                for (var iterator$entry = this.compositionOffsets.iterator(); iterator$entry.hasNext(); ) {
                    var entry = iterator$entry.next();
                    entry.offset -= min;
                }
            }
            var first = this.compositionOffsets.get(0);
            if (first.getOffset() > 0) {
                if (this.edits == null) {
                    this.edits = new ArrayList();
                    this.edits.add(new Edit(this.trackTotalDuration, first.getOffset(), 1.0));
                } else {
                    for (var iterator$edit = this.edits.iterator(); iterator$edit.hasNext(); ) {
                        var edit = iterator$edit.next();
                        edit.setMediaTime(edit.getMediaTime() + first.getOffset());
                    }
                }
            }
            var intEntries = Array(this.compositionOffsets.size());
            for (var i = 0; i < this.compositionOffsets.size(); i++) {
                var longEntry = this.compositionOffsets.get(i);
                intEntries[i] = new CompositionOffsetsBox.Entry(Ints.checkedCast(longEntry.count), Ints.checkedCast(longEntry.offset));
            }
            stbl.add(CompositionOffsetsBox.createCompositionOffsetsBox(intEntries));
        }
    };
    constructor.minLongOffset = function(offs) {
        var min = Long.MAX_VALUE;
        for (var iterator$entry = offs.iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            min = Math.min(min, entry.getOffset());
        }
        return min;
    };
    constructor.minOffset = function(offs) {
        var min = Integer.MAX_VALUE;
        for (var iterator$entry = offs.iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            min = Math.min(min, entry.getOffset());
        }
        return min;
    };
    prototype.getTrackTotalDuration = function() {
        return this.trackTotalDuration;
    };
    prototype.getTimecodeTrack = function() {
        return this.timecodeTrack;
    };
    prototype.setTimecode = function(timecodeTrack) {
        this.timecodeTrack = timecodeTrack;
    };
}, {sampleDurations: {name: "List", arguments: ["TimeToSampleBox.TimeToSampleEntry"]}, chunkOffsets: "LongArrayList", sampleSizes: "IntArrayList", iframes: "IntArrayList", compositionOffsets: {name: "List", arguments: ["CompositionOffsetsBox.LongEntry"]}, timecodeTrack: "TimecodeMP4MuxerTrack", type: "MP4TrackType", tgtChunkDuration: "Rational", tgtChunkDurationUnit: {name: "Enum", arguments: ["Unit"]}, curChunk: {name: "List", arguments: ["ByteBuffer"]}, samplesInChunks: {name: "List", arguments: ["SampleToChunkBox.SampleToChunkEntry"]}, sampleEntries: {name: "List", arguments: ["SampleEntry"]}, edits: {name: "List", arguments: ["Edit"]}, out: "SeekableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Creates MP4 file out of a set of samples
 *  
 *  @author The JCodec project
 *  
 */
var MovieBox = function(atom) {
    NodeBox.call(this, atom);
};
MovieBox = stjs.extend(MovieBox, NodeBox, [], function(constructor, prototype) {
    constructor.fourcc = function() {
        return "moov";
    };
    constructor.createMovieBox = function() {
        return new MovieBox(new Header(MovieBox.fourcc()));
    };
    prototype.getTracks = function() {
        return NodeBox.findAll(this, TrakBox, "trak");
    };
    prototype.getVideoTrack = function() {
        var tracks = this.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            if (trakBox.isVideo()) 
                return trakBox;
        }
        return null;
    };
    prototype.getTimecodeTrack = function() {
        var tracks = this.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            if (trakBox.isTimecode()) 
                return trakBox;
        }
        return null;
    };
    prototype.getTimescale = function() {
        return this.getMovieHeader().getTimescale();
    };
    prototype.rescale = function(tv, ts) {
        return stjs.trunc((tv * this.getTimescale()) / ts);
    };
    prototype.fixTimescale = function(newTs) {
        var oldTs = this.getTimescale();
        this.setTimescale(newTs);
        var tracks = this.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            trakBox.setDuration(this.rescale(trakBox.getDuration(), oldTs));
            var edits = trakBox.getEdits();
            if (edits == null) 
                continue;
            var lit = edits.listIterator();
             while (lit.hasNext()){
                var edit = lit.next();
                lit.set(new Edit(this.rescale(edit.getDuration(), oldTs), edit.getMediaTime(), edit.getRate()));
            }
        }
        this.setDuration(this.rescale(this.getDuration(), oldTs));
    };
    prototype.setTimescale = function(newTs) {
        NodeBox.findFirst(this, MovieHeaderBox, "mvhd").setTimescale(newTs);
    };
    prototype.setDuration = function(movDuration) {
        this.getMovieHeader().setDuration(movDuration);
    };
    prototype.getMovieHeader = function() {
        return NodeBox.findFirst(this, MovieHeaderBox, "mvhd");
    };
    prototype.getAudioTracks = function() {
        var result = new ArrayList();
        var tracks = this.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            if (trakBox.isAudio()) 
                result.add(trakBox);
        }
        return result;
    };
    prototype.getDuration = function() {
        return this.getMovieHeader().getDuration();
    };
    prototype.importTrack = function(movie, track) {
        var newTrack = NodeBox.cloneBox(track, 1024 * 1024, this.factory);
        var edits = newTrack.getEdits();
        var result = new ArrayList();
        if (edits != null) {
            for (var iterator$edit = edits.iterator(); iterator$edit.hasNext(); ) {
                var edit = iterator$edit.next();
                result.add(new Edit(this.rescale(edit.getDuration(), movie.getTimescale()), edit.getMediaTime(), edit.getRate()));
            }
        }
        newTrack.setEdits(result);
        return newTrack;
    };
    prototype.appendTrack = function(newTrack) {
        newTrack.getTrackHeader().setNo(this.getMovieHeader().getNextTrackId());
        this.getMovieHeader().setNextTrackId(this.getMovieHeader().getNextTrackId() + 1);
        this.boxes.add(newTrack);
    };
    prototype.isPureRefMovie = function() {
        var pureRef = true;
        var tracks = this.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            pureRef &= trakBox.isPureRef();
        }
        return pureRef;
    };
    prototype.updateDuration = function() {
        var tracks = this.getTracks();
        var min = Integer.MAX_VALUE;
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            if (trakBox.getDuration() < min) 
                min = trakBox.getDuration();
        }
        this.getMovieHeader().setDuration(min);
    };
    prototype.getDisplaySize = function() {
        var videoTrack = this.getVideoTrack();
        if (videoTrack == null) 
            return null;
        var clef = NodeBox.findFirstPath(videoTrack, ClearApertureBox, Box.path("tapt.clef"));
        if (clef != null) {
            return this.applyMatrix(videoTrack, new Size(stjs.trunc(clef.getWidth()), stjs.trunc(clef.getHeight())));
        }
        var box = NodeBox.findFirstPath(videoTrack, SampleDescriptionBox, Box.path("mdia.minf.stbl.stsd")).getBoxes().get(0);
        if (box == null || !(stjs.isInstanceOf(box.constructor, VideoSampleEntry))) 
            return null;
        var vs = box;
        var par = videoTrack.getPAR();
        return this.applyMatrix(videoTrack, new Size(stjs.trunc((stjs.trunc((vs.getWidth() * par.getNum()) / par.getDen()))), stjs.trunc(vs.getHeight())));
    };
    prototype.applyMatrix = function(videoTrack, size) {
        var matrix = videoTrack.getTrackHeader().getMatrix();
        return new Size(stjs.trunc((size.getWidth() * matrix[0] / 65536)), stjs.trunc((size.getHeight() * matrix[4] / 65536)));
    };
    prototype.getStoredSize = function() {
        var videoTrack = this.getVideoTrack();
        if (videoTrack == null) 
            return null;
        var enof = NodeBox.findFirstPath(videoTrack, EncodedPixelBox, Box.path("tapt.enof"));
        if (enof != null) {
            return new Size(stjs.trunc(enof.getWidth()), stjs.trunc(enof.getHeight()));
        }
        var box = NodeBox.findFirstPath(videoTrack, SampleDescriptionBox, Box.path("mdia.minf.stbl.stsd")).getBoxes().get(0);
        if (box == null || !(stjs.isInstanceOf(box.constructor, VideoSampleEntry))) 
            return null;
        var vs = box;
        return new Size(stjs.trunc(vs.getWidth()), stjs.trunc(vs.getHeight()));
    };
}, {boxes: {name: "List", arguments: ["Box"]}, factory: "IBoxFactory", header: "Header"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Shared routines between PCM and Frames tracks
 *  
 *  @author The JCodec project
 *  
 */
var AbstractMP4DemuxerTrack = function(trak) {
    this.no = trak.getTrackHeader().getNo();
    this.type = TrakBox.getTrackType(trak);
    this.sampleEntries = NodeBox.findAllPath(trak, SampleEntry, ["mdia", "minf", "stbl", "stsd", null]);
    var stbl = trak.getMdia().getMinf().getStbl();
    var stts = NodeBox.findFirst(stbl, TimeToSampleBox, "stts");
    var stsc = NodeBox.findFirst(stbl, SampleToChunkBox, "stsc");
    var stco = NodeBox.findFirst(stbl, ChunkOffsetsBox, "stco");
    var co64 = NodeBox.findFirst(stbl, ChunkOffsets64Box, "co64");
    this.timeToSamples = stts.getEntries();
    this.sampleToChunks = stsc.getSampleToChunk();
    this.chunkOffsets = stco != null ? stco.getChunkOffsets() : co64.getChunkOffsets();
    for (var i = 0; i < this.timeToSamples.length; i++) {
        var ttse = this.timeToSamples[i];
        this.duration += ttse.getSampleCount() * ttse.getSampleDuration();
    }
    this.box = trak;
    this.timescale = trak.getTimescale();
};
AbstractMP4DemuxerTrack = stjs.extend(AbstractMP4DemuxerTrack, null, [SeekableDemuxerTrack], function(constructor, prototype) {
    prototype.box = null;
    prototype.type = null;
    prototype.no = 0;
    prototype.sampleEntries = null;
    prototype.timeToSamples = null;
    prototype.sampleToChunks = null;
    prototype.chunkOffsets = null;
    prototype.duration = 0;
    prototype.sttsInd = 0;
    prototype.sttsSubInd = 0;
    prototype.stcoInd = 0;
    prototype.stscInd = 0;
    prototype.pts = 0;
    prototype.curFrame = 0;
    prototype.timescale = 0;
    prototype.pts2Sample = function(_tv, _timescale) {
        var tv = stjs.trunc(_tv * this.timescale / _timescale);
        var ttsInd, sample = 0;
        for (ttsInd = 0; ttsInd < this.timeToSamples.length - 1; ttsInd++) {
            var a = this.timeToSamples[ttsInd].getSampleCount() * this.timeToSamples[ttsInd].getSampleDuration();
            if (tv < a) 
                break;
            tv -= a;
            sample += this.timeToSamples[ttsInd].getSampleCount();
        }
        return sample + (((stjs.trunc(tv / this.timeToSamples[ttsInd].getSampleDuration()))) | 0);
    };
    prototype.getType = function() {
        return this.type;
    };
    prototype.getNo = function() {
        return this.no;
    };
    prototype.getSampleEntries = function() {
        return this.sampleEntries;
    };
    prototype.getBox = function() {
        return this.box;
    };
    prototype.getTimescale = function() {
        return this.timescale;
    };
    prototype.seekPointer = function(frameNo) {};
    prototype.canSeek = function(pts) {
        return pts >= 0 && pts < this.duration;
    };
    prototype.seekPts = function(pts) {
        if (pts < 0) 
             throw new IllegalArgumentException("Seeking to negative pts");
        if (pts >= this.duration) 
            return false;
        var prevDur = 0;
        var frameNo = 0;
        for (this.sttsInd = 0; pts > prevDur + this.timeToSamples[this.sttsInd].getSampleCount() * this.timeToSamples[this.sttsInd].getSampleDuration() && this.sttsInd < this.timeToSamples.length - 1; this.sttsInd++) {
            prevDur += this.timeToSamples[this.sttsInd].getSampleCount() * this.timeToSamples[this.sttsInd].getSampleDuration();
            frameNo += this.timeToSamples[this.sttsInd].getSampleCount();
        }
        this.sttsSubInd = (((stjs.trunc((pts - prevDur) / this.timeToSamples[this.sttsInd].getSampleDuration()))) | 0);
        frameNo += this.sttsSubInd;
        this.pts = prevDur + this.timeToSamples[this.sttsInd].getSampleDuration() * this.sttsSubInd;
        this.seekPointer(frameNo);
        return true;
    };
    prototype.shiftPts = function(frames) {
        this.pts -= this.sttsSubInd * this.timeToSamples[this.sttsInd].getSampleDuration();
        this.sttsSubInd += frames;
         while (this.sttsInd < this.timeToSamples.length - 1 && this.sttsSubInd >= this.timeToSamples[this.sttsInd].getSampleCount()){
            this.pts += this.timeToSamples[this.sttsInd].getSegmentDuration();
            this.sttsSubInd -= this.timeToSamples[this.sttsInd].getSampleCount();
            this.sttsInd++;
        }
        this.pts += this.sttsSubInd * this.timeToSamples[this.sttsInd].getSampleDuration();
    };
    prototype.nextChunk = function() {
        if (this.stcoInd >= this.chunkOffsets.length) 
            return;
        this.stcoInd++;
        if ((this.stscInd + 1 < this.sampleToChunks.length) && this.stcoInd + 1 == this.sampleToChunks[this.stscInd + 1].getFirst()) {
            this.stscInd++;
        }
    };
    prototype.gotoFrame = function(frameNo) {
        if (frameNo < 0) 
             throw new IllegalArgumentException("negative frame number");
        if (frameNo >= this.getFrameCount()) 
            return false;
        if (frameNo == this.curFrame) 
            return true;
        this.seekPointer(frameNo);
        this.seekFrame(frameNo);
        return true;
    };
    prototype.seek = function(second) {
        this.seekPts(stjs.trunc((second * this.timescale)));
    };
    prototype.seekFrame = function(frameNo) {
        this.pts = this.sttsInd = this.sttsSubInd = 0;
        this.shiftPts(frameNo);
    };
    prototype.getDuration = function() {
        return new RationalLarge(this.box.getMediaDuration(), this.box.getTimescale());
    };
    prototype.getFrameCount = function() {};
    prototype.getCurFrame = function() {
        return this.curFrame;
    };
    prototype.getEdits = function() {
        var editListBox = NodeBox.findFirstPath(this.box, EditListBox, Box.path("edts.elst"));
        if (editListBox != null) 
            return editListBox.getEdits();
        return null;
    };
    prototype.getName = function() {
        var nameBox = NodeBox.findFirstPath(this.box, NameBox, Box.path("udta.name"));
        return nameBox != null ? nameBox.getName() : null;
    };
    prototype.getFourcc = function() {
        var entries = this.getSampleEntries();
        var se = entries == null || entries.length == 0 ? null : entries[0];
        var fourcc = se == null ? null : se.getHeader().getFourcc();
        return fourcc;
    };
    prototype.readPacketData = function(input, buffer, offset, size) {
        var result = buffer.duplicate();
        {
            input.setPosition(offset);
            NIOUtils.readL(input, result, size);
        }result.flip();
        return result;
    };
    prototype.getNextFrame = function(storage) {};
    prototype.convertPacket = function(_in) {
        return _in;
    };
    prototype.getMeta = function() {
        return MP4DemuxerTrackMeta.fromTrack(this);
    };
}, {box: "TrakBox", type: "MP4TrackType", sampleEntries: "Array", timeToSamples: "Array", sampleToChunks: "Array", chunkOffsets: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var PCMMP4MuxerTrack = function(trackId, format) {
    AbstractMP4MuxerTrack.call(this, trackId, MP4TrackType.SOUND);
    this.chunkOffsets = LongArrayList.createLongArrayList();
    this.frameDuration = 1;
    this.frameSize = (format.getSampleSizeInBits() >> 3) * format.getChannels();
    this.addSampleEntry(AudioSampleEntry.audioSampleEntryPCM(format));
    this._timescale = format.getSampleRate();
    this.setTgtChunkDuration(new Rational(1, 2), Unit.SEC);
};
PCMMP4MuxerTrack = stjs.extend(PCMMP4MuxerTrack, AbstractMP4MuxerTrack, [], function(constructor, prototype) {
    prototype.frameDuration = 0;
    prototype.frameSize = 0;
    prototype.framesInCurChunk = 0;
    prototype.chunkOffsets = null;
    prototype.totalFrames = 0;
    prototype.addFrame = function(outPacket) {
        this.addSamples(outPacket.getData().duplicate());
    };
    prototype.addSamples = function(buffer) {
        this.curChunk.add(buffer);
        var frames = stjs.trunc(buffer.remaining() / this.frameSize);
        this.totalFrames += frames;
        this.framesInCurChunk += frames;
        this.chunkDuration += frames * this.frameDuration;
        this.outChunkIfNeeded();
    };
    prototype.outChunkIfNeeded = function() {
        Preconditions.checkState(this.tgtChunkDurationUnit == Unit.FRAME || this.tgtChunkDurationUnit == Unit.SEC, "");
        if (this.tgtChunkDurationUnit == Unit.FRAME && this.framesInCurChunk * this.tgtChunkDuration.getDen() == this.tgtChunkDuration.getNum()) {
            this.outChunk();
        } else if (this.tgtChunkDurationUnit == Unit.SEC && this.chunkDuration > 0 && this.chunkDuration * this.tgtChunkDuration.getDen() >= this.tgtChunkDuration.getNum() * this._timescale) {
            this.outChunk();
        }
    };
    prototype.outChunk = function() {
        if (this.framesInCurChunk == 0) 
            return;
        this.chunkOffsets.add(this.out.position());
        for (var iterator$b = this.curChunk.iterator(); iterator$b.hasNext(); ) {
            var b = iterator$b.next();
            this.out.write(b);
        }
        this.curChunk.clear();
        if (this.samplesInLastChunk == -1 || this.framesInCurChunk != this.samplesInLastChunk) {
            this.samplesInChunks.add(new SampleToChunkBox.SampleToChunkEntry(this.chunkNo + 1, this.framesInCurChunk, 1));
        }
        this.samplesInLastChunk = this.framesInCurChunk;
        this.chunkNo++;
        this.framesInCurChunk = 0;
        this.chunkDuration = 0;
    };
    prototype.finish = function(mvhd) {
        if (this.finished) 
             throw new IllegalStateException("The muxer track has finished muxing");
        this.outChunk();
        this.finished = true;
        var trak = TrakBox.createTrakBox();
        var dd = this.getDisplayDimensions();
        var tkhd = TrackHeaderBox.createTrackHeaderBox(this.trackId, stjs.trunc((stjs.trunc(mvhd.getTimescale()) * this.totalFrames * this.frameDuration) / this._timescale), dd.getWidth(), dd.getHeight(), new jsutil.Date().getTime(), new jsutil.Date().getTime(), 1.0, ((0) << 16 >> 16), 0, new Int32Array([65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]));
        tkhd.setFlags(15);
        trak.add(tkhd);
        this.tapt(trak);
        var media = MediaBox.createMediaBox();
        trak.add(media);
        media.add(MediaHeaderBox.createMediaHeaderBox(this._timescale, this.totalFrames * this.frameDuration, 0, new jsutil.Date().getTime(), new jsutil.Date().getTime(), 0));
        var hdlr = HandlerBox.createHandlerBox("mhlr", this.type.getHandler(), "appl", 0, 0);
        media.add(hdlr);
        var minf = MediaInfoBox.createMediaInfoBox();
        media.add(minf);
        this.mediaHeader(minf, this.type);
        minf.add(HandlerBox.createHandlerBox("dhlr", "url ", "appl", 0, 0));
        this.addDref(minf);
        var stbl = new NodeBox(new Header("stbl"));
        minf.add(stbl);
        this.putEdits(trak);
        this.putName(trak);
        stbl.add(SampleDescriptionBox.createSampleDescriptionBox(this.sampleEntries.toArray(Array(0))));
        stbl.add(SampleToChunkBox.createSampleToChunkBox(this.samplesInChunks.toArray(Array(0))));
        stbl.add(SampleSizesBox.createSampleSizesBox(this.frameSize, this.totalFrames));
        stbl.add(TimeToSampleBox.createTimeToSampleBox([new TimeToSampleBox.TimeToSampleEntry(this.totalFrames, this.frameDuration)]));
        stbl.add(ChunkOffsets64Box.createChunkOffsets64Box(this.chunkOffsets.toArray()));
        return trak;
    };
    prototype.getTrackTotalDuration = function() {
        return this.totalFrames * this.frameDuration;
    };
}, {chunkOffsets: "LongArrayList", type: "MP4TrackType", tgtChunkDuration: "Rational", tgtChunkDurationUnit: {name: "Enum", arguments: ["Unit"]}, curChunk: {name: "List", arguments: ["ByteBuffer"]}, samplesInChunks: {name: "List", arguments: ["SampleToChunkBox.SampleToChunkEntry"]}, sampleEntries: {name: "List", arguments: ["SampleEntry"]}, edits: {name: "List", arguments: ["Edit"]}, out: "SeekableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Encodes macroblock as I16x16
 *  
 *  @author Stanislav Vitvitskyy
 */
var MBEncoderI16x16 = function(cavlc, leftRow, topLine) {
    this.cavlc = cavlc;
    this.leftRow = leftRow;
    this.topLine = topLine;
};
MBEncoderI16x16 = stjs.extend(MBEncoderI16x16, null, [SaveRestore], function(constructor, prototype) {
    prototype.cavlc = null;
    prototype.leftRow = null;
    prototype.topLine = null;
    prototype.save = function() {
        for (var i = 0; i < this.cavlc.length; i++) 
            this.cavlc[i].save();
    };
    prototype.restore = function() {
        for (var i = 0; i < this.cavlc.length; i++) 
            this.cavlc[i].restore();
    };
    prototype.encodeMacroblock = function(pic, mbX, mbY, out, outMB, leftOutMB, topOutMB, qp, qpDelta) {
        CAVLCWriter.writeUE(out, 0);
        CAVLCWriter.writeSE(out, qpDelta);
        outMB.setType(MBType.I_16x16);
        outMB.setQp(qp);
        this.luma(pic, mbX, mbY, out, qp, outMB.getPixels(), this.cavlc[0]);
        this.chroma(pic, mbX, mbY, out, qp, outMB.getPixels());
        new MBDeblocker().deblockMBI(outMB, leftOutMB, topOutMB);
    };
    constructor.DUMMY = new Int32Array(16);
    prototype.chroma = function(pic, mbX, mbY, out, qp, outMB) {
        var x = mbX << 3;
        var y = mbY << 3;
        var ac1 = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(16);
        });
        var ac2 = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(16);
        });
        var pred1 = Array.apply(null, Array(4)).map(function() {
            return new Int8Array(16);
        });
        var pred2 = Array.apply(null, Array(4)).map(function() {
            return new Int8Array(16);
        });
        this.predictChroma(pic, ac1, pred1, 1, x, y);
        this.predictChroma(pic, ac2, pred2, 2, x, y);
        MBEncoderI16x16.chromaResidual(pic, mbX, mbY, out, qp, ac1, ac2, this.cavlc[1], this.cavlc[2], MBType.I_16x16, MBType.I_16x16);
        this.putChroma(outMB.getData()[1], 1, x, y, ac1, pred1);
        this.putChroma(outMB.getData()[2], 2, x, y, ac2, pred2);
    };
    constructor.chromaResidual = function(pic, mbX, mbY, out, qp, ac1, ac2, cavlc1, cavlc2, leftMBType, topMBType) {
        MBEncoderI16x16.transformChroma(ac1);
        MBEncoderI16x16.transformChroma(ac2);
        var dc1 = MBEncoderI16x16.extractDC(ac1);
        var dc2 = MBEncoderI16x16.extractDC(ac2);
        MBEncoderI16x16.writeDC(cavlc1, mbX, mbY, out, qp, mbX << 1, mbY << 1, dc1, leftMBType, topMBType);
        MBEncoderI16x16.writeDC(cavlc2, mbX, mbY, out, qp, mbX << 1, mbY << 1, dc2, leftMBType, topMBType);
        MBEncoderI16x16.writeAC(cavlc1, mbX, mbY, out, mbX << 1, mbY << 1, ac1, qp, leftMBType, topMBType, MBEncoderI16x16.DUMMY);
        MBEncoderI16x16.writeAC(cavlc2, mbX, mbY, out, mbX << 1, mbY << 1, ac2, qp, leftMBType, topMBType, MBEncoderI16x16.DUMMY);
        MBEncoderI16x16.restorePlane(dc1, ac1, qp);
        MBEncoderI16x16.restorePlane(dc2, ac2, qp);
    };
    prototype.luma = function(pic, mbX, mbY, out, qp, outMB, cavlc) {
        var x = mbX << 4;
        var y = mbY << 4;
        var ac = Array.apply(null, Array(16)).map(function() {
            return new Int32Array(16);
        });
        var pred = Array.apply(null, Array(16)).map(function() {
            return new Int8Array(16);
        });
        this.lumaDCPred(x, y, pred);
        this.transform(pic, 0, ac, pred, x, y);
        var dc = MBEncoderI16x16.extractDC(ac);
        MBEncoderI16x16.writeDC(cavlc, mbX, mbY, out, qp, mbX << 2, mbY << 2, dc, MBType.I_16x16, MBType.I_16x16);
        MBEncoderI16x16.writeAC(cavlc, mbX, mbY, out, mbX << 2, mbY << 2, ac, qp, MBType.I_16x16, MBType.I_16x16, MBEncoderI16x16.DUMMY);
        MBEncoderI16x16.restorePlane(dc, ac, qp);
        for (var blk = 0; blk < ac.length; blk++) {
            MBEncoderHelper.putBlk(outMB.getPlaneData(0), ac[blk], pred[blk], 4, H264Const.BLK_X[blk], H264Const.BLK_Y[blk], 4, 4);
        }
    };
    prototype.putChroma = function(mb, comp, x, y, ac, pred) {
        MBEncoderHelper.putBlk(mb, ac[0], pred[0], 3, 0, 0, 4, 4);
        MBEncoderHelper.putBlk(mb, ac[1], pred[1], 3, 4, 0, 4, 4);
        MBEncoderHelper.putBlk(mb, ac[2], pred[2], 3, 0, 4, 4, 4);
        MBEncoderHelper.putBlk(mb, ac[3], pred[3], 3, 4, 4, 4, 4);
    };
    constructor.restorePlane = function(dc, ac, qp) {
        if (dc.length == 4) {
            CoeffTransformer.invDC2x2(dc);
            CoeffTransformer.dequantizeDC2x2(dc, qp, null);
        } else if (dc.length == 8) {
            CoeffTransformer.invDC4x2(dc);
            CoeffTransformer.dequantizeDC4x2(dc, qp);
        } else {
            CoeffTransformer.invDC4x4(dc);
            CoeffTransformer.dequantizeDC4x4(dc, qp, null);
            CoeffTransformer.reorderDC4x4(dc);
        }
        for (var i = 0; i < ac.length; i++) {
            CoeffTransformer.dequantizeAC(ac[i], qp, null);
            ac[i][0] = dc[i];
            CoeffTransformer.idct4x4(ac[i]);
        }
    };
    constructor.extractDC = function(ac) {
        var dc = new Int32Array(ac.length);
        for (var i = 0; i < ac.length; i++) {
            dc[i] = ac[i][0];
            ac[i][0] = 0;
        }
        return dc;
    };
    constructor.writeAC = function(cavlc, mbX, mbY, out, mbLeftBlk, mbTopBlk, ac, qp, leftMBType, topMBType, nc) {
        for (var i = 0; i < ac.length; i++) {
            CoeffTransformer.quantizeAC(ac[i], qp);
            nc[H264Const.BLK_INV_MAP[i]] = CAVLC.totalCoeff(cavlc.writeACBlock(out, mbLeftBlk + H264Const.MB_BLK_OFF_LEFT[i], mbTopBlk + H264Const.MB_BLK_OFF_TOP[i], leftMBType, topMBType, ac[i], H264Const.totalZeros16, 1, 15, CoeffTransformer.zigzag4x4));
        }
    };
    constructor.writeDC = function(cavlc, mbX, mbY, out, qp, mbLeftBlk, mbTopBlk, dc, leftMBType, topMBType) {
        if (dc.length == 4) {
            CoeffTransformer.quantizeDC2x2(dc, qp);
            CoeffTransformer.fvdDC2x2(dc);
            cavlc.writeChrDCBlock(out, dc, H264Const.totalZeros4, 0, dc.length, new Int32Array([0, 1, 2, 3]));
        } else if (dc.length == 8) {
            CoeffTransformer.quantizeDC4x2(dc, qp);
            CoeffTransformer.fvdDC4x2(dc);
            cavlc.writeChrDCBlock(out, dc, H264Const.totalZeros8, 0, dc.length, new Int32Array([0, 1, 2, 3, 4, 5, 6, 7]));
        } else {
            CoeffTransformer.reorderDC4x4(dc);
            CoeffTransformer.quantizeDC4x4(dc, qp);
            CoeffTransformer.fvdDC4x4(dc);
            cavlc.writeLumaDCBlock(out, mbLeftBlk, mbTopBlk, leftMBType, topMBType, dc, H264Const.totalZeros16, 0, 16, CoeffTransformer.zigzag4x4);
        }
    };
    constructor.transformChroma = function(ac) {
        for (var i = 0; i < 4; i++) {
            CoeffTransformer.fdct4x4(ac[i]);
        }
    };
    prototype.predictChroma = function(pic, ac, pred, comp, x, y) {
        this.chromaPredBlk0(comp, x, y, pred[0]);
        this.chromaPredBlk1(comp, x, y, pred[1]);
        this.chromaPredBlk2(comp, x, y, pred[2]);
        this.chromaPredBlk3(comp, x, y, pred[3]);
        MBEncoderHelper.takeSubtract(pic.getPlaneData(comp), pic.getPlaneWidth(comp), pic.getPlaneHeight(comp), x, y, ac[0], pred[0], 4, 4);
        MBEncoderHelper.takeSubtract(pic.getPlaneData(comp), pic.getPlaneWidth(comp), pic.getPlaneHeight(comp), x + 4, y, ac[1], pred[1], 4, 4);
        MBEncoderHelper.takeSubtract(pic.getPlaneData(comp), pic.getPlaneWidth(comp), pic.getPlaneHeight(comp), x, y + 4, ac[2], pred[2], 4, 4);
        MBEncoderHelper.takeSubtract(pic.getPlaneData(comp), pic.getPlaneWidth(comp), pic.getPlaneHeight(comp), x + 4, y + 4, ac[3], pred[3], 4, 4);
    };
    prototype.chromaPredOne = function(pix, x) {
        return (pix[x] + pix[x + 1] + pix[x + 2] + pix[x + 3] + 2) >> 2;
    };
    prototype.chromaPredTwo = function(pix1, pix2, x, y) {
        return (pix1[x] + pix1[x + 1] + pix1[x + 2] + pix1[x + 3] + pix2[y] + pix2[y + 1] + pix2[y + 2] + pix2[y + 3] + 4) >> 3;
    };
    prototype.chromaPredBlk0 = function(comp, x, y, pred) {
        var dc, predY = y & 7;
        if (x != 0 && y != 0) 
            dc = this.chromaPredTwo(this.leftRow[comp], this.topLine[comp], predY, x);
         else if (x != 0) 
            dc = this.chromaPredOne(this.leftRow[comp], predY);
         else if (y != 0) 
            dc = this.chromaPredOne(this.topLine[comp], x);
         else 
            dc = 0;
        for (var i = 0; i < pred.length; i++) 
            pred[i] += dc;
    };
    prototype.chromaPredBlk1 = function(comp, x, y, pred) {
        var dc, predY = y & 7;
        if (y != 0) 
            dc = this.chromaPredOne(this.topLine[comp], x + 4);
         else if (x != 0) 
            dc = this.chromaPredOne(this.leftRow[comp], predY);
         else 
            dc = 0;
        for (var i = 0; i < pred.length; i++) 
            pred[i] += dc;
    };
    prototype.chromaPredBlk2 = function(comp, x, y, pred) {
        var dc, predY = y & 7;
        if (x != 0) 
            dc = this.chromaPredOne(this.leftRow[comp], predY + 4);
         else if (y != 0) 
            dc = this.chromaPredOne(this.topLine[comp], x);
         else 
            dc = 0;
        for (var i = 0; i < pred.length; i++) 
            pred[i] += dc;
    };
    prototype.chromaPredBlk3 = function(comp, x, y, pred) {
        var dc, predY = y & 7;
        if (x != 0 && y != 0) 
            dc = this.chromaPredTwo(this.leftRow[comp], this.topLine[comp], predY + 4, x + 4);
         else if (x != 0) 
            dc = this.chromaPredOne(this.leftRow[comp], predY + 4);
         else if (y != 0) 
            dc = this.chromaPredOne(this.topLine[comp], x + 4);
         else 
            dc = 0;
        for (var i = 0; i < pred.length; i++) 
            pred[i] += dc;
    };
    prototype.lumaDCPred = function(x, y, pred) {
        var dc;
        if (x == 0 && y == 0) 
            dc = 0;
         else if (y == 0) 
            dc = (ArrayUtil.sumByte(this.leftRow[0]) + 8) >> 4;
         else if (x == 0) 
            dc = (ArrayUtil.sumByte3(this.topLine[0], x, 16) + 8) >> 4;
         else 
            dc = (ArrayUtil.sumByte(this.leftRow[0]) + ArrayUtil.sumByte3(this.topLine[0], x, 16) + 16) >> 5;
        for (var i = 0; i < pred.length; i++) 
            for (var j = 0; j < pred[i].length; j++) 
                pred[i][j] += dc;
    };
    prototype.transform = function(pic, comp, ac, pred, x, y) {
        for (var i = 0; i < ac.length; i++) {
            var coeff = ac[i];
            MBEncoderHelper.takeSubtract(pic.getPlaneData(comp), pic.getPlaneWidth(comp), pic.getPlaneHeight(comp), x + H264Const.BLK_X[i], y + H264Const.BLK_Y[i], coeff, pred[i], 4, 4);
            CoeffTransformer.fdct4x4(coeff);
        }
    };
    prototype.getPredMode = function(pic, mbX, mbY) {
        return 2;
    };
    prototype.getCbpChroma = function(pic, mbX, mbY) {
        return 2;
    };
    prototype.getCbpLuma = function(pic, mbX, mbY) {
        return 15;
    };
}, {cavlc: "Array", leftRow: "Array", topLine: "Array", DUMMY: "Int32Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 4 AVC ( H.264 ) Frame reader
 *  
 *  Conforms to H.264 ( ISO/IEC 14496-10 ) specifications
 *  
 *  @author The JCodec project
 *  
 */
var FrameReader = function() {
    this.sps = new IntObjectMap();
    this.pps = new IntObjectMap();
};
FrameReader = stjs.extend(FrameReader, null, [], function(constructor, prototype) {
    prototype.sps = null;
    prototype.pps = null;
    prototype.readFrame = function(nalUnits) {
        var result = new ArrayList();
        for (var iterator$nalData = nalUnits.iterator(); iterator$nalData.hasNext(); ) {
            var nalData = iterator$nalData.next();
            var nalUnit = NALUnit.read(nalData);
            H264Utils.unescapeNAL(nalData);
            if (NALUnitType.SPS == nalUnit.type) {
                var _sps = SeqParameterSet.read(nalData);
                this.sps.put(_sps.seqParameterSetId, _sps);
            } else if (NALUnitType.PPS == nalUnit.type) {
                var _pps = PictureParameterSet.read(nalData);
                this.pps.put(_pps.picParameterSetId, _pps);
            } else if (NALUnitType.IDR_SLICE == nalUnit.type || NALUnitType.NON_IDR_SLICE == nalUnit.type) {
                if (this.sps.size() == 0 || this.pps.size() == 0) {
                    Logger.warn("Skipping frame as no SPS/PPS have been seen so far...");
                    return null;
                }
                result.add(this.createSliceReader(nalData, nalUnit));
            }
        }
        return result;
    };
    prototype.createSliceReader = function(segment, nalUnit) {
        var _in = BitReader.createBitReader(segment);
        var sh = SliceHeaderReader.readPart1(_in);
        sh.pps = this.pps.get(sh.picParameterSetId);
        sh.sps = this.sps.get(sh.pps.seqParameterSetId);
        SliceHeaderReader.readPart2(sh, nalUnit, sh.sps, sh.pps, _in);
        var mapper = new MapManager(sh.sps, sh.pps).getMapper(sh);
        var cavlc = [new CAVLC(sh.sps, sh.pps, 2, 2), new CAVLC(sh.sps, sh.pps, 1, 1), new CAVLC(sh.sps, sh.pps, 1, 1)];
        var mbWidth = sh.sps.picWidthInMbsMinus1 + 1;
        var cabac = new CABAC(mbWidth);
        var mDecoder = null;
        if (sh.pps.entropyCodingModeFlag) {
            _in.terminate();
            var cm = Array.apply(null, Array(2)).map(function() {
                return new Int32Array(1024);
            });
            var qp = sh.pps.picInitQpMinus26 + 26 + sh.sliceQpDelta;
            cabac.initModels(cm, sh.sliceType, sh.cabacInitIdc, qp);
            mDecoder = new MDecoder(segment, cm);
        }
        return new SliceReader(sh.pps, cabac, cavlc, mDecoder, _in, mapper, sh, nalUnit);
    };
    prototype.addSpsList = function(spsList) {
        for (var iterator$byteBuffer = spsList.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            this.addSps(byteBuffer);
        }
    };
    prototype.addSps = function(byteBuffer) {
        var clone = NIOUtils.clone(byteBuffer);
        H264Utils.unescapeNAL(clone);
        var s = SeqParameterSet.read(clone);
        this.sps.put(s.seqParameterSetId, s);
    };
    prototype.addPpsList = function(ppsList) {
        for (var iterator$byteBuffer = ppsList.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            this.addPps(byteBuffer);
        }
    };
    prototype.addPps = function(byteBuffer) {
        var clone = NIOUtils.clone(byteBuffer);
        H264Utils.unescapeNAL(clone);
        var p = PictureParameterSet.read(clone);
        this.pps.put(p.picParameterSetId, p);
    };
}, {sps: {name: "IntObjectMap", arguments: ["SeqParameterSet"]}, pps: {name: "IntObjectMap", arguments: ["PictureParameterSet"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  A decoder for an individual slice
 *  
 *  @author The JCodec project
 *  
 */
var SliceDecoder = function(activeSps, sRefs, lRefs, di, result) {
    this.di = di;
    this.activeSps = activeSps;
    this.frameOut = result;
    this.sRefs = sRefs;
    this.lRefs = lRefs;
};
SliceDecoder = stjs.extend(SliceDecoder, null, [], function(constructor, prototype) {
    prototype.mapper = null;
    prototype.decoderIntra16x16 = null;
    prototype.decoderIntraNxN = null;
    prototype.decoderInter = null;
    prototype.decoderInter8x8 = null;
    prototype.skipDecoder = null;
    prototype.decoderBDirect = null;
    prototype.refListManager = null;
    prototype.decoderIPCM = null;
    prototype.parser = null;
    prototype.activeSps = null;
    prototype.frameOut = null;
    prototype.decoderState = null;
    prototype.di = null;
    prototype.lRefs = null;
    prototype.sRefs = null;
    prototype.decodeFromReader = function(sliceReader) {
        this.parser = sliceReader;
        this.initContext();
        MBlockDecoderUtils.debugPrint("============%d============= ", this.frameOut.getPOC());
        var refList = this.refListManager.getRefList();
        this.decodeMacroblocks(refList);
    };
    prototype.initContext = function() {
        var sh = this.parser.getSliceHeader();
        this.decoderState = new DecoderState(sh);
        this.mapper = new MapManager(sh.sps, sh.pps).getMapper(sh);
        this.decoderIntra16x16 = new MBlockDecoderIntra16x16(this.mapper, sh, this.di, this.frameOut.getPOC(), this.decoderState);
        this.decoderIntraNxN = new MBlockDecoderIntraNxN(this.mapper, sh, this.di, this.frameOut.getPOC(), this.decoderState);
        this.decoderInter = new MBlockDecoderInter(this.mapper, sh, this.di, this.frameOut.getPOC(), this.decoderState);
        this.decoderBDirect = new MBlockDecoderBDirect(this.mapper, sh, this.di, this.frameOut.getPOC(), this.decoderState);
        this.decoderInter8x8 = new MBlockDecoderInter8x8(this.mapper, this.decoderBDirect, sh, this.di, this.frameOut.getPOC(), this.decoderState);
        this.skipDecoder = new MBlockSkipDecoder(this.mapper, this.decoderBDirect, sh, this.di, this.frameOut.getPOC(), this.decoderState);
        this.decoderIPCM = new MBlockDecoderIPCM(this.mapper, this.decoderState);
        this.refListManager = new RefListManager(sh, this.sRefs, this.lRefs, this.frameOut);
    };
    prototype.decodeMacroblocks = function(refList) {
        var mb = Picture.create(16, 16, this.activeSps.chromaFormatIdc);
        var mbWidth = this.activeSps.picWidthInMbsMinus1 + 1;
        var mBlock = new MBlock(this.activeSps.chromaFormatIdc);
         while (this.parser.readMacroblock(mBlock)){
            this.decode(mBlock, this.parser.getSliceHeader().sliceType, mb, refList);
            var mbAddr = this.mapper.getAddress(mBlock.mbIdx);
            var mbX = mbAddr % mbWidth;
            var mbY = stjs.trunc(mbAddr / mbWidth);
            SliceDecoder.putMacroblock(this.frameOut, mb, mbX, mbY);
            this.di.shs[mbAddr] = this.parser.getSliceHeader();
            this.di.refsUsed[mbAddr] = refList;
            this.fillCoeff(mBlock, mbX, mbY);
            mb.fill(0);
            mBlock.clear();
        }
    };
    prototype.fillCoeff = function(mBlock, mbX, mbY) {
        for (var i = 0; i < 16; i++) {
            var blkOffLeft = H264Const.MB_BLK_OFF_LEFT[i];
            var blkOffTop = H264Const.MB_BLK_OFF_TOP[i];
            var blkX = (mbX << 2) + blkOffLeft;
            var blkY = (mbY << 2) + blkOffTop;
            this.di.nCoeff[blkY][blkX] = mBlock.nCoeff[i];
        }
    };
    prototype.decode = function(mBlock, sliceType, mb, references) {
        if (mBlock.skipped) {
            this.skipDecoder.decodeSkip(mBlock, references, mb, sliceType);
        } else if (sliceType == SliceType.I) {
            this.decodeMBlockI(mBlock, mb);
        } else if (sliceType == SliceType.P) {
            this.decodeMBlockP(mBlock, mb, references);
        } else {
            this.decodeMBlockB(mBlock, mb, references);
        }
    };
    prototype.decodeMBlockI = function(mBlock, mb) {
        this.decodeMBlockIInt(mBlock, mb);
    };
    prototype.decodeMBlockIInt = function(mBlock, mb) {
        if (mBlock.curMbType == MBType.I_NxN) {
            this.decoderIntraNxN.decode(mBlock, mb);
        } else if (mBlock.curMbType == MBType.I_16x16) {
            this.decoderIntra16x16.decode(mBlock, mb);
        } else {
            Logger.warn("IPCM macroblock found. Not tested, may cause unpredictable behavior.");
            this.decoderIPCM.decode(mBlock, mb);
        }
    };
    prototype.decodeMBlockP = function(mBlock, mb, references) {
        if (MBType.P_16x16 == mBlock.curMbType) {
            this.decoderInter.decode16x16(mBlock, mb, references, H264Const.PartPred.L0);
        } else if (MBType.P_16x8 == mBlock.curMbType) {
            this.decoderInter.decode16x8(mBlock, mb, references, H264Const.PartPred.L0, H264Const.PartPred.L0);
        } else if (MBType.P_8x16 == mBlock.curMbType) {
            this.decoderInter.decode8x16(mBlock, mb, references, H264Const.PartPred.L0, H264Const.PartPred.L0);
        } else if (MBType.P_8x8 == mBlock.curMbType) {
            this.decoderInter8x8.decode(mBlock, references, mb, SliceType.P, false);
        } else if (MBType.P_8x8ref0 == mBlock.curMbType) {
            this.decoderInter8x8.decode(mBlock, references, mb, SliceType.P, true);
        } else {
            this.decodeMBlockIInt(mBlock, mb);
        }
    };
    prototype.decodeMBlockB = function(mBlock, mb, references) {
        if (mBlock.curMbType.isIntra()) {
            this.decodeMBlockIInt(mBlock, mb);
        } else {
            if (mBlock.curMbType == MBType.B_Direct_16x16) {
                this.decoderBDirect.decode(mBlock, mb, references);
            } else if (mBlock.mbType <= 3) {
                this.decoderInter.decode16x16(mBlock, mb, references, H264Const.bPredModes[mBlock.mbType][0]);
            } else if (mBlock.mbType == 22) {
                this.decoderInter8x8.decode(mBlock, references, mb, SliceType.B, false);
            } else if ((mBlock.mbType & 1) == 0) {
                this.decoderInter.decode16x8(mBlock, mb, references, H264Const.bPredModes[mBlock.mbType][0], H264Const.bPredModes[mBlock.mbType][1]);
            } else {
                this.decoderInter.decode8x16(mBlock, mb, references, H264Const.bPredModes[mBlock.mbType][0], H264Const.bPredModes[mBlock.mbType][1]);
            }
        }
    };
    constructor.putMacroblock = function(tgt, decoded, mbX, mbY) {
        var luma = tgt.getPlaneData(0);
        var stride = tgt.getPlaneWidth(0);
        var cb = tgt.getPlaneData(1);
        var cr = tgt.getPlaneData(2);
        var strideChroma = tgt.getPlaneWidth(1);
        var dOff = 0;
        var mbx16 = mbX * 16;
        var mby16 = mbY * 16;
        var decodedY = decoded.getPlaneData(0);
        for (var i = 0; i < 16; i++) {
            System.arraycopy(decodedY, dOff, luma, (mby16 + i) * stride + mbx16, 16);
            dOff += 16;
        }
        var mbx8 = mbX * 8;
        var mby8 = mbY * 8;
        var decodedCb = decoded.getPlaneData(1);
        var decodedCr = decoded.getPlaneData(2);
        for (var i = 0; i < 8; i++) {
            var decodePos = i << 3;
            var chromaPos = (mby8 + i) * strideChroma + mbx8;
            System.arraycopy(decodedCb, decodePos, cb, chromaPos, 8);
            System.arraycopy(decodedCr, decodePos, cr, chromaPos, 8);
        }
    };
}, {mapper: "Mapper", decoderIntra16x16: "MBlockDecoderIntra16x16", decoderIntraNxN: "MBlockDecoderIntraNxN", decoderInter: "MBlockDecoderInter", decoderInter8x8: "MBlockDecoderInter8x8", skipDecoder: "MBlockSkipDecoder", decoderBDirect: "MBlockDecoderBDirect", refListManager: "RefListManager", decoderIPCM: "MBlockDecoderIPCM", parser: "SliceReader", activeSps: "SeqParameterSet", frameOut: "Frame", decoderState: "DecoderState", di: "DeblockerInput", lRefs: {name: "IntObjectMap", arguments: ["Frame"]}, sRefs: "Array"}, {});
/**
 *  This class is part of JAAD ( jaadec.sourceforge.net ) that is distributed
 *  under the Public Domain license. Code changes provided by the JCodec project
 *  are distributed under FreeBSD license.
 *  
 *  Main AAC decoder class
 *  
 *  @author in-somnia
 */
var Decoder = /**
 *  Initializes the decoder with a MP4 decoder specific info.
 * 
 *  After this the MP4 frames can be passed to the
 *  <code>decodeFrame(byte[], SampleBuffer)</code> method to decode them.
 *  
 *  @param decoderSpecificInfo
 *             a byte array containing the decoder specific info from an MP4
 *             container
 *  @throws AACException
 *              if the specified profile is not supported
 */
function(decoderSpecificInfo) {
    this.config = DecoderConfig.parseMP4DecoderSpecificInfo(decoderSpecificInfo);
    if (this.config == null) 
         throw new IllegalArgumentException("illegal MP4 decoder specific info");
    if (!Decoder.canDecode(this.config.getProfile())) 
         throw new AACException("unsupported profile: " + this.config.getProfile().getDescription());
    this.syntacticElements = new SyntacticElements(this.config);
    this.filterBank = new FilterBank(this.config.isSmallFrameUsed(), this.config.getChannelConfiguration().getChannelCount());
    this._in = new BitStream();
    Logger.debug("profile: {0}", this.config.getProfile());
    Logger.debug("sf: {0}", this.config.getSampleFrequency().getFrequency());
    Logger.debug("channels: {0}", this.config.getChannelConfiguration().getDescription());
};
Decoder = stjs.extend(Decoder, null, [SyntaxConstants], function(constructor, prototype) {
    prototype.config = null;
    prototype.syntacticElements = null;
    prototype.filterBank = null;
    prototype._in = null;
    prototype.adifHeader = null;
    /**
     *  The methods returns true, if a profile is supported by the decoder.
     *  
     *  @param profile
     *             an AAC profile
     *  @return true if the specified profile can be decoded
     *  @see Profile#isDecodingSupported()
     */
    constructor.canDecode = function(profile) {
        return profile.isDecodingSupported();
    };
    prototype.getConfig = function() {
        return this.config;
    };
    /**
     *  Decodes one frame of AAC data in frame mode and returns the raw PCM data.
     *  
     *  @param frame
     *             the AAC frame
     *  @param buffer
     *             a buffer to hold the decoded PCM data
     *  @throws AACException
     *              if decoding fails
     */
    prototype.decodeFrame = function(frame, buffer) {
        if (frame != null) 
            this._in.setData(frame);
        Logger.debug("bits left " + this._in.getBitsLeft());
        try {
            this.decode(buffer);
        }catch (e) {
            if (!e.isEndOfStream()) 
                 throw e;
             else 
                Logger.warn("unexpected end of frame");
        }
    };
    prototype.decode = function(buffer) {
        if (ADIFHeader.isPresent(this._in)) {
            this.adifHeader = ADIFHeader.readHeader(this._in);
            var pce = this.adifHeader.getFirstPCE();
            this.config.setProfile(pce.getProfile());
            this.config.setSampleFrequency(pce.getSampleFrequency());
            this.config.setChannelConfiguration(ChannelConfiguration.forInt(pce.getChannelCount()));
        }
        if (!Decoder.canDecode(this.config.getProfile())) 
             throw new AACException("unsupported profile: " + this.config.getProfile().getDescription());
        this.syntacticElements.startNewFrame();
        try {
            this.syntacticElements.decode(this._in);
            this.syntacticElements.process(this.filterBank);
            this.syntacticElements.sendToOutput(buffer);
        }catch (e) {
            buffer.setData(new Int8Array(0), 0, 0, 0, 0);
             throw AACException.wrap(e);
        }
    };
}, {config: "DecoderConfig", syntacticElements: "SyntacticElements", filterBank: "FilterBank", _in: "IBitStream", adifHeader: "ADIFHeader"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var CodecMP4MuxerTrack = function(trackId, type, codec) {
    MP4MuxerTrack.call(this, trackId, type);
    this.codec = codec;
    this.spsList = new ArrayList();
    this.ppsList = new ArrayList();
};
CodecMP4MuxerTrack = stjs.extend(CodecMP4MuxerTrack, MP4MuxerTrack, [], function(constructor, prototype) {
    constructor.codec2fourcc = new HashMap();
    prototype.codec = null;
    prototype.spsList = null;
    prototype.ppsList = null;
    prototype.adtsHeader = null;
    prototype.addFrame = function(pkt) {
        if (this.codec == Codec.H264) {
            var result = pkt.getData();
            if (pkt.frameType == Packet.FrameType.UNKNOWN) {
                pkt.setFrameType(H264Utils.isByteBufferIDRSlice(result) ? Packet.FrameType.KEY : Packet.FrameType.INTER);
            }
            H264Utils.wipePSinplace(result, this.spsList, this.ppsList);
            result = H264Utils.encodeMOVPacket(result);
            pkt = Packet.createPacketWithData(pkt, result);
        } else if (this.codec == Codec.AAC) {
            var result = pkt.getData();
            this.adtsHeader = ADTSParser.read(result);
            pkt = Packet.createPacketWithData(pkt, result);
        }
        MP4MuxerTrack.prototype.addFrame.call(this, pkt);
    };
    prototype.addFrameInternal = function(pkt, entryNo) {
        Preconditions.checkState(!this.finished, "The muxer track has finished muxing");
        if (this._timescale == AbstractMP4MuxerTrack.NO_TIMESCALE_SET) {
            if (this.adtsHeader != null) {
                this._timescale = this.adtsHeader.getSampleRate();
            } else {
                this._timescale = pkt.getTimescale();
            }
        }
        if (this._timescale != pkt.getTimescale()) {
            pkt.setPts(stjs.trunc((pkt.getPts() * this._timescale) / pkt.getTimescale()));
            pkt.setDuration(stjs.trunc((pkt.getPts() * this._timescale) / pkt.getDuration()));
        }
        if (this.adtsHeader != null) {
            pkt.setDuration(1024);
        }
        MP4MuxerTrack.prototype.addFrameInternal.call(this, pkt, entryNo);
    };
    prototype.finish = function(mvhd) {
        Preconditions.checkState(!this.finished, "The muxer track has finished muxing");
        if (this.getEntries().isEmpty()) {
            if (this.codec == Codec.H264 && !this.spsList.isEmpty()) {
                var sps = SeqParameterSet.read(this.spsList.get(0).duplicate());
                var size = H264Utils.getPicSize(sps);
                var meta = VideoCodecMeta.createSimpleVideoCodecMeta(size, ColorSpace.YUV420);
                this.addVideoSampleEntry(meta);
            } else {
                Logger.warn("CodecMP4MuxerTrack: Creating a track without sample entry");
            }
        }
        this.setCodecPrivateIfNeeded();
        return MP4MuxerTrack.prototype.finish.call(this, mvhd);
    };
    prototype.addVideoSampleEntry = function(meta) {
        var se = VideoSampleEntry.videoSampleEntry(CodecMP4MuxerTrack.codec2fourcc.get(this.codec), meta.getSize(), "JCodec");
        if (meta.getPixelAspectRatio() != null) 
            se.add(PixelAspectExt.createPixelAspectExt(meta.getPixelAspectRatio()));
        this.addSampleEntry(se);
    };
    constructor.selectUnique = function(bblist) {
        var all = new HashSet();
        for (var iterator$byteBuffer = bblist.iterator(); iterator$byteBuffer.hasNext(); ) {
            var byteBuffer = iterator$byteBuffer.next();
            all.add(new CodecMP4MuxerTrack.ByteArrayWrapper(byteBuffer));
        }
        var result = new ArrayList();
        for (var iterator$bs = all.iterator(); iterator$bs.hasNext(); ) {
            var bs = iterator$bs.next();
            result.add(bs.get());
        }
        return result;
    };
    prototype.setCodecPrivateIfNeeded = function() {
        if (this.codec == Codec.H264) {
            var sps = CodecMP4MuxerTrack.selectUnique(this.spsList);
            var pps = CodecMP4MuxerTrack.selectUnique(this.ppsList);
            if (!sps.isEmpty() && !pps.isEmpty()) {
                this.getEntries().get(0).add(H264Utils.createAvcCFromPS(sps, pps, 4));
            } else {
                Logger.warn("CodecMP4MuxerTrack: Not adding a sample entry for h.264 track, missing any SPS/PPS NAL units");
            }
        } else if (this.codec == Codec.AAC) {
            if (this.adtsHeader != null) {
                this.getEntries().get(0).add(EsdsBox.fromADTS(this.adtsHeader));
            } else {
                Logger.warn("CodecMP4MuxerTrack: Not adding a sample entry for AAC track, missing any ADTS headers.");
            }
        }
    };
    constructor.ByteArrayWrapper = function(bytes) {
        this.bytes = NIOUtils.toArray(bytes);
    };
    constructor.ByteArrayWrapper = stjs.extend(constructor.ByteArrayWrapper, null, [], function(constructor, prototype) {
        prototype.bytes = null;
        prototype.get = function() {
            return ByteBuffer.wrap(this.bytes);
        };
        prototype.equals = function(obj) {
            if (!(stjs.isInstanceOf(obj.constructor, CodecMP4MuxerTrack.ByteArrayWrapper))) 
                return false;
            return Platform.arrayEqualsByte(this.bytes, (obj).bytes);
        };
        prototype.hashCode = function() {
            return Arrays.hashCode(this.bytes);
        };
    }, {bytes: "Int8Array"}, {});
    prototype.addAudioSampleEntry = function(format) {
        var ase = AudioSampleEntry.compressedAudioSampleEntry(CodecMP4MuxerTrack.codec2fourcc.get(this.codec), ((1) << 16 >> 16), ((16) << 16 >> 16), format.getChannels(), format.getSampleRate(), 0, 0, 0);
        this.addSampleEntry(ase);
    };
}, {codec2fourcc: {name: "Map", arguments: ["Codec", null]}, codec: "Codec", spsList: {name: "List", arguments: ["ByteBuffer"]}, ppsList: {name: "List", arguments: ["ByteBuffer"]}, adtsHeader: "ADTSParser.Header", sampleDurations: {name: "List", arguments: ["TimeToSampleBox.TimeToSampleEntry"]}, chunkOffsets: "LongArrayList", sampleSizes: "IntArrayList", iframes: "IntArrayList", compositionOffsets: {name: "List", arguments: ["CompositionOffsetsBox.LongEntry"]}, timecodeTrack: "TimecodeMP4MuxerTrack", type: "MP4TrackType", tgtChunkDuration: "Rational", tgtChunkDurationUnit: {name: "Enum", arguments: ["Unit"]}, curChunk: {name: "List", arguments: ["ByteBuffer"]}, samplesInChunks: {name: "List", arguments: ["SampleToChunkBox.SampleToChunkEntry"]}, sampleEntries: {name: "List", arguments: ["SampleEntry"]}, edits: {name: "List", arguments: ["Edit"]}, out: "SeekableByteChannel"}, {});
(function() {
    CodecMP4MuxerTrack.codec2fourcc.put(Codec.MP1, ".mp1");
    CodecMP4MuxerTrack.codec2fourcc.put(Codec.MP2, ".mp2");
    CodecMP4MuxerTrack.codec2fourcc.put(Codec.MP3, ".mp3");
    CodecMP4MuxerTrack.codec2fourcc.put(Codec.H264, "avc1");
    CodecMP4MuxerTrack.codec2fourcc.put(Codec.AAC, "mp4a");
    CodecMP4MuxerTrack.codec2fourcc.put(Codec.PRORES, "apch");
    CodecMP4MuxerTrack.codec2fourcc.put(Codec.JPEG, "mjpg");
    CodecMP4MuxerTrack.codec2fourcc.put(Codec.PNG, "png ");
    CodecMP4MuxerTrack.codec2fourcc.put(Codec.V210, "v210");
})();
var DefaultBoxes = function() {
    Boxes.call(this);
    this.mappings.put(MovieExtendsBox.fourcc(), MovieExtendsBox);
    this.mappings.put(MovieExtendsHeaderBox.fourcc(), MovieExtendsHeaderBox);
    this.mappings.put(SegmentIndexBox.fourcc(), SegmentIndexBox);
    this.mappings.put(SegmentTypeBox.fourcc(), SegmentTypeBox);
    this.mappings.put(TrackExtendsBox.fourcc(), TrackExtendsBox);
    this.mappings.put(VideoMediaHeaderBox.fourcc(), VideoMediaHeaderBox);
    this.mappings.put(FileTypeBox.fourcc(), FileTypeBox);
    this.mappings.put(MovieBox.fourcc(), MovieBox);
    this.mappings.put(MovieHeaderBox.fourcc(), MovieHeaderBox);
    this.mappings.put(TrakBox.fourcc(), TrakBox);
    this.mappings.put(TrackHeaderBox.fourcc(), TrackHeaderBox);
    this.mappings.put("edts", NodeBox);
    this.mappings.put(EditListBox.fourcc(), EditListBox);
    this.mappings.put(MediaBox.fourcc(), MediaBox);
    this.mappings.put(MediaHeaderBox.fourcc(), MediaHeaderBox);
    this.mappings.put(MediaInfoBox.fourcc(), MediaInfoBox);
    this.mappings.put(HandlerBox.fourcc(), HandlerBox);
    this.mappings.put(DataInfoBox.fourcc(), DataInfoBox);
    this.mappings.put("stbl", NodeBox);
    this.mappings.put(SampleDescriptionBox.fourcc(), SampleDescriptionBox);
    this.mappings.put(TimeToSampleBox.fourcc(), TimeToSampleBox);
    this.mappings.put(SyncSamplesBox.STSS, SyncSamplesBox);
    this.mappings.put(PartialSyncSamplesBox.STPS, PartialSyncSamplesBox);
    this.mappings.put(SampleToChunkBox.fourcc(), SampleToChunkBox);
    this.mappings.put(SampleSizesBox.fourcc(), SampleSizesBox);
    this.mappings.put(ChunkOffsetsBox.fourcc(), ChunkOffsetsBox);
    this.mappings.put("keys", KeysBox);
    this.mappings.put(IListBox.fourcc(), IListBox);
    this.mappings.put("mvex", NodeBox);
    this.mappings.put("moof", NodeBox);
    this.mappings.put("traf", NodeBox);
    this.mappings.put("mfra", NodeBox);
    this.mappings.put("skip", NodeBox);
    this.mappings.put(MetaBox.fourcc(), MetaBox);
    this.mappings.put(DataRefBox.fourcc(), DataRefBox);
    this.mappings.put("ipro", NodeBox);
    this.mappings.put("sinf", NodeBox);
    this.mappings.put(ChunkOffsets64Box.fourcc(), ChunkOffsets64Box);
    this.mappings.put(SoundMediaHeaderBox.fourcc(), SoundMediaHeaderBox);
    this.mappings.put("clip", NodeBox);
    this.mappings.put(ClipRegionBox.fourcc(), ClipRegionBox);
    this.mappings.put(LoadSettingsBox.fourcc(), LoadSettingsBox);
    this.mappings.put("tapt", NodeBox);
    this.mappings.put("gmhd", NodeBox);
    this.mappings.put("tmcd", Box.LeafBox);
    this.mappings.put("tref", NodeBox);
    this.mappings.put(ClearApertureBox.CLEF, ClearApertureBox);
    this.mappings.put(ProductionApertureBox.PROF, ProductionApertureBox);
    this.mappings.put(EncodedPixelBox.ENOF, EncodedPixelBox);
    this.mappings.put(GenericMediaInfoBox.fourcc(), GenericMediaInfoBox);
    this.mappings.put(TimecodeMediaInfoBox.fourcc(), TimecodeMediaInfoBox);
    this.mappings.put(UdtaBox.fourcc(), UdtaBox);
    this.mappings.put(CompositionOffsetsBox.fourcc(), CompositionOffsetsBox);
    this.mappings.put(NameBox.fourcc(), NameBox);
    this.mappings.put("mdta", Box.LeafBox);
    this.mappings.put(MovieFragmentHeaderBox.fourcc(), MovieFragmentHeaderBox);
    this.mappings.put(TrackFragmentHeaderBox.fourcc(), TrackFragmentHeaderBox);
    this.mappings.put(MovieFragmentBox.fourcc(), MovieFragmentBox);
    this.mappings.put(TrackFragmentBox.fourcc(), TrackFragmentBox);
    this.mappings.put(TrackFragmentBaseMediaDecodeTimeBox.fourcc(), TrackFragmentBaseMediaDecodeTimeBox);
    this.mappings.put(TrunBox.fourcc(), TrunBox);
};
DefaultBoxes = stjs.extend(DefaultBoxes, Boxes, [], null, {mappings: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Specialized demuxer track for PCM audio samples
 *  
 *  Always reads one chunk of frames at a time, except for after seek. After seek
 *  the beginning of chunk before the seek point is not read effectivaly reading
 *  PCM frame from exactly the frame seek was performed to.
 *  
 *  Packet size depends on underlying container PCM chunk sizes.
 *  
 *  @author The JCodec project
 *  
 */
var PCMMP4DemuxerTrack = function(movie, trak, input) {
    AbstractMP4DemuxerTrack.call(this, trak);
    this.movie = movie;
    this.input = input;
    var stsz = NodeBox.findFirstPath(trak, SampleSizesBox, Box.path("mdia.minf.stbl.stsz"));
    this.defaultSampleSize = stsz.getDefaultSize();
    var chunks = 0;
    for (var i = 1; i < this.sampleToChunks.length; i++) {
        var ch = (((this.sampleToChunks[i].getFirst() - this.sampleToChunks[i - 1].getFirst())) | 0);
        this.totalFrames += ch * this.sampleToChunks[i - 1].getCount();
        chunks += ch;
    }
    this.totalFrames += this.sampleToChunks[this.sampleToChunks.length - 1].getCount() * (this.chunkOffsets.length - chunks);
};
PCMMP4DemuxerTrack = stjs.extend(PCMMP4DemuxerTrack, AbstractMP4DemuxerTrack, [], function(constructor, prototype) {
    prototype.defaultSampleSize = 0;
    prototype.posShift = 0;
    prototype.totalFrames = 0;
    prototype.input = null;
    prototype.movie = null;
    prototype.nextFrame = function() {
        var frameSize = this.getFrameSize();
        var chSize = this.sampleToChunks[this.stscInd].getCount() * frameSize - this.posShift;
        return this.getNextFrame(ByteBuffer.allocate(chSize));
    };
    prototype.getNextFrame = function(buffer) {
        if (this.stcoInd >= this.chunkOffsets.length) 
            return null;
        var frameSize = this.getFrameSize();
        var se = this.sampleToChunks[this.stscInd].getEntry();
        var chSize = this.sampleToChunks[this.stscInd].getCount() * frameSize;
        var pktOff = this.chunkOffsets[this.stcoInd] + this.posShift;
        var pktSize = chSize - this.posShift;
        var result = this.readPacketData(this.input, buffer, pktOff, pktSize);
        var ptsRem = this.pts;
        var doneFrames = stjs.trunc(pktSize / frameSize);
        this.shiftPts(doneFrames);
        var pkt = new MP4Packet(result, QTTimeUtil.mediaToEdited(this.box, ptsRem, this.movie.getTimescale()), this.timescale, (((this.pts - ptsRem)) | 0), this.curFrame, Packet.FrameType.KEY, null, 0, ptsRem, se - 1, pktOff, pktSize, true);
        this.curFrame += doneFrames;
        this.posShift = 0;
        ++this.stcoInd;
        if (this.stscInd < this.sampleToChunks.length - 1 && (this.stcoInd + 1) == this.sampleToChunks[this.stscInd + 1].getFirst()) 
            this.stscInd++;
        return pkt;
    };
    prototype.gotoSyncFrame = function(frameNo) {
        return this.gotoFrame(frameNo);
    };
    prototype.getFrameSize = function() {
        var entry = this.sampleEntries[this.sampleToChunks[this.stscInd].getEntry() - 1];
        if (stjs.isInstanceOf(entry.constructor, AudioSampleEntry) && this.defaultSampleSize == 0) {
            return (entry).calcFrameSize();
        } else {
            return this.defaultSampleSize;
        }
    };
    prototype.seekPointer = function(frameNo) {
        for (this.stcoInd = 0 , this.stscInd = 0 , this.curFrame = 0; ; ) {
            var nextFrame = this.curFrame + this.sampleToChunks[this.stscInd].getCount();
            if (nextFrame > frameNo) 
                break;
            this.curFrame = nextFrame;
            this.nextChunk();
        }
        this.posShift = ((((frameNo - this.curFrame) * this.getFrameSize())) | 0);
        this.curFrame = frameNo;
    };
    prototype.getFrameCount = function() {
        return this.totalFrames;
    };
    prototype.getMeta = function() {
        var ase = this.getSampleEntries()[0];
        var audioCodecMeta = AudioCodecMeta.fromAudioFormat(ase.getFormat());
        return new DemuxerTrackMeta(TrackType.AUDIO, Codec.codecByFourcc(this.getFourcc()), this.duration / this.timescale, null, this.totalFrames, null, null, audioCodecMeta);
    };
}, {input: "SeekableByteChannel", movie: "MovieBox", box: "TrakBox", type: "MP4TrackType", sampleEntries: "Array", timeToSamples: "Array", sampleToChunks: "Array", chunkOffsets: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Regular MP4 track containing frames
 *  
 *  @author The JCodec project
 *  
 */
var MP4DemuxerTrack = function(mov, trak, input) {
    AbstractMP4DemuxerTrack.call(this, trak);
    this.input = input;
    this.movie = mov;
    var stsz = NodeBox.findFirstPath(trak, SampleSizesBox, Box.path("mdia.minf.stbl.stsz"));
    var stss = NodeBox.findFirstPath(trak, SyncSamplesBox, Box.path("mdia.minf.stbl.stss"));
    var stps = NodeBox.findFirstPath(trak, SyncSamplesBox, Box.path("mdia.minf.stbl.stps"));
    var ctts = NodeBox.findFirstPath(trak, CompositionOffsetsBox, Box.path("mdia.minf.stbl.ctts"));
    this.compOffsets = ctts == null ? null : ctts.getEntries();
    if (stss != null) {
        this.syncSamples = stss.getSyncSamples();
    }
    if (stps != null) {
        this.partialSync = stps.getSyncSamples();
    }
    this.sizes = stsz.getSizes();
};
MP4DemuxerTrack = stjs.extend(MP4DemuxerTrack, AbstractMP4DemuxerTrack, [], function(constructor, prototype) {
    prototype.sizes = null;
    prototype.offInChunk = 0;
    prototype.noInChunk = 0;
    prototype.syncSamples = null;
    prototype.partialSync = null;
    prototype.ssOff = 0;
    prototype.psOff = 0;
    prototype.compOffsets = null;
    prototype.cttsInd = 0;
    prototype.cttsSubInd = 0;
    prototype.input = null;
    prototype.movie = null;
    prototype.nextFrame = function() {
        if (this.curFrame >= this.sizes.length) 
            return null;
        var size = this.sizes[((this.curFrame) | 0)];
        return this.getNextFrame(ByteBuffer.allocate(size));
    };
    prototype.getNextFrame = function(storage) {
        if (this.curFrame >= this.sizes.length) 
            return null;
        var size = this.sizes[((this.curFrame) | 0)];
        if (storage != null && storage.remaining() < size) {
             throw new IllegalArgumentException("Buffer size is not enough to fit a packet");
        }
        var pktPos = this.chunkOffsets[Math.min(this.chunkOffsets.length - 1, this.stcoInd)] + this.offInChunk;
        var result = this.readPacketData(this.input, storage, pktPos, size);
        if (result != null && result.remaining() < size) 
            return null;
        var duration = this.timeToSamples[this.sttsInd].getSampleDuration();
        var sync = this.syncSamples == null;
        if (this.syncSamples != null && this.ssOff < this.syncSamples.length && (this.curFrame + 1) == this.syncSamples[this.ssOff]) {
            sync = true;
            this.ssOff++;
        }
        var psync = false;
        if (this.partialSync != null && this.psOff < this.partialSync.length && (this.curFrame + 1) == this.partialSync[this.psOff]) {
            psync = true;
            this.psOff++;
        }
        var realPts = this.pts;
        if (this.compOffsets != null) {
            realPts = this.pts + this.compOffsets[this.cttsInd].getOffset();
            this.cttsSubInd++;
            if (this.cttsInd < this.compOffsets.length - 1 && this.cttsSubInd == this.compOffsets[this.cttsInd].getCount()) {
                this.cttsInd++;
                this.cttsSubInd = 0;
            }
        }
        var data = result == null ? null : this.convertPacket(result);
        var _pts = QTTimeUtil.mediaToEdited(this.box, realPts, this.movie.getTimescale());
        var ftype = sync ? Packet.FrameType.KEY : Packet.FrameType.INTER;
        var entryNo = this.sampleToChunks[this.stscInd].getEntry() - 1;
        var pkt = new MP4Packet(data, _pts, this.timescale, duration, this.curFrame, ftype, null, 0, realPts, entryNo, pktPos, size, psync);
        this.offInChunk += size;
        this.curFrame++;
        this.noInChunk++;
        if (this.noInChunk >= this.sampleToChunks[this.stscInd].getCount()) {
            this.noInChunk = 0;
            this.offInChunk = 0;
            this.nextChunk();
        }
        this.shiftPts(1);
        return pkt;
    };
    prototype.gotoSyncFrame = function(frameNo) {
        if (this.syncSamples == null) 
            return this.gotoFrame(frameNo);
        if (frameNo < 0) 
             throw new IllegalArgumentException("negative frame number");
        if (frameNo >= this.getFrameCount()) 
            return false;
        if (frameNo == this.curFrame) 
            return true;
        for (var i = 0; i < this.syncSamples.length; i++) {
            if (this.syncSamples[i] - 1 > frameNo) 
                return this.gotoFrame(this.syncSamples[i - 1] - 1);
        }
        return this.gotoFrame(this.syncSamples[this.syncSamples.length - 1] - 1);
    };
    prototype.seekPointer = function(frameNo) {
        if (this.compOffsets != null) {
            this.cttsSubInd = ((frameNo) | 0);
            this.cttsInd = 0;
             while (this.cttsSubInd >= this.compOffsets[this.cttsInd].getCount()){
                this.cttsSubInd -= this.compOffsets[this.cttsInd].getCount();
                this.cttsInd++;
            }
        }
        this.curFrame = ((frameNo) | 0);
        this.stcoInd = 0;
        this.stscInd = 0;
        this.noInChunk = ((frameNo) | 0);
        this.offInChunk = 0;
         while (this.noInChunk >= this.sampleToChunks[this.stscInd].getCount()){
            this.noInChunk -= this.sampleToChunks[this.stscInd].getCount();
            this.nextChunk();
        }
        for (var i = 0; i < this.noInChunk; i++) {
            this.offInChunk += this.sizes[((frameNo) | 0) - this.noInChunk + i];
        }
        if (this.syncSamples != null) 
            for (this.ssOff = 0; this.ssOff < this.syncSamples.length && this.syncSamples[this.ssOff] < this.curFrame + 1; this.ssOff++) 
                ;
        if (this.partialSync != null) 
            for (this.psOff = 0; this.psOff < this.partialSync.length && this.partialSync[this.psOff] < this.curFrame + 1; this.psOff++) 
                ;
    };
    prototype.getFrameCount = function() {
        return this.sizes.length;
    };
}, {sizes: "Int32Array", syncSamples: "Int32Array", partialSync: "Int32Array", compOffsets: "Array", input: "SeekableByteChannel", movie: "MovieBox", box: "TrakBox", type: "MP4TrackType", sampleEntries: "Array", timeToSamples: "Array", sampleToChunks: "Array", chunkOffsets: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Encodes macroblock as P16x16
 *  
 *  @author Stanislav Vitvitskyy
 */
var MBEncoderP16x16 = function(sps, ref, cavlc, me) {
    this.sps = sps;
    this.cavlc = cavlc;
    this.ref = ref;
    this.me = me;
    this.mvTopX = new Int32Array(sps.picWidthInMbsMinus1 + 1);
    this.mvTopY = new Int32Array(sps.picWidthInMbsMinus1 + 1);
    this.mvTopXSave = new Int32Array(sps.picWidthInMbsMinus1 + 1);
    this.mvTopYSave = new Int32Array(sps.picWidthInMbsMinus1 + 1);
    this.interpolator = new BlockInterpolator();
};
MBEncoderP16x16 = stjs.extend(MBEncoderP16x16, null, [SaveRestore], function(constructor, prototype) {
    prototype.cavlc = null;
    prototype.sps = null;
    prototype.ref = null;
    prototype.me = null;
    prototype.mvTopX = null;
    prototype.mvTopY = null;
    prototype.mvLeftX = 0;
    prototype.mvLeftY = 0;
    prototype.mvTopLeftX = 0;
    prototype.mvTopLeftY = 0;
    prototype.mvTopXSave = null;
    prototype.mvTopYSave = null;
    prototype.mvLeftXSave = 0;
    prototype.mvLeftYSave = 0;
    prototype.mvTopLeftXSave = 0;
    prototype.mvTopLeftYSave = 0;
    prototype.interpolator = null;
    prototype.save = function() {
        for (var i = 0; i < this.cavlc.length; i++) 
            this.cavlc[i].save();
        System.arraycopy(this.mvTopX, 0, this.mvTopXSave, 0, this.mvTopX.length);
        System.arraycopy(this.mvTopY, 0, this.mvTopYSave, 0, this.mvTopY.length);
        this.mvLeftXSave = this.mvLeftX;
        this.mvLeftYSave = this.mvLeftY;
        this.mvTopLeftXSave = this.mvTopLeftX;
        this.mvTopLeftYSave = this.mvTopLeftY;
    };
    prototype.restore = function() {
        for (var i = 0; i < this.cavlc.length; i++) 
            this.cavlc[i].restore();
        var tmp = this.mvTopX;
        this.mvTopX = this.mvTopXSave;
        this.mvTopXSave = tmp;
        tmp = this.mvTopY;
        this.mvTopY = this.mvTopYSave;
        this.mvTopYSave = tmp;
        this.mvLeftX = this.mvLeftXSave;
        this.mvLeftY = this.mvLeftYSave;
        this.mvTopLeftX = this.mvTopLeftXSave;
        this.mvTopLeftY = this.mvTopLeftYSave;
    };
    prototype.encodeMacroblock = function(pic, mbX, mbY, out, outMB, leftOutMB, topOutMB, qp, qpDelta) {
        if (this.sps.numRefFrames > 1) {
            var refIdx = this.decideRef();
            CAVLCWriter.writeTE(out, refIdx, this.sps.numRefFrames - 1);
        }
        var trAvb = mbY > 0 && mbX < this.sps.picWidthInMbsMinus1;
        var tlAvb = mbX > 0 && mbY > 0;
        var mvpx = this.median(this.mvLeftX, this.mvTopX[mbX], trAvb ? this.mvTopX[mbX + 1] : 0, tlAvb ? this.mvTopLeftX : 0, mbX > 0, mbY > 0, trAvb, tlAvb);
        var mvpy = this.median(this.mvLeftY, this.mvTopY[mbX], trAvb ? this.mvTopY[mbX + 1] : 0, tlAvb ? this.mvTopLeftY : 0, mbX > 0, mbY > 0, trAvb, tlAvb);
        var mv = this.mvEstimate(pic, mbX, mbY, mvpx, mvpy);
        this.mvTopLeftX = this.mvTopX[mbX];
        this.mvTopLeftY = this.mvTopY[mbX];
        this.mvTopX[mbX] = mv[0];
        this.mvTopY[mbX] = mv[1];
        this.mvLeftX = mv[0];
        this.mvLeftY = mv[1];
        CAVLCWriter.writeSE(out, mv[0] - mvpx);
        CAVLCWriter.writeSE(out, mv[1] - mvpy);
        var mbRef = Picture.create(16, 16, this.sps.chromaFormatIdc);
        var mb = [new Int32Array(256), new Int32Array(64), new Int32Array(64)];
        this.interpolator.getBlockLuma(this.ref, mbRef, 0, (mbX << 6) + mv[0], (mbY << 6) + mv[1], 16, 16);
        BlockInterpolator.getBlockChroma(this.ref.getPlaneData(1), this.ref.getPlaneWidth(1), this.ref.getPlaneHeight(1), mbRef.getPlaneData(1), 0, mbRef.getPlaneWidth(1), (mbX << 6) + mv[0], (mbY << 6) + mv[1], 8, 8);
        BlockInterpolator.getBlockChroma(this.ref.getPlaneData(2), this.ref.getPlaneWidth(2), this.ref.getPlaneHeight(2), mbRef.getPlaneData(2), 0, mbRef.getPlaneWidth(2), (mbX << 6) + mv[0], (mbY << 6) + mv[1], 8, 8);
        MBEncoderHelper.takeSubtract(pic.getPlaneData(0), pic.getPlaneWidth(0), pic.getPlaneHeight(0), mbX << 4, mbY << 4, mb[0], mbRef.getPlaneData(0), 16, 16);
        MBEncoderHelper.takeSubtract(pic.getPlaneData(1), pic.getPlaneWidth(1), pic.getPlaneHeight(1), mbX << 3, mbY << 3, mb[1], mbRef.getPlaneData(1), 8, 8);
        MBEncoderHelper.takeSubtract(pic.getPlaneData(2), pic.getPlaneWidth(2), pic.getPlaneHeight(2), mbX << 3, mbY << 3, mb[2], mbRef.getPlaneData(2), 8, 8);
        var codedBlockPattern = this.getCodedBlockPattern();
        CAVLCWriter.writeUE(out, H264Const.CODED_BLOCK_PATTERN_INTER_COLOR_INV[codedBlockPattern]);
        CAVLCWriter.writeSE(out, qpDelta);
        this.luma(pic, mb[0], mbX, mbY, out, qp, outMB.getNc());
        this.chroma(pic, mb[1], mb[2], mbX, mbY, out, qp);
        MBEncoderHelper.putBlk(outMB.getPixels().getPlaneData(0), mb[0], mbRef.getPlaneData(0), 4, 0, 0, 16, 16);
        MBEncoderHelper.putBlk(outMB.getPixels().getPlaneData(1), mb[1], mbRef.getPlaneData(1), 3, 0, 0, 8, 8);
        MBEncoderHelper.putBlk(outMB.getPixels().getPlaneData(2), mb[2], mbRef.getPlaneData(2), 3, 0, 0, 8, 8);
        Arrays.fill(outMB.getMx(), mv[0]);
        Arrays.fill(outMB.getMy(), mv[1]);
        outMB.setType(MBType.P_16x16);
        outMB.setQp(qp);
        new MBDeblocker().deblockMBP(outMB, leftOutMB, topOutMB);
    };
    prototype.median = function(a, b, c, d, aAvb, bAvb, cAvb, dAvb) {
        if (!cAvb) {
            c = d;
            cAvb = dAvb;
        }
        if (aAvb && !bAvb && !cAvb) {
            b = c = a;
            bAvb = cAvb = aAvb;
        }
        a = aAvb ? a : 0;
        b = bAvb ? b : 0;
        c = cAvb ? c : 0;
        return a + b + c - Math.min(Math.min(a, b), c) - Math.max(Math.max(a, b), c);
    };
    prototype.getCodedBlockPattern = function() {
        return 47;
    };
    prototype.mvEstimate = function(pic, mbX, mbY, mvpx, mvpy) {
        var patch = new Int8Array(256);
        MBEncoderHelper.take(pic.getPlaneData(0), pic.getPlaneWidth(0), pic.getPlaneHeight(0), mbX << 4, mbY << 4, patch, 16, 16);
        return this.me.estimate(this.ref, patch, mbX, mbY, mvpx, mvpy);
    };
    /**
     *  Decides which reference to use
     *  
     *  @return
     */
    prototype.decideRef = function() {
        return 0;
    };
    prototype.luma = function(pic, pix, mbX, mbY, out, qp, nc) {
        var ac = Array.apply(null, Array(16)).map(function() {
            return new Int32Array(16);
        });
        for (var i = 0; i < ac.length; i++) {
            for (var j = 0; j < H264Const.PIX_MAP_SPLIT_4x4[i].length; j++) {
                ac[i][j] = pix[H264Const.PIX_MAP_SPLIT_4x4[i][j]];
            }
            CoeffTransformer.fdct4x4(ac[i]);
        }
        this.writeAC(0, mbX, mbY, out, mbX << 2, mbY << 2, ac, qp);
        for (var i = 0; i < ac.length; i++) {
            CoeffTransformer.dequantizeAC(ac[i], qp, null);
            CoeffTransformer.idct4x4(ac[i]);
            for (var j = 0; j < H264Const.PIX_MAP_SPLIT_4x4[i].length; j++) 
                pix[H264Const.PIX_MAP_SPLIT_4x4[i][j]] = ac[i][j];
        }
    };
    prototype.chroma = function(pic, pix1, pix2, mbX, mbY, out, qp) {
        var ac1 = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(16);
        });
        var ac2 = Array.apply(null, Array(4)).map(function() {
            return new Int32Array(16);
        });
        for (var i = 0; i < ac1.length; i++) {
            for (var j = 0; j < H264Const.PIX_MAP_SPLIT_2x2[i].length; j++) 
                ac1[i][j] = pix1[H264Const.PIX_MAP_SPLIT_2x2[i][j]];
        }
        for (var i = 0; i < ac2.length; i++) {
            for (var j = 0; j < H264Const.PIX_MAP_SPLIT_2x2[i].length; j++) 
                ac2[i][j] = pix2[H264Const.PIX_MAP_SPLIT_2x2[i][j]];
        }
        MBEncoderI16x16.chromaResidual(pic, mbX, mbY, out, qp, ac1, ac2, this.cavlc[1], this.cavlc[2], MBType.P_16x16, MBType.P_16x16);
        for (var i = 0; i < ac1.length; i++) {
            for (var j = 0; j < H264Const.PIX_MAP_SPLIT_2x2[i].length; j++) 
                pix1[H264Const.PIX_MAP_SPLIT_2x2[i][j]] = ac1[i][j];
        }
        for (var i = 0; i < ac2.length; i++) {
            for (var j = 0; j < H264Const.PIX_MAP_SPLIT_2x2[i].length; j++) 
                pix2[H264Const.PIX_MAP_SPLIT_2x2[i][j]] = ac2[i][j];
        }
    };
    prototype.writeAC = function(comp, mbX, mbY, out, mbLeftBlk, mbTopBlk, ac, qp) {
        for (var i = 0; i < ac.length; i++) {
            var blkI = H264Const.BLK_INV_MAP[i];
            CoeffTransformer.quantizeAC(ac[blkI], qp);
            this.cavlc[comp].writeACBlock(out, mbLeftBlk + H264Const.MB_BLK_OFF_LEFT[i], mbTopBlk + H264Const.MB_BLK_OFF_TOP[i], MBType.P_16x16, MBType.P_16x16, ac[blkI], H264Const.totalZeros16, 0, 16, CoeffTransformer.zigzag4x4);
        }
    };
}, {cavlc: "Array", sps: "SeqParameterSet", ref: "Picture", me: "MotionEstimator", mvTopX: "Int32Array", mvTopY: "Int32Array", mvTopXSave: "Int32Array", mvTopYSave: "Int32Array", interpolator: "BlockInterpolator"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 4 AVC ( H.264 ) Decoder
 *  
 *  Conforms to H.264 ( ISO/IEC 14496-10 ) specifications
 *  
 *  @author The JCodec project
 *  
 */
var H264Decoder = function() {
    VideoDecoder.call(this);
    this.pictureBuffer = new ArrayList();
    this.poc = new POCManager();
    this.threaded = Runtime.getRuntime().availableProcessors() > 1;
    if (this.threaded) {
        this.tp = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), new (stjs.extend(function H264Decoder$1() {}, null, [ThreadFactory], function(constructor, prototype) {
            prototype.newThread = function(r) {
                var t = Executors.defaultThreadFactory().newThread(r);
                t.setDaemon(true);
                return t;
            };
        }, {}, {}))());
    }
    this.reader = new FrameReader();
};
H264Decoder = stjs.extend(H264Decoder, VideoDecoder, [], function(constructor, prototype) {
    prototype.sRefs = null;
    prototype.lRefs = null;
    prototype.pictureBuffer = null;
    prototype.poc = null;
    prototype.reader = null;
    prototype.tp = null;
    prototype.threaded = false;
    /**
     *  Constructs this decoder from a portion of a stream that contains AnnexB
     *  delimited (00 00 00 01) SPS/PPS NAL units. SPS/PPS NAL units are 0x67 and
     *  0x68 respectfully.
     *  
     *  @param codecPrivate
     */
    constructor.createH264DecoderFromCodecPrivate = function(codecPrivate) {
        var d = new H264Decoder();
        for (var iterator$bb = H264Utils.splitFrame(codecPrivate.duplicate()).iterator(); iterator$bb.hasNext(); ) {
            var bb = iterator$bb.next();
            var nu = NALUnit.read(bb);
            if (nu.type == NALUnitType.SPS) {
                d.reader.addSps(bb);
            } else if (nu.type == NALUnitType.PPS) {
                d.reader.addPps(bb);
            }
        }
        return d;
    };
    prototype.decodeFrame = function(data, buffer) {
        return this.decodeFrameFromNals(H264Utils.splitFrame(data), buffer);
    };
    prototype.decodeFrameFromNals = function(nalUnits, buffer) {
        return new H264Decoder.FrameDecoder(this).decodeFrame(nalUnits, buffer);
    };
    constructor.SliceDecoderRunnable = function(fdec, sliceReader, result) {
        this.fdec = fdec;
        this.sliceReader = sliceReader;
        this.result = result;
    };
    constructor.SliceDecoderRunnable = stjs.extend(constructor.SliceDecoderRunnable, null, [Runnable], function(constructor, prototype) {
        prototype.sliceReader = null;
        prototype.result = null;
        prototype.fdec = null;
        prototype.run = function() {
            new SliceDecoder(this.fdec.activeSps, this.fdec.dec.sRefs, this.fdec.dec.lRefs, this.fdec.di, this.result).decodeFromReader(this.sliceReader);
        };
    }, {sliceReader: "SliceReader", result: "Frame", fdec: "H264Decoder.FrameDecoder"}, {});
    constructor.FrameDecoder = function(decoder) {
        this.dec = decoder;
    };
    constructor.FrameDecoder = stjs.extend(constructor.FrameDecoder, null, [], function(constructor, prototype) {
        prototype.activeSps = null;
        prototype.filter = null;
        prototype.firstSliceHeader = null;
        prototype.firstNu = null;
        prototype.dec = null;
        prototype.di = null;
        prototype.decodeFrame = function(nalUnits, buffer) {
            var sliceReaders = this.dec.reader.readFrame(nalUnits);
            if (sliceReaders == null || sliceReaders.size() == 0) 
                return null;
            var result = this.init(sliceReaders.get(0), buffer);
            if (this.dec.threaded && sliceReaders.size() > 1) {
                var futures = new ArrayList();
                for (var iterator$sliceReader = sliceReaders.iterator(); iterator$sliceReader.hasNext(); ) {
                    var sliceReader = iterator$sliceReader.next();
                    futures.add(this.dec.tp.submit(new H264Decoder.SliceDecoderRunnable(this, sliceReader, result)));
                }
                for (var iterator$future = futures.iterator(); iterator$future.hasNext(); ) {
                    var future = iterator$future.next();
                    this.waitForSure(future);
                }
            } else {
                for (var iterator$sliceReader = sliceReaders.iterator(); iterator$sliceReader.hasNext(); ) {
                    var sliceReader = iterator$sliceReader.next();
                    new SliceDecoder(this.activeSps, this.dec.sRefs, this.dec.lRefs, this.di, result).decodeFromReader(sliceReader);
                }
            }
            this.filter.deblockFrame(result);
            this.updateReferences(result);
            return result;
        };
        prototype.waitForSure = function(future) {
             while (true){
                try {
                    future.get();
                    break;
                }catch (e) {
                     throw new RuntimeException(e);
                }
            }
        };
        prototype.updateReferences = function(picture) {
            if (this.firstNu.nal_ref_idc != 0) {
                if (this.firstNu.type == NALUnitType.IDR_SLICE) {
                    this.performIDRMarking(this.firstSliceHeader.refPicMarkingIDR, picture);
                } else {
                    this.performMarking(this.firstSliceHeader.refPicMarkingNonIDR, picture);
                }
            }
        };
        prototype.init = function(sliceReader, buffer) {
            this.firstNu = sliceReader.getNALUnit();
            this.firstSliceHeader = sliceReader.getSliceHeader();
            this.activeSps = this.firstSliceHeader.sps;
            this.validateSupportedFeatures(this.firstSliceHeader.sps, this.firstSliceHeader.pps);
            var picWidthInMbs = this.activeSps.picWidthInMbsMinus1 + 1;
            if (this.dec.sRefs == null) {
                this.dec.sRefs = Array(1 << (this.firstSliceHeader.sps.log2MaxFrameNumMinus4 + 4));
                this.dec.lRefs = new IntObjectMap();
            }
            this.di = new DeblockerInput(this.activeSps);
            var result = H264Decoder.createFrame(this.activeSps, buffer, this.firstSliceHeader.frameNum, this.firstSliceHeader.sliceType, this.di.mvs, this.di.refsUsed, this.dec.poc.calcPOC(this.firstSliceHeader, this.firstNu));
            this.filter = new DeblockingFilter(picWidthInMbs, this.activeSps.bitDepthChromaMinus8 + 8, this.di);
            return result;
        };
        prototype.validateSupportedFeatures = function(sps, pps) {
            if (sps.mbAdaptiveFrameFieldFlag) 
                 throw new RuntimeException("Unsupported h264 feature: MBAFF.");
            if (sps.bitDepthLumaMinus8 != 0 || sps.bitDepthChromaMinus8 != 0) 
                 throw new RuntimeException("Unsupported h264 feature: High bit depth.");
            if (sps.chromaFormatIdc != ColorSpace.YUV420J) 
                 throw new RuntimeException("Unsupported h264 feature: " + sps.chromaFormatIdc + " color.");
            if (!sps.frameMbsOnlyFlag || sps.fieldPicFlag) 
                 throw new RuntimeException("Unsupported h264 feature: interlace.");
            if (pps.constrainedIntraPredFlag) 
                 throw new RuntimeException("Unsupported h264 feature: constrained intra prediction.");
            if (sps.qpprimeYZeroTransformBypassFlag) 
                 throw new RuntimeException("Unsupported h264 feature: qprime zero transform bypass.");
            if (sps.profileIdc != H264Const.PROFILE_BASELINE && sps.profileIdc != H264Const.PROFILE_MAIN && sps.profileIdc != H264Const.PROFILE_HIGH) 
                 throw new RuntimeException("Unsupported h264 feature: " + sps.profileIdc + " profile.");
        };
        prototype.performIDRMarking = function(refPicMarkingIDR, picture) {
            this.clearAll();
            this.dec.pictureBuffer.clear();
            var saved = this.saveRef(picture);
            if (refPicMarkingIDR.isUseForlongTerm()) {
                this.dec.lRefs.put(0, saved);
                saved.setShortTerm(false);
            } else 
                this.dec.sRefs[this.firstSliceHeader.frameNum] = saved;
        };
        prototype.saveRef = function(decoded) {
            var frame = this.dec.pictureBuffer.size() > 0 ? this.dec.pictureBuffer.remove(0) : Frame.createFrame(decoded);
            frame.copyFromFrame(decoded);
            return frame;
        };
        prototype.releaseRef = function(picture) {
            if (picture != null) {
                this.dec.pictureBuffer.add(picture);
            }
        };
        prototype.clearAll = function() {
            for (var i = 0; i < this.dec.sRefs.length; i++) {
                this.releaseRef(this.dec.sRefs[i]);
                this.dec.sRefs[i] = null;
            }
            var keys = this.dec.lRefs.keys();
            for (var i = 0; i < keys.length; i++) {
                this.releaseRef(this.dec.lRefs.get(keys[i]));
            }
            this.dec.lRefs.clear();
        };
        prototype.performMarking = function(refPicMarking, picture) {
            var saved = this.saveRef(picture);
            if (refPicMarking != null) {
                var instructions = refPicMarking.getInstructions();
                for (var i = 0; i < instructions.length; i++) {
                    var instr = instructions[i];
                    switch (instr.getType()) {
                        case RefPicMarking.InstrType.REMOVE_SHORT:
                            this.unrefShortTerm(instr.getArg1());
                            break;
                        case RefPicMarking.InstrType.REMOVE_LONG:
                            this.unrefLongTerm(instr.getArg1());
                            break;
                        case RefPicMarking.InstrType.CONVERT_INTO_LONG:
                            this.convert(instr.getArg1(), instr.getArg2());
                            break;
                        case RefPicMarking.InstrType.TRUNK_LONG:
                            this.truncateLongTerm(instr.getArg1() - 1);
                            break;
                        case RefPicMarking.InstrType.CLEAR:
                            this.clearAll();
                            break;
                        case RefPicMarking.InstrType.MARK_LONG:
                            this.saveLong(saved, instr.getArg1());
                            saved = null;
                    }
                }
            }
            if (saved != null) 
                this.saveShort(saved);
            var maxFrames = 1 << (this.activeSps.log2MaxFrameNumMinus4 + 4);
            if (refPicMarking == null) {
                var maxShort = Math.max(1, this.activeSps.numRefFrames - this.dec.lRefs.size());
                var min = Integer.MAX_VALUE, num = 0, minFn = 0;
                for (var i = 0; i < this.dec.sRefs.length; i++) {
                    if (this.dec.sRefs[i] != null) {
                        var fnWrap = this.unwrap(this.firstSliceHeader.frameNum, this.dec.sRefs[i].getFrameNo(), maxFrames);
                        if (fnWrap < min) {
                            min = fnWrap;
                            minFn = this.dec.sRefs[i].getFrameNo();
                        }
                        num++;
                    }
                }
                if (num > maxShort) {
                    this.releaseRef(this.dec.sRefs[minFn]);
                    this.dec.sRefs[minFn] = null;
                }
            }
        };
        prototype.unwrap = function(thisFrameNo, refFrameNo, maxFrames) {
            return refFrameNo > thisFrameNo ? refFrameNo - maxFrames : refFrameNo;
        };
        prototype.saveShort = function(saved) {
            this.dec.sRefs[this.firstSliceHeader.frameNum] = saved;
        };
        prototype.saveLong = function(saved, longNo) {
            var prev = this.dec.lRefs.get(longNo);
            if (prev != null) 
                this.releaseRef(prev);
            saved.setShortTerm(false);
            this.dec.lRefs.put(longNo, saved);
        };
        prototype.truncateLongTerm = function(maxLongNo) {
            var keys = this.dec.lRefs.keys();
            for (var i = 0; i < keys.length; i++) {
                if (keys[i] > maxLongNo) {
                    this.releaseRef(this.dec.lRefs.get(keys[i]));
                    this.dec.lRefs.remove(keys[i]);
                }
            }
        };
        prototype.convert = function(shortNo, longNo) {
            var ind = MathUtil.wrap(this.firstSliceHeader.frameNum - shortNo, 1 << (this.firstSliceHeader.sps.log2MaxFrameNumMinus4 + 4));
            this.releaseRef(this.dec.lRefs.get(longNo));
            this.dec.lRefs.put(longNo, this.dec.sRefs[ind]);
            this.dec.sRefs[ind] = null;
            this.dec.lRefs.get(longNo).setShortTerm(false);
        };
        prototype.unrefLongTerm = function(longNo) {
            this.releaseRef(this.dec.lRefs.get(longNo));
            this.dec.lRefs.remove(longNo);
        };
        prototype.unrefShortTerm = function(shortNo) {
            var ind = MathUtil.wrap(this.firstSliceHeader.frameNum - shortNo, 1 << (this.firstSliceHeader.sps.log2MaxFrameNumMinus4 + 4));
            this.releaseRef(this.dec.sRefs[ind]);
            this.dec.sRefs[ind] = null;
        };
    }, {activeSps: "SeqParameterSet", filter: "DeblockingFilter", firstSliceHeader: "SliceHeader", firstNu: "NALUnit", dec: "H264Decoder", di: "DeblockerInput"}, {});
    constructor.createFrame = function(sps, buffer, frameNum, frameType, mvs, refsUsed, POC) {
        var width = sps.picWidthInMbsMinus1 + 1 << 4;
        var height = SeqParameterSet.getPicHeightInMbs(sps) << 4;
        var crop = null;
        if (sps.frameCroppingFlag) {
            var sX = sps.frameCropLeftOffset << 1;
            var sY = sps.frameCropTopOffset << 1;
            var w = width - (sps.frameCropRightOffset << 1) - sX;
            var h = height - (sps.frameCropBottomOffset << 1) - sY;
            crop = new Rect(sX, sY, w, h);
        }
        return new Frame(width, height, buffer, ColorSpace.YUV420, crop, frameNum, frameType, mvs, refsUsed, POC);
    };
    prototype.addSps = function(spsList) {
        this.reader.addSpsList(spsList);
    };
    prototype.addPps = function(ppsList) {
        this.reader.addPpsList(ppsList);
    };
    constructor.probe = function(data) {
        var validSps = false, validPps = false, validSh = false;
        for (var iterator$nalUnit = H264Utils.splitFrame(data.duplicate()).iterator(); iterator$nalUnit.hasNext(); ) {
            var nalUnit = iterator$nalUnit.next();
            var marker = NALUnit.read(nalUnit);
            if (marker.type == NALUnitType.IDR_SLICE || marker.type == NALUnitType.NON_IDR_SLICE) {
                var reader = BitReader.createBitReader(nalUnit);
                validSh = H264Decoder.validSh(SliceHeaderReader.readPart1(reader));
                break;
            } else if (marker.type == NALUnitType.SPS) {
                validSps = H264Decoder.validSps(SeqParameterSet.read(nalUnit));
            } else if (marker.type == NALUnitType.PPS) {
                validPps = H264Decoder.validPps(PictureParameterSet.read(nalUnit));
            }
        }
        return (validSh ? 60 : 0) + (validSps ? 20 : 0) + (validPps ? 20 : 0);
    };
    constructor.validSh = function(sh) {
        return sh.firstMbInSlice == 0 && sh.sliceType != null && sh.picParameterSetId < 2;
    };
    constructor.validSps = function(sps) {
        return sps.bitDepthChromaMinus8 < 4 && sps.bitDepthLumaMinus8 < 4 && sps.chromaFormatIdc != null && sps.seqParameterSetId < 2 && sps.picOrderCntType <= 2;
    };
    constructor.validPps = function(pps) {
        return pps.picInitQpMinus26 <= 26 && pps.seqParameterSetId <= 2 && pps.picParameterSetId <= 2;
    };
    prototype.getCodecMeta = function(data) {
        var rawSPS = H264Utils.getRawSPS(data.duplicate());
        var rawPPS = H264Utils.getRawPPS(data.duplicate());
        if (rawSPS.size() == 0) {
            Logger.warn("Can not extract metadata from the packet not containing an SPS.");
            return null;
        }
        var sps = SeqParameterSet.read(rawSPS.get(0));
        var size = H264Utils.getPicSize(sps);
        return VideoCodecMeta.createSimpleVideoCodecMeta(size, ColorSpace.YUV420);
    };
}, {sRefs: "Array", lRefs: {name: "IntObjectMap", arguments: ["Frame"]}, pictureBuffer: {name: "List", arguments: ["Frame"]}, poc: "POCManager", reader: "FrameReader", tp: "ExecutorService", byteBuffer: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Wraps around the JAAD decoder and implements an AudioDecoder interface.
 *  
 *  @author Stanislav Vitvitskyy
 */
var AACDecoder = function(decoderSpecific) {
    if (decoderSpecific.remaining() >= 7) {
        var header = ADTSParser.read(decoderSpecific);
        if (header != null) {
            decoderSpecific = ADTSParser.adtsToStreamInfo(header);
        }
        Logger.info("Creating AAC decoder from ADTS header.");
    }
    this.decoder = new Decoder(NIOUtils.toArray(decoderSpecific));
};
AACDecoder = stjs.extend(AACDecoder, null, [AudioDecoder], function(constructor, prototype) {
    prototype.decoder = null;
    prototype.decodeFrame = function(frame, dst) {
        ADTSParser.read(frame);
        var sampleBuffer = new SampleBuffer();
        this.decoder.decodeFrame(NIOUtils.toArray(frame), sampleBuffer);
        if (sampleBuffer.isBigEndian()) {
            sampleBuffer.setBigEndian(false);
        }
        return new AudioBuffer(ByteBuffer.wrap(sampleBuffer.getData()), this.toAudioFormat(sampleBuffer), 0);
    };
    prototype.toAudioFormat = function(sampleBuffer) {
        return new AudioFormat(sampleBuffer.getSampleRate(), sampleBuffer.getBitsPerSample(), sampleBuffer.getChannels(), true, sampleBuffer.isBigEndian());
    };
    prototype.getCodecMeta = function(data) {
        var sampleBuffer = new SampleBuffer();
        this.decoder.decodeFrame(NIOUtils.toArray(data), sampleBuffer);
        sampleBuffer.setBigEndian(false);
        return AudioCodecMeta.fromAudioFormat(this.toAudioFormat(sampleBuffer));
    };
    constructor.probe = function(data) {
        if (data.remaining() < 7) 
            return 0;
        var header = ADTSParser.read(data);
        if (header != null) 
            return 100;
        return 0;
    };
}, {decoder: "Decoder"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Timecode MP4 muxer track
 *  
 *  @author The JCodec project
 *  
 */
var TimecodeMP4MuxerTrack = function(trackId) {
    CodecMP4MuxerTrack.call(this, trackId, MP4TrackType.TIMECODE, Codec.TIMECODE);
    this.lower = new ArrayList();
    this.gop = new ArrayList();
};
TimecodeMP4MuxerTrack = stjs.extend(TimecodeMP4MuxerTrack, CodecMP4MuxerTrack, [], function(constructor, prototype) {
    prototype.prevTimecode = null;
    prototype.firstTimecode = null;
    prototype.fpsEstimate = 0;
    prototype.sampleDuration = 0;
    prototype.samplePts = 0;
    prototype.tcFrames = 0;
    prototype.lower = null;
    prototype.gop = null;
    prototype.addTimecode = function(packet) {
        if (this._timescale == AbstractMP4MuxerTrack.NO_TIMESCALE_SET) 
            this._timescale = packet.getTimescale();
        if (this._timescale != AbstractMP4MuxerTrack.NO_TIMESCALE_SET && this._timescale != packet.getTimescale()) 
             throw new RuntimeException("MP4 timecode track doesn't support timescale switching.");
        if (packet.isKeyFrame()) 
            this.processGop();
        this.gop.add(Packet.createPacketWithData(packet, null));
    };
    prototype.processGop = function() {
        if (this.gop.size() > 0) {
            for (var iterator$pkt = this.sortByDisplay(this.gop).iterator(); iterator$pkt.hasNext(); ) {
                var pkt = iterator$pkt.next();
                this.addTimecodeInt(pkt);
            }
            this.gop.clear();
        }
    };
    prototype.sortByDisplay = function(gop) {
        var result = new ArrayList(gop);
        Collections.sort(result, new (stjs.extend(function TimecodeMP4MuxerTrack$1() {}, null, [Comparator], function(constructor, prototype) {
            prototype.compare = function(o1, o2) {
                if (o1 == null && o2 == null) 
                    return 0;
                 else if (o1 == null) 
                    return -1;
                 else if (o2 == null) 
                    return 1;
                 else 
                    return o1.getDisplayOrder() > o2.getDisplayOrder() ? 1 : (o1.getDisplayOrder() == o2.getDisplayOrder() ? 0 : -1);
            };
        }, {}, {}))());
        return result;
    };
    prototype.finish = function(mvhd) {
        this.processGop();
        this.outTimecodeSample();
        if (this.sampleEntries.size() == 0) 
            return null;
        if (this.edits != null) {
            this.edits = Util.editsOnEdits(new Rational(1, 1), this.lower, this.edits);
        } else 
            this.edits = this.lower;
        return CodecMP4MuxerTrack.prototype.finish.call(this, mvhd);
    };
    prototype.addTimecodeInt = function(packet) {
        var tapeTimecode = packet.getTapeTimecode();
        var gap = this.isGap(this.prevTimecode, tapeTimecode);
        this.prevTimecode = tapeTimecode;
        if (gap) {
            this.outTimecodeSample();
            this.firstTimecode = tapeTimecode;
            this.fpsEstimate = tapeTimecode.isDropFrame() ? 30 : -1;
            this.samplePts += this.sampleDuration;
            this.sampleDuration = 0;
            this.tcFrames = 0;
        }
        this.sampleDuration += packet.getDuration();
        this.tcFrames++;
    };
    prototype.isGap = function(prevTimecode, tapeTimecode) {
        var gap = false;
        if (prevTimecode == null && tapeTimecode != null) {
            gap = true;
        } else if (prevTimecode != null) {
            if (tapeTimecode == null) 
                gap = true;
             else {
                if (prevTimecode.isDropFrame() != tapeTimecode.isDropFrame()) {
                    gap = true;
                } else {
                    gap = this.isTimeGap(prevTimecode, tapeTimecode);
                }
            }
        }
        return gap;
    };
    prototype.isTimeGap = function(prevTimecode, tapeTimecode) {
        var gap = false;
        var sec = TimecodeMP4MuxerTrack.toSec(tapeTimecode);
        var secDiff = sec - TimecodeMP4MuxerTrack.toSec(prevTimecode);
        if (secDiff == 0) {
            var frameDiff = tapeTimecode.getFrame() - prevTimecode.getFrame();
            if (this.fpsEstimate != -1) 
                frameDiff = (frameDiff + this.fpsEstimate) % this.fpsEstimate;
            gap = frameDiff != 1;
        } else if (secDiff == 1) {
            if (this.fpsEstimate == -1) {
                if (tapeTimecode.getFrame() == 0) 
                    this.fpsEstimate = prevTimecode.getFrame() + 1;
                 else 
                    gap = true;
            } else {
                var firstFrame = tapeTimecode.isDropFrame() && (sec % 60) == 0 && (sec % 600) != 0 ? 2 : 0;
                if (tapeTimecode.getFrame() != firstFrame || prevTimecode.getFrame() != this.fpsEstimate - 1) 
                    gap = true;
            }
        } else {
            gap = true;
        }
        return gap;
    };
    prototype.outTimecodeSample = function() {
        if (this.sampleDuration > 0) {
            if (this.firstTimecode != null) {
                if (this.fpsEstimate == -1) 
                    this.fpsEstimate = this.prevTimecode.getFrame() + 1;
                var tmcd = TimecodeSampleEntry.createTimecodeSampleEntry((this.firstTimecode.isDropFrame() ? 1 : 0), this._timescale, (((stjs.trunc(this.sampleDuration / this.tcFrames))) | 0), this.fpsEstimate);
                this.sampleEntries.add(tmcd);
                var sample = ByteBuffer.allocate(4);
                sample.putInt(this.toCounter(this.firstTimecode, this.fpsEstimate));
                sample.flip();
                this.addFrame(MP4Packet.createMP4Packet(sample, this.samplePts, this._timescale, this.sampleDuration, 0, Packet.FrameType.KEY, null, 0, this.samplePts, this.sampleEntries.size() - 1));
                this.lower.add(new Edit(this.sampleDuration, this.samplePts, 1.0));
            } else {
                this.lower.add(new Edit(this.sampleDuration, -1, 1.0));
            }
        }
    };
    prototype.toCounter = function(tc, fps) {
        var frames = TimecodeMP4MuxerTrack.toSec(tc) * fps + tc.getFrame();
        if (tc.isDropFrame()) {
            var D = stjs.trunc(frames / 18000);
            var M = frames % 18000;
            frames -= 18 * D + 2 * (stjs.trunc((M - 2) / 1800));
        }
        return frames;
    };
    constructor.toSec = function(tc) {
        return tc.getHour() * 3600 + tc.getMinute() * 60 + tc.getSecond();
    };
}, {prevTimecode: "TapeTimecode", firstTimecode: "TapeTimecode", lower: {name: "List", arguments: ["Edit"]}, gop: {name: "List", arguments: ["Packet"]}, codec2fourcc: {name: "Map", arguments: ["Codec", null]}, codec: "Codec", spsList: {name: "List", arguments: ["ByteBuffer"]}, ppsList: {name: "List", arguments: ["ByteBuffer"]}, adtsHeader: "ADTSParser.Header", sampleDurations: {name: "List", arguments: ["TimeToSampleBox.TimeToSampleEntry"]}, chunkOffsets: "LongArrayList", sampleSizes: "IntArrayList", iframes: "IntArrayList", compositionOffsets: {name: "List", arguments: ["CompositionOffsetsBox.LongEntry"]}, timecodeTrack: "TimecodeMP4MuxerTrack", type: "MP4TrackType", tgtChunkDuration: "Rational", tgtChunkDurationUnit: {name: "Enum", arguments: ["Unit"]}, curChunk: {name: "List", arguments: ["ByteBuffer"]}, samplesInChunks: {name: "List", arguments: ["SampleToChunkBox.SampleToChunkEntry"]}, sampleEntries: {name: "List", arguments: ["SampleEntry"]}, edits: {name: "List", arguments: ["Edit"]}, out: "SeekableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Default box factory
 *  
 *  @author The JCodec project
 *  
 */
var BoxFactory = function(boxes) {
    this.boxes = boxes;
};
BoxFactory = stjs.extend(BoxFactory, null, [IBoxFactory], function(constructor, prototype) {
    constructor.instance = new BoxFactory(new DefaultBoxes());
    constructor.audio = new BoxFactory(new AudioBoxes());
    constructor.data = new BoxFactory(new DataBoxes());
    constructor.sample = new BoxFactory(new SampleBoxes());
    constructor.timecode = new BoxFactory(new TimecodeBoxes());
    constructor.video = new BoxFactory(new VideoBoxes());
    constructor.waveext = new BoxFactory(new WaveExtBoxes());
    prototype.boxes = null;
    constructor.getDefault = function() {
        return BoxFactory.instance;
    };
    prototype.newBox = function(header) {
        var claz = this.boxes.toClass(header.getFourcc());
        if (claz == null) 
            return new Box.LeafBox(header);
        var box = Platform.newInstance(claz, [header]);
        if (stjs.isInstanceOf(box.constructor, NodeBox)) {
            var nodebox = box;
            if (stjs.isInstanceOf(nodebox.constructor, SampleDescriptionBox)) {
                nodebox.setFactory(BoxFactory.sample);
            } else if (stjs.isInstanceOf(nodebox.constructor, VideoSampleEntry)) {
                nodebox.setFactory(BoxFactory.video);
            } else if (stjs.isInstanceOf(nodebox.constructor, AudioSampleEntry)) {
                nodebox.setFactory(BoxFactory.audio);
            } else if (stjs.isInstanceOf(nodebox.constructor, TimecodeSampleEntry)) {
                nodebox.setFactory(BoxFactory.timecode);
            } else if (stjs.isInstanceOf(nodebox.constructor, DataRefBox)) {
                nodebox.setFactory(BoxFactory.data);
            } else if (stjs.isInstanceOf(nodebox.constructor, WaveExtension)) {
                nodebox.setFactory(BoxFactory.waveext);
            } else {
                nodebox.setFactory(this);
            }
        }
        return box;
    };
}, {instance: "IBoxFactory", audio: "IBoxFactory", data: "IBoxFactory", sample: "IBoxFactory", timecode: "IBoxFactory", video: "IBoxFactory", waveext: "IBoxFactory", boxes: "Boxes"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Regular MP4 track containing frames
 *  
 *  @author The JCodec project
 *  
 */
var CodecMP4DemuxerTrack = function(mov, trak, input) {
    MP4DemuxerTrack.call(this, mov, trak, input);
    if (Codec.codecByFourcc(this.getFourcc()) == Codec.H264) {
        this.avcC = H264Utils.parseAVCC(this.getSampleEntries()[0]);
    }
    this.codecPrivate = MP4DemuxerTrackMeta.getCodecPrivate(this);
};
CodecMP4DemuxerTrack = stjs.extend(CodecMP4DemuxerTrack, MP4DemuxerTrack, [], function(constructor, prototype) {
    prototype.codecPrivate = null;
    prototype.avcC = null;
    prototype.convertPacket = function(result) {
        if (this.codecPrivate != null) {
            if (Codec.codecByFourcc(this.getFourcc()) == Codec.H264) {
                var annexbCoded = H264Utils.decodeMOVPacket(result, this.avcC);
                if (H264Utils.isByteBufferIDRSlice(annexbCoded)) {
                    return NIOUtils.combineBuffers(Arrays.asList(this.codecPrivate, annexbCoded));
                }
                return annexbCoded;
            } else if (Codec.codecByFourcc(this.getFourcc()) == Codec.AAC) {
                var adts = AACUtils.streamInfoToADTS(this.codecPrivate, true, 1, result.remaining());
                var adtsRaw = ByteBuffer.allocate(7);
                ADTSParser.write(adts, adtsRaw);
                return NIOUtils.combineBuffers(Arrays.asList(adtsRaw, result));
            }
        }
        return result;
    };
}, {codecPrivate: "ByteBuffer", avcC: "AvcCBox", sizes: "Int32Array", syncSamples: "Int32Array", partialSync: "Int32Array", compOffsets: "Array", input: "SeekableByteChannel", movie: "MovieBox", box: "TrakBox", type: "MP4TrackType", sampleEntries: "Array", timeToSamples: "Array", sampleToChunks: "Array", chunkOffsets: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  MPEG 4 AVC ( H.264 ) Encoder
 *  
 *  Conforms to H.264 ( ISO/IEC 14496-10 ) specifications
 *  
 *  @author The JCodec project
 *  
 */
var H264Encoder = function(rc) {
    VideoEncoder.call(this);
    this.rc = rc;
    this.keyInterval = H264Encoder.KEY_INTERVAL_DEFAULT;
    this.motionSearchRange = H264Encoder.MOTION_SEARCH_RANGE_DEFAULT;
};
H264Encoder = stjs.extend(H264Encoder, VideoEncoder, [], function(constructor, prototype) {
    constructor.KEY_INTERVAL_DEFAULT = 25;
    constructor.MOTION_SEARCH_RANGE_DEFAULT = 16;
    constructor.createH264Encoder = function() {
        return new H264Encoder(new DumbRateControl());
    };
    prototype.cavlc = null;
    prototype.leftRow = null;
    prototype.topLine = null;
    prototype.rc = null;
    prototype.frameNumber = 0;
    prototype.keyInterval = 0;
    prototype.motionSearchRange = 0;
    prototype.maxPOC = 0;
    prototype.maxFrameNumber = 0;
    prototype.sps = null;
    prototype.pps = null;
    prototype.mbEncoderI16x16 = null;
    prototype.mbEncoderP16x16 = null;
    prototype.ref = null;
    prototype.picOut = null;
    prototype.topEncoded = null;
    prototype.outMB = null;
    prototype.getKeyInterval = function() {
        return this.keyInterval;
    };
    prototype.setKeyInterval = function(keyInterval) {
        this.keyInterval = keyInterval;
    };
    prototype.getMotionSearchRange = function() {
        return this.motionSearchRange;
    };
    prototype.setMotionSearchRange = function(motionSearchRange) {
        this.motionSearchRange = motionSearchRange;
    };
    /**
     *  Encode this picture into h.264 frame. Frame type will be selected by
     *  encoder.
     */
    prototype.encodeFrame = function(pic, _out) {
        if (pic.getColor() != ColorSpace.YUV420J) 
             throw new IllegalArgumentException("Input picture color is not supported: " + pic.getColor());
        if (this.frameNumber >= this.keyInterval) {
            this.frameNumber = 0;
        }
        var sliceType = this.frameNumber == 0 ? SliceType.I : SliceType.P;
        var idr = this.frameNumber == 0;
        var data = this.doEncodeFrame(pic, _out, idr, this.frameNumber++, sliceType);
        return new VideoEncoder.EncodedFrame(data, idr);
    };
    /**
     *  Encode this picture as an IDR frame. IDR frame starts a new independently
     *  decodeable video sequence
     *  
     *  @param pic
     *  @param _out
     *  @return
     */
    prototype.encodeIDRFrame = function(pic, _out) {
        this.frameNumber = 0;
        return this.doEncodeFrame(pic, _out, true, this.frameNumber, SliceType.I);
    };
    /**
     *  Encode this picture as a P-frame. P-frame is an frame predicted from one
     *  or more of the previosly decoded frame and is usually 10x less in size
     *  then the IDR frame.
     *  
     *  @param pic
     *  @param _out
     *  @return
     */
    prototype.encodePFrame = function(pic, _out) {
        this.frameNumber++;
        return this.doEncodeFrame(pic, _out, true, this.frameNumber, SliceType.P);
    };
    prototype.doEncodeFrame = function(pic, _out, idr, frameNumber, frameType) {
        var dup = _out.duplicate();
        var maxSize = Math.min(dup.remaining(), pic.getWidth() * pic.getHeight());
        maxSize -= (maxSize >>> 6);
        var qp = this.rc.startPicture(pic.getSize(), maxSize, frameType);
        if (idr) {
            this.sps = this.initSPS(new Size(pic.getCroppedWidth(), pic.getCroppedHeight()));
            this.pps = this.initPPS();
            this.maxPOC = 1 << (this.sps.log2MaxPicOrderCntLsbMinus4 + 4);
            this.maxFrameNumber = 1 << (this.sps.log2MaxFrameNumMinus4 + 4);
        }
        if (idr) {
            dup.putInt(1);
            new NALUnit(NALUnitType.SPS, 3).write(dup);
            this.writeSPS(dup, this.sps);
            dup.putInt(1);
            new NALUnit(NALUnitType.PPS, 3).write(dup);
            this.writePPS(dup, this.pps);
        }
        var mbWidth = this.sps.picWidthInMbsMinus1 + 1;
        var mbHeight = this.sps.picHeightInMapUnitsMinus1 + 1;
        this.leftRow = [new Int8Array(16), new Int8Array(8), new Int8Array(8)];
        this.topLine = [new Int8Array(mbWidth << 4), new Int8Array(mbWidth << 3), new Int8Array(mbWidth << 3)];
        this.picOut = Picture.create(mbWidth << 4, mbHeight << 4, ColorSpace.YUV420J);
        this.outMB = new EncodedMB();
        this.topEncoded = Array(mbWidth);
        for (var i = 0; i < mbWidth; i++) 
            this.topEncoded[i] = new EncodedMB();
        this.encodeSlice(this.sps, this.pps, pic, dup, idr, frameNumber, frameType, qp);
        this.putLastMBLine();
        this.ref = this.picOut;
        dup.flip();
        return dup;
    };
    prototype.writePPS = function(dup, pps) {
        var tmp = ByteBuffer.allocate(1024);
        pps.write(tmp);
        tmp.flip();
        H264Utils.escapeNAL(tmp, dup);
    };
    prototype.writeSPS = function(dup, sps) {
        var tmp = ByteBuffer.allocate(1024);
        sps.write(tmp);
        tmp.flip();
        H264Utils.escapeNAL(tmp, dup);
    };
    prototype.initPPS = function() {
        var pps = new PictureParameterSet();
        pps.picInitQpMinus26 = 0;
        return pps;
    };
    prototype.initSPS = function(sz) {
        var sps = new SeqParameterSet();
        sps.picWidthInMbsMinus1 = ((sz.getWidth() + 15) >> 4) - 1;
        sps.picHeightInMapUnitsMinus1 = ((sz.getHeight() + 15) >> 4) - 1;
        sps.chromaFormatIdc = ColorSpace.YUV420J;
        sps.profileIdc = 66;
        sps.levelIdc = 40;
        sps.numRefFrames = 1;
        sps.frameMbsOnlyFlag = true;
        sps.log2MaxFrameNumMinus4 = Math.max(0, MathUtil.log2(this.keyInterval) - 3);
        var codedWidth = (sps.picWidthInMbsMinus1 + 1) << 4;
        var codedHeight = (sps.picHeightInMapUnitsMinus1 + 1) << 4;
        sps.frameCroppingFlag = codedWidth != sz.getWidth() || codedHeight != sz.getHeight();
        sps.frameCropRightOffset = (codedWidth - sz.getWidth() + 1) >> 1;
        sps.frameCropBottomOffset = (codedHeight - sz.getHeight() + 1) >> 1;
        return sps;
    };
    prototype.encodeSlice = function(sps, pps, pic, dup, idr, frameNum, sliceType, qp) {
        if (idr && sliceType != SliceType.I) {
            idr = false;
            Logger.warn("Illegal value of idr = true when sliceType != I");
        }
        this.cavlc = [new CAVLC(sps, pps, 2, 2), new CAVLC(sps, pps, 1, 1), new CAVLC(sps, pps, 1, 1)];
        this.mbEncoderI16x16 = new MBEncoderI16x16(this.cavlc, this.leftRow, this.topLine);
        this.mbEncoderP16x16 = new MBEncoderP16x16(sps, this.ref, this.cavlc, new MotionEstimator(this.motionSearchRange));
        dup.putInt(1);
        new NALUnit(idr ? NALUnitType.IDR_SLICE : NALUnitType.NON_IDR_SLICE, 3).write(dup);
        var sh = new SliceHeader();
        sh.sliceType = sliceType;
        if (idr) 
            sh.refPicMarkingIDR = new RefPicMarkingIDR(false, false);
        sh.pps = pps;
        sh.sps = sps;
        sh.picOrderCntLsb = (frameNum << 1) % this.maxPOC;
        sh.frameNum = frameNum % this.maxFrameNumber;
        sh.sliceQpDelta = qp - (pps.picInitQpMinus26 + 26);
        var buf = ByteBuffer.allocate(pic.getWidth() * pic.getHeight());
        var sliceData = new BitWriter(buf);
        SliceHeaderWriter.write(sh, idr, 2, sliceData);
        for (var mbY = 0, mbAddr = 0; mbY < sps.picHeightInMapUnitsMinus1 + 1; mbY++) {
            for (var mbX = 0; mbX < sps.picWidthInMbsMinus1 + 1; mbX++ , mbAddr++) {
                if (sliceType == SliceType.P) {
                    CAVLCWriter.writeUE(sliceData, 0);
                }
                var mbType = this.selectMBType(sliceType);
                if (mbType == MBType.I_16x16) {
                    var predMode = this.mbEncoderI16x16.getPredMode(pic, mbX, mbY);
                    var cbpChroma = this.mbEncoderI16x16.getCbpChroma(pic, mbX, mbY);
                    var cbpLuma = this.mbEncoderI16x16.getCbpLuma(pic, mbX, mbY);
                    var i16x16TypeOffset = (stjs.trunc(cbpLuma / 15)) * 12 + cbpChroma * 4 + predMode;
                    var mbTypeOffset = sliceType == SliceType.P ? 5 : 0;
                    CAVLCWriter.writeUE(sliceData, mbTypeOffset + mbType.code() + i16x16TypeOffset);
                } else {
                    CAVLCWriter.writeUE(sliceData, mbType.code());
                }
                var candidate;
                var totalQpDelta = 0;
                var qpDelta = this.rc.initialQpDelta();
                do {
                    candidate = sliceData.fork();
                    totalQpDelta += qpDelta;
                    this.encodeMacroblock(mbType, pic, mbX, mbY, candidate, qp, totalQpDelta);
                    qpDelta = this.rc.accept(candidate.position() - sliceData.position());
                    if (qpDelta != 0) 
                        this.restoreMacroblock(mbType);
                } while (qpDelta != 0);
                sliceData = candidate;
                qp += totalQpDelta;
                this.collectPredictors(this.outMB.getPixels(), mbX);
                this.addToReference(mbX, mbY);
            }
        }
        sliceData.write1Bit(1);
        sliceData.flush();
        buf = sliceData.getBuffer();
        buf.flip();
        H264Utils.escapeNAL(buf, dup);
    };
    prototype.encodeMacroblock = function(mbType, pic, mbX, mbY, candidate, qp, qpDelta) {
        if (mbType == MBType.I_16x16) {
            this.mbEncoderI16x16.save();
            this.mbEncoderI16x16.encodeMacroblock(pic, mbX, mbY, candidate, this.outMB, mbX > 0 ? this.topEncoded[mbX - 1] : null, mbY > 0 ? this.topEncoded[mbX] : null, qp + qpDelta, qpDelta);
        } else if (mbType == MBType.P_16x16) {
            this.mbEncoderP16x16.save();
            this.mbEncoderP16x16.encodeMacroblock(pic, mbX, mbY, candidate, this.outMB, mbX > 0 ? this.topEncoded[mbX - 1] : null, mbY > 0 ? this.topEncoded[mbX] : null, qp + qpDelta, qpDelta);
        } else 
             throw new RuntimeException("Macroblock of type " + mbType + " is not supported.");
    };
    prototype.restoreMacroblock = function(mbType) {
        if (mbType == MBType.I_16x16) {
            this.mbEncoderI16x16.restore();
        } else if (mbType == MBType.P_16x16) {
            this.mbEncoderP16x16.restore();
        } else 
             throw new RuntimeException("Macroblock of type " + mbType + " is not supported.");
    };
    prototype.selectMBType = function(sliceType) {
        if (sliceType == SliceType.I) 
            return MBType.I_16x16;
         else if (sliceType == SliceType.P) 
            return MBType.P_16x16;
         else 
             throw new RuntimeException("Unsupported slice type");
    };
    prototype.addToReference = function(mbX, mbY) {
        if (mbY > 0) 
            MBEncoderHelper.putBlkPic(this.picOut, this.topEncoded[mbX].getPixels(), mbX << 4, (mbY - 1) << 4);
        var tmp = this.topEncoded[mbX];
        this.topEncoded[mbX] = this.outMB;
        this.outMB = tmp;
    };
    prototype.putLastMBLine = function() {
        var mbWidth = this.sps.picWidthInMbsMinus1 + 1;
        var mbHeight = this.sps.picHeightInMapUnitsMinus1 + 1;
        for (var mbX = 0; mbX < mbWidth; mbX++) 
            MBEncoderHelper.putBlkPic(this.picOut, this.topEncoded[mbX].getPixels(), mbX << 4, (mbHeight - 1) << 4);
    };
    prototype.collectPredictors = function(outMB, mbX) {
        System.arraycopy(outMB.getPlaneData(0), 240, this.topLine[0], mbX << 4, 16);
        System.arraycopy(outMB.getPlaneData(1), 56, this.topLine[1], mbX << 3, 8);
        System.arraycopy(outMB.getPlaneData(2), 56, this.topLine[2], mbX << 3, 8);
        this.copyCol(outMB.getPlaneData(0), 15, 16, this.leftRow[0]);
        this.copyCol(outMB.getPlaneData(1), 7, 8, this.leftRow[1]);
        this.copyCol(outMB.getPlaneData(2), 7, 8, this.leftRow[2]);
    };
    prototype.copyCol = function(planeData, off, stride, out) {
        for (var i = 0; i < out.length; i++) {
            out[i] = planeData[off];
            off += stride;
        }
    };
    prototype.getSupportedColorSpaces = function() {
        return [ColorSpace.YUV420J];
    };
    prototype.estimateBufferSize = function(frame) {
        return Math.max(1 << 16, stjs.trunc(frame.getWidth() * frame.getHeight() / 2));
    };
}, {cavlc: "Array", leftRow: "Array", topLine: "Array", rc: "RateControl", sps: "SeqParameterSet", pps: "PictureParameterSet", mbEncoderI16x16: "MBEncoderI16x16", mbEncoderP16x16: "MBEncoderP16x16", ref: "Picture", picOut: "Picture", topEncoded: "Array", outMB: "EncodedMB"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var VerifyTool = function() {};
VerifyTool = stjs.extend(VerifyTool, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length != 1) {
            System.out.println("Syntax: <error folder location>");
            return;
        }
        new VerifyTool().doIt(args[0]);
    };
    prototype.doIt = function(location) {
        var h264 = new File(location).listFiles(new (stjs.extend(function VerifyTool$1() {}, null, [FilenameFilter], function(constructor, prototype) {
            prototype.accept = function(dir, name) {
                return name.endsWith(".264");
            };
        }, {}, {}))());
        for (var index$coded = 0, arr$coded = h264; index$coded < arr$coded.length; index$coded++) {
            var coded = arr$coded[index$coded];
            var ref = new File(coded.getParentFile(), coded.getName().replaceAll(".264$", "_dec.yuv"));
            if (coded.exists() && ref.exists()) {
                try {
                    if (this.test(coded, ref)) {
                        System.out.println(coded.getAbsolutePath() + " -- FIXED");
                        Platform.deleteFile(coded);
                        Platform.deleteFile(ref);
                    } else {
                        System.out.println(coded.getAbsolutePath() + " -- NOT FIXED!!!!");
                    }
                }catch (t) {
                    System.out.println(coded.getAbsolutePath() + " -- ERROR: " + t.getMessage());
                }
            }
        }
    };
    prototype.test = function(coded, ref) {
        var es = new BufferH264ES(NIOUtils.fetchFromFile(coded));
        var buf = Picture.create(1920, 1088, ColorSpace.YUV420);
        var dec = new H264Decoder();
        var nextFrame;
        var _yuv = NIOUtils.fetchFromFile(ref);
         while ((nextFrame = es.nextFrame()) != null){
            var out = dec.decodeFrame(nextFrame.getData(), buf.getData()).cropped();
            var pic = out.createCompatible();
            pic.copyFrom(out);
            var lumaSize = pic.getWidth() * pic.getHeight();
            var crSize = lumaSize >> 2;
            var cbSize = lumaSize >> 2;
            var yuv = NIOUtils.read(_yuv, lumaSize + crSize + cbSize);
            if (!Platform.arrayEqualsByte(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, lumaSize)), pic.getPlaneData(0))) 
                return false;
            if (!Platform.arrayEqualsByte(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, crSize)), pic.getPlaneData(1))) 
                return false;
            if (!Platform.arrayEqualsByte(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, cbSize)), pic.getPlaneData(2))) 
                return false;
        }
        return true;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  High level frame grabber helper.
 *  
 *  @author The JCodec project
 *  
 */
var AVCMP4Adaptor = function(meta) {
    this.meta = meta;
    this.curENo = -1;
    this.calcBufferSize();
};
AVCMP4Adaptor = stjs.extend(AVCMP4Adaptor, null, [ContainerAdaptor], function(constructor, prototype) {
    prototype.decoder = null;
    prototype.curENo = 0;
    prototype.size = null;
    prototype.meta = null;
    prototype.calcBufferSize = function() {
        var w = Integer.MIN_VALUE, h = Integer.MIN_VALUE;
        var bb = this.meta.getCodecPrivate().duplicate();
        var b;
         while ((b = H264Utils.nextNALUnit(bb)) != null){
            var nu = NALUnit.read(b);
            if (nu.type != NALUnitType.SPS) 
                continue;
            var sps = H264Utils.readSPS(b);
            var ww = sps.picWidthInMbsMinus1 + 1;
            if (ww > w) 
                w = ww;
            var hh = SeqParameterSet.getPicHeightInMbs(sps);
            if (hh > h) 
                h = hh;
        }
        this.size = new Size(w << 4, h << 4);
    };
    prototype.decodeFrame = function(packet, data) {
        this.updateState(packet);
        var pic = this.decoder.decodeFrame(packet.getData(), data);
        var pasp = this.meta.getVideoCodecMeta().getPixelAspectRatio();
        if (pasp != null) {}
        return pic;
    };
    prototype.updateState = function(packet) {
        var eNo = (packet).getEntryNo();
        if (eNo != this.curENo) {
            this.curENo = eNo;
        }
        if (this.decoder == null) {
            this.decoder = H264Decoder.createH264DecoderFromCodecPrivate(this.meta.getCodecPrivate());
        }
    };
    prototype.canSeek = function(pkt) {
        this.updateState(pkt);
        return H264Utils.idrSlice(H264Utils.splitFrame(pkt.getData()));
    };
    prototype.allocatePicture = function() {
        return Picture.create(this.size.getWidth(), this.size.getHeight(), ColorSpace.YUV444).getData();
    };
    prototype.getMediaInfo = function() {
        return new MediaInfo(this.size);
    };
}, {decoder: "H264Decoder", size: "Size", meta: "DemuxerTrackMeta"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MP4Util = function() {};
MP4Util = stjs.extend(MP4Util, null, [], function(constructor, prototype) {
    constructor.codecMapping = new HashMap();
    constructor.Movie = function(ftyp, moov) {
        this.ftyp = ftyp;
        this.moov = moov;
    };
    constructor.Movie = stjs.extend(constructor.Movie, null, [], function(constructor, prototype) {
        prototype.ftyp = null;
        prototype.moov = null;
        prototype.getFtyp = function() {
            return this.ftyp;
        };
        prototype.getMoov = function() {
            return this.moov;
        };
    }, {ftyp: "FileTypeBox", moov: "MovieBox"}, {});
    constructor.createRefMovie = function(input, url) {
        var movie = MP4Util.parseMovieChannel(input);
        var tracks = movie.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            trakBox.setDataRef(url);
        }
        return movie;
    };
    constructor.parseMovieChannel = function(input) {
        for (var iterator$atom = MP4Util.getRootAtoms(input).iterator(); iterator$atom.hasNext(); ) {
            var atom = iterator$atom.next();
            if ("moov".equals(atom.getHeader().getFourcc())) {
                return atom.parseBox(input);
            }
        }
        return null;
    };
    constructor.createRefFullMovie = function(input, url) {
        var movie = MP4Util.parseFullMovieChannel(input);
        var tracks = movie.moov.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            trakBox.setDataRef(url);
        }
        return movie;
    };
    constructor.parseFullMovieChannel = function(input) {
        var ftyp = null;
        for (var iterator$atom = MP4Util.getRootAtoms(input).iterator(); iterator$atom.hasNext(); ) {
            var atom = iterator$atom.next();
            if ("ftyp".equals(atom.getHeader().getFourcc())) {
                ftyp = atom.parseBox(input);
            } else if ("moov".equals(atom.getHeader().getFourcc())) {
                return new MP4Util.Movie(ftyp, atom.parseBox(input));
            }
        }
        return null;
    };
    constructor.parseMovieFragments = function(input) {
        var moov = null;
        var fragments = new LinkedList();
        for (var iterator$atom = MP4Util.getRootAtoms(input).iterator(); iterator$atom.hasNext(); ) {
            var atom = iterator$atom.next();
            if ("moov".equals(atom.getHeader().getFourcc())) {
                moov = atom.parseBox(input);
            } else if ("moof".equalsIgnoreCase(atom.getHeader().getFourcc())) {
                fragments.add(atom.parseBox(input));
            }
        }
        for (var iterator$fragment = fragments.iterator(); iterator$fragment.hasNext(); ) {
            var fragment = iterator$fragment.next();
            fragment.setMovie(moov);
        }
        return fragments;
    };
    constructor.getRootAtoms = function(input) {
        input.setPosition(0);
        var result = new ArrayList();
        var off = 0;
        var atom;
         while (off < input.size()){
            input.setPosition(off);
            atom = Header.read(NIOUtils.fetchFromChannel(input, 16));
            if (atom == null) 
                break;
            result.add(new MP4Util.Atom(atom, off));
            off += atom.getSize();
        }
        return result;
    };
    constructor.findFirstAtomInFile = function(fourcc, input) {
        var c = new AutoFileChannelWrapper(input);
        try {
            return MP4Util.findFirstAtom(fourcc, c);
        } finally {
            IOUtils.closeQuietly(c);
        }
    };
    constructor.findFirstAtom = function(fourcc, input) {
        var rootAtoms = MP4Util.getRootAtoms(input);
        for (var iterator$atom = rootAtoms.iterator(); iterator$atom.hasNext(); ) {
            var atom = iterator$atom.next();
            if (fourcc.equals(atom.getHeader().getFourcc())) 
                return atom;
        }
        return null;
    };
    constructor.atom = function(input) {
        var off = input.position();
        var atom = Header.read(NIOUtils.fetchFromChannel(input, 16));
        return atom == null ? null : new MP4Util.Atom(atom, off);
    };
    constructor.Atom = function(header, offset) {
        this.header = header;
        this.offset = offset;
    };
    constructor.Atom = stjs.extend(constructor.Atom, null, [], function(constructor, prototype) {
        prototype.offset = 0;
        prototype.header = null;
        prototype.getOffset = function() {
            return this.offset;
        };
        prototype.getHeader = function() {
            return this.header;
        };
        prototype.parseBox = function(input) {
            input.setPosition(this.offset + this.header.headerSize());
            return BoxUtil.parseBox(NIOUtils.fetchFromChannel(input, ((this.header.getBodySize()) | 0)), this.header, BoxFactory.getDefault());
        };
        prototype.copy = function(input, out) {
            input.setPosition(this.offset);
            NIOUtils.copy(input, out, this.header.getSize());
        };
    }, {header: "Header"}, {});
    constructor.parseMovie = function(source) {
        var input = null;
        try {
            input = NIOUtils.readableChannel(source);
            return MP4Util.parseMovieChannel(input);
        } finally {
            if (input != null) 
                input.close();
        }
    };
    constructor.createRefMovieFromFile = function(source) {
        var input = null;
        try {
            input = NIOUtils.readableChannel(source);
            return MP4Util.createRefMovie(input, "file://" + source.getCanonicalPath());
        } finally {
            if (input != null) 
                input.close();
        }
    };
    constructor.writeMovieToFile = function(f, movie) {
        var out = null;
        try {
            out = NIOUtils.writableChannel(f);
            MP4Util.writeMovie(out, movie);
        } finally {
            IOUtils.closeQuietly(out);
        }
    };
    constructor.writeMovie = function(out, movie) {
        MP4Util.doWriteMovieToChannel(out, movie, 0);
    };
    constructor.doWriteMovieToChannel = function(out, movie, additionalSize) {
        var sizeHint = MP4Util.estimateMoovBoxSize(movie) + additionalSize;
        Logger.debug("Using " + sizeHint + " bytes for MOOV box");
        var buf = ByteBuffer.allocate(sizeHint * 4);
        movie.write(buf);
        buf.flip();
        out.write(buf);
    };
    constructor.parseFullMovie = function(source) {
        var input = null;
        try {
            input = NIOUtils.readableChannel(source);
            return MP4Util.parseFullMovieChannel(input);
        } finally {
            if (input != null) 
                input.close();
        }
    };
    constructor.createRefFullMovieFromFile = function(source) {
        var input = null;
        try {
            input = NIOUtils.readableChannel(source);
            return MP4Util.createRefFullMovie(input, "file://" + source.getCanonicalPath());
        } finally {
            if (input != null) 
                input.close();
        }
    };
    constructor.writeFullMovieToFile = function(f, movie) {
        var out = null;
        try {
            out = NIOUtils.writableChannel(f);
            MP4Util.writeFullMovie(out, movie);
        } finally {
            IOUtils.closeQuietly(out);
        }
    };
    constructor.writeFullMovie = function(out, movie) {
        MP4Util.doWriteFullMovieToChannel(out, movie, 0);
    };
    constructor.doWriteFullMovieToChannel = function(out, movie, additionalSize) {
        var sizeHint = MP4Util.estimateMoovBoxSize(movie.getMoov()) + additionalSize;
        Logger.debug("Using " + sizeHint + " bytes for MOOV box");
        var buf = ByteBuffer.allocate(sizeHint + 128);
        movie.getFtyp().write(buf);
        movie.getMoov().write(buf);
        buf.flip();
        out.write(buf);
    };
    /**
     *  Estimate buffer size needed to write MOOV box based on the amount of
     *  stuff in there
     *  
     *  @param movie
     *  @return
     */
    constructor.estimateMoovBoxSize = function(movie) {
        return movie.estimateSize() + (4 << 10);
    };
    constructor.getFourcc = function(codec) {
        return MP4Util.codecMapping.get(codec);
    };
    constructor.writeBox = function(box, approxSize) {
        var buf = ByteBuffer.allocate(approxSize);
        box.write(buf);
        buf.flip();
        return buf;
    };
}, {codecMapping: {name: "Map", arguments: ["Codec", null]}}, {});
(function() {
    MP4Util.codecMapping.put(Codec.MPEG2, "m2v1");
    MP4Util.codecMapping.put(Codec.H264, "avc1");
    MP4Util.codecMapping.put(Codec.J2K, "mjp2");
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var QTRefEdit = function(_arguments) {
    this.factories = arguments;
};
QTRefEdit = stjs.extend(QTRefEdit, null, [], function(constructor, prototype) {
    prototype.factories = null;
    prototype.execute = function(args) {
        var aa = new LinkedList(Arrays.asList(args));
        var edits = new LinkedList();
         while (aa.size() > 0){
            var i;
            for (i = 0; i < this.factories.length; i++) {
                if (aa.get(0).equals(this.factories[i].getName())) {
                    aa.remove(0);
                    try {
                        edits.add(this.factories[i].parseArgs(aa));
                    }catch (e) {
                        System.err.println("ERROR: " + e.getMessage());
                        return;
                    }
                    break;
                }
            }
            if (i == this.factories.length) 
                break;
        }
        if (aa.size() == 0) {
            System.err.println("ERROR: A movie file should be specified");
            this.help();
        }
        if (edits.size() == 0) {
            System.err.println("ERROR: At least one command should be specified");
            this.help();
        }
        var input = new File(aa.remove(0));
        if (aa.size() == 0) {
            System.err.println("ERROR: A movie output file should be specified");
            this.help();
        }
        var output = new File(aa.remove(0));
        if (!input.exists()) {
            System.err.println("ERROR: Input file '" + input.getAbsolutePath() + "' doesn't exist");
            this.help();
        }
        if (output.exists()) {
            System.err.println("WARNING: Output file '" + output.getAbsolutePath() + "' exist, overwritting");
        }
        var ref = MP4Util.createRefFullMovieFromFile(input);
        new CompoundMP4Edit(edits).apply(ref.getMoov());
        MP4Util.writeFullMovieToFile(output, ref);
        System.out.println("INFO: Created reference file: " + output.getAbsolutePath());
    };
    prototype.help = function() {
        System.out.println("Quicktime movie editor");
        System.out.println("Syntax: qtedit <command1> <options> ... <commandN> <options> <movie> <output>");
        System.out.println("Where options:");
        for (var index$commandFactory = 0, arr$commandFactory = this.factories; index$commandFactory < arr$commandFactory.length; index$commandFactory++) {
            var commandFactory = arr$commandFactory[index$commandFactory];
            System.out.println("\t" + commandFactory.getHelp());
        }
        System.exit(-1);
    };
}, {factories: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Creates MP4 file out of a set of samples
 *  
 *  @author The JCodec project
 *  
 */
var MP4Muxer = function(output, ftyp) {
    this.tracks = new ArrayList();
    this.out = output;
    var buf = ByteBuffer.allocate(1024);
    ftyp.write(buf);
    Header.createHeader("wide", 8).write(buf);
    Header.createHeader("mdat", 1).write(buf);
    this.mdatOffset = buf.position();
    buf.putLong(0);
    buf.flip();
    output.write(buf);
};
MP4Muxer = stjs.extend(MP4Muxer, null, [Muxer], function(constructor, prototype) {
    prototype.tracks = null;
    prototype.mdatOffset = 0;
    prototype.nextTrackId = 1;
    prototype.out = null;
    constructor.createMP4MuxerToChannel = function(output) {
        return new MP4Muxer(output, Brand.MP4.getFileTypeBox());
    };
    constructor.createMP4Muxer = function(output, brand) {
        return new MP4Muxer(output, brand.getFileTypeBox());
    };
    prototype.addTimecodeTrack = function() {
        return this.addTrack(new TimecodeMP4MuxerTrack(this.nextTrackId++));
    };
    prototype.addTrackWithId = function(type, codec, trackId) {
        Preconditions.checkArgument(!this.hasTrackId(trackId), "track with id %s already exists", trackId);
        var track = new CodecMP4MuxerTrack(trackId, type, codec);
        this.tracks.add(track);
        this.nextTrackId = Math.max(this.nextTrackId, trackId + 1);
        return track;
    };
    prototype.getNextTrackId = function() {
        return this.nextTrackId;
    };
    prototype.doAddTrack = function(type, codec) {
        return this.addTrack(new CodecMP4MuxerTrack(this.nextTrackId++, type, codec));
    };
    prototype.addTrack = function(track) {
        Preconditions.checkNotNull(track, "track can not be null");
        var trackId = track.getTrackId();
        Preconditions.checkArgument(trackId <= this.nextTrackId);
        Preconditions.checkArgument(!this.hasTrackId(trackId), "track with id %s already exists", trackId);
        this.tracks.add(track.setOut(this.out));
        this.nextTrackId = Math.max(trackId + 1, this.nextTrackId);
        return track;
    };
    prototype.hasTrackId = function(trackId) {
        for (var iterator$t = this.tracks.iterator(); iterator$t.hasNext(); ) {
            var t = iterator$t.next();
            if (t.getTrackId() == trackId) {
                return true;
            }
        }
        return false;
    };
    prototype.getTracks = function() {
        return Collections.unmodifiableList(this.tracks);
    };
    prototype.finish = function() {
        Preconditions.checkState(this.tracks.size() != 0, "Can not save header with 0 tracks.");
        var movie = this.finalizeHeader();
        this.storeHeader(movie);
    };
    prototype.storeHeader = function(movie) {
        var mdatSize = this.out.position() - this.mdatOffset + 8;
        MP4Util.writeMovie(this.out, movie);
        this.out.setPosition(this.mdatOffset);
        NIOUtils.writeLong(this.out, mdatSize);
    };
    prototype.finalizeHeader = function() {
        var movie = MovieBox.createMovieBox();
        var mvhd = this.movieHeader();
        movie.addFirst(mvhd);
        for (var iterator$track = this.tracks.iterator(); iterator$track.hasNext(); ) {
            var track = iterator$track.next();
            var trak = track.finish(mvhd);
            if (trak != null) 
                movie.add(trak);
        }
        return movie;
    };
    prototype.getVideoTrack = function() {
        for (var iterator$frameMuxer = this.tracks.iterator(); iterator$frameMuxer.hasNext(); ) {
            var frameMuxer = iterator$frameMuxer.next();
            if (frameMuxer.isVideo()) {
                return frameMuxer;
            }
        }
        return null;
    };
    prototype.getTimecodeTrack = function() {
        for (var iterator$frameMuxer = this.tracks.iterator(); iterator$frameMuxer.hasNext(); ) {
            var frameMuxer = iterator$frameMuxer.next();
            if (frameMuxer.isTimecode()) {
                return frameMuxer;
            }
        }
        return null;
    };
    prototype.getAudioTracks = function() {
        var result = new ArrayList();
        for (var iterator$frameMuxer = this.tracks.iterator(); iterator$frameMuxer.hasNext(); ) {
            var frameMuxer = iterator$frameMuxer.next();
            if (frameMuxer.isAudio()) {
                result.add(frameMuxer);
            }
        }
        return result;
    };
    prototype.movieHeader = function() {
        var timescale = this.tracks.get(0).getTimescale();
        var duration = this.tracks.get(0).getTrackTotalDuration();
        var videoTrack = this.getVideoTrack();
        if (videoTrack != null) {
            timescale = videoTrack.getTimescale();
            duration = videoTrack.getTrackTotalDuration();
        }
        return MovieHeaderBox.createMovieHeaderBox(timescale, duration, 1.0, 1.0, new jsutil.Date().getTime(), new jsutil.Date().getTime(), new Int32Array([65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]), this.nextTrackId);
    };
    prototype.addPCMAudioTrack = function(format) {
        return this.addTrack(new PCMMP4MuxerTrack(this.nextTrackId++, format));
    };
    prototype.addCompressedAudioTrack = function(codec, format) {
        var track = this.doAddTrack(MP4TrackType.SOUND, codec);
        track.addAudioSampleEntry(format);
        return track;
    };
    prototype.addVideoTrack = function(codec, meta) {
        var track = this.doAddTrack(MP4TrackType.VIDEO, codec);
        Preconditions.checkArgument(meta != null || codec == Codec.H264, "VideoCodecMeta is required upfront for all codecs but H.264");
        track.addVideoSampleEntry(meta);
        return track;
    };
    prototype.addAudioTrack = function(codec, meta) {
        var format = meta.getFormat();
        if (codec == Codec.PCM) {
            return this.addPCMAudioTrack(format);
        } else {
            return this.addCompressedAudioTrack(codec, format);
        }
    };
}, {tracks: {name: "List", arguments: ["AbstractMP4MuxerTrack"]}, out: "SeekableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Demuxer frontend for MP4
 *  
 *  @author The JCodec project
 *  
 */
var MP4Demuxer = function(input) {
    this.input = input;
    this.tracks = new LinkedList();
    this.findMovieBox(input);
};
MP4Demuxer = stjs.extend(MP4Demuxer, null, [Demuxer], function(constructor, prototype) {
    prototype.tracks = null;
    prototype.timecodeTrack = null;
    prototype.movie = null;
    prototype.input = null;
    constructor.createMP4Demuxer = function(input) {
        return new MP4Demuxer(input);
    };
    constructor.createRawMP4Demuxer = function(input) {
        return new (stjs.extend(function MP4Demuxer$1(input) {
            MP4Demuxer.call(this, input);
        }, MP4Demuxer, [], function(constructor, prototype) {
            prototype.newTrack = function(trak) {
                return new MP4DemuxerTrack(this.movie, trak, this.input);
            };
        }, {tracks: {name: "List", arguments: ["AbstractMP4DemuxerTrack"]}, timecodeTrack: "TimecodeMP4DemuxerTrack", movie: "MovieBox", input: "SeekableByteChannel"}, {}))(input);
    };
    prototype.fromTrakBox = function(trak) {
        var stsz = NodeBox.findFirstPath(trak, SampleSizesBox, Box.path("mdia.minf.stbl.stsz"));
        if (stsz.getDefaultSize() == 0) 
            return this.newTrack(trak);
        return new PCMMP4DemuxerTrack(this.movie, trak, this.input);
    };
    prototype.newTrack = function(trak) {
        return new CodecMP4DemuxerTrack(this.movie, trak, this.input);
    };
    prototype.findMovieBox = function(input) {
        var mv = MP4Util.parseFullMovieChannel(input);
        if (mv == null || mv.getMoov() == null) 
             throw new IOException("Could not find movie meta information box");
        this.movie = mv.getMoov();
        this.processHeader(this.movie);
    };
    prototype.processHeader = function(moov) {
        var tt = null;
        var trakBoxs = NodeBox.findAll(moov, TrakBox, "trak");
        for (var i = 0; i < trakBoxs.length; i++) {
            var trak = trakBoxs[i];
            var se = NodeBox.findFirstPath(trak, SampleEntry, ["mdia", "minf", "stbl", "stsd", null]);
            if (se != null && "tmcd".equals(se.getFourcc())) {
                tt = trak;
            } else {
                this.tracks.add(this.fromTrakBox(trak));
            }
        }
        if (tt != null) {
            var video = this.getVideoTrack();
            if (video != null) 
                this.timecodeTrack = new TimecodeMP4DemuxerTrack(this.movie, tt, this.input);
        }
    };
    constructor.getTrackType = function(trak) {
        var handler = NodeBox.findFirstPath(trak, HandlerBox, Box.path("mdia.hdlr"));
        return MP4TrackType.fromHandler(handler.getComponentSubType());
    };
    prototype.getVideoTrack = function() {
        for (var iterator$demuxerTrack = this.tracks.iterator(); iterator$demuxerTrack.hasNext(); ) {
            var demuxerTrack = iterator$demuxerTrack.next();
            if (demuxerTrack.box.isVideo()) 
                return demuxerTrack;
        }
        return null;
    };
    prototype.getMovie = function() {
        return this.movie;
    };
    prototype.getTrack = function(no) {
        for (var iterator$track = this.tracks.iterator(); iterator$track.hasNext(); ) {
            var track = iterator$track.next();
            if (track.getNo() == no) 
                return track;
        }
        return null;
    };
    prototype.getTracks = function() {
        return new ArrayList(this.tracks);
    };
    prototype.getVideoTracks = function() {
        var result = new ArrayList();
        for (var iterator$demuxerTrack = this.tracks.iterator(); iterator$demuxerTrack.hasNext(); ) {
            var demuxerTrack = iterator$demuxerTrack.next();
            if (demuxerTrack.box.isVideo()) 
                result.add(demuxerTrack);
        }
        return result;
    };
    prototype.getAudioTracks = function() {
        var result = new ArrayList();
        for (var iterator$demuxerTrack = this.tracks.iterator(); iterator$demuxerTrack.hasNext(); ) {
            var demuxerTrack = iterator$demuxerTrack.next();
            if (demuxerTrack.box.isAudio()) 
                result.add(demuxerTrack);
        }
        return result;
    };
    prototype.getTimecodeTrack = function() {
        return this.timecodeTrack;
    };
    constructor.probe = function(b) {
        var fork = b.duplicate();
        var success = 0;
        var total = 0;
         while (fork.remaining() >= 8){
            var len = Platform.unsignedInt(fork.getInt());
            var fcc = fork.getInt();
            var hdrLen = 8;
            if (len == 1) {
                len = fork.getLong();
                hdrLen = 16;
            } else if (len < 8) 
                break;
            if (fcc == Fourcc.ftyp && len < 64 || fcc == Fourcc.moov && len < 100 * 1024 * 1024 || fcc == Fourcc.free || fcc == Fourcc.mdat || fcc == Fourcc.wide) 
                success++;
            total++;
            if (len >= Integer.MAX_VALUE) 
                break;
            NIOUtils.skip(fork, (((len - hdrLen)) | 0));
        }
        return total == 0 ? 0 : stjs.trunc(success * 100 / total);
    };
    prototype.close = function() {
        this.input.close();
    };
}, {tracks: {name: "List", arguments: ["AbstractMP4DemuxerTrack"]}, timecodeTrack: "TimecodeMP4DemuxerTrack", movie: "MovieBox", input: "SeekableByteChannel"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Self contained movie creator
 *  
 *  @author The JCodec project
 *  
 */
var Flattern = function() {
    this.listeners = new ArrayList();
};
Flattern = stjs.extend(Flattern, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 2) {
            System.out.println("Syntax: self <ref movie> <out movie>");
            System.exit(-1);
        }
        var outFile = new File(args[1]);
        Platform.deleteFile(outFile);
        var input = null;
        try {
            input = NIOUtils.readableChannel(new File(args[0]));
            var movie = MP4Util.parseFullMovieChannel(input);
            new Flattern().flattern(movie, outFile);
        } finally {
            if (input != null) 
                input.close();
        }
    };
    prototype.listeners = null;
    constructor.ProgressListener = function() {};
    constructor.ProgressListener = stjs.extend(constructor.ProgressListener, null, [], function(constructor, prototype) {
        prototype.trigger = function(progress) {};
    }, {}, {});
    prototype.addProgressListener = function(listener) {
        this.listeners.add(listener);
    };
    prototype.flatternChannel = function(movie, out) {
        var ftyp = movie.getFtyp();
        var moov = movie.getMoov();
        if (!moov.isPureRefMovie()) 
             throw new IllegalArgumentException("movie should be reference");
        out.setPosition(0);
        MP4Util.writeFullMovie(out, movie);
        var extraSpace = this.calcSpaceReq(moov);
        var buf = ByteBuffer.allocate(extraSpace);
        out.write(buf);
        var mdatOff = out.position();
        this.writeHeader(Header.createHeader("mdat", 4294967297), out);
        var inputs = this.getInputs(moov);
        var tracks = moov.getTracks();
        var readers = Array(tracks.length);
        var writers = Array(tracks.length);
        var head = Array(tracks.length);
        var totalChunks = 0, writtenChunks = 0, lastProgress = 0;
        var off = Array(tracks.length);
        for (var i = 0; i < tracks.length; i++) {
            readers[i] = new ChunkReader(tracks[i]);
            totalChunks += readers[i].size();
            writers[i] = new ChunkWriter(tracks[i], inputs[i], out);
            head[i] = readers[i].next();
            if (tracks[i].isVideo()) 
                off[i] = 2 * moov.getTimescale();
        }
         while (true){
            var min = -1;
            for (var i = 0; i < readers.length; i++) {
                if (head[i] == null) 
                    continue;
                if (min == -1) 
                    min = i;
                 else {
                    var iTv = moov.rescale(head[i].getStartTv(), tracks[i].getTimescale()) + off[i];
                    var minTv = moov.rescale(head[min].getStartTv(), tracks[min].getTimescale()) + off[min];
                    if (iTv < minTv) 
                        min = i;
                }
            }
            if (min == -1) 
                break;
            writers[min].write(head[min]);
            head[min] = readers[min].next();
            writtenChunks++;
            lastProgress = this.calcProgress(totalChunks, writtenChunks, lastProgress);
        }
        for (var i = 0; i < tracks.length; i++) {
            writers[i].apply();
        }
        var mdatSize = out.position() - mdatOff;
        out.setPosition(0);
        MP4Util.writeFullMovie(out, movie);
        var extra = mdatOff - out.position();
        if (extra < 0) 
             throw new RuntimeException("Not enough space to write the header");
        this.writeHeader(Header.createHeader("free", extra), out);
        out.setPosition(mdatOff);
        this.writeHeader(Header.createHeader("mdat", mdatSize), out);
    };
    prototype.writeHeader = function(header, out) {
        var bb = ByteBuffer.allocate(16);
        header.write(bb);
        bb.flip();
        out.write(bb);
    };
    prototype.calcProgress = function(totalChunks, writtenChunks, lastProgress) {
        var curProgress = stjs.trunc(100 * writtenChunks / totalChunks);
        if (lastProgress < curProgress) {
            lastProgress = curProgress;
            for (var iterator$pl = this.listeners.iterator(); iterator$pl.hasNext(); ) {
                var pl = iterator$pl.next();
                pl.trigger(lastProgress);
            }
        }
        return lastProgress;
    };
    prototype.getInputs = function(movie) {
        var tracks = movie.getTracks();
        var result = Array(tracks.length);
        for (var i = 0; i < tracks.length; i++) {
            var drefs = NodeBox.findFirstPath(tracks[i], DataRefBox, Box.path("mdia.minf.dinf.dref"));
            if (drefs == null) {
                 throw new RuntimeException("No data references");
            }
            var entries = drefs.getBoxes();
            var e = Array(entries.size());
            var inputs = Array(entries.size());
            for (var j = 0; j < e.length; j++) {
                inputs[j] = this.resolveDataRef(entries.get(j));
            }
            result[i] = inputs;
        }
        return result;
    };
    prototype.calcSpaceReq = function(movie) {
        var sum = 0;
        var tracks = movie.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            var stco = trakBox.getStco();
            if (stco != null) 
                sum += stco.getChunkOffsets().length * 4;
        }
        return sum;
    };
    prototype.resolveDataRef = function(box) {
        if (stjs.isInstanceOf(box.constructor, UrlBox)) {
            var url = (box).getUrl();
            if (!url.startsWith("file://")) 
                 throw new RuntimeException("Only file:// urls are supported in data reference");
            return NIOUtils.readableChannel(new File(url.substring(7)));
        } else if (stjs.isInstanceOf(box.constructor, AliasBox)) {
            var uxPath = (box).getUnixPath();
            if (uxPath == null) 
                 throw new RuntimeException("Could not resolve alias");
            return NIOUtils.readableChannel(new File(uxPath));
        } else {
             throw new RuntimeException(box.getHeader().getFourcc() + " dataref type is not supported");
        }
    };
    prototype.flattern = function(movie, video) {
        Platform.deleteFile(video);
        var out = null;
        try {
            out = NIOUtils.writableChannel(video);
            this.flatternChannel(movie, out);
        } finally {
            if (out != null) 
                out.close();
        }
    };
}, {listeners: {name: "List", arguments: ["Flattern.ProgressListener"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MovDump = function() {};
MovDump = stjs.extend(MovDump, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 1) {
            System.out.println("Syntax: movdump [options] <filename>");
            System.out.println("Options: \n\t-f <filename> save header to a file\n\t-a <atom name> dump only a specific atom\n");
            return;
        }
        var idx = 0;
        var headerFile = null;
        var atom = null;
         while (idx < args.length){
            if ("-f".equals(args[idx])) {
                ++idx;
                headerFile = new File(args[idx++]);
            } else if ("-a".equals(args[idx])) {
                ++idx;
                atom = args[idx++];
            } else 
                break;
        }
        var source = new File(args[idx]);
        if (headerFile != null) {
            MovDump.dumpHeader(headerFile, source);
        }
        if (atom == null) 
            System.out.println(MovDump.print(source));
         else {
            var dump = MovDump.printAtom(source, atom);
            if (dump != null) 
                System.out.println(dump);
        }
    };
    constructor.dumpHeader = function(headerFile, source) {
        var raf = null;
        var daos = null;
        try {
            raf = NIOUtils.readableChannel(source);
            daos = NIOUtils.writableChannel(headerFile);
            for (var iterator$atom = MP4Util.getRootAtoms(raf).iterator(); iterator$atom.hasNext(); ) {
                var atom = iterator$atom.next();
                var fourcc = atom.getHeader().getFourcc();
                if ("moov".equals(fourcc) || "ftyp".equals(fourcc)) {
                    atom.copy(raf, daos);
                }
            }
        } finally {
            IOUtils.closeQuietly(raf);
            IOUtils.closeQuietly(daos);
        }
    };
    constructor.print = function(file) {
        return MP4Util.parseMovie(file).toString();
    };
    constructor.findDeep = function(root, atom) {
        for (var iterator$b = root.getBoxes().iterator(); iterator$b.hasNext(); ) {
            var b = iterator$b.next();
            if (atom.equalsIgnoreCase(b.getFourcc())) {
                return b;
            } else if (stjs.isInstanceOf(b.constructor, NodeBox)) {
                var res = MovDump.findDeep(b, atom);
                if (res != null) 
                    return res;
            }
        }
        return null;
    };
    constructor.printAtom = function(file, atom) {
        var mov = MP4Util.parseMovie(file);
        var found = MovDump.findDeep(mov, atom);
        if (found == null) {
            System.out.println("Atom " + atom + " not found.");
            return null;
        }
        return found.toString();
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SampleOffsetUtils = function() {};
SampleOffsetUtils = stjs.extend(SampleOffsetUtils, null, [], function(constructor, prototype) {
    constructor.getSampleData = function(sample, file) {
        var moov = MP4Util.parseMovie(file);
        var minf = moov.getAudioTracks().get(0).getMdia().getMinf();
        var stco = NodeBox.findFirstPath(minf, ChunkOffsetsBox, Box.path("stbl.stco"));
        var stsc = NodeBox.findFirstPath(minf, SampleToChunkBox, Box.path("stbl.stsc"));
        var stsz = NodeBox.findFirstPath(minf, SampleSizesBox, Box.path("stbl.stsz"));
        var sampleOffset = SampleOffsetUtils.getSampleOffset(sample, stsc, stco, stsz);
        var map = NIOUtils.mapFile(file);
        map.setPosition(((sampleOffset) | 0));
        map.setLimit(map.position() + stsz.getSizes()[sample]);
        return map;
    };
    constructor.getSampleOffset = function(sample, stsc, stco, stsz) {
        var chunkBySample = SampleOffsetUtils.getChunkBySample(sample, stco, stsc);
        var firstSampleAtChunk = SampleOffsetUtils.getFirstSampleAtChunk(chunkBySample, stsc, stco);
        var offset = stco.getChunkOffsets()[chunkBySample - 1];
        var sizes = stsz.getSizes();
        for (var i = firstSampleAtChunk; i < sample; i++) {
            offset += sizes[i];
        }
        return offset;
    };
    constructor.getFirstSampleAtChunk = function(chunk, stsc, stco) {
        var chunks = stco.getChunkOffsets().length;
        var samples = 0;
        for (var i = 1; i <= chunks; i++) {
            if (i == chunk) {
                break;
            }
            var samplesInChunk = SampleOffsetUtils.getSamplesInChunk(i, stsc);
            samples += samplesInChunk;
        }
        return samples;
    };
    constructor.getChunkBySample = function(sampleOfInterest, stco, stsc) {
        var chunks = stco.getChunkOffsets().length;
        var startSample = 0;
        var endSample = 0;
        for (var i = 1; i <= chunks; i++) {
            var samplesInChunk = SampleOffsetUtils.getSamplesInChunk(i, stsc);
            endSample = startSample + samplesInChunk;
            if (sampleOfInterest >= startSample && sampleOfInterest < endSample) {
                return i;
            }
            startSample = endSample;
        }
        return -1;
    };
    constructor.getSamplesInChunk = function(chunk, stsc) {
        var sampleToChunk = stsc.getSampleToChunk();
        var sampleCount = 0;
        for (var index$sampleToChunkEntry = 0, arr$sampleToChunkEntry = sampleToChunk; index$sampleToChunkEntry < arr$sampleToChunkEntry.length; index$sampleToChunkEntry++) {
            var sampleToChunkEntry = arr$sampleToChunkEntry[index$sampleToChunkEntry];
            if (sampleToChunkEntry.getFirst() > chunk) {
                return sampleCount;
            }
            sampleCount = sampleToChunkEntry.getCount();
        }
        return sampleCount;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Strips movie to editlist
 *  
 *  @author The JCodec project
 *  
 */
var Strip = function() {};
Strip = stjs.extend(Strip, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 2) {
            System.out.println("Syntax: strip <ref movie> <out movie>");
            System.exit(-1);
        }
        var input = null;
        var out = null;
        try {
            input = NIOUtils.readableChannel(new File(args[0]));
            var file = new File(args[1]);
            Platform.deleteFile(file);
            out = NIOUtils.writableChannel(file);
            var movie = MP4Util.createRefFullMovie(input, "file://" + new File(args[0]).getAbsolutePath());
            new Strip().strip(movie.getMoov());
            MP4Util.writeFullMovie(out, movie);
        } finally {
            if (input != null) 
                input.close();
            if (out != null) 
                out.close();
        }
    };
    prototype.strip = function(movie) {
        var tracks = movie.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var track = tracks[i];
            this.stripTrack(movie, track);
        }
    };
    prototype.stripTrack = function(movie, track) {
        var chunks = new ChunkReader(track);
        var edits = track.getEdits();
        var oldEdits = this.deepCopy(edits);
        var result = new ArrayList();
        var chunk;
         while ((chunk = chunks.next()) != null){
            var intersects = false;
            for (var iterator$edit = oldEdits.iterator(); iterator$edit.hasNext(); ) {
                var edit = iterator$edit.next();
                if (edit.getMediaTime() == -1) 
                    continue;
                var editS = edit.getMediaTime();
                var editE = edit.getMediaTime() + track.rescale(edit.getDuration(), movie.getTimescale());
                var chunkS = chunk.getStartTv();
                var chunkE = chunk.getStartTv() + chunk.getDuration();
                intersects = this.intersects(editS, editE, chunkS, chunkE);
                if (intersects) 
                    break;
            }
            if (!intersects) {
                for (var i = 0; i < oldEdits.size(); i++) {
                    if (oldEdits.get(i).getMediaTime() >= chunk.getStartTv() + chunk.getDuration()) 
                        edits.get(i).shift(-chunk.getDuration());
                }
            } else 
                result.add(chunk);
        }
        var stbl = NodeBox.findFirstPath(track, NodeBox, Box.path("mdia.minf.stbl"));
        stbl.replace("stts", this.getTimeToSamples(result));
        stbl.replace("stsz", this.getSampleSizes(result));
        stbl.replace("stsc", this.getSamplesToChunk(result));
        stbl.removeChildren("stco", "co64");
        stbl.add(this.getChunkOffsets(result));
        NodeBox.findFirstPath(track, MediaHeaderBox, Box.path("mdia.mdhd")).setDuration(this.totalDuration(result));
    };
    prototype.totalDuration = function(result) {
        var duration = 0;
        for (var iterator$chunk = result.iterator(); iterator$chunk.hasNext(); ) {
            var chunk = iterator$chunk.next();
            duration += chunk.getDuration();
        }
        return duration;
    };
    prototype.deepCopy = function(edits) {
        var newList = new ArrayList();
        for (var iterator$edit = edits.iterator(); iterator$edit.hasNext(); ) {
            var edit = iterator$edit.next();
            newList.add(Edit.createEdit(edit));
        }
        return newList;
    };
    prototype.getChunkOffsets = function(chunks) {
        var result = Array(chunks.size());
        var longBox = false;
        var i = 0;
        for (var iterator$chunk = chunks.iterator(); iterator$chunk.hasNext(); ) {
            var chunk = iterator$chunk.next();
            if (chunk.getOffset() >= 4294967296) 
                longBox = true;
            result[i++] = chunk.getOffset();
        }
        return longBox ? ChunkOffsets64Box.createChunkOffsets64Box(result) : ChunkOffsetsBox.createChunkOffsetsBox(result);
    };
    prototype.getTimeToSamples = function(chunks) {
        var tts = new ArrayList();
        var curTts = -1, cnt = 0;
        for (var iterator$chunk = chunks.iterator(); iterator$chunk.hasNext(); ) {
            var chunk = iterator$chunk.next();
            if (chunk.getSampleDur() > 0) {
                if (curTts == -1 || curTts != chunk.getSampleDur()) {
                    if (curTts != -1) 
                        tts.add(new TimeToSampleBox.TimeToSampleEntry(cnt, curTts));
                    cnt = 0;
                    curTts = chunk.getSampleDur();
                }
                cnt += chunk.getSampleCount();
            } else {
                for (var index$dur = 0, arr$dur = chunk.getSampleDurs(); index$dur < arr$dur.length; index$dur++) {
                    var dur = arr$dur[index$dur];
                    if (curTts == -1 || curTts != dur) {
                        if (curTts != -1) 
                            tts.add(new TimeToSampleBox.TimeToSampleEntry(cnt, curTts));
                        cnt = 0;
                        curTts = dur;
                    }
                    ++cnt;
                }
            }
        }
        if (cnt > 0) 
            tts.add(new TimeToSampleBox.TimeToSampleEntry(cnt, curTts));
        return TimeToSampleBox.createTimeToSampleBox(tts.toArray(Array(0)));
    };
    prototype.getSampleSizes = function(chunks) {
        var nSamples = 0, prevSize = chunks.get(0).getSampleSize();
        for (var iterator$chunk = chunks.iterator(); iterator$chunk.hasNext(); ) {
            var chunk = iterator$chunk.next();
            nSamples += chunk.getSampleCount();
            if (prevSize == 0 && chunk.getSampleSize() != 0) 
                 throw new RuntimeException("Mixed sample sizes not supported");
        }
        if (prevSize > 0) 
            return SampleSizesBox.createSampleSizesBox(prevSize, nSamples);
        var sizes = new Int32Array(nSamples);
        var startSample = 0;
        for (var iterator$chunk = chunks.iterator(); iterator$chunk.hasNext(); ) {
            var chunk = iterator$chunk.next();
            System.arraycopy(chunk.getSampleSizes(), 0, sizes, startSample, chunk.getSampleCount());
            startSample += chunk.getSampleCount();
        }
        return SampleSizesBox.createSampleSizesBox2(sizes);
    };
    prototype.getSamplesToChunk = function(chunks) {
        var result = new ArrayList();
        var it = chunks.iterator();
        var chunk = it.next();
        var curSz = chunk.getSampleCount();
        var curEntry = chunk.getEntry();
        var first = 1, cnt = 1;
         while (it.hasNext()){
            chunk = it.next();
            var newSz = chunk.getSampleCount();
            var newEntry = chunk.getEntry();
            if (curSz != newSz || curEntry != newEntry) {
                result.add(new SampleToChunkBox.SampleToChunkEntry(first, curSz, curEntry));
                curSz = newSz;
                curEntry = newEntry;
                first += cnt;
                cnt = 0;
            }
            ++cnt;
        }
        if (cnt > 0) 
            result.add(new SampleToChunkBox.SampleToChunkEntry(first, curSz, curEntry));
        return SampleToChunkBox.createSampleToChunkBox(result.toArray(Array(0)));
    };
    prototype.intersects = function(a, b, c, d) {
        return (a >= c && a < d) || (b >= c && b < d) || (c >= a && c < b) || (d >= a && d < b);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Parses MP4 header and allows custom MP4Editor to modify it, then tries to put
 *  the resulting header into the same place relatively to a file.
 *  
 *  This might not work out, for example if the resulting header is bigger then
 *  the original.
 *  
 *  Use this class to make blazing fast changes to MP4 files when you know your
 *  are not adding anything new to the header, perhaps only patching some values
 *  or removing stuff from the header.
 *  
 *  @author The JCodec project
 *  
 */
var InplaceMP4Editor = function() {};
InplaceMP4Editor = stjs.extend(InplaceMP4Editor, null, [], function(constructor, prototype) {
    /**
     *  Tries to modify movie header in place according to what's implemented in
     *  the edit, the file gets pysically modified if the operation is
     *  successful. No temporary file is created.
     *  
     *  @param file
     *             A file to be modified
     *  @param edit
     *             An edit to be carried out on a movie header
     *  @return Whether or not edit was successful, i.e. was there enough place
     *          to put the new header
     *  @throws IOException
     *  @throws Exception
     */
    prototype.modify = function(file, edit) {
        var fi = null;
        try {
            fi = NIOUtils.rwChannel(file);
            var fragments = this.doTheFix(fi, edit);
            if (fragments == null) 
                return false;
            for (var iterator$fragment = fragments.iterator(); iterator$fragment.hasNext(); ) {
                var fragment = iterator$fragment.next();
                this.replaceBox(fi, fragment.v0, fragment.v1);
            }
            return true;
        } finally {
            NIOUtils.closeQuietly(fi);
        }
    };
    /**
     *  Tries to modify movie header in place according to what's implemented in
     *  the edit. Copies modified contents to a new file.
     *  
     *  Note: The header is still edited in-place, so the new file will have
     *  all-the-same sample offsets.
     *  
     *  Note: Still subject to the same limitations as 'modify', i.e. the new
     *  header must 'fit' into an old place.
     *  
     *  This method is useful when you can't write to the original file, for ex.
     *  you don't have permission.
     *  
     *  @param src
     *             An original file
     *  @param dst
     *             A file to store the modified copy
     *  @param edit
     *             An edit logic to apply
     *  @return
     *  @throws IOException
     */
    prototype.copy = function(src, dst, edit) {
        var fi = null;
        var fo = null;
        try {
            fi = NIOUtils.readableChannel(src);
            fo = NIOUtils.writableChannel(dst);
            var fragments = this.doTheFix(fi, edit);
            if (fragments == null) 
                return false;
            var fragOffsets = Tuple._2map0(fragments, new (stjs.extend(function InplaceMP4Editor$1() {}, null, [Tuple.Mapper], function(constructor, prototype) {
                prototype.map = function(t) {
                    return t.getOffset();
                };
            }, {}, {}))());
            var rewrite = Tuple.asMap(fragOffsets);
            for (var iterator$atom = MP4Util.getRootAtoms(fi).iterator(); iterator$atom.hasNext(); ) {
                var atom = iterator$atom.next();
                var byteBuffer = rewrite.get(atom.getOffset());
                if (byteBuffer != null) 
                    fo.write(byteBuffer);
                 else 
                    atom.copy(fi, fo);
            }
            return true;
        } finally {
            NIOUtils.closeQuietly(fi);
            NIOUtils.closeQuietly(fo);
        }
    };
    /**
     *  Tries to modify movie header in place according to what's implemented in
     *  the edit. Copies modified contents to a new file with the same name
     *  erasing the original file if successful.
     *  
     *  This is a shortcut for 'copy' when you want the new file to have the same
     *  name but for some reason can not modify the original file in place. Maybe
     *  modifications of files are expensive or not supported on your filesystem.
     *  
     *  @param src
     *             A source and destination file
     *  @param edit
     *             An edit to be applied
     *  @return
     *  @throws IOException
     */
    prototype.replace = function(src, edit) {
        var tmp = new File(src.getParentFile(), "." + src.getName());
        if (this.copy(src, tmp, edit)) {
            tmp.renameTo(src);
            return true;
        }
        return false;
    };
    prototype.doTheFix = function(fi, edit) {
        var moovAtom = this.getMoov(fi);
        Preconditions.checkNotNull(moovAtom);
        var moovBuffer = this.fetchBox(fi, moovAtom);
        var moovBox = this.parseBox(moovBuffer);
        var fragments = new LinkedList();
        if (BoxUtil.containsBox(moovBox, "mvex")) {
            var temp = new LinkedList();
            for (var iterator$fragAtom = this.getFragments(fi).iterator(); iterator$fragAtom.hasNext(); ) {
                var fragAtom = iterator$fragAtom.next();
                var fragBuffer = this.fetchBox(fi, fragAtom);
                fragments.add(Tuple.pair(fragAtom, fragBuffer));
                var fragBox = this.parseBox(fragBuffer);
                fragBox.setMovie(moovBox);
                temp.add(Tuple.pair(fragBuffer, fragBox));
            }
            edit.applyToFragment(moovBox, Tuple._2_project1(temp).toArray(Array(0)));
            for (var iterator$frag = temp.iterator(); iterator$frag.hasNext(); ) {
                var frag = iterator$frag.next();
                if (!this.rewriteBox(frag.v0, frag.v1)) 
                    return null;
            }
        } else 
            edit.apply(moovBox);
        if (!this.rewriteBox(moovBuffer, moovBox)) 
            return null;
        fragments.add(Tuple.pair(moovAtom, moovBuffer));
        return fragments;
    };
    prototype.replaceBox = function(fi, atom, buffer) {
        fi.setPosition(atom.getOffset());
        fi.write(buffer);
    };
    prototype.rewriteBox = function(buffer, box) {
        try {
            buffer.clear();
            box.write(buffer);
            if (buffer.hasRemaining()) {
                if (buffer.remaining() < 8) 
                    return false;
                buffer.putInt(buffer.remaining());
                buffer.putArr(new Int8Array(['f'.charCodeAt(0), 'r'.charCodeAt(0), 'e'.charCodeAt(0), 'e'.charCodeAt(0)]));
            }
            buffer.flip();
            return true;
        }catch (e) {
            return false;
        }
    };
    prototype.fetchBox = function(fi, moov) {
        fi.setPosition(moov.getOffset());
        var oldMov = NIOUtils.fetchFromChannel(fi, ((moov.getHeader().getSize()) | 0));
        return oldMov;
    };
    prototype.parseBox = function(oldMov) {
        var header = Header.read(oldMov);
        var box = BoxUtil.parseBox(oldMov, header, BoxFactory.getDefault());
        return box;
    };
    prototype.getMoov = function(f) {
        for (var iterator$atom = MP4Util.getRootAtoms(f).iterator(); iterator$atom.hasNext(); ) {
            var atom = iterator$atom.next();
            if ("moov".equals(atom.getHeader().getFourcc())) {
                return atom;
            }
        }
        return null;
    };
    prototype.getFragments = function(f) {
        var result = new LinkedList();
        for (var iterator$atom = MP4Util.getRootAtoms(f).iterator(); iterator$atom.hasNext(); ) {
            var atom = iterator$atom.next();
            if ("moof".equals(atom.getHeader().getFourcc())) {
                result.add(atom);
            }
        }
        return result;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Uses QuickTime feature to undo the recent changes
 *  
 *  @author The JCodec project
 *  
 */
var Undo = function() {};
Undo = stjs.extend(Undo, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 1) {
            System.err.println("Syntax: qt-undo [-l] <movie>");
            System.err.println("\t-l\t\tList all the previous versions of this movie.");
            System.exit(-1);
        }
        var undo = new Undo();
        if ("-l".equals(args[0])) {
            var list = undo.list(args[1]);
            System.out.println((list.size() - 1) + " versions.");
        } else {
            undo.undo(args[0]);
        }
    };
    prototype.undo = function(fineName) {
        var versions = this.list(fineName);
        if (versions.size() < 2) {
            System.err.println("Nowhere to rollback.");
            return;
        }
        var raf = null;
        try {
            raf = new RandomAccessFile(new File(fineName), "rw");
            raf.seek(versions.get(versions.size() - 2).getOffset() + 4);
            raf.write(new Int8Array(['m'.charCodeAt(0), 'o'.charCodeAt(0), 'o'.charCodeAt(0), 'v'.charCodeAt(0)]));
            raf.seek(versions.get(versions.size() - 1).getOffset() + 4);
            raf.write(new Int8Array(['f'.charCodeAt(0), 'r'.charCodeAt(0), 'e'.charCodeAt(0), 'e'.charCodeAt(0)]));
        } finally {
            IOUtils.closeQuietly(raf);
        }
    };
    prototype.list = function(fileName) {
        var result = new ArrayList();
        var is = null;
        try {
            is = NIOUtils.readableChannel(new File(fileName));
            var version = 0;
            for (var iterator$atom = MP4Util.getRootAtoms(is).iterator(); iterator$atom.hasNext(); ) {
                var atom = iterator$atom.next();
                if ("free".equals(atom.getHeader().getFourcc()) && this.isMoov(is, atom)) {
                    result.add(atom);
                }
                if ("moov".equals(atom.getHeader().getFourcc())) {
                    result.add(atom);
                    break;
                }
            }
        } finally {
            IOUtils.closeQuietly(is);
        }
        return result;
    };
    prototype.isMoov = function(is, atom) {
        is.setPosition(atom.getOffset() + atom.getHeader().headerSize());
        try {
            var mov = BoxUtil.parseBox(NIOUtils.fetchFromChannel(is, ((atom.getHeader().getSize()) | 0)), Header.createHeader("moov", atom.getHeader().getSize()), BoxFactory.getDefault());
            return (stjs.isInstanceOf(mov.constructor, MovieBox)) && BoxUtil.containsBox(mov, "mvhd");
        }catch (t) {
            return false;
        }
    };
}, {}, {});
var MTSRandomAccessDemuxerMain = function() {};
MTSRandomAccessDemuxerMain = stjs.extend(MTSRandomAccessDemuxerMain, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        var indexer = new MTSIndexer();
        var source = new File(args[0]);
        var index;
        var indexFile = new File(source.getParentFile(), source.getName() + ".idx");
        if (!indexFile.exists()) {
            indexer.index(source, null);
            index = indexer.serialize();
            NIOUtils.writeTo(index.serialize(), indexFile);
        } else {
            System.out.println("Reading index from: " + indexFile.getName());
            index = MTSIndex.parse(NIOUtils.fetchFromFile(indexFile));
        }
        var demuxer = new MTSRandomAccessDemuxer(NIOUtils.readableChannel(source), index);
        var guids = demuxer.getGuids();
        var video = MTSRandomAccessDemuxerMain.getVideoStream(demuxer.getProgramDemuxer(guids[0]));
        var ch = NIOUtils.writableChannel(new File(args[1]));
        var mp4Muxer = MP4Muxer.createMP4Muxer(ch, Brand.MOV);
        video.gotoSyncFrame(175);
        var pkt = video.nextFrame();
        var meta = new MPEGDecoder().getCodecMeta(pkt.getData());
        var videoTrack = mp4Muxer.addVideoTrack(Codec.MPEG2, meta);
        var firstPts = pkt.getPts();
        for (var i = 0; pkt != null && i < 150; i++) {
            videoTrack.addFrame(MP4Packet.createMP4Packet(pkt.getData(), pkt.getPts() - firstPts, pkt.getTimescale(), pkt.getDuration(), pkt.getFrameNo(), pkt.getFrameType(), pkt.getTapeTimecode(), 0, pkt.getPts() - firstPts, 0));
            pkt = video.nextFrame();
        }
        mp4Muxer.finish();
        NIOUtils.closeQuietly(ch);
    };
    constructor.getVideoStream = function(demuxer) {
        var streams = demuxer.getStreams();
        for (var index$stream = 0, arr$stream = streams; index$stream < arr$stream.length; index$stream++) {
            var stream = arr$stream[index$stream];
            if (stream.getStreamId() >= 224 && stream.getStreamId() <= 239) 
                return stream;
        }
        return null;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var WebOptimizedMP4Muxer = function(output, brand, headerSize) {
    MP4Muxer.call(this, output, brand.getFileTypeBox());
    this.headerPos = output.position() - 24;
    output.setPosition(this.headerPos);
    this.header = ByteBuffer.allocate(headerSize);
    output.write(this.header);
    this.header.clear();
    Header.createHeader("wide", 8).writeChannel(output);
    Header.createHeader("mdat", 1).writeChannel(output);
    this.mdatOffset = output.position();
    NIOUtils.writeLong(output, 0);
};
WebOptimizedMP4Muxer = stjs.extend(WebOptimizedMP4Muxer, MP4Muxer, [], function(constructor, prototype) {
    prototype.header = null;
    prototype.headerPos = 0;
    constructor.withOldHeader = function(output, brand, oldHeader) {
        var size = ((oldHeader.getHeader().getSize()) | 0);
        var vt = oldHeader.getVideoTrack();
        var stsc = vt.getStsc();
        size -= stsc.getSampleToChunk().length * 12;
        size += 12;
        var stco = vt.getStco();
        if (stco != null) {
            size -= stco.getChunkOffsets().length << 2;
            size += vt.getFrameCount() << 3;
        } else {
            var co64 = vt.getCo64();
            size -= co64.getChunkOffsets().length << 3;
            size += vt.getFrameCount() << 3;
        }
        return new WebOptimizedMP4Muxer(output, brand, size + (size >> 1));
    };
    prototype.storeHeader = function(movie) {
        var mdatEnd = this.out.position();
        var mdatSize = mdatEnd - this.mdatOffset + 8;
        this.out.setPosition(this.mdatOffset);
        NIOUtils.writeLong(this.out, mdatSize);
        this.out.setPosition(this.headerPos);
        try {
            movie.write(this.header);
            this.header.flip();
            var rem = this.header.capacity() - this.header.limit();
            if (rem < 8) {
                this.header.duplicate().putInt(this.header.capacity());
            }
            this.out.write(this.header);
            if (rem >= 8) 
                Header.createHeader("free", rem).writeChannel(this.out);
        }catch (e) {
            Logger.warn("Could not web-optimize, header is bigger then allocated space.");
            Header.createHeader("free", this.header.remaining()).writeChannel(this.out);
            this.out.setPosition(mdatEnd);
            MP4Util.writeMovie(this.out, movie);
        }
    };
}, {header: "ByteBuffer", tracks: {name: "List", arguments: ["AbstractMP4MuxerTrack"]}, out: "SeekableByteChannel"}, {});
/**
 *  The sink that consumes the uncompressed frames and stores them into a
 *  compressed file.
 *  
 *  @author Stanislav Vitvitskiy
 */
var SinkImpl = function(destName, outputFormat, outputVideoCodec, outputAudioCodec) {
    if (destName == null && outputFormat == Format.IMG) 
         throw new IllegalArgumentException("A destination file should be specified for the image muxer.");
    this.destName = destName;
    this.outputFormat = outputFormat;
    this.outputVideoCodec = outputVideoCodec;
    this.outputAudioCodec = outputAudioCodec;
    this.outputFormat = outputFormat;
    this.bufferStore = new ThreadLocal();
};
SinkImpl = stjs.extend(SinkImpl, null, [Sink, PacketSink], function(constructor, prototype) {
    prototype.destName = null;
    prototype.destStream = null;
    prototype.muxer = null;
    prototype.videoOutputTrack = null;
    prototype.audioOutputTrack = null;
    prototype.framesOutput = false;
    prototype.outputVideoCodec = null;
    prototype.outputAudioCodec = null;
    prototype.outputFormat = null;
    prototype.bufferStore = null;
    prototype.audioEncoder = null;
    prototype.videoEncoder = null;
    prototype.profile = null;
    prototype.interlaced = false;
    prototype.outputVideoPacket = function(packet, codecMeta) {
        if (!this.outputFormat.isVideo()) 
            return;
        if (this.videoOutputTrack == null) {
            this.videoOutputTrack = this.muxer.addVideoTrack(this.outputVideoCodec, codecMeta);
        }
        this.videoOutputTrack.addFrame(packet);
        this.framesOutput = true;
    };
    prototype.outputAudioPacket = function(audioPkt, audioCodecMeta) {
        if (!this.outputFormat.isAudio()) 
            return;
        if (this.audioOutputTrack == null) {
            this.audioOutputTrack = this.muxer.addAudioTrack(this.outputAudioCodec, audioCodecMeta);
        }
        this.audioOutputTrack.addFrame(audioPkt);
        this.framesOutput = true;
    };
    prototype.initMuxer = function() {
        if (this.destStream == null && this.outputFormat != Format.IMG) 
            this.destStream = NIOUtils.writableFileChannel(this.destName);
        if (Format.MKV == this.outputFormat) {
            this.muxer = new MKVMuxer(this.destStream);
        } else if (Format.MOV == this.outputFormat) {
            this.muxer = MP4Muxer.createMP4MuxerToChannel(this.destStream);
        } else if (Format.IVF == this.outputFormat) {
            this.muxer = new IVFMuxer(this.destStream);
        } else if (Format.IMG == this.outputFormat) {
            this.muxer = new ImageSequenceMuxer(this.destName);
        } else if (Format.WAV == this.outputFormat) {
            this.muxer = new WavMuxer(this.destStream);
        } else if (Format.Y4M == this.outputFormat) {
            this.muxer = new Y4MMuxer(this.destStream);
        } else if (Format.RAW == this.outputFormat) {
            this.muxer = new RawMuxer(this.destStream);
        } else {
             throw new RuntimeException("The output format " + this.outputFormat + " is not supported.");
        }
    };
    prototype.finish = function() {
        if (this.framesOutput) {
            this.muxer.finish();
        } else {
            Logger.warn("No frames output.");
        }
        if (this.destStream != null) {
            IOUtils.closeQuietly(this.destStream);
        }
    };
    constructor.createWithStream = function(destStream, outputFormat, outputVideoCodec, outputAudioCodec) {
        var result = new SinkImpl(null, outputFormat, outputVideoCodec, outputAudioCodec);
        result.destStream = destStream;
        return result;
    };
    prototype.init = function() {
        this.initMuxer();
        if (this.outputFormat.isVideo() && this.outputVideoCodec != null) {
            if (Codec.PRORES == this.outputVideoCodec) {
                this.videoEncoder = ProresEncoder.createProresEncoder(this.profile, this.interlaced);
            } else if (Codec.H264 == this.outputVideoCodec) {
                this.videoEncoder = H264Encoder.createH264Encoder();
            } else if (Codec.VP8 == this.outputVideoCodec) {
                this.videoEncoder = VP8Encoder.createVP8Encoder(10);
            } else if (Codec.PNG == this.outputVideoCodec) {
                this.videoEncoder = new PNGEncoder();
            } else if (Codec.RAW == this.outputVideoCodec) {
                this.videoEncoder = new RAWVideoEncoder();
            } else {
                 throw new RuntimeException("Could not find encoder for the codec: " + this.outputVideoCodec);
            }
        }
    };
    prototype.encodeVideo = function(frame, _out) {
        if (!this.outputFormat.isVideo()) 
            return null;
        return this.videoEncoder.encodeFrame(frame, _out);
    };
    prototype.createAudioEncoder = function(codec, format) {
        if (codec != Codec.PCM) {
             throw new RuntimeException("Only PCM audio encoding (RAW audio) is supported.");
        }
        return new SinkImpl.RawAudioEncoder();
    };
    constructor.RawAudioEncoder = function() {};
    constructor.RawAudioEncoder = stjs.extend(constructor.RawAudioEncoder, null, [AudioEncoder], function(constructor, prototype) {
        prototype.encode = function(audioPkt, buf) {
            return audioPkt;
        };
    }, {}, {});
    prototype.encodeAudio = function(audioBuffer) {
        if (this.audioEncoder == null) {
            var format = audioBuffer.getFormat();
            this.audioEncoder = this.createAudioEncoder(this.outputAudioCodec, format);
        }
        return this.audioEncoder.encode(audioBuffer.getData(), null);
    };
    prototype.setProfile = function(profile) {
        this.profile = profile;
    };
    prototype.setInterlaced = function(interlaced) {
        this.interlaced = interlaced;
    };
    prototype.outputVideoFrame = function(videoFrame) {
        if (!this.outputFormat.isVideo() || this.outputVideoCodec == null) 
            return;
        var outputVideoPacket;
        var buffer = this.bufferStore.get();
        var bufferSize = this.videoEncoder.estimateBufferSize(videoFrame.getFrame().getPicture());
        if (buffer == null || bufferSize < buffer.capacity()) {
            buffer = ByteBuffer.allocate(bufferSize);
            this.bufferStore.set(buffer);
        }
        buffer.clear();
        var frame = videoFrame.getFrame().getPicture();
        var enc = this.encodeVideo(frame, buffer);
        outputVideoPacket = Packet.createPacketWithData(videoFrame.getPacket(), NIOUtils.clone(enc.getData()));
        outputVideoPacket.setFrameType(enc.isKeyFrame() ? Packet.FrameType.KEY : Packet.FrameType.INTER);
        this.outputVideoPacket(outputVideoPacket, VideoCodecMeta.createSimpleVideoCodecMeta(new Size(frame.getWidth(), frame.getHeight()), frame.getColor()));
    };
    prototype.outputAudioFrame = function(audioFrame) {
        if (!this.outputFormat.isAudio() || this.outputAudioCodec == null) 
            return;
        this.outputAudioPacket(Packet.createPacketWithData(audioFrame.getPacket(), this.encodeAudio(audioFrame.getAudio())), AudioCodecMeta.fromAudioFormat(audioFrame.getAudio().getFormat()));
    };
    prototype.getInputColor = function() {
        if (this.videoEncoder == null) 
             throw new IllegalStateException("Video encoder has not been initialized, init() must be called before using this class.");
        var colorSpaces = this.videoEncoder.getSupportedColorSpaces();
        return colorSpaces == null ? null : colorSpaces[0];
    };
    prototype.setOption = function(option, value) {
        if (option == Options.PROFILE) 
            this.profile = value;
         else if (option == Options.INTERLACED) 
            this.interlaced = value;
    };
    prototype.isVideo = function() {
        return this.outputFormat.isVideo();
    };
    prototype.isAudio = function() {
        return this.outputFormat.isAudio();
    };
}, {destStream: "SeekableByteChannel", muxer: "Muxer", videoOutputTrack: "MuxerTrack", audioOutputTrack: "MuxerTrack", outputVideoCodec: "Codec", outputAudioCodec: "Codec", outputFormat: "Format", bufferStore: {name: "ThreadLocal", arguments: ["ByteBuffer"]}, audioEncoder: "AudioEncoder", videoEncoder: "VideoEncoder"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var JCodecUtil = function() {};
JCodecUtil = stjs.extend(JCodecUtil, null, [], function(constructor, prototype) {
    constructor.decoders = new HashMap();
    constructor.demuxers = new HashMap();
    constructor.detectFormat = function(f) {
        return JCodecUtil.detectFormatBuffer(NIOUtils.fetchFromFileL(f, 200 * 1024));
    };
    constructor.detectFormatChannel = function(f) {
        return JCodecUtil.detectFormatBuffer(NIOUtils.fetchFromChannel(f, 200 * 1024));
    };
    constructor.detectFormatBuffer = function(b) {
        var maxScore = 0;
        var selected = null;
        for (var iterator$vd = JCodecUtil.demuxers.entrySet().iterator(); iterator$vd.hasNext(); ) {
            var vd = iterator$vd.next();
            var score = JCodecUtil.probe(b.duplicate(), vd.getValue());
            if (score > maxScore) {
                selected = vd.getKey();
                maxScore = score;
            }
        }
        return selected;
    };
    constructor.detectDecoder = function(b) {
        var maxScore = 0;
        var selected = null;
        for (var iterator$vd = JCodecUtil.decoders.entrySet().iterator(); iterator$vd.hasNext(); ) {
            var vd = iterator$vd.next();
            var score = JCodecUtil.probe(b.duplicate(), vd.getValue());
            if (score > maxScore) {
                selected = vd.getKey();
                maxScore = score;
            }
        }
        return selected;
    };
    constructor.probe = function(b, vd) {
        try {
            return Platform.invokeStaticMethod(vd, "probe", [b]);
        }catch (e) {}
        return 0;
    };
    constructor.getVideoDecoder = function(fourcc) {
        if ("apch".equals(fourcc) || "apcs".equals(fourcc) || "apco".equals(fourcc) || "apcn".equals(fourcc) || "ap4h".equals(fourcc)) 
            return new ProresDecoder();
         else if ("m2v1".equals(fourcc)) 
            return new MPEGDecoder();
         else 
            return null;
    };
    constructor.savePictureAsPPM = function(pic, file) {
        var transform = ColorUtil.getTransform(pic.getColor(), ColorSpace.RGB);
        var rgb = Picture.create(pic.getWidth(), pic.getHeight(), ColorSpace.RGB);
        transform.transform(pic, rgb);
        NIOUtils.writeTo(new PPMEncoder().encodeFrame(rgb), file);
    };
    constructor.asciiString = function(fourcc) {
        var ch = fourcc.toCharArray();
        var result = new Int8Array(ch.length);
        for (var i = 0; i < ch.length; i++) {
            result[i] = (ch[i] << 24 >> 24);
        }
        return result;
    };
    constructor.writeBER32 = function(buffer, value) {
        buffer.put((((value >> 21) | 128) << 24 >> 24));
        buffer.put((((value >> 14) | 128) << 24 >> 24));
        buffer.put((((value >> 7) | 128) << 24 >> 24));
        buffer.put(((value & 127) << 24 >> 24));
    };
    constructor.writeBER32Var = function(bb, value) {
        for (var i = 0, bits = MathUtil.log2(value); i < 4 && bits > 0; i++) {
            bits -= 7;
            var out = value >> bits;
            if (bits > 0) 
                out |= 128;
            bb.put((out << 24 >> 24));
        }
    };
    constructor.readBER32 = function(input) {
        var size = 0;
        for (var i = 0; i < 4; i++) {
            var b = input.get();
            size = (size << 7) | (b & 127);
            if (((b & 255) >> 7) == 0) 
                break;
        }
        return size;
    };
    constructor.getAsIntArray = function(yuv, size) {
        var b = new Int8Array(size);
        var result = new Int32Array(size);
        yuv.getBuf(b);
        for (var i = 0; i < b.length; i++) {
            result[i] = b[i] & 255;
        }
        return result;
    };
    constructor.removeExtension = function(name) {
        if (name == null) 
            return null;
        return name.replaceAll("\\.[^\\.]+$", "");
    };
    constructor.createDemuxer = function(format, input) {
        var ch = null;
        if (format != Format.IMG) {
            ch = NIOUtils.readableChannel(input);
        }
        if (Format.MOV == format) {
            return MP4Demuxer.createMP4Demuxer(ch);
        } else if (Format.MPEG_PS == format) {
            return new MPSDemuxer(ch);
        } else if (Format.MKV == format) {
            return new MKVDemuxer(ch);
        } else if (Format.IMG == format) {
            return new ImageSequenceDemuxer(input.getAbsolutePath(), Integer.MAX_VALUE);
        } else if (Format.Y4M == format) {
            return new Y4MDemuxer(ch);
        } else if (Format.WEBP == format) {
            return new WebpDemuxer(ch);
        } else if (Format.H264 == format) {
            return new BufferH264ES(NIOUtils.fetchAllFromChannel(ch));
        } else if (Format.WAV == format) {
            return new WavDemuxer(ch);
        } else if (Format.MPEG_AUDIO == format) {
            return new MPEGAudioDemuxer(ch);
        } else {
            Logger.error("Format " + format + " is not supported");
        }
        return null;
    };
    constructor.createM2TSDemuxer = function(input, targetTrack) {
        var ch = NIOUtils.readableChannel(input);
        var mts = new MTSDemuxer(ch);
        var programs = mts.getPrograms();
        if (programs.size() == 0) {
            Logger.error("The MPEG TS stream contains no programs");
            return null;
        }
        var found = null;
        for (var iterator$pid = programs.iterator(); iterator$pid.hasNext(); ) {
            var pid = iterator$pid.next();
            var program = mts.getProgram(pid);
            if (found != null) {
                program.close();
                continue;
            }
            var demuxer = new MPSDemuxer(program);
            if (targetTrack == TrackType.AUDIO && demuxer.getAudioTracks().size() > 0 || targetTrack == TrackType.VIDEO && demuxer.getVideoTracks().size() > 0) {
                found = Tuple.pair(pid, demuxer);
                Logger.info("Using M2TS program: " + pid + " for " + targetTrack + " track.");
            } else {
                program.close();
            }
        }
        return found;
    };
    constructor.createAudioDecoder = function(codec, decoderSpecific) {
        if (Codec.AAC == codec) {
            return new AACDecoder(decoderSpecific);
        } else {
            Logger.error("Codec " + codec + " is not supported");
        }
        return null;
    };
    constructor.createVideoDecoder = function(codec, decoderSpecific) {
        if (Codec.H264 == codec) {
            return decoderSpecific != null ? H264Decoder.createH264DecoderFromCodecPrivate(decoderSpecific) : new H264Decoder();
        } else if (Codec.MPEG2 == codec) {
            return new MPEGDecoder();
        } else if (Codec.VP8 == codec) {
            return new VP8Decoder();
        } else if (Codec.JPEG == codec) {
            return new JpegDecoder();
        } else {
            Logger.error("Codec " + codec + " is not supported");
        }
        return null;
    };
}, {decoders: {name: "Map", arguments: ["Codec", {name: "Class", arguments: ["Object"]}]}, demuxers: {name: "Map", arguments: ["Format", {name: "Class", arguments: ["Object"]}]}}, {});
(function() {
    JCodecUtil.decoders.put(Codec.VP8, VP8Decoder);
    JCodecUtil.decoders.put(Codec.PRORES, ProresDecoder);
    JCodecUtil.decoders.put(Codec.MPEG2, MPEGDecoder);
    JCodecUtil.decoders.put(Codec.H264, H264Decoder);
    JCodecUtil.decoders.put(Codec.AAC, AACDecoder);
    JCodecUtil.decoders.put(Codec.MPEG4, MPEG4Decoder);
    JCodecUtil.demuxers.put(Format.MPEG_TS, MTSDemuxer);
    JCodecUtil.demuxers.put(Format.MPEG_PS, MPSDemuxer);
    JCodecUtil.demuxers.put(Format.MOV, MP4Demuxer);
    JCodecUtil.demuxers.put(Format.WEBP, WebpDemuxer);
    JCodecUtil.demuxers.put(Format.MPEG_AUDIO, MPEGAudioDemuxer);
})();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var TestTool = function(jm, errs) {
    this.jm = jm;
    this.errs = new File(errs);
    this.coded = File.createTempFile("seq", ".264");
    this.decoded = File.createTempFile("seq_dec", ".yuv");
    this.jmconf = File.createTempFile("ldecod", ".conf");
    this.prepareJMConf();
};
TestTool = stjs.extend(TestTool, null, [], function(constructor, prototype) {
    prototype.jm = null;
    prototype.coded = null;
    prototype.decoded = null;
    prototype.jmconf = null;
    prototype.errs = null;
    constructor.main1 = function(args) {
        if (args.length != 3) {
            System.out.println("JCodec h.264 test tool");
            System.out.println("Syntax: <path to ldecod> <movie file> <foder for errors>");
            return;
        }
        new TestTool(args[0], args[2]).doIt(args[1]);
    };
    prototype.doIt = function(_in) {
        var raw = null;
        var source = null;
        try {
            source = new FileChannelWrapper(new FileInputStream(_in).getChannel());
            var demux = MP4Demuxer.createMP4Demuxer(source);
            var inTrack = demux.getVideoTrack();
            var _rawData = ByteBuffer.allocate(1920 * 1088 * 6);
            var codecPrivate = inTrack.getMeta().getCodecPrivate();
            var decoder = H264Decoder.createH264DecoderFromCodecPrivate(codecPrivate);
            var inFrame;
            var sf = 2600;
            inTrack.gotoFrame(sf);
             while ((inFrame = inTrack.nextFrame()) != null && !inFrame.isKeyFrame())
                ;
            if (inFrame == null) {
                 throw new NullPointerException("inFrame == null");
            }
            inTrack.gotoFrame(inFrame.getFrameNo());
            var decodedPics = new ArrayList();
            var totalFrames = stjs.trunc(inTrack.getMeta().getTotalFrames()), seqNo = 0;
            for (var i = sf; (inFrame = inTrack.nextFrame()) != null; i++) {
                var data = inFrame.getData();
                var nalUnits = H264Utils.splitFrame(data);
                _rawData.clear();
                H264Utils.joinNALUnitsToBuffer(nalUnits, _rawData);
                _rawData.flip();
                if (H264Utils.isByteBufferIDRSlice(_rawData)) {
                    if (raw != null) {
                        raw.close();
                        this.runJMCompareResults(decodedPics, seqNo);
                        decodedPics = new ArrayList();
                        seqNo = i;
                    }
                    raw = new FileChannelWrapper(new FileOutputStream(this.coded).getChannel());
                    raw.write(codecPrivate);
                }
                if (raw == null) {
                     throw new IllegalStateException("IDR slice not found");
                }
                raw.write(_rawData);
                var size = inTrack.getMeta().getVideoCodecMeta().getSize();
                decodedPics.add(decoder.decodeFrameFromNals(nalUnits, Picture.create((size.getWidth() + 15) & ~15, (size.getHeight() + 15) & ~15, ColorSpace.YUV420).getData()));
                if (i % 500 == 0) 
                    System.out.println((stjs.trunc(i * 100 / totalFrames)) + "%");
            }
            if (decodedPics.size() > 0) 
                this.runJMCompareResults(decodedPics, seqNo);
        } finally {
            if (source != null) 
                source.close();
            if (raw != null) 
                raw.close();
        }
    };
    prototype.runJMCompareResults = function(decodedPics, seqNo) {
        try {
            var process = Runtime.getRuntime().exec(this.jm + " -d " + this.jmconf.getAbsolutePath());
            process.waitFor();
            var yuv = NIOUtils.fetchFromFile(this.decoded);
            for (var iterator$pic = decodedPics.iterator(); iterator$pic.hasNext(); ) {
                var pic = iterator$pic.next();
                pic = pic.cropped();
                var equals = Platform.arrayEqualsByte(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, pic.getPlaneWidth(0) * pic.getPlaneHeight(0))), pic.getPlaneData(0));
                equals &= Platform.arrayEqualsByte(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, pic.getPlaneWidth(1) * pic.getPlaneHeight(1))), pic.getPlaneData(1));
                equals &= Platform.arrayEqualsByte(ArrayUtil.toByteArrayShifted(JCodecUtil2.getAsIntArray(yuv, pic.getPlaneWidth(2) * pic.getPlaneHeight(2))), pic.getPlaneData(2));
                if (!equals) 
                    this.diff(seqNo);
            }
        }catch (e) {
            this.diff(seqNo);
        }
    };
    prototype.diff = function(seqNo) {
        System.out.println(seqNo + ": DIFF!!!");
        this.coded.renameTo(new File(this.errs, String.format("seq%08d.264", seqNo)));
        this.decoded.renameTo(new File(this.errs, String.format("seq%08d_dec.yuv", seqNo)));
    };
    prototype.prepareJMConf = function() {
        var sb = new StringBuilder();
        sb.append("InputFile              = \"").append(this.coded.getAbsolutePath()).append("\"\n");
        sb.append("OutputFile             = \"").append(this.decoded.getAbsolutePath()).append("\"\n");
        sb.append("RefFile                = \"/dev/null\"\n");
        sb.append("WriteUV                = 1\n");
        sb.append("FileFormat             = 0\n");
        sb.append("RefOffset              = 0\n");
        sb.append("POCScale               = 2\n");
        sb.append("DisplayDecParams       = 0\n");
        sb.append("ConcealMode            = 0\n");
        sb.append("RefPOCGap              = 2\n");
        sb.append("POCGap                 = 2\n");
        sb.append("Silent                 = 1\n");
        sb.append("IntraProfileDeblocking = 1\n");
        sb.append("DecFrmNum              = 0\n");
        sb.append("DecodeAllLayers        = 0\n");
        IOUtils.writeStringToFile(this.jmconf, sb.toString());
    };
}, {coded: "File", decoded: "File", jmconf: "File", errs: "File"}, {});
/**
 *  A source producing uncompressed video/audio streams out of a compressed file.
 *  
 *  The buffers for the frames coming out of this source will be borrowed from a
 *  pixel store and must be returned to it for maximum efficiency.
 *  
 *  @author Stanislav Vitvitskiy
 */
var SourceImpl = function(sourceName, inputFormat, inputVideoCodec, inputAudioCodec) {
    this.sourceName = sourceName;
    this.inputFormat = inputFormat;
    this.inputVideoCodec = inputVideoCodec;
    this.inputAudioCodec = inputAudioCodec;
    this.frameReorderBuffer = new ArrayList();
    this.videoPacketReorderBuffer = new ArrayList();
};
SourceImpl = stjs.extend(SourceImpl, null, [Source, PacketSource], function(constructor, prototype) {
    prototype.sourceName = null;
    prototype.sourceStream = null;
    prototype.demuxVideo = null;
    prototype.demuxAudio = null;
    prototype.inputFormat = null;
    prototype.videoInputTrack = null;
    prototype.audioInputTrack = null;
    prototype.inputVideoCodec = null;
    prototype.inputAudioCodec = null;
    prototype.frameReorderBuffer = null;
    prototype.videoPacketReorderBuffer = null;
    prototype.pixelStore = null;
    prototype.videoCodecMeta = null;
    prototype.audioCodecMeta = null;
    prototype.audioDecoder = null;
    prototype.videoDecoder = null;
    prototype.downscale = 1;
    constructor.createMpegDecoder = function(downscale) {
        if (downscale == 2) 
            return new Mpeg2Thumb4x4();
         else if (downscale == 4) 
            return new Mpeg2Thumb2x2();
         else 
            return new MPEGDecoder();
    };
    constructor.createProresDecoder = function(downscale) {
        if (2 == downscale) {
            return new ProresToThumb4x4();
        } else if (4 == downscale) {
            return new ProresToThumb2x2();
        } else if (8 == downscale) {
            return new ProresToThumb();
        } else {
            return new ProresDecoder();
        }
    };
    prototype.initDemuxer = function() {
        if (this.inputFormat != Format.IMG) 
            this.sourceStream = NIOUtils.readableFileChannel(this.sourceName);
        if (Format.MOV == this.inputFormat) {
            this.demuxVideo = this.demuxAudio = MP4Demuxer.createMP4Demuxer(this.sourceStream);
        } else if (Format.MKV == this.inputFormat) {
            this.demuxVideo = this.demuxAudio = new MKVDemuxer(this.sourceStream);
        } else if (Format.IMG == this.inputFormat) {
            this.demuxVideo = new ImageSequenceDemuxer(this.sourceName, Integer.MAX_VALUE);
        } else if (Format.WEBP == this.inputFormat) {
            this.demuxVideo = new WebpDemuxer(this.sourceStream);
        } else if (Format.MPEG_PS == this.inputFormat) {
            this.demuxVideo = this.demuxAudio = new MPSDemuxer(this.sourceStream);
        } else if (Format.Y4M == this.inputFormat) {
            var y4mDemuxer = new Y4MDemuxer(this.sourceStream);
            this.demuxVideo = this.demuxAudio = y4mDemuxer;
            this.videoInputTrack = y4mDemuxer;
        } else if (Format.H264 == this.inputFormat) {
            this.demuxVideo = new BufferH264ES(NIOUtils.fetchAllFromChannel(this.sourceStream));
        } else if (Format.WAV == this.inputFormat) {
            this.demuxAudio = new WavDemuxer(this.sourceStream);
        } else if (Format.MPEG_AUDIO == this.inputFormat) {
            this.demuxAudio = new MPEGAudioDemuxer(this.sourceStream);
        } else if (Format.MPEG_TS == this.inputFormat) {
            var mtsDemuxer = new MTSDemuxer(this.sourceStream);
            var mpsDemuxer = null;
            if (this.inputVideoCodec != null) {
                mpsDemuxer = new MPSDemuxer(mtsDemuxer.getProgram(this.inputVideoCodec.v0));
                this.videoInputTrack = this.openTSTrack(mpsDemuxer, this.inputVideoCodec.v1);
                this.demuxVideo = mpsDemuxer;
            }
            if (this.inputAudioCodec != null) {
                if (this.inputVideoCodec == null || this.inputVideoCodec.v0 != this.inputAudioCodec.v0) {
                    mpsDemuxer = new MPSDemuxer(mtsDemuxer.getProgram(this.inputAudioCodec.v0));
                }
                this.audioInputTrack = this.openTSTrack(mpsDemuxer, this.inputAudioCodec.v1);
                this.demuxAudio = mpsDemuxer;
            }
            for (var iterator$pid = mtsDemuxer.getPrograms().iterator(); iterator$pid.hasNext(); ) {
                var pid = iterator$pid.next();
                if ((this.inputVideoCodec == null || pid != this.inputVideoCodec.v0) && (this.inputAudioCodec == null || pid != this.inputAudioCodec.v0)) {
                    Logger.info("Unused program: " + pid);
                    mtsDemuxer.getProgram(pid).close();
                }
            }
        } else {
             throw new RuntimeException("Input format: " + this.inputFormat + " is not supported.");
        }
        if (this.demuxVideo != null && this.inputVideoCodec != null) {
            var videoTracks = this.demuxVideo.getVideoTracks();
            if (videoTracks.size() > 0) {
                this.videoInputTrack = videoTracks.get(this.inputVideoCodec.v1);
            }
        }
        if (this.demuxAudio != null && this.inputAudioCodec != null) {
            var audioTracks = this.demuxAudio.getAudioTracks();
            if (audioTracks.size() > 0) {
                this.audioInputTrack = audioTracks.get(this.inputAudioCodec.v1);
            }
        }
    };
    /**
     *  Seeks to a previous key frame prior or on the given frame, if the track is
     *  not seekable returns 0.
     *  
     *  @param frame
     *             A frame to seek
     *  @return Frame number of a key frame or 0 if the track is not seekable.
     *  @throws IOException
     */
    prototype.seekToKeyFrame = function(frame) {
        if (stjs.isInstanceOf(this.videoInputTrack.constructor, SeekableDemuxerTrack)) {
            var seekable = this.videoInputTrack;
            seekable.gotoSyncFrame(frame);
            return ((seekable.getCurFrame()) | 0);
        } else {
            Logger.warn("Can not seek in " + this.videoInputTrack + " container.");
            return -1;
        }
    };
    prototype.openTSTrack = function(demuxerVideo, selectedTrack) {
        var trackNo = 0;
        for (var iterator$track = demuxerVideo.getTracks().iterator(); iterator$track.hasNext(); ) {
            var track = iterator$track.next();
            if (trackNo == selectedTrack) {
                return track;
            } else 
                track.ignore();
            ++trackNo;
        }
        return null;
    };
    prototype.inputVideoPacket = function() {
         while (true){
            var packet = this.getNextVideoPacket();
            if (packet != null) 
                this.videoPacketReorderBuffer.add(packet);
            if (packet == null || this.videoPacketReorderBuffer.size() > Transcoder.REORDER_BUFFER_SIZE) {
                if (this.videoPacketReorderBuffer.size() == 0) 
                    return null;
                var out = this.videoPacketReorderBuffer.remove(0);
                var duration = Integer.MAX_VALUE;
                for (var iterator$packet2 = this.videoPacketReorderBuffer.iterator(); iterator$packet2.hasNext(); ) {
                    var packet2 = iterator$packet2.next();
                    var cand = (((packet2.getPts() - out.getPts())) | 0);
                    if (cand > 0 && cand < duration) 
                        duration = cand;
                }
                if (duration != Integer.MAX_VALUE) 
                    out.setDuration(duration);
                return out;
            }
        }
    };
    prototype.getNextVideoPacket = function() {
        if (this.videoInputTrack == null) 
            return null;
        var nextFrame = this.videoInputTrack.nextFrame();
        if (this.videoDecoder == null) {
            this.videoDecoder = this.createVideoDecoder(this.inputVideoCodec.v2, this.downscale, nextFrame.getData(), null);
            if (this.videoDecoder != null) {
                this.videoCodecMeta = this.videoDecoder.getCodecMeta(nextFrame.getData());
            }
        }
        return nextFrame;
    };
    prototype.inputAudioPacket = function() {
        if (this.audioInputTrack == null) 
            return null;
        var audioPkt = this.audioInputTrack.nextFrame();
        if (this.audioDecoder == null && audioPkt != null) {
            this.audioDecoder = this.createAudioDecoder(audioPkt.getData());
            if (this.audioDecoder != null) 
                this.audioCodecMeta = this.audioDecoder.getCodecMeta(audioPkt.getData());
        }
        return audioPkt;
    };
    prototype.getTrackVideoMeta = function() {
        if (this.videoInputTrack == null) 
            return null;
        return this.videoInputTrack.getMeta();
    };
    prototype.getAudioMeta = function() {
        if (this.audioInputTrack == null) 
            return null;
        return this.audioInputTrack.getMeta();
    };
    prototype.haveAudio = function() {
        return this.audioInputTrack != null;
    };
    prototype.finish = function() {
        if (this.sourceStream != null) 
            IOUtils.closeQuietly(this.sourceStream);
    };
    prototype.init = function(pixelStore) {
        this.pixelStore = pixelStore;
        this.initDemuxer();
    };
    prototype.createAudioDecoder = function(codecPrivate) {
        if (Codec.AAC == this.inputAudioCodec.v2) {
            return new AACDecoder(codecPrivate);
        } else if (Codec.PCM == this.inputAudioCodec.v2) {
            return new SourceImpl.RawAudioDecoder(this.getAudioMeta().getAudioCodecMeta().getFormat());
        }
        return null;
    };
    prototype.createVideoDecoder = function(codec, downscale, codecPrivate, videoCodecMeta) {
        if (Codec.H264 == codec) {
            return H264Decoder.createH264DecoderFromCodecPrivate(codecPrivate);
        } else if (Codec.PNG == codec) {
            return new PNGDecoder();
        } else if (Codec.MPEG2 == codec) {
            return SourceImpl.createMpegDecoder(downscale);
        } else if (Codec.PRORES == codec) {
            return SourceImpl.createProresDecoder(downscale);
        } else if (Codec.VP8 == codec) {
            return new VP8Decoder();
        } else if (Codec.JPEG == codec) {
            return SourceImpl.createJpegDecoder(downscale);
        } else if (Codec.MPEG4 == codec) {
            return new MPEG4Decoder();
        } else if (Codec.RAW == codec) {
            var dim = videoCodecMeta.getSize();
            return new RAWVideoDecoder(dim.getWidth(), dim.getHeight());
        }
        return null;
    };
    prototype.decodeVideo = function(data, target1) {
        return this.videoDecoder.decodeFrame(data, target1.getData());
    };
    prototype.decodeAudio = function(audioPkt) {
        if (this.inputAudioCodec.v2 == Codec.PCM) {
            return audioPkt;
        } else {
            var decodeFrame = this.audioDecoder.decodeFrame(audioPkt, null);
            return decodeFrame.getData();
        }
    };
    constructor.RawAudioDecoder = function(format) {
        this.format = format;
    };
    constructor.RawAudioDecoder = stjs.extend(constructor.RawAudioDecoder, null, [AudioDecoder], function(constructor, prototype) {
        prototype.format = null;
        prototype.decodeFrame = function(frame, dst) {
            return new AudioBuffer(frame, this.format, stjs.trunc(frame.remaining() / this.format.getFrameSize()));
        };
        prototype.getCodecMeta = function(data) {
            return AudioCodecMeta.fromAudioFormat(this.format);
        };
    }, {format: "AudioFormat"}, {});
    prototype.seekFrames = function(seekFrames) {
        if (seekFrames == 0) 
            return;
        var skipFrames = seekFrames - this.seekToKeyFrame(seekFrames);
        var inVideoPacket;
        for (; skipFrames > 0 && (inVideoPacket = this.getNextVideoPacket()) != null; ) {
            var loanerBuffer = this.getPixelBuffer(inVideoPacket.getData());
            var decodedFrame = this.decodeVideo(inVideoPacket.getData(), loanerBuffer.getPicture());
            if (decodedFrame == null) {
                this.pixelStore.putBack(loanerBuffer);
                continue;
            }
            this.frameReorderBuffer.add(new VideoFrameWithPacket(inVideoPacket, new PixelStore.LoanerPicture(decodedFrame, 1)));
            if (this.frameReorderBuffer.size() > Transcoder.REORDER_BUFFER_SIZE) {
                Collections.sort(this.frameReorderBuffer);
                var removed = this.frameReorderBuffer.remove(0);
                skipFrames--;
                if (removed.getFrame() != null) 
                    this.pixelStore.putBack(removed.getFrame());
            }
        }
    };
    prototype.detectFrameType = function(inVideoPacket) {
        if (this.inputVideoCodec.v2 != Codec.H264) {
            return;
        }
        inVideoPacket.setFrameType(H264Utils.isByteBufferIDRSlice(inVideoPacket.getData()) ? Packet.FrameType.KEY : Packet.FrameType.INTER);
    };
    /**
     *  Returns a pixel buffer of a suitable size to hold the given video frame. The
     *  video size is taken either from the video metadata or by analyzing the
     *  incoming video packet.
     *  
     *  @param firstFrame
     *  @return
     */
    prototype.getPixelBuffer = function(firstFrame) {
        var videoMeta = this.getVideoCodecMeta();
        var size = videoMeta.getSize();
        return this.pixelStore.getPicture((size.getWidth() + 15) & ~15, (size.getHeight() + 15) & ~15, videoMeta.getColor());
    };
    prototype.getVideoCodecMeta = function() {
        if (this.videoCodecMeta != null) 
            return this.videoCodecMeta;
        var meta = this.getTrackVideoMeta();
        if (meta != null && meta.getVideoCodecMeta() != null) {
            this.videoCodecMeta = meta.getVideoCodecMeta();
        }
        return this.videoCodecMeta;
    };
    prototype.getNextVideoFrame = function() {
        var inVideoPacket;
         while ((inVideoPacket = this.getNextVideoPacket()) != null){
            if (inVideoPacket.getFrameType() == Packet.FrameType.UNKNOWN) {
                this.detectFrameType(inVideoPacket);
            }
            var decodedFrame = null;
            var pixelBuffer = this.getPixelBuffer(inVideoPacket.getData());
            decodedFrame = this.decodeVideo(inVideoPacket.getData(), pixelBuffer.getPicture());
            if (decodedFrame == null) {
                this.pixelStore.putBack(pixelBuffer);
                continue;
            }
            this.frameReorderBuffer.add(new VideoFrameWithPacket(inVideoPacket, new PixelStore.LoanerPicture(decodedFrame, 1)));
            if (this.frameReorderBuffer.size() > Transcoder.REORDER_BUFFER_SIZE) {
                return this.removeFirstFixDuration(this.frameReorderBuffer);
            }
        }
        if (this.frameReorderBuffer.size() > 0) {
            return this.removeFirstFixDuration(this.frameReorderBuffer);
        }
        return null;
    };
    prototype.removeFirstFixDuration = function(reorderBuffer) {
        Collections.sort(reorderBuffer);
        var frame = reorderBuffer.remove(0);
        if (!reorderBuffer.isEmpty()) {
            var nextFrame = reorderBuffer.get(0);
            frame.getPacket().setDuration(nextFrame.getPacket().getPts() - frame.getPacket().getPts());
        }
        return frame;
    };
    prototype.getNextAudioFrame = function() {
        var audioPkt = this.inputAudioPacket();
        if (audioPkt == null) 
            return null;
        var audioBuffer;
        if (this.inputAudioCodec.v2 == Codec.PCM) {
            var audioMeta = this.getAudioMeta();
            audioBuffer = new AudioBuffer(audioPkt.getData(), audioMeta.getAudioCodecMeta().getFormat(), audioMeta.getTotalFrames());
        } else {
            audioBuffer = this.audioDecoder.decodeFrame(audioPkt.getData(), null);
        }
        return new AudioFrameWithPacket(audioBuffer, audioPkt);
    };
    prototype.getIntputVideoCodec = function() {
        return this.inputVideoCodec;
    };
    prototype.getInputAudioCode = function() {
        return this.inputAudioCodec;
    };
    prototype.setOption = function(option, value) {
        if (option == Options.DOWNSCALE) 
            this.downscale = value;
    };
    prototype.getAudioCodecMeta = function() {
        if (this.audioInputTrack != null && this.audioInputTrack.getMeta() != null && this.audioInputTrack.getMeta().getAudioCodecMeta() != null) {
            return this.audioInputTrack.getMeta().getAudioCodecMeta();
        }
        return this.audioCodecMeta;
    };
    prototype.isVideo = function() {
        if (!this.inputFormat.isVideo()) 
            return false;
        var tracks = this.demuxVideo.getVideoTracks();
        return tracks != null && tracks.size() > 0;
    };
    prototype.isAudio = function() {
        if (!this.inputFormat.isAudio()) 
            return false;
        var tracks = this.demuxAudio.getAudioTracks();
        return tracks != null && tracks.size() > 0;
    };
    constructor.createJpegDecoder = function(downscale) {
        if (downscale == 2) {
            return new JpegToThumb4x4();
        } else if (downscale == 4) {
            return new JpegToThumb2x2();
        } else {
            return new JpegDecoder();
        }
    };
}, {sourceStream: "SeekableByteChannel", demuxVideo: "Demuxer", demuxAudio: "Demuxer", inputFormat: "Format", videoInputTrack: "DemuxerTrack", audioInputTrack: "DemuxerTrack", inputVideoCodec: {name: "Tuple._3", arguments: [null, null, "Codec"]}, inputAudioCodec: {name: "Tuple._3", arguments: [null, null, "Codec"]}, frameReorderBuffer: {name: "List", arguments: ["VideoFrameWithPacket"]}, videoPacketReorderBuffer: {name: "List", arguments: ["Packet"]}, pixelStore: "PixelStore", videoCodecMeta: "VideoCodecMeta", audioCodecMeta: "AudioCodecMeta", audioDecoder: "AudioDecoder", videoDecoder: "VideoDecoder"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var WebOptimize = function() {};
WebOptimize = stjs.extend(WebOptimize, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 1) {
            System.out.println("Syntax: optimize <movie>");
            System.exit(-1);
        }
        var tgt = new File(args[0]);
        var src = WebOptimize.hidFile(tgt);
        tgt.renameTo(src);
        try {
            var movie = MP4Util.createRefFullMovieFromFile(src);
            new Flattern().flattern(movie, tgt);
        }catch (t) {
            t.printStackTrace();
            tgt.renameTo(new File(tgt.getParentFile(), tgt.getName() + ".error"));
            src.renameTo(tgt);
        }
    };
    constructor.hidFile = function(tgt) {
        var src = new File(tgt.getParentFile(), "." + tgt.getName());
        if (src.exists()) {
            var i = 1;
            do {
                src = new File(tgt.getParentFile(), "." + tgt.getName() + "." + (i++));
            } while (src.exists());
        }
        return src;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Cut on ref movies
 *  
 *  @author The JCodec project
 *  
 */
var Cut = function() {};
Cut = stjs.extend(Cut, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 1) {
            System.out.println("Syntax: cut [-command arg]...[-command arg] [-self] <movie file>\n\tCreates a reference movie out of the file and applies a set of changes specified by the commands to it.");
            System.exit(-1);
        }
        var slices = new ArrayList();
        var sliceNames = new ArrayList();
        var selfContained = false;
        var shift = 0;
         while (true){
            if ("-cut".equals(args[shift])) {
                var pt = StringUtils.splitS(args[shift + 1], ":");
                slices.add(new Cut.Slice(Integer.parseInt(pt[0]), Integer.parseInt(pt[1])));
                if (pt.length > 2) 
                    sliceNames.add(pt[2]);
                 else 
                    sliceNames.add(null);
                shift += 2;
            } else if ("-self".equals(args[shift])) {
                ++shift;
                selfContained = true;
            } else 
                break;
        }
        var source = new File(args[shift]);
        var input = null;
        var out = null;
        var outs = new ArrayList();
        try {
            input = NIOUtils.readableChannel(source);
            var movie = MP4Util.createRefFullMovie(input, "file://" + source.getCanonicalPath());
            var slicesMovs;
            if (!selfContained) {
                out = NIOUtils.writableChannel(new File(source.getParentFile(), JCodecUtil2.removeExtension(source.getName()) + ".ref.mov"));
                slicesMovs = new Cut().cut(movie, slices);
                MP4Util.writeFullMovie(out, movie);
            } else {
                out = NIOUtils.writableChannel(new File(source.getParentFile(), JCodecUtil2.removeExtension(source.getName()) + ".self.mov"));
                slicesMovs = new Cut().cut(movie, slices);
                new Strip().strip(movie.getMoov());
                new Flattern().flatternChannel(movie, out);
            }
            Cut.saveSlices(slicesMovs, sliceNames, source.getParentFile());
        } finally {
            if (input != null) 
                input.close();
            if (out != null) 
                out.close();
            for (var iterator$o = outs.iterator(); iterator$o.hasNext(); ) {
                var o = iterator$o.next();
                o.close();
            }
        }
    };
    constructor.saveSlices = function(slices, names, parentFile) {
        for (var i = 0; i < slices.size(); i++) {
            if (names.get(i) == null) 
                continue;
            var out = null;
            try {
                out = NIOUtils.writableChannel(new File(parentFile, names.get(i)));
                MP4Util.writeFullMovie(out, slices.get(i));
            } finally {
                NIOUtils.closeQuietly(out);
            }
        }
    };
    constructor.Slice = function(_in, out) {
        this.inSec = _in;
        this.outSec = out;
    };
    constructor.Slice = stjs.extend(constructor.Slice, null, [], function(constructor, prototype) {
        prototype.inSec = 0.0;
        prototype.outSec = 0.0;
    }, {}, {});
    prototype.cut = function(movie, commands) {
        var moov = movie.getMoov();
        var videoTrack = moov.getVideoTrack();
        if (videoTrack != null && videoTrack.getTimescale() != moov.getTimescale()) 
            moov.fixTimescale(videoTrack.getTimescale());
        var tracks = moov.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var trakBox = tracks[i];
            Util.forceEditList(moov, trakBox);
            var edits = trakBox.getEdits();
            for (var iterator$cut = commands.iterator(); iterator$cut.hasNext(); ) {
                var cut = iterator$cut.next();
                this.split(edits, cut.inSec, moov, trakBox);
                this.split(edits, cut.outSec, moov, trakBox);
            }
        }
        var result = new ArrayList();
        for (var iterator$cut = commands.iterator(); iterator$cut.hasNext(); ) {
            var cut = iterator$cut.next();
            var clone = NodeBox.cloneBox(moov, 16 * 1024 * 1024, BoxFactory.getDefault());
            for (var index$trakBox = 0, arr$trakBox = clone.getTracks(); index$trakBox < arr$trakBox.length; index$trakBox++) {
                var trakBox = arr$trakBox[index$trakBox];
                this.selectInner(trakBox.getEdits(), cut, moov, trakBox);
            }
            result.add(new MP4Util.Movie(movie.getFtyp(), clone));
        }
        var movDuration = 0;
        for (var index$trakBox = 0, arr$trakBox = moov.getTracks(); index$trakBox < arr$trakBox.length; index$trakBox++) {
            var trakBox = arr$trakBox[index$trakBox];
            this.selectOuter(trakBox.getEdits(), commands, moov, trakBox);
            trakBox.setEdits(trakBox.getEdits());
            movDuration = Math.max(movDuration, trakBox.getDuration());
        }
        moov.setDuration(movDuration);
        return result;
    };
    prototype.selectOuter = function(edits, commands, movie, trakBox) {
        var inMv = Array(commands.size());
        var outMv = Array(commands.size());
        for (var i = 0; i < commands.size(); i++) {
            inMv[i] = stjs.trunc((commands.get(i).inSec * movie.getTimescale()));
            outMv[i] = stjs.trunc((commands.get(i).outSec * movie.getTimescale()));
        }
        var editStartMv = 0;
        var lit = edits.listIterator();
         while (lit.hasNext()){
            var edit = lit.next();
            for (var i = 0; i < inMv.length; i++) {
                if (editStartMv + edit.getDuration() > inMv[i] && editStartMv < outMv[i]) 
                    lit.remove();
            }
            editStartMv += edit.getDuration();
        }
    };
    prototype.selectInner = function(edits, cut, movie, trakBox) {
        var inMv = stjs.trunc((movie.getTimescale() * cut.inSec));
        var outMv = stjs.trunc((movie.getTimescale() * cut.outSec));
        var editStart = 0;
        var lit = edits.listIterator();
         while (lit.hasNext()){
            var edit = lit.next();
            if (editStart + edit.getDuration() <= inMv || editStart >= outMv) 
                lit.remove();
            editStart += edit.getDuration();
        }
    };
    prototype.split = function(edits, sec, movie, trakBox) {
        Util.split(movie, trakBox, stjs.trunc((sec * movie.getTimescale())));
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Paste on ref movies
 *  
 *  @author The JCodec project
 *  
 */
var Paste = function() {};
Paste = stjs.extend(Paste, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 2) {
            System.out.println("Syntax: paste <to movie> <from movie> [second]");
            System.exit(-1);
        }
        var toFile = new File(args[0]);
        var to = null;
        var from = null;
        var out = null;
        try {
            var outFile = new File(toFile.getParentFile(), toFile.getName().replaceAll("\\.mov$", "") + ".paste.mov");
            Platform.deleteFile(outFile);
            out = NIOUtils.writableChannel(outFile);
            to = NIOUtils.writableChannel(toFile);
            var fromFile = new File(args[1]);
            from = NIOUtils.readableChannel(fromFile);
            var toMov = MP4Util.createRefFullMovie(to, "file://" + toFile.getCanonicalPath());
            var fromMov = MP4Util.createRefFullMovie(from, "file://" + fromFile.getCanonicalPath());
            new Strip().strip(fromMov.getMoov());
            if (args.length > 2) {
                new Paste().paste(toMov.getMoov(), fromMov.getMoov(), Double.parseDouble(args[2]));
            } else {
                new Paste().addToMovie(toMov.getMoov(), fromMov.getMoov());
            }
            MP4Util.writeFullMovie(out, toMov);
        } finally {
            if (to != null) 
                to.close();
            if (from != null) 
                from.close();
            if (out != null) 
                out.close();
        }
    };
    prototype.paste = function(to, from, sec) {
        var videoTrack = to.getVideoTrack();
        if (videoTrack != null && videoTrack.getTimescale() != to.getTimescale()) 
            to.fixTimescale(videoTrack.getTimescale());
        var displayTv = stjs.trunc((to.getTimescale() * sec));
        Util.forceEditListMov(to);
        Util.forceEditListMov(from);
        var fromTracks = from.getTracks();
        var toTracks = to.getTracks();
        var matches = this.findMatches(fromTracks, toTracks);
        for (var i = 0; i < matches[0].length; i++) {
            var localTrack = to.importTrack(from, fromTracks[i]);
            if (matches[0][i] != -1) {
                Util.insertTo(to, toTracks[matches[0][i]], localTrack, displayTv);
            } else {
                to.appendTrack(localTrack);
                Util.shift(to, localTrack, displayTv);
            }
        }
        for (var i = 0; i < matches[1].length; i++) {
            if (matches[1][i] == -1) {
                Util.spread(to, toTracks[i], displayTv, to.rescale(from.getDuration(), from.getTimescale()));
            }
        }
        to.updateDuration();
    };
    prototype.addToMovie = function(to, from) {
        var tracks = from.getTracks();
        for (var i = 0; i < tracks.length; i++) {
            var track = tracks[i];
            to.appendTrack(to.importTrack(from, track));
        }
    };
    prototype.tv = null;
    prototype.getFrameTv = function(videoTrack, frame) {
        if (this.tv == null) {
            this.tv = Util.getTimevalues(videoTrack);
        }
        return this.tv[frame];
    };
    prototype.findMatches = function(fromTracks, toTracks) {
        var f2t = new Int32Array(fromTracks.length);
        var t2f = new Int32Array(toTracks.length);
        Arrays.fill(f2t, -1);
        Arrays.fill(t2f, -1);
        for (var i = 0; i < fromTracks.length; i++) {
            if (f2t[i] != -1) 
                continue;
            for (var j = 0; j < toTracks.length; j++) {
                if (t2f[j] != -1) 
                    continue;
                if (this.matches(fromTracks[i], toTracks[j])) {
                    f2t[i] = j;
                    t2f[j] = i;
                    break;
                }
            }
        }
        return [f2t, t2f];
    };
    prototype.matches = function(trakBox1, trakBox2) {
        return trakBox1.getHandlerType().equals(trakBox2.getHandlerType()) && this.matchHeaders(trakBox1, trakBox2) && this.matchSampleSizes(trakBox1, trakBox2) && this.matchMediaHeader(trakBox1, trakBox2) && this.matchClip(trakBox1, trakBox2) && this.matchLoad(trakBox1, trakBox2);
    };
    prototype.matchSampleSizes = function(trakBox1, trakBox2) {
        var stsz1 = NodeBox.findFirstPath(trakBox1, SampleSizesBox, Box.path("mdia.minf.stbl.stsz"));
        var stsz2 = NodeBox.findFirstPath(trakBox1, SampleSizesBox, Box.path("mdia.minf.stbl.stsz"));
        return stsz1.getDefaultSize() == stsz2.getDefaultSize();
    };
    prototype.matchMediaHeader = function(trakBox1, trakBox2) {
        var vmhd1 = NodeBox.findFirstPath(trakBox1, VideoMediaHeaderBox, Box.path("mdia.minf.vmhd"));
        var vmhd2 = NodeBox.findFirstPath(trakBox2, VideoMediaHeaderBox, Box.path("mdia.minf.vmhd"));
        if ((vmhd1 != null && vmhd2 == null) || (vmhd1 == null && vmhd2 != null)) 
            return false;
         else if (vmhd1 != null && vmhd2 != null) {
            return vmhd1.getGraphicsMode() == vmhd2.getGraphicsMode() && vmhd1.getbOpColor() == vmhd2.getbOpColor() && vmhd1.getgOpColor() == vmhd2.getgOpColor() && vmhd1.getrOpColor() == vmhd2.getrOpColor();
        } else {
            var smhd1 = NodeBox.findFirstPath(trakBox1, SoundMediaHeaderBox, Box.path("mdia.minf.smhd"));
            var smhd2 = NodeBox.findFirstPath(trakBox2, SoundMediaHeaderBox, Box.path("mdia.minf.smhd"));
            if ((smhd1 == null && smhd2 != null) || (smhd1 != null && smhd2 == null)) 
                return false;
             else if (smhd1 != null && smhd2 != null) 
                return smhd1.getBalance() == smhd1.getBalance();
        }
        return true;
    };
    prototype.matchHeaders = function(trakBox1, trakBox2) {
        var th1 = trakBox1.getTrackHeader();
        var th2 = trakBox2.getTrackHeader();
        return ("vide".equals(trakBox1.getHandlerType()) && Platform.arrayEqualsInt(th1.getMatrix(), th2.getMatrix()) && th1.getLayer() == th2.getLayer() && th1.getWidth() == th2.getWidth() && th1.getHeight() == th2.getHeight()) || ("soun".equals(trakBox1.getHandlerType()) && th1.getVolume() == th2.getVolume()) || "tmcd".equals(trakBox1.getHandlerType());
    };
    prototype.matchLoad = function(trakBox1, trakBox2) {
        var load1 = NodeBox.findFirst(trakBox1, LoadSettingsBox, "load");
        var load2 = NodeBox.findFirst(trakBox2, LoadSettingsBox, "load");
        if (load1 != null && load2 != null) {
            return load1.getPreloadStartTime() == load2.getPreloadStartTime() && load1.getPreloadDuration() == load2.getPreloadDuration() && load1.getPreloadFlags() == load2.getPreloadFlags() && load1.getDefaultHints() == load2.getDefaultHints();
        }
        if (load1 == null && load2 == null) 
            return true;
        return false;
    };
    prototype.matchClip = function(trakBox1, trakBox2) {
        var crgn1 = NodeBox.findFirstPath(trakBox1, ClipRegionBox, Box.path("clip.crgn"));
        var crgn2 = NodeBox.findFirstPath(trakBox2, ClipRegionBox, Box.path("clip.crgn"));
        if (crgn1 != null && crgn2 != null) {
            return crgn1.getRgnSize() == crgn2.getRgnSize() && crgn1.getX() == crgn2.getX() && crgn1.getY() == crgn2.getY() && crgn1.getWidth() == crgn2.getWidth() && crgn1.getHeight() == crgn2.getHeight();
        }
        if (crgn1 == null && crgn2 == null) 
            return true;
        return false;
    };
}, {tv: "Array"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var SetPAR = function() {};
SetPAR = stjs.extend(SetPAR, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 2) {
            System.out.println("Syntax: setpasp <movie> <num:den>");
            System.exit(-1);
        }
        var newPAR = Rational.parse(args[1]);
        new InplaceMP4Editor().modify(new File(args[0]), new (stjs.extend(function SetPAR$1() {}, null, [MP4Edit], function(constructor, prototype) {
            prototype.apply = function(mov) {
                var vt = mov.getVideoTrack();
                vt.setPAR(newPAR);
                var box = NodeBox.findFirstPath(vt, SampleDescriptionBox, Box.path("mdia.minf.stbl.stsd")).getBoxes().get(0);
                if (box != null && (stjs.isInstanceOf(box.constructor, VideoSampleEntry))) {
                    var vs = box;
                    var codedWidth = stjs.trunc(vs.getWidth());
                    var codedHeight = stjs.trunc(vs.getHeight());
                    var displayWidth = stjs.trunc(codedWidth * newPAR.getNum() / newPAR.getDen());
                    vt.getTrackHeader().setWidth(displayWidth);
                    if (BoxUtil.containsBox(vt, "tapt")) {
                        vt.setAperture(new Size(codedWidth, codedHeight), new Size(displayWidth, codedHeight));
                    }
                }
            };
            prototype.applyToFragment = function(mov, fragmentBox) {
                 throw new RuntimeException("Unsupported");
            };
        }, {}, {}))());
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 * 
 *  Changes FPS on an MP4 file.
 * 
 *  @author Stan Vitvitskyy
 */
var SetFPS = function() {};
SetFPS = stjs.extend(SetFPS, null, [], function(constructor, prototype) {
    constructor.MIN_TIMESCALE_ALLOWED = 25;
    constructor.main1 = function(args) {
        var cmd = MainUtils.parseArguments(args, []);
        if (cmd.argsLength() < 2) {
            MainUtils.printHelpNoFlags("movie", "num:den");
            System.exit(-1);
        }
        var newFPS = RationalLarge.parse(cmd.getArg(1));
        new InplaceMP4Editor().modify(new File(cmd.getArg(0)), new (stjs.extend(function SetFPS$1() {}, null, [MP4Edit], function(constructor, prototype) {
            prototype.apply = function(mov) {
                var vt = mov.getVideoTrack();
                var stts = vt.getStts();
                var entries = stts.getEntries();
                var nSamples = 0;
                var totalDuration = 0;
                for (var index$e = 0, arr$e = entries; index$e < arr$e.length; index$e++) {
                    var e = arr$e[index$e];
                    nSamples += e.getSampleCount();
                    totalDuration += e.getSampleCount() * e.getSampleDuration();
                }
                var newTimescale = ((newFPS.multiply(new RationalLarge(totalDuration, nSamples)).scalarClip()) | 0);
                if (newTimescale >= SetFPS.MIN_TIMESCALE_ALLOWED) {
                    vt.setTimescale(newTimescale);
                } else {
                    var mul = new RationalLarge(vt.getTimescale() * totalDuration, nSamples).divideBy(newFPS).scalar();
                    Logger.info("Applying multiplier to sample durations: " + mul);
                    for (var index$e = 0, arr$e = entries; index$e < arr$e.length; index$e++) {
                        var e = arr$e[index$e];
                        e.setSampleDuration(stjs.trunc((e.getSampleDuration() * mul * 100)));
                    }
                    vt.setTimescale(vt.getTimescale() * 100);
                }
                if (newTimescale != vt.getTimescale()) {
                    Logger.info("Changing timescale to: " + vt.getTimescale());
                    var newDuration = stjs.trunc(totalDuration * mov.getTimescale() / vt.getTimescale());
                    mov.setDuration(newDuration);
                    vt.setDuration(newDuration);
                } else {
                    Logger.info("Already at " + newFPS.toString() + "fps, not changing.");
                }
            };
            prototype.applyToFragment = function(mov, fragmentBox) {
                 throw new RuntimeException("Unsupported");
            };
        }, {}, {}))());
    };
}, {}, {});
/**
 *  A full fledged MP4 editor.
 *  
 *  Parses MP4 file, applies the edit and saves the result in a new file.
 *  
 *  Unlike InplaceMP4Edit any changes are allowed. This class will take care of
 *  adjusting all the sample offsets so the result file will be correct.
 *  
 *  @author The JCodec project
 *  
 */
var ReplaceMP4Editor = function() {};
ReplaceMP4Editor = stjs.extend(ReplaceMP4Editor, null, [], function(constructor, prototype) {
    prototype.modifyOrReplace = function(src, edit) {
        var modify = new InplaceMP4Editor().modify(src, edit);
        if (!modify) 
            this.replace(src, edit);
    };
    prototype.replace = function(src, edit) {
        var tmp = new File(src.getParentFile(), "." + src.getName());
        this.copy(src, tmp, edit);
        tmp.renameTo(src);
    };
    prototype.copy = function(src, dst, edit) {
        var movie = MP4Util.createRefFullMovieFromFile(src);
        edit.apply(movie.getMoov());
        var fl = new Flattern();
        fl.flattern(movie, dst);
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var ChangeTimescale = function() {};
ChangeTimescale = stjs.extend(ChangeTimescale, null, [], function(constructor, prototype) {
    constructor.main1 = function(args) {
        if (args.length < 2) {
            System.out.println("Syntax: chts <movie> <timescale>");
            System.exit(-1);
        }
        var ts = Integer.parseInt(args[1]);
        if (ts < 600) {
            System.out.println("Could not set timescale < 600");
            System.exit(-1);
        }
        new InplaceMP4Editor().modify(new File(args[0]), new (stjs.extend(function ChangeTimescale$1() {}, null, [MP4Edit], function(constructor, prototype) {
            prototype.apply = function(mov) {
                var vt = mov.getVideoTrack();
                var mdhd = NodeBox.findFirstPath(vt, MediaHeaderBox, Box.path("mdia.mdhd"));
                var oldTs = mdhd.getTimescale();
                if (oldTs > ts) {
                     throw new RuntimeException("Old timescale (" + oldTs + ") is greater then new timescale (" + ts + "), not touching.");
                }
                vt.fixMediaTimescale(ts);
                mov.fixTimescale(ts);
            };
            prototype.applyToFragment = function(mov, fragmentBox) {
                 throw new RuntimeException("Unsupported");
            };
        }, {}, {}))());
    };
}, {}, {});
/**
 *  Parses MP4 file, applies the edit and saves the result in a new file.
 * 
 *  Relocates the movie header to the end of the file if necessary.
 *  
 *  @author The JCodec project
 *  
 */
var RelocateMP4Editor = function() {};
RelocateMP4Editor = stjs.extend(RelocateMP4Editor, null, [], function(constructor, prototype) {
    prototype.modifyOrRelocate = function(src, edit) {
        var modify = new InplaceMP4Editor().modify(src, edit);
        if (!modify) 
            this.relocate(src, edit);
    };
    prototype.relocate = function(src, edit) {
        var f = null;
        try {
            f = NIOUtils.rwChannel(src);
            var moovAtom = this.getMoov(f);
            var moovBuffer = this.fetchBox(f, moovAtom);
            var moovBox = this.parseBox(moovBuffer);
            edit.apply(moovBox);
            if (moovAtom.getOffset() + moovAtom.getHeader().getSize() < f.size()) {
                Logger.info("Relocating movie header to the end of the file.");
                f.setPosition(moovAtom.getOffset() + 4);
                f.write(ByteBuffer.wrap(Header.FOURCC_FREE));
                f.setPosition(f.size());
            } else {
                f.setPosition(moovAtom.getOffset());
            }
            MP4Util.writeMovie(f, moovBox);
        } finally {
            NIOUtils.closeQuietly(f);
        }
    };
    prototype.fetchBox = function(fi, moov) {
        fi.setPosition(moov.getOffset());
        var oldMov = NIOUtils.fetchFromChannel(fi, ((moov.getHeader().getSize()) | 0));
        return oldMov;
    };
    prototype.parseBox = function(oldMov) {
        var header = Header.read(oldMov);
        var box = BoxUtil.parseBox(oldMov, header, BoxFactory.getDefault());
        return box;
    };
    prototype.getMoov = function(f) {
        for (var iterator$atom = MP4Util.getRootAtoms(f).iterator(); iterator$atom.hasNext(); ) {
            var atom = iterator$atom.next();
            if ("moov".equals(atom.getHeader().getFourcc())) {
                return atom;
            }
        }
        return null;
    };
}, {}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Encodes a sequence of images as a video.
 *  
 *  @author The JCodec project
 */
var SequenceEncoder = function(out, fps, outputFormat, outputVideoCodec, outputAudioCodec) {
    this.fps = fps;
    this.sink = SinkImpl.createWithStream(out, outputFormat, outputVideoCodec, outputAudioCodec);
    this.sink.init();
    if (this.sink.getInputColor() != null) 
        this.transform = ColorUtil.getTransform(ColorSpace.RGB, this.sink.getInputColor());
    this.pixelStore = new PixelStoreImpl();
};
SequenceEncoder = stjs.extend(SequenceEncoder, null, [], function(constructor, prototype) {
    prototype.transform = null;
    prototype.frameNo = 0;
    prototype.timestamp = 0;
    prototype.fps = null;
    prototype.sink = null;
    prototype.pixelStore = null;
    constructor.createSequenceEncoder = function(out, fps) {
        return new SequenceEncoder(NIOUtils.writableChannel(out), Rational.R(fps, 1), Format.MOV, Codec.H264, null);
    };
    constructor.create25Fps = function(out) {
        return new SequenceEncoder(NIOUtils.writableChannel(out), Rational.R(25, 1), Format.MOV, Codec.H264, null);
    };
    constructor.create30Fps = function(out) {
        return new SequenceEncoder(NIOUtils.writableChannel(out), Rational.R(30, 1), Format.MOV, Codec.H264, null);
    };
    constructor.create2997Fps = function(out) {
        return new SequenceEncoder(NIOUtils.writableChannel(out), Rational.R(30000, 1001), Format.MOV, Codec.H264, null);
    };
    constructor.create24Fps = function(out) {
        return new SequenceEncoder(NIOUtils.writableChannel(out), Rational.R(24, 1), Format.MOV, Codec.H264, null);
    };
    constructor.createWithFps = function(out, fps) {
        return new SequenceEncoder(out, fps, Format.MOV, Codec.H264, null);
    };
    /**
     *  Encodes a frame into a movie.
     *  
     *  @param pic
     *  @throws IOException
     */
    prototype.encodeNativeFrame = function(pic) {
        if (pic.getColor() != ColorSpace.RGB) 
             throw new IllegalArgumentException("The input images is expected in RGB color.");
        var sinkColor = this.sink.getInputColor();
        var toEncode;
        if (sinkColor != null) {
            toEncode = this.pixelStore.getPicture(pic.getWidth(), pic.getHeight(), sinkColor);
            this.transform.transform(pic, toEncode.getPicture());
        } else {
            toEncode = new PixelStore.LoanerPicture(pic, 0);
        }
        var pkt = Packet.createPacket(null, this.timestamp, this.fps.getNum(), this.fps.getDen(), this.frameNo, Packet.FrameType.KEY, null);
        this.sink.outputVideoFrame(new VideoFrameWithPacket(pkt, toEncode));
        if (sinkColor != null) 
            this.pixelStore.putBack(toEncode);
        this.timestamp += this.fps.getDen();
        this.frameNo++;
    };
    prototype.finish = function() {
        this.sink.finish();
    };
}, {transform: "Transform", fps: "Rational", sink: "Sink", pixelStore: "PixelStore"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Extracts frames from a movie into uncompressed images suitable for
 *  processing.
 *  
 *  Supports going to random points inside of a movie ( seeking ) by frame number
 *  of by second.
 *  
 *  NOTE: Supports only AVC ( H.264 ) in MP4 ( ISO BMF, QuickTime ) at this
 *  point.
 *  
 *  @author The JCodec project
 *  
 */
var FrameGrab = function(videoTrack, decoder) {
    this.videoTrack = videoTrack;
    this.decoder = decoder;
    this.buffers = new ThreadLocal();
};
FrameGrab = stjs.extend(FrameGrab, null, [], function(constructor, prototype) {
    prototype.videoTrack = null;
    prototype.decoder = null;
    prototype.buffers = null;
    constructor.createFrameGrab = function(_in) {
        var header = ByteBuffer.allocate(65536);
        _in.read(header);
        header.flip();
        var detectFormat = JCodecUtil.detectFormatBuffer(header);
        if (detectFormat == null) {
             throw new UnsupportedFormatException("Could not detect the format of the input video.");
        }
        var videoTrack_;
        if (Format.MOV == detectFormat) {
            var d1 = MP4Demuxer.createMP4Demuxer(_in);
            videoTrack_ = d1.getVideoTrack();
        } else if (Format.MPEG_PS == detectFormat) {
             throw new UnsupportedFormatException("MPEG PS is temporarily unsupported.");
        } else if (Format.MPEG_TS == detectFormat) {
             throw new UnsupportedFormatException("MPEG TS is temporarily unsupported.");
        } else {
             throw new UnsupportedFormatException("Container format is not supported by JCodec");
        }
        var fg = new FrameGrab(videoTrack_, FrameGrab.detectDecoder(videoTrack_));
        fg.decodeLeadingFrames();
        return fg;
    };
    prototype.sdt = function() {
        if (!(stjs.isInstanceOf(this.videoTrack.constructor, SeekableDemuxerTrack))) 
             throw new JCodecException("Not a seekable track");
        return this.videoTrack;
    };
    /**
     *  Position frame grabber to a specific second in a movie. As a result the
     *  next decoded frame will be precisely at the requested second.
     *  
     *  WARNING: potentially very slow. Use only when you absolutely need precise
     *  seek. Tries to seek to exactly the requested second and for this it might
     *  have to decode a sequence of frames from the closes key frame. Depending
     *  on GOP structure this may be as many as 500 frames.
     *  
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    prototype.seekToSecondPrecise = function(second) {
        this.sdt().seek(second);
        this.decodeLeadingFrames();
        return this;
    };
    /**
     *  Position frame grabber to a specific frame in a movie. As a result the
     *  next decoded frame will be precisely the requested frame number.
     *  
     *  WARNING: potentially very slow. Use only when you absolutely need precise
     *  seek. Tries to seek to exactly the requested frame and for this it might
     *  have to decode a sequence of frames from the closes key frame. Depending
     *  on GOP structure this may be as many as 500 frames.
     *  
     *  @param frameNumber
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    prototype.seekToFramePrecise = function(frameNumber) {
        this.sdt().gotoFrame(frameNumber);
        this.decodeLeadingFrames();
        return this;
    };
    /**
     *  Position frame grabber to a specific second in a movie.
     *  
     *  Performs a sloppy seek, meaning that it may actually not seek to exact
     *  second requested, instead it will seek to the closest key frame
     *  
     *  NOTE: fast, as it just seeks to the closest previous key frame and
     *  doesn't try to decode frames in the middle
     *  
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    prototype.seekToSecondSloppy = function(second) {
        this.sdt().seek(second);
        this.goToPrevKeyframe();
        return this;
    };
    /**
     *  Position frame grabber to a specific frame in a movie
     *  
     *  Performs a sloppy seek, meaning that it may actually not seek to exact
     *  frame requested, instead it will seek to the closest key frame
     *  
     *  NOTE: fast, as it just seeks to the closest previous key frame and
     *  doesn't try to decode frames in the middle
     *  
     *  @param frameNumber
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    prototype.seekToFrameSloppy = function(frameNumber) {
        this.sdt().gotoFrame(frameNumber);
        this.goToPrevKeyframe();
        return this;
    };
    prototype.goToPrevKeyframe = function() {
        this.sdt().gotoFrame(this.detectKeyFrame(((this.sdt().getCurFrame()) | 0)));
    };
    prototype.decodeLeadingFrames = function() {
        var sdt = this.sdt();
        var curFrame = ((sdt.getCurFrame()) | 0);
        var keyFrame = this.detectKeyFrame(curFrame);
        sdt.gotoFrame(keyFrame);
        var frame = sdt.nextFrame();
        if (this.decoder == null) 
            this.decoder = FrameGrab.detectDecoder(sdt);
         while (frame.getFrameNo() < curFrame){
            this.decoder.decodeFrame(frame, this.getBuffer());
            frame = sdt.nextFrame();
        }
        sdt.gotoFrame(curFrame);
    };
    prototype.getBuffer = function() {
        var buf = this.buffers.get();
        if (buf == null) {
            buf = this.decoder.allocatePicture();
            this.buffers.set(buf);
        }
        return buf;
    };
    prototype.detectKeyFrame = function(start) {
        var seekFrames = this.videoTrack.getMeta().getSeekFrames();
        if (seekFrames == null) 
            return start;
        var prev = seekFrames[0];
        for (var i = 1; i < seekFrames.length; i++) {
            if (seekFrames[i] > start) 
                break;
            prev = seekFrames[i];
        }
        return prev;
    };
    constructor.detectDecoder = function(videoTrack) {
        var meta = videoTrack.getMeta();
        if (Codec.H264 == meta.getCodec()) {
            return new AVCMP4Adaptor(meta);
        } else {
             throw new UnsupportedFormatException("Codec is not supported");
        }
    };
    /**
     *  Get frame at current position in JCodec native image
     *  
     *  @return A decoded picture with metadata.
     *  @throws IOException
     */
    prototype.getNativeFrameWithMetadata = function() {
        var frame = this.videoTrack.nextFrame();
        if (frame == null) 
            return null;
        var picture = this.decoder.decodeFrame(frame, this.getBuffer());
        return new PictureWithMetadata(picture, frame.getPtsD(), frame.getDurationD(), this.videoTrack.getMeta().getOrientation());
    };
    /**
     *  Get frame at current position in JCodec native image
     *  
     *  @return
     *  @throws IOException
     */
    prototype.getNativeFrame = function() {
        var frame = this.videoTrack.nextFrame();
        if (frame == null) 
            return null;
        return this.decoder.decodeFrame(frame, this.getBuffer());
    };
    /**
     *  Get frame at a specified second as JCodec image
     *  
     *  @param file
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getFrameAtSec = function(file, second) {
        var ch = null;
        try {
            ch = NIOUtils.readableChannel(file);
            return FrameGrab.createFrameGrab(ch).seekToSecondPrecise(second).getNativeFrame();
        } finally {
            NIOUtils.closeQuietly(ch);
        }
    };
    /**
     *  Get frame at a specified second as JCodec image
     *  
     *  @param file
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getFrameFromChannelAtSec = function(file, second) {
        return FrameGrab.createFrameGrab(file).seekToSecondPrecise(second).getNativeFrame();
    };
    /**
     *  Get frame at a specified frame number as JCodec image
     *  
     *  @param file
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getFrameFromFile = function(file, frameNumber) {
        var ch = null;
        try {
            ch = NIOUtils.readableChannel(file);
            return FrameGrab.createFrameGrab(ch).seekToFramePrecise(frameNumber).getNativeFrame();
        } finally {
            NIOUtils.closeQuietly(ch);
        }
    };
    /**
     *  Get frame at a specified frame number as JCodec image
     *  
     *  @param file
     *  @param second
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getFrameFromChannel = function(file, frameNumber) {
        return FrameGrab.createFrameGrab(file).seekToFramePrecise(frameNumber).getNativeFrame();
    };
    /**
     *  Get a specified frame by number from an already open demuxer track
     *  
     *  @param vt
     *  @param decoder
     *  @param frameNumber
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getNativeFrameAtFrame = function(vt, decoder, frameNumber) {
        return new FrameGrab(vt, decoder).seekToFramePrecise(frameNumber).getNativeFrame();
    };
    /**
     *  Get a specified frame by second from an already open demuxer track
     *  
     *  @param vt
     *  @param decoder
     *  @param frameNumber
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getNativeFrameAtSec = function(vt, decoder, second) {
        return new FrameGrab(vt, decoder).seekToSecondPrecise(second).getNativeFrame();
    };
    /**
     *  Get a specified frame by number from an already open demuxer track (
     *  sloppy mode, i.e. nearest keyframe )
     *  
     *  @param vt
     *  @param decoder
     *  @param frameNumber
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getNativeFrameSloppy = function(vt, decoder, frameNumber) {
        return new FrameGrab(vt, decoder).seekToFrameSloppy(frameNumber).getNativeFrame();
    };
    /**
     *  Get a specified frame by second from an already open demuxer track (
     *  sloppy mode, i.e. nearest keyframe )
     *  
     *  @param vt
     *  @param decoder
     *  @param frameNumber
     *  @return
     *  @throws IOException
     *  @throws JCodecException
     */
    constructor.getNativeFrameAtSecSloppy = function(vt, decoder, second) {
        return new FrameGrab(vt, decoder).seekToSecondSloppy(second).getNativeFrame();
    };
    /**
     *  Gets info about the media
     *  
     *  @return
     */
    prototype.getMediaInfo = function() {
        return this.decoder.getMediaInfo();
    };
    /**
     *  @return the videoTrack
     */
    prototype.getVideoTrack = function() {
        return this.videoTrack;
    };
    /**
     *  @return the decoder
     */
    prototype.getDecoder = function() {
        return this.decoder;
    };
}, {videoTrack: "SeekableDemuxerTrack", decoder: "ContainerAdaptor", buffers: {name: "ThreadLocal", arguments: ["Array"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  Transcoder command line.
 *  
 *  @author The JCodec project
 *  
 */
var TranscodeMain = function() {};
TranscodeMain = stjs.extend(TranscodeMain, null, [], function(constructor, prototype) {
    constructor.FLAG_INPUT = new MainUtils.Flag("input", "i", "Designates an input argument", MainUtils.FlagType.VOID);
    constructor.FLAG_MAP_VIDEO = MainUtils.Flag.flag("map:v", "mv", "Map a video from a specified input into this output");
    constructor.FLAG_MAP_AUDIO = MainUtils.Flag.flag("map:a", "ma", "Map a audio from a specified input into this output");
    constructor.FLAG_SEEK_FRAMES = MainUtils.Flag.flag("seek-frames", null, "Seek frames");
    constructor.FLAG_MAX_FRAMES = MainUtils.Flag.flag("max-frames", "limit", "Max frames");
    constructor.FLAG_AUDIO_CODEC = MainUtils.Flag.flag("codec:audio", "acodec", "Audio codec [default=auto].");
    constructor.FLAG_VIDEO_CODEC = MainUtils.Flag.flag("codec:video", "vcodec", "Video codec [default=auto].");
    constructor.FLAG_FORMAT = MainUtils.Flag.flag("format", "f", "Format [default=auto].");
    constructor.FLAG_PROFILE = MainUtils.Flag.flag("profile", null, "Profile to use (supported by some encoders).");
    constructor.FLAG_INTERLACED = MainUtils.Flag.flag("interlaced", null, "Encode output as interlaced (supported by Prores encoder).");
    constructor.FLAG_DUMPMV = MainUtils.Flag.flag("dumpMv", null, "Dump motion vectors (supported by h.264 decoder).");
    constructor.FLAG_DUMPMVJS = MainUtils.Flag.flag("dumpMvJs", null, "Dump motion vectors in form of JASON file (supported by h.264 decoder).");
    constructor.FLAG_DOWNSCALE = MainUtils.Flag.flag("downscale", null, "Decode frames in downscale (supported by MPEG, Prores and Jpeg decoders).");
    constructor.FLAG_VIDEO_FILTER = MainUtils.Flag.flag("videoFilter", "vf", "Contains a comma separated list of video filters with arguments.");
    constructor.ALL_FLAGS = [TranscodeMain.FLAG_INPUT, TranscodeMain.FLAG_FORMAT, TranscodeMain.FLAG_VIDEO_CODEC, TranscodeMain.FLAG_AUDIO_CODEC, TranscodeMain.FLAG_SEEK_FRAMES, TranscodeMain.FLAG_MAX_FRAMES, TranscodeMain.FLAG_PROFILE, TranscodeMain.FLAG_INTERLACED, TranscodeMain.FLAG_DUMPMV, TranscodeMain.FLAG_DUMPMVJS, TranscodeMain.FLAG_DOWNSCALE, TranscodeMain.FLAG_MAP_VIDEO, TranscodeMain.FLAG_MAP_AUDIO, TranscodeMain.FLAG_VIDEO_FILTER];
    constructor.extensionToF = new HashMap();
    constructor.extensionToC = new HashMap();
    constructor.videoCodecsForF = new HashMap();
    constructor.audioCodecsForF = new HashMap();
    constructor.supportedDecoders = new HashSet();
    constructor.knownFilters = new HashMap();
    constructor.main = function(args) {
        Logger.addSink(new OutLogSink(System.out, new OutLogSink.SimpleFormat("#message"), LogLevel.INFO));
        var cmd = MainUtils.parseArguments(args, TranscodeMain.ALL_FLAGS);
        var builder = Transcoder.newTranscoder();
        var sources = new ArrayList();
        var inputCodecsVideo = new ArrayList();
        var inputCodecsAudio = new ArrayList();
        for (var index = 0; index < cmd.argsLength(); index++) {
            if (!cmd.getBooleanFlagI(index, TranscodeMain.FLAG_INPUT)) 
                continue;
            var inputCodecVideo = null, inputCodecAudio = null;
            var input = cmd.getArg(index);
            var inputFormatRaw = cmd.getStringFlagI(index, TranscodeMain.FLAG_FORMAT);
            var inputFormat;
            if (inputFormatRaw == null) {
                inputFormat = TranscodeMain.getFormatFromExtension(input);
                if (inputFormat != Format.IMG) {
                    var detectFormat = JCodecUtil.detectFormat(new File(input));
                    if (detectFormat != null) {
                        inputFormat = detectFormat;
                    }
                }
            } else {
                inputFormat = Format.valueOf(inputFormatRaw.toUpperCase());
            }
            if (inputFormat == null) {
                Logger.error("Input format could not be detected");
                return;
            } else {
                Logger.info(String.format("Input stream %d: %s", index, String.valueOf(inputFormat)));
            }
            var videoTrackNo = -1;
            var inputCodecVideoRaw = cmd.getStringFlagI(index, TranscodeMain.FLAG_VIDEO_CODEC);
            if (inputCodecVideoRaw == null) {
                if (inputFormat == Format.IMG) {
                    inputCodecVideo = Tuple.triple(0, 0, TranscodeMain.getCodecFromExtension(input));
                } else if (inputFormat.isVideo()) {
                    inputCodecVideo = TranscodeMain.selectSuitableTrack(input, inputFormat, TrackType.VIDEO);
                }
            } else {
                inputCodecVideo = Tuple.triple(0, 0, Codec.valueOf(inputCodecVideoRaw.toUpperCase()));
            }
            if (inputCodecVideo != null) {
                if (inputFormat == Format.MPEG_TS) {
                    Logger.info(String.format("Video codec: %s[pid=%d,stream=%d]", String.valueOf(inputCodecVideo.v2), inputCodecVideo.v0, inputCodecVideo.v1));
                } else {
                    Logger.info(String.format("Video codec: %s", String.valueOf(inputCodecVideo.v2)));
                }
            }
            var inputCodecAudioRaw = cmd.getStringFlagI(index, TranscodeMain.FLAG_AUDIO_CODEC);
            if (inputCodecAudioRaw == null) {
                if (inputFormat.isAudio()) {
                    inputCodecAudio = TranscodeMain.selectSuitableTrack(input, inputFormat, TrackType.AUDIO);
                }
            } else {
                inputCodecAudio = Tuple.triple(0, 0, Codec.valueOf(inputCodecAudioRaw.toUpperCase()));
            }
            if (inputCodecAudio != null) {
                if (inputFormat == Format.MPEG_TS) {
                    Logger.info(String.format("Audio codec: %s[pid=%d,stream=%d]", String.valueOf(inputCodecAudio.v2), inputCodecAudio.v0, inputCodecAudio.v1));
                } else {
                    Logger.info(String.format("Audio codec: %s", String.valueOf(inputCodecAudio.v2)));
                }
            }
            var source = new SourceImpl(input, inputFormat, inputCodecVideo, inputCodecAudio);
            var downscale = cmd.getIntegerFlagID(index, TranscodeMain.FLAG_DOWNSCALE, 1);
            if (downscale != null && (1 << MathUtil.log2(downscale)) != downscale) {
                Logger.error("Only values [2, 4, 8] are supported for " + TranscodeMain.FLAG_DOWNSCALE + ", the option will have no effect.");
            } else {
                source.setOption(Options.DOWNSCALE, downscale);
            }
            source.setOption(Options.PROFILE, cmd.getStringFlagI(index, TranscodeMain.FLAG_PROFILE));
            source.setOption(Options.INTERLACED, cmd.getBooleanFlagID(index, TranscodeMain.FLAG_INTERLACED, false));
            sources.add(source);
            inputCodecsVideo.add(inputCodecVideo);
            inputCodecsAudio.add(inputCodecAudio);
            builder.addSource(source);
            builder.setSeekFrames(sources.size() - 1, cmd.getIntegerFlagID(index, TranscodeMain.FLAG_SEEK_FRAMES, 0)).setMaxFrames(sources.size() - 1, cmd.getIntegerFlagID(index, TranscodeMain.FLAG_MAX_FRAMES, Integer.MAX_VALUE));
        }
        if (sources.isEmpty()) {
            MainUtils.printHelpArgs(TranscodeMain.ALL_FLAGS, ["input", "output"]);
            return;
        }
        var sinks = new ArrayList();
        for (var index = 0; index < cmd.argsLength(); index++) {
            if (cmd.getBooleanFlagI(index, TranscodeMain.FLAG_INPUT)) 
                continue;
            var output = cmd.getArg(index);
            var outputFormatRaw = cmd.getStringFlagI(index, TranscodeMain.FLAG_FORMAT);
            var outputFormat;
            if (outputFormatRaw == null) {
                outputFormat = TranscodeMain.getFormatFromExtension(output);
            } else {
                outputFormat = Format.valueOf(outputFormatRaw.toUpperCase());
            }
            var outputCodecVideoRaw = cmd.getStringFlagI(index, TranscodeMain.FLAG_VIDEO_CODEC);
            var outputCodecVideo = null;
            var videoCopy = false;
            if (outputCodecVideoRaw == null) {
                outputCodecVideo = TranscodeMain.getCodecFromExtension(output);
                if (outputCodecVideo == null) 
                    outputCodecVideo = TranscodeMain.getFirstVideoCodecForFormat(outputFormat);
            } else {
                if ("copy".equalsIgnoreCase(outputCodecVideoRaw)) {
                    videoCopy = true;
                } else if ("none".equalsIgnoreCase(outputCodecVideoRaw)) {
                    outputCodecVideo = null;
                } else {
                    outputCodecVideo = Codec.valueOf(outputCodecVideoRaw.toUpperCase());
                }
            }
            var outputCodecAudioRaw = cmd.getStringFlagI(index, TranscodeMain.FLAG_AUDIO_CODEC);
            var outputCodecAudio = null;
            var audioCopy = false;
            if (outputCodecAudioRaw == null) {
                if (outputFormat.isAudio()) 
                    outputCodecAudio = TranscodeMain.getFirstAudioCodecForFormat(outputFormat);
            } else {
                if ("copy".equalsIgnoreCase(outputCodecAudioRaw)) {
                    audioCopy = true;
                } else if ("none".equalsIgnoreCase(outputCodecVideoRaw)) {
                    outputCodecAudio = null;
                } else {
                    outputCodecAudio = Codec.valueOf(outputCodecAudioRaw.toUpperCase());
                }
            }
            var audioMap = cmd.getIntegerFlagID(index, TranscodeMain.FLAG_MAP_AUDIO, 0);
            if (audioMap > sources.size()) {
                Logger.error("Can not map audio from source " + audioMap + ", " + sources.size() + " sources specified.");
            }
            var videoMap = cmd.getIntegerFlagID(index, TranscodeMain.FLAG_MAP_VIDEO, 0);
            if (videoMap > sources.size()) {
                Logger.error("Can not map video from source " + videoMap + ", " + sources.size() + " sources specified.");
            }
            if (videoCopy) {
                var inputCodecVideo = inputCodecsVideo.get(videoMap);
                outputCodecVideo = inputCodecVideo != null ? inputCodecVideo.v2 : null;
            }
            if (audioCopy) {
                var inputCodecAudio = inputCodecsAudio.get(audioMap);
                outputCodecAudio = inputCodecAudio != null ? inputCodecAudio.v2 : null;
            }
            var sink = new SinkImpl(output, outputFormat, outputCodecVideo, outputCodecAudio);
            sinks.add(sink);
            builder.addSink(sink);
            builder.setAudioMapping(audioMap, sinks.size() - 1, audioCopy);
            builder.setVideoMapping(videoMap, sinks.size() - 1, videoCopy);
            if (cmd.getBooleanFlagI(index, TranscodeMain.FLAG_DUMPMV)) 
                builder.addFilter(sinks.size() - 1, new DumpMvFilter(false));
             else if (cmd.getBooleanFlagI(index, TranscodeMain.FLAG_DUMPMVJS)) 
                builder.addFilter(sinks.size() - 1, new DumpMvFilter(true));
            var vf = cmd.getStringFlagI(index, TranscodeMain.FLAG_VIDEO_FILTER);
            if (vf != null) {
                TranscodeMain.addVideoFilters(vf, builder, sinks.size() - 1);
            }
        }
        if (sources.isEmpty() || sinks.isEmpty()) {
            MainUtils.printHelpArgs(TranscodeMain.ALL_FLAGS, ["input", "output"]);
            return;
        }
        var transcoder = builder.create();
        transcoder.transcode();
    };
    constructor.addVideoFilters = function(vf, builder, sinkIndex) {
        if (vf == null) 
            return;
        for (var index$filter = 0, arr$filter = vf.split(","); index$filter < arr$filter.length; index$filter++) {
            var filter = arr$filter[index$filter];
            var parts = filter.split("=");
            var filterName = parts[0];
            var filterClass = TranscodeMain.knownFilters.get(filterName);
            if (filterClass == null) {
                Logger.error("Unknown filter: " + filterName);
                 throw new RuntimeException("Unknown filter: " + filterName);
            }
            if (parts.length > 1) {
                var filterArgs = parts[1];
                var split = filterArgs.split(":");
                var params = Array(split.length);
                for (var i = 0; i < split.length; i++) {
                    params[i] = Integer.parseInt(split[i]);
                }
                try {
                    var f = Platform.newInstance(filterClass, params);
                    builder.addFilter(sinkIndex, f);
                }catch (e) {
                    var message = "The filter " + filterName + " doesn't take " + split.length + " arguments.";
                    Logger.error(message);
                     throw new RuntimeException(message);
                }
            }
        }
    };
    constructor.getFirstAudioCodecForFormat = function(inputFormat) {
        return TranscodeMain.audioCodecsForF.get(inputFormat);
    };
    constructor.getFirstVideoCodecForFormat = function(inputFormat) {
        return TranscodeMain.videoCodecsForF.get(inputFormat);
    };
    constructor.detectVideoDecoder = function(track) {
        var meta = track.getMeta();
        if (meta != null) {
            var codec = meta.getCodec();
            if (codec != null) 
                return codec;
        }
        var packet = track.nextFrame();
        if (packet == null) 
            return null;
        return JCodecUtil.detectDecoder(packet.getData());
    };
    constructor.selectSuitableTrack = function(input, format, targetType) {
        var demuxerPid;
        if (format == Format.MPEG_TS) {
            demuxerPid = JCodecUtil.createM2TSDemuxer(new File(input), targetType);
        } else {
            demuxerPid = Tuple.pair(0, JCodecUtil.createDemuxer(format, new File(input)));
        }
        if (demuxerPid == null || demuxerPid.v1 == null) 
            return null;
        var trackNo = 0;
        var tracks = targetType == TrackType.VIDEO ? demuxerPid.v1.getVideoTracks() : demuxerPid.v1.getAudioTracks();
        for (var iterator$demuxerTrack = tracks.iterator(); iterator$demuxerTrack.hasNext(); ) {
            var demuxerTrack = iterator$demuxerTrack.next();
            var codec = TranscodeMain.detectVideoDecoder(demuxerTrack);
            if (TranscodeMain.supportedDecoders.contains(codec)) {
                return Tuple.triple(demuxerPid.v0, trackNo, codec);
            }
            trackNo++;
        }
        return null;
    };
    constructor.getFormatFromExtension = function(output) {
        var extension = output.replaceFirst(".*\\.([^\\.]+$)", "$1");
        return TranscodeMain.extensionToF.get(extension);
    };
    constructor.getCodecFromExtension = function(output) {
        var extension = output.replaceFirst(".*\\.([^\\.]+$)", "$1");
        return TranscodeMain.extensionToC.get(extension);
    };
}, {FLAG_INPUT: "MainUtils.Flag", FLAG_MAP_VIDEO: "MainUtils.Flag", FLAG_MAP_AUDIO: "MainUtils.Flag", FLAG_SEEK_FRAMES: "MainUtils.Flag", FLAG_MAX_FRAMES: "MainUtils.Flag", FLAG_AUDIO_CODEC: "MainUtils.Flag", FLAG_VIDEO_CODEC: "MainUtils.Flag", FLAG_FORMAT: "MainUtils.Flag", FLAG_PROFILE: "MainUtils.Flag", FLAG_INTERLACED: "MainUtils.Flag", FLAG_DUMPMV: "MainUtils.Flag", FLAG_DUMPMVJS: "MainUtils.Flag", FLAG_DOWNSCALE: "MainUtils.Flag", FLAG_VIDEO_FILTER: "MainUtils.Flag", ALL_FLAGS: "Array", extensionToF: {name: "Map", arguments: [null, "Format"]}, extensionToC: {name: "Map", arguments: [null, "Codec"]}, videoCodecsForF: {name: "Map", arguments: ["Format", "Codec"]}, audioCodecsForF: {name: "Map", arguments: ["Format", "Codec"]}, supportedDecoders: {name: "Set", arguments: ["Codec"]}, knownFilters: {name: "Map", arguments: [null, {name: "Class", arguments: ["Object"]}]}}, {});
(function() {
    TranscodeMain.extensionToF.put("mp3", Format.MPEG_AUDIO);
    TranscodeMain.extensionToF.put("mp2", Format.MPEG_AUDIO);
    TranscodeMain.extensionToF.put("mp1", Format.MPEG_AUDIO);
    TranscodeMain.extensionToF.put("mpg", Format.MPEG_PS);
    TranscodeMain.extensionToF.put("mpeg", Format.MPEG_PS);
    TranscodeMain.extensionToF.put("m2p", Format.MPEG_PS);
    TranscodeMain.extensionToF.put("ps", Format.MPEG_PS);
    TranscodeMain.extensionToF.put("vob", Format.MPEG_PS);
    TranscodeMain.extensionToF.put("evo", Format.MPEG_PS);
    TranscodeMain.extensionToF.put("mod", Format.MPEG_PS);
    TranscodeMain.extensionToF.put("tod", Format.MPEG_PS);
    TranscodeMain.extensionToF.put("ts", Format.MPEG_TS);
    TranscodeMain.extensionToF.put("m2t", Format.MPEG_TS);
    TranscodeMain.extensionToF.put("mp4", Format.MOV);
    TranscodeMain.extensionToF.put("m4a", Format.MOV);
    TranscodeMain.extensionToF.put("m4v", Format.MOV);
    TranscodeMain.extensionToF.put("mov", Format.MOV);
    TranscodeMain.extensionToF.put("3gp", Format.MOV);
    TranscodeMain.extensionToF.put("mkv", Format.MKV);
    TranscodeMain.extensionToF.put("webm", Format.MKV);
    TranscodeMain.extensionToF.put("264", Format.H264);
    TranscodeMain.extensionToF.put("jsv", Format.H264);
    TranscodeMain.extensionToF.put("h264", Format.H264);
    TranscodeMain.extensionToF.put("raw", Format.RAW);
    TranscodeMain.extensionToF.put("", Format.RAW);
    TranscodeMain.extensionToF.put("flv", Format.FLV);
    TranscodeMain.extensionToF.put("avi", Format.AVI);
    TranscodeMain.extensionToF.put("jpg", Format.IMG);
    TranscodeMain.extensionToF.put("jpeg", Format.IMG);
    TranscodeMain.extensionToF.put("png", Format.IMG);
    TranscodeMain.extensionToF.put("mjp", Format.MJPEG);
    TranscodeMain.extensionToF.put("ivf", Format.IVF);
    TranscodeMain.extensionToF.put("y4m", Format.Y4M);
    TranscodeMain.extensionToF.put("wav", Format.WAV);
    TranscodeMain.extensionToC.put("mpg", Codec.MPEG2);
    TranscodeMain.extensionToC.put("mpeg", Codec.MPEG2);
    TranscodeMain.extensionToC.put("m2p", Codec.MPEG2);
    TranscodeMain.extensionToC.put("ps", Codec.MPEG2);
    TranscodeMain.extensionToC.put("vob", Codec.MPEG2);
    TranscodeMain.extensionToC.put("evo", Codec.MPEG2);
    TranscodeMain.extensionToC.put("mod", Codec.MPEG2);
    TranscodeMain.extensionToC.put("tod", Codec.MPEG2);
    TranscodeMain.extensionToC.put("ts", Codec.MPEG2);
    TranscodeMain.extensionToC.put("m2t", Codec.MPEG2);
    TranscodeMain.extensionToC.put("m4a", Codec.AAC);
    TranscodeMain.extensionToC.put("mkv", Codec.H264);
    TranscodeMain.extensionToC.put("webm", Codec.VP8);
    TranscodeMain.extensionToC.put("264", Codec.H264);
    TranscodeMain.extensionToC.put("raw", Codec.RAW);
    TranscodeMain.extensionToC.put("jpg", Codec.JPEG);
    TranscodeMain.extensionToC.put("jpeg", Codec.JPEG);
    TranscodeMain.extensionToC.put("png", Codec.PNG);
    TranscodeMain.extensionToC.put("mjp", Codec.JPEG);
    TranscodeMain.extensionToC.put("y4m", Codec.RAW);
    TranscodeMain.videoCodecsForF.put(Format.MPEG_PS, Codec.MPEG2);
    TranscodeMain.audioCodecsForF.put(Format.MPEG_PS, Codec.MP2);
    TranscodeMain.videoCodecsForF.put(Format.MOV, Codec.H264);
    TranscodeMain.audioCodecsForF.put(Format.MOV, Codec.AAC);
    TranscodeMain.videoCodecsForF.put(Format.MKV, Codec.VP8);
    TranscodeMain.audioCodecsForF.put(Format.MKV, Codec.VORBIS);
    TranscodeMain.audioCodecsForF.put(Format.WAV, Codec.PCM);
    TranscodeMain.videoCodecsForF.put(Format.H264, Codec.H264);
    TranscodeMain.videoCodecsForF.put(Format.RAW, Codec.RAW);
    TranscodeMain.videoCodecsForF.put(Format.FLV, Codec.H264);
    TranscodeMain.videoCodecsForF.put(Format.AVI, Codec.MPEG4);
    TranscodeMain.videoCodecsForF.put(Format.IMG, Codec.PNG);
    TranscodeMain.videoCodecsForF.put(Format.MJPEG, Codec.JPEG);
    TranscodeMain.videoCodecsForF.put(Format.IVF, Codec.VP8);
    TranscodeMain.videoCodecsForF.put(Format.Y4M, Codec.RAW);
    TranscodeMain.supportedDecoders.add(Codec.AAC);
    TranscodeMain.supportedDecoders.add(Codec.H264);
    TranscodeMain.supportedDecoders.add(Codec.JPEG);
    TranscodeMain.supportedDecoders.add(Codec.MPEG2);
    TranscodeMain.supportedDecoders.add(Codec.PCM);
    TranscodeMain.supportedDecoders.add(Codec.PNG);
    TranscodeMain.supportedDecoders.add(Codec.MPEG4);
    TranscodeMain.supportedDecoders.add(Codec.PRORES);
    TranscodeMain.supportedDecoders.add(Codec.RAW);
    TranscodeMain.supportedDecoders.add(Codec.VP8);
    TranscodeMain.supportedDecoders.add(Codec.MP3);
    TranscodeMain.supportedDecoders.add(Codec.MP2);
    TranscodeMain.supportedDecoders.add(Codec.MP1);
    TranscodeMain.knownFilters.put("scale", ScaleFilter);
})();
if (!stjs.mainCallDisabled) 
    TranscodeMain.main();
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var QTEdit = function(_arguments) {
    this.listeners = new ArrayList();
    this.factories = arguments;
};
QTEdit = stjs.extend(QTEdit, null, [], function(constructor, prototype) {
    prototype.factories = null;
    prototype.listeners = null;
    constructor.EditFactory = function() {};
    constructor.EditFactory = stjs.extend(constructor.EditFactory, null, [], function(constructor, prototype) {
        prototype.getName = function() {};
        prototype.parseArgs = function(args) {};
        prototype.getHelp = function() {};
    }, {}, {});
    constructor.BaseCommand = function() {};
    constructor.BaseCommand = stjs.extend(constructor.BaseCommand, null, [MP4Edit], function(constructor, prototype) {
        prototype.applyRefs = function(movie, refs) {
            this.apply(movie);
        };
        prototype.apply = function(movie) {};
    }, {}, {});
    prototype.addProgressListener = function(listener) {
        this.listeners.add(listener);
    };
    prototype.execute = function(args) {
        var aa = new LinkedList(Arrays.asList(args));
        var commands = new LinkedList();
         while (aa.size() > 0){
            var i;
            for (i = 0; i < this.factories.length; i++) {
                if (aa.get(0).equals(this.factories[i].getName())) {
                    aa.remove(0);
                    try {
                        commands.add(this.factories[i].parseArgs(aa));
                    }catch (e) {
                        System.err.println("ERROR: " + e.getMessage());
                        return;
                    }
                    break;
                }
            }
            if (i == this.factories.length) 
                break;
        }
        if (aa.size() == 0) {
            System.err.println("ERROR: A movie file should be specified");
            this.help();
        }
        if (commands.size() == 0) {
            System.err.println("ERROR: At least one command should be specified");
            this.help();
        }
        var input = new File(aa.remove(0));
        if (!input.exists()) {
            System.err.println("ERROR: Input file '" + input.getAbsolutePath() + "' doesn't exist");
            this.help();
        }
        new ReplaceMP4Editor().replace(input, new CompoundMP4Edit(commands));
    };
    prototype.help = function() {
        System.out.println("Quicktime movie editor");
        System.out.println("Syntax: qtedit <command1> <options> ... <commandN> <options> <movie>");
        System.out.println("Where options:");
        for (var index$commandFactory = 0, arr$commandFactory = this.factories; index$commandFactory < arr$commandFactory.length; index$commandFactory++) {
            var commandFactory = arr$commandFactory[index$commandFactory];
            System.out.println("\t" + commandFactory.getHelp());
        }
        System.exit(-1);
    };
}, {factories: "Array", listeners: {name: "List", arguments: ["Flattern.ProgressListener"]}}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MetadataEditor = function(source, keyedMeta, itunesMeta) {
    this.source = source;
    this.keyedMeta = keyedMeta;
    this.itunesMeta = itunesMeta;
};
MetadataEditor = stjs.extend(MetadataEditor, null, [], function(constructor, prototype) {
    prototype.keyedMeta = null;
    prototype.itunesMeta = null;
    prototype.source = null;
    constructor.createFrom = function(f) {
        var format = JCodecUtil.detectFormat(f);
        if (format != Format.MOV) {
             throw new IllegalArgumentException("Unsupported format: " + format);
        }
        var movie = MP4Util.parseFullMovie(f);
        var keyedMeta = NodeBox.findFirst(movie.getMoov(), MetaBox, MetaBox.fourcc());
        var itunesMeta = NodeBox.findFirstPath(movie.getMoov(), MetaBox, ["udta", MetaBox.fourcc()]);
        return new MetadataEditor(f, keyedMeta == null ? new HashMap() : keyedMeta.getKeyedMeta(), itunesMeta == null ? new HashMap() : itunesMeta.getItunesMeta());
    };
    prototype.save = function(fast) {
        var self = this;
        var edit = new (stjs.extend(function MetadataEditor$1() {}, null, [MP4Edit], function(constructor, prototype) {
            prototype.applyToFragment = function(mov, fragmentBox) {};
            prototype.apply = function(movie) {
                var meta1 = NodeBox.findFirst(movie, MetaBox, MetaBox.fourcc());
                var meta2 = NodeBox.findFirstPath(movie, MetaBox, ["udta", MetaBox.fourcc()]);
                if (self.keyedMeta != null && self.keyedMeta.size() > 0) {
                    if (meta1 == null) {
                        meta1 = MetaBox.createMetaBox();
                        movie.add(meta1);
                    }
                    meta1.setKeyedMeta(self.keyedMeta);
                }
                if (self.itunesMeta != null && self.itunesMeta.size() > 0) {
                    if (meta2 == null) {
                        meta2 = UdtaMetaBox.createUdtaMetaBox();
                        var udta = NodeBox.findFirst(movie, NodeBox, "udta");
                        if (udta == null) {
                            udta = new NodeBox(Header.createHeader("udta", 0));
                            movie.add(udta);
                        }
                        udta.add(meta2);
                    }
                    meta2.setItunesMeta(self.itunesMeta);
                }
            };
        }, {}, {}))();
        if (fast) {
            new RelocateMP4Editor().modifyOrRelocate(this.source, edit);
        } else {
            new ReplaceMP4Editor().modifyOrReplace(this.source, edit);
        }
    };
    prototype.getItunesMeta = function() {
        return this.itunesMeta;
    };
    prototype.getKeyedMeta = function() {
        return this.keyedMeta;
    };
}, {keyedMeta: {name: "Map", arguments: [null, "MetaValue"]}, itunesMeta: {name: "Map", arguments: [null, "MetaValue"]}, source: "File"}, {});
/**
 *  This class is part of JCodec ( www.jcodec.org ) This software is distributed
 *  under FreeBSD License
 *  
 *  @author The JCodec project
 *  
 */
var MetadataEditorMain = function() {};
MetadataEditorMain = stjs.extend(MetadataEditorMain, null, [], function(constructor, prototype) {
    constructor.TYPENAME_FLOAT = "float";
    constructor.TYPENAME_INT2 = "integer";
    constructor.TYPENAME_INT = "int";
    constructor.FLAG_SET_KEYED = MainUtils.Flag.flag("set-keyed", "sk", "key1[,type1]=value1:key2[,type2]=value2[,...] Sets the metadata piece into a file.");
    constructor.FLAG_SET_ITUNES = MainUtils.Flag.flag("set-itunes", "si", "key1[,type1]=value1:key2[,type2]=value2[,...] Sets the metadata piece into a file.");
    constructor.FLAG_SET_ITUNES_BLOB = MainUtils.Flag.flag("set-itunes-blob", "sib", "key[,type]=file Sets the data read from a file into the metadata field 'key'. If file is not present stdin is read.");
    constructor.FLAG_QUERY = MainUtils.Flag.flag("query", "q", "Query the value of one key from the metadata set.");
    constructor.FLAG_FAST = new MainUtils.Flag("fast", "f", "Fast edit, will move the header to the end of the file when ther's no room to fit it.", MainUtils.FlagType.VOID);
    constructor.FLAG_DROP_KEYED = MainUtils.Flag.flag("drop-keyed", "dk", "Drop the field(s) from keyed metadata, format: key1,key2,key3,...");
    constructor.FLAG_DROP_ITUNES = MainUtils.Flag.flag("drop-itunes", "di", "Drop the field(s) from iTunes metadata, format: key1,key2,key3,...");
    constructor.flags = [MetadataEditorMain.FLAG_SET_KEYED, MetadataEditorMain.FLAG_SET_ITUNES, MetadataEditorMain.FLAG_QUERY, MetadataEditorMain.FLAG_FAST, MetadataEditorMain.FLAG_SET_ITUNES_BLOB, MetadataEditorMain.FLAG_DROP_KEYED, MetadataEditorMain.FLAG_DROP_ITUNES];
    constructor.strToType = new HashMap();
    constructor.main = function(args) {
        var cmd = MainUtils.parseArguments(args, MetadataEditorMain.flags);
        if (cmd.argsLength() < 1) {
            MainUtils.printHelpCmdVa("metaedit", MetadataEditorMain.flags, "file name");
            System.exit(-1);
            return;
        }
        var mediaMeta = MetadataEditor.createFrom(new File(cmd.getArg(0)));
        var save = false;
        var flagSetKeyed = cmd.getStringFlag(MetadataEditorMain.FLAG_SET_KEYED);
        if (flagSetKeyed != null) {
            var map = MetadataEditorMain.parseMetaSpec(flagSetKeyed);
            save |= map.size() > 0;
            mediaMeta.getKeyedMeta().putAll(map);
        }
        var flagDropKeyed = cmd.getStringFlag(MetadataEditorMain.FLAG_DROP_KEYED);
        if (flagDropKeyed != null) {
            var keys = flagDropKeyed.split(",");
            var keyedMeta = mediaMeta.getKeyedMeta();
            for (var index$key = 0, arr$key = keys; index$key < arr$key.length; index$key++) {
                var key = arr$key[index$key];
                save |= keyedMeta.remove(key) != null;
            }
        }
        var flagDropItunes = cmd.getStringFlag(MetadataEditorMain.FLAG_DROP_ITUNES);
        if (flagDropItunes != null) {
            var keys = flagDropItunes.split(",");
            var itunesMeta = mediaMeta.getItunesMeta();
            for (var index$key = 0, arr$key = keys; index$key < arr$key.length; index$key++) {
                var key = arr$key[index$key];
                var fourcc = MetadataEditorMain.stringToFourcc(key);
                save |= itunesMeta.remove(fourcc) != null;
            }
        }
        var flagSetItunes = cmd.getStringFlag(MetadataEditorMain.FLAG_SET_ITUNES);
        if (flagSetItunes != null) {
            var map = MetadataEditorMain.toFourccMeta(MetadataEditorMain.parseMetaSpec(flagSetItunes));
            save |= map.size() > 0;
            mediaMeta.getItunesMeta().putAll(map);
        }
        var flagSetItunesBlob = cmd.getStringFlag(MetadataEditorMain.FLAG_SET_ITUNES_BLOB);
        if (flagSetItunesBlob != null) {
            var lr = flagSetItunesBlob.split("=");
            var kt = lr[0].split(",");
            var key = kt[0];
            var type = 1;
            if (kt.length > 1) {
                type = MetadataEditorMain.strToType.get(kt[1]);
            }
            if (type != null) {
                var data = MetadataEditorMain.readStdin(lr.length > 1 ? lr[1] : null);
                mediaMeta.getItunesMeta().put(MetadataEditorMain.stringToFourcc(key), MetaValue.createOther(type, data));
                save = true;
            } else {
                System.err.println("Unsupported metadata type: " + kt[1]);
            }
        }
        if (save) {
            mediaMeta.save(cmd.getBooleanFlag(MetadataEditorMain.FLAG_FAST));
            mediaMeta = MetadataEditor.createFrom(new File(cmd.getArg(0)));
        }
        var keyedMeta = mediaMeta.getKeyedMeta();
        if (keyedMeta != null) {
            var flagQuery = cmd.getStringFlag(MetadataEditorMain.FLAG_QUERY);
            if (flagQuery == null) {
                System.out.println("Keyed metadata:");
                for (var iterator$entry = keyedMeta.entrySet().iterator(); iterator$entry.hasNext(); ) {
                    var entry = iterator$entry.next();
                    System.out.println(entry.getKey() + ": " + entry.getValue());
                }
            } else {
                MetadataEditorMain.printValue(keyedMeta.get(flagQuery));
            }
        }
        var itunesMeta = mediaMeta.getItunesMeta();
        if (itunesMeta != null) {
            var flagQuery = cmd.getStringFlag(MetadataEditorMain.FLAG_QUERY);
            if (flagQuery == null) {
                System.out.println("iTunes metadata:");
                for (var iterator$entry = itunesMeta.entrySet().iterator(); iterator$entry.hasNext(); ) {
                    var entry = iterator$entry.next();
                    System.out.println(MetadataEditorMain.fourccToString(entry.getKey()) + ": " + entry.getValue());
                }
            } else {
                MetadataEditorMain.printValue(itunesMeta.get(MetadataEditorMain.stringToFourcc(flagQuery)));
            }
        }
    };
    constructor.readStdin = function(fileName) {
        var fis = null;
        try {
            if (fileName != null) {
                fis = new FileInputStream(new File(fileName));
                return IOUtils.toByteArray(fis);
            } else {
                return IOUtils.toByteArray(Platform.stdin());
            }
        } finally {
            IOUtils.closeQuietly(fis);
        }
    };
    constructor.printValue = function(value) {
        if (value == null) 
            return;
        if (value.isBlob()) 
            System.out.write(value.getData());
         else 
            System.out.println(value);
    };
    constructor.toFourccMeta = function(keyed) {
        var ret = new HashMap();
        for (var iterator$entry = keyed.entrySet().iterator(); iterator$entry.hasNext(); ) {
            var entry = iterator$entry.next();
            ret.put(MetadataEditorMain.stringToFourcc(entry.getKey()), entry.getValue());
        }
        return ret;
    };
    constructor.parseMetaSpec = function(flagSetKeyed) {
        var map = new HashMap();
        for (var index$value = 0, arr$value = flagSetKeyed.split(":"); index$value < arr$value.length; index$value++) {
            var value = arr$value[index$value];
            var lr = value.split("=");
            var kt = lr[0].split(",");
            map.put(kt[0], MetadataEditorMain.typedValue(lr.length > 1 ? lr[1] : null, kt.length > 1 ? kt[1] : null));
        }
        return map;
    };
    constructor.fourccToString = function(key) {
        var bytes = new Int8Array(4);
        ByteBuffer.wrap(bytes).order(ByteOrder.BIG_ENDIAN).putInt(key);
        return Platform.stringFromCharset(bytes, Platform.ISO8859_1);
    };
    constructor.stringToFourcc = function(fourcc) {
        if (fourcc.length != 4) 
            return 0;
        var bytes = Platform.getBytesForCharset(fourcc, Platform.ISO8859_1);
        return ByteBuffer.wrap(bytes).order(ByteOrder.BIG_ENDIAN).getInt();
    };
    constructor.typedValue = function(value, type) {
        if (MetadataEditorMain.TYPENAME_INT.equalsIgnoreCase(type) || MetadataEditorMain.TYPENAME_INT2.equalsIgnoreCase(type)) 
            return MetaValue.createInt(Integer.parseInt(value));
        if (MetadataEditorMain.TYPENAME_FLOAT.equalsIgnoreCase(type)) 
            return MetaValue.createFloat(Float.parseFloat(value));
        return MetaValue.createString(value);
    };
}, {FLAG_SET_KEYED: "MainUtils.Flag", FLAG_SET_ITUNES: "MainUtils.Flag", FLAG_SET_ITUNES_BLOB: "MainUtils.Flag", FLAG_QUERY: "MainUtils.Flag", FLAG_FAST: "MainUtils.Flag", FLAG_DROP_KEYED: "MainUtils.Flag", FLAG_DROP_ITUNES: "MainUtils.Flag", flags: "Array", strToType: {name: "Map", arguments: [null, null]}}, {});
(function() {
    MetadataEditorMain.strToType.put("utf8", 1);
    MetadataEditorMain.strToType.put("utf16", 2);
    MetadataEditorMain.strToType.put(MetadataEditorMain.TYPENAME_FLOAT, 23);
    MetadataEditorMain.strToType.put(MetadataEditorMain.TYPENAME_INT, 21);
    MetadataEditorMain.strToType.put(MetadataEditorMain.TYPENAME_INT2, 21);
    MetadataEditorMain.strToType.put("jpeg", 13);
    MetadataEditorMain.strToType.put("jpg", 13);
    MetadataEditorMain.strToType.put("png", 14);
    MetadataEditorMain.strToType.put("bmp", 27);
})();
if (!stjs.mainCallDisabled) 
    MetadataEditorMain.main();
//# sourceMappingURL=jcodec.map
